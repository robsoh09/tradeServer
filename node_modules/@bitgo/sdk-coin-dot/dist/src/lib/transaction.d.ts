/// <reference types="node" />
import { BaseKey, BaseTransaction, TransactionType } from '@bitgo/sdk-core';
import { BaseCoin as CoinConfig } from '@bitgo/statics';
import { UnsignedTransaction } from '@substrate/txwrapper-core';
import { TypeRegistry } from '@substrate/txwrapper-core/lib/types';
import { KeyPair } from './keyPair';
import { TransactionExplanation, TxData } from './iface';
/**
 * Use a dummy address as the destination of a bond or bondExtra because our inputs and outputs model
 * doesn't seem to handle the concept of locking funds within a wallet as a method of transferring coins.
 */
export declare const STAKING_DESTINATION: string;
export declare class Transaction extends BaseTransaction {
    protected _dotTransaction: UnsignedTransaction;
    private _signedTransaction?;
    private _registry;
    private _chainName;
    private _sender;
    private static FAKE_SIGNATURE;
    constructor(coinConfig: Readonly<CoinConfig>);
    /** @inheritdoc */
    canSign({ key }: BaseKey): boolean;
    /**
     * Sign a polkadot transaction and update the transaction hex
     *
     * @param {KeyPair} keyPair - ed signature
     */
    sign(keyPair: KeyPair): void;
    /**
     * Adds the signature to the DOT Transaction
     * @param {string} signature
     */
    addSignature(signature: string): void;
    /**
     * Returns a serialized representation of this transaction with a fake signature attached which
     * can be used to estimate transaction fees.
     */
    fakeSign(): string;
    registry(registry: TypeRegistry): void;
    chainName(chainName: string): void;
    sender(sender: string): void;
    /** @inheritdoc */
    toBroadcastFormat(): string;
    transactionSize(): number;
    /** @inheritdoc */
    toJson(): TxData;
    explainTransferTransaction(json: TxData, explanationResult: TransactionExplanation): TransactionExplanation;
    explainStakingActivateTransaction(json: TxData, explanationResult: TransactionExplanation): TransactionExplanation;
    explainAddressInitializationTransaction(json: TxData, explanationResult: TransactionExplanation): TransactionExplanation;
    explainStakingUnlockTransaction(json: TxData, explanationResult: TransactionExplanation): TransactionExplanation;
    /** @inheritdoc */
    explainTransaction(): TransactionExplanation;
    /**
     * Load the input and output data on this transaction.
     */
    loadInputsAndOutputs(): void;
    private decodeInputsAndOutputsForSend;
    private decodeInputsAndOutputsForBatch;
    private getRemoveProxyCost;
    private getAddProxyCost;
    private getConstant;
    private decodeInputsAndOutputsForBond;
    private decodeInputsAndOutputsForUnbond;
    private decodeInputsAndOutputsForWithdrawUnbond;
    /**
     * Constructs a signed payload using construct.signTx
     * This method will be called during the build step if a TSS signature
     * is added and will set the signTransaction which is the txHex that will be broadcasted
     * As well as add the signature used to sign to the signature array in hex format
     *
     * @param {Buffer} signature The signature to be added to a dot transaction
     */
    constructSignedPayload(signature: Buffer): void;
    setTransaction(tx: UnsignedTransaction): void;
    /** @inheritdoc **/
    get signablePayload(): Buffer;
    /**
     * Set the transaction type.
     *
     * @param {TransactionType} transactionType The transaction type to be set.
     */
    transactionType(transactionType: TransactionType): void;
}
//# sourceMappingURL=transaction.d.ts.map