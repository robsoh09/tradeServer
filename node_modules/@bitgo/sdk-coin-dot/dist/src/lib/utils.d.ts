import { DotAssetTypes, BaseUtils, DotAddressFormat, Seed } from '@bitgo/sdk-core';
import { BaseCoin as CoinConfig } from '@bitgo/statics';
import { KeyringPair } from '@polkadot/keyring/types';
import { Args, BaseTxInfo, OptionsWithMeta, UnsignedTransaction } from '@substrate/txwrapper-core';
import { DecodedSignedTx, DecodedSigningPayload, TypeRegistry } from '@substrate/txwrapper-core/lib/types';
import { AddProxyBatchCallArgs, BatchArgs, BatchCallObject, HexString, Material, ProxyArgs, StakeArgs, StakeBatchCallArgs, StakeMoreArgs, StakeMoreCallArgs, TransferAllArgs, TransferArgs, TxMethod, UnstakeBatchCallArgs } from './iface';
import { KeyPair } from '.';
export declare class Utils implements BaseUtils {
    /** @inheritdoc */
    isValidAddress(address: string): boolean;
    /** @inheritdoc */
    isValidBlockId(hash: string): boolean;
    /** @inheritdoc */
    isValidPrivateKey(key: string): boolean;
    /** @inheritdoc */
    isValidPublicKey(key: string): boolean;
    /** @inheritdoc */
    isValidSignature(signature: string): boolean;
    /**
     * Verifies the signature on a given message
     *
     * @param {string} signedMessage the signed message for the signature
     * @param {string} signature the signature to verify
     * @param {string} address the address of the signer
     * @returns {boolean} whether the signature is valid or not
     */
    verifySignature(signedMessage: string, signature: string, address: string): boolean;
    /** @inheritdoc */
    isValidTransactionId(txId: string): boolean;
    /**
     * decodeSeed decodes a dot seed
     *
     * @param {string} seed - the seed to be validated.
     * @returns {Seed} - the object Seed
     */
    decodeSeed(seed: string): Seed;
    /**
     * Helper function to capitalize the first letter of a string
     *
     * @param {string} val
     * @returns {string}
     */
    capitalizeFirstLetter(val: string): string;
    /**
     * Helper function to decode the internal method hex in case of a proxy transaction
     *
     * @param {string | UnsignedTransaction} tx
     * @param { metadataRpc: string; registry: TypeRegistry } options
     * @returns {TransferArgs}
     */
    decodeCallMethod(tx: string | UnsignedTransaction, options: {
        metadataRpc: string;
        registry: TypeRegistry;
    }): TransferArgs;
    /**
     * keyPairFromSeed generates an object with secretKey and publicKey using the polkadot sdk
     * @param seed 32 bytes long seed
     * @returns KeyPair
     */
    keyPairFromSeed(seed: Uint8Array): KeyPair;
    /**
     * Signing function. Implement this on the OFFLINE signing device.
     *
     * @param {KeyringPair} pair - The signing pair.
     * @param {string} signingPayload - Payload to sign.
     * @param {UnsignedTransaction} transaction - raw transaction to sign
     * @param {Object} options
     * @param {HexString} options.metadataRpc - metadata that is needed for dot to sign
     * @param {TypeRegistry} options.registry - metadata that is needed for dot to sign
     */
    createSignedTx(pair: KeyringPair, signingPayload: string, transaction: UnsignedTransaction, options: {
        metadataRpc: HexString;
        registry: TypeRegistry;
    }): string;
    /**
     * Serializes the signed transaction
     *
     * @param transaction Transaction to serialize
     * @param signature Signature of the message
     * @param metadataRpc Network metadata
     * @param registry Transaction registry
     * @returns string Serialized transaction
     */
    serializeSignedTransaction(transaction: any, signature: any, metadataRpc: `0x${string}`, registry: any): string;
    /**
     * Decodes the dot address from the given format
     *
     * @param {string} address
     * @param {number} [ss58Format]
     * @returns {string}
     */
    decodeDotAddress(address: string, ss58Format: number): string;
    /**
     * Decodes the dot address from the given format
     *
     * @param {string} address
     * @param {number} [ss58Format]
     * @returns {string}
     */
    encodeDotAddress(address: string, ss58Format?: number): string;
    /**
     * Retrieves the txHash of a signed txHex
     *
     * @param txHex signed transaction hex
     * @returns {string}
     */
    getTxHash(txHex: string): string;
    getMaterial(coinConfig: Readonly<CoinConfig>): Material;
    isSigningPayload(payload: DecodedSigningPayload | DecodedSignedTx): payload is DecodedSigningPayload;
    isProxyTransfer(arg: TxMethod['args']): arg is ProxyArgs;
    isTransfer(arg: TxMethod['args']): arg is TransferArgs;
    isTransferAll(arg: TxMethod['args']): arg is TransferAllArgs;
    /**
     * Returns true if arg is of type BatchArgs, false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type BatchArgs, false otherwise.
     */
    isBatch(arg: TxMethod['args']): arg is BatchArgs;
    /**
     * Returns true if arg is of type BatchArgs and the calls of the batch are staking calls: a stake
     * call (bond) followed by an add proxy call (addProxy), false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type BatchArgs and the calls of the batch are staking calls: a stake
     * call (bond) followed by an add proxy call (addProxy), false otherwise.
     */
    isStakingBatch(arg: TxMethod['args']): arg is BatchArgs;
    /**
     * Returns true if arg is of type StakeBatchCallArgs, false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type StakeBatchCallArgs, false otherwise.
     */
    isStakeBatchCallArgs(arg: BatchCallObject['args']): arg is StakeBatchCallArgs;
    /**
     * Returns true if arg is of type AddProxyBatchCallArgs, false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type AddProxyBatchCallArgs, false otherwise.
     */
    isAddProxyBatchCallArgs(arg: BatchCallObject['args']): arg is AddProxyBatchCallArgs;
    /**
     * Returns true if arg is of type BatchArgs and the calls of the batch are unstaking calls: a remove
     * proxy call (removeProxy), followed by a chill call, and an unstake call (unbond), false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type BatchArgs and the calls of the batch are unstaking calls: a remove
     * proxy call (removeProxy), followed by a chill call, and an unstake call (unbond), false otherwise.
     */
    isUnstakingBatch(arg: TxMethod['args']): arg is BatchArgs;
    /**
     * Returns true if arg is of type AddProxyBatchCallArgs, false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type AddProxyBatchCallArgs, false otherwise.
     */
    isRemoveProxyBatchCallArgs(arg: BatchCallObject['args']): arg is AddProxyBatchCallArgs;
    /**
     * Returns true if arg is of type UnstakeBatchCallArgs, false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type UnstakeBatchCallArgs, false otherwise.
     */
    isUnstakeBatchCallArgs(arg: BatchCallObject['args']): arg is UnstakeBatchCallArgs;
    /**
     * Returns true if arg is of type StakeArgs, false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type StakeArgs, false otherwise.
     */
    isBond(arg: TxMethod['args']): arg is StakeArgs;
    /**
     * Returns true if arg is of type StakeMoreArgs, false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type StakeMoreArgs, false otherwise.
     */
    isBondExtra(arg: TxMethod['args'] | BatchCallObject['args']): arg is StakeMoreArgs;
    /**
     * Returns true if arg is of type StakeMoreArgs, false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type StakeMoreArgs, false otherwise.
     */
    isBondBatchExtra(arg: BatchCallObject['args']): arg is StakeMoreCallArgs;
    /**
     * extracts and returns the signature in hex format given a raw signed transaction
     *
     * @param {string} rawTx signed raw transaction
     * @param options registry dot registry used to retrieve the signature
     */
    recoverSignatureFromRawTx(rawTx: string, options: {
        registry: TypeRegistry;
    }): string;
    /**
     * Decodes the dot address from the given format
     *
     * @param {string} address
     * @param {number} [ss58Format]
     * @returns {KeyPair}
     */
    decodeDotAddressToKeyPair(address: string, ss58Format?: number): KeyPair;
    /**
     * Checks whether the given input is a hex string with with 0 value
     * used to check whether a given transaction is immortal or mortal
     * @param hexValue
     */
    isZeroHex(hexValue: string): boolean;
    /**
     * Takes an asset name and returns the respective address to format to
     * since polkadot addresses differ depending on the network
     * ref: https://wiki.polkadot.network/docs/learn-accounts
     * @param networkCoinName
     */
    getAddressFormat(networkCoinName: DotAssetTypes): DotAddressFormat;
    /**
     * Creates a pure proxy extrinsic. Polkadot has renamed anonymous proxies to pure proxies, but
     * the libraries we are using to build transactions have not been updated, as a stop gap we are
     * defining the pure proxy extrinsic here.
     *
     * @param args Arguments to the createPure extrinsic.
     * @param info Common information to all transactions.
     * @param options Chain registry and metadata.
     */
    pureProxy(args: PureProxyArgs, info: BaseTxInfo, options: OptionsWithMeta): UnsignedTransaction;
    /**
     * Removes '0x' from a given `string` if present.
     *
     * @param {string} str the string value.
     *
     * @return {string} a string without a '0x' prefix.
     */
    stripHexPrefix(str: string): string;
    /**
     * Returns true if a string starts with '0x', false otherwise.
     *
     * @param {string} str the string value.
     *
     * @return {boolean} true if a string starts with '0x', false otherwise.
     */
    isHexPrefixed(str: string): boolean;
}
interface PureProxyArgs extends Args {
    proxyType: string;
    delay: number;
    index: number;
}
declare const utils: Utils;
export default utils;
//# sourceMappingURL=utils.d.ts.map