"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const keyring_1 = require("@polkadot/keyring");
const decode_1 = require("@polkadot/keyring/pair/decode");
const types_1 = require("@polkadot/types");
const Extrinsic_1 = require("@polkadot/types/extrinsic/v4/Extrinsic");
const util_1 = require("@polkadot/util");
const util_crypto_1 = require("@polkadot/util-crypto");
const txwrapper_core_1 = require("@substrate/txwrapper-core");
const txwrapper_polkadot_1 = require("@substrate/txwrapper-polkadot");
const bs58_1 = __importDefault(require("bs58"));
const hi_base32_1 = __importDefault(require("hi-base32"));
const _ = __importStar(require("lodash"));
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const _1 = require(".");
const resources_1 = require("../resources");
const PROXY_METHOD_ARG = 2;
// map to retrieve the address encoding format when the key is the asset name
const coinToAddressMap = new Map([
    ['dot', sdk_core_1.DotAddressFormat.polkadot],
    ['tdot', sdk_core_1.DotAddressFormat.substrate],
]);
class Utils {
    /** @inheritdoc */
    isValidAddress(address) {
        try {
            (0, keyring_1.encodeAddress)((0, util_1.isHex)(address) ? (0, util_1.hexToU8a)(address) : (0, keyring_1.decodeAddress)(address));
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /** @inheritdoc */
    isValidBlockId(hash) {
        return (0, util_1.isHex)(hash, 256);
    }
    /** @inheritdoc */
    isValidPrivateKey(key) {
        try {
            const decodedPrv = (0, util_1.hexToU8a)(key);
            return decodedPrv.length === tweetnacl_1.default.sign.secretKeyLength / 2;
        }
        catch (e) {
            return false;
        }
    }
    /** @inheritdoc */
    isValidPublicKey(key) {
        let pubKey = key;
        // convert base58 pub key to hex format
        // tss common pub is in base58 format and decodes to length of 32
        if ((0, sdk_core_1.isBase58)(pubKey, 32)) {
            const base58Decode = bs58_1.default.decode(pubKey);
            pubKey = base58Decode.toString('hex');
        }
        return (0, sdk_core_1.isValidEd25519PublicKey)(pubKey);
    }
    /** @inheritdoc */
    isValidSignature(signature) {
        const signatureU8a = (0, util_1.u8aToU8a)(signature);
        return [64, 65, 66].includes(signatureU8a.length);
    }
    /**
     * Verifies the signature on a given message
     *
     * @param {string} signedMessage the signed message for the signature
     * @param {string} signature the signature to verify
     * @param {string} address the address of the signer
     * @returns {boolean} whether the signature is valid or not
     */
    verifySignature(signedMessage, signature, address) {
        const publicKey = (0, keyring_1.decodeAddress)(address);
        const hexPublicKey = (0, util_1.u8aToHex)(publicKey);
        return (0, util_crypto_1.signatureVerify)(signedMessage, signature, hexPublicKey).isValid;
    }
    /** @inheritdoc */
    isValidTransactionId(txId) {
        return (0, util_1.isHex)(txId, 256);
    }
    /**
     * decodeSeed decodes a dot seed
     *
     * @param {string} seed - the seed to be validated.
     * @returns {Seed} - the object Seed
     */
    decodeSeed(seed) {
        const decoded = hi_base32_1.default.decode.asBytes(seed);
        return {
            seed: Buffer.from(decoded),
        };
    }
    /**
     * Helper function to capitalize the first letter of a string
     *
     * @param {string} val
     * @returns {string}
     */
    capitalizeFirstLetter(val) {
        return val.charAt(0).toUpperCase() + val.slice(1);
    }
    /**
     * Helper function to decode the internal method hex in case of a proxy transaction
     *
     * @param {string | UnsignedTransaction} tx
     * @param { metadataRpc: string; registry: TypeRegistry } options
     * @returns {TransferArgs}
     */
    decodeCallMethod(tx, options) {
        const { registry } = options;
        let methodCall;
        if (typeof tx === 'string') {
            try {
                const payload = (0, types_1.createTypeUnsafe)(registry, 'ExtrinsicPayload', [
                    tx,
                    { version: Extrinsic_1.EXTRINSIC_VERSION },
                ]);
                methodCall = (0, types_1.createTypeUnsafe)(registry, 'Call', [payload.method]);
            }
            catch (e) {
                methodCall = registry.createType('Extrinsic', (0, util_1.hexToU8a)(tx), {
                    isSigned: true,
                });
            }
        }
        else {
            methodCall = registry.createType('Call', tx.method);
        }
        const method = methodCall.args[PROXY_METHOD_ARG];
        const decodedArgs = method.toJSON();
        return decodedArgs.args;
    }
    /**
     * keyPairFromSeed generates an object with secretKey and publicKey using the polkadot sdk
     * @param seed 32 bytes long seed
     * @returns KeyPair
     */
    keyPairFromSeed(seed) {
        const keyring = new keyring_1.Keyring({ type: 'ed25519' });
        const keyringPair = keyring.addFromSeed(seed);
        const pairJson = keyringPair.toJson();
        const decodedKeyPair = (0, decode_1.decodePair)('', (0, util_crypto_1.base64Decode)(pairJson.encoded), pairJson.encoding.type);
        return new _1.KeyPair({ prv: Buffer.from(decodedKeyPair.secretKey).toString('hex') });
    }
    /**
     * Signing function. Implement this on the OFFLINE signing device.
     *
     * @param {KeyringPair} pair - The signing pair.
     * @param {string} signingPayload - Payload to sign.
     * @param {UnsignedTransaction} transaction - raw transaction to sign
     * @param {Object} options
     * @param {HexString} options.metadataRpc - metadata that is needed for dot to sign
     * @param {TypeRegistry} options.registry - metadata that is needed for dot to sign
     */
    createSignedTx(pair, signingPayload, transaction, options) {
        const { registry, metadataRpc } = options;
        const { signature } = registry
            .createType('ExtrinsicPayload', signingPayload, {
            version: Extrinsic_1.EXTRINSIC_VERSION,
        })
            .sign(pair);
        // Serialize a signed transaction.
        return this.serializeSignedTransaction(transaction, signature, metadataRpc, registry);
    }
    /**
     * Serializes the signed transaction
     *
     * @param transaction Transaction to serialize
     * @param signature Signature of the message
     * @param metadataRpc Network metadata
     * @param registry Transaction registry
     * @returns string Serialized transaction
     */
    serializeSignedTransaction(transaction, signature, metadataRpc, registry) {
        return txwrapper_polkadot_1.construct.signedTx(transaction, signature, {
            metadataRpc,
            registry,
        });
    }
    /**
     * Decodes the dot address from the given format
     *
     * @param {string} address
     * @param {number} [ss58Format]
     * @returns {string}
     */
    decodeDotAddress(address, ss58Format) {
        const keypair = new _1.KeyPair({ pub: Buffer.from((0, keyring_1.decodeAddress)(address, undefined, ss58Format)).toString('hex') });
        return keypair.getAddress(ss58Format);
    }
    /**
     * Decodes the dot address from the given format
     *
     * @param {string} address
     * @param {number} [ss58Format]
     * @returns {string}
     */
    encodeDotAddress(address, ss58Format) {
        return (0, keyring_1.encodeAddress)(address, ss58Format);
    }
    /**
     * Retrieves the txHash of a signed txHex
     *
     * @param txHex signed transaction hex
     * @returns {string}
     */
    getTxHash(txHex) {
        return txwrapper_polkadot_1.construct.txHash(txHex);
    }
    getMaterial(coinConfig) {
        const networkConfig = coinConfig.network;
        const { specName, specVersion, chainName, txVersion, genesisHash } = networkConfig;
        const metadataRpc = networkConfig.specName === 'westend' ? resources_1.westendMetadataRpc : resources_1.mainnetMetadataRpc;
        return {
            specName,
            specVersion,
            chainName,
            metadata: metadataRpc,
            txVersion,
            genesisHash,
        };
    }
    isSigningPayload(payload) {
        return payload.blockHash !== undefined;
    }
    isProxyTransfer(arg) {
        return arg.real !== undefined;
    }
    isTransfer(arg) {
        var _a;
        return ((_a = arg.dest) === null || _a === void 0 ? void 0 : _a.id) !== undefined && arg.value !== undefined;
    }
    isTransferAll(arg) {
        var _a;
        return ((_a = arg.dest) === null || _a === void 0 ? void 0 : _a.id) !== undefined && arg.keepAlive !== undefined;
    }
    /**
     * Returns true if arg is of type BatchArgs, false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type BatchArgs, false otherwise.
     */
    isBatch(arg) {
        return arg.calls !== undefined;
    }
    /**
     * Returns true if arg is of type BatchArgs and the calls of the batch are staking calls: a stake
     * call (bond) followed by an add proxy call (addProxy), false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type BatchArgs and the calls of the batch are staking calls: a stake
     * call (bond) followed by an add proxy call (addProxy), false otherwise.
     */
    isStakingBatch(arg) {
        const calls = arg.calls;
        if (calls !== undefined) {
            return (calls.length === 2 &&
                (this.isStakeBatchCallArgs(calls[0].args) || this.isBondBatchExtra(calls[0].args)) &&
                this.isAddProxyBatchCallArgs(calls[1].args));
        }
        return false;
    }
    /**
     * Returns true if arg is of type StakeBatchCallArgs, false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type StakeBatchCallArgs, false otherwise.
     */
    isStakeBatchCallArgs(arg) {
        return arg.value !== undefined && arg.payee !== undefined;
    }
    /**
     * Returns true if arg is of type AddProxyBatchCallArgs, false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type AddProxyBatchCallArgs, false otherwise.
     */
    isAddProxyBatchCallArgs(arg) {
        return (arg.delegate !== undefined &&
            arg.proxy_type !== undefined &&
            arg.delay !== undefined);
    }
    /**
     * Returns true if arg is of type BatchArgs and the calls of the batch are unstaking calls: a remove
     * proxy call (removeProxy), followed by a chill call, and an unstake call (unbond), false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type BatchArgs and the calls of the batch are unstaking calls: a remove
     * proxy call (removeProxy), followed by a chill call, and an unstake call (unbond), false otherwise.
     */
    isUnstakingBatch(arg) {
        const calls = arg.calls;
        if (calls !== undefined) {
            return (calls.length === 3 &&
                this.isRemoveProxyBatchCallArgs(calls[0].args) &&
                _.isEmpty(calls[1].args) &&
                this.isUnstakeBatchCallArgs(calls[2].args));
        }
        return false;
    }
    /**
     * Returns true if arg is of type AddProxyBatchCallArgs, false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type AddProxyBatchCallArgs, false otherwise.
     */
    isRemoveProxyBatchCallArgs(arg) {
        return (arg.delegate !== undefined &&
            arg.proxy_type !== undefined &&
            arg.delay !== undefined);
    }
    /**
     * Returns true if arg is of type UnstakeBatchCallArgs, false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type UnstakeBatchCallArgs, false otherwise.
     */
    isUnstakeBatchCallArgs(arg) {
        return arg.value !== undefined;
    }
    /**
     * Returns true if arg is of type StakeArgs, false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type StakeArgs, false otherwise.
     */
    isBond(arg) {
        return arg.value !== undefined && arg.payee !== undefined;
    }
    /**
     * Returns true if arg is of type StakeMoreArgs, false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type StakeMoreArgs, false otherwise.
     */
    isBondExtra(arg) {
        return arg.maxAdditional !== undefined;
    }
    /**
     * Returns true if arg is of type StakeMoreArgs, false otherwise.
     *
     * @param arg The object to test.
     *
     * @return true if arg is of type StakeMoreArgs, false otherwise.
     */
    isBondBatchExtra(arg) {
        return arg.max_additional !== undefined;
    }
    /**
     * extracts and returns the signature in hex format given a raw signed transaction
     *
     * @param {string} rawTx signed raw transaction
     * @param options registry dot registry used to retrieve the signature
     */
    recoverSignatureFromRawTx(rawTx, options) {
        const { registry } = options;
        const methodCall = registry.createType('Extrinsic', rawTx, {
            isSigned: true,
        });
        let signature = (0, util_1.u8aToHex)(methodCall.signature);
        // remove 0x from the signature since this is how it's returned from TSS signing
        if (signature.startsWith('0x')) {
            signature = signature.substr(2);
        }
        return signature;
    }
    /**
     * Decodes the dot address from the given format
     *
     * @param {string} address
     * @param {number} [ss58Format]
     * @returns {KeyPair}
     */
    decodeDotAddressToKeyPair(address, ss58Format) {
        return new _1.KeyPair({ pub: Buffer.from((0, keyring_1.decodeAddress)(address, undefined, ss58Format)).toString('hex') });
    }
    /**
     * Checks whether the given input is a hex string with with 0 value
     * used to check whether a given transaction is immortal or mortal
     * @param hexValue
     */
    isZeroHex(hexValue) {
        return hexValue === '0x00';
    }
    /**
     * Takes an asset name and returns the respective address to format to
     * since polkadot addresses differ depending on the network
     * ref: https://wiki.polkadot.network/docs/learn-accounts
     * @param networkCoinName
     */
    getAddressFormat(networkCoinName) {
        return coinToAddressMap.get(networkCoinName);
    }
    /**
     * Creates a pure proxy extrinsic. Polkadot has renamed anonymous proxies to pure proxies, but
     * the libraries we are using to build transactions have not been updated, as a stop gap we are
     * defining the pure proxy extrinsic here.
     *
     * @param args Arguments to the createPure extrinsic.
     * @param info Common information to all transactions.
     * @param options Chain registry and metadata.
     */
    pureProxy(args, info, options) {
        return (0, txwrapper_core_1.defineMethod)({
            method: {
                args,
                name: 'createPure',
                pallet: 'proxy',
            },
            ...info,
        }, options);
    }
    /**
     * Removes '0x' from a given `string` if present.
     *
     * @param {string} str the string value.
     *
     * @return {string} a string without a '0x' prefix.
     */
    stripHexPrefix(str) {
        return this.isHexPrefixed(str) ? str.slice(2) : str;
    }
    /**
     * Returns true if a string starts with '0x', false otherwise.
     *
     * @param {string} str the string value.
     *
     * @return {boolean} true if a string starts with '0x', false otherwise.
     */
    isHexPrefixed(str) {
        return str.slice(0, 2) === '0x';
    }
}
exports.Utils = Utils;
const utils = new Utils();
exports.default = utils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsOENBQXNIO0FBRXRILCtDQUEwRTtBQUMxRSwwREFBMkQ7QUFFM0QsMkNBQTJHO0FBQzNHLHNFQUEyRTtBQUMzRSx5Q0FBcUU7QUFDckUsdURBQXNFO0FBQ3RFLDhEQUFpSDtBQUVqSCxzRUFBMEQ7QUFDMUQsZ0RBQXdCO0FBQ3hCLDBEQUErQjtBQUMvQiwwQ0FBNEI7QUFDNUIsMERBQTZCO0FBa0I3Qix3QkFBNEI7QUFDNUIsNENBQXNFO0FBRXRFLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDO0FBQzNCLDZFQUE2RTtBQUM3RSxNQUFNLGdCQUFnQixHQUFHLElBQUksR0FBRyxDQUFrQztJQUNoRSxDQUFDLEtBQUssRUFBRSwyQkFBZ0IsQ0FBQyxRQUFRLENBQUM7SUFDbEMsQ0FBQyxNQUFNLEVBQUUsMkJBQWdCLENBQUMsU0FBUyxDQUFDO0NBQ3JDLENBQUMsQ0FBQztBQUVILE1BQWEsS0FBSztJQUNoQixrQkFBa0I7SUFDbEIsY0FBYyxDQUFDLE9BQWU7UUFDNUIsSUFBSTtZQUNGLElBQUEsdUJBQWEsRUFBQyxJQUFBLFlBQUssRUFBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBQSxlQUFRLEVBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUEsdUJBQWEsRUFBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQzNFLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFBQyxPQUFPLEtBQUssRUFBRTtZQUNkLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7SUFDSCxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLGNBQWMsQ0FBQyxJQUFZO1FBQ3pCLE9BQU8sSUFBQSxZQUFLLEVBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRCxr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Q0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILGFBQWEsQ0FBQyxHQUFXO1FBQ3ZCLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDO0lBQ2xDLENBQUM7Q0FDRjtBQTNkRCxzQkEyZEM7QUFRRCxNQUFNLEtBQUssR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO0FBRTFCLGtCQUFlLEtBQUssQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERvdEFzc2V0VHlwZXMsIEJhc2VVdGlscywgRG90QWRkcmVzc0Zvcm1hdCwgaXNCYXNlNTgsIGlzVmFsaWRFZDI1NTE5UHVibGljS2V5LCBTZWVkIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcsIERvdE5ldHdvcmsgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBkZWNvZGVBZGRyZXNzLCBlbmNvZGVBZGRyZXNzLCBLZXlyaW5nIH0gZnJvbSAnQHBvbGthZG90L2tleXJpbmcnO1xuaW1wb3J0IHsgZGVjb2RlUGFpciB9IGZyb20gJ0Bwb2xrYWRvdC9rZXlyaW5nL3BhaXIvZGVjb2RlJztcbmltcG9ydCB7IEtleXJpbmdQYWlyIH0gZnJvbSAnQHBvbGthZG90L2tleXJpbmcvdHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlVHlwZVVuc2FmZSwgR2VuZXJpY0NhbGwsIEdlbmVyaWNFeHRyaW5zaWMsIEdlbmVyaWNFeHRyaW5zaWNQYXlsb2FkIH0gZnJvbSAnQHBvbGthZG90L3R5cGVzJztcbmltcG9ydCB7IEVYVFJJTlNJQ19WRVJTSU9OIH0gZnJvbSAnQHBvbGthZG90L3R5cGVzL2V4dHJpbnNpYy92NC9FeHRyaW5zaWMnO1xuaW1wb3J0IHsgaGV4VG9VOGEsIGlzSGV4LCB1OGFUb0hleCwgdThhVG9VOGEgfSBmcm9tICdAcG9sa2Fkb3QvdXRpbCc7XG5pbXBvcnQgeyBiYXNlNjREZWNvZGUsIHNpZ25hdHVyZVZlcmlmeSB9IGZyb20gJ0Bwb2xrYWRvdC91dGlsLWNyeXB0byc7XG5pbXBvcnQgeyBBcmdzLCBCYXNlVHhJbmZvLCBkZWZpbmVNZXRob2QsIE9wdGlvbnNXaXRoTWV0YSwgVW5zaWduZWRUcmFuc2FjdGlvbiB9IGZyb20gJ0BzdWJzdHJhdGUvdHh3cmFwcGVyLWNvcmUnO1xuaW1wb3J0IHsgRGVjb2RlZFNpZ25lZFR4LCBEZWNvZGVkU2lnbmluZ1BheWxvYWQsIFR5cGVSZWdpc3RyeSB9IGZyb20gJ0BzdWJzdHJhdGUvdHh3cmFwcGVyLWNvcmUvbGliL3R5cGVzJztcbmltcG9ydCB7IGNvbnN0cnVjdCB9IGZyb20gJ0BzdWJzdHJhdGUvdHh3cmFwcGVyLXBvbGthZG90JztcbmltcG9ydCBiczU4IGZyb20gJ2JzNTgnO1xuaW1wb3J0IGJhc2UzMiBmcm9tICdoaS1iYXNlMzInO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IG5hY2wgZnJvbSAndHdlZXRuYWNsJztcbmltcG9ydCB7XG4gIEFkZFByb3h5QmF0Y2hDYWxsQXJncyxcbiAgQmF0Y2hBcmdzLFxuICBCYXRjaENhbGxPYmplY3QsXG4gIEhleFN0cmluZyxcbiAgTWF0ZXJpYWwsXG4gIFByb3h5QXJncyxcbiAgUHJveHlDYWxsQXJncyxcbiAgU3Rha2VBcmdzLFxuICBTdGFrZUJhdGNoQ2FsbEFyZ3MsXG4gIFN0YWtlTW9yZUFyZ3MsXG4gIFN0YWtlTW9yZUNhbGxBcmdzLFxuICBUcmFuc2ZlckFsbEFyZ3MsXG4gIFRyYW5zZmVyQXJncyxcbiAgVHhNZXRob2QsXG4gIFVuc3Rha2VCYXRjaENhbGxBcmdzLFxufSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IEtleVBhaXIgfSBmcm9tICcuJztcbmltcG9ydCB7IG1haW5uZXRNZXRhZGF0YVJwYywgd2VzdGVuZE1ldGFkYXRhUnBjIH0gZnJvbSAnLi4vcmVzb3VyY2VzJztcblxuY29uc3QgUFJPWFlfTUVUSE9EX0FSRyA9IDI7XG4vLyBtYXAgdG8gcmV0cmlldmUgdGhlIGFkZHJlc3MgZW5jb2RpbmcgZm9ybWF0IHdoZW4gdGhlIGtleSBpcyB0aGUgYXNzZXQgbmFtZVxuY29uc3QgY29pblRvQWRkcmVzc01hcCA9IG5ldyBNYXA8RG90QXNzZXRUeXBlcywgRG90QWRkcmVzc0Zvcm1hdD4oW1xuICBbJ2RvdCcsIERvdEFkZHJlc3NGb3JtYXQucG9sa2Fkb3RdLFxuICBbJ3Rkb3QnLCBEb3RBZGRyZXNzRm9ybWF0LnN1YnN0cmF0ZV0sXG5dKTtcblxuZXhwb3J0IGNsYXNzIFV0aWxzIGltcGxlbWVudHMgQmFzZVV0aWxzIHtcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBlbmNvZGVBZGRyZXNzKGlzSGV4KGFkZHJlc3MpID8gaGV4VG9VOGEoYWRkcmVzcykgOiBkZWNvZGVBZGRyZXNzKGFkZHJlc3MpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRCbG9ja0lkKGhhc2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc0hleChoYXNoLCAyNTYpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRQcml2YXRlS2V5KGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRlY29kZWRQcnYgPSBoZXhUb1U4YShrZXkpO1xuICAgICAgcmV0dXJuIGRlY29kZWRQcnYubGVuZ3RoID09PSBuYWNsLnNpZ24uc2VjcmV0S2V5TGVuZ3RoIC8gMjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRQdWJsaWNLZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBsZXQgcHViS2V5ID0ga2V5O1xuXG4gICAgLy8gY29udmVydCBiYXNlNTggcHViIGtleSB0byBoZXggZm9ybWF0XG4gICAgLy8gdHNzIGNvbW1vbiBwdWIgaXMgaW4gYmFzZTU4IGZvcm1hdCBhbmQgZGVjb2RlcyB0byBsZW5ndGggb2YgMzJcbiAgICBpZiAoaXNCYXNlNTgocHViS2V5LCAzMikpIHtcbiAgICAgIGNvbnN0IGJhc2U1OERlY29kZSA9IGJzNTguZGVjb2RlKHB1YktleSk7XG4gICAgICBwdWJLZXkgPSBiYXNlNThEZWNvZGUudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cblxuICAgIHJldHVybiBpc1ZhbGlkRWQyNTUxOVB1YmxpY0tleShwdWJLZXkpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRTaWduYXR1cmUoc2lnbmF0dXJlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBzaWduYXR1cmVVOGEgPSB1OGFUb1U4YShzaWduYXR1cmUpO1xuICAgIHJldHVybiBbNjQsIDY1LCA2Nl0uaW5jbHVkZXMoc2lnbmF0dXJlVThhLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpZXMgdGhlIHNpZ25hdHVyZSBvbiBhIGdpdmVuIG1lc3NhZ2VcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25lZE1lc3NhZ2UgdGhlIHNpZ25lZCBtZXNzYWdlIGZvciB0aGUgc2lnbmF0dXJlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaWduYXR1cmUgdGhlIHNpZ25hdHVyZSB0byB2ZXJpZnlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgdGhlIGFkZHJlc3Mgb2YgdGhlIHNpZ25lclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkIG9yIG5vdFxuICAgKi9cbiAgdmVyaWZ5U2lnbmF0dXJlKHNpZ25lZE1lc3NhZ2U6IHN0cmluZywgc2lnbmF0dXJlOiBzdHJpbmcsIGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGRlY29kZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgY29uc3QgaGV4UHVibGljS2V5ID0gdThhVG9IZXgocHVibGljS2V5KTtcblxuICAgIHJldHVybiBzaWduYXR1cmVWZXJpZnkoc2lnbmVkTWVzc2FnZSwgc2lnbmF0dXJlLCBoZXhQdWJsaWNLZXkpLmlzVmFsaWQ7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZFRyYW5zYWN0aW9uSWQodHhJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzSGV4KHR4SWQsIDI1Nik7XG4gIH1cblxuICAvKipcbiAgICogZGVjb2RlU2VlZCBkZWNvZGVzIGEgZG90IHNlZWRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlZWQgLSB0aGUgc2VlZCB0byBiZSB2YWxpZGF0ZWQuXG4gICAqIEByZXR1cm5zIHtTZWVkfSAtIHRoZSBvYmplY3QgU2VlZFxuICAgKi9cbiAgZGVjb2RlU2VlZChzZWVkOiBzdHJpbmcpOiBTZWVkIHtcbiAgICBjb25zdCBkZWNvZGVkID0gYmFzZTMyLmRlY29kZS5hc0J5dGVzKHNlZWQpO1xuICAgIHJldHVybiB7XG4gICAgICBzZWVkOiBCdWZmZXIuZnJvbShkZWNvZGVkKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBjYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmdcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHZhbDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdmFsLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdmFsLnNsaWNlKDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBkZWNvZGUgdGhlIGludGVybmFsIG1ldGhvZCBoZXggaW4gY2FzZSBvZiBhIHByb3h5IHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVW5zaWduZWRUcmFuc2FjdGlvbn0gdHhcbiAgICogQHBhcmFtIHsgbWV0YWRhdGFScGM6IHN0cmluZzsgcmVnaXN0cnk6IFR5cGVSZWdpc3RyeSB9IG9wdGlvbnNcbiAgICogQHJldHVybnMge1RyYW5zZmVyQXJnc31cbiAgICovXG4gIGRlY29kZUNhbGxNZXRob2QoXG4gICAgdHg6IHN0cmluZyB8IFVuc2lnbmVkVHJhbnNhY3Rpb24sXG4gICAgb3B0aW9uczogeyBtZXRhZGF0YVJwYzogc3RyaW5nOyByZWdpc3RyeTogVHlwZVJlZ2lzdHJ5IH1cbiAgKTogVHJhbnNmZXJBcmdzIHtcbiAgICBjb25zdCB7IHJlZ2lzdHJ5IH0gPSBvcHRpb25zO1xuICAgIGxldCBtZXRob2RDYWxsOiBHZW5lcmljQ2FsbCB8IEdlbmVyaWNFeHRyaW5zaWM7XG4gICAgaWYgKHR5cGVvZiB0eCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQ6IEdlbmVyaWNFeHRyaW5zaWNQYXlsb2FkID0gY3JlYXRlVHlwZVVuc2FmZShyZWdpc3RyeSwgJ0V4dHJpbnNpY1BheWxvYWQnLCBbXG4gICAgICAgICAgdHgsXG4gICAgICAgICAgeyB2ZXJzaW9uOiBFWFRSSU5TSUNfVkVSU0lPTiB9LFxuICAgICAgICBdKTtcbiAgICAgICAgbWV0aG9kQ2FsbCA9IGNyZWF0ZVR5cGVVbnNhZmUocmVnaXN0cnksICdDYWxsJywgW3BheWxvYWQubWV0aG9kXSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIG1ldGhvZENhbGwgPSByZWdpc3RyeS5jcmVhdGVUeXBlKCdFeHRyaW5zaWMnLCBoZXhUb1U4YSh0eCksIHtcbiAgICAgICAgICBpc1NpZ25lZDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1ldGhvZENhbGwgPSByZWdpc3RyeS5jcmVhdGVUeXBlKCdDYWxsJywgdHgubWV0aG9kKTtcbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gbWV0aG9kQ2FsbC5hcmdzW1BST1hZX01FVEhPRF9BUkddO1xuICAgIGNvbnN0IGRlY29kZWRBcmdzID0gbWV0aG9kLnRvSlNPTigpIGFzIHVua25vd24gYXMgUHJveHlDYWxsQXJncztcbiAgICByZXR1cm4gZGVjb2RlZEFyZ3MuYXJncztcbiAgfVxuXG4gIC8qKlxuICAgKiBrZXlQYWlyRnJvbVNlZWQgZ2VuZXJhdGVzIGFuIG9iamVjdCB3aXRoIHNlY3JldEtleSBhbmQgcHVibGljS2V5IHVzaW5nIHRoZSBwb2xrYWRvdCBzZGtcbiAgICogQHBhcmFtIHNlZWQgMzIgYnl0ZXMgbG9uZyBzZWVkXG4gICAqIEByZXR1cm5zIEtleVBhaXJcbiAgICovXG4gIGtleVBhaXJGcm9tU2VlZChzZWVkOiBVaW50OEFycmF5KTogS2V5UGFpciB7XG4gICAgY29uc3Qga2V5cmluZyA9IG5ldyBLZXlyaW5nKHsgdHlwZTogJ2VkMjU1MTknIH0pO1xuICAgIGNvbnN0IGtleXJpbmdQYWlyID0ga2V5cmluZy5hZGRGcm9tU2VlZChzZWVkKTtcbiAgICBjb25zdCBwYWlySnNvbiA9IGtleXJpbmdQYWlyLnRvSnNvbigpO1xuICAgIGNvbnN0IGRlY29kZWRLZXlQYWlyID0gZGVjb2RlUGFpcignJywgYmFzZTY0RGVjb2RlKHBhaXJKc29uLmVuY29kZWQpLCBwYWlySnNvbi5lbmNvZGluZy50eXBlKTtcbiAgICByZXR1cm4gbmV3IEtleVBhaXIoeyBwcnY6IEJ1ZmZlci5mcm9tKGRlY29kZWRLZXlQYWlyLnNlY3JldEtleSkudG9TdHJpbmcoJ2hleCcpIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25pbmcgZnVuY3Rpb24uIEltcGxlbWVudCB0aGlzIG9uIHRoZSBPRkZMSU5FIHNpZ25pbmcgZGV2aWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0tleXJpbmdQYWlyfSBwYWlyIC0gVGhlIHNpZ25pbmcgcGFpci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25pbmdQYXlsb2FkIC0gUGF5bG9hZCB0byBzaWduLlxuICAgKiBAcGFyYW0ge1Vuc2lnbmVkVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIC0gcmF3IHRyYW5zYWN0aW9uIHRvIHNpZ25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtIZXhTdHJpbmd9IG9wdGlvbnMubWV0YWRhdGFScGMgLSBtZXRhZGF0YSB0aGF0IGlzIG5lZWRlZCBmb3IgZG90IHRvIHNpZ25cbiAgICogQHBhcmFtIHtUeXBlUmVnaXN0cnl9IG9wdGlvbnMucmVnaXN0cnkgLSBtZXRhZGF0YSB0aGF0IGlzIG5lZWRlZCBmb3IgZG90IHRvIHNpZ25cbiAgICovXG4gIGNyZWF0ZVNpZ25lZFR4KFxuICAgIHBhaXI6IEtleXJpbmdQYWlyLFxuICAgIHNpZ25pbmdQYXlsb2FkOiBzdHJpbmcsXG4gICAgdHJhbnNhY3Rpb246IFVuc2lnbmVkVHJhbnNhY3Rpb24sXG4gICAgb3B0aW9uczogeyBtZXRhZGF0YVJwYzogSGV4U3RyaW5nOyByZWdpc3RyeTogVHlwZVJlZ2lzdHJ5IH1cbiAgKTogc3RyaW5nIHtcbiAgICBjb25zdCB7IHJlZ2lzdHJ5LCBtZXRhZGF0YVJwYyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IHNpZ25hdHVyZSB9ID0gcmVnaXN0cnlcbiAgICAgIC5jcmVhdGVUeXBlKCdFeHRyaW5zaWNQYXlsb2FkJywgc2lnbmluZ1BheWxvYWQsIHtcbiAgICAgICAgdmVyc2lvbjogRVhUUklOU0lDX1ZFUlNJT04sXG4gICAgICB9KVxuICAgICAgLnNpZ24ocGFpcik7XG5cbiAgICAvLyBTZXJpYWxpemUgYSBzaWduZWQgdHJhbnNhY3Rpb24uXG4gICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplU2lnbmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgbWV0YWRhdGFScGMsIHJlZ2lzdHJ5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBzaWduZWQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIHRvIHNlcmlhbGl6ZVxuICAgKiBAcGFyYW0gc2lnbmF0dXJlIFNpZ25hdHVyZSBvZiB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0gbWV0YWRhdGFScGMgTmV0d29yayBtZXRhZGF0YVxuICAgKiBAcGFyYW0gcmVnaXN0cnkgVHJhbnNhY3Rpb24gcmVnaXN0cnlcbiAgICogQHJldHVybnMgc3RyaW5nIFNlcmlhbGl6ZWQgdHJhbnNhY3Rpb25cbiAgICovXG4gIHNlcmlhbGl6ZVNpZ25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUsIG1ldGFkYXRhUnBjOiBgMHgke3N0cmluZ31gLCByZWdpc3RyeSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdC5zaWduZWRUeCh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlLCB7XG4gICAgICBtZXRhZGF0YVJwYyxcbiAgICAgIHJlZ2lzdHJ5LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZXMgdGhlIGRvdCBhZGRyZXNzIGZyb20gdGhlIGdpdmVuIGZvcm1hdFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3NzNThGb3JtYXRdXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBkZWNvZGVEb3RBZGRyZXNzKGFkZHJlc3M6IHN0cmluZywgc3M1OEZvcm1hdDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBjb25zdCBrZXlwYWlyID0gbmV3IEtleVBhaXIoeyBwdWI6IEJ1ZmZlci5mcm9tKGRlY29kZUFkZHJlc3MoYWRkcmVzcywgdW5kZWZpbmVkLCBzczU4Rm9ybWF0KSkudG9TdHJpbmcoJ2hleCcpIH0pO1xuICAgIHJldHVybiBrZXlwYWlyLmdldEFkZHJlc3Moc3M1OEZvcm1hdCk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlcyB0aGUgZG90IGFkZHJlc3MgZnJvbSB0aGUgZ2l2ZW4gZm9ybWF0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3M1OEZvcm1hdF1cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGVuY29kZURvdEFkZHJlc3MoYWRkcmVzczogc3RyaW5nLCBzczU4Rm9ybWF0PzogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZW5jb2RlQWRkcmVzcyhhZGRyZXNzLCBzczU4Rm9ybWF0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIHR4SGFzaCBvZiBhIHNpZ25lZCB0eEhleFxuICAgKlxuICAgKiBAcGFyYW0gdHhIZXggc2lnbmVkIHRyYW5zYWN0aW9uIGhleFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VHhIYXNoKHR4SGV4OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBjb25zdHJ1Y3QudHhIYXNoKHR4SGV4KTtcbiAgfVxuXG4gIGdldE1hdGVyaWFsKGNvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+KTogTWF0ZXJpYWwge1xuICAgIGNvbnN0IG5ldHdvcmtDb25maWcgPSBjb2luQ29uZmlnLm5ldHdvcmsgYXMgRG90TmV0d29yaztcbiAgICBjb25zdCB7IHNwZWNOYW1lLCBzcGVjVmVyc2lvbiwgY2hhaW5OYW1lLCB0eFZlcnNpb24sIGdlbmVzaXNIYXNoIH0gPSBuZXR3b3JrQ29uZmlnO1xuICAgIGNvbnN0IG1ldGFkYXRhUnBjID0gbmV0d29ya0NvbmZpZy5zcGVjTmFtZSA9PT0gJ3dlc3RlbmQnID8gd2VzdGVuZE1ldGFkYXRhUnBjIDogbWFpbm5ldE1ldGFkYXRhUnBjO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNwZWNOYW1lLFxuICAgICAgc3BlY1ZlcnNpb24sXG4gICAgICBjaGFpbk5hbWUsXG4gICAgICBtZXRhZGF0YTogbWV0YWRhdGFScGMsXG4gICAgICB0eFZlcnNpb24sXG4gICAgICBnZW5lc2lzSGFzaCxcbiAgICB9IGFzIE1hdGVyaWFsO1xuICB9XG5cbiAgaXNTaWduaW5nUGF5bG9hZChwYXlsb2FkOiBEZWNvZGVkU2lnbmluZ1BheWxvYWQgfCBEZWNvZGVkU2lnbmVkVHgpOiBwYXlsb2FkIGlzIERlY29kZWRTaWduaW5nUGF5bG9hZCB7XG4gICAgcmV0dXJuIChwYXlsb2FkIGFzIERlY29kZWRTaWduaW5nUGF5bG9hZCkuYmxvY2tIYXNoICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICBpc1Byb3h5VHJhbnNmZXIoYXJnOiBUeE1ldGhvZFsnYXJncyddKTogYXJnIGlzIFByb3h5QXJncyB7XG4gICAgcmV0dXJuIChhcmcgYXMgUHJveHlBcmdzKS5yZWFsICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICBpc1RyYW5zZmVyKGFyZzogVHhNZXRob2RbJ2FyZ3MnXSk6IGFyZyBpcyBUcmFuc2ZlckFyZ3Mge1xuICAgIHJldHVybiAoYXJnIGFzIFRyYW5zZmVyQXJncykuZGVzdD8uaWQgIT09IHVuZGVmaW5lZCAmJiAoYXJnIGFzIFRyYW5zZmVyQXJncykudmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlzVHJhbnNmZXJBbGwoYXJnOiBUeE1ldGhvZFsnYXJncyddKTogYXJnIGlzIFRyYW5zZmVyQWxsQXJncyB7XG4gICAgcmV0dXJuIChhcmcgYXMgVHJhbnNmZXJBbGxBcmdzKS5kZXN0Py5pZCAhPT0gdW5kZWZpbmVkICYmIChhcmcgYXMgVHJhbnNmZXJBbGxBcmdzKS5rZWVwQWxpdmUgIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYXJnIGlzIG9mIHR5cGUgQmF0Y2hBcmdzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgVGhlIG9iamVjdCB0byB0ZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgYXJnIGlzIG9mIHR5cGUgQmF0Y2hBcmdzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0JhdGNoKGFyZzogVHhNZXRob2RbJ2FyZ3MnXSk6IGFyZyBpcyBCYXRjaEFyZ3Mge1xuICAgIHJldHVybiAoYXJnIGFzIEJhdGNoQXJncykuY2FsbHMgIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYXJnIGlzIG9mIHR5cGUgQmF0Y2hBcmdzIGFuZCB0aGUgY2FsbHMgb2YgdGhlIGJhdGNoIGFyZSBzdGFraW5nIGNhbGxzOiBhIHN0YWtlXG4gICAqIGNhbGwgKGJvbmQpIGZvbGxvd2VkIGJ5IGFuIGFkZCBwcm94eSBjYWxsIChhZGRQcm94eSksIGZhbHNlIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHBhcmFtIGFyZyBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBhcmcgaXMgb2YgdHlwZSBCYXRjaEFyZ3MgYW5kIHRoZSBjYWxscyBvZiB0aGUgYmF0Y2ggYXJlIHN0YWtpbmcgY2FsbHM6IGEgc3Rha2VcbiAgICogY2FsbCAoYm9uZCkgZm9sbG93ZWQgYnkgYW4gYWRkIHByb3h5IGNhbGwgKGFkZFByb3h5KSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNTdGFraW5nQmF0Y2goYXJnOiBUeE1ldGhvZFsnYXJncyddKTogYXJnIGlzIEJhdGNoQXJncyB7XG4gICAgY29uc3QgY2FsbHMgPSAoYXJnIGFzIEJhdGNoQXJncykuY2FsbHM7XG4gICAgaWYgKGNhbGxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNhbGxzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAodGhpcy5pc1N0YWtlQmF0Y2hDYWxsQXJncyhjYWxsc1swXS5hcmdzKSB8fCB0aGlzLmlzQm9uZEJhdGNoRXh0cmEoY2FsbHNbMF0uYXJncykpICYmXG4gICAgICAgIHRoaXMuaXNBZGRQcm94eUJhdGNoQ2FsbEFyZ3MoY2FsbHNbMV0uYXJncylcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYXJnIGlzIG9mIHR5cGUgU3Rha2VCYXRjaENhbGxBcmdzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgVGhlIG9iamVjdCB0byB0ZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgYXJnIGlzIG9mIHR5cGUgU3Rha2VCYXRjaENhbGxBcmdzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1N0YWtlQmF0Y2hDYWxsQXJncyhhcmc6IEJhdGNoQ2FsbE9iamVjdFsnYXJncyddKTogYXJnIGlzIFN0YWtlQmF0Y2hDYWxsQXJncyB7XG4gICAgcmV0dXJuIChhcmcgYXMgU3Rha2VCYXRjaENhbGxBcmdzKS52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIChhcmcgYXMgU3Rha2VCYXRjaENhbGxBcmdzKS5wYXllZSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhcmcgaXMgb2YgdHlwZSBBZGRQcm94eUJhdGNoQ2FsbEFyZ3MsIGZhbHNlIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHBhcmFtIGFyZyBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBhcmcgaXMgb2YgdHlwZSBBZGRQcm94eUJhdGNoQ2FsbEFyZ3MsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzQWRkUHJveHlCYXRjaENhbGxBcmdzKGFyZzogQmF0Y2hDYWxsT2JqZWN0WydhcmdzJ10pOiBhcmcgaXMgQWRkUHJveHlCYXRjaENhbGxBcmdzIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGFyZyBhcyBBZGRQcm94eUJhdGNoQ2FsbEFyZ3MpLmRlbGVnYXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChhcmcgYXMgQWRkUHJveHlCYXRjaENhbGxBcmdzKS5wcm94eV90eXBlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChhcmcgYXMgQWRkUHJveHlCYXRjaENhbGxBcmdzKS5kZWxheSAhPT0gdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYXJnIGlzIG9mIHR5cGUgQmF0Y2hBcmdzIGFuZCB0aGUgY2FsbHMgb2YgdGhlIGJhdGNoIGFyZSB1bnN0YWtpbmcgY2FsbHM6IGEgcmVtb3ZlXG4gICAqIHByb3h5IGNhbGwgKHJlbW92ZVByb3h5KSwgZm9sbG93ZWQgYnkgYSBjaGlsbCBjYWxsLCBhbmQgYW4gdW5zdGFrZSBjYWxsICh1bmJvbmQpLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgVGhlIG9iamVjdCB0byB0ZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgYXJnIGlzIG9mIHR5cGUgQmF0Y2hBcmdzIGFuZCB0aGUgY2FsbHMgb2YgdGhlIGJhdGNoIGFyZSB1bnN0YWtpbmcgY2FsbHM6IGEgcmVtb3ZlXG4gICAqIHByb3h5IGNhbGwgKHJlbW92ZVByb3h5KSwgZm9sbG93ZWQgYnkgYSBjaGlsbCBjYWxsLCBhbmQgYW4gdW5zdGFrZSBjYWxsICh1bmJvbmQpLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1Vuc3Rha2luZ0JhdGNoKGFyZzogVHhNZXRob2RbJ2FyZ3MnXSk6IGFyZyBpcyBCYXRjaEFyZ3Mge1xuICAgIGNvbnN0IGNhbGxzID0gKGFyZyBhcyBCYXRjaEFyZ3MpLmNhbGxzO1xuICAgIGlmIChjYWxscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjYWxscy5sZW5ndGggPT09IDMgJiZcbiAgICAgICAgdGhpcy5pc1JlbW92ZVByb3h5QmF0Y2hDYWxsQXJncyhjYWxsc1swXS5hcmdzKSAmJlxuICAgICAgICBfLmlzRW1wdHkoY2FsbHNbMV0uYXJncykgJiZcbiAgICAgICAgdGhpcy5pc1Vuc3Rha2VCYXRjaENhbGxBcmdzKGNhbGxzWzJdLmFyZ3MpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGFyZyBpcyBvZiB0eXBlIEFkZFByb3h5QmF0Y2hDYWxsQXJncywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIGFyZyBpcyBvZiB0eXBlIEFkZFByb3h5QmF0Y2hDYWxsQXJncywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNSZW1vdmVQcm94eUJhdGNoQ2FsbEFyZ3MoYXJnOiBCYXRjaENhbGxPYmplY3RbJ2FyZ3MnXSk6IGFyZyBpcyBBZGRQcm94eUJhdGNoQ2FsbEFyZ3Mge1xuICAgIHJldHVybiAoXG4gICAgICAoYXJnIGFzIEFkZFByb3h5QmF0Y2hDYWxsQXJncykuZGVsZWdhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKGFyZyBhcyBBZGRQcm94eUJhdGNoQ2FsbEFyZ3MpLnByb3h5X3R5cGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKGFyZyBhcyBBZGRQcm94eUJhdGNoQ2FsbEFyZ3MpLmRlbGF5ICE9PSB1bmRlZmluZWRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhcmcgaXMgb2YgdHlwZSBVbnN0YWtlQmF0Y2hDYWxsQXJncywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIGFyZyBpcyBvZiB0eXBlIFVuc3Rha2VCYXRjaENhbGxBcmdzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1Vuc3Rha2VCYXRjaENhbGxBcmdzKGFyZzogQmF0Y2hDYWxsT2JqZWN0WydhcmdzJ10pOiBhcmcgaXMgVW5zdGFrZUJhdGNoQ2FsbEFyZ3Mge1xuICAgIHJldHVybiAoYXJnIGFzIFVuc3Rha2VCYXRjaENhbGxBcmdzKS52YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhcmcgaXMgb2YgdHlwZSBTdGFrZUFyZ3MsIGZhbHNlIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHBhcmFtIGFyZyBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBhcmcgaXMgb2YgdHlwZSBTdGFrZUFyZ3MsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzQm9uZChhcmc6IFR4TWV0aG9kWydhcmdzJ10pOiBhcmcgaXMgU3Rha2VBcmdzIHtcbiAgICByZXR1cm4gKGFyZyBhcyBTdGFrZUFyZ3MpLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgKGFyZyBhcyBTdGFrZUFyZ3MpLnBheWVlICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGFyZyBpcyBvZiB0eXBlIFN0YWtlTW9yZUFyZ3MsIGZhbHNlIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHBhcmFtIGFyZyBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBhcmcgaXMgb2YgdHlwZSBTdGFrZU1vcmVBcmdzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0JvbmRFeHRyYShhcmc6IFR4TWV0aG9kWydhcmdzJ10gfCBCYXRjaENhbGxPYmplY3RbJ2FyZ3MnXSk6IGFyZyBpcyBTdGFrZU1vcmVBcmdzIHtcbiAgICByZXR1cm4gKGFyZyBhcyBTdGFrZU1vcmVBcmdzKS5tYXhBZGRpdGlvbmFsICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGFyZyBpcyBvZiB0eXBlIFN0YWtlTW9yZUFyZ3MsIGZhbHNlIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHBhcmFtIGFyZyBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBhcmcgaXMgb2YgdHlwZSBTdGFrZU1vcmVBcmdzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0JvbmRCYXRjaEV4dHJhKGFyZzogQmF0Y2hDYWxsT2JqZWN0WydhcmdzJ10pOiBhcmcgaXMgU3Rha2VNb3JlQ2FsbEFyZ3Mge1xuICAgIHJldHVybiAoYXJnIGFzIFN0YWtlTW9yZUNhbGxBcmdzKS5tYXhfYWRkaXRpb25hbCAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIGV4dHJhY3RzIGFuZCByZXR1cm5zIHRoZSBzaWduYXR1cmUgaW4gaGV4IGZvcm1hdCBnaXZlbiBhIHJhdyBzaWduZWQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJhd1R4IHNpZ25lZCByYXcgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIG9wdGlvbnMgcmVnaXN0cnkgZG90IHJlZ2lzdHJ5IHVzZWQgdG8gcmV0cmlldmUgdGhlIHNpZ25hdHVyZVxuICAgKi9cbiAgcmVjb3ZlclNpZ25hdHVyZUZyb21SYXdUeChyYXdUeDogc3RyaW5nLCBvcHRpb25zOiB7IHJlZ2lzdHJ5OiBUeXBlUmVnaXN0cnkgfSk6IHN0cmluZyB7XG4gICAgY29uc3QgeyByZWdpc3RyeSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBtZXRob2RDYWxsID0gcmVnaXN0cnkuY3JlYXRlVHlwZSgnRXh0cmluc2ljJywgcmF3VHgsIHtcbiAgICAgIGlzU2lnbmVkOiB0cnVlLFxuICAgIH0pO1xuICAgIGxldCBzaWduYXR1cmUgPSB1OGFUb0hleChtZXRob2RDYWxsLnNpZ25hdHVyZSkgYXMgc3RyaW5nO1xuXG4gICAgLy8gcmVtb3ZlIDB4IGZyb20gdGhlIHNpZ25hdHVyZSBzaW5jZSB0aGlzIGlzIGhvdyBpdCdzIHJldHVybmVkIGZyb20gVFNTIHNpZ25pbmdcbiAgICBpZiAoc2lnbmF0dXJlLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgIHNpZ25hdHVyZSA9IHNpZ25hdHVyZS5zdWJzdHIoMik7XG4gICAgfVxuICAgIHJldHVybiBzaWduYXR1cmU7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlcyB0aGUgZG90IGFkZHJlc3MgZnJvbSB0aGUgZ2l2ZW4gZm9ybWF0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3M1OEZvcm1hdF1cbiAgICogQHJldHVybnMge0tleVBhaXJ9XG4gICAqL1xuICBkZWNvZGVEb3RBZGRyZXNzVG9LZXlQYWlyKGFkZHJlc3M6IHN0cmluZywgc3M1OEZvcm1hdD86IG51bWJlcik6IEtleVBhaXIge1xuICAgIHJldHVybiBuZXcgS2V5UGFpcih7IHB1YjogQnVmZmVyLmZyb20oZGVjb2RlQWRkcmVzcyhhZGRyZXNzLCB1bmRlZmluZWQsIHNzNThGb3JtYXQpKS50b1N0cmluZygnaGV4JykgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGlucHV0IGlzIGEgaGV4IHN0cmluZyB3aXRoIHdpdGggMCB2YWx1ZVxuICAgKiB1c2VkIHRvIGNoZWNrIHdoZXRoZXIgYSBnaXZlbiB0cmFuc2FjdGlvbiBpcyBpbW1vcnRhbCBvciBtb3J0YWxcbiAgICogQHBhcmFtIGhleFZhbHVlXG4gICAqL1xuICBpc1plcm9IZXgoaGV4VmFsdWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBoZXhWYWx1ZSA9PT0gJzB4MDAnO1xuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIGFuIGFzc2V0IG5hbWUgYW5kIHJldHVybnMgdGhlIHJlc3BlY3RpdmUgYWRkcmVzcyB0byBmb3JtYXQgdG9cbiAgICogc2luY2UgcG9sa2Fkb3QgYWRkcmVzc2VzIGRpZmZlciBkZXBlbmRpbmcgb24gdGhlIG5ldHdvcmtcbiAgICogcmVmOiBodHRwczovL3dpa2kucG9sa2Fkb3QubmV0d29yay9kb2NzL2xlYXJuLWFjY291bnRzXG4gICAqIEBwYXJhbSBuZXR3b3JrQ29pbk5hbWVcbiAgICovXG4gIGdldEFkZHJlc3NGb3JtYXQobmV0d29ya0NvaW5OYW1lOiBEb3RBc3NldFR5cGVzKTogRG90QWRkcmVzc0Zvcm1hdCB7XG4gICAgcmV0dXJuIGNvaW5Ub0FkZHJlc3NNYXAuZ2V0KG5ldHdvcmtDb2luTmFtZSkgYXMgRG90QWRkcmVzc0Zvcm1hdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcHVyZSBwcm94eSBleHRyaW5zaWMuIFBvbGthZG90IGhhcyByZW5hbWVkIGFub255bW91cyBwcm94aWVzIHRvIHB1cmUgcHJveGllcywgYnV0XG4gICAqIHRoZSBsaWJyYXJpZXMgd2UgYXJlIHVzaW5nIHRvIGJ1aWxkIHRyYW5zYWN0aW9ucyBoYXZlIG5vdCBiZWVuIHVwZGF0ZWQsIGFzIGEgc3RvcCBnYXAgd2UgYXJlXG4gICAqIGRlZmluaW5nIHRoZSBwdXJlIHByb3h5IGV4dHJpbnNpYyBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0gYXJncyBBcmd1bWVudHMgdG8gdGhlIGNyZWF0ZVB1cmUgZXh0cmluc2ljLlxuICAgKiBAcGFyYW0gaW5mbyBDb21tb24gaW5mb3JtYXRpb24gdG8gYWxsIHRyYW5zYWN0aW9ucy5cbiAgICogQHBhcmFtIG9wdGlvbnMgQ2hhaW4gcmVnaXN0cnkgYW5kIG1ldGFkYXRhLlxuICAgKi9cbiAgcHVyZVByb3h5KGFyZ3M6IFB1cmVQcm94eUFyZ3MsIGluZm86IEJhc2VUeEluZm8sIG9wdGlvbnM6IE9wdGlvbnNXaXRoTWV0YSk6IFVuc2lnbmVkVHJhbnNhY3Rpb24ge1xuICAgIHJldHVybiBkZWZpbmVNZXRob2QoXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDoge1xuICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgbmFtZTogJ2NyZWF0ZVB1cmUnLFxuICAgICAgICAgIHBhbGxldDogJ3Byb3h5JyxcbiAgICAgICAgfSxcbiAgICAgICAgLi4uaW5mbyxcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzICcweCcgZnJvbSBhIGdpdmVuIGBzdHJpbmdgIGlmIHByZXNlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgdGhlIHN0cmluZyB2YWx1ZS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBhIHN0cmluZyB3aXRob3V0IGEgJzB4JyBwcmVmaXguXG4gICAqL1xuICBzdHJpcEhleFByZWZpeChzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyLnNsaWNlKDIpIDogc3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAnMHgnLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgdGhlIHN0cmluZyB2YWx1ZS5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAnMHgnLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0hleFByZWZpeGVkKHN0cjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHN0ci5zbGljZSgwLCAyKSA9PT0gJzB4JztcbiAgfVxufVxuXG5pbnRlcmZhY2UgUHVyZVByb3h5QXJncyBleHRlbmRzIEFyZ3Mge1xuICBwcm94eVR5cGU6IHN0cmluZztcbiAgZGVsYXk6IG51bWJlcjtcbiAgaW5kZXg6IG51bWJlcjtcbn1cblxuY29uc3QgdXRpbHMgPSBuZXcgVXRpbHMoKTtcblxuZXhwb3J0IGRlZmF1bHQgdXRpbHM7XG4iXX0=