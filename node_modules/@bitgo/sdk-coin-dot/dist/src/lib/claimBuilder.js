"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClaimBuilder = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const txwrapper_polkadot_1 = require("@substrate/txwrapper-polkadot");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const iface_1 = require("./iface");
const transactionBuilder_1 = require("./transactionBuilder");
const txnSchema_1 = require("./txnSchema");
const utils_1 = __importDefault(require("./utils"));
class ClaimBuilder extends transactionBuilder_1.TransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
    }
    /**
     *
     * Pay out all the stakers behind a single validator for a single era.
     * Any account can create this transaction.
     *
     * @returns {UnsignedTransaction} an unsigned Dot transaction
     *
     * @see https://polkadot.js.org/docs/substrate/extrinsics/#payoutstakersvalidator_stash-accountid32-era-u32
     */
    buildTransaction() {
        const baseTxInfo = this.createBaseTxInfo();
        return txwrapper_polkadot_1.methods.staking.payoutStakers({
            validatorStash: this._validatorStash,
            era: this._claimEra,
        }, baseTxInfo.baseTxInfo, baseTxInfo.options);
    }
    /**
     * Get the transaction type.
     */
    get transactionType() {
        return sdk_core_1.TransactionType.StakingClaim;
    }
    /**
     *
     * The stash account of the validator.
     *
     * @param {string} validatorStash
     * @returns {ClaimBuilder} This claim builder.
     *
     */
    validatorStash(validatorStash) {
        this.validateAddress(validatorStash);
        this._validatorStash = validatorStash.address;
        return this;
    }
    /**
     * The era to claim.
     *
     * @param {string} claimEra
     * @returns {ClaimBuilder} This claim builder.
     *
     */
    claimEra(claimEra) {
        this.validateValue(new bignumber_js_1.default(claimEra));
        this._claimEra = claimEra;
        return this;
    }
    /** @inheritdoc */
    validateDecodedTransaction(decodedTxn) {
        var _a;
        if (((_a = decodedTxn.method) === null || _a === void 0 ? void 0 : _a.name) === iface_1.MethodNames.PayoutStakers) {
            const txMethod = decodedTxn.method.args;
            const claimEra = txMethod.era;
            const validatorStash = txMethod.validatorStash;
            const validationResult = txnSchema_1.ClaimTransactionSchema.validate({ claimEra, validatorStash });
            if (validationResult.error) {
                throw new sdk_core_1.InvalidTransactionError(`Claim Transaction validation failed: ${validationResult.error.message}`);
            }
        }
    }
    /** @inheritdoc */
    fromImplementation(rawTransaction) {
        var _a, _b;
        const tx = super.fromImplementation(rawTransaction);
        if (((_a = this._method) === null || _a === void 0 ? void 0 : _a.name) === iface_1.MethodNames.PayoutStakers) {
            const txMethod = this._method.args;
            this.validatorStash({
                address: utils_1.default.decodeDotAddress(txMethod.validatorStash, utils_1.default.getAddressFormat(this._coinConfig.name)),
            });
            this.claimEra(txMethod.era);
        }
        else {
            throw new sdk_core_1.InvalidTransactionError(`Invalid Transaction Type: ${(_b = this._method) === null || _b === void 0 ? void 0 : _b.name}. Expected payoutStakers`);
        }
        return tx;
    }
    /** @inheritdoc */
    validateTransaction(_) {
        super.validateTransaction(_);
        this.validateFields(this._claimEra, this._validatorStash);
    }
    /**
     *
     * The stash account of the validator.
     *
     * @param {string} claimEra
     * @param {string} validatorStash
     * @throws {Error} If the expected fields are not valid.
     *
     */
    validateFields(claimEra, validatorStash) {
        const validationResult = txnSchema_1.ClaimTransactionSchema.validate({
            claimEra,
            validatorStash,
        });
        if (validationResult.error) {
            throw new sdk_core_1.InvalidTransactionError(`Claim Builder Transaction validation failed: ${validationResult.error.message}`);
        }
    }
}
exports.ClaimBuilder = ClaimBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhaW1CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9jbGFpbUJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsOENBQXVHO0FBR3ZHLHNFQUF3RDtBQUN4RCxnRUFBcUM7QUFDckMsbUNBQWlEO0FBRWpELDZEQUEwRDtBQUMxRCwyQ0FBcUQ7QUFDckQsb0RBQTRCO0FBRTVCLE1BQWEsWUFBYSxTQUFRLHVDQUFrQjtJQUlsRCxZQUFZLFdBQWlDO1FBQzNDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDTyxnQkFBZ0I7UUFDeEIsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDM0MsT0FBTyw0QkFBTyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQ2xDO1lBQ0UsY0FBYyxFQUFFLElBQUksQ0FBQyxlQUFlO1lBQ3BDLEdBQUcsRUFBRSxJQUFJLENBQUMsU0FBUztTQUNwQixFQUNELFVBQVUsQ0FBQyxVQUFVLEVBQ3JCLFVBQVUsQ0FBQyxPQUFPLENBQ25CLENBQUM7SUFDSixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFjLGVBQWU7UUFDM0IsT0FBTywwQkFBZSxDQUFDLFlBQVksQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILGNBQWMsQ0FBQyxjQUEyQjtRQUN4QyxJQUFJLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxlQUFlLEdBQUcsY0FBYyxDQUFDLE9BQU8sQ0FBQztRQUM5QyxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxRQUFRLENBQUMsUUFBZ0I7UUFDdkIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLHNCQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUM1QyxJQUFJLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQztRQUMxQixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsMEJBQTBCLENBQUMsVUFBbUQ7O1FBQzVFLElBQUksQ0FBQSxNQUFBLFVBQVUsQ0FBQyxNQUFNLDBDQUFFLElBQUksTUFBSyxtQkFBVyxDQUFDLGFBQWEsRUFBRTtZQUN6RCxNQUFNLFFBQVEsR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQTRCLENBQUM7WUFDaEUsTUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQztZQUM5QixNQUFNLGNBQWMsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDO1lBQy9DLE1BQU0sZ0JBQWdCLEdBQUcsa0NBQXNCLENBQUMsUUFBUSxDQUFDLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxDQUFDLENBQUM7WUFDdkYsSUFBSSxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUU7Z0JBQzFCLE1BQU0sSUFBSSxrQ0FBdUIsQ0FBQyx3Q0FBd0MsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7YUFDN0c7U0FDRjtJQUNILENBQUM7SUFFRCxrQkFBa0I7SUFDUixrQkFBa0IsQ0FBQyxjQUFzQjs7UUFDakQsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3BELElBQUksQ0FBQSxNQUFBLElBQUksQ0FBQyxPQUFPLDBDQUFFLElBQUksTUFBSyxtQkFBVyxDQUFDLGFBQWEsRUFBRTtZQUNwRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQWlCLENBQUM7WUFDaEQsSUFBSSxDQUFDLGNBQWMsQ0FBQztnQkFDbEIsT0FBTyxFQUFFLGVBQUssQ0FBQyxnQkFBZ0IsQ0FDN0IsUUFBUSxDQUFDLGNBQWMsRUFDdkIsZUFBSyxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBcUIsQ0FBQyxDQUMvRDthQUNGLENBQUMsQ0FBQztZQUNILElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzdCO2FBQU07WUFDTCxNQUFNLElBQUksa0NBQXVCLENBQUMsNkJBQTZCLE1BQUEsSUFBSSxDQUFDLE9BQU8sMENBQUUsSUFBSSwwQkFBMEIsQ0FBQyxDQUFDO1NBQzlHO1FBQ0QsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLG1CQUFtQixDQUFDLENBQWM7UUFDaEMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdCLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ssY0FBYyxDQUFDLFFBQWdCLEVBQUUsY0FBc0I7UUFDN0QsTUFBTSxnQkFBZ0IsR0FBRyxrQ0FBc0IsQ0FBQyxRQUFRLENBQUM7WUFDdkQsUUFBUTtZQUNSLGNBQWM7U0FDZixDQUFDLENBQUM7UUFFSCxJQUFJLGdCQUFnQixDQUFDLEtBQUssRUFBRTtZQUMxQixNQUFNLElBQUksa0NBQXVCLENBQy9CLGdEQUFnRCxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQ2pGLENBQUM7U0FDSDtJQUNILENBQUM7Q0FDRjtBQXpIRCxvQ0F5SEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQWRkcmVzcywgRG90QXNzZXRUeXBlcywgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IsIFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBCYXNlQ29pbiBhcyBDb2luQ29uZmlnIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHsgRGVjb2RlZFNpZ25lZFR4LCBEZWNvZGVkU2lnbmluZ1BheWxvYWQsIFVuc2lnbmVkVHJhbnNhY3Rpb24gfSBmcm9tICdAc3Vic3RyYXRlL3R4d3JhcHBlci1jb3JlJztcbmltcG9ydCB7IG1ldGhvZHMgfSBmcm9tICdAc3Vic3RyYXRlL3R4d3JhcHBlci1wb2xrYWRvdCc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBDbGFpbUFyZ3MsIE1ldGhvZE5hbWVzIH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25CdWlsZGVyIH0gZnJvbSAnLi90cmFuc2FjdGlvbkJ1aWxkZXInO1xuaW1wb3J0IHsgQ2xhaW1UcmFuc2FjdGlvblNjaGVtYSB9IGZyb20gJy4vdHhuU2NoZW1hJztcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGNsYXNzIENsYWltQnVpbGRlciBleHRlbmRzIFRyYW5zYWN0aW9uQnVpbGRlciB7XG4gIHByb3RlY3RlZCBfdmFsaWRhdG9yU3Rhc2g6IHN0cmluZztcbiAgcHJvdGVjdGVkIF9jbGFpbUVyYTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKF9jb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xuICAgIHN1cGVyKF9jb2luQ29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBQYXkgb3V0IGFsbCB0aGUgc3Rha2VycyBiZWhpbmQgYSBzaW5nbGUgdmFsaWRhdG9yIGZvciBhIHNpbmdsZSBlcmEuXG4gICAqIEFueSBhY2NvdW50IGNhbiBjcmVhdGUgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge1Vuc2lnbmVkVHJhbnNhY3Rpb259IGFuIHVuc2lnbmVkIERvdCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vcG9sa2Fkb3QuanMub3JnL2RvY3Mvc3Vic3RyYXRlL2V4dHJpbnNpY3MvI3BheW91dHN0YWtlcnN2YWxpZGF0b3Jfc3Rhc2gtYWNjb3VudGlkMzItZXJhLXUzMlxuICAgKi9cbiAgcHJvdGVjdGVkIGJ1aWxkVHJhbnNhY3Rpb24oKTogVW5zaWduZWRUcmFuc2FjdGlvbiB7XG4gICAgY29uc3QgYmFzZVR4SW5mbyA9IHRoaXMuY3JlYXRlQmFzZVR4SW5mbygpO1xuICAgIHJldHVybiBtZXRob2RzLnN0YWtpbmcucGF5b3V0U3Rha2VycyhcbiAgICAgIHtcbiAgICAgICAgdmFsaWRhdG9yU3Rhc2g6IHRoaXMuX3ZhbGlkYXRvclN0YXNoLFxuICAgICAgICBlcmE6IHRoaXMuX2NsYWltRXJhLFxuICAgICAgfSxcbiAgICAgIGJhc2VUeEluZm8uYmFzZVR4SW5mbyxcbiAgICAgIGJhc2VUeEluZm8ub3B0aW9uc1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldCB0cmFuc2FjdGlvblR5cGUoKTogVHJhbnNhY3Rpb25UeXBlIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdDbGFpbTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBUaGUgc3Rhc2ggYWNjb3VudCBvZiB0aGUgdmFsaWRhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsaWRhdG9yU3Rhc2hcbiAgICogQHJldHVybnMge0NsYWltQnVpbGRlcn0gVGhpcyBjbGFpbSBidWlsZGVyLlxuICAgKlxuICAgKi9cbiAgdmFsaWRhdG9yU3Rhc2godmFsaWRhdG9yU3Rhc2g6IEJhc2VBZGRyZXNzKTogdGhpcyB7XG4gICAgdGhpcy52YWxpZGF0ZUFkZHJlc3ModmFsaWRhdG9yU3Rhc2gpO1xuICAgIHRoaXMuX3ZhbGlkYXRvclN0YXNoID0gdmFsaWRhdG9yU3Rhc2guYWRkcmVzcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZXJhIHRvIGNsYWltLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhaW1FcmFcbiAgICogQHJldHVybnMge0NsYWltQnVpbGRlcn0gVGhpcyBjbGFpbSBidWlsZGVyLlxuICAgKlxuICAgKi9cbiAgY2xhaW1FcmEoY2xhaW1FcmE6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudmFsaWRhdGVWYWx1ZShuZXcgQmlnTnVtYmVyKGNsYWltRXJhKSk7XG4gICAgdGhpcy5fY2xhaW1FcmEgPSBjbGFpbUVyYTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZURlY29kZWRUcmFuc2FjdGlvbihkZWNvZGVkVHhuOiBEZWNvZGVkU2lnbmluZ1BheWxvYWQgfCBEZWNvZGVkU2lnbmVkVHgpOiB2b2lkIHtcbiAgICBpZiAoZGVjb2RlZFR4bi5tZXRob2Q/Lm5hbWUgPT09IE1ldGhvZE5hbWVzLlBheW91dFN0YWtlcnMpIHtcbiAgICAgIGNvbnN0IHR4TWV0aG9kID0gZGVjb2RlZFR4bi5tZXRob2QuYXJncyBhcyB1bmtub3duIGFzIENsYWltQXJncztcbiAgICAgIGNvbnN0IGNsYWltRXJhID0gdHhNZXRob2QuZXJhO1xuICAgICAgY29uc3QgdmFsaWRhdG9yU3Rhc2ggPSB0eE1ldGhvZC52YWxpZGF0b3JTdGFzaDtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBDbGFpbVRyYW5zYWN0aW9uU2NoZW1hLnZhbGlkYXRlKHsgY2xhaW1FcmEsIHZhbGlkYXRvclN0YXNoIH0pO1xuICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKGBDbGFpbSBUcmFuc2FjdGlvbiB2YWxpZGF0aW9uIGZhaWxlZDogJHt2YWxpZGF0aW9uUmVzdWx0LmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBmcm9tSW1wbGVtZW50YXRpb24ocmF3VHJhbnNhY3Rpb246IHN0cmluZyk6IFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCB0eCA9IHN1cGVyLmZyb21JbXBsZW1lbnRhdGlvbihyYXdUcmFuc2FjdGlvbik7XG4gICAgaWYgKHRoaXMuX21ldGhvZD8ubmFtZSA9PT0gTWV0aG9kTmFtZXMuUGF5b3V0U3Rha2Vycykge1xuICAgICAgY29uc3QgdHhNZXRob2QgPSB0aGlzLl9tZXRob2QuYXJncyBhcyBDbGFpbUFyZ3M7XG4gICAgICB0aGlzLnZhbGlkYXRvclN0YXNoKHtcbiAgICAgICAgYWRkcmVzczogdXRpbHMuZGVjb2RlRG90QWRkcmVzcyhcbiAgICAgICAgICB0eE1ldGhvZC52YWxpZGF0b3JTdGFzaCxcbiAgICAgICAgICB1dGlscy5nZXRBZGRyZXNzRm9ybWF0KHRoaXMuX2NvaW5Db25maWcubmFtZSBhcyBEb3RBc3NldFR5cGVzKVxuICAgICAgICApLFxuICAgICAgfSk7XG4gICAgICB0aGlzLmNsYWltRXJhKHR4TWV0aG9kLmVyYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBUcmFuc2FjdGlvbiBUeXBlOiAke3RoaXMuX21ldGhvZD8ubmFtZX0uIEV4cGVjdGVkIHBheW91dFN0YWtlcnNgKTtcbiAgICB9XG4gICAgcmV0dXJuIHR4O1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlVHJhbnNhY3Rpb24oXzogVHJhbnNhY3Rpb24pOiB2b2lkIHtcbiAgICBzdXBlci52YWxpZGF0ZVRyYW5zYWN0aW9uKF8pO1xuICAgIHRoaXMudmFsaWRhdGVGaWVsZHModGhpcy5fY2xhaW1FcmEsIHRoaXMuX3ZhbGlkYXRvclN0YXNoKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBUaGUgc3Rhc2ggYWNjb3VudCBvZiB0aGUgdmFsaWRhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhaW1FcmFcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvclN0YXNoXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZXhwZWN0ZWQgZmllbGRzIGFyZSBub3QgdmFsaWQuXG4gICAqXG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlRmllbGRzKGNsYWltRXJhOiBzdHJpbmcsIHZhbGlkYXRvclN0YXNoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gQ2xhaW1UcmFuc2FjdGlvblNjaGVtYS52YWxpZGF0ZSh7XG4gICAgICBjbGFpbUVyYSxcbiAgICAgIHZhbGlkYXRvclN0YXNoLFxuICAgIH0pO1xuXG4gICAgaWYgKHZhbGlkYXRpb25SZXN1bHQuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihcbiAgICAgICAgYENsYWltIEJ1aWxkZXIgVHJhbnNhY3Rpb24gdmFsaWRhdGlvbiBmYWlsZWQ6ICR7dmFsaWRhdGlvblJlc3VsdC5lcnJvci5tZXNzYWdlfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iXX0=