/// <reference types="node" />
import { BaseCoin, BitGoBase, Eddsa, ExplanationResult, KeyPair, MPCAlgorithm, ParsedTransaction, ParseTransactionOptions, SignedTransaction, SignTransactionOptions as BaseSignTransactionOptions, UnsignedTransaction, VerifyAddressOptions, VerifyTransactionOptions, MPCTx, MPCRecoveryOptions, MPCConsolidationRecoveryOptions, MPCSweepTxs, MPCSweepRecoveryOptions, MPCTxs } from '@bitgo/sdk-core';
import { BaseCoin as StaticsBaseCoin } from '@bitgo/statics';
import { Interface } from './lib';
import { ApiPromise } from '@polkadot/api';
import { Material } from './lib/iface';
export declare const DEFAULT_SCAN_FACTOR = 20;
export interface SignTransactionOptions extends BaseSignTransactionOptions {
    txPrebuild: TransactionPrebuild;
    prv: string;
}
export interface TransactionPrebuild {
    txHex: string;
    transaction: Interface.TxData;
}
export interface ExplainTransactionOptions {
    txPrebuild: TransactionPrebuild;
    publicKey: string;
    feeInfo: {
        fee: string;
    };
}
export interface VerifiedTransactionParameters {
    txHex: string;
    prv: string;
}
export declare class Dot extends BaseCoin {
    protected readonly _staticsCoin: Readonly<StaticsBaseCoin>;
    readonly MAX_VALIDITY_DURATION = 2400;
    readonly SWEEP_TXN_DURATION = 64;
    constructor(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>);
    protected static initialized: boolean;
    protected static MPC: Eddsa;
    protected static nodeApiInitialized: boolean;
    protected static API: ApiPromise;
    static createInstance(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>): BaseCoin;
    getChain(): string;
    getBaseChain(): string;
    getFamily(): string;
    getFullName(): string;
    getBaseFactor(): number;
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed(): boolean;
    /** @inheritDoc */
    supportsTss(): boolean;
    getMPCAlgorithm(): MPCAlgorithm;
    allowsAccountConsolidations(): boolean;
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    generateKeyPair(seed?: Buffer): KeyPair;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub: string): boolean;
    /**
     * Return boolean indicating whether the supplied private key is a valid dot private key
     *
     * @param {String} prv the prv to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPrv(prv: string): boolean;
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {String} address the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidAddress(address: string): boolean;
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     * @return {Buffer} A signature over the given message using the given key
     */
    signMessage(key: KeyPair, message: string | Buffer): Promise<Buffer>;
    /**
     * Explain/parse transaction
     * @param unsignedTransaction
     */
    explainTransaction(unsignedTransaction: UnsignedTransaction): Promise<ExplanationResult>;
    verifySignTransactionParams(params: SignTransactionOptions): VerifiedTransactionParameters;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {TransactionPrebuild} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @returns {Promise<SignedTransaction>}
     */
    signTransaction(params: SignTransactionOptions): Promise<SignedTransaction>;
    protected getInitializedNodeAPI(): Promise<ApiPromise>;
    protected getAccountInfo(walletAddr: string): Promise<{
        nonce: number;
        freeBalance: number;
    }>;
    protected getHeaderInfo(): Promise<{
        headerNumber: number;
        headerHash: string;
    }>;
    /**
     *
     * Estimate the fee of the transaction
     *
     * @param {string} destAddr destination wallet address
     * @param {string} srcAddr source wallet address
     * @param {string} amount amount to transfer
     * @returns {number} the estimated fee the transaction will cost
     *
     * @see https://polkadot.js.org/docs/api/cookbook/tx#how-do-i-estimate-the-transaction-fees
     */
    protected getFee(destAddr: string, srcAddr: string, amount: number): Promise<number>;
    protected getMaterial(): Promise<Material>;
    /**
     * Builds a funds recovery transaction without BitGo
     * @param {MPCRecoveryOptions} params parameters needed to construct and
     * (maybe) sign the transaction
     *
     * @returns {MPCTx} the serialized transaction hex string and index
     * of the address being swept
     */
    recover(params: MPCRecoveryOptions): Promise<MPCTx | MPCSweepTxs>;
    /**
     * Builds native DOT recoveries of receive addresses in batch without BitGo.
     * Funds will be recovered to base address first. You need to initiate another sweep txn after that.
     *
     * @param {MPCConsolidationRecoveryOptions} params - options for consolidation recovery.
     * @param {string} [params.startingScanIndex] - receive address index to start scanning from. default to 1 (inclusive).
     * @param {string} [params.endingScanIndex] - receive address index to end scanning at. default to startingScanIndex + 20 (exclusive).
     */
    recoverConsolidations(params: MPCConsolidationRecoveryOptions): Promise<MPCTxs | MPCSweepTxs>;
    /**
     * Creates funds sweep recovery transaction(s) without BitGo
     *
     * @param {MPCSweepRecoveryOptions} params parameters needed to combine the signatures
     * and transactions to create broadcastable transactions
     *
     * @returns {MPCTx[]} array of the serialized transaction hex strings and indices
     * of the addresses being swept
     */
    createBroadcastableSweepTransaction(params: MPCSweepRecoveryOptions): Promise<MPCTxs>;
    parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
    isWalletAddress(params: VerifyAddressOptions): Promise<boolean>;
    verifyTransaction(params: VerifyTransactionOptions): Promise<boolean>;
    getAddressFromPublicKey(Pubkey: string): string;
    private getBuilder;
}
//# sourceMappingURL=dot.d.ts.map