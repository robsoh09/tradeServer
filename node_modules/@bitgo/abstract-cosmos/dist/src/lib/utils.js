"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosmosUtils = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const amino_1 = require("@cosmjs/amino");
const encoding_1 = require("@cosmjs/encoding");
const proto_signing_1 = require("@cosmjs/proto-signing");
const stargate_1 = require("@cosmjs/stargate");
const bignumber_js_1 = require("bignumber.js");
const tx_1 = require("cosmjs-types/cosmos/tx/v1beta1/tx");
const tx_2 = require("cosmjs-types/cosmwasm/wasm/v1/tx");
const crypto_1 = require("crypto");
const constants = require("./constants");
const keyPair_1 = require("./keyPair");
class CosmosUtils {
    constructor() {
        this.registry = new proto_signing_1.Registry([...stargate_1.defaultRegistryTypes]);
        this.registry.register(constants.executeContractMsgTypeUrl, tx_2.MsgExecuteContract);
    }
    /** @inheritdoc */
    isValidBlockId(hash) {
        return this.validateBlake2b(hash);
    }
    /** @inheritdoc */
    isValidPrivateKey(key) {
        try {
            new keyPair_1.CosmosKeyPair({ prv: key });
            return true;
        }
        catch {
            return false;
        }
    }
    /** @inheritdoc */
    isValidPublicKey(key) {
        try {
            new keyPair_1.CosmosKeyPair({ pub: key });
            return true;
        }
        catch {
            return false;
        }
    }
    /** @inheritdoc */
    isValidSignature(signature) {
        throw new sdk_core_1.NotImplementedError('isValidSignature not implemented');
    }
    /** @inheritdoc */
    isValidTransactionId(txId) {
        return this.validateBlake2b(txId);
    }
    /**
     * Checks if transaction hash is in valid black2b format
     */
    validateBlake2b(hash) {
        if ((hash === null || hash === void 0 ? void 0 : hash.length) !== 64) {
            return false;
        }
        return hash.match(/^[a-zA-Z0-9]+$/) !== null;
    }
    /**
     * Validates whether amounts are in range
     *
     * @param {number[]} amounts - the amounts to validate
     * @returns {boolean} - the validation result
     */
    isValidAmounts(amounts) {
        for (const amount of amounts) {
            if (!this.isValidAmount(amount)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Validates whether amount is in range
     * @param {number} amount
     * @returns {boolean} the validation result
     */
    isValidAmount(amount) {
        const bigNumberAmount = new bignumber_js_1.default(amount);
        if (!bigNumberAmount.isInteger() || bigNumberAmount.isLessThanOrEqualTo(0)) {
            return false;
        }
        return true;
    }
    /**
     * Decodes raw tx data into messages, signing info, and fee data
     * @param {string} txHex - raw base64 tx
     * @returns {DecodedTxRaw} Decoded transaction
     */
    getDecodedTxFromRawBase64(txRaw) {
        try {
            return (0, proto_signing_1.decodeTxRaw)((0, encoding_1.fromBase64)(txRaw));
        }
        catch (e) {
            throw new sdk_core_1.ParseTransactionError('Error decoding TxRaw base64 encoded string: ' + e.message);
        }
    }
    /**
     * Returns the array of messages in the body of the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {EncodeObject[]} messages along with type url
     */
    getEncodedMessagesFromDecodedTx(decodedTx) {
        return decodedTx.body.messages;
    }
    /**
     * Checks the txn sequence is valid or not
     * @param {number} sequence
     */
    validateSequence(sequence) {
        if (sequence < 0) {
            throw new sdk_core_1.InvalidTransactionError('Invalid sequence: less than zero');
        }
    }
    /**
     * Pulls the sequence number from a DecodedTxRaw AuthInfo property
     * @param {DecodedTxRaw} decodedTx
     * @returns {number} sequence
     */
    getSequenceFromDecodedTx(decodedTx) {
        return Number(decodedTx.authInfo.signerInfos[0].sequence);
    }
    /**
     * Pulls the typeUrl from the encoded message of a DecodedTxRaw
     * @param {DecodedTxRaw} decodedTx
     * @returns {string} cosmos proto type url
     */
    getTypeUrlFromDecodedTx(decodedTx) {
        const encodedMessage = this.getEncodedMessagesFromDecodedTx(decodedTx)[0];
        return encodedMessage.typeUrl;
    }
    /**
     * Returns the fee data from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {FeeData} fee data
     */
    getGasBudgetFromDecodedTx(decodedTx) {
        var _a, _b;
        return {
            amount: (_a = decodedTx.authInfo.fee) === null || _a === void 0 ? void 0 : _a.amount,
            gasLimit: Number((_b = decodedTx.authInfo.fee) === null || _b === void 0 ? void 0 : _b.gasLimit),
        };
    }
    /**
     * Returns the publicKey from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {string | undefined} publicKey in hex format if it exists, undefined otherwise
     */
    getPublicKeyFromDecodedTx(decodedTx) {
        var _a, _b, _c, _d;
        const publicKeyUInt8Array = (_b = (_a = decodedTx.authInfo.signerInfos) === null || _a === void 0 ? void 0 : _a[0].publicKey) === null || _b === void 0 ? void 0 : _b.value;
        if (publicKeyUInt8Array) {
            return (0, encoding_1.toHex)((0, encoding_1.fromBase64)((_d = (0, proto_signing_1.decodePubkey)((_c = decodedTx.authInfo.signerInfos) === null || _c === void 0 ? void 0 : _c[0].publicKey)) === null || _d === void 0 ? void 0 : _d.value));
        }
        return undefined;
    }
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Send transaction message data
     */
    getSendMessageDataFromDecodedTx(decodedTx) {
        return decodedTx.body.messages.map((message) => {
            const value = this.registry.decode(message);
            return {
                value: {
                    fromAddress: value.fromAddress,
                    toAddress: value.toAddress,
                    amount: value.amount,
                },
                typeUrl: message.typeUrl,
            };
        });
    }
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Delegate of undelegate transaction message data
     */
    getDelegateOrUndelegateMessageDataFromDecodedTx(decodedTx) {
        return decodedTx.body.messages.map((message) => {
            const value = this.registry.decode(message);
            return {
                value: {
                    delegatorAddress: value.delegatorAddress,
                    validatorAddress: value.validatorAddress,
                    amount: value.amount,
                },
                typeUrl: message.typeUrl,
            };
        });
    }
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Redelegate transaction message data
     */
    getRedelegateMessageDataFromDecodedTx(decodedTx) {
        return decodedTx.body.messages.map((message) => {
            const value = this.registry.decode(message);
            return {
                value: {
                    delegatorAddress: value.delegatorAddress,
                    validatorSrcAddress: value.validatorSrcAddress,
                    validatorDstAddress: value.validatorDstAddress,
                    amount: value.amount,
                },
                typeUrl: message.typeUrl,
            };
        });
    }
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} WithdrawDelegatorRewards transaction message data
     */
    getWithdrawRewardsMessageDataFromDecodedTx(decodedTx) {
        return decodedTx.body.messages.map((message) => {
            const value = this.registry.decode(message);
            return {
                value: {
                    delegatorAddress: value.delegatorAddress,
                    validatorAddress: value.validatorAddress,
                },
                typeUrl: message.typeUrl,
            };
        });
    }
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Delegate of undelegate transaction message data
     */
    getWithdrawDelegatorRewardsMessageDataFromDecodedTx(decodedTx) {
        return decodedTx.body.messages.map((message) => {
            const value = this.registry.decode(message);
            return {
                value: {
                    delegatorAddress: value.delegatorAddress,
                    validatorAddress: value.validatorAddress,
                },
                typeUrl: message.typeUrl,
            };
        });
    }
    /**
     * Get a cosmos chain address from its equivalent hex
     * @param {string} prefix
     * @param {string} addressHex
     * @returns {string}
     */
    getCosmosLikeAddressFromHex(prefix, addressHex) {
        if (addressHex.indexOf('0x') === 0) {
            addressHex = addressHex.slice(2);
        }
        return (0, encoding_1.toBech32)(prefix, (0, encoding_1.fromHex)(addressHex));
    }
    /**
     * Get a EVM chain address from its equivalent hex
     * @param {string} prefix
     * @param {string} addressHex
     * @returns {string}
     */
    getEvmLikeAddressFromCosmos(cosmosLikeAddress) {
        return '0x' + (0, encoding_1.toHex)((0, encoding_1.fromBech32)(cosmosLikeAddress).data);
    }
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Execute contract transaction message data
     */
    getExecuteContractMessageDataFromDecodedTx(decodedTx) {
        return decodedTx.body.messages.map((message) => {
            const value = this.registry.decode(message);
            return {
                value: {
                    sender: value.sender,
                    contract: value.contract,
                    msg: value.msg,
                    funds: value.funds,
                },
                typeUrl: message.typeUrl,
            };
        });
    }
    /**
     * Determines bitgo transaction type based on cosmos proto type url
     * @param {string} typeUrl
     * @returns {TransactionType | undefined} TransactionType if url is supported else undefined
     */
    getTransactionTypeFromTypeUrl(typeUrl) {
        switch (typeUrl) {
            case constants.sendMsgTypeUrl:
                return sdk_core_1.TransactionType.Send;
            case constants.delegateMsgTypeUrl:
                return sdk_core_1.TransactionType.StakingActivate;
            case constants.undelegateMsgTypeUrl:
                return sdk_core_1.TransactionType.StakingDeactivate;
            case constants.withdrawDelegatorRewardMsgTypeUrl:
                return sdk_core_1.TransactionType.StakingWithdraw;
            case constants.executeContractMsgTypeUrl:
                return sdk_core_1.TransactionType.ContractCall;
            case constants.redelegateTypeUrl:
                return sdk_core_1.TransactionType.StakingRedelegate;
            default:
                return undefined;
        }
    }
    /**
     * Takes a hex encoded pubkey, converts it to the Amino JSON representation (type/value wrapper)
     * and returns it as protobuf `Any`
     * @param {string} pubkey hex encoded compressed secp256k1 public key
     * @returns {Any} pubkey encoded as protobuf `Any`
     */
    getEncodedPubkey(pubkey) {
        return (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)((0, encoding_1.fromHex)(pubkey)));
    }
    /**
     * Creates a txRaw from an cosmos like transaction @see CosmosLikeTransaction
     * @Precondition cosmosLikeTransaction.publicKey must be defined
     * @param {CosmosLikeTransaction} cosmosLikeTransaction
     * @returns {TxRaw} Unsigned raw transaction
     */
    createTxRawFromCosmosLikeTransaction(cosmosLikeTransaction) {
        if (!cosmosLikeTransaction.publicKey) {
            throw new Error('publicKey is required to create a txRaw');
        }
        const encodedPublicKey = this.getEncodedPubkey(cosmosLikeTransaction.publicKey);
        const messages = cosmosLikeTransaction.sendMessages;
        let txBodyValue;
        if (cosmosLikeTransaction.memo) {
            txBodyValue = {
                memo: cosmosLikeTransaction.memo,
                messages: messages,
            };
        }
        else {
            txBodyValue = {
                messages: messages,
            };
        }
        const txBodyBytes = this.registry.encodeTxBody(txBodyValue);
        const sequence = cosmosLikeTransaction.sequence;
        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey: encodedPublicKey, sequence }], cosmosLikeTransaction.gasBudget.amount, cosmosLikeTransaction.gasBudget.gasLimit, undefined, undefined, undefined);
        return tx_1.TxRaw.fromPartial({
            bodyBytes: txBodyBytes,
            authInfoBytes: authInfoBytes,
        });
    }
    /**
     * Encodes a signature into a txRaw
     * @param {string} publicKeyHex publicKey in hex encoded string format
     * @param {string} signatureHex signature in hex encoded string format
     * @param {TxRaw} unsignedTx raw transaction
     * @returns {TxRaw} Signed raw transaction
     */
    createSignedTxRaw(publicKeyHex, signatureHex, unsignedTx) {
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)((0, encoding_1.fromHex)(publicKeyHex), (0, encoding_1.fromHex)(signatureHex));
        return tx_1.TxRaw.fromPartial({
            bodyBytes: unsignedTx.bodyBytes,
            authInfoBytes: unsignedTx.authInfoBytes,
            signatures: [(0, encoding_1.fromBase64)(stdSignature.signature)],
        });
    }
    /**
     * Decodes a raw transaction into a DecodedTxRaw and checks if it has non empty signatures
     * @param {string} rawTransaction
     * @returns {boolean} true if transaction is signed else false
     */
    isSignedRawTx(rawTransaction) {
        const decodedTx = this.getDecodedTxFromRawBase64(rawTransaction);
        if (decodedTx.signatures.length > 0) {
            return true;
        }
        return false;
    }
    /**
     * Returns whether or not the string is a valid protocol public key
     * @param {string | undefined} publicKey - the  public key to be validated
     */
    validatePublicKey(publicKey) {
        if (publicKey !== undefined) {
            try {
                new keyPair_1.CosmosKeyPair({ pub: publicKey });
            }
            catch {
                throw new sdk_core_1.InvalidTransactionError(`Invalid Public Key`);
            }
        }
    }
    /**
     * Creates a sign doc from an cosmos like transaction @see CosmosLikeTransaction
     * @Precondition cosmosLikeTransaction.accountNumber and cosmosLikeTransaction.chainId must be defined
     * @param {CosmosLikeTransaction} cosmosLikeTransaction
     * @returns {SignDoc} sign doc
     */
    createSignDoc(cosmosLikeTransaction, accountNumber, chainId) {
        if (!accountNumber) {
            throw new Error('accountNumber is required to create a sign doc');
        }
        if (!chainId) {
            throw new Error('chainId is required to create a sign doc');
        }
        if (!cosmosLikeTransaction) {
            throw new Error('cosmosLikeTransaction is required to create a sign doc');
        }
        const txRaw = this.createTxRawFromCosmosLikeTransaction(cosmosLikeTransaction);
        return (0, proto_signing_1.makeSignDoc)(txRaw.bodyBytes, txRaw.authInfoBytes, chainId, accountNumber);
    }
    /**
     * Returns whether or not the string is a valid hex
     * @param hexString - hex string format
     * @returns {boolean} true if string is hex else false
     */
    isValidHexString(hexString) {
        return /^[0-9A-Fa-f]*$/.test(hexString);
    }
    /**
     * Validates the WithdrawDelegatorRewardsMessage
     * @param {WithdrawDelegatorRewardsMessage} withdrawRewardsMessage - The WithdrawDelegatorRewardsMessage to validate.
     * @throws {InvalidTransactionError} Throws an error if the validatorAddress or delegatorAddress is invalid or missing.
     */
    validateWithdrawRewardsMessage(withdrawRewardsMessage) {
        if (!withdrawRewardsMessage.validatorAddress ||
            !this.isValidValidatorAddress(withdrawRewardsMessage.validatorAddress)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid WithdrawDelegatorRewardsMessage validatorAddress: ` + withdrawRewardsMessage.validatorAddress);
        }
        if (!withdrawRewardsMessage.delegatorAddress || !this.isValidAddress(withdrawRewardsMessage.delegatorAddress)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid WithdrawDelegatorRewardsMessage delegatorAddress: ` + withdrawRewardsMessage.delegatorAddress);
        }
    }
    /**
     * Helper method to check if the specified properties in an object are missing or null.
     * @param {Object} obj - The object to check.
     * @param {string[]} keys - An array of property keys to check.
     * @throws {Error} Throws an error if any of the specified properties are missing or null.
     */
    isObjPropertyNull(obj, keys) {
        for (const key of keys) {
            if (obj[key] == null) {
                throw new Error(`Missing or null value for property ${key}`);
            }
        }
    }
    /**
     * Validates the DelegateOrUndelegeteMessage
     * @param {DelegateOrUndelegeteMessage} delegateMessage - The DelegateOrUndelegeteMessage to validate.
     * @throws {InvalidTransactionError} Throws an error if the validatorAddress, delegatorAddress, or amount is invalid or missing.
     */
    validateDelegateOrUndelegateMessage(delegateMessage) {
        this.isObjPropertyNull(delegateMessage, ['validatorAddress', 'delegatorAddress']);
        if (!this.isValidValidatorAddress(delegateMessage.validatorAddress)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid DelegateOrUndelegeteMessage validatorAddress: ` + delegateMessage.validatorAddress);
        }
        if (!this.isValidAddress(delegateMessage.delegatorAddress)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid DelegateOrUndelegeteMessage delegatorAddress: ` + delegateMessage.delegatorAddress);
        }
        this.validateAmount(delegateMessage.amount);
    }
    /**
     * Validates the RedelegateMessage
     * @param {DelegateOrUndelegeteMessage} redelegateMessage - The RedelegateMessage to validate.
     * @throws {InvalidTransactionError} Throws an error if the validatorSrcAddress, validatorDstAddress, delegatorAddress, or amount is invalid or missing.
     */
    validateRedelegateMessage(redelegateMessage) {
        this.isObjPropertyNull(redelegateMessage, ['validatorSrcAddress', 'validatorDstAddress', 'delegatorAddress']);
        if (!this.isValidValidatorAddress(redelegateMessage.validatorSrcAddress)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid RedelegateMessage validatorSrcAddress: ` + redelegateMessage.validatorSrcAddress);
        }
        if (!this.isValidValidatorAddress(redelegateMessage.validatorDstAddress)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid RedelegateMessage validatorDstAddress: ` + redelegateMessage.validatorDstAddress);
        }
        if (!this.isValidAddress(redelegateMessage.delegatorAddress)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid DelegateOrUndelegeteMessage delegatorAddress: ` + redelegateMessage.delegatorAddress);
        }
        this.validateAmount(redelegateMessage.amount);
    }
    /**
     * Validates the MessageData
     * @param {MessageData} messageData - The MessageData to validate.
     * @throws {InvalidTransactionError} Throws an error if the messageData is invalid or missing required fields.
     */
    validateMessageData(messageData) {
        if (messageData == null) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid MessageData: undefined`);
        }
        if (messageData.typeUrl == null || this.getTransactionTypeFromTypeUrl(messageData.typeUrl) == null) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid MessageData typeurl: ` + messageData.typeUrl);
        }
        const type = this.getTransactionTypeFromTypeUrl(messageData.typeUrl);
        switch (type) {
            case sdk_core_1.TransactionType.Send: {
                const value = messageData.value;
                this.validateSendMessage(value);
                break;
            }
            case sdk_core_1.TransactionType.StakingActivate:
            case sdk_core_1.TransactionType.StakingDeactivate: {
                const value = messageData.value;
                this.validateDelegateOrUndelegateMessage(value);
                break;
            }
            case sdk_core_1.TransactionType.StakingWithdraw: {
                const value = messageData.value;
                this.validateWithdrawRewardsMessage(value);
                break;
            }
            case sdk_core_1.TransactionType.ContractCall: {
                const value = messageData.value;
                this.validateExecuteContractMessage(value, sdk_core_1.TransactionType.ContractCall);
                break;
            }
            case sdk_core_1.TransactionType.StakingRedelegate: {
                const value = messageData.value;
                this.validateRedelegateMessage(value);
                break;
            }
            default:
                throw new sdk_core_1.InvalidTransactionError(`Invalid MessageData TypeUrl is not supported: ` + messageData.typeUrl);
        }
    }
    /**
     * Validates the Cosmos-like transaction.
     * @param {CosmosLikeTransaction} tx - The transaction to validate.
     * @throws {InvalidTransactionError} Throws an error if the transaction is invalid or missing required fields.
     */
    validateTransaction(tx) {
        this.validateSequence(tx.sequence);
        this.validateGasBudget(tx.gasBudget);
        this.validatePublicKey(tx.publicKey);
        if (tx.sendMessages === undefined || tx.sendMessages.length === 0) {
            throw new sdk_core_1.InvalidTransactionError('Invalid transaction: messages is required');
        }
        else {
            tx.sendMessages.forEach((message) => this.validateMessageData(message));
        }
    }
    /**
     * Creates a Cosmos-like transaction.
     * @param {number} sequence - The sender address sequence number for the transaction.
     * @param {MessageData[]} messages - The array of message data for the transaction.
     * @param {FeeData} gasBudget - The fee data for the transaction.
     * @param {string} [publicKey] - The public key associated with the sender.
     * @param {string} [memo] - The memo for the transaction.
     * @returns {CosmosLikeTransaction} Returns the created Cosmos-like transaction.
     * @throws {InvalidTransactionError} Throws an error if the created transaction is invalid.
     */
    createTransaction(sequence, messages, gasBudget, publicKey, memo) {
        const cosmosLikeTxn = {
            sequence: sequence,
            sendMessages: messages,
            gasBudget: gasBudget,
            publicKey: publicKey,
            memo: memo,
        };
        this.validateTransaction(cosmosLikeTxn);
        return cosmosLikeTxn;
    }
    /**
     * Creates a Cosmos-like transaction with a hash.
     * @param {number} sequence - The sender address sequence number for the transaction.
     * @param {MessageData[]} messages - The array of message data for the transaction.
     * @param {FeeData} gasBudget - The fee data for the transaction.
     * @param {string} [publicKey] - The public key associated with the transaction.
     * @param {Buffer} [signature] - The signature for the transaction.
     * @param {string} [memo] - The memo for the transaction.
     * @returns {CosmosLikeTransaction} Returns the created Cosmos-like transaction with the hash and signature if provided.
     */
    createTransactionWithHash(sequence, messages, gasBudget, publicKey, signature, memo) {
        const cosmosLikeTxn = this.createTransaction(sequence, messages, gasBudget, publicKey, memo);
        let hash = constants.UNAVAILABLE_TEXT;
        if (signature !== undefined) {
            const unsignedTx = this.createTxRawFromCosmosLikeTransaction(cosmosLikeTxn);
            const signedTx = tx_1.TxRaw.fromPartial({
                bodyBytes: unsignedTx.bodyBytes,
                authInfoBytes: unsignedTx.authInfoBytes,
                signatures: [signature],
            });
            hash = (0, crypto_1.createHash)('sha256')
                .update(tx_1.TxRaw.encode(signedTx).finish())
                .digest()
                .toString('hex')
                .toLocaleUpperCase('en-US');
            return { ...cosmosLikeTxn, hash: hash, signature: signature };
        }
        return { ...cosmosLikeTxn, hash: hash };
    }
    /**
     * Deserializes base64 enocded raw transaction string into @see CosmosLikeTransaction
     * @param {string} rawTx base64 enocded raw transaction string
     * @returns {CosmosLikeTransaction} Deserialized cosmosLikeTransaction
     */
    deserializeTransaction(rawTx) {
        var _a, _b;
        const decodedTx = this.getDecodedTxFromRawBase64(rawTx);
        const typeUrl = this.getTypeUrlFromDecodedTx(decodedTx);
        const type = this.getTransactionTypeFromTypeUrl(typeUrl);
        let sendMessageData;
        if (type === sdk_core_1.TransactionType.Send) {
            sendMessageData = this.getSendMessageDataFromDecodedTx(decodedTx);
        }
        else if (type === sdk_core_1.TransactionType.StakingActivate || type === sdk_core_1.TransactionType.StakingDeactivate) {
            sendMessageData = this.getDelegateOrUndelegateMessageDataFromDecodedTx(decodedTx);
        }
        else if (type === sdk_core_1.TransactionType.StakingWithdraw) {
            sendMessageData = this.getWithdrawRewardsMessageDataFromDecodedTx(decodedTx);
        }
        else if (type === sdk_core_1.TransactionType.ContractCall) {
            sendMessageData = this.getExecuteContractMessageDataFromDecodedTx(decodedTx);
        }
        else if (type === sdk_core_1.TransactionType.StakingRedelegate) {
            sendMessageData = this.getRedelegateMessageDataFromDecodedTx(decodedTx);
        }
        else {
            throw new Error('Transaction type not supported: ' + typeUrl);
        }
        const sequence = this.getSequenceFromDecodedTx(decodedTx);
        const gasBudget = this.getGasBudgetFromDecodedTx(decodedTx);
        const publicKey = this.getPublicKeyFromDecodedTx(decodedTx);
        const signature = ((_a = decodedTx.signatures) === null || _a === void 0 ? void 0 : _a[0]) !== undefined ? Buffer.from(decodedTx.signatures[0]) : undefined;
        return this.createTransactionWithHash(sequence, sendMessageData, gasBudget, publicKey, signature, (_b = decodedTx.body) === null || _b === void 0 ? void 0 : _b.memo);
    }
    /**
     * Validates an array of coin amounts.
     * @param {Coin[]} amountArray - The array of coin amounts to validate.
     * @param {TransactionType} transactionType - optional field for transaction type
     */
    validateAmountData(amountArray, transactionType) {
        amountArray.forEach((coinAmount) => {
            this.validateAmount(coinAmount, transactionType);
        });
    }
    /**
     * Validates the gas limit and gas amount for a transaction.
     * @param {FeeData} gasBudget - The gas budget to validate.
     * @throws {InvalidTransactionError} Throws an error if the gas budget is invalid.
     */
    validateGasBudget(gasBudget) {
        if (gasBudget.gasLimit <= 0) {
            throw new sdk_core_1.InvalidTransactionError('Invalid gas limit ' + gasBudget.gasLimit);
        }
        this.validateAmountData(gasBudget.amount);
    }
    /**
     * Validates a send message for a transaction.
     * @param {SendMessage} sendMessage - The send message to validate.
     * @throws {InvalidTransactionError} Throws an error if the send message is invalid.
     */
    validateSendMessage(sendMessage) {
        if (!sendMessage.toAddress || !this.isValidAddress(sendMessage.toAddress)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid SendMessage toAddress: ` + sendMessage.toAddress);
        }
        if (!sendMessage.fromAddress || !this.isValidAddress(sendMessage.fromAddress)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid SendMessage fromAddress: ` + sendMessage.fromAddress);
        }
        this.validateAmountData(sendMessage.amount);
    }
    /**
     * Validates a coin amount.
     * @param {Coin} amount - The coin amount to validate.
     * @param {TransactionType} transactionType - optional field for transaction type
     * @throws {InvalidTransactionError} Throws an error if the coin amount is invalid.
     */
    validateAmount(amount, transactionType) {
        throw new sdk_core_1.NotImplementedError('validateAmount not implemented');
    }
    /**
     * Checks if a cosmos like Bech32 address matches given regular expression and
     * validates memoId if present
     * @param {string} address
     * @param {RegExp} regExp Regular expression to validate the root address against after trimming the memoId
     * @returns {boolean} true if address is valid
     */
    isValidCosmosLikeAddressWithMemoId(address, regExp) {
        if (typeof address !== 'string')
            return false;
        const addressArray = address.split('?memoId=');
        if (![1, 2].includes(addressArray.length) || // should have at most one occurrence of 'memoId='
            !this.isValidBech32AddressMatchingRegex(addressArray[0], regExp) ||
            (addressArray[1] && !this.isValidMemoId(addressArray[1]))) {
            return false;
        }
        return true;
    }
    /**
     * Checks if address is valid Bech32 and matches given regular expression
     * @param {string} address
     * @param {RegExp} regExp Regular expression to validate the address against
     * @returns {boolean} true if address is valid
     */
    isValidBech32AddressMatchingRegex(address, regExp) {
        try {
            (0, encoding_1.fromBech32)(address);
        }
        catch (e) {
            return false;
        }
        return regExp.test(address);
    }
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId memo id
     * @returns true if memo id is valid
     */
    isValidMemoId(memoId) {
        let memoIdNumber;
        try {
            memoIdNumber = new bignumber_js_1.default(memoId);
        }
        catch (e) {
            return false;
        }
        return memoIdNumber.gte(0) && memoIdNumber.isInteger();
    }
    /**
     * Validates if the address matches with regex @see accountAddressRegex
     * @param {string} address
     * @returns {boolean} - the validation result
     */
    isValidValidatorAddress(address) {
        throw new sdk_core_1.NotImplementedError('isValidValidatorAddress not implemented');
    }
    /**
     * Validates if the address matches with regex @see accountAddressRegex
     * @param {string} address
     * @returns {boolean} - the validation result
     */
    isValidAddress(address) {
        throw new sdk_core_1.NotImplementedError('isValidAddress not implemented');
    }
    /**
     * Validates if the address matches with regex @see contractAddressRegex
     * @param {string} address
     * @returns {boolean} - the validation result
     */
    isValidContractAddress(address) {
        throw new sdk_core_1.NotImplementedError('isValidContractAddress not implemented');
    }
    /**
     * Validates a execute contract message
     * @param {ExecuteContractMessage} message - The execute contract message to validate
     * @param {TransactionType} transactionType - optional field for transaction type
     * @throws {InvalidTransactionError} Throws an error if the message is invalid
     */
    validateExecuteContractMessage(message, transactionType) {
        if (!message.contract || !this.isValidContractAddress(message.contract)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid ExecuteContractMessage contract address: ` + message.contract);
        }
        if (!message.sender || !this.isValidAddress(message.sender)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid ExecuteContractMessage sender address: ` + message.sender);
        }
        if (!message.msg) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid ExecuteContractMessage msg: ` + message.msg);
        }
        if (message.funds) {
            this.validateAmountData(message.funds, transactionType);
        }
    }
    /**
     * Get coin specific hash function
     * @returns {Hash} The hash function
     */
    getHashFunction() {
        return (0, crypto_1.createHash)('sha256');
    }
}
exports.CosmosUtils = CosmosUtils;
const utils = new CosmosUtils();
exports.default = utils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDhDQU15QjtBQUN6Qix5Q0FBZ0Y7QUFDaEYsK0NBQW9GO0FBQ3BGLHlEQVMrQjtBQUMvQiwrQ0FBOEQ7QUFDOUQsK0NBQXFDO0FBQ3JDLDBEQUFtRTtBQUVuRSx5REFBc0U7QUFFdEUsbUNBQTBDO0FBQzFDLHlDQUF5QztBQVd6Qyx1Q0FBcUQ7QUFFckQsTUFBYSxXQUFXO0lBR3RCO1FBQ0UsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLHdCQUFRLENBQUMsQ0FBQyxHQUFHLCtCQUFvQixDQUFDLENBQUMsQ0FBQztRQUN4RCxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMseUJBQXlCLEVBQUUsdUJBQWtCLENBQUMsQ0FBQztJQUNsRixDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLGNBQWMsQ0FBQyxJQUFZO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLGlCQUFpQixDQUFDLEdBQVc7UUFDM0IsSUFBSTtZQUNGLElBQUksdUJBQU8sQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQzFCLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFBQyxNQUFNO1lBQ04sT0FBTyxLQUFLLENBQUM7U0FDZDtJQUNILENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsZ0JBQWdCLENBQUMsR0FBVztRQUMxQixJQUFJO1lBQ0YsSUFBSSx1QkFBTyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFDMUIsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUFDLE1BQU07WUFDTixPQUFPLEtBQUssQ0FBQztTQUNkO0lBQ0gsQ0FBQztJQUVELGtCQUFrQjtJQUNsQixnQkFBZ0IsQ0FB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QyxJQUFJLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ3ZFLE1BQU0sSUFBSSxrQ0FBdUIsQ0FBQyxtREFBbUQsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDM0c7UUFDRCxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQzNELE1BQU0sSUFBSSxrQ0FBdUIsQ0FBQyxpREFBaUQsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDdkc7UUFDRCxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRTtZQUNoQixNQUFNLElBQUksa0NBQXVCLENBQUMsc0NBQXNDLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3pGO1FBQ0QsSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFO1lBQ2pCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLGVBQWUsQ0FBQyxDQUFDO1NBQ3pEO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNILGVBQWU7UUFDYixPQUFPLElBQUEsbUJBQVUsRUFBQyxRQUFRLENBQUMsQ0FBQztJQUM5QixDQUFDO0NBQ0Y7QUFoMUJELGtDQWcxQkM7QUFFRCxNQUFNLEtBQUssR0FBRyxJQUFJLFdBQVcsRUFBRSxDQUFDO0FBRWhDLGtCQUFlLEtBQUssQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEJhc2VVdGlscyxcbiAgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IsXG4gIE5vdEltcGxlbWVudGVkRXJyb3IsXG4gIFBhcnNlVHJhbnNhY3Rpb25FcnJvcixcbiAgVHJhbnNhY3Rpb25UeXBlLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgZW5jb2RlU2VjcDI1NmsxUHVia2V5LCBlbmNvZGVTZWNwMjU2azFTaWduYXR1cmUgfSBmcm9tICdAY29zbWpzL2FtaW5vJztcbmltcG9ydCB7IGZyb21CYXNlNjQsIGZyb21CZWNoMzIsIGZyb21IZXgsIHRvSGV4LCB0b0JlY2gzMiB9IGZyb20gJ0Bjb3NtanMvZW5jb2RpbmcnO1xuaW1wb3J0IHtcbiAgRGVjb2RlZFR4UmF3LFxuICBFbmNvZGVPYmplY3QsXG4gIFJlZ2lzdHJ5LFxuICBkZWNvZGVQdWJrZXksXG4gIGRlY29kZVR4UmF3LFxuICBlbmNvZGVQdWJrZXksXG4gIG1ha2VBdXRoSW5mb0J5dGVzLFxuICBtYWtlU2lnbkRvYyxcbn0gZnJvbSAnQGNvc21qcy9wcm90by1zaWduaW5nJztcbmltcG9ydCB7IENvaW4sIGRlZmF1bHRSZWdpc3RyeVR5cGVzIH0gZnJvbSAnQGNvc21qcy9zdGFyZ2F0ZSc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBTaWduRG9jLCBUeFJhdyB9IGZyb20gJ2Nvc21qcy10eXBlcy9jb3Ntb3MvdHgvdjFiZXRhMS90eCc7XG5pbXBvcnQgeyBBbnkgfSBmcm9tICdjb3NtanMtdHlwZXMvZ29vZ2xlL3Byb3RvYnVmL2FueSc7XG5pbXBvcnQgeyBNc2dFeGVjdXRlQ29udHJhY3QgfSBmcm9tICdjb3NtanMtdHlwZXMvY29zbXdhc20vd2FzbS92MS90eCc7XG5cbmltcG9ydCB7IEhhc2gsIGNyZWF0ZUhhc2ggfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7XG4gIENvc21vc0xpa2VUcmFuc2FjdGlvbixcbiAgRGVsZWdhdGVPclVuZGVsZWdldGVNZXNzYWdlLFxuICBFeGVjdXRlQ29udHJhY3RNZXNzYWdlLFxuICBGZWVEYXRhLFxuICBNZXNzYWdlRGF0YSxcbiAgUmVkZWxlZ2F0ZU1lc3NhZ2UsXG4gIFNlbmRNZXNzYWdlLFxuICBXaXRoZHJhd0RlbGVnYXRvclJld2FyZHNNZXNzYWdlLFxufSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IENvc21vc0tleVBhaXIgYXMgS2V5UGFpciB9IGZyb20gJy4va2V5UGFpcic7XG5cbmV4cG9ydCBjbGFzcyBDb3Ntb3NVdGlscyBpbXBsZW1lbnRzIEJhc2VVdGlscyB7XG4gIHByaXZhdGUgcmVnaXN0cnk7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZWdpc3RyeSA9IG5ldyBSZWdpc3RyeShbLi4uZGVmYXVsdFJlZ2lzdHJ5VHlwZXNdKTtcbiAgICB0aGlzLnJlZ2lzdHJ5LnJlZ2lzdGVyKGNvbnN0YW50cy5leGVjdXRlQ29udHJhY3RNc2dUeXBlVXJsLCBNc2dFeGVjdXRlQ29udHJhY3QpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRCbG9ja0lkKGhhc2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlQmxha2UyYihoYXNoKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkUHJpdmF0ZUtleShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBuZXcgS2V5UGFpcih7IHBydjoga2V5IH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRQdWJsaWNLZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEtleVBhaXIoeyBwdWI6IGtleSB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkU2lnbmF0dXJlKHNpZ25hdHVyZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ2lzVmFsaWRTaWduYXR1cmUgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZFRyYW5zYWN0aW9uSWQodHhJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGVCbGFrZTJiKHR4SWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0cmFuc2FjdGlvbiBoYXNoIGlzIGluIHZhbGlkIGJsYWNrMmIgZm9ybWF0XG4gICAqL1xuICB2YWxpZGF0ZUJsYWtlMmIoaGFzaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKGhhc2g/Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2gubWF0Y2goL15bYS16QS1aMC05XSskLykgIT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHdoZXRoZXIgYW1vdW50cyBhcmUgaW4gcmFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gYW1vdW50cyAtIHRoZSBhbW91bnRzIHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgaXNWYWxpZEFtb3VudHMoYW1vdW50czogbnVtYmVyW10pOiBib29sZWFuIHtcbiAgICBmb3IgKGNvbnN0IGFtb3VudCBvZiBhbW91bnRzKSB7XG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZEFtb3VudChhbW91bnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHdoZXRoZXIgYW1vdW50IGlzIGluIHJhbmdlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgaXNWYWxpZEFtb3VudChhbW91bnQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGJpZ051bWJlckFtb3VudCA9IG5ldyBCaWdOdW1iZXIoYW1vdW50KTtcbiAgICBpZiAoIWJpZ051bWJlckFtb3VudC5pc0ludGVnZXIoKSB8fCBiaWdOdW1iZXJBbW91bnQuaXNMZXNzVGhhbk9yRXF1YWxUbygwKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGVzIHJhdyB0eCBkYXRhIGludG8gbWVzc2FnZXMsIHNpZ25pbmcgaW5mbywgYW5kIGZlZSBkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eEhleCAtIHJhdyBiYXNlNjQgdHhcbiAgICogQHJldHVybnMge0RlY29kZWRUeFJhd30gRGVjb2RlZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgZ2V0RGVjb2RlZFR4RnJvbVJhd0Jhc2U2NCh0eFJhdzogc3RyaW5nKTogRGVjb2RlZFR4UmF3IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGRlY29kZVR4UmF3KGZyb21CYXNlNjQodHhSYXcpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VUcmFuc2FjdGlvbkVycm9yKCdFcnJvciBkZWNvZGluZyBUeFJhdyBiYXNlNjQgZW5jb2RlZCBzdHJpbmc6ICcgKyBlLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBtZXNzYWdlcyBpbiB0aGUgYm9keSBvZiB0aGUgZGVjb2RlZCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0RlY29kZWRUeFJhd30gZGVjb2RlZFR4XG4gICAqIEByZXR1cm5zIHtFbmNvZGVPYmplY3RbXX0gbWVzc2FnZXMgYWxvbmcgd2l0aCB0eXBlIHVybFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRFbmNvZGVkTWVzc2FnZXNGcm9tRGVjb2RlZFR4KGRlY29kZWRUeDogRGVjb2RlZFR4UmF3KTogRW5jb2RlT2JqZWN0W10ge1xuICAgIHJldHVybiBkZWNvZGVkVHguYm9keS5tZXNzYWdlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIHR4biBzZXF1ZW5jZSBpcyB2YWxpZCBvciBub3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlcXVlbmNlXG4gICAqL1xuICB2YWxpZGF0ZVNlcXVlbmNlKHNlcXVlbmNlOiBudW1iZXIpIHtcbiAgICBpZiAoc2VxdWVuY2UgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgc2VxdWVuY2U6IGxlc3MgdGhhbiB6ZXJvJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1bGxzIHRoZSBzZXF1ZW5jZSBudW1iZXIgZnJvbSBhIERlY29kZWRUeFJhdyBBdXRoSW5mbyBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge0RlY29kZWRUeFJhd30gZGVjb2RlZFR4XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHNlcXVlbmNlXG4gICAqL1xuICBnZXRTZXF1ZW5jZUZyb21EZWNvZGVkVHgoZGVjb2RlZFR4OiBEZWNvZGVkVHhSYXcpOiBudW1iZXIge1xuICAgIHJldHVybiBOdW1iZXIoZGVjb2RlZFR4LmF1dGhJbmZvLnNpZ25lckluZm9zWzBdLnNlcXVlbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWxscyB0aGUgdHlwZVVybCBmcm9tIHRoZSBlbmNvZGVkIG1lc3NhZ2Ugb2YgYSBEZWNvZGVkVHhSYXdcbiAgICogQHBhcmFtIHtEZWNvZGVkVHhSYXd9IGRlY29kZWRUeFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjb3Ntb3MgcHJvdG8gdHlwZSB1cmxcbiAgICovXG4gIGdldFR5cGVVcmxGcm9tRGVjb2RlZFR4KGRlY29kZWRUeDogRGVjb2RlZFR4UmF3KTogc3RyaW5nIHtcbiAgICBjb25zdCBlbmNvZGVkTWVzc2FnZSA9IHRoaXMuZ2V0RW5jb2RlZE1lc3NhZ2VzRnJvbURlY29kZWRUeChkZWNvZGVkVHgpWzBdO1xuICAgIHJldHVybiBlbmNvZGVkTWVzc2FnZS50eXBlVXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZlZSBkYXRhIGZyb20gdGhlIGRlY29kZWQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtEZWNvZGVkVHhSYXd9IGRlY29kZWRUeFxuICAgKiBAcmV0dXJucyB7RmVlRGF0YX0gZmVlIGRhdGFcbiAgICovXG4gIGdldEdhc0J1ZGdldEZyb21EZWNvZGVkVHgoZGVjb2RlZFR4OiBEZWNvZGVkVHhSYXcpOiBGZWVEYXRhIHtcbiAgICByZXR1cm4ge1xuICAgICAgYW1vdW50OiBkZWNvZGVkVHguYXV0aEluZm8uZmVlPy5hbW91bnQgYXMgQ29pbltdLFxuICAgICAgZ2FzTGltaXQ6IE51bWJlcihkZWNvZGVkVHguYXV0aEluZm8uZmVlPy5nYXNMaW1pdCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwdWJsaWNLZXkgZnJvbSB0aGUgZGVjb2RlZCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0RlY29kZWRUeFJhd30gZGVjb2RlZFR4XG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IHB1YmxpY0tleSBpbiBoZXggZm9ybWF0IGlmIGl0IGV4aXN0cywgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgKi9cbiAgZ2V0UHVibGljS2V5RnJvbURlY29kZWRUeChkZWNvZGVkVHg6IERlY29kZWRUeFJhdyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcHVibGljS2V5VUludDhBcnJheSA9IGRlY29kZWRUeC5hdXRoSW5mby5zaWduZXJJbmZvcz8uWzBdLnB1YmxpY0tleT8udmFsdWU7XG4gICAgaWYgKHB1YmxpY0tleVVJbnQ4QXJyYXkpIHtcbiAgICAgIHJldHVybiB0b0hleChmcm9tQmFzZTY0KGRlY29kZVB1YmtleShkZWNvZGVkVHguYXV0aEluZm8uc2lnbmVySW5mb3M/LlswXS5wdWJsaWNLZXkpPy52YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFycmF5IG9mIE1lc3NhZ2VEYXRhW10gZnJvbSB0aGUgZGVjb2RlZCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0RlY29kZWRUeFJhd30gZGVjb2RlZFR4XG4gICAqIEByZXR1cm5zIHtNZXNzYWdlRGF0YVtdfSBTZW5kIHRyYW5zYWN0aW9uIG1lc3NhZ2UgZGF0YVxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFNlbmRNZXNzYWdlRGF0YUZyb21EZWNvZGVkVHgoZGVjb2RlZFR4OiBEZWNvZGVkVHhSYXcpOiBNZXNzYWdlRGF0YVtdIHtcbiAgICByZXR1cm4gZGVjb2RlZFR4LmJvZHkubWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucmVnaXN0cnkuZGVjb2RlKG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBmcm9tQWRkcmVzczogdmFsdWUuZnJvbUFkZHJlc3MsXG4gICAgICAgICAgdG9BZGRyZXNzOiB2YWx1ZS50b0FkZHJlc3MsXG4gICAgICAgICAgYW1vdW50OiB2YWx1ZS5hbW91bnQsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGVVcmw6IG1lc3NhZ2UudHlwZVVybCxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXJyYXkgb2YgTWVzc2FnZURhdGFbXSBmcm9tIHRoZSBkZWNvZGVkIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7RGVjb2RlZFR4UmF3fSBkZWNvZGVkVHhcbiAgICogQHJldHVybnMge01lc3NhZ2VEYXRhW119IERlbGVnYXRlIG9mIHVuZGVsZWdhdGUgdHJhbnNhY3Rpb24gbWVzc2FnZSBkYXRhXG4gICAqL1xuICBnZXREZWxlZ2F0ZU9yVW5kZWxlZ2F0ZU1lc3NhZ2VEYXRhRnJvbURlY29kZWRUeChkZWNvZGVkVHg6IERlY29kZWRUeFJhdyk6IE1lc3NhZ2VEYXRhW10ge1xuICAgIHJldHVybiBkZWNvZGVkVHguYm9keS5tZXNzYWdlcy5tYXAoKG1lc3NhZ2UpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZWdpc3RyeS5kZWNvZGUobWVzc2FnZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGRlbGVnYXRvckFkZHJlc3M6IHZhbHVlLmRlbGVnYXRvckFkZHJlc3MsXG4gICAgICAgICAgdmFsaWRhdG9yQWRkcmVzczogdmFsdWUudmFsaWRhdG9yQWRkcmVzcyxcbiAgICAgICAgICBhbW91bnQ6IHZhbHVlLmFtb3VudCxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZVVybDogbWVzc2FnZS50eXBlVXJsLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBNZXNzYWdlRGF0YVtdIGZyb20gdGhlIGRlY29kZWQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtEZWNvZGVkVHhSYXd9IGRlY29kZWRUeFxuICAgKiBAcmV0dXJucyB7TWVzc2FnZURhdGFbXX0gUmVkZWxlZ2F0ZSB0cmFuc2FjdGlvbiBtZXNzYWdlIGRhdGFcbiAgICovXG4gIGdldFJlZGVsZWdhdGVNZXNzYWdlRGF0YUZyb21EZWNvZGVkVHgoZGVjb2RlZFR4OiBEZWNvZGVkVHhSYXcpOiBNZXNzYWdlRGF0YVtdIHtcbiAgICByZXR1cm4gZGVjb2RlZFR4LmJvZHkubWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucmVnaXN0cnkuZGVjb2RlKG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBkZWxlZ2F0b3JBZGRyZXNzOiB2YWx1ZS5kZWxlZ2F0b3JBZGRyZXNzLFxuICAgICAgICAgIHZhbGlkYXRvclNyY0FkZHJlc3M6IHZhbHVlLnZhbGlkYXRvclNyY0FkZHJlc3MsXG4gICAgICAgICAgdmFsaWRhdG9yRHN0QWRkcmVzczogdmFsdWUudmFsaWRhdG9yRHN0QWRkcmVzcyxcbiAgICAgICAgICBhbW91bnQ6IHZhbHVlLmFtb3VudCxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZVVybDogbWVzc2FnZS50eXBlVXJsLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBNZXNzYWdlRGF0YVtdIGZyb20gdGhlIGRlY29kZWQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtEZWNvZGVkVHhSYXd9IGRlY29kZWRUeFxuICAgKiBAcmV0dXJucyB7TWVzc2FnZURhdGFbXX0gV2l0aGRyYXdEZWxlZ2F0b3JSZXdhcmRzIHRyYW5zYWN0aW9uIG1lc3NhZ2UgZGF0YVxuICAgKi9cbiAgZ2V0V2l0aGRyYXdSZXdhcmRzTWVzc2FnZURhdGFGcm9tRGVjb2RlZFR4KGRlY29kZWRUeDogRGVjb2RlZFR4UmF3KTogTWVzc2FnZURhdGFbXSB7XG4gICAgcmV0dXJuIGRlY29kZWRUeC5ib2R5Lm1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlZ2lzdHJ5LmRlY29kZShtZXNzYWdlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgZGVsZWdhdG9yQWRkcmVzczogdmFsdWUuZGVsZWdhdG9yQWRkcmVzcyxcbiAgICAgICAgICB2YWxpZGF0b3JBZGRyZXNzOiB2YWx1ZS52YWxpZGF0b3JBZGRyZXNzLFxuICAgICAgICB9LFxuICAgICAgICB0eXBlVXJsOiBtZXNzYWdlLnR5cGVVcmwsXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFycmF5IG9mIE1lc3NhZ2VEYXRhW10gZnJvbSB0aGUgZGVjb2RlZCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0RlY29kZWRUeFJhd30gZGVjb2RlZFR4XG4gICAqIEByZXR1cm5zIHtNZXNzYWdlRGF0YVtdfSBEZWxlZ2F0ZSBvZiB1bmRlbGVnYXRlIHRyYW5zYWN0aW9uIG1lc3NhZ2UgZGF0YVxuICAgKi9cbiAgZ2V0V2l0aGRyYXdEZWxlZ2F0b3JSZXdhcmRzTWVzc2FnZURhdGFGcm9tRGVjb2RlZFR4KGRlY29kZWRUeDogRGVjb2RlZFR4UmF3KTogTWVzc2FnZURhdGFbXSB7XG4gICAgcmV0dXJuIGRlY29kZWRUeC5ib2R5Lm1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlZ2lzdHJ5LmRlY29kZShtZXNzYWdlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgZGVsZWdhdG9yQWRkcmVzczogdmFsdWUuZGVsZWdhdG9yQWRkcmVzcyxcbiAgICAgICAgICB2YWxpZGF0b3JBZGRyZXNzOiB2YWx1ZS52YWxpZGF0b3JBZGRyZXNzLFxuICAgICAgICB9LFxuICAgICAgICB0eXBlVXJsOiBtZXNzYWdlLnR5cGVVcmwsXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGNvc21vcyBjaGFpbiBhZGRyZXNzIGZyb20gaXRzIGVxdWl2YWxlbnQgaGV4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NIZXhcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldENvc21vc0xpa2VBZGRyZXNzRnJvbUhleChwcmVmaXg6IHN0cmluZywgYWRkcmVzc0hleDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoYWRkcmVzc0hleC5pbmRleE9mKCcweCcpID09PSAwKSB7XG4gICAgICBhZGRyZXNzSGV4ID0gYWRkcmVzc0hleC5zbGljZSgyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvQmVjaDMyKHByZWZpeCwgZnJvbUhleChhZGRyZXNzSGV4KSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgRVZNIGNoYWluIGFkZHJlc3MgZnJvbSBpdHMgZXF1aXZhbGVudCBoZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0hleFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0RXZtTGlrZUFkZHJlc3NGcm9tQ29zbW9zKGNvc21vc0xpa2VBZGRyZXNzOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiAnMHgnICsgdG9IZXgoZnJvbUJlY2gzMihjb3Ntb3NMaWtlQWRkcmVzcykuZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXJyYXkgb2YgTWVzc2FnZURhdGFbXSBmcm9tIHRoZSBkZWNvZGVkIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7RGVjb2RlZFR4UmF3fSBkZWNvZGVkVHhcbiAgICogQHJldHVybnMge01lc3NhZ2VEYXRhW119IEV4ZWN1dGUgY29udHJhY3QgdHJhbnNhY3Rpb24gbWVzc2FnZSBkYXRhXG4gICAqL1xuICBnZXRFeGVjdXRlQ29udHJhY3RNZXNzYWdlRGF0YUZyb21EZWNvZGVkVHgoZGVjb2RlZFR4OiBEZWNvZGVkVHhSYXcpOiBNZXNzYWdlRGF0YVtdIHtcbiAgICByZXR1cm4gZGVjb2RlZFR4LmJvZHkubWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucmVnaXN0cnkuZGVjb2RlKG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBzZW5kZXI6IHZhbHVlLnNlbmRlcixcbiAgICAgICAgICBjb250cmFjdDogdmFsdWUuY29udHJhY3QsXG4gICAgICAgICAgbXNnOiB2YWx1ZS5tc2csXG4gICAgICAgICAgZnVuZHM6IHZhbHVlLmZ1bmRzLFxuICAgICAgICB9LFxuICAgICAgICB0eXBlVXJsOiBtZXNzYWdlLnR5cGVVcmwsXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgYml0Z28gdHJhbnNhY3Rpb24gdHlwZSBiYXNlZCBvbiBjb3Ntb3MgcHJvdG8gdHlwZSB1cmxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVVcmxcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uVHlwZSB8IHVuZGVmaW5lZH0gVHJhbnNhY3Rpb25UeXBlIGlmIHVybCBpcyBzdXBwb3J0ZWQgZWxzZSB1bmRlZmluZWRcbiAgICovXG4gIGdldFRyYW5zYWN0aW9uVHlwZUZyb21UeXBlVXJsKHR5cGVVcmw6IHN0cmluZyk6IFRyYW5zYWN0aW9uVHlwZSB8IHVuZGVmaW5lZCB7XG4gICAgc3dpdGNoICh0eXBlVXJsKSB7XG4gICAgICBjYXNlIGNvbnN0YW50cy5zZW5kTXNnVHlwZVVybDpcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZS5TZW5kO1xuICAgICAgY2FzZSBjb25zdGFudHMuZGVsZWdhdGVNc2dUeXBlVXJsOlxuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdBY3RpdmF0ZTtcbiAgICAgIGNhc2UgY29uc3RhbnRzLnVuZGVsZWdhdGVNc2dUeXBlVXJsOlxuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdEZWFjdGl2YXRlO1xuICAgICAgY2FzZSBjb25zdGFudHMud2l0aGRyYXdEZWxlZ2F0b3JSZXdhcmRNc2dUeXBlVXJsOlxuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdXaXRoZHJhdztcbiAgICAgIGNhc2UgY29uc3RhbnRzLmV4ZWN1dGVDb250cmFjdE1zZ1R5cGVVcmw6XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuQ29udHJhY3RDYWxsO1xuICAgICAgY2FzZSBjb25zdGFudHMucmVkZWxlZ2F0ZVR5cGVVcmw6XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ1JlZGVsZWdhdGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlcyBhIGhleCBlbmNvZGVkIHB1YmtleSwgY29udmVydHMgaXQgdG8gdGhlIEFtaW5vIEpTT04gcmVwcmVzZW50YXRpb24gKHR5cGUvdmFsdWUgd3JhcHBlcilcbiAgICogYW5kIHJldHVybnMgaXQgYXMgcHJvdG9idWYgYEFueWBcbiAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmtleSBoZXggZW5jb2RlZCBjb21wcmVzc2VkIHNlY3AyNTZrMSBwdWJsaWMga2V5XG4gICAqIEByZXR1cm5zIHtBbnl9IHB1YmtleSBlbmNvZGVkIGFzIHByb3RvYnVmIGBBbnlgXG4gICAqL1xuICBnZXRFbmNvZGVkUHVia2V5KHB1YmtleTogc3RyaW5nKTogQW55IHtcbiAgICByZXR1cm4gZW5jb2RlUHVia2V5KGVuY29kZVNlY3AyNTZrMVB1YmtleShmcm9tSGV4KHB1YmtleSkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdHhSYXcgZnJvbSBhbiBjb3Ntb3MgbGlrZSB0cmFuc2FjdGlvbiBAc2VlIENvc21vc0xpa2VUcmFuc2FjdGlvblxuICAgKiBAUHJlY29uZGl0aW9uIGNvc21vc0xpa2VUcmFuc2FjdGlvbi5wdWJsaWNLZXkgbXVzdCBiZSBkZWZpbmVkXG4gICAqIEBwYXJhbSB7Q29zbW9zTGlrZVRyYW5zYWN0aW9ufSBjb3Ntb3NMaWtlVHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMge1R4UmF3fSBVbnNpZ25lZCByYXcgdHJhbnNhY3Rpb25cbiAgICovXG4gIGNyZWF0ZVR4UmF3RnJvbUNvc21vc0xpa2VUcmFuc2FjdGlvbihjb3Ntb3NMaWtlVHJhbnNhY3Rpb246IENvc21vc0xpa2VUcmFuc2FjdGlvbik6IFR4UmF3IHtcbiAgICBpZiAoIWNvc21vc0xpa2VUcmFuc2FjdGlvbi5wdWJsaWNLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHVibGljS2V5IGlzIHJlcXVpcmVkIHRvIGNyZWF0ZSBhIHR4UmF3Jyk7XG4gICAgfVxuICAgIGNvbnN0IGVuY29kZWRQdWJsaWNLZXk6IEFueSA9IHRoaXMuZ2V0RW5jb2RlZFB1YmtleShjb3Ntb3NMaWtlVHJhbnNhY3Rpb24ucHVibGljS2V5KTtcbiAgICBjb25zdCBtZXNzYWdlcyA9IGNvc21vc0xpa2VUcmFuc2FjdGlvbi5zZW5kTWVzc2FnZXMgYXMgdW5rbm93biBhcyBBbnlbXTtcbiAgICBsZXQgdHhCb2R5VmFsdWU7XG4gICAgaWYgKGNvc21vc0xpa2VUcmFuc2FjdGlvbi5tZW1vKSB7XG4gICAgICB0eEJvZHlWYWx1ZSA9IHtcbiAgICAgICAgbWVtbzogY29zbW9zTGlrZVRyYW5zYWN0aW9uLm1lbW8sXG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHR4Qm9keVZhbHVlID0ge1xuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXMsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHR4Qm9keUJ5dGVzID0gdGhpcy5yZWdpc3RyeS5lbmNvZGVUeEJvZHkodHhCb2R5VmFsdWUpO1xuICAgIGNvbnN0IHNlcXVlbmNlID0gY29zbW9zTGlrZVRyYW5zYWN0aW9uLnNlcXVlbmNlO1xuICAgIGNvbnN0IGF1dGhJbmZvQnl0ZXMgPSBtYWtlQXV0aEluZm9CeXRlcyhcbiAgICAgIFt7IHB1YmtleTogZW5jb2RlZFB1YmxpY0tleSwgc2VxdWVuY2UgfV0sXG4gICAgICBjb3Ntb3NMaWtlVHJhbnNhY3Rpb24uZ2FzQnVkZ2V0LmFtb3VudCxcbiAgICAgIGNvc21vc0xpa2VUcmFuc2FjdGlvbi5nYXNCdWRnZXQuZ2FzTGltaXQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWRcbiAgICApO1xuICAgIHJldHVybiBUeFJhdy5mcm9tUGFydGlhbCh7XG4gICAgICBib2R5Qnl0ZXM6IHR4Qm9keUJ5dGVzLFxuICAgICAgYXV0aEluZm9CeXRlczogYXV0aEluZm9CeXRlcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGVzIGEgc2lnbmF0dXJlIGludG8gYSB0eFJhd1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljS2V5SGV4IHB1YmxpY0tleSBpbiBoZXggZW5jb2RlZCBzdHJpbmcgZm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaWduYXR1cmVIZXggc2lnbmF0dXJlIGluIGhleCBlbmNvZGVkIHN0cmluZyBmb3JtYXRcbiAgICogQHBhcmFtIHtUeFJhd30gdW5zaWduZWRUeCByYXcgdHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMge1R4UmF3fSBTaWduZWQgcmF3IHRyYW5zYWN0aW9uXG4gICAqL1xuICBjcmVhdGVTaWduZWRUeFJhdyhcbiAgICBwdWJsaWNLZXlIZXg6IHN0cmluZyxcbiAgICBzaWduYXR1cmVIZXg6IHN0cmluZyxcbiAgICB1bnNpZ25lZFR4OiB7IGJvZHlCeXRlczogVWludDhBcnJheTsgYXV0aEluZm9CeXRlczogVWludDhBcnJheSB9XG4gICk6IFR4UmF3IHtcbiAgICBjb25zdCBzdGRTaWduYXR1cmUgPSBlbmNvZGVTZWNwMjU2azFTaWduYXR1cmUoZnJvbUhleChwdWJsaWNLZXlIZXgpLCBmcm9tSGV4KHNpZ25hdHVyZUhleCkpO1xuICAgIHJldHVybiBUeFJhdy5mcm9tUGFydGlhbCh7XG4gICAgICBib2R5Qnl0ZXM6IHVuc2lnbmVkVHguYm9keUJ5dGVzLFxuICAgICAgYXV0aEluZm9CeXRlczogdW5zaWduZWRUeC5hdXRoSW5mb0J5dGVzLFxuICAgICAgc2lnbmF0dXJlczogW2Zyb21CYXNlNjQoc3RkU2lnbmF0dXJlLnNpZ25hdHVyZSldLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZXMgYSByYXcgdHJhbnNhY3Rpb24gaW50byBhIERlY29kZWRUeFJhdyBhbmQgY2hlY2tzIGlmIGl0IGhhcyBub24gZW1wdHkgc2lnbmF0dXJlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcmF3VHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdHJhbnNhY3Rpb24gaXMgc2lnbmVkIGVsc2UgZmFsc2VcbiAgICovXG4gIGlzU2lnbmVkUmF3VHgocmF3VHJhbnNhY3Rpb246IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGRlY29kZWRUeCA9IHRoaXMuZ2V0RGVjb2RlZFR4RnJvbVJhd0Jhc2U2NChyYXdUcmFuc2FjdGlvbik7XG4gICAgaWYgKGRlY29kZWRUeC5zaWduYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgcHJvdG9jb2wgcHVibGljIGtleVxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gcHVibGljS2V5IC0gdGhlICBwdWJsaWMga2V5IHRvIGJlIHZhbGlkYXRlZFxuICAgKi9cbiAgdmFsaWRhdGVQdWJsaWNLZXkocHVibGljS2V5OiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAocHVibGljS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBLZXlQYWlyKHsgcHViOiBwdWJsaWNLZXkgfSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIFB1YmxpYyBLZXlgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNpZ24gZG9jIGZyb20gYW4gY29zbW9zIGxpa2UgdHJhbnNhY3Rpb24gQHNlZSBDb3Ntb3NMaWtlVHJhbnNhY3Rpb25cbiAgICogQFByZWNvbmRpdGlvbiBjb3Ntb3NMaWtlVHJhbnNhY3Rpb24uYWNjb3VudE51bWJlciBhbmQgY29zbW9zTGlrZVRyYW5zYWN0aW9uLmNoYWluSWQgbXVzdCBiZSBkZWZpbmVkXG4gICAqIEBwYXJhbSB7Q29zbW9zTGlrZVRyYW5zYWN0aW9ufSBjb3Ntb3NMaWtlVHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMge1NpZ25Eb2N9IHNpZ24gZG9jXG4gICAqL1xuICBjcmVhdGVTaWduRG9jKFxuICAgIGNvc21vc0xpa2VUcmFuc2FjdGlvbjogQ29zbW9zTGlrZVRyYW5zYWN0aW9uLFxuICAgIGFjY291bnROdW1iZXI6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgICBjaGFpbklkOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgKTogU2lnbkRvYyB7XG4gICAgaWYgKCFhY2NvdW50TnVtYmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FjY291bnROdW1iZXIgaXMgcmVxdWlyZWQgdG8gY3JlYXRlIGEgc2lnbiBkb2MnKTtcbiAgICB9XG4gICAgaWYgKCFjaGFpbklkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoYWluSWQgaXMgcmVxdWlyZWQgdG8gY3JlYXRlIGEgc2lnbiBkb2MnKTtcbiAgICB9XG4gICAgaWYgKCFjb3Ntb3NMaWtlVHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY29zbW9zTGlrZVRyYW5zYWN0aW9uIGlzIHJlcXVpcmVkIHRvIGNyZWF0ZSBhIHNpZ24gZG9jJyk7XG4gICAgfVxuICAgIGNvbnN0IHR4UmF3ID0gdGhpcy5jcmVhdGVUeFJhd0Zyb21Db3Ntb3NMaWtlVHJhbnNhY3Rpb24oY29zbW9zTGlrZVRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gbWFrZVNpZ25Eb2ModHhSYXcuYm9keUJ5dGVzLCB0eFJhdy5hdXRoSW5mb0J5dGVzLCBjaGFpbklkLCBhY2NvdW50TnVtYmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBoZXhcbiAgICogQHBhcmFtIGhleFN0cmluZyAtIGhleCBzdHJpbmcgZm9ybWF0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHN0cmluZyBpcyBoZXggZWxzZSBmYWxzZVxuICAgKi9cbiAgaXNWYWxpZEhleFN0cmluZyhoZXhTdHJpbmc6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAvXlswLTlBLUZhLWZdKiQvLnRlc3QoaGV4U3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIFdpdGhkcmF3RGVsZWdhdG9yUmV3YXJkc01lc3NhZ2VcbiAgICogQHBhcmFtIHtXaXRoZHJhd0RlbGVnYXRvclJld2FyZHNNZXNzYWdlfSB3aXRoZHJhd1Jld2FyZHNNZXNzYWdlIC0gVGhlIFdpdGhkcmF3RGVsZWdhdG9yUmV3YXJkc01lc3NhZ2UgdG8gdmFsaWRhdGUuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRUcmFuc2FjdGlvbkVycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHZhbGlkYXRvckFkZHJlc3Mgb3IgZGVsZWdhdG9yQWRkcmVzcyBpcyBpbnZhbGlkIG9yIG1pc3NpbmcuXG4gICAqL1xuICB2YWxpZGF0ZVdpdGhkcmF3UmV3YXJkc01lc3NhZ2Uod2l0aGRyYXdSZXdhcmRzTWVzc2FnZTogV2l0aGRyYXdEZWxlZ2F0b3JSZXdhcmRzTWVzc2FnZSkge1xuICAgIGlmIChcbiAgICAgICF3aXRoZHJhd1Jld2FyZHNNZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgfHxcbiAgICAgICF0aGlzLmlzVmFsaWRWYWxpZGF0b3JBZGRyZXNzKHdpdGhkcmF3UmV3YXJkc01lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihcbiAgICAgICAgYEludmFsaWQgV2l0aGRyYXdEZWxlZ2F0b3JSZXdhcmRzTWVzc2FnZSB2YWxpZGF0b3JBZGRyZXNzOiBgICsgd2l0aGRyYXdSZXdhcmRzTWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXdpdGhkcmF3UmV3YXJkc01lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyB8fCAhdGhpcy5pc1ZhbGlkQWRkcmVzcyh3aXRoZHJhd1Jld2FyZHNNZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIFdpdGhkcmF3RGVsZWdhdG9yUmV3YXJkc01lc3NhZ2UgZGVsZWdhdG9yQWRkcmVzczogYCArIHdpdGhkcmF3UmV3YXJkc01lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzc1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byBjaGVjayBpZiB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMgaW4gYW4gb2JqZWN0IGFyZSBtaXNzaW5nIG9yIG51bGwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBrZXlzIC0gQW4gYXJyYXkgb2YgcHJvcGVydHkga2V5cyB0byBjaGVjay5cbiAgICogQHRocm93cyB7RXJyb3J9IFRocm93cyBhbiBlcnJvciBpZiBhbnkgb2YgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzIGFyZSBtaXNzaW5nIG9yIG51bGwuXG4gICAqL1xuICBpc09ialByb3BlcnR5TnVsbChvYmo6IHsgW2tleTogc3RyaW5nXTogYW55IH0sIGtleXM6IEFycmF5PHN0cmluZz4pIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAob2JqW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3Npbmcgb3IgbnVsbCB2YWx1ZSBmb3IgcHJvcGVydHkgJHtrZXl9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgRGVsZWdhdGVPclVuZGVsZWdldGVNZXNzYWdlXG4gICAqIEBwYXJhbSB7RGVsZWdhdGVPclVuZGVsZWdldGVNZXNzYWdlfSBkZWxlZ2F0ZU1lc3NhZ2UgLSBUaGUgRGVsZWdhdGVPclVuZGVsZWdldGVNZXNzYWdlIHRvIHZhbGlkYXRlLlxuICAgKiBAdGhyb3dzIHtJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcn0gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSB2YWxpZGF0b3JBZGRyZXNzLCBkZWxlZ2F0b3JBZGRyZXNzLCBvciBhbW91bnQgaXMgaW52YWxpZCBvciBtaXNzaW5nLlxuICAgKi9cbiAgdmFsaWRhdGVEZWxlZ2F0ZU9yVW5kZWxlZ2F0ZU1lc3NhZ2UoZGVsZWdhdGVNZXNzYWdlOiBEZWxlZ2F0ZU9yVW5kZWxlZ2V0ZU1lc3NhZ2UpIHtcbiAgICB0aGlzLmlzT2JqUHJvcGVydHlOdWxsKGRlbGVnYXRlTWVzc2FnZSwgWyd2YWxpZGF0b3JBZGRyZXNzJywgJ2RlbGVnYXRvckFkZHJlc3MnXSk7XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZFZhbGlkYXRvckFkZHJlc3MoZGVsZWdhdGVNZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIERlbGVnYXRlT3JVbmRlbGVnZXRlTWVzc2FnZSB2YWxpZGF0b3JBZGRyZXNzOiBgICsgZGVsZWdhdGVNZXNzYWdlLnZhbGlkYXRvckFkZHJlc3NcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhkZWxlZ2F0ZU1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihcbiAgICAgICAgYEludmFsaWQgRGVsZWdhdGVPclVuZGVsZWdldGVNZXNzYWdlIGRlbGVnYXRvckFkZHJlc3M6IGAgKyBkZWxlZ2F0ZU1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzc1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy52YWxpZGF0ZUFtb3VudChkZWxlZ2F0ZU1lc3NhZ2UuYW1vdW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIFJlZGVsZWdhdGVNZXNzYWdlXG4gICAqIEBwYXJhbSB7RGVsZWdhdGVPclVuZGVsZWdldGVNZXNzYWdlfSByZWRlbGVnYXRlTWVzc2FnZSAtIFRoZSBSZWRlbGVnYXRlTWVzc2FnZSB0byB2YWxpZGF0ZS5cbiAgICogQHRocm93cyB7SW52YWxpZFRyYW5zYWN0aW9uRXJyb3J9IFRocm93cyBhbiBlcnJvciBpZiB0aGUgdmFsaWRhdG9yU3JjQWRkcmVzcywgdmFsaWRhdG9yRHN0QWRkcmVzcywgZGVsZWdhdG9yQWRkcmVzcywgb3IgYW1vdW50IGlzIGludmFsaWQgb3IgbWlzc2luZy5cbiAgICovXG4gIHZhbGlkYXRlUmVkZWxlZ2F0ZU1lc3NhZ2UocmVkZWxlZ2F0ZU1lc3NhZ2U6IFJlZGVsZWdhdGVNZXNzYWdlKSB7XG4gICAgdGhpcy5pc09ialByb3BlcnR5TnVsbChyZWRlbGVnYXRlTWVzc2FnZSwgWyd2YWxpZGF0b3JTcmNBZGRyZXNzJywgJ3ZhbGlkYXRvckRzdEFkZHJlc3MnLCAnZGVsZWdhdG9yQWRkcmVzcyddKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkVmFsaWRhdG9yQWRkcmVzcyhyZWRlbGVnYXRlTWVzc2FnZS52YWxpZGF0b3JTcmNBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKFxuICAgICAgICBgSW52YWxpZCBSZWRlbGVnYXRlTWVzc2FnZSB2YWxpZGF0b3JTcmNBZGRyZXNzOiBgICsgcmVkZWxlZ2F0ZU1lc3NhZ2UudmFsaWRhdG9yU3JjQWRkcmVzc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRWYWxpZGF0b3JBZGRyZXNzKHJlZGVsZWdhdGVNZXNzYWdlLnZhbGlkYXRvckRzdEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIFJlZGVsZWdhdGVNZXNzYWdlIHZhbGlkYXRvckRzdEFkZHJlc3M6IGAgKyByZWRlbGVnYXRlTWVzc2FnZS52YWxpZGF0b3JEc3RBZGRyZXNzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MocmVkZWxlZ2F0ZU1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihcbiAgICAgICAgYEludmFsaWQgRGVsZWdhdGVPclVuZGVsZWdldGVNZXNzYWdlIGRlbGVnYXRvckFkZHJlc3M6IGAgKyByZWRlbGVnYXRlTWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnZhbGlkYXRlQW1vdW50KHJlZGVsZWdhdGVNZXNzYWdlLmFtb3VudCk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBNZXNzYWdlRGF0YVxuICAgKiBAcGFyYW0ge01lc3NhZ2VEYXRhfSBtZXNzYWdlRGF0YSAtIFRoZSBNZXNzYWdlRGF0YSB0byB2YWxpZGF0ZS5cbiAgICogQHRocm93cyB7SW52YWxpZFRyYW5zYWN0aW9uRXJyb3J9IFRocm93cyBhbiBlcnJvciBpZiB0aGUgbWVzc2FnZURhdGEgaXMgaW52YWxpZCBvciBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkcy5cbiAgICovXG4gIHZhbGlkYXRlTWVzc2FnZURhdGEobWVzc2FnZURhdGE6IE1lc3NhZ2VEYXRhKTogdm9pZCB7XG4gICAgaWYgKG1lc3NhZ2VEYXRhID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBNZXNzYWdlRGF0YTogdW5kZWZpbmVkYCk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlRGF0YS50eXBlVXJsID09IG51bGwgfHwgdGhpcy5nZXRUcmFuc2FjdGlvblR5cGVGcm9tVHlwZVVybChtZXNzYWdlRGF0YS50eXBlVXJsKSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgTWVzc2FnZURhdGEgdHlwZXVybDogYCArIG1lc3NhZ2VEYXRhLnR5cGVVcmwpO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFRyYW5zYWN0aW9uVHlwZUZyb21UeXBlVXJsKG1lc3NhZ2VEYXRhLnR5cGVVcmwpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU2VuZDoge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG1lc3NhZ2VEYXRhLnZhbHVlIGFzIFNlbmRNZXNzYWdlO1xuICAgICAgICB0aGlzLnZhbGlkYXRlU2VuZE1lc3NhZ2UodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdBY3RpdmF0ZTpcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdEZWFjdGl2YXRlOiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbWVzc2FnZURhdGEudmFsdWUgYXMgRGVsZWdhdGVPclVuZGVsZWdldGVNZXNzYWdlO1xuICAgICAgICB0aGlzLnZhbGlkYXRlRGVsZWdhdGVPclVuZGVsZWdhdGVNZXNzYWdlKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nV2l0aGRyYXc6IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBtZXNzYWdlRGF0YS52YWx1ZSBhcyBXaXRoZHJhd0RlbGVnYXRvclJld2FyZHNNZXNzYWdlO1xuICAgICAgICB0aGlzLnZhbGlkYXRlV2l0aGRyYXdSZXdhcmRzTWVzc2FnZSh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuQ29udHJhY3RDYWxsOiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbWVzc2FnZURhdGEudmFsdWUgYXMgRXhlY3V0ZUNvbnRyYWN0TWVzc2FnZTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUV4ZWN1dGVDb250cmFjdE1lc3NhZ2UodmFsdWUsIFRyYW5zYWN0aW9uVHlwZS5Db250cmFjdENhbGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdSZWRlbGVnYXRlOiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbWVzc2FnZURhdGEudmFsdWUgYXMgUmVkZWxlZ2F0ZU1lc3NhZ2U7XG4gICAgICAgIHRoaXMudmFsaWRhdGVSZWRlbGVnYXRlTWVzc2FnZSh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIE1lc3NhZ2VEYXRhIFR5cGVVcmwgaXMgbm90IHN1cHBvcnRlZDogYCArIG1lc3NhZ2VEYXRhLnR5cGVVcmwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIENvc21vcy1saWtlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge0Nvc21vc0xpa2VUcmFuc2FjdGlvbn0gdHggLSBUaGUgdHJhbnNhY3Rpb24gdG8gdmFsaWRhdGUuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRUcmFuc2FjdGlvbkVycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGludmFsaWQgb3IgbWlzc2luZyByZXF1aXJlZCBmaWVsZHMuXG4gICAqL1xuICB2YWxpZGF0ZVRyYW5zYWN0aW9uKHR4OiBDb3Ntb3NMaWtlVHJhbnNhY3Rpb24pOiB2b2lkIHtcbiAgICB0aGlzLnZhbGlkYXRlU2VxdWVuY2UodHguc2VxdWVuY2UpO1xuICAgIHRoaXMudmFsaWRhdGVHYXNCdWRnZXQodHguZ2FzQnVkZ2V0KTtcbiAgICB0aGlzLnZhbGlkYXRlUHVibGljS2V5KHR4LnB1YmxpY0tleSk7XG4gICAgaWYgKHR4LnNlbmRNZXNzYWdlcyA9PT0gdW5kZWZpbmVkIHx8IHR4LnNlbmRNZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbjogbWVzc2FnZXMgaXMgcmVxdWlyZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHguc2VuZE1lc3NhZ2VzLmZvckVhY2goKG1lc3NhZ2UpID0+IHRoaXMudmFsaWRhdGVNZXNzYWdlRGF0YShtZXNzYWdlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBDb3Ntb3MtbGlrZSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlcXVlbmNlIC0gVGhlIHNlbmRlciBhZGRyZXNzIHNlcXVlbmNlIG51bWJlciBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge01lc3NhZ2VEYXRhW119IG1lc3NhZ2VzIC0gVGhlIGFycmF5IG9mIG1lc3NhZ2UgZGF0YSBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge0ZlZURhdGF9IGdhc0J1ZGdldCAtIFRoZSBmZWUgZGF0YSBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3B1YmxpY0tleV0gLSBUaGUgcHVibGljIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHNlbmRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFttZW1vXSAtIFRoZSBtZW1vIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAqIEByZXR1cm5zIHtDb3Ntb3NMaWtlVHJhbnNhY3Rpb259IFJldHVybnMgdGhlIGNyZWF0ZWQgQ29zbW9zLWxpa2UgdHJhbnNhY3Rpb24uXG4gICAqIEB0aHJvd3Mge0ludmFsaWRUcmFuc2FjdGlvbkVycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGNyZWF0ZWQgdHJhbnNhY3Rpb24gaXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZVRyYW5zYWN0aW9uKFxuICAgIHNlcXVlbmNlOiBudW1iZXIsXG4gICAgbWVzc2FnZXM6IE1lc3NhZ2VEYXRhW10sXG4gICAgZ2FzQnVkZ2V0OiBGZWVEYXRhLFxuICAgIHB1YmxpY0tleT86IHN0cmluZyxcbiAgICBtZW1vPzogc3RyaW5nXG4gICk6IENvc21vc0xpa2VUcmFuc2FjdGlvbiB7XG4gICAgY29uc3QgY29zbW9zTGlrZVR4biA9IHtcbiAgICAgIHNlcXVlbmNlOiBzZXF1ZW5jZSxcbiAgICAgIHNlbmRNZXNzYWdlczogbWVzc2FnZXMsXG4gICAgICBnYXNCdWRnZXQ6IGdhc0J1ZGdldCxcbiAgICAgIHB1YmxpY0tleTogcHVibGljS2V5LFxuICAgICAgbWVtbzogbWVtbyxcbiAgICB9O1xuICAgIHRoaXMudmFsaWRhdGVUcmFuc2FjdGlvbihjb3Ntb3NMaWtlVHhuKTtcbiAgICByZXR1cm4gY29zbW9zTGlrZVR4bjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQ29zbW9zLWxpa2UgdHJhbnNhY3Rpb24gd2l0aCBhIGhhc2guXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZXF1ZW5jZSAtIFRoZSBzZW5kZXIgYWRkcmVzcyBzZXF1ZW5jZSBudW1iZXIgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtNZXNzYWdlRGF0YVtdfSBtZXNzYWdlcyAtIFRoZSBhcnJheSBvZiBtZXNzYWdlIGRhdGEgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtGZWVEYXRhfSBnYXNCdWRnZXQgLSBUaGUgZmVlIGRhdGEgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwdWJsaWNLZXldIC0gVGhlIHB1YmxpYyBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtzaWduYXR1cmVdIC0gVGhlIHNpZ25hdHVyZSBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW21lbW9dIC0gVGhlIG1lbW8gZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICogQHJldHVybnMge0Nvc21vc0xpa2VUcmFuc2FjdGlvbn0gUmV0dXJucyB0aGUgY3JlYXRlZCBDb3Ntb3MtbGlrZSB0cmFuc2FjdGlvbiB3aXRoIHRoZSBoYXNoIGFuZCBzaWduYXR1cmUgaWYgcHJvdmlkZWQuXG4gICAqL1xuICBjcmVhdGVUcmFuc2FjdGlvbldpdGhIYXNoKFxuICAgIHNlcXVlbmNlOiBudW1iZXIsXG4gICAgbWVzc2FnZXM6IE1lc3NhZ2VEYXRhW10sXG4gICAgZ2FzQnVkZ2V0OiBGZWVEYXRhLFxuICAgIHB1YmxpY0tleT86IHN0cmluZyxcbiAgICBzaWduYXR1cmU/OiBCdWZmZXIsXG4gICAgbWVtbz86IHN0cmluZ1xuICApOiBDb3Ntb3NMaWtlVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0IGNvc21vc0xpa2VUeG4gPSB0aGlzLmNyZWF0ZVRyYW5zYWN0aW9uKHNlcXVlbmNlLCBtZXNzYWdlcywgZ2FzQnVkZ2V0LCBwdWJsaWNLZXksIG1lbW8pO1xuICAgIGxldCBoYXNoID0gY29uc3RhbnRzLlVOQVZBSUxBQkxFX1RFWFQ7XG4gICAgaWYgKHNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCB1bnNpZ25lZFR4ID0gdGhpcy5jcmVhdGVUeFJhd0Zyb21Db3Ntb3NMaWtlVHJhbnNhY3Rpb24oY29zbW9zTGlrZVR4bik7XG4gICAgICBjb25zdCBzaWduZWRUeCA9IFR4UmF3LmZyb21QYXJ0aWFsKHtcbiAgICAgICAgYm9keUJ5dGVzOiB1bnNpZ25lZFR4LmJvZHlCeXRlcyxcbiAgICAgICAgYXV0aEluZm9CeXRlczogdW5zaWduZWRUeC5hdXRoSW5mb0J5dGVzLFxuICAgICAgICBzaWduYXR1cmVzOiBbc2lnbmF0dXJlXSxcbiAgICAgIH0pO1xuICAgICAgaGFzaCA9IGNyZWF0ZUhhc2goJ3NoYTI1NicpXG4gICAgICAgIC51cGRhdGUoVHhSYXcuZW5jb2RlKHNpZ25lZFR4KS5maW5pc2goKSlcbiAgICAgICAgLmRpZ2VzdCgpXG4gICAgICAgIC50b1N0cmluZygnaGV4JylcbiAgICAgICAgLnRvTG9jYWxlVXBwZXJDYXNlKCdlbi1VUycpO1xuICAgICAgcmV0dXJuIHsgLi4uY29zbW9zTGlrZVR4biwgaGFzaDogaGFzaCwgc2lnbmF0dXJlOiBzaWduYXR1cmUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4uY29zbW9zTGlrZVR4biwgaGFzaDogaGFzaCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplcyBiYXNlNjQgZW5vY2RlZCByYXcgdHJhbnNhY3Rpb24gc3RyaW5nIGludG8gQHNlZSBDb3Ntb3NMaWtlVHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJhd1R4IGJhc2U2NCBlbm9jZGVkIHJhdyB0cmFuc2FjdGlvbiBzdHJpbmdcbiAgICogQHJldHVybnMge0Nvc21vc0xpa2VUcmFuc2FjdGlvbn0gRGVzZXJpYWxpemVkIGNvc21vc0xpa2VUcmFuc2FjdGlvblxuICAgKi9cbiAgZGVzZXJpYWxpemVUcmFuc2FjdGlvbihyYXdUeDogc3RyaW5nKTogQ29zbW9zTGlrZVRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCBkZWNvZGVkVHggPSB0aGlzLmdldERlY29kZWRUeEZyb21SYXdCYXNlNjQocmF3VHgpO1xuICAgIGNvbnN0IHR5cGVVcmwgPSB0aGlzLmdldFR5cGVVcmxGcm9tRGVjb2RlZFR4KGRlY29kZWRUeCk7XG4gICAgY29uc3QgdHlwZTogVHJhbnNhY3Rpb25UeXBlIHwgdW5kZWZpbmVkID0gdGhpcy5nZXRUcmFuc2FjdGlvblR5cGVGcm9tVHlwZVVybCh0eXBlVXJsKTtcbiAgICBsZXQgc2VuZE1lc3NhZ2VEYXRhOiBNZXNzYWdlRGF0YVtdO1xuICAgIGlmICh0eXBlID09PSBUcmFuc2FjdGlvblR5cGUuU2VuZCkge1xuICAgICAgc2VuZE1lc3NhZ2VEYXRhID0gdGhpcy5nZXRTZW5kTWVzc2FnZURhdGFGcm9tRGVjb2RlZFR4KGRlY29kZWRUeCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0FjdGl2YXRlIHx8IHR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nRGVhY3RpdmF0ZSkge1xuICAgICAgc2VuZE1lc3NhZ2VEYXRhID0gdGhpcy5nZXREZWxlZ2F0ZU9yVW5kZWxlZ2F0ZU1lc3NhZ2VEYXRhRnJvbURlY29kZWRUeChkZWNvZGVkVHgpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdXaXRoZHJhdykge1xuICAgICAgc2VuZE1lc3NhZ2VEYXRhID0gdGhpcy5nZXRXaXRoZHJhd1Jld2FyZHNNZXNzYWdlRGF0YUZyb21EZWNvZGVkVHgoZGVjb2RlZFR4KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5Db250cmFjdENhbGwpIHtcbiAgICAgIHNlbmRNZXNzYWdlRGF0YSA9IHRoaXMuZ2V0RXhlY3V0ZUNvbnRyYWN0TWVzc2FnZURhdGFGcm9tRGVjb2RlZFR4KGRlY29kZWRUeCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ1JlZGVsZWdhdGUpIHtcbiAgICAgIHNlbmRNZXNzYWdlRGF0YSA9IHRoaXMuZ2V0UmVkZWxlZ2F0ZU1lc3NhZ2VEYXRhRnJvbURlY29kZWRUeChkZWNvZGVkVHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIHR5cGUgbm90IHN1cHBvcnRlZDogJyArIHR5cGVVcmwpO1xuICAgIH1cbiAgICBjb25zdCBzZXF1ZW5jZSA9IHRoaXMuZ2V0U2VxdWVuY2VGcm9tRGVjb2RlZFR4KGRlY29kZWRUeCk7XG4gICAgY29uc3QgZ2FzQnVkZ2V0ID0gdGhpcy5nZXRHYXNCdWRnZXRGcm9tRGVjb2RlZFR4KGRlY29kZWRUeCk7XG4gICAgY29uc3QgcHVibGljS2V5ID0gdGhpcy5nZXRQdWJsaWNLZXlGcm9tRGVjb2RlZFR4KGRlY29kZWRUeCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gZGVjb2RlZFR4LnNpZ25hdHVyZXM/LlswXSAhPT0gdW5kZWZpbmVkID8gQnVmZmVyLmZyb20oZGVjb2RlZFR4LnNpZ25hdHVyZXNbMF0pIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVRyYW5zYWN0aW9uV2l0aEhhc2goXG4gICAgICBzZXF1ZW5jZSxcbiAgICAgIHNlbmRNZXNzYWdlRGF0YSxcbiAgICAgIGdhc0J1ZGdldCxcbiAgICAgIHB1YmxpY0tleSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIGRlY29kZWRUeC5ib2R5Py5tZW1vXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYW4gYXJyYXkgb2YgY29pbiBhbW91bnRzLlxuICAgKiBAcGFyYW0ge0NvaW5bXX0gYW1vdW50QXJyYXkgLSBUaGUgYXJyYXkgb2YgY29pbiBhbW91bnRzIHRvIHZhbGlkYXRlLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uVHlwZX0gdHJhbnNhY3Rpb25UeXBlIC0gb3B0aW9uYWwgZmllbGQgZm9yIHRyYW5zYWN0aW9uIHR5cGVcbiAgICovXG4gIHZhbGlkYXRlQW1vdW50RGF0YShhbW91bnRBcnJheTogQ29pbltdLCB0cmFuc2FjdGlvblR5cGU/OiBUcmFuc2FjdGlvblR5cGUpOiB2b2lkIHtcbiAgICBhbW91bnRBcnJheS5mb3JFYWNoKChjb2luQW1vdW50KSA9PiB7XG4gICAgICB0aGlzLnZhbGlkYXRlQW1vdW50KGNvaW5BbW91bnQsIHRyYW5zYWN0aW9uVHlwZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBnYXMgbGltaXQgYW5kIGdhcyBhbW91bnQgZm9yIGEgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7RmVlRGF0YX0gZ2FzQnVkZ2V0IC0gVGhlIGdhcyBidWRnZXQgdG8gdmFsaWRhdGUuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRUcmFuc2FjdGlvbkVycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGdhcyBidWRnZXQgaXMgaW52YWxpZC5cbiAgICovXG4gIHZhbGlkYXRlR2FzQnVkZ2V0KGdhc0J1ZGdldDogRmVlRGF0YSk6IHZvaWQge1xuICAgIGlmIChnYXNCdWRnZXQuZ2FzTGltaXQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIGdhcyBsaW1pdCAnICsgZ2FzQnVkZ2V0Lmdhc0xpbWl0KTtcbiAgICB9XG4gICAgdGhpcy52YWxpZGF0ZUFtb3VudERhdGEoZ2FzQnVkZ2V0LmFtb3VudCk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIGEgc2VuZCBtZXNzYWdlIGZvciBhIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge1NlbmRNZXNzYWdlfSBzZW5kTWVzc2FnZSAtIFRoZSBzZW5kIG1lc3NhZ2UgdG8gdmFsaWRhdGUuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRUcmFuc2FjdGlvbkVycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHNlbmQgbWVzc2FnZSBpcyBpbnZhbGlkLlxuICAgKi9cbiAgdmFsaWRhdGVTZW5kTWVzc2FnZShzZW5kTWVzc2FnZTogU2VuZE1lc3NhZ2UpIHtcbiAgICBpZiAoIXNlbmRNZXNzYWdlLnRvQWRkcmVzcyB8fCAhdGhpcy5pc1ZhbGlkQWRkcmVzcyhzZW5kTWVzc2FnZS50b0FkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgU2VuZE1lc3NhZ2UgdG9BZGRyZXNzOiBgICsgc2VuZE1lc3NhZ2UudG9BZGRyZXNzKTtcbiAgICB9XG4gICAgaWYgKCFzZW5kTWVzc2FnZS5mcm9tQWRkcmVzcyB8fCAhdGhpcy5pc1ZhbGlkQWRkcmVzcyhzZW5kTWVzc2FnZS5mcm9tQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBTZW5kTWVzc2FnZSBmcm9tQWRkcmVzczogYCArIHNlbmRNZXNzYWdlLmZyb21BZGRyZXNzKTtcbiAgICB9XG4gICAgdGhpcy52YWxpZGF0ZUFtb3VudERhdGEoc2VuZE1lc3NhZ2UuYW1vdW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYSBjb2luIGFtb3VudC5cbiAgICogQHBhcmFtIHtDb2lufSBhbW91bnQgLSBUaGUgY29pbiBhbW91bnQgdG8gdmFsaWRhdGUuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25UeXBlfSB0cmFuc2FjdGlvblR5cGUgLSBvcHRpb25hbCBmaWVsZCBmb3IgdHJhbnNhY3Rpb24gdHlwZVxuICAgKiBAdGhyb3dzIHtJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcn0gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBjb2luIGFtb3VudCBpcyBpbnZhbGlkLlxuICAgKi9cbiAgdmFsaWRhdGVBbW91bnQoYW1vdW50OiBDb2luLCB0cmFuc2FjdGlvblR5cGU/OiBUcmFuc2FjdGlvblR5cGUpOiB2b2lkIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcigndmFsaWRhdGVBbW91bnQgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgY29zbW9zIGxpa2UgQmVjaDMyIGFkZHJlc3MgbWF0Y2hlcyBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gYW5kXG4gICAqIHZhbGlkYXRlcyBtZW1vSWQgaWYgcHJlc2VudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnRXhwIFJlZ3VsYXIgZXhwcmVzc2lvbiB0byB2YWxpZGF0ZSB0aGUgcm9vdCBhZGRyZXNzIGFnYWluc3QgYWZ0ZXIgdHJpbW1pbmcgdGhlIG1lbW9JZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBhZGRyZXNzIGlzIHZhbGlkXG4gICAqL1xuICBwcm90ZWN0ZWQgaXNWYWxpZENvc21vc0xpa2VBZGRyZXNzV2l0aE1lbW9JZChhZGRyZXNzOiBzdHJpbmcsIHJlZ0V4cDogUmVnRXhwKTogYm9vbGVhbiB7XG4gICAgaWYgKHR5cGVvZiBhZGRyZXNzICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGFkZHJlc3NBcnJheSA9IGFkZHJlc3Muc3BsaXQoJz9tZW1vSWQ9Jyk7XG4gICAgaWYgKFxuICAgICAgIVsxLCAyXS5pbmNsdWRlcyhhZGRyZXNzQXJyYXkubGVuZ3RoKSB8fCAvLyBzaG91bGQgaGF2ZSBhdCBtb3N0IG9uZSBvY2N1cnJlbmNlIG9mICdtZW1vSWQ9J1xuICAgICAgIXRoaXMuaXNWYWxpZEJlY2gzMkFkZHJlc3NNYXRjaGluZ1JlZ2V4KGFkZHJlc3NBcnJheVswXSwgcmVnRXhwKSB8fFxuICAgICAgKGFkZHJlc3NBcnJheVsxXSAmJiAhdGhpcy5pc1ZhbGlkTWVtb0lkKGFkZHJlc3NBcnJheVsxXSkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhZGRyZXNzIGlzIHZhbGlkIEJlY2gzMiBhbmQgbWF0Y2hlcyBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ0V4cCBSZWd1bGFyIGV4cHJlc3Npb24gdG8gdmFsaWRhdGUgdGhlIGFkZHJlc3MgYWdhaW5zdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBhZGRyZXNzIGlzIHZhbGlkXG4gICAqL1xuICBwcm90ZWN0ZWQgaXNWYWxpZEJlY2gzMkFkZHJlc3NNYXRjaGluZ1JlZ2V4KGFkZHJlc3M6IHN0cmluZywgcmVnRXhwOiBSZWdFeHApOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgZnJvbUJlY2gzMihhZGRyZXNzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiByZWdFeHAudGVzdChhZGRyZXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYSBtZW1vIGlkIGlzIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSBtZW1vSWQgbWVtbyBpZFxuICAgKiBAcmV0dXJucyB0cnVlIGlmIG1lbW8gaWQgaXMgdmFsaWRcbiAgICovXG4gIGlzVmFsaWRNZW1vSWQobWVtb0lkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBsZXQgbWVtb0lkTnVtYmVyOiBCaWdOdW1iZXI7XG4gICAgdHJ5IHtcbiAgICAgIG1lbW9JZE51bWJlciA9IG5ldyBCaWdOdW1iZXIobWVtb0lkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBtZW1vSWROdW1iZXIuZ3RlKDApICYmIG1lbW9JZE51bWJlci5pc0ludGVnZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgaWYgdGhlIGFkZHJlc3MgbWF0Y2hlcyB3aXRoIHJlZ2V4IEBzZWUgYWNjb3VudEFkZHJlc3NSZWdleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAgICovXG4gIGlzVmFsaWRWYWxpZGF0b3JBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCdpc1ZhbGlkVmFsaWRhdG9yQWRkcmVzcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgaWYgdGhlIGFkZHJlc3MgbWF0Y2hlcyB3aXRoIHJlZ2V4IEBzZWUgYWNjb3VudEFkZHJlc3NSZWdleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCdpc1ZhbGlkQWRkcmVzcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgaWYgdGhlIGFkZHJlc3MgbWF0Y2hlcyB3aXRoIHJlZ2V4IEBzZWUgY29udHJhY3RBZGRyZXNzUmVnZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gICAqL1xuICBpc1ZhbGlkQ29udHJhY3RBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCdpc1ZhbGlkQ29udHJhY3RBZGRyZXNzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBhIGV4ZWN1dGUgY29udHJhY3QgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0V4ZWN1dGVDb250cmFjdE1lc3NhZ2V9IG1lc3NhZ2UgLSBUaGUgZXhlY3V0ZSBjb250cmFjdCBtZXNzYWdlIHRvIHZhbGlkYXRlXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25UeXBlfSB0cmFuc2FjdGlvblR5cGUgLSBvcHRpb25hbCBmaWVsZCBmb3IgdHJhbnNhY3Rpb24gdHlwZVxuICAgKiBAdGhyb3dzIHtJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcn0gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBtZXNzYWdlIGlzIGludmFsaWRcbiAgICovXG4gIHZhbGlkYXRlRXhlY3V0ZUNvbnRyYWN0TWVzc2FnZShtZXNzYWdlOiBFeGVjdXRlQ29udHJhY3RNZXNzYWdlLCB0cmFuc2FjdGlvblR5cGU/OiBUcmFuc2FjdGlvblR5cGUpIHtcbiAgICBpZiAoIW1lc3NhZ2UuY29udHJhY3QgfHwgIXRoaXMuaXNWYWxpZENvbnRyYWN0QWRkcmVzcyhtZXNzYWdlLmNvbnRyYWN0KSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIEV4ZWN1dGVDb250cmFjdE1lc3NhZ2UgY29udHJhY3QgYWRkcmVzczogYCArIG1lc3NhZ2UuY29udHJhY3QpO1xuICAgIH1cbiAgICBpZiAoIW1lc3NhZ2Uuc2VuZGVyIHx8ICF0aGlzLmlzVmFsaWRBZGRyZXNzKG1lc3NhZ2Uuc2VuZGVyKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIEV4ZWN1dGVDb250cmFjdE1lc3NhZ2Ugc2VuZGVyIGFkZHJlc3M6IGAgKyBtZXNzYWdlLnNlbmRlcik7XG4gICAgfVxuICAgIGlmICghbWVzc2FnZS5tc2cpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBFeGVjdXRlQ29udHJhY3RNZXNzYWdlIG1zZzogYCArIG1lc3NhZ2UubXNnKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UuZnVuZHMpIHtcbiAgICAgIHRoaXMudmFsaWRhdGVBbW91bnREYXRhKG1lc3NhZ2UuZnVuZHMsIHRyYW5zYWN0aW9uVHlwZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjb2luIHNwZWNpZmljIGhhc2ggZnVuY3Rpb25cbiAgICogQHJldHVybnMge0hhc2h9IFRoZSBoYXNoIGZ1bmN0aW9uXG4gICAqL1xuICBnZXRIYXNoRnVuY3Rpb24oKTogSGFzaCB7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpO1xuICB9XG59XG5cbmNvbnN0IHV0aWxzID0gbmV3IENvc21vc1V0aWxzKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHV0aWxzO1xuIl19