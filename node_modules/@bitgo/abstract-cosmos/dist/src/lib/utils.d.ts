/// <reference types="node" />
/// <reference types="node" />
import { BaseUtils, TransactionType } from '@bitgo/sdk-core';
import { DecodedTxRaw } from '@cosmjs/proto-signing';
import { Coin } from '@cosmjs/stargate';
import { SignDoc, TxRaw } from 'cosmjs-types/cosmos/tx/v1beta1/tx';
import { Any } from 'cosmjs-types/google/protobuf/any';
import { Hash } from 'crypto';
import { CosmosLikeTransaction, DelegateOrUndelegeteMessage, ExecuteContractMessage, FeeData, MessageData, RedelegateMessage, SendMessage, WithdrawDelegatorRewardsMessage } from './iface';
export declare class CosmosUtils implements BaseUtils {
    private registry;
    constructor();
    /** @inheritdoc */
    isValidBlockId(hash: string): boolean;
    /** @inheritdoc */
    isValidPrivateKey(key: string): boolean;
    /** @inheritdoc */
    isValidPublicKey(key: string): boolean;
    /** @inheritdoc */
    isValidSignature(signature: string): boolean;
    /** @inheritdoc */
    isValidTransactionId(txId: string): boolean;
    /**
     * Checks if transaction hash is in valid black2b format
     */
    validateBlake2b(hash: string): boolean;
    /**
     * Validates whether amounts are in range
     *
     * @param {number[]} amounts - the amounts to validate
     * @returns {boolean} - the validation result
     */
    isValidAmounts(amounts: number[]): boolean;
    /**
     * Validates whether amount is in range
     * @param {number} amount
     * @returns {boolean} the validation result
     */
    isValidAmount(amount: number): boolean;
    /**
     * Decodes raw tx data into messages, signing info, and fee data
     * @param {string} txHex - raw base64 tx
     * @returns {DecodedTxRaw} Decoded transaction
     */
    getDecodedTxFromRawBase64(txRaw: string): DecodedTxRaw;
    /**
     * Returns the array of messages in the body of the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {EncodeObject[]} messages along with type url
     */
    private getEncodedMessagesFromDecodedTx;
    /**
     * Checks the txn sequence is valid or not
     * @param {number} sequence
     */
    validateSequence(sequence: number): void;
    /**
     * Pulls the sequence number from a DecodedTxRaw AuthInfo property
     * @param {DecodedTxRaw} decodedTx
     * @returns {number} sequence
     */
    getSequenceFromDecodedTx(decodedTx: DecodedTxRaw): number;
    /**
     * Pulls the typeUrl from the encoded message of a DecodedTxRaw
     * @param {DecodedTxRaw} decodedTx
     * @returns {string} cosmos proto type url
     */
    getTypeUrlFromDecodedTx(decodedTx: DecodedTxRaw): string;
    /**
     * Returns the fee data from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {FeeData} fee data
     */
    getGasBudgetFromDecodedTx(decodedTx: DecodedTxRaw): FeeData;
    /**
     * Returns the publicKey from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {string | undefined} publicKey in hex format if it exists, undefined otherwise
     */
    getPublicKeyFromDecodedTx(decodedTx: DecodedTxRaw): string | undefined;
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Send transaction message data
     */
    protected getSendMessageDataFromDecodedTx(decodedTx: DecodedTxRaw): MessageData[];
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Delegate of undelegate transaction message data
     */
    getDelegateOrUndelegateMessageDataFromDecodedTx(decodedTx: DecodedTxRaw): MessageData[];
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Redelegate transaction message data
     */
    getRedelegateMessageDataFromDecodedTx(decodedTx: DecodedTxRaw): MessageData[];
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} WithdrawDelegatorRewards transaction message data
     */
    getWithdrawRewardsMessageDataFromDecodedTx(decodedTx: DecodedTxRaw): MessageData[];
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Delegate of undelegate transaction message data
     */
    getWithdrawDelegatorRewardsMessageDataFromDecodedTx(decodedTx: DecodedTxRaw): MessageData[];
    /**
     * Get a cosmos chain address from its equivalent hex
     * @param {string} prefix
     * @param {string} addressHex
     * @returns {string}
     */
    getCosmosLikeAddressFromHex(prefix: string, addressHex: string): string;
    /**
     * Get a EVM chain address from its equivalent hex
     * @param {string} prefix
     * @param {string} addressHex
     * @returns {string}
     */
    getEvmLikeAddressFromCosmos(cosmosLikeAddress: string): string;
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Execute contract transaction message data
     */
    getExecuteContractMessageDataFromDecodedTx(decodedTx: DecodedTxRaw): MessageData[];
    /**
     * Determines bitgo transaction type based on cosmos proto type url
     * @param {string} typeUrl
     * @returns {TransactionType | undefined} TransactionType if url is supported else undefined
     */
    getTransactionTypeFromTypeUrl(typeUrl: string): TransactionType | undefined;
    /**
     * Takes a hex encoded pubkey, converts it to the Amino JSON representation (type/value wrapper)
     * and returns it as protobuf `Any`
     * @param {string} pubkey hex encoded compressed secp256k1 public key
     * @returns {Any} pubkey encoded as protobuf `Any`
     */
    getEncodedPubkey(pubkey: string): Any;
    /**
     * Creates a txRaw from an cosmos like transaction @see CosmosLikeTransaction
     * @Precondition cosmosLikeTransaction.publicKey must be defined
     * @param {CosmosLikeTransaction} cosmosLikeTransaction
     * @returns {TxRaw} Unsigned raw transaction
     */
    createTxRawFromCosmosLikeTransaction(cosmosLikeTransaction: CosmosLikeTransaction): TxRaw;
    /**
     * Encodes a signature into a txRaw
     * @param {string} publicKeyHex publicKey in hex encoded string format
     * @param {string} signatureHex signature in hex encoded string format
     * @param {TxRaw} unsignedTx raw transaction
     * @returns {TxRaw} Signed raw transaction
     */
    createSignedTxRaw(publicKeyHex: string, signatureHex: string, unsignedTx: {
        bodyBytes: Uint8Array;
        authInfoBytes: Uint8Array;
    }): TxRaw;
    /**
     * Decodes a raw transaction into a DecodedTxRaw and checks if it has non empty signatures
     * @param {string} rawTransaction
     * @returns {boolean} true if transaction is signed else false
     */
    isSignedRawTx(rawTransaction: string): boolean;
    /**
     * Returns whether or not the string is a valid protocol public key
     * @param {string | undefined} publicKey - the  public key to be validated
     */
    validatePublicKey(publicKey: string | undefined): void;
    /**
     * Creates a sign doc from an cosmos like transaction @see CosmosLikeTransaction
     * @Precondition cosmosLikeTransaction.accountNumber and cosmosLikeTransaction.chainId must be defined
     * @param {CosmosLikeTransaction} cosmosLikeTransaction
     * @returns {SignDoc} sign doc
     */
    createSignDoc(cosmosLikeTransaction: CosmosLikeTransaction, accountNumber: number | undefined, chainId: string | undefined): SignDoc;
    /**
     * Returns whether or not the string is a valid hex
     * @param hexString - hex string format
     * @returns {boolean} true if string is hex else false
     */
    isValidHexString(hexString: string): boolean;
    /**
     * Validates the WithdrawDelegatorRewardsMessage
     * @param {WithdrawDelegatorRewardsMessage} withdrawRewardsMessage - The WithdrawDelegatorRewardsMessage to validate.
     * @throws {InvalidTransactionError} Throws an error if the validatorAddress or delegatorAddress is invalid or missing.
     */
    validateWithdrawRewardsMessage(withdrawRewardsMessage: WithdrawDelegatorRewardsMessage): void;
    /**
     * Helper method to check if the specified properties in an object are missing or null.
     * @param {Object} obj - The object to check.
     * @param {string[]} keys - An array of property keys to check.
     * @throws {Error} Throws an error if any of the specified properties are missing or null.
     */
    isObjPropertyNull(obj: {
        [key: string]: any;
    }, keys: Array<string>): void;
    /**
     * Validates the DelegateOrUndelegeteMessage
     * @param {DelegateOrUndelegeteMessage} delegateMessage - The DelegateOrUndelegeteMessage to validate.
     * @throws {InvalidTransactionError} Throws an error if the validatorAddress, delegatorAddress, or amount is invalid or missing.
     */
    validateDelegateOrUndelegateMessage(delegateMessage: DelegateOrUndelegeteMessage): void;
    /**
     * Validates the RedelegateMessage
     * @param {DelegateOrUndelegeteMessage} redelegateMessage - The RedelegateMessage to validate.
     * @throws {InvalidTransactionError} Throws an error if the validatorSrcAddress, validatorDstAddress, delegatorAddress, or amount is invalid or missing.
     */
    validateRedelegateMessage(redelegateMessage: RedelegateMessage): void;
    /**
     * Validates the MessageData
     * @param {MessageData} messageData - The MessageData to validate.
     * @throws {InvalidTransactionError} Throws an error if the messageData is invalid or missing required fields.
     */
    validateMessageData(messageData: MessageData): void;
    /**
     * Validates the Cosmos-like transaction.
     * @param {CosmosLikeTransaction} tx - The transaction to validate.
     * @throws {InvalidTransactionError} Throws an error if the transaction is invalid or missing required fields.
     */
    validateTransaction(tx: CosmosLikeTransaction): void;
    /**
     * Creates a Cosmos-like transaction.
     * @param {number} sequence - The sender address sequence number for the transaction.
     * @param {MessageData[]} messages - The array of message data for the transaction.
     * @param {FeeData} gasBudget - The fee data for the transaction.
     * @param {string} [publicKey] - The public key associated with the sender.
     * @param {string} [memo] - The memo for the transaction.
     * @returns {CosmosLikeTransaction} Returns the created Cosmos-like transaction.
     * @throws {InvalidTransactionError} Throws an error if the created transaction is invalid.
     */
    createTransaction(sequence: number, messages: MessageData[], gasBudget: FeeData, publicKey?: string, memo?: string): CosmosLikeTransaction;
    /**
     * Creates a Cosmos-like transaction with a hash.
     * @param {number} sequence - The sender address sequence number for the transaction.
     * @param {MessageData[]} messages - The array of message data for the transaction.
     * @param {FeeData} gasBudget - The fee data for the transaction.
     * @param {string} [publicKey] - The public key associated with the transaction.
     * @param {Buffer} [signature] - The signature for the transaction.
     * @param {string} [memo] - The memo for the transaction.
     * @returns {CosmosLikeTransaction} Returns the created Cosmos-like transaction with the hash and signature if provided.
     */
    createTransactionWithHash(sequence: number, messages: MessageData[], gasBudget: FeeData, publicKey?: string, signature?: Buffer, memo?: string): CosmosLikeTransaction;
    /**
     * Deserializes base64 enocded raw transaction string into @see CosmosLikeTransaction
     * @param {string} rawTx base64 enocded raw transaction string
     * @returns {CosmosLikeTransaction} Deserialized cosmosLikeTransaction
     */
    deserializeTransaction(rawTx: string): CosmosLikeTransaction;
    /**
     * Validates an array of coin amounts.
     * @param {Coin[]} amountArray - The array of coin amounts to validate.
     * @param {TransactionType} transactionType - optional field for transaction type
     */
    validateAmountData(amountArray: Coin[], transactionType?: TransactionType): void;
    /**
     * Validates the gas limit and gas amount for a transaction.
     * @param {FeeData} gasBudget - The gas budget to validate.
     * @throws {InvalidTransactionError} Throws an error if the gas budget is invalid.
     */
    validateGasBudget(gasBudget: FeeData): void;
    /**
     * Validates a send message for a transaction.
     * @param {SendMessage} sendMessage - The send message to validate.
     * @throws {InvalidTransactionError} Throws an error if the send message is invalid.
     */
    validateSendMessage(sendMessage: SendMessage): void;
    /**
     * Validates a coin amount.
     * @param {Coin} amount - The coin amount to validate.
     * @param {TransactionType} transactionType - optional field for transaction type
     * @throws {InvalidTransactionError} Throws an error if the coin amount is invalid.
     */
    validateAmount(amount: Coin, transactionType?: TransactionType): void;
    /**
     * Checks if a cosmos like Bech32 address matches given regular expression and
     * validates memoId if present
     * @param {string} address
     * @param {RegExp} regExp Regular expression to validate the root address against after trimming the memoId
     * @returns {boolean} true if address is valid
     */
    protected isValidCosmosLikeAddressWithMemoId(address: string, regExp: RegExp): boolean;
    /**
     * Checks if address is valid Bech32 and matches given regular expression
     * @param {string} address
     * @param {RegExp} regExp Regular expression to validate the address against
     * @returns {boolean} true if address is valid
     */
    protected isValidBech32AddressMatchingRegex(address: string, regExp: RegExp): boolean;
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId memo id
     * @returns true if memo id is valid
     */
    isValidMemoId(memoId: string): boolean;
    /**
     * Validates if the address matches with regex @see accountAddressRegex
     * @param {string} address
     * @returns {boolean} - the validation result
     */
    isValidValidatorAddress(address: string): boolean;
    /**
     * Validates if the address matches with regex @see accountAddressRegex
     * @param {string} address
     * @returns {boolean} - the validation result
     */
    isValidAddress(address: string): boolean;
    /**
     * Validates if the address matches with regex @see contractAddressRegex
     * @param {string} address
     * @returns {boolean} - the validation result
     */
    isValidContractAddress(address: string): boolean;
    /**
     * Validates a execute contract message
     * @param {ExecuteContractMessage} message - The execute contract message to validate
     * @param {TransactionType} transactionType - optional field for transaction type
     * @throws {InvalidTransactionError} Throws an error if the message is invalid
     */
    validateExecuteContractMessage(message: ExecuteContractMessage, transactionType?: TransactionType): void;
    /**
     * Get coin specific hash function
     * @returns {Hash} The hash function
     */
    getHashFunction(): Hash;
}
declare const utils: CosmosUtils;
export default utils;
//# sourceMappingURL=utils.d.ts.map