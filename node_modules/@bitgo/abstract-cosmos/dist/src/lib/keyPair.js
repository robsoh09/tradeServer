"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosmosKeyPair = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const crypto_1 = require("crypto");
const constants_1 = require("./constants");
/**
 * Cosmos keys and address management.
 */
class CosmosKeyPair extends sdk_core_1.Secp256k1ExtendedKeyPair {
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     * @param { KeyPairOptions } source Either a master seed, a private key (extended or raw), or a public key
     *     (extended, compressed, or uncompressed)
     */
    constructor(source) {
        super(source);
        if (!source) {
            const seed = (0, crypto_1.randomBytes)(constants_1.DEFAULT_SEED_SIZE_BYTES);
            this.hdNode = utxo_lib_1.bip32.fromSeed(seed);
        }
        else if ((0, sdk_core_1.isSeed)(source)) {
            this.hdNode = utxo_lib_1.bip32.fromSeed(source.seed);
        }
        else if ((0, sdk_core_1.isPrivateKey)(source)) {
            this.recordKeysFromPrivateKey(source.prv);
        }
        else if ((0, sdk_core_1.isPublicKey)(source)) {
            this.recordKeysFromPublicKey(source.pub);
        }
        else {
            throw new Error('Invalid key pair options');
        }
        if (this.hdNode) {
            this.keyPair = sdk_core_1.Secp256k1ExtendedKeyPair.toKeyPair(this.hdNode);
        }
    }
    /**
     * Cosmos default keys format: raw private and compressed public key
     * @returns { DefaultKeys } The keys in the protocol default key format
     */
    getKeys() {
        var _a;
        return {
            pub: this.getPublicKey({ compressed: true }).toString('hex'),
            prv: (_a = this.getPrivateKey()) === null || _a === void 0 ? void 0 : _a.toString('hex'),
        };
    }
}
exports.CosmosKeyPair = CosmosKeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIva2V5UGFpci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw4Q0FPeUI7QUFDekIsOENBQXdDO0FBQ3hDLG1DQUFxQztBQUVyQywyQ0FBc0Q7QUFFdEQ7O0dBRUc7QUFDSCxNQUFhLGFBQWMsU0FBUSxtQ0FBd0I7SUFDekQ7Ozs7T0FJRztJQUNILFlBQVksTUFBdUI7UUFDakMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2QsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLE1BQU0sSUFBSSxHQUFHLElBQUEsb0JBQVcsRUFBQyxtQ0FBdUIsQ0FBQyxDQUFDO1lBQ2xELElBQUksQ0FBQyxNQUFNLEdBQUcsZ0JBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDcEM7YUFBTSxJQUFJLElBQUEsaUJBQU0sRUFBQyxNQUFNLENBQUMsRUFBRTtZQUN6QixJQUFJLENBQUMsTUFBTSxHQUFHLGdCQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUMzQzthQUFNLElBQUksSUFBQSx1QkFBWSxFQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQy9CLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDM0M7YUFBTSxJQUFJLElBQUEsc0JBQVcsRUFBQyxNQUFNLENBQUMsRUFBRTtZQUM5QixJQUFJLENBQUMsdUJBQXVCLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzFDO2FBQU07WUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUM7U0FDN0M7UUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDZixJQUFJLENBQUMsT0FBTyxHQUFHLG1DQUF3QixDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDaEU7SUFDSCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsT0FBTzs7UUFDTCxPQUFPO1lBQ0wsR0FBRyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO1lBQzVELEdBQUcsRUFBRSxNQUFBLElBQUksQ0FBQyxhQUFhLEVBQUUsMENBQUUsUUFBUSxDQUFDLEtBQUssQ0FBQztTQUMzQyxDQUFDO0lBQ0osQ0FBQztDQUNGO0FBcENELHNDQW9DQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIERlZmF1bHRLZXlzLFxuICBpc1ByaXZhdGVLZXksXG4gIGlzUHVibGljS2V5LFxuICBpc1NlZWQsXG4gIEtleVBhaXJPcHRpb25zLFxuICBTZWNwMjU2azFFeHRlbmRlZEtleVBhaXIsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBiaXAzMiB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5cbmltcG9ydCB7IERFRkFVTFRfU0VFRF9TSVpFX0JZVEVTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIENvc21vcyBrZXlzIGFuZCBhZGRyZXNzIG1hbmFnZW1lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb3Ntb3NLZXlQYWlyIGV4dGVuZHMgU2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyIHtcbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci4gQnkgZGVmYXVsdCwgY3JlYXRlcyBhIGtleSBwYWlyIHdpdGggYSByYW5kb20gbWFzdGVyIHNlZWQuXG4gICAqIEBwYXJhbSB7IEtleVBhaXJPcHRpb25zIH0gc291cmNlIEVpdGhlciBhIG1hc3RlciBzZWVkLCBhIHByaXZhdGUga2V5IChleHRlbmRlZCBvciByYXcpLCBvciBhIHB1YmxpYyBrZXlcbiAgICogICAgIChleHRlbmRlZCwgY29tcHJlc3NlZCwgb3IgdW5jb21wcmVzc2VkKVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlPzogS2V5UGFpck9wdGlvbnMpIHtcbiAgICBzdXBlcihzb3VyY2UpO1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICBjb25zdCBzZWVkID0gcmFuZG9tQnl0ZXMoREVGQVVMVF9TRUVEX1NJWkVfQllURVMpO1xuICAgICAgdGhpcy5oZE5vZGUgPSBiaXAzMi5mcm9tU2VlZChzZWVkKTtcbiAgICB9IGVsc2UgaWYgKGlzU2VlZChzb3VyY2UpKSB7XG4gICAgICB0aGlzLmhkTm9kZSA9IGJpcDMyLmZyb21TZWVkKHNvdXJjZS5zZWVkKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJpdmF0ZUtleShzb3VyY2UpKSB7XG4gICAgICB0aGlzLnJlY29yZEtleXNGcm9tUHJpdmF0ZUtleShzb3VyY2UucHJ2KTtcbiAgICB9IGVsc2UgaWYgKGlzUHVibGljS2V5KHNvdXJjZSkpIHtcbiAgICAgIHRoaXMucmVjb3JkS2V5c0Zyb21QdWJsaWNLZXkoc291cmNlLnB1Yik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgcGFpciBvcHRpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGROb2RlKSB7XG4gICAgICB0aGlzLmtleVBhaXIgPSBTZWNwMjU2azFFeHRlbmRlZEtleVBhaXIudG9LZXlQYWlyKHRoaXMuaGROb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29zbW9zIGRlZmF1bHQga2V5cyBmb3JtYXQ6IHJhdyBwcml2YXRlIGFuZCBjb21wcmVzc2VkIHB1YmxpYyBrZXlcbiAgICogQHJldHVybnMgeyBEZWZhdWx0S2V5cyB9IFRoZSBrZXlzIGluIHRoZSBwcm90b2NvbCBkZWZhdWx0IGtleSBmb3JtYXRcbiAgICovXG4gIGdldEtleXMoKTogRGVmYXVsdEtleXMge1xuICAgIHJldHVybiB7XG4gICAgICBwdWI6IHRoaXMuZ2V0UHVibGljS2V5KHsgY29tcHJlc3NlZDogdHJ1ZSB9KS50b1N0cmluZygnaGV4JyksXG4gICAgICBwcnY6IHRoaXMuZ2V0UHJpdmF0ZUtleSgpPy50b1N0cmluZygnaGV4JyksXG4gICAgfTtcbiAgfVxufVxuIl19