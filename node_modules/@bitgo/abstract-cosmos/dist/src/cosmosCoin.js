"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosmosCoin = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const sdk_lib_mpc_1 = require("@bitgo/sdk-lib-mpc");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const bignumber_js_1 = require("bignumber.js");
const buffer_1 = require("buffer");
const crypto_1 = require("crypto");
const _ = require("lodash");
const querystring = require("querystring");
const request = require("superagent");
const url = require("url");
const constants_1 = require("./lib/constants");
const utils_1 = require("./lib/utils");
class CosmosCoin extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new CosmosCoin(bitgo, staticsCoin);
    }
    /**
     * Creates an instance of TransactionBuilderFactory for the coin specific sdk
     */
    getBuilder() {
        throw new Error('Method not implemented.');
    }
    /** @inheritDoc **/
    getBaseFactor() {
        throw new Error('Method not implemented');
    }
    /** @inheritDoc **/
    getChain() {
        return this._staticsCoin.name;
    }
    /** @inheritDoc **/
    getFamily() {
        return this._staticsCoin.family;
    }
    /** @inheritDoc **/
    getFullName() {
        return this._staticsCoin.fullName;
    }
    /** @inheritDoc */
    supportsTss() {
        return true;
    }
    /** @inheritDoc **/
    getMPCAlgorithm() {
        return 'ecdsa';
    }
    /** @inheritDoc **/
    isValidPub(pub) {
        return utils_1.default.isValidPublicKey(pub);
    }
    /** @inheritDoc **/
    isValidPrv(prv) {
        return utils_1.default.isValidPrivateKey(prv);
    }
    isValidAddress(address) {
        throw new Error('Method not implemented.');
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param {RecoveryOptions} params parameters needed to construct and
     * (maybe) sign the transaction
     *
     * @returns {CosmosLikeCoinRecoveryOutput} the serialized transaction hex string and index
     * of the address being swept
     */
    async recover(params) {
        // Step 1: Check if params contains the required parameters
        if (!params.bitgoKey) {
            throw new Error('missing bitgoKey');
        }
        if (!params.recoveryDestination || !this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination');
        }
        if (!params.userKey) {
            throw new Error('missing userKey');
        }
        if (!params.backupKey) {
            throw new Error('missing backupKey');
        }
        if (!params.walletPassphrase) {
            throw new Error('missing wallet passphrase');
        }
        // Step 2: Fetch the bitgo key from params
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        // Step 3: Instantiate the ECDSA signer and fetch the address details
        const MPC = new sdk_core_1.Ecdsa();
        const chainId = await this.getChainId();
        const publicKey = MPC.deriveUnhardened(bitgoKey, constants_1.ROOT_PATH).slice(0, 66);
        const senderAddress = this.getAddressFromPublicKey(publicKey);
        // Step 4: Fetch account details such as accountNo, balance and check for sufficient funds once gasAmount has been deducted
        const [accountNumber, sequenceNo] = await this.getAccountDetails(senderAddress);
        const balance = new bignumber_js_1.BigNumber(await this.getAccountBalance(senderAddress));
        const gasBudget = {
            amount: [{ denom: this.getDenomination(), amount: this.getGasAmountDetails().gasAmount }],
            gasLimit: this.getGasAmountDetails().gasLimit,
        };
        const gasAmount = new bignumber_js_1.BigNumber(gasBudget.amount[0].amount);
        const actualBalance = balance.minus(gasAmount);
        if (actualBalance.isLessThanOrEqualTo(0)) {
            throw new Error('Did not have enough funds to recover');
        }
        // Step 5: Once sufficient funds are present, construct the recover tx messsage
        const amount = [
            {
                denom: this.getDenomination(),
                amount: actualBalance.toFixed(),
            },
        ];
        const sendMessage = [
            {
                fromAddress: senderAddress,
                toAddress: params.recoveryDestination,
                amount: amount,
            },
        ];
        // Step 6: Build the unsigned tx using the constructed message
        const txnBuilder = this.getBuilder().getTransferBuilder();
        txnBuilder
            .messages(sendMessage)
            .gasBudget(gasBudget)
            .publicKey(publicKey)
            .sequence(Number(sequenceNo))
            .accountNumber(Number(accountNumber))
            .chainId(chainId);
        const unsignedTransaction = (await txnBuilder.build());
        let serializedTx = unsignedTransaction.toBroadcastFormat();
        const signableHex = unsignedTransaction.signablePayload.toString('hex');
        const userKey = params.userKey.replace(/\s/g, '');
        const backupKey = params.backupKey.replace(/\s/g, '');
        const [userKeyCombined, backupKeyCombined] = (() => {
            const [userKeyCombined, backupKeyCombined] = this.getKeyCombinedFromTssKeyShares(userKey, backupKey, params.walletPassphrase);
            return [userKeyCombined, backupKeyCombined];
        })();
        if (!userKeyCombined || !backupKeyCombined) {
            throw new Error('Missing combined key shares for user or backup');
        }
        // Step 7: Sign the tx
        const signature = await this.signRecoveryTSS(userKeyCombined, backupKeyCombined, signableHex);
        const signableBuffer = buffer_1.Buffer.from(signableHex, 'hex');
        MPC.verify(signableBuffer, signature, this.getHashFunction());
        const cosmosKeyPair = this.getKeyPair(publicKey);
        txnBuilder.addSignature({ pub: cosmosKeyPair.getKeys().pub }, buffer_1.Buffer.from(signature.r + signature.s, 'hex'));
        const signedTransaction = await txnBuilder.build();
        serializedTx = signedTransaction.toBroadcastFormat();
        return { serializedTx: serializedTx };
    }
    /**
     * Builds a redelegate transaction
     * @param {RecoveryOptions} params parameters needed to construct and
     * (maybe) sign the transaction
     *
     * @returns {CosmosLikeCoinRecoveryOutput} the serialized transaction hex string
     */
    async redelegate(params) {
        if (!params.bitgoKey) {
            throw new Error('missing bitgoKey');
        }
        if (!params.validatorSrcAddress || !this.isValidAddress(params.validatorSrcAddress)) {
            throw new Error('invalid validatorSrcAddress');
        }
        if (!params.validatorDstAddress || !this.isValidAddress(params.validatorDstAddress)) {
            throw new Error('invalid validatorDstAddress');
        }
        if (!params.userKey) {
            throw new Error('missing userKey');
        }
        if (!params.backupKey) {
            throw new Error('missing backupKey');
        }
        if (!params.walletPassphrase) {
            throw new Error('missing wallet passphrase');
        }
        if (!params.amountToRedelegate) {
            throw new Error('missing amountToRedelegate');
        }
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        const MPC = new sdk_core_1.Ecdsa();
        const chainId = await this.getChainId();
        const publicKey = MPC.deriveUnhardened(bitgoKey, constants_1.ROOT_PATH).slice(0, 66);
        const senderAddress = this.getAddressFromPublicKey(publicKey);
        const [accountNumber, sequenceNo] = await this.getAccountDetails(senderAddress);
        const gasBudget = {
            amount: [{ denom: this.getDenomination(), amount: this.getGasAmountDetails().gasAmount }],
            gasLimit: this.getGasAmountDetails().gasLimit,
        };
        const amount = {
            denom: this.getDenomination(),
            amount: new bignumber_js_1.BigNumber(params.amountToRedelegate).toFixed(),
        };
        const sendMessage = [
            {
                delegatorAddress: senderAddress,
                validatorSrcAddress: params.validatorSrcAddress,
                validatorDstAddress: params.validatorDstAddress,
                amount: amount,
            },
        ];
        const txnBuilder = this.getBuilder().getStakingRedelegateBuilder();
        txnBuilder
            .messages(sendMessage)
            .gasBudget(gasBudget)
            .publicKey(publicKey)
            .sequence(Number(sequenceNo))
            .accountNumber(Number(accountNumber))
            .chainId(chainId);
        const unsignedTransaction = (await txnBuilder.build());
        let serializedTx = unsignedTransaction.toBroadcastFormat();
        const signableHex = unsignedTransaction.signablePayload.toString('hex');
        const userKey = params.userKey.replace(/\s/g, '');
        const backupKey = params.backupKey.replace(/\s/g, '');
        const [userKeyCombined, backupKeyCombined] = (() => {
            const [userKeyCombined, backupKeyCombined] = this.getKeyCombinedFromTssKeyShares(userKey, backupKey, params.walletPassphrase);
            return [userKeyCombined, backupKeyCombined];
        })();
        if (!userKeyCombined || !backupKeyCombined) {
            throw new Error('Missing combined key shares for user or backup');
        }
        const signature = await this.signRecoveryTSS(userKeyCombined, backupKeyCombined, signableHex);
        const signableBuffer = buffer_1.Buffer.from(signableHex, 'hex');
        MPC.verify(signableBuffer, signature, this.getHashFunction());
        const cosmosKeyPair = this.getKeyPair(publicKey);
        txnBuilder.addSignature({ pub: cosmosKeyPair.getKeys().pub }, buffer_1.Buffer.from(signature.r + signature.s, 'hex'));
        const signedTransaction = await txnBuilder.build();
        serializedTx = signedTransaction.toBroadcastFormat();
        return { serializedTx: serializedTx };
    }
    getKeyCombinedFromTssKeyShares(userPublicOrPrivateKeyShare, backupPrivateOrPublicKeyShare, walletPassphrase) {
        let backupPrv;
        let userPrv;
        try {
            backupPrv = this.bitgo.decrypt({
                input: backupPrivateOrPublicKeyShare,
                password: walletPassphrase,
            });
            userPrv = this.bitgo.decrypt({
                input: userPublicOrPrivateKeyShare,
                password: walletPassphrase,
            });
        }
        catch (e) {
            throw new Error(`Error decrypting backup keychain: ${e.message}`);
        }
        const userSigningMaterial = JSON.parse(userPrv);
        const backupSigningMaterial = JSON.parse(backupPrv);
        if (!userSigningMaterial.backupNShare) {
            throw new Error('Invalid user key - missing backupNShare');
        }
        if (!backupSigningMaterial.userNShare) {
            throw new Error('Invalid backup key - missing userNShare');
        }
        const MPC = new sdk_core_1.Ecdsa();
        const userKeyCombined = MPC.keyCombine(userSigningMaterial.pShare, [
            userSigningMaterial.bitgoNShare,
            userSigningMaterial.backupNShare,
        ]);
        const userSigningKeyDerived = MPC.keyDerive(userSigningMaterial.pShare, [userSigningMaterial.bitgoNShare, userSigningMaterial.backupNShare], 'm/0');
        const userKeyDerivedCombined = {
            xShare: userSigningKeyDerived.xShare,
            yShares: userKeyCombined.yShares,
        };
        const backupKeyCombined = MPC.keyCombine(backupSigningMaterial.pShare, [
            userSigningKeyDerived.nShares[2],
            backupSigningMaterial.bitgoNShare,
        ]);
        if (userKeyDerivedCombined.xShare.y !== backupKeyCombined.xShare.y ||
            userKeyDerivedCombined.xShare.chaincode !== backupKeyCombined.xShare.chaincode) {
            throw new Error('Common keychains do not match');
        }
        return [userKeyDerivedCombined, backupKeyCombined];
    }
    // TODO(BG-78714): Reduce code duplication between this and eth.ts
    async signRecoveryTSS(userKeyCombined, backupKeyCombined, txHex, { rangeProofChallenge, } = {}) {
        const MPC = new sdk_core_1.Ecdsa();
        const signerOneIndex = userKeyCombined.xShare.i;
        const signerTwoIndex = backupKeyCombined.xShare.i;
        // Since this is a user <> backup signing, we will reuse the same range proof challenge
        rangeProofChallenge =
            rangeProofChallenge !== null && rangeProofChallenge !== void 0 ? rangeProofChallenge : sdk_lib_mpc_1.EcdsaTypes.serializeNtildeWithProofs(await sdk_lib_mpc_1.EcdsaRangeProof.generateNtilde());
        const userToBackupPaillierChallenge = await sdk_lib_mpc_1.EcdsaPaillierProof.generateP((0, sdk_core_1.hexToBigInt)(userKeyCombined.yShares[signerTwoIndex].n));
        const backupToUserPaillierChallenge = await sdk_lib_mpc_1.EcdsaPaillierProof.generateP((0, sdk_core_1.hexToBigInt)(backupKeyCombined.yShares[signerOneIndex].n));
        const userXShare = MPC.appendChallenge(userKeyCombined.xShare, rangeProofChallenge, sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({ p: userToBackupPaillierChallenge }));
        const userYShare = MPC.appendChallenge(userKeyCombined.yShares[signerTwoIndex], rangeProofChallenge, sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({ p: backupToUserPaillierChallenge }));
        const backupXShare = MPC.appendChallenge(backupKeyCombined.xShare, rangeProofChallenge, sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({ p: backupToUserPaillierChallenge }));
        const backupYShare = MPC.appendChallenge(backupKeyCombined.yShares[signerOneIndex], rangeProofChallenge, sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({ p: userToBackupPaillierChallenge }));
        const signShares = await MPC.signShare(userXShare, userYShare);
        const signConvertS21 = await MPC.signConvertStep1({
            xShare: backupXShare,
            yShare: backupYShare,
            kShare: signShares.kShare,
        });
        const signConvertS12 = await MPC.signConvertStep2({
            aShare: signConvertS21.aShare,
            wShare: signShares.wShare,
        });
        const signConvertS21_2 = await MPC.signConvertStep3({
            muShare: signConvertS12.muShare,
            bShare: signConvertS21.bShare,
        });
        const [signCombineOne, signCombineTwo] = [
            MPC.signCombine({
                gShare: signConvertS12.gShare,
                signIndex: {
                    i: signConvertS12.muShare.i,
                    j: signConvertS12.muShare.j,
                },
            }),
            MPC.signCombine({
                gShare: signConvertS21_2.gShare,
                signIndex: {
                    i: signConvertS21_2.signIndex.i,
                    j: signConvertS21_2.signIndex.j,
                },
            }),
        ];
        const MESSAGE = buffer_1.Buffer.from(txHex, 'hex');
        const [signA, signB] = [
            MPC.sign(MESSAGE, signCombineOne.oShare, signCombineTwo.dShare, this.getHashFunction()),
            MPC.sign(MESSAGE, signCombineTwo.oShare, signCombineOne.dShare, this.getHashFunction()),
        ];
        return MPC.constructSignature([signA, signB]);
    }
    /** @inheritDoc **/
    async verifyTransaction(params) {
        var _a;
        let totalAmount = new bignumber_js_1.BigNumber(0);
        const { txPrebuild, txParams } = params;
        const rawTx = txPrebuild.txHex;
        if (!rawTx) {
            throw new Error('missing required tx prebuild property txHex');
        }
        const transaction = await this.getBuilder().from(rawTx).build();
        const explainedTx = transaction.explainTransaction();
        if (txParams.recipients && txParams.recipients.length > 0) {
            const filteredRecipients = (_a = txParams.recipients) === null || _a === void 0 ? void 0 : _a.map((recipient) => _.pick(recipient, ['address', 'amount']));
            const filteredOutputs = explainedTx.outputs.map((output) => _.pick(output, ['address', 'amount']));
            if (!_.isEqual(filteredOutputs, filteredRecipients)) {
                throw new Error('Tx outputs does not match with expected txParams recipients');
            }
            // WithdrawDelegatorRewards and ContractCall transaction don't have amount
            if (transaction.type !== sdk_core_1.TransactionType.StakingWithdraw && transaction.type !== sdk_core_1.TransactionType.ContractCall) {
                for (const recipients of txParams.recipients) {
                    totalAmount = totalAmount.plus(recipients.amount);
                }
                if (!totalAmount.isEqualTo(explainedTx.outputAmount)) {
                    throw new Error('Tx total amount does not match with expected total amount field');
                }
            }
        }
        return true;
    }
    /** @inheritDoc **/
    async explainTransaction(options) {
        if (!options.txHex) {
            throw new Error('missing required txHex parameter');
        }
        try {
            const transactionBuilder = this.getBuilder().from(options.txHex);
            const transaction = await transactionBuilder.build();
            return transaction.explainTransaction();
        }
        catch (e) {
            throw new Error('Invalid transaction: ' + e.message);
        }
    }
    /**
     * Sign a transaction with a single private key
     * @param params parameters in the form of { txPrebuild: {txHex}, prv }
     * @returns signed transaction in the form of { txHex }
     */
    async signTransaction(params) {
        var _a;
        const txHex = (_a = params === null || params === void 0 ? void 0 : params.txPrebuild) === null || _a === void 0 ? void 0 : _a.txHex;
        const privateKey = params === null || params === void 0 ? void 0 : params.prv;
        if (!txHex) {
            throw new sdk_core_1.SigningError('missing required txPrebuild parameter: params.txPrebuild.txHex');
        }
        if (!privateKey) {
            throw new sdk_core_1.SigningError('missing required prv parameter: params.prv');
        }
        const txBuilder = this.getBuilder().from(params.txPrebuild.txHex);
        txBuilder.sign({ key: params.prv });
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new sdk_core_1.SigningError('Failed to build signed transaction');
        }
        const serializedTx = transaction.toBroadcastFormat();
        return {
            txHex: serializedTx,
        };
    }
    /** @inheritDoc **/
    async parseTransaction(params) {
        const transactionExplanation = await this.explainTransaction({ txHex: params.txHex });
        if (!transactionExplanation) {
            throw new Error('Invalid transaction');
        }
        if (transactionExplanation.outputs.length <= 0) {
            return {
                inputs: [],
                outputs: [],
            };
        }
        const senderAddress = transactionExplanation.outputs[0].address;
        const feeAmount = new bignumber_js_1.BigNumber(transactionExplanation.fee.fee === '' ? '0' : transactionExplanation.fee.fee);
        const inputs = [
            {
                address: senderAddress,
                amount: new bignumber_js_1.BigNumber(transactionExplanation.outputAmount).plus(feeAmount).toFixed(),
            },
        ];
        const outputs = transactionExplanation.outputs.map((output) => {
            return {
                address: output.address,
                amount: new bignumber_js_1.BigNumber(output.amount).toFixed(),
            };
        });
        return {
            inputs,
            outputs,
        };
    }
    /**
     * Get the public node url from the Environments constant we have defined
     */
    getPublicNodeUrl() {
        throw new Error('Method not implemented.');
    }
    /**
     * Get account number from public node
     */
    async getAccountFromNode(senderAddress) {
        const nodeUrl = this.getPublicNodeUrl();
        const getAccountPath = '/cosmos/auth/v1beta1/accounts/';
        const fullEndpoint = nodeUrl + getAccountPath + senderAddress;
        try {
            return await request.get(fullEndpoint).send();
        }
        catch (e) {
            console.debug(e);
        }
        throw new Error(`Unable to call endpoint ${getAccountPath + senderAddress} from node: ${nodeUrl}`);
    }
    /**
     * Get balance from public node
     */
    async getBalanceFromNode(senderAddress) {
        const nodeUrl = this.getPublicNodeUrl();
        const getBalancePath = '/cosmos/bank/v1beta1/balances/';
        const fullEndpoint = nodeUrl + getBalancePath + senderAddress;
        try {
            return await request.get(fullEndpoint).send();
        }
        catch (e) {
            console.debug(e);
        }
        throw new Error(`Unable to call endpoint ${getBalancePath + senderAddress} from node: ${nodeUrl}`);
    }
    /**
     * Get chain id from public node
     */
    async getChainIdFromNode() {
        const nodeUrl = this.getPublicNodeUrl();
        const getLatestBlockPath = '/cosmos/base/tendermint/v1beta1/blocks/latest';
        const fullEndpoint = nodeUrl + getLatestBlockPath;
        try {
            return await request.get(fullEndpoint).send();
        }
        catch (e) {
            console.debug(e);
        }
        throw new Error(`Unable to call endpoint ${getLatestBlockPath} from node: ${nodeUrl}`);
    }
    /**
     * Helper to fetch account balance
     */
    async getAccountBalance(senderAddress) {
        const response = await this.getBalanceFromNode(senderAddress);
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        const balance = response.body.balances.find((item) => item.denom === this.getDenomination());
        return balance.amount;
    }
    /**
     * Helper to fetch chainId
     */
    async getChainId() {
        const response = await this.getChainIdFromNode();
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return response.body.block.header.chain_id;
    }
    /**
     * Helper to fetch account number
     */
    async getAccountDetails(senderAddress) {
        const response = await this.getAccountFromNode(senderAddress);
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return [response.body.account.account_number, response.body.account.sequence];
    }
    /** @inheritDoc **/
    generateKeyPair(seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = (0, crypto_1.randomBytes)(512 / 8);
        }
        const extendedKey = utxo_lib_1.bip32.fromSeed(seed);
        return {
            pub: extendedKey.neutered().toBase58(),
            prv: extendedKey.toBase58(),
        };
    }
    /**
     * Retrieves the address from a public key.
     * @param {string} pubKey - The public key.
     * @returns {string} The corresponding address.
     */
    getAddressFromPublicKey(pubKey) {
        throw new Error('Method not implemented');
    }
    /** @inheritDoc **/
    async isWalletAddress(params) {
        const addressDetails = this.getAddressDetails(params.address);
        if (!this.isValidAddress(addressDetails.address)) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${addressDetails.address}`);
        }
        const rootAddress = params.coinSpecific.rootAddress;
        if (addressDetails.address !== rootAddress) {
            throw new sdk_core_1.UnexpectedAddressError(`address validation failure: ${addressDetails.address} vs ${rootAddress}`);
        }
        return true;
    }
    /** @inheritDoc **/
    getHashFunction() {
        return utils_1.default.getHashFunction();
    }
    /**
     * Process address into address and memo id
     *
     * @param address the address
     * @returns object containing address and memo id
     */
    getAddressDetails(address) {
        const destinationDetails = url.parse(address);
        const destinationAddress = destinationDetails.pathname || '';
        // address doesn't have a memo id
        if (destinationDetails.pathname === address) {
            return {
                address: address,
                memoId: undefined,
            };
        }
        if (!destinationDetails.query) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        const queryDetails = querystring.parse(destinationDetails.query);
        if (!queryDetails.memoId) {
            // if there are more properties, the query details need to contain the memo id property
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        if (Array.isArray(queryDetails.memoId)) {
            throw new sdk_core_1.InvalidAddressError(`memoId may only be given at most once, but found ${queryDetails.memoId.length} instances in address ${address}`);
        }
        if (Array.isArray(queryDetails.memoId) && queryDetails.memoId.length !== 1) {
            // valid addresses can only contain one memo id
            throw new sdk_core_1.InvalidAddressError(`invalid address '${address}', must contain exactly one memoId`);
        }
        const [memoId] = _.castArray(queryDetails.memoId) || undefined;
        if (!this.isValidMemoId(memoId)) {
            throw new sdk_core_1.InvalidMemoIdError(`invalid address: '${address}', memoId is not valid`);
        }
        return {
            address: destinationAddress,
            memoId,
        };
    }
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId memo id
     * @returns true if memo id is valid
     */
    isValidMemoId(memoId) {
        return utils_1.default.isValidMemoId(memoId);
    }
    /**
     * Helper method to return the respective coin's base unit
     */
    getDenomination() {
        throw new Error('Method not implemented');
    }
    /**
     * Helper method to fetch gas amount details for respective coin
     */
    getGasAmountDetails() {
        throw new Error('Method not implemented');
    }
    /**
     * Helper method to get key pair for individual coin
     * @param publicKey
     */
    getKeyPair(publicKey) {
        throw new Error('Method not implemented');
    }
}
exports.CosmosCoin = CosmosCoin;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29zbW9zQ29pbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3Ntb3NDb2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDhDQXNCeUI7QUFDekIsb0RBQXFGO0FBRXJGLDhDQUF3QztBQUV4QywrQ0FBeUM7QUFDekMsbUNBQWdDO0FBQ2hDLG1DQUEyQztBQUMzQyw0QkFBNEI7QUFDNUIsMkNBQTJDO0FBQzNDLHNDQUFzQztBQUN0QywyQkFBMkI7QUFXM0IsK0NBQTRDO0FBQzVDLHVDQUFnQztBQWlCaEMsTUFBYSxVQUFXLFNBQVEsbUJBQVE7SUFFdEMsWUFBc0IsS0FBZ0IsRUFBRSxXQUF1QztRQUM3RSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFYixJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztTQUN2RTtRQUVELElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO0lBQ2xDLENBQUM7SUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLEtBQWdCLEVBQUUsV0FBdUM7UUFDN0UsT0FBTyxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsVUFBVTtRQUNSLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQsbUJBQW1CO0lBQ25CLGFBQWE7UUFDWCxNQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVELG1CQUFtQjtJQUNuQixRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQztJQUNoQyxDQUFDO0lBRUQsbUJBQW1CO0lBQ25CLFNBQVM7UUFDUCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDO0lBQ2xDLENBQUM7SUFFRCxtQkFBbUI7SUFDbkIsV0FBVztRQUNULE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUM7SUFDcEMsQ0FBQztJQUVELGtCQUFrQjtJQUNsQixXQUFXO1FBQ1QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsbUJBQW1CO0lBQ25CLGVBQWU7UUFDYixPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0lBRUQsbUJBQW1CO0lBQ25CLFVBQVUsQ0FBQyxHQUFXO1FBQ3BCLE9BQU8sZUFBSyxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRCxtQkFBbUI7SUFDbkIsVUFBVSxDQUFDLEdBQVc7UUFDcEIsT0FBTyxlQUFLLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVELGNBQWMsQ0FBQyxPQUFlO1FBQzVCLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBdUI7UUFDbkMsMkRBQTJEO1FBQzNELElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFO1lBQ3BCLE1BQU0sSUFBSSxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQztTQUNyQztRQUVELElBQUksQ0FBQyxNQUFNLENBQUMsbUJBQW1CLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFO1lBQ25GLE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQztTQUNoRDtRQUVELElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFO1lBQ25CLE1BQU0sSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztTQUNwQztRQUVELElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFO1lBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztTQUN0QztRQUVELElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLEVBQUU7WUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1NBQzlDO1FBRUQsMENBQTBDO1FBQzFDLE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVwRCxxRUFBcUU7UUFDckUsTUFBTSxHQUFHLEdBQUcsSUFBSSxnQkFBSyxFQUFFLENBQUM7UUFDeEIsTUFBTSxPQUFPLEdBQUcsTUFBTSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDeEMsTUFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxxQkFBUyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUN6RSxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFOUQsMkhBQTJIO1FBQzNILE1BQU0sQ0FBQyxhQUFhLEVBQUUsVUFBVSxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDaEYsTUFBTSxPQUFPLEdBQUcsSUFBSSx3QkFBUyxDQUFDLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7UUFDM0UsTUFBTSxTQUFTLEdBQVk7WUFDekIsTUFBTSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLGVBQWUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUN6RixRQUFRLEVBQUUsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUMsUUFBUTtTQUM5QyxDQUFDO1FBQ0YsTUFBTSxTQUFTLEdBQUcsSUFBSSx3QkFBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDNUQsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUUvQyxJQUFJLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUN4QyxNQUFNLElBQUksS0FBSyxDQUFDLHNDQUFzQyxDQUFDLENBQUM7U0FDekQ7UUFFRCwrRUFBK0U7UUFDL0UsTUFBTSxNQUFNLEdBQVc7WUFDckI7Z0JBQ0UsS0FBSyxFQUFFLElBQUksQ0FBQyxlQUFlLEVBQUU7Z0JBQzdCLE1BQU0sRUFBRSxhQUFhLENBQUMsT0FBTyxFQUFFO2FBQ2hDO1NBQ0YsQ0FBQztRQUNGLE1BQU0sV0FBVyxHQUFrQjtZQUNqQztnQkFDRSxXQUFXLEVBQUUsYUFBYTtnQkFDMUIsU0FBUyxFQUFFLE1BQU0sQ0FBQyxtQkFBbUI7Z0JBQ3JDLE1BQU0sRUFBRSxNQUFNO2FBQ2Y7U0FDRixDQUFDO1FBRUYsOERBQThEO1FBQzlELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQzFELFVBQVU7YUFDUCxRQUFRLENBQUMsV0FBVyxDQUFDO2FBQ3JCLFNBQVMsQ0FBQyxTQUFTLENBQUM7YUFDcEIsU0FBUyxDQUFDLFNBQVMsQ0FBQzthQUNwQixRQUFRLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQzVCLGFBQWEsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7YUFDcEMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3BCLE1BQU0sbUJBQW1CLEdBQUcsQ0FBQyxNQUFNLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBc0IsQ0FBQztRQUM1RSxJQUFJLFlBQVksR0FBRyxtQkFBbUIsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQzNELE1BQU0sV0FBVyxHQUFHLG1CQUFtQixDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDeEUsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ2xELE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUN0RCxNQUFNLENBQUMsZUFBZSxFQUFFLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxHQUc1QyxFQUFFO1lBQ0YsTUFBTSxDQUFDLGVBQWUsRUFBRSxpQkFBaUIsQ0FBQyxHQUFHLElBQUksQ0FBQyw4QkFBOEIsQ0FDOUUsT0FBTyxFQUNQLFNBQVMsRUFDVCxNQUFNLENBQUMsZ0JBQWdCLENBQ3hCLENBQUM7WUFDRixPQUFPLENBQUMsZUFBZSxFQUFFLGlCQUFpQixDQUFDLENBQUM7UUFDOUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUVMLElBQUksQ0FBQyxlQUFlLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtZQUMxQyxNQUFNLElBQUksS0FBSyxDQUFDLGdEQUFnRCxDQUFDLENBQUM7U0FDbkU7UUFFRCxzQkFBc0I7UUFDdEIsTUFBTSxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLGVBQWUsRUFBRSxpQkFBaUIsRUFBRSxXQUFXLENBQUMsQ0FBQztRQUM5RixNQUFNLGNBQWMsR0FBRyxlQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN2RCxHQUFHLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7UUFDOUQsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqRCxVQUFVLENBQUMsWUFBWSxDQUFDLEVBQUUsR0FBRyxFQUFFLGFBQWEsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxlQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzdHLE1BQU0saUJBQWlCLEdBQUcsTUFBTSxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDbkQsWUFBWSxHQUFHLGlCQUFpQixDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFFckQsT0FBTyxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsQ0FBQztJQUN4QyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsS0FBSyxDQUFDLFVBQVUsQ0FDZCxNQUlDO1FBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUU7WUFDcEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1NBQ3JDO1FBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLEVBQUU7WUFDbkYsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1NBQ2hEO1FBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLEVBQUU7WUFDbkYsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1NBQ2hEO1FBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUU7WUFDbkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1NBQ3BDO1FBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUU7WUFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQ3RDO1FBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTtZQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLDJCQUEyQixDQUFDLENBQUM7U0FDOUM7UUFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLGtCQUFrQixFQUFFO1lBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLENBQUMsQ0FBQztTQUMvQztRQUVELE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVwRCxNQUFNLEdBQUcsR0FBRyxJQUFJLGdCQUFLLEVBQUUsQ0FBQztRQUN4QixNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUN4QyxNQUFNLFNBQVMsR0FBRyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLHFCQUFTLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3pFLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUU5RCxNQUFNLENBQUMsYUFBYSxFQUFFLFVBQVUsQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ2hGLE1BQU0sU0FBUyxHQUFZO1lBQ3pCLE1BQU0sRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxlQUFlLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDekYsUUFBUSxFQUFFLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLFFBQVE7U0FDOUMsQ0FBQztRQUVGLE1BQU0sTUFBTSxHQUFTO1lBQ25CLEtBQUssRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQzdCLE1BQU0sRUFBRSxJQUFJLHdCQUFTLENBQUMsTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQUMsT0FBTyxFQUFFO1NBQzNELENBQUM7UUFFRixNQUFNLFdBQVcsR0FBd0I7WUFDdkM7Z0JBQ0UsZ0JBQWdCLEVBQUUsYUFBYTtnQkFDL0IsbUJBQW1CLEVBQUUsTUFBTSxDQUFDLG1CQUFtQjtnQkFDL0MsbUJBQW1CLEVBQUUsTUFBTSxDQUFDLG1CQUFtQjtnQkFDL0MsTUFBTSxFQUFFLE1BQU07YUFDZjtTQUNGLENBQUM7UUFFRixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsMkJBQTJCLEVBQUUsQ0FBQztRQUNuRSxVQUFVO2FBQ1AsUUFBUSxDQUFDLFdBQVcsQ0FBQzthQUNyQixTQUFTLENBQUMsU0FBUyxDQUFDO2FBQ3BCLFNBQVMsQ0FBQyxTQUFTLENBQUM7YUFDcEIsUUFBUSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUM1QixhQUFhLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO2FBQ3BDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUVwQixNQUFNLG1CQUFtQixHQUFHLENBQUMsTUFBTSxVQUFVLENBQUMsS0FBSyxFQUFFLENBQXNCLENBQUM7UUFDNUUsSUFBSSxZQUFZLEdBQUcsbUJBQW1CLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUMzRCxNQUFNLFdBQVcsR0FBRyxtQkFBbUIsQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3hFLE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNsRCxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDdEQsTUFBTSxDQUFDLGVBQWUsRUFBRSxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsR0FHNUMsRUFBRTtZQUNGLE1BQU0sQ0FBQyxlQUFlLEVBQUUsaUJBQWlCLENBQUMsR0FBRyxJQUFJLENBQUMsOEJBQThCLENBQzlFLE9BQU8sRUFDUCxTQUFTLEVBQ1QsTUFBTSxDQUFDLGdCQUFnQixDQUN4QixDQUFDO1lBQ0YsT0FBTyxDQUFDLGVBQWUsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1FBQzlDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFFTCxJQUFJLENBQUMsZUFBZSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDMUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxnREFBZ0QsQ0FBQyxDQUFDO1NBQ25FO1FBRUQsTUFBTSxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLGVBQWUsRUFBRSxpQkFBaUIsRUFBRSxXQUFXLENBQUMsQ0FBQztRQUM5RixNQUFNLGNBQWMsR0FBRyxlQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN2RCxHQUFHLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7UUFDOUQsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqRCxVQUFVLENBQUMsWUFBWSxDQUFDLEVBQUUsR0FBRyxFQUFFLGFBQWEsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxlQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzdHLE1BQU0saUJBQWlCLEdBQUcsTUFBTSxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDbkQsWUFBWSxHQUFHLGlCQUFpQixDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFFckQsT0FBTyxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsQ0FBQztJQUN4QyxDQUFDO0lBRU8sOEJBQThCLENBQ3BDLDJCQUFtQyxFQUNuQyw2QkFBcUMsRUFDckMsZ0JBQXlCO1FBRXpCLElBQUksU0FBUyxDQUFDO1FBQ2QsSUFBSSxPQUFPLENBQUM7UUFDWixJQUFJO1lBQ0YsU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDO2dCQUM3QixLQUFLLEVBQUUsNkJBQTZCO2dCQUNwQyxRQUFRLEVBQUUsZ0JBQWdCO2FBQzNCLENBQUMsQ0FBQztZQUNILE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQztnQkFDM0IsS0FBSyxFQUFFLDJCQUEyQjtnQkFDbEMsUUFBUSxFQUFFLGdCQUFnQjthQUMzQixDQUFDLENBQUM7U0FDSjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7U0FDbkU7UUFFRCxNQUFNLG1CQUFtQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFxQyxDQUFDO1FBQ3BGLE1BQU0scUJBQXFCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQXFDLENBQUM7UUFFeEYsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFlBQVksRUFBRTtZQUNyQyxNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7U0FDNUQ7UUFFRCxJQUFJLENBQUMscUJBQXFCLENBQUMsVUFBVSxFQUFFO1lBQ3JDLE1BQU0sSUFBSSxLQUFLLENBQUMseUNBQXlDLENBQUMsQ0FBQztTQUM1RDtRQUVELE1BQU0sR0FBRyxHQUFHLElBQUksZ0JBQUssRUFBRSxDQUFDO1FBRXhCLE1BQU0sZUFBZSxHQUFHLEdBQUcsQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUMsTUFBTSxFQUFFO1lBQ2pFLG1CQUFtQixDQUFDLFdBQVc7WUFDL0IsbUJBQW1CLENBQUMsWUFBWTtTQUNqQyxDQUFDLENBQUM7UUFFSCxNQUFNLHFCQUFxQixHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQ3pDLG1CQUFtQixDQUFDLE1BQU0sRUFDMUIsQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLEVBQUUsbUJBQW1CLENBQUMsWUFBWSxDQUFDLEVBQ25FLEtBQUssQ0FDTixDQUFDO1FBRUYsTUFBTSxzQkFBc0IsR0FBRztZQUM3QixNQUFNLEVBQUUscUJBQXFCLENBQUMsTUFBTTtZQUNwQyxPQUFPLEVBQUUsZUFBZSxDQUFDLE9BQU87U0FDakMsQ0FBQztRQUVGLE1BQU0saUJBQWlCLEdBQUcsR0FBRyxDQUFDLFVBQVUsQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLEVBQUU7WUFDckUscUJBQXFCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztZQUNoQyxxQkFBcUIsQ0FBQyxXQUFXO1NBQ2xDLENBQUMsQ0FBQztRQUVILElBQ0Usc0JBQXNCLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM5RCxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsU0FBUyxLQUFLLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQzlFO1lBQ0EsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO1NBQ2xEO1FBRUQsT0FBTyxDQUFDLHNCQUFzQixFQUFFLGlCQUFpQixDQUFDLENBQUM7SUFDckQsQ0FBQztJQUVELGtFQUFrRTtJQUMxRCxLQUFLLENBQUMsZUFBZSxDQUMzQixlQUFrQyxFQUNsQyxpQkFBb0MsRUFDcEMsS0FBYSxFQUNiLEVBQ0UsbUJBQW1CLE1BR2pCLEVBQUU7UUFFTixNQUFNLEdBQUcsR0FBRyxJQUFJLGdCQUFLLEVBQUUsQ0FBQztRQUN4QixNQUFNLGNBQWMsR0FBRyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUNoRCxNQUFNLGNBQWMsR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBRWxELHVGQUF1RjtRQUN2RixtQkFBbUI7WUFDakIsbUJBQW1CLGFBQW5CLG1CQUFtQixjQUFuQixtQkFBbUIsR0FBSSx3QkFBVSxDQUFDLHlCQUF5QixDQUFDLE1BQU0sNkJBQWUsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDO1FBRXRHLE1BQU0sNkJBQTZCLEdBQUcsTUFBTSxnQ0FBa0IsQ0FBQyxTQUFTLENBQ3RFLElBQUEsc0JBQVcsRUFBQyxlQUFlLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUN2RCxDQUFDO1FBQ0YsTUFBTSw2QkFBNkIsR0FBRyxNQUFNLGdDQUFrQixDQUFDLFNBQVMsQ0FDdEUsSUFBQSxzQkFBVyxFQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDekQsQ0FBQztRQUVGLE1BQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQyxlQUFlLENBQ3BDLGVBQWUsQ0FBQyxNQUFNLEVBQ3RCLG1CQUFtQixFQUNuQix3QkFBVSxDQUFDLDBCQUEwQixDQUFDLEVBQUUsQ0FBQyxFQUFFLDZCQUE2QixFQUFFLENBQUMsQ0FDNUUsQ0FBQztRQUNGLE1BQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQyxlQUFlLENBQ3BDLGVBQWUsQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLEVBQ3ZDLG1CQUFtQixFQUNuQix3QkFBVSxDQUFDLDBCQUEwQixDQUFDLEVBQUUsQ0FBQyxFQUFFLDZCQUE2QixFQUFFLENBQUMsQ0FDNUUsQ0FBQztRQUNGLE1BQU0sWUFBWSxHQUFHLEdBQUcsQ0FBQyxlQUFlLENBQ3RDLGlCQUFpQixDQUFDLE1BQU0sRUFDeEIsbUJBQW1CLEVBQ25CLHdCQUFVLENBQUMsMEJBQTBCLENBQUMsRUFBRSxDQUFDLEVBQUUsNkJBQTZCLEVBQUUsQ0FBQyxDQUM1RSxDQUFDO1FBQ0YsTUFBTSxZQUFZLEdBQUcsR0FBRyxDQUFDLGVBQWUsQ0FDdEMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxFQUN6QyxtQkFBbUIsRUFDbkIsd0JBQVUsQ0FBQywwQkFBMEIsQ0FBQyxFQUFFLENBQUMsRUFBRSw2QkFBNkIsRUFBRSxDQUFDLENBQzVFLENBQUM7UUFFRixNQUFNLFVBQVUsR0FBc0IsTUFBTSxHQUFHLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUVsRixNQUFNLGNBQWMsR0FBRyxNQUFNLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQztZQUNoRCxNQUFNLEVBQUUsWUFBWTtZQUNwQixNQUFNLEVBQUUsWUFBWTtZQUNwQixNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU07U0FDMUIsQ0FBQyxDQUFDO1FBQ0gsTUFBTSxjQUFjLEdBQUcsTUFBTSxHQUFHLENBQUMsZ0JBQWdCLENBQUM7WUFDaEQsTUFBTSxFQUFFLGNBQWMsQ0FBQyxNQUFNO1lBQzdCLE1BQU0sRUFBRSxVQUFVLENBQUMsTUFBTTtTQUMxQixDQUFDLENBQUM7UUFDSCxNQUFNLGdCQUFnQixHQUFHLE1BQU0sR0FBRyxDQUFDLGdCQUFnQixDQUFDO1lBQ2xELE9BQU8sRUFBRSxjQUFjLENBQUMsT0FBTztZQUMvQixNQUFNLEVBQUUsY0FBYyxDQUFDLE1BQU07U0FDOUIsQ0FBQyxDQUFDO1FBRUgsTUFBTSxDQUFDLGNBQWMsRUFBRSxjQUFjLENBQUMsR0FBRztZQUN2QyxHQUFHLENBQUMsV0FBVyxDQUFDO2dCQUNkLE1BQU0sRUFBRSxjQUFjLENBQUMsTUFBTTtnQkFDN0IsU0FBUyxFQUFFO29CQUNULENBQUMsRUFBRSxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBQzNCLENBQUMsRUFBRSxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7aUJBQzVCO2FBQ0YsQ0FBQztZQUNGLEdBQUcsQ0FBQyxXQUFXLENBQUM7Z0JBQ2QsTUFBTSxFQUFFLGdCQUFnQixDQUFDLE1BQU07Z0JBQy9CLFNBQVMsRUFBRTtvQkFDVCxDQUFDLEVBQUUsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7b0JBQy9CLENBQUMsRUFBRSxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztpQkFDaEM7YUFDRixDQUFDO1NBQ0gsQ0FBQztRQUVGLE1BQU0sT0FBTyxHQUFHLGVBQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRTFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEdBQUc7WUFDckIsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsY0FBYyxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUN2RixHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxjQUFjLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1NBQ3hGLENBQUM7UUFFRixPQUFPLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRCxtQkFBbUI7SUFDbkIsS0FBSyxDQUFDLGlCQUFpQixDQUFDLE1BQWdDOztRQUN0RCxJQUFJLFdBQVcsR0FBRyxJQUFJLHdCQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbkMsTUFBTSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsR0FBRyxNQUFNLENBQUM7UUFDeEMsTUFBTSxLQUFLLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQztRQUMvQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO1NBQ2hFO1FBQ0QsTUFBTSxXQUFXLEdBQUcsTUFBTSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2hFLE1BQU0sV0FBVyxHQUFHLFdBQVcsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBRXJELElBQUksUUFBUSxDQUFDLFVBQVUsSUFBSSxRQUFRLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDekQsTUFBTSxrQkFBa0IsR0FBRyxNQUFBLFFBQVEsQ0FBQyxVQUFVLDBDQUFFLEdBQUcsQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzdHLE1BQU0sZUFBZSxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLFNBQVMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFbkcsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsZUFBZSxFQUFFLGtCQUFrQixDQUFDLEVBQUU7Z0JBQ25ELE1BQU0sSUFBSSxLQUFLLENBQUMsNkRBQTZELENBQUMsQ0FBQzthQUNoRjtZQUNELDBFQUEwRTtZQUMxRSxJQUFJLFdBQVcsQ0FBQyxJQUFJLEtBQUssMEJBQWUsQ0FBQyxlQUFlLElBQUksV0FBVyxDQUFDLElBQUksS0FBSywwQkFBZSxDQUFDLFlBQVksRUFBRTtnQkFDN0csS0FBSyxNQUFNLFVBQVUsSUFBSSxRQUFRLENBQUMsVUFBVSxFQUFFO29CQUM1QyxXQUFXLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7aUJBQ25EO2dCQUNELElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsRUFBRTtvQkFDcEQsTUFBTSxJQUFJLEtBQUssQ0FBQyxpRUFBaUUsQ0FBQyxDQUFDO2lCQUNwRjthQUNGO1NBQ0Y7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxtQkFBbUI7SUFDbkIsS0FBSyxDQUFDLGtCQUFrQixDQUFDLE9BQTBCO1FBQ2pELElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFO1lBQ2xCLE1BQU0sSUFBSSxLQUFLLENBQUMsa0NBQWtDLENBQUMsQ0FBQztTQUNyRDtRQUNELElBQUk7WUFDRixNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ2pFLE1BQU0sV0FBVyxHQUFHLE1BQU0sa0JBQWtCLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDckQsT0FBTyxXQUFXLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztTQUN6QztRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDdEQ7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxlQUFlLENBQ25CLE1BQStFOztRQUUvRSxNQUFNLEtBQUssR0FBRyxNQUFBLE1BQU0sYUFBTixNQUFNLHVCQUFOLE1BQU0sQ0FBRSxVQUFVLDBDQUFFLEtBQUssQ0FBQztRQUN4QyxNQUFNLFVBQVUsR0FBRyxNQUFNLGFBQU4sTUFBTSx1QkFBTixNQUFNLENBQUUsR0FBRyxDQUFDO1FBQy9CLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDVixNQUFNLElBQUksdUJBQVksQ0FBQyxnRUFBZ0UsQ0FBQyxDQUFDO1NBQzFGO1FBQ0QsSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNmLE1BQU0sSUFBSSx1QkFBWSxDQUFDLDRDQUE0QyxDQUFDLENBQUM7U0FDdEU7UUFDRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbEUsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUNwQyxNQUFNLFdBQVcsR0FBb0IsTUFBTSxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDN0QsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNoQixNQUFNLElBQUksdUJBQVksQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO1NBQzlEO1FBQ0QsTUFBTSxZQUFZLEdBQUcsV0FBVyxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDckQsT0FBTztZQUNMLEtBQUssRUFBRSxZQUFZO1NBQ3BCLENBQUM7SUFDSixDQUFDO0lBRUQsbUJBQW1CO0lBQ25CLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFtRDtRQUN4RSxNQUFNLHNCQUFzQixHQUFHLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBQ3RGLElBQUksQ0FBQyxzQkFBc0IsRUFBRTtZQUMzQixNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUM7U0FDeEM7UUFFRCxJQUFJLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO1lBQzlDLE9BQU87Z0JBQ0wsTUFBTSxFQUFFLEVBQUU7Z0JBQ1YsT0FBTyxFQUFFLEVBQUU7YUFDWixDQUFDO1NBQ0g7UUFDRCxNQUFNLGFBQWEsR0FBRyxzQkFBc0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO1FBQ2hFLE1BQU0sU0FBUyxHQUFHLElBQUksd0JBQVMsQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDOUcsTUFBTSxNQUFNLEdBQUc7WUFDYjtnQkFDRSxPQUFPLEVBQUUsYUFBYTtnQkFDdEIsTUFBTSxFQUFFLElBQUksd0JBQVMsQ0FBQyxzQkFBc0IsQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxFQUFFO2FBQ3JGO1NBQ0YsQ0FBQztRQUNGLE1BQU0sT0FBTyxHQUFHLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRTtZQUM1RCxPQUFPO2dCQUNMLE9BQU8sRUFBRSxNQUFNLENBQUMsT0FBTztnQkFDdkIsTUFBTSxFQUFFLElBQUksd0JBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxFQUFFO2FBQy9DLENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQztRQUNILE9BQU87WUFDTCxNQUFNO1lBQ04sT0FBTztTQUNSLENBQUM7SUFDSixDQUFDO0lBRUQ7O09BRUc7SUFDTyxnQkFBZ0I7UUFDeEIsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRDs7T0FFRztJQUNPLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxhQUFxQjtRQUN0RCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUN4QyxNQUFNLGNBQWMsR0FBRyxnQ0FBZ0MsQ0FBQztRQUN4RCxNQUFNLFlBQVksR0FBRyxPQUFPLEdBQUcsY0FBYyxHQUFHLGFBQWEsQ0FBQztRQUM5RCxJQUFJO1lBQ0YsT0FBTyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDL0M7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDbEI7UUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLDJCQUEyQixjQUFjLEdBQUcsYUFBYSxlQUFlLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFDckcsQ0FBQztJQUVEOztPQUVHO0lBQ08sS0FBSyxDQUFDLGtCQUFrQixDQUFDLGFBQXFCO1FBQ3RELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ3hDLE1BQU0sY0FBYyxHQUFHLGdDQUFnQyxDQUFDO1FBQ3hELE1BQU0sWUFBWSxHQUFHLE9BQU8sR0FBRyxjQUFjLEdBQUcsYUFBYSxDQUFDO1FBQzlELElBQUk7WUFDRixPQUFPLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUMvQztRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNsQjtRQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLGNBQWMsR0FBRyxhQUFhLGVBQWUsT0FBTyxFQUFFLENBQUMsQ0FBQztJQUNyRyxDQUFDO0lBRUQ7O09BRUc7SUFDTyxLQUFLLENBQUMsa0JBQWtCO1FBQ2hDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ3hDLE1BQU0sa0JBQWtCLEdBQUcsK0NBQStDLENBQUM7UUFDM0UsTUFBTSxZQUFZLEdBQUcsT0FBTyxHQUFHLGtCQUFrQixDQUFDO1FBQ2xELElBQUk7WUFDRixPQUFPLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUMvQztRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNsQjtRQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLGtCQUFrQixlQUFlLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFDekYsQ0FBQztJQUVEOztPQUVHO0lBQ08sS0FBSyxDQUFDLGlCQUFpQixDQUFDLGFBQXFCO1FBQ3JELE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQzlELElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxHQUFHLEVBQUU7WUFDM0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQ3RDO1FBQ0QsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxLQUFLLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDO1FBQzdGLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQztJQUN4QixDQUFDO0lBRUQ7O09BRUc7SUFDTyxLQUFLLENBQUMsVUFBVTtRQUN4QixNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQ2pELElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxHQUFHLEVBQUU7WUFDM0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQ3RDO1FBQ0QsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO0lBQzdDLENBQUM7SUFFRDs7T0FFRztJQUNPLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxhQUFxQjtRQUNyRCxNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUM5RCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssR0FBRyxFQUFFO1lBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztTQUN0QztRQUNELE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDaEYsQ0FBQztJQUVELG1CQUFtQjtJQUNuQixlQUFlLENBQUMsSUFBYTtRQUMzQixJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1QsMEVBQTBFO1lBQzFFLDBFQUEwRTtZQUMxRSxrRUFBa0U7WUFDbEUsSUFBSSxHQUFHLElBQUEsb0JBQVcsRUFBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDN0I7UUFDRCxNQUFNLFdBQVcsR0FBRyxnQkFBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6QyxPQUFPO1lBQ0wsR0FBRyxFQUFFLFdBQVcsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUU7WUFDdEMsR0FBRyxFQUFFLFdBQVcsQ0FBQyxRQUFRLEVBQUU7U0FDNUIsQ0FBQztJQUNKLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsdUJBQXVCLENBQUMsTUFBYztRQUNwQyxNQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVELG1CQUFtQjtJQUNuQixLQUFLLENBQUMsZUFBZSxDQUFDLE1BQTRCO1FBQ2hELE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFOUQsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ2hELE1BQU0sSUFBSSw4QkFBbUIsQ0FBQyxvQkFBb0IsY0FBYyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7U0FDN0U7UUFDRCxNQUFNLFdBQVcsR0FBSSxNQUFNLENBQUMsWUFBbUMsQ0FBQyxXQUFXLENBQUM7UUFDNUUsSUFBSSxjQUFjLENBQUMsT0FBTyxLQUFLLFdBQVcsRUFBRTtZQUMxQyxNQUFNLElBQUksaUNBQXNCLENBQUMsK0JBQStCLGNBQWMsQ0FBQyxPQUFPLE9BQU8sV0FBVyxFQUFFLENBQUMsQ0FBQztTQUM3RztRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELG1CQUFtQjtJQUNuQixlQUFlO1FBQ2IsT0FBTyxlQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDakMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsaUJBQWlCLENBQUMsT0FBZTtRQUMvQixNQUFNLGtCQUFrQixHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUMsTUFBTSxrQkFBa0IsR0FBRyxrQkFBa0IsQ0FBQyxRQUFRLElBQUksRUFBRSxDQUFDO1FBRTdELGlDQUFpQztRQUNqQyxJQUFJLGtCQUFrQixDQUFDLFFBQVEsS0FBSyxPQUFPLEVBQUU7WUFDM0MsT0FBTztnQkFDTCxPQUFPLEVBQUUsT0FBTztnQkFDaEIsTUFBTSxFQUFFLFNBQVM7YUFDbEIsQ0FBQztTQUNIO1FBRUQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRTtZQUM3QixNQUFNLElBQUksOEJBQW1CLENBQUMsb0JBQW9CLE9BQU8sRUFBRSxDQUFDLENBQUM7U0FDOUQ7UUFFRCxNQUFNLFlBQVksR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2pFLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFO1lBQ3hCLHVGQUF1RjtZQUN2RixNQUFNLElBQUksOEJBQW1CLENBQUMsb0JBQW9CLE9BQU8sRUFBRSxDQUFDLENBQUM7U0FDOUQ7UUFFRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ3RDLE1BQU0sSUFBSSw4QkFBbUIsQ0FDM0Isb0RBQW9ELFlBQVksQ0FBQyxNQUFNLENBQUMsTUFBTSx5QkFBeUIsT0FBTyxFQUFFLENBQ2pILENBQUM7U0FDSDtRQUVELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQzFFLCtDQUErQztZQUMvQyxNQUFNLElBQUksOEJBQW1CLENBQUMsb0JBQW9CLE9BQU8sb0NBQW9DLENBQUMsQ0FBQztTQUNoRztRQUVELE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxTQUFTLENBQUM7UUFDL0QsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDL0IsTUFBTSxJQUFJLDZCQUFrQixDQUFDLHFCQUFxQixPQUFPLHdCQUF3QixDQUFDLENBQUM7U0FDcEY7UUFFRCxPQUFPO1lBQ0wsT0FBTyxFQUFFLGtCQUFrQjtZQUMzQixNQUFNO1NBQ1AsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGFBQWEsQ0FBQyxNQUFjO1FBQzFCLE9BQU8sZUFBSyxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxlQUFlO1FBQ2IsTUFBTSxJQUFJLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFRDs7T0FFRztJQUNILG1CQUFtQjtRQUNqQixNQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVEOzs7T0FHRztJQUNILFVBQVUsQ0FBQyxTQUFpQjtRQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUM7SUFDNUMsQ0FBQztDQUNGO0FBcnZCRCxnQ0FxdkJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQmFzZUNvaW4sXG4gIEJhc2VUcmFuc2FjdGlvbixcbiAgQml0R29CYXNlLFxuICBFQ0RTQSxcbiAgRWNkc2EsXG4gIEVDRFNBTWV0aG9kVHlwZXMsXG4gIEV4cGxhbmF0aW9uUmVzdWx0LFxuICBoZXhUb0JpZ0ludCxcbiAgSW52YWxpZEFkZHJlc3NFcnJvcixcbiAgSW52YWxpZE1lbW9JZEVycm9yLFxuICBLZXlQYWlyLFxuICBNUENBbGdvcml0aG0sXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgU2lnbmVkVHJhbnNhY3Rpb24sXG4gIFNpZ25pbmdFcnJvcixcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25UeXBlLFxuICBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgRWNkc2FQYWlsbGllclByb29mLCBFY2RzYVJhbmdlUHJvb2YsIEVjZHNhVHlwZXMgfSBmcm9tICdAYml0Z28vc2RrLWxpYi1tcGMnO1xuaW1wb3J0IHsgQmFzZUNvaW4gYXMgU3RhdGljc0Jhc2VDb2luLCBDb2luRmFtaWx5IH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHsgYmlwMzIgfSBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0IHsgQ29pbiB9IGZyb20gJ0Bjb3NtanMvc3RhcmdhdGUnO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XG5pbXBvcnQgeyBIYXNoLCByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICdxdWVyeXN0cmluZyc7XG5pbXBvcnQgKiBhcyByZXF1ZXN0IGZyb20gJ3N1cGVyYWdlbnQnO1xuaW1wb3J0ICogYXMgdXJsIGZyb20gJ3VybCc7XG5pbXBvcnQge1xuICBDb3Ntb3NLZXlQYWlyLFxuICBDb3Ntb3NMaWtlQ29pblJlY292ZXJ5T3V0cHV0LFxuICBDb3Ntb3NUcmFuc2FjdGlvbixcbiAgRmVlRGF0YSxcbiAgR2FzQW1vdW50RGV0YWlscyxcbiAgUmVjb3ZlcnlPcHRpb25zLFxuICBSZWRlbGVnYXRlTWVzc2FnZSxcbiAgU2VuZE1lc3NhZ2UsXG59IGZyb20gJy4vbGliJztcbmltcG9ydCB7IFJPT1RfUEFUSCB9IGZyb20gJy4vbGliL2NvbnN0YW50cyc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi9saWIvdXRpbHMnO1xuXG4vKipcbiAqIENvc21vcyBhY2NvdW50cyBzdXBwb3J0IG1lbW8gSWQgYmFzZWQgYWRkcmVzc2VzXG4gKi9cbmludGVyZmFjZSBBZGRyZXNzRGV0YWlscyB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgbWVtb0lkPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENvc21vcyBhY2NvdW50cyBzdXBwb3J0IG1lbW8gSWQgYmFzZWQgYWRkcmVzc2VzXG4gKi9cbmludGVyZmFjZSBDb3Ntb3NDb2luU3BlY2lmaWMge1xuICByb290QWRkcmVzczogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ29zbW9zQ29pbiBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9zdGF0aWNzQ29pbjogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPjtcbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHb0Jhc2UsIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPikge1xuICAgIHN1cGVyKGJpdGdvKTtcblxuICAgIGlmICghc3RhdGljc0NvaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgc3RhdGljc0NvaW4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0aWNzQ29pbiA9IHN0YXRpY3NDb2luO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHb0Jhc2UsIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPik6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IENvc21vc0NvaW4oYml0Z28sIHN0YXRpY3NDb2luKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFRyYW5zYWN0aW9uQnVpbGRlckZhY3RvcnkgZm9yIHRoZSBjb2luIHNwZWNpZmljIHNka1xuICAgKi9cbiAgZ2V0QnVpbGRlcigpOiBhbnkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqKi9cbiAgZ2V0QmFzZUZhY3RvcigpOiBzdHJpbmcgfCBudW1iZXIge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICoqL1xuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5uYW1lO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICoqL1xuICBnZXRGYW1pbHkoKTogQ29pbkZhbWlseSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZhbWlseTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqKi9cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZnVsbE5hbWU7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgc3VwcG9ydHNUc3MoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKiovXG4gIGdldE1QQ0FsZ29yaXRobSgpOiBNUENBbGdvcml0aG0ge1xuICAgIHJldHVybiAnZWNkc2EnO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICoqL1xuICBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHV0aWxzLmlzVmFsaWRQdWJsaWNLZXkocHViKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqKi9cbiAgaXNWYWxpZFBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB1dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShwcnYpO1xuICB9XG5cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R29cbiAgICogQHBhcmFtIHtSZWNvdmVyeU9wdGlvbnN9IHBhcmFtcyBwYXJhbWV0ZXJzIG5lZWRlZCB0byBjb25zdHJ1Y3QgYW5kXG4gICAqIChtYXliZSkgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge0Nvc21vc0xpa2VDb2luUmVjb3ZlcnlPdXRwdXR9IHRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIGhleCBzdHJpbmcgYW5kIGluZGV4XG4gICAqIG9mIHRoZSBhZGRyZXNzIGJlaW5nIHN3ZXB0XG4gICAqL1xuICBhc3luYyByZWNvdmVyKHBhcmFtczogUmVjb3ZlcnlPcHRpb25zKTogUHJvbWlzZTxDb3Ntb3NMaWtlQ29pblJlY292ZXJ5T3V0cHV0PiB7XG4gICAgLy8gU3RlcCAxOiBDaGVjayBpZiBwYXJhbXMgY29udGFpbnMgdGhlIHJlcXVpcmVkIHBhcmFtZXRlcnNcbiAgICBpZiAoIXBhcmFtcy5iaXRnb0tleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGJpdGdvS2V5Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbiB8fCAhdGhpcy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZWNvdmVyeURlc3RpbmF0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMudXNlcktleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHVzZXJLZXknKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5iYWNrdXBLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBiYWNrdXBLZXknKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgd2FsbGV0IHBhc3NwaHJhc2UnKTtcbiAgICB9XG5cbiAgICAvLyBTdGVwIDI6IEZldGNoIHRoZSBiaXRnbyBrZXkgZnJvbSBwYXJhbXNcbiAgICBjb25zdCBiaXRnb0tleSA9IHBhcmFtcy5iaXRnb0tleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuXG4gICAgLy8gU3RlcCAzOiBJbnN0YW50aWF0ZSB0aGUgRUNEU0Egc2lnbmVyIGFuZCBmZXRjaCB0aGUgYWRkcmVzcyBkZXRhaWxzXG4gICAgY29uc3QgTVBDID0gbmV3IEVjZHNhKCk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IE1QQy5kZXJpdmVVbmhhcmRlbmVkKGJpdGdvS2V5LCBST09UX1BBVEgpLnNsaWNlKDAsIDY2KTtcbiAgICBjb25zdCBzZW5kZXJBZGRyZXNzID0gdGhpcy5nZXRBZGRyZXNzRnJvbVB1YmxpY0tleShwdWJsaWNLZXkpO1xuXG4gICAgLy8gU3RlcCA0OiBGZXRjaCBhY2NvdW50IGRldGFpbHMgc3VjaCBhcyBhY2NvdW50Tm8sIGJhbGFuY2UgYW5kIGNoZWNrIGZvciBzdWZmaWNpZW50IGZ1bmRzIG9uY2UgZ2FzQW1vdW50IGhhcyBiZWVuIGRlZHVjdGVkXG4gICAgY29uc3QgW2FjY291bnROdW1iZXIsIHNlcXVlbmNlTm9dID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50RGV0YWlscyhzZW5kZXJBZGRyZXNzKTtcbiAgICBjb25zdCBiYWxhbmNlID0gbmV3IEJpZ051bWJlcihhd2FpdCB0aGlzLmdldEFjY291bnRCYWxhbmNlKHNlbmRlckFkZHJlc3MpKTtcbiAgICBjb25zdCBnYXNCdWRnZXQ6IEZlZURhdGEgPSB7XG4gICAgICBhbW91bnQ6IFt7IGRlbm9tOiB0aGlzLmdldERlbm9taW5hdGlvbigpLCBhbW91bnQ6IHRoaXMuZ2V0R2FzQW1vdW50RGV0YWlscygpLmdhc0Ftb3VudCB9XSxcbiAgICAgIGdhc0xpbWl0OiB0aGlzLmdldEdhc0Ftb3VudERldGFpbHMoKS5nYXNMaW1pdCxcbiAgICB9O1xuICAgIGNvbnN0IGdhc0Ftb3VudCA9IG5ldyBCaWdOdW1iZXIoZ2FzQnVkZ2V0LmFtb3VudFswXS5hbW91bnQpO1xuICAgIGNvbnN0IGFjdHVhbEJhbGFuY2UgPSBiYWxhbmNlLm1pbnVzKGdhc0Ftb3VudCk7XG5cbiAgICBpZiAoYWN0dWFsQmFsYW5jZS5pc0xlc3NUaGFuT3JFcXVhbFRvKDApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgaGF2ZSBlbm91Z2ggZnVuZHMgdG8gcmVjb3ZlcicpO1xuICAgIH1cblxuICAgIC8vIFN0ZXAgNTogT25jZSBzdWZmaWNpZW50IGZ1bmRzIGFyZSBwcmVzZW50LCBjb25zdHJ1Y3QgdGhlIHJlY292ZXIgdHggbWVzc3NhZ2VcbiAgICBjb25zdCBhbW91bnQ6IENvaW5bXSA9IFtcbiAgICAgIHtcbiAgICAgICAgZGVub206IHRoaXMuZ2V0RGVub21pbmF0aW9uKCksXG4gICAgICAgIGFtb3VudDogYWN0dWFsQmFsYW5jZS50b0ZpeGVkKCksXG4gICAgICB9LFxuICAgIF07XG4gICAgY29uc3Qgc2VuZE1lc3NhZ2U6IFNlbmRNZXNzYWdlW10gPSBbXG4gICAgICB7XG4gICAgICAgIGZyb21BZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICB0b0FkZHJlc3M6IHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uLFxuICAgICAgICBhbW91bnQ6IGFtb3VudCxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIC8vIFN0ZXAgNjogQnVpbGQgdGhlIHVuc2lnbmVkIHR4IHVzaW5nIHRoZSBjb25zdHJ1Y3RlZCBtZXNzYWdlXG4gICAgY29uc3QgdHhuQnVpbGRlciA9IHRoaXMuZ2V0QnVpbGRlcigpLmdldFRyYW5zZmVyQnVpbGRlcigpO1xuICAgIHR4bkJ1aWxkZXJcbiAgICAgIC5tZXNzYWdlcyhzZW5kTWVzc2FnZSlcbiAgICAgIC5nYXNCdWRnZXQoZ2FzQnVkZ2V0KVxuICAgICAgLnB1YmxpY0tleShwdWJsaWNLZXkpXG4gICAgICAuc2VxdWVuY2UoTnVtYmVyKHNlcXVlbmNlTm8pKVxuICAgICAgLmFjY291bnROdW1iZXIoTnVtYmVyKGFjY291bnROdW1iZXIpKVxuICAgICAgLmNoYWluSWQoY2hhaW5JZCk7XG4gICAgY29uc3QgdW5zaWduZWRUcmFuc2FjdGlvbiA9IChhd2FpdCB0eG5CdWlsZGVyLmJ1aWxkKCkpIGFzIENvc21vc1RyYW5zYWN0aW9uO1xuICAgIGxldCBzZXJpYWxpemVkVHggPSB1bnNpZ25lZFRyYW5zYWN0aW9uLnRvQnJvYWRjYXN0Rm9ybWF0KCk7XG4gICAgY29uc3Qgc2lnbmFibGVIZXggPSB1bnNpZ25lZFRyYW5zYWN0aW9uLnNpZ25hYmxlUGF5bG9hZC50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgdXNlcktleSA9IHBhcmFtcy51c2VyS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgY29uc3QgYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgIGNvbnN0IFt1c2VyS2V5Q29tYmluZWQsIGJhY2t1cEtleUNvbWJpbmVkXSA9ICgoKTogW1xuICAgICAgRUNEU0FNZXRob2RUeXBlcy5LZXlDb21iaW5lZCB8IHVuZGVmaW5lZCxcbiAgICAgIEVDRFNBTWV0aG9kVHlwZXMuS2V5Q29tYmluZWQgfCB1bmRlZmluZWRcbiAgICBdID0+IHtcbiAgICAgIGNvbnN0IFt1c2VyS2V5Q29tYmluZWQsIGJhY2t1cEtleUNvbWJpbmVkXSA9IHRoaXMuZ2V0S2V5Q29tYmluZWRGcm9tVHNzS2V5U2hhcmVzKFxuICAgICAgICB1c2VyS2V5LFxuICAgICAgICBiYWNrdXBLZXksXG4gICAgICAgIHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlXG4gICAgICApO1xuICAgICAgcmV0dXJuIFt1c2VyS2V5Q29tYmluZWQsIGJhY2t1cEtleUNvbWJpbmVkXTtcbiAgICB9KSgpO1xuXG4gICAgaWYgKCF1c2VyS2V5Q29tYmluZWQgfHwgIWJhY2t1cEtleUNvbWJpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgY29tYmluZWQga2V5IHNoYXJlcyBmb3IgdXNlciBvciBiYWNrdXAnKTtcbiAgICB9XG5cbiAgICAvLyBTdGVwIDc6IFNpZ24gdGhlIHR4XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5zaWduUmVjb3ZlcnlUU1ModXNlcktleUNvbWJpbmVkLCBiYWNrdXBLZXlDb21iaW5lZCwgc2lnbmFibGVIZXgpO1xuICAgIGNvbnN0IHNpZ25hYmxlQnVmZmVyID0gQnVmZmVyLmZyb20oc2lnbmFibGVIZXgsICdoZXgnKTtcbiAgICBNUEMudmVyaWZ5KHNpZ25hYmxlQnVmZmVyLCBzaWduYXR1cmUsIHRoaXMuZ2V0SGFzaEZ1bmN0aW9uKCkpO1xuICAgIGNvbnN0IGNvc21vc0tleVBhaXIgPSB0aGlzLmdldEtleVBhaXIocHVibGljS2V5KTtcbiAgICB0eG5CdWlsZGVyLmFkZFNpZ25hdHVyZSh7IHB1YjogY29zbW9zS2V5UGFpci5nZXRLZXlzKCkucHViIH0sIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZS5yICsgc2lnbmF0dXJlLnMsICdoZXgnKSk7XG4gICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb24gPSBhd2FpdCB0eG5CdWlsZGVyLmJ1aWxkKCk7XG4gICAgc2VyaWFsaXplZFR4ID0gc2lnbmVkVHJhbnNhY3Rpb24udG9Ccm9hZGNhc3RGb3JtYXQoKTtcblxuICAgIHJldHVybiB7IHNlcmlhbGl6ZWRUeDogc2VyaWFsaXplZFR4IH07XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgcmVkZWxlZ2F0ZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlY292ZXJ5T3B0aW9uc30gcGFyYW1zIHBhcmFtZXRlcnMgbmVlZGVkIHRvIGNvbnN0cnVjdCBhbmRcbiAgICogKG1heWJlKSBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29zbW9zTGlrZUNvaW5SZWNvdmVyeU91dHB1dH0gdGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gaGV4IHN0cmluZ1xuICAgKi9cbiAgYXN5bmMgcmVkZWxlZ2F0ZShcbiAgICBwYXJhbXM6IFJlY292ZXJ5T3B0aW9ucyAmIHtcbiAgICAgIHZhbGlkYXRvclNyY0FkZHJlc3M6IHN0cmluZztcbiAgICAgIHZhbGlkYXRvckRzdEFkZHJlc3M6IHN0cmluZztcbiAgICAgIGFtb3VudFRvUmVkZWxlZ2F0ZTogc3RyaW5nO1xuICAgIH1cbiAgKTogUHJvbWlzZTxDb3Ntb3NMaWtlQ29pblJlY292ZXJ5T3V0cHV0PiB7XG4gICAgaWYgKCFwYXJhbXMuYml0Z29LZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBiaXRnb0tleScpO1xuICAgIH1cblxuICAgIGlmICghcGFyYW1zLnZhbGlkYXRvclNyY0FkZHJlc3MgfHwgIXRoaXMuaXNWYWxpZEFkZHJlc3MocGFyYW1zLnZhbGlkYXRvclNyY0FkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdmFsaWRhdG9yU3JjQWRkcmVzcycpO1xuICAgIH1cblxuICAgIGlmICghcGFyYW1zLnZhbGlkYXRvckRzdEFkZHJlc3MgfHwgIXRoaXMuaXNWYWxpZEFkZHJlc3MocGFyYW1zLnZhbGlkYXRvckRzdEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdmFsaWRhdG9yRHN0QWRkcmVzcycpO1xuICAgIH1cblxuICAgIGlmICghcGFyYW1zLnVzZXJLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB1c2VyS2V5Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMuYmFja3VwS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYmFja3VwS2V5Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHdhbGxldCBwYXNzcGhyYXNlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMuYW1vdW50VG9SZWRlbGVnYXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYW1vdW50VG9SZWRlbGVnYXRlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYml0Z29LZXkgPSBwYXJhbXMuYml0Z29LZXkucmVwbGFjZSgvXFxzL2csICcnKTtcblxuICAgIGNvbnN0IE1QQyA9IG5ldyBFY2RzYSgpO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBNUEMuZGVyaXZlVW5oYXJkZW5lZChiaXRnb0tleSwgUk9PVF9QQVRIKS5zbGljZSgwLCA2Nik7XG4gICAgY29uc3Qgc2VuZGVyQWRkcmVzcyA9IHRoaXMuZ2V0QWRkcmVzc0Zyb21QdWJsaWNLZXkocHVibGljS2V5KTtcblxuICAgIGNvbnN0IFthY2NvdW50TnVtYmVyLCBzZXF1ZW5jZU5vXSA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudERldGFpbHMoc2VuZGVyQWRkcmVzcyk7XG4gICAgY29uc3QgZ2FzQnVkZ2V0OiBGZWVEYXRhID0ge1xuICAgICAgYW1vdW50OiBbeyBkZW5vbTogdGhpcy5nZXREZW5vbWluYXRpb24oKSwgYW1vdW50OiB0aGlzLmdldEdhc0Ftb3VudERldGFpbHMoKS5nYXNBbW91bnQgfV0sXG4gICAgICBnYXNMaW1pdDogdGhpcy5nZXRHYXNBbW91bnREZXRhaWxzKCkuZ2FzTGltaXQsXG4gICAgfTtcblxuICAgIGNvbnN0IGFtb3VudDogQ29pbiA9IHtcbiAgICAgIGRlbm9tOiB0aGlzLmdldERlbm9taW5hdGlvbigpLFxuICAgICAgYW1vdW50OiBuZXcgQmlnTnVtYmVyKHBhcmFtcy5hbW91bnRUb1JlZGVsZWdhdGUpLnRvRml4ZWQoKSxcbiAgICB9O1xuXG4gICAgY29uc3Qgc2VuZE1lc3NhZ2U6IFJlZGVsZWdhdGVNZXNzYWdlW10gPSBbXG4gICAgICB7XG4gICAgICAgIGRlbGVnYXRvckFkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgIHZhbGlkYXRvclNyY0FkZHJlc3M6IHBhcmFtcy52YWxpZGF0b3JTcmNBZGRyZXNzLFxuICAgICAgICB2YWxpZGF0b3JEc3RBZGRyZXNzOiBwYXJhbXMudmFsaWRhdG9yRHN0QWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBhbW91bnQsXG4gICAgICB9LFxuICAgIF07XG5cbiAgICBjb25zdCB0eG5CdWlsZGVyID0gdGhpcy5nZXRCdWlsZGVyKCkuZ2V0U3Rha2luZ1JlZGVsZWdhdGVCdWlsZGVyKCk7XG4gICAgdHhuQnVpbGRlclxuICAgICAgLm1lc3NhZ2VzKHNlbmRNZXNzYWdlKVxuICAgICAgLmdhc0J1ZGdldChnYXNCdWRnZXQpXG4gICAgICAucHVibGljS2V5KHB1YmxpY0tleSlcbiAgICAgIC5zZXF1ZW5jZShOdW1iZXIoc2VxdWVuY2VObykpXG4gICAgICAuYWNjb3VudE51bWJlcihOdW1iZXIoYWNjb3VudE51bWJlcikpXG4gICAgICAuY2hhaW5JZChjaGFpbklkKTtcblxuICAgIGNvbnN0IHVuc2lnbmVkVHJhbnNhY3Rpb24gPSAoYXdhaXQgdHhuQnVpbGRlci5idWlsZCgpKSBhcyBDb3Ntb3NUcmFuc2FjdGlvbjtcbiAgICBsZXQgc2VyaWFsaXplZFR4ID0gdW5zaWduZWRUcmFuc2FjdGlvbi50b0Jyb2FkY2FzdEZvcm1hdCgpO1xuICAgIGNvbnN0IHNpZ25hYmxlSGV4ID0gdW5zaWduZWRUcmFuc2FjdGlvbi5zaWduYWJsZVBheWxvYWQudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IHVzZXJLZXkgPSBwYXJhbXMudXNlcktleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgIGNvbnN0IGJhY2t1cEtleSA9IHBhcmFtcy5iYWNrdXBLZXkucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICBjb25zdCBbdXNlcktleUNvbWJpbmVkLCBiYWNrdXBLZXlDb21iaW5lZF0gPSAoKCk6IFtcbiAgICAgIEVDRFNBTWV0aG9kVHlwZXMuS2V5Q29tYmluZWQgfCB1bmRlZmluZWQsXG4gICAgICBFQ0RTQU1ldGhvZFR5cGVzLktleUNvbWJpbmVkIHwgdW5kZWZpbmVkXG4gICAgXSA9PiB7XG4gICAgICBjb25zdCBbdXNlcktleUNvbWJpbmVkLCBiYWNrdXBLZXlDb21iaW5lZF0gPSB0aGlzLmdldEtleUNvbWJpbmVkRnJvbVRzc0tleVNoYXJlcyhcbiAgICAgICAgdXNlcktleSxcbiAgICAgICAgYmFja3VwS2V5LFxuICAgICAgICBwYXJhbXMud2FsbGV0UGFzc3BocmFzZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBbdXNlcktleUNvbWJpbmVkLCBiYWNrdXBLZXlDb21iaW5lZF07XG4gICAgfSkoKTtcblxuICAgIGlmICghdXNlcktleUNvbWJpbmVkIHx8ICFiYWNrdXBLZXlDb21iaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNvbWJpbmVkIGtleSBzaGFyZXMgZm9yIHVzZXIgb3IgYmFja3VwJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5zaWduUmVjb3ZlcnlUU1ModXNlcktleUNvbWJpbmVkLCBiYWNrdXBLZXlDb21iaW5lZCwgc2lnbmFibGVIZXgpO1xuICAgIGNvbnN0IHNpZ25hYmxlQnVmZmVyID0gQnVmZmVyLmZyb20oc2lnbmFibGVIZXgsICdoZXgnKTtcbiAgICBNUEMudmVyaWZ5KHNpZ25hYmxlQnVmZmVyLCBzaWduYXR1cmUsIHRoaXMuZ2V0SGFzaEZ1bmN0aW9uKCkpO1xuICAgIGNvbnN0IGNvc21vc0tleVBhaXIgPSB0aGlzLmdldEtleVBhaXIocHVibGljS2V5KTtcbiAgICB0eG5CdWlsZGVyLmFkZFNpZ25hdHVyZSh7IHB1YjogY29zbW9zS2V5UGFpci5nZXRLZXlzKCkucHViIH0sIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZS5yICsgc2lnbmF0dXJlLnMsICdoZXgnKSk7XG4gICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb24gPSBhd2FpdCB0eG5CdWlsZGVyLmJ1aWxkKCk7XG4gICAgc2VyaWFsaXplZFR4ID0gc2lnbmVkVHJhbnNhY3Rpb24udG9Ccm9hZGNhc3RGb3JtYXQoKTtcblxuICAgIHJldHVybiB7IHNlcmlhbGl6ZWRUeDogc2VyaWFsaXplZFR4IH07XG4gIH1cblxuICBwcml2YXRlIGdldEtleUNvbWJpbmVkRnJvbVRzc0tleVNoYXJlcyhcbiAgICB1c2VyUHVibGljT3JQcml2YXRlS2V5U2hhcmU6IHN0cmluZyxcbiAgICBiYWNrdXBQcml2YXRlT3JQdWJsaWNLZXlTaGFyZTogc3RyaW5nLFxuICAgIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmdcbiAgKTogW0VDRFNBTWV0aG9kVHlwZXMuS2V5Q29tYmluZWQsIEVDRFNBTWV0aG9kVHlwZXMuS2V5Q29tYmluZWRdIHtcbiAgICBsZXQgYmFja3VwUHJ2O1xuICAgIGxldCB1c2VyUHJ2O1xuICAgIHRyeSB7XG4gICAgICBiYWNrdXBQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICBpbnB1dDogYmFja3VwUHJpdmF0ZU9yUHVibGljS2V5U2hhcmUsXG4gICAgICAgIHBhc3N3b3JkOiB3YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgfSk7XG4gICAgICB1c2VyUHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgaW5wdXQ6IHVzZXJQdWJsaWNPclByaXZhdGVLZXlTaGFyZSxcbiAgICAgICAgcGFzc3dvcmQ6IHdhbGxldFBhc3NwaHJhc2UsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY3J5cHRpbmcgYmFja3VwIGtleWNoYWluOiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZSh1c2VyUHJ2KSBhcyBFQ0RTQU1ldGhvZFR5cGVzLlNpZ25pbmdNYXRlcmlhbDtcbiAgICBjb25zdCBiYWNrdXBTaWduaW5nTWF0ZXJpYWwgPSBKU09OLnBhcnNlKGJhY2t1cFBydikgYXMgRUNEU0FNZXRob2RUeXBlcy5TaWduaW5nTWF0ZXJpYWw7XG5cbiAgICBpZiAoIXVzZXJTaWduaW5nTWF0ZXJpYWwuYmFja3VwTlNoYXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlciBrZXkgLSBtaXNzaW5nIGJhY2t1cE5TaGFyZScpO1xuICAgIH1cblxuICAgIGlmICghYmFja3VwU2lnbmluZ01hdGVyaWFsLnVzZXJOU2hhcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiYWNrdXAga2V5IC0gbWlzc2luZyB1c2VyTlNoYXJlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgTVBDID0gbmV3IEVjZHNhKCk7XG5cbiAgICBjb25zdCB1c2VyS2V5Q29tYmluZWQgPSBNUEMua2V5Q29tYmluZSh1c2VyU2lnbmluZ01hdGVyaWFsLnBTaGFyZSwgW1xuICAgICAgdXNlclNpZ25pbmdNYXRlcmlhbC5iaXRnb05TaGFyZSxcbiAgICAgIHVzZXJTaWduaW5nTWF0ZXJpYWwuYmFja3VwTlNoYXJlLFxuICAgIF0pO1xuXG4gICAgY29uc3QgdXNlclNpZ25pbmdLZXlEZXJpdmVkID0gTVBDLmtleURlcml2ZShcbiAgICAgIHVzZXJTaWduaW5nTWF0ZXJpYWwucFNoYXJlLFxuICAgICAgW3VzZXJTaWduaW5nTWF0ZXJpYWwuYml0Z29OU2hhcmUsIHVzZXJTaWduaW5nTWF0ZXJpYWwuYmFja3VwTlNoYXJlXSxcbiAgICAgICdtLzAnXG4gICAgKTtcblxuICAgIGNvbnN0IHVzZXJLZXlEZXJpdmVkQ29tYmluZWQgPSB7XG4gICAgICB4U2hhcmU6IHVzZXJTaWduaW5nS2V5RGVyaXZlZC54U2hhcmUsXG4gICAgICB5U2hhcmVzOiB1c2VyS2V5Q29tYmluZWQueVNoYXJlcyxcbiAgICB9O1xuXG4gICAgY29uc3QgYmFja3VwS2V5Q29tYmluZWQgPSBNUEMua2V5Q29tYmluZShiYWNrdXBTaWduaW5nTWF0ZXJpYWwucFNoYXJlLCBbXG4gICAgICB1c2VyU2lnbmluZ0tleURlcml2ZWQublNoYXJlc1syXSxcbiAgICAgIGJhY2t1cFNpZ25pbmdNYXRlcmlhbC5iaXRnb05TaGFyZSxcbiAgICBdKTtcblxuICAgIGlmIChcbiAgICAgIHVzZXJLZXlEZXJpdmVkQ29tYmluZWQueFNoYXJlLnkgIT09IGJhY2t1cEtleUNvbWJpbmVkLnhTaGFyZS55IHx8XG4gICAgICB1c2VyS2V5RGVyaXZlZENvbWJpbmVkLnhTaGFyZS5jaGFpbmNvZGUgIT09IGJhY2t1cEtleUNvbWJpbmVkLnhTaGFyZS5jaGFpbmNvZGVcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29tbW9uIGtleWNoYWlucyBkbyBub3QgbWF0Y2gnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3VzZXJLZXlEZXJpdmVkQ29tYmluZWQsIGJhY2t1cEtleUNvbWJpbmVkXTtcbiAgfVxuXG4gIC8vIFRPRE8oQkctNzg3MTQpOiBSZWR1Y2UgY29kZSBkdXBsaWNhdGlvbiBiZXR3ZWVuIHRoaXMgYW5kIGV0aC50c1xuICBwcml2YXRlIGFzeW5jIHNpZ25SZWNvdmVyeVRTUyhcbiAgICB1c2VyS2V5Q29tYmluZWQ6IEVDRFNBLktleUNvbWJpbmVkLFxuICAgIGJhY2t1cEtleUNvbWJpbmVkOiBFQ0RTQS5LZXlDb21iaW5lZCxcbiAgICB0eEhleDogc3RyaW5nLFxuICAgIHtcbiAgICAgIHJhbmdlUHJvb2ZDaGFsbGVuZ2UsXG4gICAgfToge1xuICAgICAgcmFuZ2VQcm9vZkNoYWxsZW5nZT86IEVjZHNhVHlwZXMuU2VyaWFsaXplZE50aWxkZTtcbiAgICB9ID0ge31cbiAgKTogUHJvbWlzZTxFQ0RTQU1ldGhvZFR5cGVzLlNpZ25hdHVyZT4ge1xuICAgIGNvbnN0IE1QQyA9IG5ldyBFY2RzYSgpO1xuICAgIGNvbnN0IHNpZ25lck9uZUluZGV4ID0gdXNlcktleUNvbWJpbmVkLnhTaGFyZS5pO1xuICAgIGNvbnN0IHNpZ25lclR3b0luZGV4ID0gYmFja3VwS2V5Q29tYmluZWQueFNoYXJlLmk7XG5cbiAgICAvLyBTaW5jZSB0aGlzIGlzIGEgdXNlciA8PiBiYWNrdXAgc2lnbmluZywgd2Ugd2lsbCByZXVzZSB0aGUgc2FtZSByYW5nZSBwcm9vZiBjaGFsbGVuZ2VcbiAgICByYW5nZVByb29mQ2hhbGxlbmdlID1cbiAgICAgIHJhbmdlUHJvb2ZDaGFsbGVuZ2UgPz8gRWNkc2FUeXBlcy5zZXJpYWxpemVOdGlsZGVXaXRoUHJvb2ZzKGF3YWl0IEVjZHNhUmFuZ2VQcm9vZi5nZW5lcmF0ZU50aWxkZSgpKTtcblxuICAgIGNvbnN0IHVzZXJUb0JhY2t1cFBhaWxsaWVyQ2hhbGxlbmdlID0gYXdhaXQgRWNkc2FQYWlsbGllclByb29mLmdlbmVyYXRlUChcbiAgICAgIGhleFRvQmlnSW50KHVzZXJLZXlDb21iaW5lZC55U2hhcmVzW3NpZ25lclR3b0luZGV4XS5uKVxuICAgICk7XG4gICAgY29uc3QgYmFja3VwVG9Vc2VyUGFpbGxpZXJDaGFsbGVuZ2UgPSBhd2FpdCBFY2RzYVBhaWxsaWVyUHJvb2YuZ2VuZXJhdGVQKFxuICAgICAgaGV4VG9CaWdJbnQoYmFja3VwS2V5Q29tYmluZWQueVNoYXJlc1tzaWduZXJPbmVJbmRleF0ubilcbiAgICApO1xuXG4gICAgY29uc3QgdXNlclhTaGFyZSA9IE1QQy5hcHBlbmRDaGFsbGVuZ2UoXG4gICAgICB1c2VyS2V5Q29tYmluZWQueFNoYXJlLFxuICAgICAgcmFuZ2VQcm9vZkNoYWxsZW5nZSxcbiAgICAgIEVjZHNhVHlwZXMuc2VyaWFsaXplUGFpbGxpZXJDaGFsbGVuZ2UoeyBwOiB1c2VyVG9CYWNrdXBQYWlsbGllckNoYWxsZW5nZSB9KVxuICAgICk7XG4gICAgY29uc3QgdXNlcllTaGFyZSA9IE1QQy5hcHBlbmRDaGFsbGVuZ2UoXG4gICAgICB1c2VyS2V5Q29tYmluZWQueVNoYXJlc1tzaWduZXJUd29JbmRleF0sXG4gICAgICByYW5nZVByb29mQ2hhbGxlbmdlLFxuICAgICAgRWNkc2FUeXBlcy5zZXJpYWxpemVQYWlsbGllckNoYWxsZW5nZSh7IHA6IGJhY2t1cFRvVXNlclBhaWxsaWVyQ2hhbGxlbmdlIH0pXG4gICAgKTtcbiAgICBjb25zdCBiYWNrdXBYU2hhcmUgPSBNUEMuYXBwZW5kQ2hhbGxlbmdlKFxuICAgICAgYmFja3VwS2V5Q29tYmluZWQueFNoYXJlLFxuICAgICAgcmFuZ2VQcm9vZkNoYWxsZW5nZSxcbiAgICAgIEVjZHNhVHlwZXMuc2VyaWFsaXplUGFpbGxpZXJDaGFsbGVuZ2UoeyBwOiBiYWNrdXBUb1VzZXJQYWlsbGllckNoYWxsZW5nZSB9KVxuICAgICk7XG4gICAgY29uc3QgYmFja3VwWVNoYXJlID0gTVBDLmFwcGVuZENoYWxsZW5nZShcbiAgICAgIGJhY2t1cEtleUNvbWJpbmVkLnlTaGFyZXNbc2lnbmVyT25lSW5kZXhdLFxuICAgICAgcmFuZ2VQcm9vZkNoYWxsZW5nZSxcbiAgICAgIEVjZHNhVHlwZXMuc2VyaWFsaXplUGFpbGxpZXJDaGFsbGVuZ2UoeyBwOiB1c2VyVG9CYWNrdXBQYWlsbGllckNoYWxsZW5nZSB9KVxuICAgICk7XG5cbiAgICBjb25zdCBzaWduU2hhcmVzOiBFQ0RTQS5TaWduU2hhcmVSVCA9IGF3YWl0IE1QQy5zaWduU2hhcmUodXNlclhTaGFyZSwgdXNlcllTaGFyZSk7XG5cbiAgICBjb25zdCBzaWduQ29udmVydFMyMSA9IGF3YWl0IE1QQy5zaWduQ29udmVydFN0ZXAxKHtcbiAgICAgIHhTaGFyZTogYmFja3VwWFNoYXJlLFxuICAgICAgeVNoYXJlOiBiYWNrdXBZU2hhcmUsIC8vIFlTaGFyZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBvdGhlciBwYXJ0aWNpcGFudCBzaWduZXJPbmVcbiAgICAgIGtTaGFyZTogc2lnblNoYXJlcy5rU2hhcmUsXG4gICAgfSk7XG4gICAgY29uc3Qgc2lnbkNvbnZlcnRTMTIgPSBhd2FpdCBNUEMuc2lnbkNvbnZlcnRTdGVwMih7XG4gICAgICBhU2hhcmU6IHNpZ25Db252ZXJ0UzIxLmFTaGFyZSxcbiAgICAgIHdTaGFyZTogc2lnblNoYXJlcy53U2hhcmUsXG4gICAgfSk7XG4gICAgY29uc3Qgc2lnbkNvbnZlcnRTMjFfMiA9IGF3YWl0IE1QQy5zaWduQ29udmVydFN0ZXAzKHtcbiAgICAgIG11U2hhcmU6IHNpZ25Db252ZXJ0UzEyLm11U2hhcmUsXG4gICAgICBiU2hhcmU6IHNpZ25Db252ZXJ0UzIxLmJTaGFyZSxcbiAgICB9KTtcblxuICAgIGNvbnN0IFtzaWduQ29tYmluZU9uZSwgc2lnbkNvbWJpbmVUd29dID0gW1xuICAgICAgTVBDLnNpZ25Db21iaW5lKHtcbiAgICAgICAgZ1NoYXJlOiBzaWduQ29udmVydFMxMi5nU2hhcmUsXG4gICAgICAgIHNpZ25JbmRleDoge1xuICAgICAgICAgIGk6IHNpZ25Db252ZXJ0UzEyLm11U2hhcmUuaSxcbiAgICAgICAgICBqOiBzaWduQ29udmVydFMxMi5tdVNoYXJlLmosXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICAgIE1QQy5zaWduQ29tYmluZSh7XG4gICAgICAgIGdTaGFyZTogc2lnbkNvbnZlcnRTMjFfMi5nU2hhcmUsXG4gICAgICAgIHNpZ25JbmRleDoge1xuICAgICAgICAgIGk6IHNpZ25Db252ZXJ0UzIxXzIuc2lnbkluZGV4LmksXG4gICAgICAgICAgajogc2lnbkNvbnZlcnRTMjFfMi5zaWduSW5kZXguaixcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF07XG5cbiAgICBjb25zdCBNRVNTQUdFID0gQnVmZmVyLmZyb20odHhIZXgsICdoZXgnKTtcblxuICAgIGNvbnN0IFtzaWduQSwgc2lnbkJdID0gW1xuICAgICAgTVBDLnNpZ24oTUVTU0FHRSwgc2lnbkNvbWJpbmVPbmUub1NoYXJlLCBzaWduQ29tYmluZVR3by5kU2hhcmUsIHRoaXMuZ2V0SGFzaEZ1bmN0aW9uKCkpLFxuICAgICAgTVBDLnNpZ24oTUVTU0FHRSwgc2lnbkNvbWJpbmVUd28ub1NoYXJlLCBzaWduQ29tYmluZU9uZS5kU2hhcmUsIHRoaXMuZ2V0SGFzaEZ1bmN0aW9uKCkpLFxuICAgIF07XG5cbiAgICByZXR1cm4gTVBDLmNvbnN0cnVjdFNpZ25hdHVyZShbc2lnbkEsIHNpZ25CXSk7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKiovXG4gIGFzeW5jIHZlcmlmeVRyYW5zYWN0aW9uKHBhcmFtczogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgbGV0IHRvdGFsQW1vdW50ID0gbmV3IEJpZ051bWJlcigwKTtcbiAgICBjb25zdCB7IHR4UHJlYnVpbGQsIHR4UGFyYW1zIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmF3VHggPSB0eFByZWJ1aWxkLnR4SGV4O1xuICAgIGlmICghcmF3VHgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCB0eCBwcmVidWlsZCBwcm9wZXJ0eSB0eEhleCcpO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuZ2V0QnVpbGRlcigpLmZyb20ocmF3VHgpLmJ1aWxkKCk7XG4gICAgY29uc3QgZXhwbGFpbmVkVHggPSB0cmFuc2FjdGlvbi5leHBsYWluVHJhbnNhY3Rpb24oKTtcblxuICAgIGlmICh0eFBhcmFtcy5yZWNpcGllbnRzICYmIHR4UGFyYW1zLnJlY2lwaWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmlsdGVyZWRSZWNpcGllbnRzID0gdHhQYXJhbXMucmVjaXBpZW50cz8ubWFwKChyZWNpcGllbnQpID0+IF8ucGljayhyZWNpcGllbnQsIFsnYWRkcmVzcycsICdhbW91bnQnXSkpO1xuICAgICAgY29uc3QgZmlsdGVyZWRPdXRwdXRzID0gZXhwbGFpbmVkVHgub3V0cHV0cy5tYXAoKG91dHB1dCkgPT4gXy5waWNrKG91dHB1dCwgWydhZGRyZXNzJywgJ2Ftb3VudCddKSk7XG5cbiAgICAgIGlmICghXy5pc0VxdWFsKGZpbHRlcmVkT3V0cHV0cywgZmlsdGVyZWRSZWNpcGllbnRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R4IG91dHB1dHMgZG9lcyBub3QgbWF0Y2ggd2l0aCBleHBlY3RlZCB0eFBhcmFtcyByZWNpcGllbnRzJyk7XG4gICAgICB9XG4gICAgICAvLyBXaXRoZHJhd0RlbGVnYXRvclJld2FyZHMgYW5kIENvbnRyYWN0Q2FsbCB0cmFuc2FjdGlvbiBkb24ndCBoYXZlIGFtb3VudFxuICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgIT09IFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nV2l0aGRyYXcgJiYgdHJhbnNhY3Rpb24udHlwZSAhPT0gVHJhbnNhY3Rpb25UeXBlLkNvbnRyYWN0Q2FsbCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlY2lwaWVudHMgb2YgdHhQYXJhbXMucmVjaXBpZW50cykge1xuICAgICAgICAgIHRvdGFsQW1vdW50ID0gdG90YWxBbW91bnQucGx1cyhyZWNpcGllbnRzLmFtb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b3RhbEFtb3VudC5pc0VxdWFsVG8oZXhwbGFpbmVkVHgub3V0cHV0QW1vdW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHggdG90YWwgYW1vdW50IGRvZXMgbm90IG1hdGNoIHdpdGggZXhwZWN0ZWQgdG90YWwgYW1vdW50IGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKiovXG4gIGFzeW5jIGV4cGxhaW5UcmFuc2FjdGlvbihvcHRpb25zOiB7IHR4SGV4OiBzdHJpbmcgfSk6IFByb21pc2U8RXhwbGFuYXRpb25SZXN1bHQ+IHtcbiAgICBpZiAoIW9wdGlvbnMudHhIZXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCB0eEhleCBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uQnVpbGRlciA9IHRoaXMuZ2V0QnVpbGRlcigpLmZyb20ob3B0aW9ucy50eEhleCk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHRyYW5zYWN0aW9uQnVpbGRlci5idWlsZCgpO1xuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uLmV4cGxhaW5UcmFuc2FjdGlvbigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbjogJyArIGUubWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gYSB0cmFuc2FjdGlvbiB3aXRoIGEgc2luZ2xlIHByaXZhdGUga2V5XG4gICAqIEBwYXJhbSBwYXJhbXMgcGFyYW1ldGVycyBpbiB0aGUgZm9ybSBvZiB7IHR4UHJlYnVpbGQ6IHt0eEhleH0sIHBydiB9XG4gICAqIEByZXR1cm5zIHNpZ25lZCB0cmFuc2FjdGlvbiBpbiB0aGUgZm9ybSBvZiB7IHR4SGV4IH1cbiAgICovXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgJiB7IHR4UHJlYnVpbGQ6IHsgdHhIZXg6IHN0cmluZyB9OyBwcnY6IHN0cmluZyB9XG4gICk6IFByb21pc2U8U2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCB0eEhleCA9IHBhcmFtcz8udHhQcmVidWlsZD8udHhIZXg7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IHBhcmFtcz8ucHJ2O1xuICAgIGlmICghdHhIZXgpIHtcbiAgICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgdHhQcmVidWlsZCBwYXJhbWV0ZXI6IHBhcmFtcy50eFByZWJ1aWxkLnR4SGV4Jyk7XG4gICAgfVxuICAgIGlmICghcHJpdmF0ZUtleSkge1xuICAgICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignbWlzc2luZyByZXF1aXJlZCBwcnYgcGFyYW1ldGVyOiBwYXJhbXMucHJ2Jyk7XG4gICAgfVxuICAgIGNvbnN0IHR4QnVpbGRlciA9IHRoaXMuZ2V0QnVpbGRlcigpLmZyb20ocGFyYW1zLnR4UHJlYnVpbGQudHhIZXgpO1xuICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiBwYXJhbXMucHJ2IH0pO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uOiBCYXNlVHJhbnNhY3Rpb24gPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICBpZiAoIXRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdGYWlsZWQgdG8gYnVpbGQgc2lnbmVkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6ZWRUeCA9IHRyYW5zYWN0aW9uLnRvQnJvYWRjYXN0Rm9ybWF0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR4SGV4OiBzZXJpYWxpemVkVHgsXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqKi9cbiAgYXN5bmMgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zICYgeyB0eEhleDogc3RyaW5nIH0pOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25FeHBsYW5hdGlvbiA9IGF3YWl0IHRoaXMuZXhwbGFpblRyYW5zYWN0aW9uKHsgdHhIZXg6IHBhcmFtcy50eEhleCB9KTtcbiAgICBpZiAoIXRyYW5zYWN0aW9uRXhwbGFuYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGlmICh0cmFuc2FjdGlvbkV4cGxhbmF0aW9uLm91dHB1dHMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2VuZGVyQWRkcmVzcyA9IHRyYW5zYWN0aW9uRXhwbGFuYXRpb24ub3V0cHV0c1swXS5hZGRyZXNzO1xuICAgIGNvbnN0IGZlZUFtb3VudCA9IG5ldyBCaWdOdW1iZXIodHJhbnNhY3Rpb25FeHBsYW5hdGlvbi5mZWUuZmVlID09PSAnJyA/ICcwJyA6IHRyYW5zYWN0aW9uRXhwbGFuYXRpb24uZmVlLmZlZSk7XG4gICAgY29uc3QgaW5wdXRzID0gW1xuICAgICAge1xuICAgICAgICBhZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IG5ldyBCaWdOdW1iZXIodHJhbnNhY3Rpb25FeHBsYW5hdGlvbi5vdXRwdXRBbW91bnQpLnBsdXMoZmVlQW1vdW50KS50b0ZpeGVkKCksXG4gICAgICB9LFxuICAgIF07XG4gICAgY29uc3Qgb3V0cHV0cyA9IHRyYW5zYWN0aW9uRXhwbGFuYXRpb24ub3V0cHV0cy5tYXAoKG91dHB1dCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogb3V0cHV0LmFkZHJlc3MsXG4gICAgICAgIGFtb3VudDogbmV3IEJpZ051bWJlcihvdXRwdXQuYW1vdW50KS50b0ZpeGVkKCksXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dHMsXG4gICAgICBvdXRwdXRzLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwdWJsaWMgbm9kZSB1cmwgZnJvbSB0aGUgRW52aXJvbm1lbnRzIGNvbnN0YW50IHdlIGhhdmUgZGVmaW5lZFxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFB1YmxpY05vZGVVcmwoKTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFjY291bnQgbnVtYmVyIGZyb20gcHVibGljIG5vZGVcbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBnZXRBY2NvdW50RnJvbU5vZGUoc2VuZGVyQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxyZXF1ZXN0LlJlc3BvbnNlPiB7XG4gICAgY29uc3Qgbm9kZVVybCA9IHRoaXMuZ2V0UHVibGljTm9kZVVybCgpO1xuICAgIGNvbnN0IGdldEFjY291bnRQYXRoID0gJy9jb3Ntb3MvYXV0aC92MWJldGExL2FjY291bnRzLyc7XG4gICAgY29uc3QgZnVsbEVuZHBvaW50ID0gbm9kZVVybCArIGdldEFjY291bnRQYXRoICsgc2VuZGVyQWRkcmVzcztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QuZ2V0KGZ1bGxFbmRwb2ludCkuc2VuZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNhbGwgZW5kcG9pbnQgJHtnZXRBY2NvdW50UGF0aCArIHNlbmRlckFkZHJlc3N9IGZyb20gbm9kZTogJHtub2RlVXJsfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBiYWxhbmNlIGZyb20gcHVibGljIG5vZGVcbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBnZXRCYWxhbmNlRnJvbU5vZGUoc2VuZGVyQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxyZXF1ZXN0LlJlc3BvbnNlPiB7XG4gICAgY29uc3Qgbm9kZVVybCA9IHRoaXMuZ2V0UHVibGljTm9kZVVybCgpO1xuICAgIGNvbnN0IGdldEJhbGFuY2VQYXRoID0gJy9jb3Ntb3MvYmFuay92MWJldGExL2JhbGFuY2VzLyc7XG4gICAgY29uc3QgZnVsbEVuZHBvaW50ID0gbm9kZVVybCArIGdldEJhbGFuY2VQYXRoICsgc2VuZGVyQWRkcmVzcztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QuZ2V0KGZ1bGxFbmRwb2ludCkuc2VuZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNhbGwgZW5kcG9pbnQgJHtnZXRCYWxhbmNlUGF0aCArIHNlbmRlckFkZHJlc3N9IGZyb20gbm9kZTogJHtub2RlVXJsfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjaGFpbiBpZCBmcm9tIHB1YmxpYyBub2RlXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0Q2hhaW5JZEZyb21Ob2RlKCk6IFByb21pc2U8cmVxdWVzdC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IG5vZGVVcmwgPSB0aGlzLmdldFB1YmxpY05vZGVVcmwoKTtcbiAgICBjb25zdCBnZXRMYXRlc3RCbG9ja1BhdGggPSAnL2Nvc21vcy9iYXNlL3RlbmRlcm1pbnQvdjFiZXRhMS9ibG9ja3MvbGF0ZXN0JztcbiAgICBjb25zdCBmdWxsRW5kcG9pbnQgPSBub2RlVXJsICsgZ2V0TGF0ZXN0QmxvY2tQYXRoO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgcmVxdWVzdC5nZXQoZnVsbEVuZHBvaW50KS5zZW5kKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5kZWJ1ZyhlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY2FsbCBlbmRwb2ludCAke2dldExhdGVzdEJsb2NrUGF0aH0gZnJvbSBub2RlOiAke25vZGVVcmx9YCk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRvIGZldGNoIGFjY291bnQgYmFsYW5jZVxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGdldEFjY291bnRCYWxhbmNlKHNlbmRlckFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldEJhbGFuY2VGcm9tTm9kZShzZW5kZXJBZGRyZXNzKTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWNjb3VudCBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgYmFsYW5jZSA9IHJlc3BvbnNlLmJvZHkuYmFsYW5jZXMuZmluZCgoaXRlbSkgPT4gaXRlbS5kZW5vbSA9PT0gdGhpcy5nZXREZW5vbWluYXRpb24oKSk7XG4gICAgcmV0dXJuIGJhbGFuY2UuYW1vdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBmZXRjaCBjaGFpbklkXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0Q2hhaW5JZCgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkRnJvbU5vZGUoKTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWNjb3VudCBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLmJvZHkuYmxvY2suaGVhZGVyLmNoYWluX2lkO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBmZXRjaCBhY2NvdW50IG51bWJlclxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGdldEFjY291bnREZXRhaWxzKHNlbmRlckFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEZyb21Ob2RlKHNlbmRlckFkZHJlc3MpO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gW3Jlc3BvbnNlLmJvZHkuYWNjb3VudC5hY2NvdW50X251bWJlciwgcmVzcG9uc2UuYm9keS5hY2NvdW50LnNlcXVlbmNlXTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBpZiAoIXNlZWQpIHtcbiAgICAgIC8vIEFuIGV4dGVuZGVkIHByaXZhdGUga2V5IGhhcyBib3RoIGEgbm9ybWFsIDI1NiBiaXQgcHJpdmF0ZSBrZXkgYW5kIGEgMjU2XG4gICAgICAvLyBiaXQgY2hhaW4gY29kZSwgYm90aCBvZiB3aGljaCBtdXN0IGJlIHJhbmRvbS4gNTEyIGJpdHMgaXMgdGhlcmVmb3JlIHRoZVxuICAgICAgLy8gbWF4aW11bSBlbnRyb3B5IGFuZCBnaXZlcyB1cyBtYXhpbXVtIHNlY3VyaXR5IGFnYWluc3QgY3JhY2tpbmcuXG4gICAgICBzZWVkID0gcmFuZG9tQnl0ZXMoNTEyIC8gOCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuZGVkS2V5ID0gYmlwMzIuZnJvbVNlZWQoc2VlZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YjogZXh0ZW5kZWRLZXkubmV1dGVyZWQoKS50b0Jhc2U1OCgpLFxuICAgICAgcHJ2OiBleHRlbmRlZEtleS50b0Jhc2U1OCgpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBhZGRyZXNzIGZyb20gYSBwdWJsaWMga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHViS2V5IC0gVGhlIHB1YmxpYyBrZXkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb3JyZXNwb25kaW5nIGFkZHJlc3MuXG4gICAqL1xuICBnZXRBZGRyZXNzRnJvbVB1YmxpY0tleShwdWJLZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKiovXG4gIGFzeW5jIGlzV2FsbGV0QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKHBhcmFtcy5hZGRyZXNzKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzRGV0YWlscy5hZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzRGV0YWlscy5hZGRyZXNzfWApO1xuICAgIH1cbiAgICBjb25zdCByb290QWRkcmVzcyA9IChwYXJhbXMuY29pblNwZWNpZmljIGFzIENvc21vc0NvaW5TcGVjaWZpYykucm9vdEFkZHJlc3M7XG4gICAgaWYgKGFkZHJlc3NEZXRhaWxzLmFkZHJlc3MgIT09IHJvb3RBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZEFkZHJlc3NFcnJvcihgYWRkcmVzcyB2YWxpZGF0aW9uIGZhaWx1cmU6ICR7YWRkcmVzc0RldGFpbHMuYWRkcmVzc30gdnMgJHtyb290QWRkcmVzc31gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKiovXG4gIGdldEhhc2hGdW5jdGlvbigpOiBIYXNoIHtcbiAgICByZXR1cm4gdXRpbHMuZ2V0SGFzaEZ1bmN0aW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBhZGRyZXNzIGludG8gYWRkcmVzcyBhbmQgbWVtbyBpZFxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyB0aGUgYWRkcmVzc1xuICAgKiBAcmV0dXJucyBvYmplY3QgY29udGFpbmluZyBhZGRyZXNzIGFuZCBtZW1vIGlkXG4gICAqL1xuICBnZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzOiBzdHJpbmcpOiBBZGRyZXNzRGV0YWlscyB7XG4gICAgY29uc3QgZGVzdGluYXRpb25EZXRhaWxzID0gdXJsLnBhcnNlKGFkZHJlc3MpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uQWRkcmVzcyA9IGRlc3RpbmF0aW9uRGV0YWlscy5wYXRobmFtZSB8fCAnJztcblxuICAgIC8vIGFkZHJlc3MgZG9lc24ndCBoYXZlIGEgbWVtbyBpZFxuICAgIGlmIChkZXN0aW5hdGlvbkRldGFpbHMucGF0aG5hbWUgPT09IGFkZHJlc3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgIG1lbW9JZDogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWRlc3RpbmF0aW9uRGV0YWlscy5xdWVyeSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IHF1ZXJ5RGV0YWlscyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKGRlc3RpbmF0aW9uRGV0YWlscy5xdWVyeSk7XG4gICAgaWYgKCFxdWVyeURldGFpbHMubWVtb0lkKSB7XG4gICAgICAvLyBpZiB0aGVyZSBhcmUgbW9yZSBwcm9wZXJ0aWVzLCB0aGUgcXVlcnkgZGV0YWlscyBuZWVkIHRvIGNvbnRhaW4gdGhlIG1lbW8gaWQgcHJvcGVydHlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShxdWVyeURldGFpbHMubWVtb0lkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoXG4gICAgICAgIGBtZW1vSWQgbWF5IG9ubHkgYmUgZ2l2ZW4gYXQgbW9zdCBvbmNlLCBidXQgZm91bmQgJHtxdWVyeURldGFpbHMubWVtb0lkLmxlbmd0aH0gaW5zdGFuY2VzIGluIGFkZHJlc3MgJHthZGRyZXNzfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlEZXRhaWxzLm1lbW9JZCkgJiYgcXVlcnlEZXRhaWxzLm1lbW9JZC5sZW5ndGggIT09IDEpIHtcbiAgICAgIC8vIHZhbGlkIGFkZHJlc3NlcyBjYW4gb25seSBjb250YWluIG9uZSBtZW1vIGlkXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzICcke2FkZHJlc3N9JywgbXVzdCBjb250YWluIGV4YWN0bHkgb25lIG1lbW9JZGApO1xuICAgIH1cblxuICAgIGNvbnN0IFttZW1vSWRdID0gXy5jYXN0QXJyYXkocXVlcnlEZXRhaWxzLm1lbW9JZCkgfHwgdW5kZWZpbmVkO1xuICAgIGlmICghdGhpcy5pc1ZhbGlkTWVtb0lkKG1lbW9JZCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVtb0lkRXJyb3IoYGludmFsaWQgYWRkcmVzczogJyR7YWRkcmVzc30nLCBtZW1vSWQgaXMgbm90IHZhbGlkYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZHJlc3M6IGRlc3RpbmF0aW9uQWRkcmVzcyxcbiAgICAgIG1lbW9JZCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhIG1lbW8gaWQgaXMgdmFsaWRcbiAgICpcbiAgICogQHBhcmFtIG1lbW9JZCBtZW1vIGlkXG4gICAqIEByZXR1cm5zIHRydWUgaWYgbWVtbyBpZCBpcyB2YWxpZFxuICAgKi9cbiAgaXNWYWxpZE1lbW9JZChtZW1vSWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB1dGlscy5pc1ZhbGlkTWVtb0lkKG1lbW9JZCk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byByZXR1cm4gdGhlIHJlc3BlY3RpdmUgY29pbidzIGJhc2UgdW5pdFxuICAgKi9cbiAgZ2V0RGVub21pbmF0aW9uKCk6IHN0cmluZyB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byBmZXRjaCBnYXMgYW1vdW50IGRldGFpbHMgZm9yIHJlc3BlY3RpdmUgY29pblxuICAgKi9cbiAgZ2V0R2FzQW1vdW50RGV0YWlscygpOiBHYXNBbW91bnREZXRhaWxzIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIGdldCBrZXkgcGFpciBmb3IgaW5kaXZpZHVhbCBjb2luXG4gICAqIEBwYXJhbSBwdWJsaWNLZXlcbiAgICovXG4gIGdldEtleVBhaXIocHVibGljS2V5OiBzdHJpbmcpOiBDb3Ntb3NLZXlQYWlyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuIl19