"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const local_forging_1 = require("@taquito/local-forging");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const multisigUtils_1 = require("./multisigUtils");
const Utils = __importStar(require("./utils"));
/**
 * Tezos transaction model.
 */
class Transaction extends sdk_core_1.BaseTransaction {
    /**
     * Public constructor.
     *
     * @param {Readonly<CoinConfig>} coinConfig
     */
    constructor(coinConfig) {
        super(coinConfig);
        this._owners = [];
    }
    /**
     * Initialize the transaction fields based on another serialized transaction.
     *
     * @param serializedTransaction Transaction in broadcast format.
     */
    async initFromSerializedTransaction(serializedTransaction) {
        this._encodedTransaction = serializedTransaction;
        try {
            const parsedTransaction = await local_forging_1.localForger.parse(serializedTransaction);
            await this.initFromParsedTransaction(parsedTransaction);
        }
        catch (e) {
            // If it throws, it is possible the serialized transaction is signed, which is not supported
            // by local-forging. Try extracting the last 64 bytes and parse it again.
            const unsignedSerializedTransaction = serializedTransaction.slice(0, -128);
            const signature = serializedTransaction.slice(-128);
            if (Utils.isValidSignature(signature)) {
                throw new sdk_core_1.ParseTransactionError('Invalid transaction');
            }
            // TODO: encode the signature and save it in _signature
            const parsedTransaction = await local_forging_1.localForger.parse(unsignedSerializedTransaction);
            const transactionId = await Utils.calculateTransactionId(serializedTransaction);
            await this.initFromParsedTransaction(parsedTransaction, transactionId);
        }
    }
    /**
     * Initialize the transaction fields based on another parsed transaction.
     *
     * @param {ParsedTransaction} parsedTransaction A Tezos transaction object
     * @param {string} transactionId The transaction id of the parsedTransaction if it is signed
     */
    async initFromParsedTransaction(parsedTransaction, transactionId) {
        if (!this._encodedTransaction) {
            this._encodedTransaction = await local_forging_1.localForger.forge(parsedTransaction);
        }
        if (transactionId) {
            // If the transaction id is passed, save it and clean up the entries since they will be
            // recalculated
            this._id = transactionId;
            this._inputs = [];
            this._outputs = [];
        }
        else {
            this._id = '';
        }
        this._parsedTransaction = parsedTransaction;
        let operationIndex = 0;
        for (const operation of parsedTransaction.contents) {
            if (this._source && this._source !== operation.source) {
                throw new sdk_core_1.InvalidTransactionError('Source must be the same for every operation but it changed from ' + this._source + ' to ' + operation.source);
            }
            else {
                this._source = operation.source;
            }
            switch (operation.kind) {
                case local_forging_1.CODEC.OP_ORIGINATION:
                    await this.recordOriginationOpFields(operation, operationIndex);
                    operationIndex++;
                    break;
                case local_forging_1.CODEC.OP_REVEAL:
                    this.recordRevealOpFields(operation);
                    break;
                case local_forging_1.CODEC.OP_TRANSACTION:
                    this.recordTransactionOpFields(operation);
                    break;
                default:
                    break;
            }
        }
    }
    /**
     * Record the most important fields from an origination operation.
     *
     * @param {Operation} operation An operation object from a Tezos transaction
     * @param {number} index The origination operation index in the transaction. Used to calculate the
     *      originated address
     */
    async recordOriginationOpFields(operation, index) {
        const originationData = (0, multisigUtils_1.getOriginationDataFromOperation)(operation);
        if (originationData.forwarderDestination) {
            this._type = sdk_core_1.TransactionType.AddressInitialization;
            this._forwarderDestination = originationData.forwarderDestination;
        }
        else {
            this._type = sdk_core_1.TransactionType.WalletInitialization;
            this._owners = (0, multisigUtils_1.getOwnersPublicKeys)(operation);
        }
        this._delegate = operation.delegate;
        this._outputs.push({
            // Kt addresses can only be calculated for signed transactions with an id
            address: this._id ? await Utils.calculateOriginatedAddress(this._id, index) : '',
            // Balance
            value: operation.balance,
        });
        this._inputs.push({
            address: operation.source,
            // Balance + fees + max gas + max storage are paid by the source account
            value: new bignumber_js_1.default(operation.balance).plus(operation.fee).toString(),
        });
    }
    /**
     * Record the most important fields from a reveal operation.
     *
     * @param {RevealOp} operation A reveal operation object from a Tezos transaction
     */
    recordRevealOpFields(operation) {
        this._type = sdk_core_1.TransactionType.AccountUpdate;
        this._publicKeyToReveal = operation.public_key;
        this._inputs.push({
            address: operation.source,
            // Balance + fees + max gas + max storage are paid by the source account
            value: operation.fee,
        });
    }
    /**
     * Record the most important fields for a Transaction operation.
     *
     * @param {TransactionOp} operation A transaction object from a Tezos operation
     */
    recordTransactionOpFields(operation) {
        if (operation.parameters) {
            this._type = sdk_core_1.TransactionType.Send;
        }
        else {
            this._type = sdk_core_1.TransactionType.SingleSigSend;
        }
        const transferData = (0, multisigUtils_1.getMultisigTransferDataFromOperation)(operation);
        // Fees are paid by the source account, along with the amount in the transaction
        this._inputs.push({
            address: operation.source,
            value: new bignumber_js_1.default(transferData.fee.fee).toFixed(0),
        });
        if (transferData.coin === 'mutez') {
            this._outputs.push({
                // Kt addresses can only be calculated for signed transactions with an id
                address: transferData.to,
                // Balance
                value: transferData.amount,
            });
            // The funds being transferred from the wallet
            this._inputs.push({
                address: transferData.from,
                // Balance + fees + max gas + max storage are paid by the source account
                value: transferData.amount,
            });
        }
    }
    /**
     * Sign the transaction with the provided key. It does not check if the signer is allowed to sign
     * it or not.
     *
     * @param {KeyPair} keyPair The key to sign the transaction with
     */
    async sign(keyPair) {
        // TODO: fail if the transaction is already signed
        // Check if there is a transaction to sign
        if (!this._parsedTransaction) {
            throw new sdk_core_1.InvalidTransactionError('Empty transaction');
        }
        // Get the transaction body to sign
        const encodedTransaction = await local_forging_1.localForger.forge(this._parsedTransaction);
        const signedTransaction = await Utils.sign(keyPair, encodedTransaction);
        this._encodedTransaction = signedTransaction.sbytes;
        // The transaction id can only be calculated for signed transactions
        this._id = await Utils.calculateTransactionId(this._encodedTransaction);
        await this.initFromParsedTransaction(this._parsedTransaction, this._id);
        this._signatures.push(signedTransaction.sig);
    }
    /**
     * Update the list of signatures for a multisig transaction operation.
     *
     * @param {IndexedSignature[]} signatures List of signatures and the index they should be put on
     *    in the multisig transfer
     * @param {number} index The transfer index to add the signatures to
     */
    async addTransferSignature(signatures, index) {
        if (!this._parsedTransaction) {
            throw new sdk_core_1.InvalidTransactionError('Empty transaction');
        }
        (0, multisigUtils_1.updateMultisigTransferSignatures)(this._parsedTransaction.contents[index], signatures);
        this._encodedTransaction = await local_forging_1.localForger.forge(this._parsedTransaction);
    }
    /** @inheritdoc */
    canSign(key) {
        // TODO: check the key belongs to the _source account in _parsedTransaction
        return true;
    }
    /** @inheritdoc */
    toJson() {
        if (!this._parsedTransaction) {
            throw new sdk_core_1.InvalidTransactionError('Empty transaction');
        }
        return this._parsedTransaction;
    }
    /** @inheritdoc */
    toBroadcastFormat() {
        if (!this._encodedTransaction) {
            throw new sdk_core_1.InvalidTransactionError('Missing encoded transaction');
        }
        return this._encodedTransaction;
    }
    /**
     * Get the transaction source if it is available.
     *
     * @returns {string} Source of the transaction
     */
    get source() {
        if (!this._source) {
            throw new sdk_core_1.InvalidTransactionError('Transaction not initialized');
        }
        return this._source;
    }
    /**
     * Get the transaction delegation address if it is available.
     *
     * @returns {string} transaction delegation address
     */
    get delegate() {
        return this._delegate;
    }
    /**
     * Get the public key revealed by the transaction if it exists
     *
     * @returns {string} public key
     */
    get publicKeyToReveal() {
        return this._publicKeyToReveal;
    }
    /**
     * Get the destination of an address initialization transaction if it exists
     *
     * @returns {string} forwarder destination
     */
    get forwarderDestination() {
        return this._forwarderDestination;
    }
    get owners() {
        return this._owners;
    }
    /**
     * Get the signatures for the given multisig transfer,
     *
     * @param {number} transferIndex The transfer script index in the Tezos transaction
     * @returns {IndexedSignature[]} A list of signatures with their index inside the multisig transfer
     *      script
     */
    getTransferSignatures(transferIndex = 0) {
        if (!this._parsedTransaction) {
            return [];
        }
        return (0, multisigUtils_1.getMultisigTransferSignatures)(this._parsedTransaction.contents[transferIndex]);
    }
    /**
     * Get the list of index per tezos transaction type. This is useful to locate specific operations
     * within the transaction and verify or sign them.
     *
     * @returns {{[p: string]: number[]}} List of indexes where the key is the transaction kind
     */
    getIndexesByTransactionType() {
        if (!this._parsedTransaction) {
            return {};
        }
        const indexes = {};
        for (let i = 0; i < this._parsedTransaction.contents.length; i++) {
            const kind = this._parsedTransaction.contents[i].kind;
            indexes[kind] = indexes[kind] ? indexes[kind].concat([i]) : [i];
        }
        return indexes;
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3RyYW5zYWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsOENBTXlCO0FBRXpCLDBEQUE0RDtBQUM1RCxnRUFBcUM7QUFHckMsbURBTXlCO0FBQ3pCLCtDQUFpQztBQUVqQzs7R0FFRztBQUNILE1BQWEsV0FBWSxTQUFRLDBCQUFlO0lBUzlDOzs7O09BSUc7SUFDSCxZQUFZLFVBQWdDO1FBQzFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNsQixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztJQUNwQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxxQkFBNkI7UUFDL0QsSUFBSSxDQUFDLG1CQUFtQixHQUFHLHFCQUFxQixDQUFDO1FBQ2pELElBQUk7WUFDRixNQUFNLGlCQUFpQixHQUFHLE1BQU0sMkJBQVcsQ0FBQyxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztZQUN6RSxNQUFNLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1NBQ3pEO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDViw0RkFBNEY7WUFDNUYseUVBQXlFO1lBQ3pFLE1BQU0sNkJBQTZCLEdBQUcscUJBQXFCLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzNFLE1BQU0sU0FBUyxHQUFHLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3BELElBQUksS0FBSyxDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUNyQyxNQUFNLElBQUksZ0NBQXFCLENBQUMscUJBQXFCLENBQUMsQ0FBQzthQUN4RDtZQUNELHVEQUF1RDtZQUN2RCxNQUFNLGlCQUFpQixHQUFHLE1B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QU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2pFO1FBQ0QsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztDQUNGO0FBbFRELGtDQWtUQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEJhc2VLZXksXG4gIEJhc2VUcmFuc2FjdGlvbixcbiAgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IsXG4gIFBhcnNlVHJhbnNhY3Rpb25FcnJvcixcbiAgVHJhbnNhY3Rpb25UeXBlLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IENPREVDLCBsb2NhbEZvcmdlciB9IGZyb20gJ0B0YXF1aXRvL2xvY2FsLWZvcmdpbmcnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgSW5kZXhlZFNpZ25hdHVyZSwgT3JpZ2luYXRpb25PcCwgUGFyc2VkVHJhbnNhY3Rpb24sIFJldmVhbE9wLCBUcmFuc2FjdGlvbk9wIH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLi9rZXlQYWlyJztcbmltcG9ydCB7XG4gIGdldE11bHRpc2lnVHJhbnNmZXJEYXRhRnJvbU9wZXJhdGlvbixcbiAgZ2V0TXVsdGlzaWdUcmFuc2ZlclNpZ25hdHVyZXMsXG4gIGdldE9yaWdpbmF0aW9uRGF0YUZyb21PcGVyYXRpb24sXG4gIGdldE93bmVyc1B1YmxpY0tleXMsXG4gIHVwZGF0ZU11bHRpc2lnVHJhbnNmZXJTaWduYXR1cmVzLFxufSBmcm9tICcuL211bHRpc2lnVXRpbHMnO1xuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogVGV6b3MgdHJhbnNhY3Rpb24gbW9kZWwuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbiBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbiB7XG4gIHByaXZhdGUgX3BhcnNlZFRyYW5zYWN0aW9uPzogUGFyc2VkVHJhbnNhY3Rpb247IC8vIHRyYW5zYWN0aW9uIGluIEpTT04gZm9ybWF0XG4gIHByaXZhdGUgX2VuY29kZWRUcmFuc2FjdGlvbj86IHN0cmluZzsgLy8gdHJhbnNhY3Rpb24gaW4gaGV4IGZvcm1hdFxuICBwcml2YXRlIF9zb3VyY2U6IHN0cmluZztcbiAgcHJpdmF0ZSBfZGVsZWdhdGU/OiBzdHJpbmc7XG4gIHByaXZhdGUgX2ZvcndhcmRlckRlc3RpbmF0aW9uPzogc3RyaW5nO1xuICBwcml2YXRlIF9wdWJsaWNLZXlUb1JldmVhbD86IHN0cmluZztcbiAgcHJpdmF0ZSBfb3duZXJzOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogUHVibGljIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWRvbmx5PENvaW5Db25maWc+fSBjb2luQ29uZmlnXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xuICAgIHN1cGVyKGNvaW5Db25maWcpO1xuICAgIHRoaXMuX293bmVycyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHRyYW5zYWN0aW9uIGZpZWxkcyBiYXNlZCBvbiBhbm90aGVyIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBzZXJpYWxpemVkVHJhbnNhY3Rpb24gVHJhbnNhY3Rpb24gaW4gYnJvYWRjYXN0IGZvcm1hdC5cbiAgICovXG4gIGFzeW5jIGluaXRGcm9tU2VyaWFsaXplZFRyYW5zYWN0aW9uKHNlcmlhbGl6ZWRUcmFuc2FjdGlvbjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5fZW5jb2RlZFRyYW5zYWN0aW9uID0gc2VyaWFsaXplZFRyYW5zYWN0aW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJzZWRUcmFuc2FjdGlvbiA9IGF3YWl0IGxvY2FsRm9yZ2VyLnBhcnNlKHNlcmlhbGl6ZWRUcmFuc2FjdGlvbik7XG4gICAgICBhd2FpdCB0aGlzLmluaXRGcm9tUGFyc2VkVHJhbnNhY3Rpb24ocGFyc2VkVHJhbnNhY3Rpb24pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIGl0IHRocm93cywgaXQgaXMgcG9zc2libGUgdGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gaXMgc2lnbmVkLCB3aGljaCBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAvLyBieSBsb2NhbC1mb3JnaW5nLiBUcnkgZXh0cmFjdGluZyB0aGUgbGFzdCA2NCBieXRlcyBhbmQgcGFyc2UgaXQgYWdhaW4uXG4gICAgICBjb25zdCB1bnNpZ25lZFNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbi5zbGljZSgwLCAtMTI4KTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbi5zbGljZSgtMTI4KTtcbiAgICAgIGlmIChVdGlscy5pc1ZhbGlkU2lnbmF0dXJlKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuICAgICAgLy8gVE9ETzogZW5jb2RlIHRoZSBzaWduYXR1cmUgYW5kIHNhdmUgaXQgaW4gX3NpZ25hdHVyZVxuICAgICAgY29uc3QgcGFyc2VkVHJhbnNhY3Rpb24gPSBhd2FpdCBsb2NhbEZvcmdlci5wYXJzZSh1bnNpZ25lZFNlcmlhbGl6ZWRUcmFuc2FjdGlvbik7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gYXdhaXQgVXRpbHMuY2FsY3VsYXRlVHJhbnNhY3Rpb25JZChzZXJpYWxpemVkVHJhbnNhY3Rpb24pO1xuICAgICAgYXdhaXQgdGhpcy5pbml0RnJvbVBhcnNlZFRyYW5zYWN0aW9uKHBhcnNlZFRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbklkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgdHJhbnNhY3Rpb24gZmllbGRzIGJhc2VkIG9uIGFub3RoZXIgcGFyc2VkIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1BhcnNlZFRyYW5zYWN0aW9ufSBwYXJzZWRUcmFuc2FjdGlvbiBBIFRlem9zIHRyYW5zYWN0aW9uIG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNhY3Rpb25JZCBUaGUgdHJhbnNhY3Rpb24gaWQgb2YgdGhlIHBhcnNlZFRyYW5zYWN0aW9uIGlmIGl0IGlzIHNpZ25lZFxuICAgKi9cbiAgYXN5bmMgaW5pdEZyb21QYXJzZWRUcmFuc2FjdGlvbihwYXJzZWRUcmFuc2FjdGlvbjogUGFyc2VkVHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uSWQ/OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuX2VuY29kZWRUcmFuc2FjdGlvbikge1xuICAgICAgdGhpcy5fZW5jb2RlZFRyYW5zYWN0aW9uID0gYXdhaXQgbG9jYWxGb3JnZXIuZm9yZ2UocGFyc2VkVHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb25JZCkge1xuICAgICAgLy8gSWYgdGhlIHRyYW5zYWN0aW9uIGlkIGlzIHBhc3NlZCwgc2F2ZSBpdCBhbmQgY2xlYW4gdXAgdGhlIGVudHJpZXMgc2luY2UgdGhleSB3aWxsIGJlXG4gICAgICAvLyByZWNhbGN1bGF0ZWRcbiAgICAgIHRoaXMuX2lkID0gdHJhbnNhY3Rpb25JZDtcbiAgICAgIHRoaXMuX2lucHV0cyA9IFtdO1xuICAgICAgdGhpcy5fb3V0cHV0cyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pZCA9ICcnO1xuICAgIH1cbiAgICB0aGlzLl9wYXJzZWRUcmFuc2FjdGlvbiA9IHBhcnNlZFRyYW5zYWN0aW9uO1xuICAgIGxldCBvcGVyYXRpb25JbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBvcGVyYXRpb24gb2YgcGFyc2VkVHJhbnNhY3Rpb24uY29udGVudHMpIHtcbiAgICAgIGlmICh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlICE9PSBvcGVyYXRpb24uc291cmNlKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihcbiAgICAgICAgICAnU291cmNlIG11c3QgYmUgdGhlIHNhbWUgZm9yIGV2ZXJ5IG9wZXJhdGlvbiBidXQgaXQgY2hhbmdlZCBmcm9tICcgKyB0aGlzLl9zb3VyY2UgKyAnIHRvICcgKyBvcGVyYXRpb24uc291cmNlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zb3VyY2UgPSBvcGVyYXRpb24uc291cmNlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChvcGVyYXRpb24ua2luZCkge1xuICAgICAgICBjYXNlIENPREVDLk9QX09SSUdJTkFUSU9OOlxuICAgICAgICAgIGF3YWl0IHRoaXMucmVjb3JkT3JpZ2luYXRpb25PcEZpZWxkcyhvcGVyYXRpb24gYXMgT3JpZ2luYXRpb25PcCwgb3BlcmF0aW9uSW5kZXgpO1xuICAgICAgICAgIG9wZXJhdGlvbkluZGV4Kys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ09ERUMuT1BfUkVWRUFMOlxuICAgICAgICAgIHRoaXMucmVjb3JkUmV2ZWFsT3BGaWVsZHMob3BlcmF0aW9uIGFzIFJldmVhbE9wKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDT0RFQy5PUF9UUkFOU0FDVElPTjpcbiAgICAgICAgICB0aGlzLnJlY29yZFRyYW5zYWN0aW9uT3BGaWVsZHMob3BlcmF0aW9uIGFzIFRyYW5zYWN0aW9uT3ApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvcmQgdGhlIG1vc3QgaW1wb3J0YW50IGZpZWxkcyBmcm9tIGFuIG9yaWdpbmF0aW9uIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPcGVyYXRpb259IG9wZXJhdGlvbiBBbiBvcGVyYXRpb24gb2JqZWN0IGZyb20gYSBUZXpvcyB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIG9yaWdpbmF0aW9uIG9wZXJhdGlvbiBpbmRleCBpbiB0aGUgdHJhbnNhY3Rpb24uIFVzZWQgdG8gY2FsY3VsYXRlIHRoZVxuICAgKiAgICAgIG9yaWdpbmF0ZWQgYWRkcmVzc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyByZWNvcmRPcmlnaW5hdGlvbk9wRmllbGRzKG9wZXJhdGlvbjogT3JpZ2luYXRpb25PcCwgaW5kZXg6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG9yaWdpbmF0aW9uRGF0YSA9IGdldE9yaWdpbmF0aW9uRGF0YUZyb21PcGVyYXRpb24ob3BlcmF0aW9uKTtcbiAgICBpZiAob3JpZ2luYXRpb25EYXRhLmZvcndhcmRlckRlc3RpbmF0aW9uKSB7XG4gICAgICB0aGlzLl90eXBlID0gVHJhbnNhY3Rpb25UeXBlLkFkZHJlc3NJbml0aWFsaXphdGlvbjtcbiAgICAgIHRoaXMuX2ZvcndhcmRlckRlc3RpbmF0aW9uID0gb3JpZ2luYXRpb25EYXRhLmZvcndhcmRlckRlc3RpbmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90eXBlID0gVHJhbnNhY3Rpb25UeXBlLldhbGxldEluaXRpYWxpemF0aW9uO1xuICAgICAgdGhpcy5fb3duZXJzID0gZ2V0T3duZXJzUHVibGljS2V5cyhvcGVyYXRpb24pO1xuICAgIH1cblxuICAgIHRoaXMuX2RlbGVnYXRlID0gb3BlcmF0aW9uLmRlbGVnYXRlO1xuICAgIHRoaXMuX291dHB1dHMucHVzaCh7XG4gICAgICAvLyBLdCBhZGRyZXNzZXMgY2FuIG9ubHkgYmUgY2FsY3VsYXRlZCBmb3Igc2lnbmVkIHRyYW5zYWN0aW9ucyB3aXRoIGFuIGlkXG4gICAgICBhZGRyZXNzOiB0aGlzLl9pZCA/IGF3YWl0IFV0aWxzLmNhbGN1bGF0ZU9yaWdpbmF0ZWRBZGRyZXNzKHRoaXMuX2lkLCBpbmRleCkgOiAnJyxcbiAgICAgIC8vIEJhbGFuY2VcbiAgICAgIHZhbHVlOiBvcGVyYXRpb24uYmFsYW5jZSxcbiAgICB9KTtcbiAgICB0aGlzLl9pbnB1dHMucHVzaCh7XG4gICAgICBhZGRyZXNzOiBvcGVyYXRpb24uc291cmNlLFxuICAgICAgLy8gQmFsYW5jZSArIGZlZXMgKyBtYXggZ2FzICsgbWF4IHN0b3JhZ2UgYXJlIHBhaWQgYnkgdGhlIHNvdXJjZSBhY2NvdW50XG4gICAgICB2YWx1ZTogbmV3IEJpZ051bWJlcihvcGVyYXRpb24uYmFsYW5jZSkucGx1cyhvcGVyYXRpb24uZmVlKS50b1N0cmluZygpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY29yZCB0aGUgbW9zdCBpbXBvcnRhbnQgZmllbGRzIGZyb20gYSByZXZlYWwgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1JldmVhbE9wfSBvcGVyYXRpb24gQSByZXZlYWwgb3BlcmF0aW9uIG9iamVjdCBmcm9tIGEgVGV6b3MgdHJhbnNhY3Rpb25cbiAgICovXG4gIHByaXZhdGUgcmVjb3JkUmV2ZWFsT3BGaWVsZHMob3BlcmF0aW9uOiBSZXZlYWxPcCk6IHZvaWQge1xuICAgIHRoaXMuX3R5cGUgPSBUcmFuc2FjdGlvblR5cGUuQWNjb3VudFVwZGF0ZTtcbiAgICB0aGlzLl9wdWJsaWNLZXlUb1JldmVhbCA9IG9wZXJhdGlvbi5wdWJsaWNfa2V5O1xuICAgIHRoaXMuX2lucHV0cy5wdXNoKHtcbiAgICAgIGFkZHJlc3M6IG9wZXJhdGlvbi5zb3VyY2UsXG4gICAgICAvLyBCYWxhbmNlICsgZmVlcyArIG1heCBnYXMgKyBtYXggc3RvcmFnZSBhcmUgcGFpZCBieSB0aGUgc291cmNlIGFjY291bnRcbiAgICAgIHZhbHVlOiBvcGVyYXRpb24uZmVlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY29yZCB0aGUgbW9zdCBpbXBvcnRhbnQgZmllbGRzIGZvciBhIFRyYW5zYWN0aW9uIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbk9wfSBvcGVyYXRpb24gQSB0cmFuc2FjdGlvbiBvYmplY3QgZnJvbSBhIFRlem9zIG9wZXJhdGlvblxuICAgKi9cbiAgcHJpdmF0ZSByZWNvcmRUcmFuc2FjdGlvbk9wRmllbGRzKG9wZXJhdGlvbjogVHJhbnNhY3Rpb25PcCk6IHZvaWQge1xuICAgIGlmIChvcGVyYXRpb24ucGFyYW1ldGVycykge1xuICAgICAgdGhpcy5fdHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5TZW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90eXBlID0gVHJhbnNhY3Rpb25UeXBlLlNpbmdsZVNpZ1NlbmQ7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZmVyRGF0YSA9IGdldE11bHRpc2lnVHJhbnNmZXJEYXRhRnJvbU9wZXJhdGlvbihvcGVyYXRpb24pO1xuICAgIC8vIEZlZXMgYXJlIHBhaWQgYnkgdGhlIHNvdXJjZSBhY2NvdW50LCBhbG9uZyB3aXRoIHRoZSBhbW91bnQgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAgdGhpcy5faW5wdXRzLnB1c2goe1xuICAgICAgYWRkcmVzczogb3BlcmF0aW9uLnNvdXJjZSxcbiAgICAgIHZhbHVlOiBuZXcgQmlnTnVtYmVyKHRyYW5zZmVyRGF0YS5mZWUuZmVlKS50b0ZpeGVkKDApLFxuICAgIH0pO1xuXG4gICAgaWYgKHRyYW5zZmVyRGF0YS5jb2luID09PSAnbXV0ZXonKSB7XG4gICAgICB0aGlzLl9vdXRwdXRzLnB1c2goe1xuICAgICAgICAvLyBLdCBhZGRyZXNzZXMgY2FuIG9ubHkgYmUgY2FsY3VsYXRlZCBmb3Igc2lnbmVkIHRyYW5zYWN0aW9ucyB3aXRoIGFuIGlkXG4gICAgICAgIGFkZHJlc3M6IHRyYW5zZmVyRGF0YS50byxcbiAgICAgICAgLy8gQmFsYW5jZVxuICAgICAgICB2YWx1ZTogdHJhbnNmZXJEYXRhLmFtb3VudCxcbiAgICAgIH0pO1xuICAgICAgLy8gVGhlIGZ1bmRzIGJlaW5nIHRyYW5zZmVycmVkIGZyb20gdGhlIHdhbGxldFxuICAgICAgdGhpcy5faW5wdXRzLnB1c2goe1xuICAgICAgICBhZGRyZXNzOiB0cmFuc2ZlckRhdGEuZnJvbSxcbiAgICAgICAgLy8gQmFsYW5jZSArIGZlZXMgKyBtYXggZ2FzICsgbWF4IHN0b3JhZ2UgYXJlIHBhaWQgYnkgdGhlIHNvdXJjZSBhY2NvdW50XG4gICAgICAgIHZhbHVlOiB0cmFuc2ZlckRhdGEuYW1vdW50LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gdGhlIHRyYW5zYWN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGtleS4gSXQgZG9lcyBub3QgY2hlY2sgaWYgdGhlIHNpZ25lciBpcyBhbGxvd2VkIHRvIHNpZ25cbiAgICogaXQgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge0tleVBhaXJ9IGtleVBhaXIgVGhlIGtleSB0byBzaWduIHRoZSB0cmFuc2FjdGlvbiB3aXRoXG4gICAqL1xuICBhc3luYyBzaWduKGtleVBhaXI6IEtleVBhaXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBUT0RPOiBmYWlsIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhbHJlYWR5IHNpZ25lZFxuICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgdHJhbnNhY3Rpb24gdG8gc2lnblxuICAgIGlmICghdGhpcy5fcGFyc2VkVHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignRW1wdHkgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSB0cmFuc2FjdGlvbiBib2R5IHRvIHNpZ25cbiAgICBjb25zdCBlbmNvZGVkVHJhbnNhY3Rpb24gPSBhd2FpdCBsb2NhbEZvcmdlci5mb3JnZSh0aGlzLl9wYXJzZWRUcmFuc2FjdGlvbik7XG5cbiAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbiA9IGF3YWl0IFV0aWxzLnNpZ24oa2V5UGFpciwgZW5jb2RlZFRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLl9lbmNvZGVkVHJhbnNhY3Rpb24gPSBzaWduZWRUcmFuc2FjdGlvbi5zYnl0ZXM7XG5cbiAgICAvLyBUaGUgdHJhbnNhY3Rpb24gaWQgY2FuIG9ubHkgYmUgY2FsY3VsYXRlZCBmb3Igc2lnbmVkIHRyYW5zYWN0aW9uc1xuICAgIHRoaXMuX2lkID0gYXdhaXQgVXRpbHMuY2FsY3VsYXRlVHJhbnNhY3Rpb25JZCh0aGlzLl9lbmNvZGVkVHJhbnNhY3Rpb24pO1xuICAgIGF3YWl0IHRoaXMuaW5pdEZyb21QYXJzZWRUcmFuc2FjdGlvbih0aGlzLl9wYXJzZWRUcmFuc2FjdGlvbiwgdGhpcy5faWQpO1xuXG4gICAgdGhpcy5fc2lnbmF0dXJlcy5wdXNoKHNpZ25lZFRyYW5zYWN0aW9uLnNpZyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBsaXN0IG9mIHNpZ25hdHVyZXMgZm9yIGEgbXVsdGlzaWcgdHJhbnNhY3Rpb24gb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0luZGV4ZWRTaWduYXR1cmVbXX0gc2lnbmF0dXJlcyBMaXN0IG9mIHNpZ25hdHVyZXMgYW5kIHRoZSBpbmRleCB0aGV5IHNob3VsZCBiZSBwdXQgb25cbiAgICogICAgaW4gdGhlIG11bHRpc2lnIHRyYW5zZmVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgdHJhbnNmZXIgaW5kZXggdG8gYWRkIHRoZSBzaWduYXR1cmVzIHRvXG4gICAqL1xuICBhc3luYyBhZGRUcmFuc2ZlclNpZ25hdHVyZShzaWduYXR1cmVzOiBJbmRleGVkU2lnbmF0dXJlW10sIGluZGV4OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuX3BhcnNlZFRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ0VtcHR5IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIHVwZGF0ZU11bHRpc2lnVHJhbnNmZXJTaWduYXR1cmVzKHRoaXMuX3BhcnNlZFRyYW5zYWN0aW9uLmNvbnRlbnRzW2luZGV4XSBhcyBUcmFuc2FjdGlvbk9wLCBzaWduYXR1cmVzKTtcbiAgICB0aGlzLl9lbmNvZGVkVHJhbnNhY3Rpb24gPSBhd2FpdCBsb2NhbEZvcmdlci5mb3JnZSh0aGlzLl9wYXJzZWRUcmFuc2FjdGlvbik7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgY2FuU2lnbihrZXk6IEJhc2VLZXkpOiBib29sZWFuIHtcbiAgICAvLyBUT0RPOiBjaGVjayB0aGUga2V5IGJlbG9uZ3MgdG8gdGhlIF9zb3VyY2UgYWNjb3VudCBpbiBfcGFyc2VkVHJhbnNhY3Rpb25cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB0b0pzb24oKTogUGFyc2VkVHJhbnNhY3Rpb24ge1xuICAgIGlmICghdGhpcy5fcGFyc2VkVHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignRW1wdHkgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZFRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHRvQnJvYWRjYXN0Rm9ybWF0KCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLl9lbmNvZGVkVHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignTWlzc2luZyBlbmNvZGVkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVkVHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0cmFuc2FjdGlvbiBzb3VyY2UgaWYgaXQgaXMgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTb3VyY2Ugb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBnZXQgc291cmNlKCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLl9zb3VyY2UpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gbm90IGluaXRpYWxpemVkJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0cmFuc2FjdGlvbiBkZWxlZ2F0aW9uIGFkZHJlc3MgaWYgaXQgaXMgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0cmFuc2FjdGlvbiBkZWxlZ2F0aW9uIGFkZHJlc3NcbiAgICovXG4gIGdldCBkZWxlZ2F0ZSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpYyBrZXkgcmV2ZWFsZWQgYnkgdGhlIHRyYW5zYWN0aW9uIGlmIGl0IGV4aXN0c1xuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwdWJsaWMga2V5XG4gICAqL1xuICBnZXQgcHVibGljS2V5VG9SZXZlYWwoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fcHVibGljS2V5VG9SZXZlYWw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZXN0aW5hdGlvbiBvZiBhbiBhZGRyZXNzIGluaXRpYWxpemF0aW9uIHRyYW5zYWN0aW9uIGlmIGl0IGV4aXN0c1xuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBmb3J3YXJkZXIgZGVzdGluYXRpb25cbiAgICovXG4gIGdldCBmb3J3YXJkZXJEZXN0aW5hdGlvbigpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9mb3J3YXJkZXJEZXN0aW5hdGlvbjtcbiAgfVxuXG4gIGdldCBvd25lcnMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLl9vd25lcnM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaWduYXR1cmVzIGZvciB0aGUgZ2l2ZW4gbXVsdGlzaWcgdHJhbnNmZXIsXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cmFuc2ZlckluZGV4IFRoZSB0cmFuc2ZlciBzY3JpcHQgaW5kZXggaW4gdGhlIFRlem9zIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtJbmRleGVkU2lnbmF0dXJlW119IEEgbGlzdCBvZiBzaWduYXR1cmVzIHdpdGggdGhlaXIgaW5kZXggaW5zaWRlIHRoZSBtdWx0aXNpZyB0cmFuc2ZlclxuICAgKiAgICAgIHNjcmlwdFxuICAgKi9cbiAgZ2V0VHJhbnNmZXJTaWduYXR1cmVzKHRyYW5zZmVySW5kZXggPSAwKTogSW5kZXhlZFNpZ25hdHVyZVtdIHtcbiAgICBpZiAoIXRoaXMuX3BhcnNlZFRyYW5zYWN0aW9uKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBnZXRNdWx0aXNpZ1RyYW5zZmVyU2lnbmF0dXJlcyh0aGlzLl9wYXJzZWRUcmFuc2FjdGlvbi5jb250ZW50c1t0cmFuc2ZlckluZGV4XSBhcyBUcmFuc2FjdGlvbk9wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2YgaW5kZXggcGVyIHRlem9zIHRyYW5zYWN0aW9uIHR5cGUuIFRoaXMgaXMgdXNlZnVsIHRvIGxvY2F0ZSBzcGVjaWZpYyBvcGVyYXRpb25zXG4gICAqIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24gYW5kIHZlcmlmeSBvciBzaWduIHRoZW0uXG4gICAqXG4gICAqIEByZXR1cm5zIHt7W3A6IHN0cmluZ106IG51bWJlcltdfX0gTGlzdCBvZiBpbmRleGVzIHdoZXJlIHRoZSBrZXkgaXMgdGhlIHRyYW5zYWN0aW9uIGtpbmRcbiAgICovXG4gIGdldEluZGV4ZXNCeVRyYW5zYWN0aW9uVHlwZSgpOiB7IFtraW5kOiBzdHJpbmddOiBudW1iZXJbXSB9IHtcbiAgICBpZiAoIXRoaXMuX3BhcnNlZFRyYW5zYWN0aW9uKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ZXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BhcnNlZFRyYW5zYWN0aW9uLmNvbnRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBraW5kID0gdGhpcy5fcGFyc2VkVHJhbnNhY3Rpb24uY29udGVudHNbaV0ua2luZDtcbiAgICAgIGluZGV4ZXNba2luZF0gPSBpbmRleGVzW2tpbmRdID8gaW5kZXhlc1traW5kXS5jb25jYXQoW2ldKSA6IFtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4ZXM7XG4gIH1cbn1cbiJdfQ==