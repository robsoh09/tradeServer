"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tofcPolygonErc20 = exports.ofcPolygonErc20 = exports.tofcAvaxErc20 = exports.ofcAvaxErc20 = exports.tofcArbethErc20 = exports.ofcArbethErc20 = exports.tofcHederaToken = exports.ofcHederaToken = exports.tofcAlgoToken = exports.ofcAlgoToken = exports.tofcStellarToken = exports.ofcStellarToken = exports.tofcsolToken = exports.ofcsolToken = exports.tofcerc20 = exports.ofcerc20 = exports.tofc = exports.ofc = exports.OfcCoin = void 0;
const base_1 = require("./base");
const networks_1 = require("./networks");
/**
 * OFC (off chain) coins. These are virtual coins used to represent off chain assets on the BitGo platform.
 */
class OfcCoin extends base_1.BaseCoin {
    constructor(options) {
        const { addressCoin, ...baseOptions } = options;
        super(baseOptions);
        this.addressCoin = addressCoin;
    }
    requiredFeatures() {
        return new Set([base_1.CoinFeature.ACCOUNT_MODEL, base_1.CoinFeature.REQUIRES_BIG_NUMBER]);
    }
    disallowedFeatures() {
        return new Set([
            base_1.CoinFeature.UNSPENT_MODEL,
            base_1.CoinFeature.CHILD_PAYS_FOR_PARENT,
            base_1.CoinFeature.PAYGO,
            base_1.CoinFeature.SUPPORTS_TOKENS,
        ]);
    }
}
exports.OfcCoin = OfcCoin;
OfcCoin.DEFAULT_FEATURES = [
    base_1.CoinFeature.ACCOUNT_MODEL,
    base_1.CoinFeature.REQUIRES_BIG_NUMBER,
    base_1.CoinFeature.CUSTODY,
    base_1.CoinFeature.CUSTODY_BITGO_TRUST,
];
/**
 * Factory function for ofc coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofc(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, 
/** OFC tokens use SECP256K1 under the hood even if the chain doesn't **/
primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.OFC,
    }));
}
exports.ofc = ofc;
/**
 * Factory function for testnet ofc coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofc(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.OFC,
    }));
}
exports.tofc = tofc;
/**
 * Factory function for ofc erc20 coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcerc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'eth', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.ofcerc20 = ofcerc20;
/**
 * Factory function for testnet ofc erc20 coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcerc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'teth', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.tofcerc20 = tofcerc20;
/**
 * Factory function for ofc solana token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param features
 * @param prefix
 * @param suffix
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param isToken
 * @param addressCoin
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcsolToken(id, name, fullName, decimalPlaces, asset, features = [...OfcCoin.DEFAULT_FEATURES, base_1.CoinFeature.REQUIRES_RESERVE], kind = base_1.CoinKind.CRYPTO, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'sol', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.SOL,
    }));
}
exports.ofcsolToken = ofcsolToken;
/**
 * Factory function for testnet ofc solana token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param features
 * @param prefix
 * @param suffix
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param isToken
 * @param addressCoin
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcsolToken(id, name, fullName, decimalPlaces, asset, features = [...OfcCoin.DEFAULT_FEATURES, base_1.CoinFeature.REQUIRES_RESERVE], kind = base_1.CoinKind.CRYPTO, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'tsol', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.SOL,
    }));
}
exports.tofcsolToken = tofcsolToken;
/**
 * Factory function for ofc stellar token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcStellarToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'xlm', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.XLM,
    }));
}
exports.ofcStellarToken = ofcStellarToken;
/**
 * Factory function for testnet ofc stellar token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcStellarToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'txlm', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.XLM,
    }));
}
exports.tofcStellarToken = tofcStellarToken;
/**
 * Factory function for ofc algo token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcAlgoToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'algo', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ALGO,
    }));
}
exports.ofcAlgoToken = ofcAlgoToken;
/**
 * Factory function for testnet ofc algo token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcAlgoToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'talgo', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ALGO,
    }));
}
exports.tofcAlgoToken = tofcAlgoToken;
/**
 * Factory function for ofc hedera token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcHederaToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'hbar', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.HBAR,
    }));
}
exports.ofcHederaToken = ofcHederaToken;
/**
 * Factory function for testnet ofc hedera token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcHederaToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'thbar', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.HBAR,
    }));
}
exports.tofcHederaToken = tofcHederaToken;
/**
 * Factory function for ofc arbethErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcArbethErc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'arbeth', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.ofcArbethErc20 = ofcArbethErc20;
/**
 * Factory function for testnet ofc arbethErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcArbethErc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'tarbeth', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.tofcArbethErc20 = tofcArbethErc20;
/**
 * Factory function for ofc avaxErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcAvaxErc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'avaxc', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.ofcAvaxErc20 = ofcAvaxErc20;
/**
 * Factory function for testnet ofc avaxErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcAvaxErc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'tavaxc', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.tofcAvaxErc20 = tofcAvaxErc20;
/**
 * Factory function for ofc polygonErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcPolygonErc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'polygon', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.ofcPolygonErc20 = ofcPolygonErc20;
/**
 * Factory function for testnet ofc polygonErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcPolygonErc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'tpolygon', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.tofcPolygonErc20 = tofcPolygonErc20;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2ZjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL29mYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxpQ0FBOEY7QUFDOUYseUNBQStEO0FBbUIvRDs7R0FFRztBQUNILE1BQWEsT0FBUSxTQUFRLGVBQVE7SUFXbkMsWUFBWSxPQUE4QjtRQUN4QyxNQUFNLEVBQUUsV0FBVyxFQUFFLEdBQUcsV0FBVyxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQ2hELEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNuQixJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztJQUNqQyxDQUFDO0lBRVMsZ0JBQWdCO1FBQ3hCLE9BQU8sSUFBSSxHQUFHLENBQWMsQ0FBQyxrQkFBVyxDQUFDLGFBQWEsRUFBRSxrQkFBVyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQztJQUM1RixDQUFDO0lBRVMsa0JBQWtCO1FBQzFCLE9BQU8sSUFBSSxHQUFHLENBQWM7WUFDMUIsa0JBQVcsQ0FBQyxhQUFhO1lBQ3pCLGtCQUFXLENBQUMscUJBQXFCO1lBQ2pDLGtCQUFXLENBQUMsS0FBSztZQUNqQixrQkFBVyxDQUFDLGVBQWU7U0FDNUIsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs7QUE1QkgsMEJBNkJDO0FBNUJ3Qix3QkFBZ0IsR0FBRztJQUN4QyxrQkFBVyxDQUFDLGFBQWE7SUFDekIsa0JBQVcsQ0FBQyxtQkFBbUI7SUFDL0Isa0JBQVcsQ0FBQyxPQUFPO0lBQ25CLGtCQUFXLENBQUMsbUJBQW1CO0NBQ2hDLENBQUM7QUF5Qko7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsU0FBZ0IsR0FBRyxDQUNqQixFQUFVLEVBQ1YsSUFBWSxFQUNaLFFBQWdCLEVBQ2hCLGFBQXFCLEVBQ3JCLEtBQXNCLEVBQ3RCLE9BQWlCLGVBQVEsQ0FBQyxNQUFNLEVBQ2hDLFdBQTBCLE9BQU8sQ0FBQyxnQkFBZ0IsRUFDbEQsTUFBTSxHQUFHLEVBQUUsRUFDWCxTQUFpQixJ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USxDQUFDLE1BQU0sRUFDaEMsV0FBMEIsT0FBTyxDQUFDLGdCQUFnQixFQUNsRCxNQUFNLEdBQUcsRUFBRSxFQUNYLFNBQWlCLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDLFdBQVcsRUFBRSxFQUN2RCxVQUFzQixtQkFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQ3ZDLE9BQU8sR0FBRyxJQUFJLEVBQ2QsV0FBVyxHQUFHLFVBQVUsRUFDeEIsa0JBQTRCLGVBQVEsQ0FBQyxTQUFTO0lBRTlDLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FDbEIsSUFBSSxPQUFPLENBQUM7UUFDVixFQUFFO1FBQ0YsSUFBSTtRQUNKLFFBQVE7UUFDUixPQUFPO1FBQ1AsTUFBTTtRQUNOLE1BQU07UUFDTixRQUFRO1FBQ1IsYUFBYTtRQUNiLE9BQU87UUFDUCxLQUFLO1FBQ0wsSUFBSTtRQUNKLFdBQVc7UUFDWCxlQUFlO1FBQ2YsUUFBUSxFQUFFLGVBQVEsQ0FBQyxHQUFHO0tBQ3ZCLENBQUMsQ0FDSCxDQUFDO0FBQ0osQ0FBQztBQWpDRCw0Q0FpQ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ29pbiwgQmFzZVVuaXQsIENvaW5GZWF0dXJlLCBDb2luS2luZCwgS2V5Q3VydmUsIFVuZGVybHlpbmdBc3NldCB9IGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBCYXNlTmV0d29yaywgTmV0d29ya3MsIE9mY05ldHdvcmsgfSBmcm9tICcuL25ldHdvcmtzJztcblxuZXhwb3J0IGludGVyZmFjZSBPZmNDb25zdHJ1Y3Rvck9wdGlvbnMge1xuICBpZDogc3RyaW5nO1xuICBmdWxsTmFtZTogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIG5ldHdvcms6IEJhc2VOZXR3b3JrO1xuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0O1xuICBiYXNlVW5pdDogQmFzZVVuaXQ7XG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdO1xuICBkZWNpbWFsUGxhY2VzOiBudW1iZXI7XG4gIGlzVG9rZW46IGJvb2xlYW47XG4gIGtpbmQ6IENvaW5LaW5kO1xuICBwcmVmaXg/OiBzdHJpbmc7XG4gIHN1ZmZpeD86IHN0cmluZztcbiAgYWRkcmVzc0NvaW4/OiBzdHJpbmc7XG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmU7XG59XG5cbi8qKlxuICogT0ZDIChvZmYgY2hhaW4pIGNvaW5zLiBUaGVzZSBhcmUgdmlydHVhbCBjb2lucyB1c2VkIHRvIHJlcHJlc2VudCBvZmYgY2hhaW4gYXNzZXRzIG9uIHRoZSBCaXRHbyBwbGF0Zm9ybS5cbiAqL1xuZXhwb3J0IGNsYXNzIE9mY0NvaW4gZXh0ZW5kcyBCYXNlQ29pbiB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9GRUFUVVJFUyA9IFtcbiAgICBDb2luRmVhdHVyZS5BQ0NPVU5UX01PREVMLFxuICAgIENvaW5GZWF0dXJlLlJFUVVJUkVTX0JJR19OVU1CRVIsXG4gICAgQ29pbkZlYXR1cmUuQ1VTVE9EWSxcbiAgICBDb2luRmVhdHVyZS5DVVNUT0RZX0JJVEdPX1RSVVNULFxuICBdO1xuXG4gIC8vIElmIHNldCwgdGhpcyBjb2luIGlzIHRoZSBuYXRpdmUgYWRkcmVzcyBmb3JtYXQgZm9yIHRoaXMgdG9rZW4uXG4gIHB1YmxpYyByZWFkb25seSBhZGRyZXNzQ29pbj86IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBPZmNDb25zdHJ1Y3Rvck9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFkZHJlc3NDb2luLCAuLi5iYXNlT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICBzdXBlcihiYXNlT3B0aW9ucyk7XG4gICAgdGhpcy5hZGRyZXNzQ29pbiA9IGFkZHJlc3NDb2luO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlcXVpcmVkRmVhdHVyZXMoKTogU2V0PENvaW5GZWF0dXJlPiB7XG4gICAgcmV0dXJuIG5ldyBTZXQ8Q29pbkZlYXR1cmU+KFtDb2luRmVhdHVyZS5BQ0NPVU5UX01PREVMLCBDb2luRmVhdHVyZS5SRVFVSVJFU19CSUdfTlVNQkVSXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZGlzYWxsb3dlZEZlYXR1cmVzKCk6IFNldDxDb2luRmVhdHVyZT4ge1xuICAgIHJldHVybiBuZXcgU2V0PENvaW5GZWF0dXJlPihbXG4gICAgICBDb2luRmVhdHVyZS5VTlNQRU5UX01PREVMLFxuICAgICAgQ29pbkZlYXR1cmUuQ0hJTERfUEFZU19GT1JfUEFSRU5ULFxuICAgICAgQ29pbkZlYXR1cmUuUEFZR08sXG4gICAgICBDb2luRmVhdHVyZS5TVVBQT1JUU19UT0tFTlMsXG4gICAgXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBvZmMgY29pbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIGNvaW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIGNvaW4gc3VmZml4LiBEZWZhdWx0cyB0byBjb2luIG5hbWUuXG4gKiBAcGFyYW0gaXNUb2tlbj8gV2hldGhlciBvciBub3QgdGhpcyBhY2NvdW50IGNvaW4gaXMgYSB0b2tlbiBvZiBhbm90aGVyIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBPZmNDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mYyhcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS5yZXBsYWNlKC9eb2ZjLywgJycpLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IE9mY05ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLm9mYyxcbiAgaXNUb2tlbiA9IHRydWUsXG4gIC8qKiBPRkMgdG9rZW5zIHVzZSBTRUNQMjU2SzEgdW5kZXIgdGhlIGhvb2QgZXZlbiBpZiB0aGUgY2hhaW4gZG9lc24ndCAqKi9cbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuT0ZDLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBvZmMgY29pbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIGNvaW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIGNvaW4gc3VmZml4LiBEZWZhdWx0cyB0byBjb2luIG5hbWUuXG4gKiBAcGFyYW0gaXNUb2tlbj8gV2hldGhlciBvciBub3QgdGhpcyBhY2NvdW50IGNvaW4gaXMgYSB0b2tlbiBvZiBhbm90aGVyIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBPZmNDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvZmMoXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUucmVwbGFjZSgvXm9mYy8sICcnKS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MudGVzdC5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5PRkMsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBvZmMgZXJjMjAgY29pbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIGNvaW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIGNvaW4gc3VmZml4LiBEZWZhdWx0cyB0byBjb2luIG5hbWUuXG4gKiBAcGFyYW0gaXNUb2tlbj8gV2hldGhlciBvciBub3QgdGhpcyBhY2NvdW50IGNvaW4gaXMgYSB0b2tlbiBvZiBhbm90aGVyIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBPZmNDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mY2VyYzIwKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLm1haW4ub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW4gPSAnZXRoJyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5FVEgsXG4gICAgfSlcbiAgKTtcbn1cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBvZmMgZXJjMjAgY29pbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIGNvaW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIGNvaW4gc3VmZml4LiBEZWZhdWx0cyB0byBjb2luIG5hbWUuXG4gKiBAcGFyYW0gaXNUb2tlbj8gV2hldGhlciBvciBub3QgdGhpcyBhY2NvdW50IGNvaW4gaXMgYSB0b2tlbiBvZiBhbm90aGVyIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBPZmNDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvZmNlcmMyMChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS5yZXBsYWNlKC9eb2ZjLywgJycpLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IE9mY05ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0Lm9mYyxcbiAgaXNUb2tlbiA9IHRydWUsXG4gIGFkZHJlc3NDb2luID0gJ3RldGgnLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIGFkZHJlc3NDb2luLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkVUSCxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIG9mYyBzb2xhbmEgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlc1xuICogQHBhcmFtIHByZWZpeFxuICogQHBhcmFtIHN1ZmZpeFxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBpc1Rva2VuXG4gKiBAcGFyYW0gYWRkcmVzc0NvaW5cbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG9mY3NvbFRva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBbLi4uT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLCBDb2luRmVhdHVyZS5SRVFVSVJFU19SRVNFUlZFXSxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUucmVwbGFjZSgvXm9mYy8sICcnKS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MubWFpbi5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICBhZGRyZXNzQ29pbiA9ICdzb2wnLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIGFkZHJlc3NDb2luLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LlNPTCxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgb2ZjIHNvbGFuYSB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIGZlYXR1cmVzXG4gKiBAcGFyYW0gcHJlZml4XG4gKiBAcGFyYW0gc3VmZml4XG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIGlzVG9rZW5cbiAqIEBwYXJhbSBhZGRyZXNzQ29pblxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdG9mY3NvbFRva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBbLi4uT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLCBDb2luRmVhdHVyZS5SRVFVSVJFU19SRVNFUlZFXSxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUucmVwbGFjZSgvXm9mYy8sICcnKS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MudGVzdC5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICBhZGRyZXNzQ29pbiA9ICd0c29sJyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5TT0wsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBvZmMgc3RlbGxhciB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIGNvaW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIGNvaW4gc3VmZml4LiBEZWZhdWx0cyB0byBjb2luIG5hbWUuXG4gKiBAcGFyYW0gaXNUb2tlbj8gV2hldGhlciBvciBub3QgdGhpcyBhY2NvdW50IGNvaW4gaXMgYSB0b2tlbiBvZiBhbm90aGVyIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBPZmNDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mY1N0ZWxsYXJUb2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MubWFpbi5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICBhZGRyZXNzQ29pbiA9ICd4bG0nLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIGFkZHJlc3NDb2luLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LlhMTSxcbiAgICB9KVxuICApO1xufVxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IG9mYyBzdGVsbGFyIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9mY1N0ZWxsYXJUb2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MudGVzdC5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICBhZGRyZXNzQ29pbiA9ICd0eGxtJyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5YTE0sXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBvZmMgYWxnbyB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIGNvaW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIGNvaW4gc3VmZml4LiBEZWZhdWx0cyB0byBjb2luIG5hbWUuXG4gKiBAcGFyYW0gaXNUb2tlbj8gV2hldGhlciBvciBub3QgdGhpcyBhY2NvdW50IGNvaW4gaXMgYSB0b2tlbiBvZiBhbm90aGVyIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBPZmNDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mY0FsZ29Ub2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MubWFpbi5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICBhZGRyZXNzQ29pbiA9ICdhbGdvJyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5BTEdPLFxuICAgIH0pXG4gICk7XG59XG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgb2ZjIGFsZ28gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2ZjQWxnb1Rva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IE9mY05ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0Lm9mYyxcbiAgaXNUb2tlbiA9IHRydWUsXG4gIGFkZHJlc3NDb2luID0gJ3RhbGdvJyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5BTEdPLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3Igb2ZjIGhlZGVyYSB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIGNvaW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIGNvaW4gc3VmZml4LiBEZWZhdWx0cyB0byBjb2luIG5hbWUuXG4gKiBAcGFyYW0gaXNUb2tlbj8gV2hldGhlciBvciBub3QgdGhpcyBhY2NvdW50IGNvaW4gaXMgYSB0b2tlbiBvZiBhbm90aGVyIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBPZmNDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mY0hlZGVyYVRva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IE9mY05ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLm9mYyxcbiAgaXNUb2tlbiA9IHRydWUsXG4gIGFkZHJlc3NDb2luID0gJ2hiYXInLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIGFkZHJlc3NDb2luLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkhCQVIsXG4gICAgfSlcbiAgKTtcbn1cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBvZmMgaGVkZXJhIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9mY0hlZGVyYVRva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IE9mY05ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0Lm9mYyxcbiAgaXNUb2tlbiA9IHRydWUsXG4gIGFkZHJlc3NDb2luID0gJ3RoYmFyJyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5IQkFSLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3Igb2ZjIGFyYmV0aEVyYzIwIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gb2ZjQXJiZXRoRXJjMjAoXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUucmVwbGFjZSgvXm9mYy8sICcnKS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MubWFpbi5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICBhZGRyZXNzQ29pbiA9ICdhcmJldGgnLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIGFkZHJlc3NDb2luLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkVUSCxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgb2ZjIGFyYmV0aEVyYzIwIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9mY0FyYmV0aEVyYzIwKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLnRlc3Qub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW4gPSAndGFyYmV0aCcsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgYWRkcmVzc0NvaW4sXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuRVRILFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3Igb2ZjIGF2YXhFcmMyMCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIGNvaW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIGNvaW4gc3VmZml4LiBEZWZhdWx0cyB0byBjb2luIG5hbWUuXG4gKiBAcGFyYW0gaXNUb2tlbj8gV2hldGhlciBvciBub3QgdGhpcyBhY2NvdW50IGNvaW4gaXMgYSB0b2tlbiBvZiBhbm90aGVyIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBPZmNDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mY0F2YXhFcmMyMChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS5yZXBsYWNlKC9eb2ZjLywgJycpLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IE9mY05ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLm9mYyxcbiAgaXNUb2tlbiA9IHRydWUsXG4gIGFkZHJlc3NDb2luID0gJ2F2YXhjJyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5FVEgsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IG9mYyBhdmF4RXJjMjAgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2ZjQXZheEVyYzIwKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLnRlc3Qub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW4gPSAndGF2YXhjJyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5FVEgsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBvZmMgcG9seWdvbkVyYzIwIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gb2ZjUG9seWdvbkVyYzIwKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLm1haW4ub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW4gPSAncG9seWdvbicsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgYWRkcmVzc0NvaW4sXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuRVRILFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBvZmMgcG9seWdvbkVyYzIwIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9mY1BvbHlnb25FcmMyMChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS5yZXBsYWNlKC9eb2ZjLywgJycpLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IE9mY05ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0Lm9mYyxcbiAgaXNUb2tlbiA9IHRydWUsXG4gIGFkZHJlc3NDb2luID0gJ3Rwb2x5Z29uJyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5FVEgsXG4gICAgfSlcbiAgKTtcbn1cbiJdfQ==