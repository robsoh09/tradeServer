"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tsolToken = exports.solToken = exports.teosToken = exports.eosToken = exports.talgoToken = exports.algoToken = exports.hederaToken = exports.hederaCoin = exports.ttronToken = exports.tronToken = exports.tstellarToken = exports.stellarToken = exports.tbscToken = exports.bscToken = exports.tceloToken = exports.celoToken = exports.erc20CompatibleAccountCoin = exports.terc1155 = exports.erc1155 = exports.nonstandardToken = exports.terc721 = exports.erc721 = exports.terc20 = exports.erc20 = exports.account = exports.FiatCoin = exports.XrpCoin = exports.ZkethERC20Token = exports.OpethERC20Token = exports.ArbethERC20Token = exports.PolygonERC20Token = exports.AvaxERC20Token = exports.AdaCoin = exports.SolCoin = exports.EosCoin = exports.AlgoCoin = exports.HederaToken = exports.HederaCoin = exports.StellarCoin = exports.BscCoin = exports.CeloCoin = exports.Erc20CompatibleAccountCoin = exports.TronErc20Coin = exports.Erc1155Coin = exports.Erc721Coin = exports.Erc20Coin = exports.Base58ContractAddressDefinedToken = exports.ContractAddressDefinedToken = exports.AccountCoinToken = exports.AccountCoin = void 0;
exports.fiat = exports.txrpToken = exports.xrpToken = exports.tzkethErc20 = exports.zkethErc20 = exports.topethErc20 = exports.opethErc20 = exports.tarbethErc20 = exports.arbethErc20 = exports.tpolygonErc20 = exports.polygonErc20 = exports.tavaxErc20 = exports.avaxErc20 = exports.tadaToken = exports.adaToken = void 0;
const base_1 = require("./base");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const networks_1 = require("./networks");
/**
 * Account based coins, such as Ethereum, Stellar, or XRP.
 *
 * These types of coins maintain an "account balance" for each address on the network,
 * as opposed to the unspent transaction output model which maintains a record of all
 * "pieces" of coin which belong to an address.
 */
class AccountCoin extends base_1.BaseCoin {
    constructor(options) {
        super({
            ...options,
            kind: base_1.CoinKind.CRYPTO,
        });
        this.network = options.network;
    }
    requiredFeatures() {
        return new Set([base_1.CoinFeature.ACCOUNT_MODEL]);
    }
    disallowedFeatures() {
        return new Set([base_1.CoinFeature.UNSPENT_MODEL]);
    }
}
exports.AccountCoin = AccountCoin;
AccountCoin.DEFAULT_FEATURES = [
    base_1.CoinFeature.ACCOUNT_MODEL,
    base_1.CoinFeature.REQUIRES_BIG_NUMBER,
    base_1.CoinFeature.VALUELESS_TRANSFER,
    base_1.CoinFeature.TRANSACTION_DATA,
    base_1.CoinFeature.CUSTODY,
    base_1.CoinFeature.CUSTODY_BITGO_TRUST,
];
class AccountCoinToken extends AccountCoin {
    constructor(options) {
        super({
            ...options,
        });
    }
}
exports.AccountCoinToken = AccountCoinToken;
/**
 * Some blockchains support tokens which are defined by an address at which they have a smart contract deployed.
 * Examples are ERC20 tokens, and the equivalent on other chains.
 */
class ContractAddressDefinedToken extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        // valid ERC 20 contract addresses are "0x" followed by 40 lowercase hex characters
        // do not use a valid address format for generic tokens because they not have onchain addresses
        if (!options.contractAddress.match(/^0x[a-f0-9]{40}$/) && !options.features.includes(base_1.CoinFeature.GENERIC_TOKEN)) {
            throw new errors_1.InvalidContractAddressError(options.name, options.contractAddress);
        }
        this.contractAddress = options.contractAddress;
    }
}
exports.ContractAddressDefinedToken = ContractAddressDefinedToken;
/**
 * ERC20 token addresses are Base58 formatted on some blockchains.
 */
class Base58ContractAddressDefinedToken extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        if (!/^[1-9A-HJ-NP-Za-km-z]{34}$/.test(options.contractAddress)) {
            throw new errors_1.InvalidContractAddressError(options.name, options.contractAddress);
        }
        this.contractAddress = options.contractAddress;
    }
}
exports.Base58ContractAddressDefinedToken = Base58ContractAddressDefinedToken;
/**
 * ERC 20 is a token standard for the Ethereum blockchain. They are similar to other account coins, but have a
 * contract address property which identifies the smart contract which defines the token.
 */
class Erc20Coin extends ContractAddressDefinedToken {
}
exports.Erc20Coin = Erc20Coin;
/**
 * ERC 721 is the non fungible token standard for the Ethereum blockchain.
 *
 * {@link https://eips.ethereum.org/EIPS/eip-721 EIP721}
 */
class Erc721Coin extends ContractAddressDefinedToken {
}
exports.Erc721Coin = Erc721Coin;
/**
 * ERC 1155 is the multi token standard for the Ethereum blockchain.
 *
 * {@link https://eips.ethereum.org/EIPS/eip-1155 EIP1155}
 */
class Erc1155Coin extends ContractAddressDefinedToken {
}
exports.Erc1155Coin = Erc1155Coin;
/**
 * The TRON blockchain supports tokens of the ERC20 standard similar to ETH ERC20 tokens.
 */
class TronErc20Coin extends Base58ContractAddressDefinedToken {
}
exports.TronErc20Coin = TronErc20Coin;
/**
 * Some blockchains have native coins which also support the ERC20 interface such as CELO.
 */
class Erc20CompatibleAccountCoin extends ContractAddressDefinedToken {
    constructor(options) {
        super({
            ...options,
            // These coins should not be classified as tokens as they are not children of other coins
            isToken: false,
        });
    }
}
exports.Erc20CompatibleAccountCoin = Erc20CompatibleAccountCoin;
/**
 * The CELO blockchain supports tokens of the ERC20 standard similar to ETH ERC20 tokens.
 */
class CeloCoin extends ContractAddressDefinedToken {
}
exports.CeloCoin = CeloCoin;
/**
 * The BSC blockchain supports tokens of the ERC20 standard similar to ETH ERC20 tokens.
 */
class BscCoin extends ContractAddressDefinedToken {
}
exports.BscCoin = BscCoin;
/**
 * The Stellar network supports tokens (non-native assets)
 * XLM is also known as the native asset.
 * Stellar tokens work similar to XLM, but the token name is determined by the chain,
 * the token code and the issuer account in the form: (t)xlm:<token>-<issuer>
 */
class StellarCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        if (options.domain !== '' && !options.domain.match(constants_1.DOMAIN_PATTERN)) {
            throw new errors_1.InvalidDomainError(options.name, options.domain);
        }
        this.domain = options.domain;
    }
}
exports.StellarCoin = StellarCoin;
/**
 * The Hedera coin needs a client set with the node account Id.
 * It's an account based coin that needs the node account ID
 * where the transaction will be sent.
 *
 */
class HederaCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        this.nodeAccountId = options.nodeAccountId;
    }
}
exports.HederaCoin = HederaCoin;
/**
 * The Hedera network supports tokens.
 * Hedera tokens work similar to native Hedera coin,
 * but the token is determined by the tokenId on the node
 *
 */
class HederaToken extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        this.nodeAccountId = options.nodeAccountId;
        this.tokenId = options.tokenId;
    }
}
exports.HederaToken = HederaToken;
/**
 * The Algo network supports tokens (assets)
 * Algo tokens work similar to native ALGO coin, but the token name is determined by
 * unique asset id on the chain. Internally, BitGo uses token identifiers of the format: (t)algo:<assetId>
 *
 */
class AlgoCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        if (options.tokenURL) {
            try {
                new URL(options.tokenURL);
            }
            catch (ex) {
                throw new errors_1.InvalidDomainError(options.name, options.tokenURL);
            }
        }
        this.tokenURL = options.tokenURL;
    }
}
exports.AlgoCoin = AlgoCoin;
/**
 * The Eos network supports tokens
 * Eos tokens work similar to native Eos coin, but the token name is determined by
 * the contractName on the chain.
 *
 */
class EosCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        this.contractName = options.contractName;
    }
}
exports.EosCoin = EosCoin;
/**
 * The Sol network supports tokens
 * Sol tokens work similar to native SOL coin, but the token name is determined by
 * the tokenAddress on the chain.
 *
 */
class SolCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        this.tokenAddress = options.tokenAddress;
    }
}
exports.SolCoin = SolCoin;
/**
 * The Ada network supports tokens
 * Ada tokens are identified by their policy ID and asset name
 *
 */
class AdaCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        this.policyId = options.policyId;
        this.assetName = options.assetName;
    }
}
exports.AdaCoin = AdaCoin;
/**
 * The AVAX C Chain network support tokens
 * AVAX C Chain Tokens are ERC20 coins
 */
class AvaxERC20Token extends ContractAddressDefinedToken {
    constructor(options) {
        super(options);
    }
}
exports.AvaxERC20Token = AvaxERC20Token;
/**
 * The Polygon Chain network support tokens
 * Polygon Chain Tokens are ERC20 coins
 */
class PolygonERC20Token extends ContractAddressDefinedToken {
    constructor(options) {
        super(options);
    }
}
exports.PolygonERC20Token = PolygonERC20Token;
/**
 * The Arbitrum Chain network support tokens
 * Arbitrum Chain Tokens are ERC20 tokens
 */
class ArbethERC20Token extends ContractAddressDefinedToken {
    constructor(options) {
        super(options);
    }
}
exports.ArbethERC20Token = ArbethERC20Token;
/**
 * The Optimism Chain network support tokens
 * Optimism Chain Tokens are ERC20 tokens
 */
class OpethERC20Token extends ContractAddressDefinedToken {
    constructor(options) {
        super(options);
    }
}
exports.OpethERC20Token = OpethERC20Token;
/**
 * The zkSync network support tokens
 * zkSync Tokens are ERC20 tokens
 */
class ZkethERC20Token extends ContractAddressDefinedToken {
    constructor(options) {
        super(options);
    }
}
exports.ZkethERC20Token = ZkethERC20Token;
/**
 * The Xrp network supports tokens
 * Xrp tokens are identified by their issuer address
 * Naming format is similar to XLM
 * <network>:<token>-<issuer>
 */
class XrpCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        if (options.domain !== '' && !options.domain.match(constants_1.DOMAIN_PATTERN)) {
            throw new errors_1.InvalidDomainError(options.name, options.domain);
        }
        this.domain = options.domain;
        this.currencyCode = options.currencyCode;
        this.issuerAddress = options.issuerAddress;
    }
}
exports.XrpCoin = XrpCoin;
/**
 * Fiat currencies, such as USD, EUR, or YEN.
 */
class FiatCoin extends base_1.BaseCoin {
    constructor(options) {
        super({ ...options, kind: base_1.CoinKind.FIAT });
        this.network = options.network;
    }
    requiredFeatures() {
        return new Set([base_1.CoinFeature.ACCOUNT_MODEL]);
    }
    disallowedFeatures() {
        return new Set([base_1.CoinFeature.UNSPENT_MODEL]);
    }
}
exports.FiatCoin = FiatCoin;
FiatCoin.DEFAULT_FEATURES = [...AccountCoin.DEFAULT_FEATURES];
/**
 * Factory function for account coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve? The elliptic curve for this chain/token
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 */
function account(id, name, fullName, network, decimalPlaces, asset, baseUnit, features = AccountCoin.DEFAULT_FEATURES, primaryKeyCurve = base_1.KeyCurve.Secp256k1, prefix = '', suffix = name.toUpperCase(), isToken = false) {
    return Object.freeze(new AccountCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        baseUnit,
        features,
        decimalPlaces,
        isToken,
        asset,
        primaryKeyCurve,
    }));
}
exports.account = account;
/**
 * Factory function for erc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Ethereum main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function erc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ethereum, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new Erc20Coin({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.erc20 = erc20;
/**
 * Factory function for testnet erc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the Kovan test network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function terc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.kovan) {
    return erc20(id, name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network);
}
exports.terc20 = terc20;
/**
 * Factory function for erc721 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param contractAddress Contract address of this token
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Ethereum main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function erc721(id, name, fullName, contractAddress, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ethereum, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new Erc721Coin({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces: 0,
        asset: base_1.UnderlyingAsset.ERC721,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.erc721 = erc721;
/**
 * Factory function for testnet erc721 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param contractAddress Contract address of this token
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Holesky test network.
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function terc721(id, name, fullName, contractAddress, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.holesky, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return erc721(id, name, fullName, contractAddress, features, prefix, suffix, network, primaryKeyCurve);
}
exports.terc721 = terc721;
/**
 * Factory function for nonstandard token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param contractAddress Contract address of this token
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Ethereum main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function nonstandardToken(id, name, fullName, contractAddress, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ethereum, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new ContractAddressDefinedToken({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces: 0,
        asset: base_1.UnderlyingAsset.NONSTANDARD,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.nonstandardToken = nonstandardToken;
/**
 * Factory function for erc1155 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param contractAddress Contract address of this token
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Ethereum main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function erc1155(id, name, fullName, contractAddress, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ethereum, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new Erc1155Coin({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces: 0,
        asset: base_1.UnderlyingAsset.ERC1155,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.erc1155 = erc1155;
/**
 * Factory function for testnet erc1155 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param contractAddress Contract address of this token
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Holesky test network.
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function terc1155(id, name, fullName, contractAddress, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.holesky, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return erc1155(id, name, fullName, contractAddress, features, prefix, suffix, network, primaryKeyCurve);
}
exports.terc1155 = terc1155;
/**
 * Factory function for ERC20-compatible account coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function erc20CompatibleAccountCoin(id, name, fullName, network, decimalPlaces, contractAddress, asset, baseUnit, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new Erc20CompatibleAccountCoin({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: false,
        primaryKeyCurve,
        baseUnit,
    }));
}
exports.erc20CompatibleAccountCoin = erc20CompatibleAccountCoin;
/**
 * Factory function for celo token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to CELO main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function celoToken(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.celo, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new CeloCoin({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.celoToken = celoToken;
/**
 * Factory function for testnet celo token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet CELO network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function tceloToken(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.celo) {
    return celoToken(id, name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network);
}
exports.tceloToken = tceloToken;
/**
 * Factory function for celo token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to BSC main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function bscToken(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.bsc, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new BscCoin({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.BSC,
    }));
}
exports.bscToken = bscToken;
/**
 * Factory function for testnet bsc token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet BSC network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function tbscToken(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.bsc) {
    return bscToken(id, name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network);
}
exports.tbscToken = tbscToken;
/**
 * Factory function for Stellar token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param domain Domain of the token issuer (used to access token information from the issuer's stellar.toml file)
 * See https://www.stellar.org/developers/guides/concepts/stellar-toml.html
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Stellar mainnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function stellarToken(id, name, fullName, decimalPlaces, asset, domain = '', features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.stellar, primaryKeyCurve = base_1.KeyCurve.Ed25519) {
    return Object.freeze(new StellarCoin({
        id,
        name,
        fullName,
        decimalPlaces,
        asset,
        domain,
        features,
        prefix,
        suffix,
        network,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.XLM,
    }));
}
exports.stellarToken = stellarToken;
/**
 * Factory function for testnet Stellar token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param domain Domain of the token issuer (used to access token information from the issuer's stellar.toml file)
 * See https://www.stellar.org/developers/guides/concepts/stellar-toml.html
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Stellar testnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function tstellarToken(id, name, fullName, decimalPlaces, asset, domain = '', features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.stellar) {
    return stellarToken(id, name, fullName, decimalPlaces, asset, domain, features, prefix, suffix, network);
}
exports.tstellarToken = tstellarToken;
/**
 * Factory function for tron token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to TRON main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tronToken(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.trx, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new TronErc20Coin({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.TRX,
    }));
}
exports.tronToken = tronToken;
/**
 * Factory function for testnet tron token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet TRON network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ttronToken(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.trx, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return tronToken(id, name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network, primaryKeyCurve);
}
exports.ttronToken = ttronToken;
/**
 * Factory function for Hedera coin instances
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param nodeAccountId node account Id from which the transaction will be sent
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Hedera mainnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function hederaCoin(id, name, fullName, network, decimalPlaces, asset, nodeAccountId = '0.0.3', features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), primaryKeyCurve = base_1.KeyCurve.Ed25519) {
    return Object.freeze(new HederaCoin({
        id,
        name,
        fullName,
        decimalPlaces,
        asset,
        nodeAccountId,
        features,
        prefix,
        suffix,
        network,
        isToken: false,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.HBAR,
    }));
}
exports.hederaCoin = hederaCoin;
/**
 * Factory function for Hedera token instances
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param nodeAccountId node account Id from which the transaction will be sent
 * @param tokenId The unique identifier of this token
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Hedera mainnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function hederaToken(id, name, fullName, network, decimalPlaces, asset, nodeAccountId = '0.0.3', tokenId, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), primaryKeyCurve = base_1.KeyCurve.Ed25519) {
    return Object.freeze(new HederaToken({
        id,
        name,
        fullName,
        decimalPlaces,
        asset,
        nodeAccountId,
        tokenId,
        features,
        prefix,
        suffix,
        network,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.HBAR,
    }));
}
exports.hederaToken = hederaToken;
/**
 * Factory function for ALGO token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token

 * @param alias (optional) alternative identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param tokenURL Optional asset Url for more informationa about the asset
 * See https://developer.algorand.org/docs/reference/transactions/#url
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to ALGO mainnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function algoToken(id, name, alias, fullName, decimalPlaces, asset, tokenURL = '', features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.algorand, primaryKeyCurve = base_1.KeyCurve.Ed25519) {
    return Object.freeze(new AlgoCoin({
        id,
        name,
        alias,
        fullName,
        decimalPlaces,
        asset,
        tokenURL: tokenURL,
        features,
        prefix,
        suffix,
        network,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ALGO,
    }));
}
exports.algoToken = algoToken;
/**
 * Factory function for testnet ALGO token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param alias (optional) alternative identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param tokenURL Optional asset Url for more informationa about the asset
 * See https://developer.algorand.org/docs/reference/transactions/#url
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Algo testnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function talgoToken(id, name, alias, fullName, decimalPlaces, asset, tokenURL = '', features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.algorand) {
    return algoToken(id, name, alias, fullName, decimalPlaces, asset, tokenURL, features, prefix, suffix, network);
}
exports.talgoToken = talgoToken;
/**
 * Factory function for eos token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractName Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to EOS main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function eosToken(id, name, fullName, decimalPlaces, contractName, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.eos, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new EosCoin({
        id,
        name,
        fullName,
        network,
        contractName,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.EOS,
    }));
}
exports.eosToken = eosToken;
/**
 * Factory function for testnet eos token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet EOS network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function teosToken(id, name, fullName, decimalPlaces, contractName, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.eos) {
    return eosToken(id, name, fullName, decimalPlaces, contractName, asset, features, prefix, suffix, network);
}
exports.teosToken = teosToken;
/**
 * Factory function for sol token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param tokenAddress Token address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to SOL main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES and REQUIRES_RESERVE defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function solToken(id, name, fullName, decimalPlaces, tokenAddress, asset, features = [...AccountCoin.DEFAULT_FEATURES, base_1.CoinFeature.REQUIRES_RESERVE], prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.sol, primaryKeyCurve = base_1.KeyCurve.Ed25519) {
    return Object.freeze(new SolCoin({
        id,
        name,
        fullName,
        network,
        tokenAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.SOL,
    }));
}
exports.solToken = solToken;
/**
 * Factory function for testnet solana token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param tokenAddress Token address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet Solana network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES and REQUIRES_RESERVE defined in `AccountCoin`
 */
function tsolToken(id, name, fullName, decimalPlaces, tokenAddress, asset, features = [...AccountCoin.DEFAULT_FEATURES, base_1.CoinFeature.REQUIRES_RESERVE], prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.sol) {
    return solToken(id, name, fullName, decimalPlaces, tokenAddress, asset, features, prefix, suffix, network);
}
exports.tsolToken = tsolToken;
/**
 * Factory function for ada token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param tokenSymbol Token symbol of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Cardano main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES and REQUIRES_RESERVE defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function adaToken(id, name, fullName, decimalPlaces, policyId, assetName, asset, features = [...AccountCoin.DEFAULT_FEATURES, base_1.CoinFeature.REQUIRES_RESERVE], prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ada, primaryKeyCurve = base_1.KeyCurve.Ed25519) {
    return Object.freeze(new AdaCoin({
        id,
        name,
        fullName,
        network,
        policyId,
        assetName,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ADA,
    }));
}
exports.adaToken = adaToken;
/**
 * Factory function for testnet cardano token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param tokenSymbol Token symbol of this token i.e: AUSD
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet Cardano network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES and REQUIRES_RESERVE defined in `AccountCoin`
 */
function tadaToken(id, name, fullName, decimalPlaces, policyId, assetName, asset, features = [...AccountCoin.DEFAULT_FEATURES, base_1.CoinFeature.REQUIRES_RESERVE], prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.ada) {
    return adaToken(id, name, fullName, decimalPlaces, policyId, assetName, asset, features, prefix, suffix, network);
}
exports.tadaToken = tadaToken;
/**
 * Factory function for avaxErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to AvalancheC main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function avaxErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.avalancheC, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new AvaxERC20Token({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.avaxErc20 = avaxErc20;
/**
 * Factory function for testnet avaxErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the AvalancheC test network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tavaxErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.avalancheC, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return avaxErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network, primaryKeyCurve);
}
exports.tavaxErc20 = tavaxErc20;
/**
 * Factory function for polygonErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Polygon main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function polygonErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.polygon, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new PolygonERC20Token({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.polygonErc20 = polygonErc20;
/**
 * Factory function for Amoy testnet polygonErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the Polygon test network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tpolygonErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.polygon, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return polygonErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network, primaryKeyCurve);
}
exports.tpolygonErc20 = tpolygonErc20;
/**
 * Factory function for arbethErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Arbitrum main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function arbethErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.arbitrum, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new ArbethERC20Token({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.arbethErc20 = arbethErc20;
/**
 * Factory function for Arbitrum Sepolia testnet arbethErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the Arbitrum test network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tarbethErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.arbitrum, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return arbethErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network, primaryKeyCurve);
}
exports.tarbethErc20 = tarbethErc20;
/**
 * Factory function for opethErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Optimism main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function opethErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.optimism, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OpethERC20Token({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.opethErc20 = opethErc20;
/**
 * Factory function for Optimism Sepolia testnet opethErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the Optimism test network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function topethErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.optimism, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return opethErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network, primaryKeyCurve);
}
exports.topethErc20 = topethErc20;
/**
 * Factory function for zkethErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to zkSync mainnet network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function zkethErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.zkSync, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new ZkethERC20Token({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.zkethErc20 = zkethErc20;
/**
 * Factory function for zkSync Sepolia testnet zkethErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the zkSync sepolia test network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tzkethErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.zkSync, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return zkethErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network, primaryKeyCurve);
}
exports.tzkethErc20 = tzkethErc20;
/**
 * Factory function for xrp token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param issuerAddress: The address of the issuer of the token,
 * @param currencyCode The token symbol. Example: USD, BTC, ETH, etc.
 * @param domain? the domain of the issuer of the token,
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Cardano main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function xrpToken(id, name, fullName, decimalPlaces, issuerAddress, currencyCode, domain = '', asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.xrp, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new XrpCoin({
        id,
        name,
        fullName,
        network,
        issuerAddress,
        currencyCode,
        domain,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.XRP,
    }));
}
exports.xrpToken = xrpToken;
/**
 * Factory function for testnet cardano token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param issuerAddress: The address of the issuer of the token,
 * @param currencyCode The token symbol. Example: USD, BTC, ETH, etc.
 * @param domain? the domain of the issuer of the token,
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet Cardano network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function txrpToken(id, name, fullName, decimalPlaces, issuerAddress, currencyCode, domain = '', asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.xrp) {
    return xrpToken(id, name, fullName, decimalPlaces, issuerAddress, currencyCode, domain, asset, features, prefix, suffix, network);
}
exports.txrpToken = txrpToken;
/**
 * Factory function for fiat coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin, should start with 'fiat' or 'tfiat' followed by the 3-char ISO-4217 alphabetical code
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `FiatCoin`
 * @param primaryKeyCurve? The elliptic curve for this chain/token
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this coin is a token of another coin
 */
function fiat(id, name, fullName, network, decimalPlaces, asset, features = FiatCoin.DEFAULT_FEATURES, primaryKeyCurve = base_1.KeyCurve.Secp256k1, prefix = '', suffix = name.toUpperCase(), isToken = false) {
    return Object.freeze(new FiatCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.FIAT,
    }));
}
exports.fiat = fiat;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3VudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hY2NvdW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpQ0FBOEY7QUFDOUYsMkNBQTZDO0FBQzdDLHFDQUEyRTtBQUMzRSx5Q0FBaUc7QUFrQmpHOzs7Ozs7R0FNRztBQUNILE1BQWEsV0FBWSxTQUFRLGVBQVE7SUFZdkMsWUFBWSxPQUFrQztRQUM1QyxLQUFLLENBQUM7WUFDSixHQUFHLE9BQU87WUFDVixJQUFJLEVBQUUsZUFBUSxDQUFDLE1BQU07U0FDdEIsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ2pDLENBQUM7SUFFUyxnQkFBZ0I7UUFDeEIsT0FBTyxJQUFJLEdBQUcsQ0FBYyxDQUFDLGtCQUFXLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRVMsa0JBQWtCO1FBQzFCLE9BQU8sSUFBSSxHQUFHLENBQWMsQ0FBQyxrQkFBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7SUFDM0QsQ0FBQzs7QUEzQkgsa0NBNEJDO0FBM0J3Qiw0QkFBZ0IsR0FBRztJQUN4QyxrQkFBVyxDQUFDLGFBQWE7SUFDekIsa0JBQVcsQ0FBQyxtQkFBbUI7SUFDL0Isa0JBQVcsQ0FBQyxrQkFBa0I7SUFDOUIsa0JBQVcsQ0FBQyxnQkFBZ0I7SUFDNUIsa0JBQVcsQ0FBQyxPQUFPO0lBQ25CLGtCQUFXLENBQUMsbUJBQW1CO0NBQ2hDLENBQUM7QUF1RUosTUFBYSxnQkFBaUIsU0FBUSxXQUFXO0lBQy9DLFlBQVksT0FBa0M7UUFDNUMsS0FBSyxDQUFDO1lBQ0osR0FBRyxPQUFPO1NBQ1gsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBTkQsNENBTUM7QUFFRDs7O0dBR0c7QUFDSCxNQUFhLDJCQUE0QixTQUFRLGdCQUFnQjtJQUcvRCxZQUFZLE9BQWdDO1FBQzFDLEtBQUssQ0FBQztZ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QzlDLE1BQU0sR0FBRyxFQUFFLEVBQ1gsU0FBaUIsSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUNuQyxPQUFPLEdBQUcsS0FBSztJQUVmLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FDbEIsSUFBSSxRQUFRLENBQUM7UUFDWCxFQUFFO1FBQ0YsSUFBSTtRQUNKLFFBQVE7UUFDUixPQUFPO1FBQ1AsTUFBTTtRQUNOLE1BQU07UUFDTixRQUFRO1FBQ1IsYUFBYTtRQUNiLE9BQU87UUFDUCxLQUFLO1FBQ0wsZUFBZTtRQUNmLFFBQVEsRUFBRSxlQUFRLENBQUMsSUFBSTtLQUN4QixDQUFDLENBQ0gsQ0FBQztBQUNKLENBQUM7QUE3QkQsb0JBNkJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNvaW4sIEJhc2VVbml0LCBDb2luRmVhdHVyZSwgQ29pbktpbmQsIEtleUN1cnZlLCBVbmRlcmx5aW5nQXNzZXQgfSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgRE9NQUlOX1BBVFRFUk4gfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBJbnZhbGlkQ29udHJhY3RBZGRyZXNzRXJyb3IsIEludmFsaWREb21haW5FcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IEFjY291bnROZXR3b3JrLCBCYXNlTmV0d29yaywgRXRoZXJldW1OZXR3b3JrLCBOZXR3b3JrcywgVHJvbk5ldHdvcmsgfSBmcm9tICcuL25ldHdvcmtzJztcblxuZXhwb3J0IGludGVyZmFjZSBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zIHtcbiAgaWQ6IHN0cmluZztcbiAgZnVsbE5hbWU6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBhbGlhcz86IHN0cmluZztcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcms7XG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQ7XG4gIGJhc2VVbml0OiBCYXNlVW5pdDtcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW107XG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcjtcbiAgaXNUb2tlbjogYm9vbGVhbjtcbiAgcHJlZml4Pzogc3RyaW5nO1xuICBzdWZmaXg/OiBzdHJpbmc7XG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmU7XG59XG5cbi8qKlxuICogQWNjb3VudCBiYXNlZCBjb2lucywgc3VjaCBhcyBFdGhlcmV1bSwgU3RlbGxhciwgb3IgWFJQLlxuICpcbiAqIFRoZXNlIHR5cGVzIG9mIGNvaW5zIG1haW50YWluIGFuIFwiYWNjb3VudCBiYWxhbmNlXCIgZm9yIGVhY2ggYWRkcmVzcyBvbiB0aGUgbmV0d29yayxcbiAqIGFzIG9wcG9zZWQgdG8gdGhlIHVuc3BlbnQgdHJhbnNhY3Rpb24gb3V0cHV0IG1vZGVsIHdoaWNoIG1haW50YWlucyBhIHJlY29yZCBvZiBhbGxcbiAqIFwicGllY2VzXCIgb2YgY29pbiB3aGljaCBiZWxvbmcgdG8gYW4gYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFjY291bnRDb2luIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfRkVBVFVSRVMgPSBbXG4gICAgQ29pbkZlYXR1cmUuQUNDT1VOVF9NT0RFTCxcbiAgICBDb2luRmVhdHVyZS5SRVFVSVJFU19CSUdfTlVNQkVSLFxuICAgIENvaW5GZWF0dXJlLlZBTFVFTEVTU19UUkFOU0ZFUixcbiAgICBDb2luRmVhdHVyZS5UUkFOU0FDVElPTl9EQVRBLFxuICAgIENvaW5GZWF0dXJlLkNVU1RPRFksXG4gICAgQ29pbkZlYXR1cmUuQ1VTVE9EWV9CSVRHT19UUlVTVCxcbiAgXTtcblxuICBwdWJsaWMgcmVhZG9ubHkgbmV0d29yazogQWNjb3VudE5ldHdvcms7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogQWNjb3VudENvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBraW5kOiBDb2luS2luZC5DUllQVE8sXG4gICAgfSk7XG5cbiAgICB0aGlzLm5ldHdvcmsgPSBvcHRpb25zLm5ldHdvcms7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVxdWlyZWRGZWF0dXJlcygpOiBTZXQ8Q29pbkZlYXR1cmU+IHtcbiAgICByZXR1cm4gbmV3IFNldDxDb2luRmVhdHVyZT4oW0NvaW5GZWF0dXJlLkFDQ09VTlRfTU9ERUxdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBkaXNhbGxvd2VkRmVhdHVyZXMoKTogU2V0PENvaW5GZWF0dXJlPiB7XG4gICAgcmV0dXJuIG5ldyBTZXQ8Q29pbkZlYXR1cmU+KFtDb2luRmVhdHVyZS5VTlNQRU5UX01PREVMXSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFcmMyMENvbnN0cnVjdG9yT3B0aW9ucyBleHRlbmRzIEFjY291bnRDb25zdHJ1Y3Rvck9wdGlvbnMge1xuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGVsbGFyQ29pbkNvbnN0cnVjdG9yT3B0aW9ucyBleHRlbmRzIEFjY291bnRDb25zdHJ1Y3Rvck9wdGlvbnMge1xuICBkb21haW46IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIZWRlcmFDb2luQ29uc3RydWN0b3JPcHRpb25zIGV4dGVuZHMgQWNjb3VudENvbnN0cnVjdG9yT3B0aW9ucyB7XG4gIG5vZGVBY2NvdW50SWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIZWRlcmFUb2tlbkNvbnN0cnVjdG9yT3B0aW9ucyBleHRlbmRzIEFjY291bnRDb25zdHJ1Y3Rvck9wdGlvbnMge1xuICBub2RlQWNjb3VudElkOiBzdHJpbmc7XG4gIHRva2VuSWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBbGdvQ29pbkNvbnN0cnVjdG9yT3B0aW9ucyBleHRlbmRzIEFjY291bnRDb25zdHJ1Y3Rvck9wdGlvbnMge1xuICB0b2tlblVSTDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVvc0NvaW5Db25zdHJ1Y3Rvck9wdGlvbnMgZXh0ZW5kcyBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zIHtcbiAgY29udHJhY3ROYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU29sQ29pbkNvbnN0cnVjdG9yT3B0aW9ucyBleHRlbmRzIEFjY291bnRDb25zdHJ1Y3Rvck9wdGlvbnMge1xuICB0b2tlbkFkZHJlc3M6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBZGFDb2luQ29uc3RydWN0b3JPcHRpb25zIGV4dGVuZHMgQWNjb3VudENvbnN0cnVjdG9yT3B0aW9ucyB7XG4gIHBvbGljeUlkOiBzdHJpbmc7XG4gIGFzc2V0TmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFhycENvaW5Db25zdHJ1Y3Rvck9wdGlvbnMgZXh0ZW5kcyBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zIHtcbiAgaXNzdWVyQWRkcmVzczogc3RyaW5nO1xuICBjdXJyZW5jeUNvZGU6IHN0cmluZztcbiAgZG9tYWluOiBzdHJpbmc7XG59XG5cbnR5cGUgRmlhdENvaW5OYW1lID0gYGZpYXQke3N0cmluZ31gIHwgYHRmaWF0JHtzdHJpbmd9YDtcbmV4cG9ydCBpbnRlcmZhY2UgRmlhdENvaW5Db25zdHJ1Y3Rvck9wdGlvbnMgZXh0ZW5kcyBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zIHtcbiAgbmFtZTogRmlhdENvaW5OYW1lO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRyYWN0QWRkcmVzcyBleHRlbmRzIFN0cmluZyB7XG4gIF9fY29udHJhY3RhZGRyZXNzX3BoYW50b21fXzogbmV2ZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBBY2NvdW50Q29pblRva2VuIGV4dGVuZHMgQWNjb3VudENvaW4ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFNvbWUgYmxvY2tjaGFpbnMgc3VwcG9ydCB0b2tlbnMgd2hpY2ggYXJlIGRlZmluZWQgYnkgYW4gYWRkcmVzcyBhdCB3aGljaCB0aGV5IGhhdmUgYSBzbWFydCBjb250cmFjdCBkZXBsb3llZC5cbiAqIEV4YW1wbGVzIGFyZSBFUkMyMCB0b2tlbnMsIGFuZCB0aGUgZXF1aXZhbGVudCBvbiBvdGhlciBjaGFpbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4gZXh0ZW5kcyBBY2NvdW50Q29pblRva2VuIHtcbiAgcHVibGljIGNvbnRyYWN0QWRkcmVzczogQ29udHJhY3RBZGRyZXNzO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEVyYzIwQ29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIC8vIHZhbGlkIEVSQyAyMCBjb250cmFjdCBhZGRyZXNzZXMgYXJlIFwiMHhcIiBmb2xsb3dlZCBieSA0MCBsb3dlcmNhc2UgaGV4IGNoYXJhY3RlcnNcbiAgICAvLyBkbyBub3QgdXNlIGEgdmFsaWQgYWRkcmVzcyBmb3JtYXQgZm9yIGdlbmVyaWMgdG9rZW5zIGJlY2F1c2UgdGhleSBub3QgaGF2ZSBvbmNoYWluIGFkZHJlc3Nlc1xuICAgIGlmICghb3B0aW9ucy5jb250cmFjdEFkZHJlc3MubWF0Y2goL14weFthLWYwLTldezQwfSQvKSAmJiAhb3B0aW9ucy5mZWF0dXJlcy5pbmNsdWRlcyhDb2luRmVhdHVyZS5HRU5FUklDX1RPS0VOKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRDb250cmFjdEFkZHJlc3NFcnJvcihvcHRpb25zLm5hbWUsIG9wdGlvbnMuY29udHJhY3RBZGRyZXNzKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyYWN0QWRkcmVzcyA9IG9wdGlvbnMuY29udHJhY3RBZGRyZXNzIGFzIHVua25vd24gYXMgQ29udHJhY3RBZGRyZXNzO1xuICB9XG59XG5cbi8qKlxuICogRVJDMjAgdG9rZW4gYWRkcmVzc2VzIGFyZSBCYXNlNTggZm9ybWF0dGVkIG9uIHNvbWUgYmxvY2tjaGFpbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlNThDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4gZXh0ZW5kcyBBY2NvdW50Q29pblRva2VuIHtcbiAgcHVibGljIGNvbnRyYWN0QWRkcmVzczogQ29udHJhY3RBZGRyZXNzO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEVyYzIwQ29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIGlmICghL15bMS05QS1ISi1OUC1aYS1rbS16XXszNH0kLy50ZXN0KG9wdGlvbnMuY29udHJhY3RBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRDb250cmFjdEFkZHJlc3NFcnJvcihvcHRpb25zLm5hbWUsIG9wdGlvbnMuY29udHJhY3RBZGRyZXNzKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyYWN0QWRkcmVzcyA9IG9wdGlvbnMuY29udHJhY3RBZGRyZXNzIGFzIHVua25vd24gYXMgQ29udHJhY3RBZGRyZXNzO1xuICB9XG59XG5cbi8qKlxuICogRVJDIDIwIGlzIGEgdG9rZW4gc3RhbmRhcmQgZm9yIHRoZSBFdGhlcmV1bSBibG9ja2NoYWluLiBUaGV5IGFyZSBzaW1pbGFyIHRvIG90aGVyIGFjY291bnQgY29pbnMsIGJ1dCBoYXZlIGFcbiAqIGNvbnRyYWN0IGFkZHJlc3MgcHJvcGVydHkgd2hpY2ggaWRlbnRpZmllcyB0aGUgc21hcnQgY29udHJhY3Qgd2hpY2ggZGVmaW5lcyB0aGUgdG9rZW4uXG4gKi9cbmV4cG9ydCBjbGFzcyBFcmMyMENvaW4gZXh0ZW5kcyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4ge31cblxuLyoqXG4gKiBFUkMgNzIxIGlzIHRoZSBub24gZnVuZ2libGUgdG9rZW4gc3RhbmRhcmQgZm9yIHRoZSBFdGhlcmV1bSBibG9ja2NoYWluLlxuICpcbiAqIHtAbGluayBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTcyMSBFSVA3MjF9XG4gKi9cbmV4cG9ydCBjbGFzcyBFcmM3MjFDb2luIGV4dGVuZHMgQ29udHJhY3RBZGRyZXNzRGVmaW5lZFRva2VuIHt9XG5cbi8qKlxuICogRVJDIDExNTUgaXMgdGhlIG11bHRpIHRva2VuIHN0YW5kYXJkIGZvciB0aGUgRXRoZXJldW0gYmxvY2tjaGFpbi5cbiAqXG4gKiB7QGxpbmsgaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTU1IEVJUDExNTV9XG4gKi9cbmV4cG9ydCBjbGFzcyBFcmMxMTU1Q29pbiBleHRlbmRzIENvbnRyYWN0QWRkcmVzc0RlZmluZWRUb2tlbiB7fVxuXG4vKipcbiAqIFRoZSBUUk9OIGJsb2NrY2hhaW4gc3VwcG9ydHMgdG9rZW5zIG9mIHRoZSBFUkMyMCBzdGFuZGFyZCBzaW1pbGFyIHRvIEVUSCBFUkMyMCB0b2tlbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcm9uRXJjMjBDb2luIGV4dGVuZHMgQmFzZTU4Q29udHJhY3RBZGRyZXNzRGVmaW5lZFRva2VuIHt9XG5cbi8qKlxuICogU29tZSBibG9ja2NoYWlucyBoYXZlIG5hdGl2ZSBjb2lucyB3aGljaCBhbHNvIHN1cHBvcnQgdGhlIEVSQzIwIGludGVyZmFjZSBzdWNoIGFzIENFTE8uXG4gKi9cbmV4cG9ydCBjbGFzcyBFcmMyMENvbXBhdGlibGVBY2NvdW50Q29pbiBleHRlbmRzIENvbnRyYWN0QWRkcmVzc0RlZmluZWRUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEVyYzIwQ29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIC8vIFRoZXNlIGNvaW5zIHNob3VsZCBub3QgYmUgY2xhc3NpZmllZCBhcyB0b2tlbnMgYXMgdGhleSBhcmUgbm90IGNoaWxkcmVuIG9mIG90aGVyIGNvaW5zXG4gICAgICBpc1Rva2VuOiBmYWxzZSxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBDRUxPIGJsb2NrY2hhaW4gc3VwcG9ydHMgdG9rZW5zIG9mIHRoZSBFUkMyMCBzdGFuZGFyZCBzaW1pbGFyIHRvIEVUSCBFUkMyMCB0b2tlbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDZWxvQ29pbiBleHRlbmRzIENvbnRyYWN0QWRkcmVzc0RlZmluZWRUb2tlbiB7fVxuXG4vKipcbiAqIFRoZSBCU0MgYmxvY2tjaGFpbiBzdXBwb3J0cyB0b2tlbnMgb2YgdGhlIEVSQzIwIHN0YW5kYXJkIHNpbWlsYXIgdG8gRVRIIEVSQzIwIHRva2Vucy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJzY0NvaW4gZXh0ZW5kcyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4ge31cblxuLyoqXG4gKiBUaGUgU3RlbGxhciBuZXR3b3JrIHN1cHBvcnRzIHRva2VucyAobm9uLW5hdGl2ZSBhc3NldHMpXG4gKiBYTE0gaXMgYWxzbyBrbm93biBhcyB0aGUgbmF0aXZlIGFzc2V0LlxuICogU3RlbGxhciB0b2tlbnMgd29yayBzaW1pbGFyIHRvIFhMTSwgYnV0IHRoZSB0b2tlbiBuYW1lIGlzIGRldGVybWluZWQgYnkgdGhlIGNoYWluLFxuICogdGhlIHRva2VuIGNvZGUgYW5kIHRoZSBpc3N1ZXIgYWNjb3VudCBpbiB0aGUgZm9ybTogKHQpeGxtOjx0b2tlbj4tPGlzc3Vlcj5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0ZWxsYXJDb2luIGV4dGVuZHMgQWNjb3VudENvaW5Ub2tlbiB7XG4gIHB1YmxpYyBkb21haW46IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTdGVsbGFyQ29pbkNvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5kb21haW4gIT09ICcnICYmICFvcHRpb25zLmRvbWFpbi5tYXRjaChET01BSU5fUEFUVEVSTikpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRG9tYWluRXJyb3Iob3B0aW9ucy5uYW1lLCBvcHRpb25zLmRvbWFpbik7XG4gICAgfVxuXG4gICAgdGhpcy5kb21haW4gPSBvcHRpb25zLmRvbWFpbiBhcyBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgSGVkZXJhIGNvaW4gbmVlZHMgYSBjbGllbnQgc2V0IHdpdGggdGhlIG5vZGUgYWNjb3VudCBJZC5cbiAqIEl0J3MgYW4gYWNjb3VudCBiYXNlZCBjb2luIHRoYXQgbmVlZHMgdGhlIG5vZGUgYWNjb3VudCBJRFxuICogd2hlcmUgdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgc2VudC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBIZWRlcmFDb2luIGV4dGVuZHMgQWNjb3VudENvaW5Ub2tlbiB7XG4gIHB1YmxpYyBub2RlQWNjb3VudElkOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogSGVkZXJhQ29pbkNvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICB0aGlzLm5vZGVBY2NvdW50SWQgPSBvcHRpb25zLm5vZGVBY2NvdW50SWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgSGVkZXJhIG5ldHdvcmsgc3VwcG9ydHMgdG9rZW5zLlxuICogSGVkZXJhIHRva2VucyB3b3JrIHNpbWlsYXIgdG8gbmF0aXZlIEhlZGVyYSBjb2luLFxuICogYnV0IHRoZSB0b2tlbiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0b2tlbklkIG9uIHRoZSBub2RlXG4gKlxuICovXG5leHBvcnQgY2xhc3MgSGVkZXJhVG9rZW4gZXh0ZW5kcyBBY2NvdW50Q29pblRva2VuIHtcbiAgcHVibGljIG5vZGVBY2NvdW50SWQ6IHN0cmluZztcbiAgcHVibGljIHRva2VuSWQ6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBIZWRlcmFUb2tlbkNvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICB0aGlzLm5vZGVBY2NvdW50SWQgPSBvcHRpb25zLm5vZGVBY2NvdW50SWQ7XG4gICAgdGhpcy50b2tlbklkID0gb3B0aW9ucy50b2tlbklkO1xuICB9XG59XG5cbi8qKlxuICogVGhlIEFsZ28gbmV0d29yayBzdXBwb3J0cyB0b2tlbnMgKGFzc2V0cylcbiAqIEFsZ28gdG9rZW5zIHdvcmsgc2ltaWxhciB0byBuYXRpdmUgQUxHTyBjb2luLCBidXQgdGhlIHRva2VuIG5hbWUgaXMgZGV0ZXJtaW5lZCBieVxuICogdW5pcXVlIGFzc2V0IGlkIG9uIHRoZSBjaGFpbi4gSW50ZXJuYWxseSwgQml0R28gdXNlcyB0b2tlbiBpZGVudGlmaWVycyBvZiB0aGUgZm9ybWF0OiAodClhbGdvOjxhc3NldElkPlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEFsZ29Db2luIGV4dGVuZHMgQWNjb3VudENvaW5Ub2tlbiB7XG4gIHB1YmxpYyB0b2tlblVSTDogc3RyaW5nO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBBbGdvQ29pbkNvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy50b2tlblVSTCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IFVSTChvcHRpb25zLnRva2VuVVJMKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkRG9tYWluRXJyb3Iob3B0aW9ucy5uYW1lLCBvcHRpb25zLnRva2VuVVJMKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRva2VuVVJMID0gb3B0aW9ucy50b2tlblVSTDtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBFb3MgbmV0d29yayBzdXBwb3J0cyB0b2tlbnNcbiAqIEVvcyB0b2tlbnMgd29yayBzaW1pbGFyIHRvIG5hdGl2ZSBFb3MgY29pbiwgYnV0IHRoZSB0b2tlbiBuYW1lIGlzIGRldGVybWluZWQgYnlcbiAqIHRoZSBjb250cmFjdE5hbWUgb24gdGhlIGNoYWluLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEVvc0NvaW4gZXh0ZW5kcyBBY2NvdW50Q29pblRva2VuIHtcbiAgcHVibGljIGNvbnRyYWN0TmFtZTogc3RyaW5nO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBFb3NDb2luQ29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIHRoaXMuY29udHJhY3ROYW1lID0gb3B0aW9ucy5jb250cmFjdE5hbWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgU29sIG5ldHdvcmsgc3VwcG9ydHMgdG9rZW5zXG4gKiBTb2wgdG9rZW5zIHdvcmsgc2ltaWxhciB0byBuYXRpdmUgU09MIGNvaW4sIGJ1dCB0aGUgdG9rZW4gbmFtZSBpcyBkZXRlcm1pbmVkIGJ5XG4gKiB0aGUgdG9rZW5BZGRyZXNzIG9uIHRoZSBjaGFpbi5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBTb2xDb2luIGV4dGVuZHMgQWNjb3VudENvaW5Ub2tlbiB7XG4gIHB1YmxpYyB0b2tlbkFkZHJlc3M6IHN0cmluZztcbiAgY29uc3RydWN0b3Iob3B0aW9uczogU29sQ29pbkNvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICB0aGlzLnRva2VuQWRkcmVzcyA9IG9wdGlvbnMudG9rZW5BZGRyZXNzO1xuICB9XG59XG5cbi8qKlxuICogVGhlIEFkYSBuZXR3b3JrIHN1cHBvcnRzIHRva2Vuc1xuICogQWRhIHRva2VucyBhcmUgaWRlbnRpZmllZCBieSB0aGVpciBwb2xpY3kgSUQgYW5kIGFzc2V0IG5hbWVcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBBZGFDb2luIGV4dGVuZHMgQWNjb3VudENvaW5Ub2tlbiB7XG4gIHB1YmxpYyBwb2xpY3lJZDogc3RyaW5nO1xuICBwdWJsaWMgYXNzZXROYW1lOiBzdHJpbmc7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEFkYUNvaW5Db25zdHJ1Y3Rvck9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuXG4gICAgdGhpcy5wb2xpY3lJZCA9IG9wdGlvbnMucG9saWN5SWQ7XG4gICAgdGhpcy5hc3NldE5hbWUgPSBvcHRpb25zLmFzc2V0TmFtZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBBVkFYIEMgQ2hhaW4gbmV0d29yayBzdXBwb3J0IHRva2Vuc1xuICogQVZBWCBDIENoYWluIFRva2VucyBhcmUgRVJDMjAgY29pbnNcbiAqL1xuZXhwb3J0IGNsYXNzIEF2YXhFUkMyMFRva2VuIGV4dGVuZHMgQ29udHJhY3RBZGRyZXNzRGVmaW5lZFRva2VuIHtcbiAgY29uc3RydWN0b3Iob3B0aW9uczogRXJjMjBDb25zdHJ1Y3Rvck9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBQb2x5Z29uIENoYWluIG5ldHdvcmsgc3VwcG9ydCB0b2tlbnNcbiAqIFBvbHlnb24gQ2hhaW4gVG9rZW5zIGFyZSBFUkMyMCBjb2luc1xuICovXG5leHBvcnQgY2xhc3MgUG9seWdvbkVSQzIwVG9rZW4gZXh0ZW5kcyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBFcmMyMENvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIEFyYml0cnVtIENoYWluIG5ldHdvcmsgc3VwcG9ydCB0b2tlbnNcbiAqIEFyYml0cnVtIENoYWluIFRva2VucyBhcmUgRVJDMjAgdG9rZW5zXG4gKi9cbmV4cG9ydCBjbGFzcyBBcmJldGhFUkMyMFRva2VuIGV4dGVuZHMgQ29udHJhY3RBZGRyZXNzRGVmaW5lZFRva2VuIHtcbiAgY29uc3RydWN0b3Iob3B0aW9uczogRXJjMjBDb25zdHJ1Y3Rvck9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBPcHRpbWlzbSBDaGFpbiBuZXR3b3JrIHN1cHBvcnQgdG9rZW5zXG4gKiBPcHRpbWlzbSBDaGFpbiBUb2tlbnMgYXJlIEVSQzIwIHRva2Vuc1xuICovXG5leHBvcnQgY2xhc3MgT3BldGhFUkMyMFRva2VuIGV4dGVuZHMgQ29udHJhY3RBZGRyZXNzRGVmaW5lZFRva2VuIHtcbiAgY29uc3RydWN0b3Iob3B0aW9uczogRXJjMjBDb25zdHJ1Y3Rvck9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSB6a1N5bmMgbmV0d29yayBzdXBwb3J0IHRva2Vuc1xuICogemtTeW5jIFRva2VucyBhcmUgRVJDMjAgdG9rZW5zXG4gKi9cbmV4cG9ydCBjbGFzcyBaa2V0aEVSQzIwVG9rZW4gZXh0ZW5kcyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBFcmMyMENvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIFhycCBuZXR3b3JrIHN1cHBvcnRzIHRva2Vuc1xuICogWHJwIHRva2VucyBhcmUgaWRlbnRpZmllZCBieSB0aGVpciBpc3N1ZXIgYWRkcmVzc1xuICogTmFtaW5nIGZvcm1hdCBpcyBzaW1pbGFyIHRvIFhMTVxuICogPG5ldHdvcms+Ojx0b2tlbj4tPGlzc3Vlcj5cbiAqL1xuZXhwb3J0IGNsYXNzIFhycENvaW4gZXh0ZW5kcyBBY2NvdW50Q29pblRva2VuIHtcbiAgcHVibGljIGlzc3VlckFkZHJlc3M6IHN0cmluZztcbiAgcHVibGljIGN1cnJlbmN5Q29kZTogc3RyaW5nO1xuICBwdWJsaWMgZG9tYWluOiBzdHJpbmc7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFhycENvaW5Db25zdHJ1Y3Rvck9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMuZG9tYWluICE9PSAnJyAmJiAhb3B0aW9ucy5kb21haW4ubWF0Y2goRE9NQUlOX1BBVFRFUk4pKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERvbWFpbkVycm9yKG9wdGlvbnMubmFtZSwgb3B0aW9ucy5kb21haW4pO1xuICAgIH1cblxuICAgIHRoaXMuZG9tYWluID0gb3B0aW9ucy5kb21haW4gYXMgc3RyaW5nO1xuICAgIHRoaXMuY3VycmVuY3lDb2RlID0gb3B0aW9ucy5jdXJyZW5jeUNvZGU7XG4gICAgdGhpcy5pc3N1ZXJBZGRyZXNzID0gb3B0aW9ucy5pc3N1ZXJBZGRyZXNzO1xuICB9XG59XG5cbi8qKlxuICogRmlhdCBjdXJyZW5jaWVzLCBzdWNoIGFzIFVTRCwgRVVSLCBvciBZRU4uXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWF0Q29pbiBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBERUZBVUxUX0ZFQVRVUkVTID0gWy4uLkFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVNdO1xuXG4gIHB1YmxpYyByZWFkb25seSBuZXR3b3JrOiBCYXNlTmV0d29yaztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBGaWF0Q29pbkNvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHsgLi4ub3B0aW9ucywga2luZDogQ29pbktpbmQuRklBVCB9KTtcblxuICAgIHRoaXMubmV0d29yayA9IG9wdGlvbnMubmV0d29yaztcbiAgfVxuXG4gIHByb3RlY3RlZCByZXF1aXJlZEZlYXR1cmVzKCk6IFNldDxDb2luRmVhdHVyZT4ge1xuICAgIHJldHVybiBuZXcgU2V0PENvaW5GZWF0dXJlPihbQ29pbkZlYXR1cmUuQUNDT1VOVF9NT0RFTF0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGRpc2FsbG93ZWRGZWF0dXJlcygpOiBTZXQ8Q29pbkZlYXR1cmU+IHtcbiAgICByZXR1cm4gbmV3IFNldDxDb2luRmVhdHVyZT4oW0NvaW5GZWF0dXJlLlVOU1BFTlRfTU9ERUxdKTtcbiAgfVxufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGFjY291bnQgY29pbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZT8gVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhY2NvdW50KFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGJhc2VVbml0OiBCYXNlVW5pdCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIGlzVG9rZW4gPSBmYWxzZVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBBY2NvdW50Q29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBiYXNlVW5pdCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGVyYzIwIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byBFdGhlcmV1bSBtYWluIG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gZXJjMjAoXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEV0aGVyZXVtTmV0d29yayA9IE5ldHdvcmtzLm1haW4uZXRoZXJldW0sXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgRXJjMjBDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5FVEgsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IGVyYzIwIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byB0aGUgS292YW4gdGVzdCBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVyYzIwKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBFdGhlcmV1bU5ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0LmtvdmFuXG4pIHtcbiAgcmV0dXJuIGVyYzIwKGlkLCBuYW1lLCBmdWxsTmFtZSwgZGVjaW1hbFBsYWNlcywgY29udHJhY3RBZGRyZXNzLCBhc3NldCwgZmVhdHVyZXMsIHByZWZpeCwgc3VmZml4LCBuZXR3b3JrKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBlcmM3MjEgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gRXRoZXJldW0gbWFpbiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVyYzcyMShcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEV0aGVyZXVtTmV0d29yayA9IE5ldHdvcmtzLm1haW4uZXRoZXJldW0sXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgRXJjNzIxQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXM6IDAsXG4gICAgICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LkVSQzcyMSxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuRVRILFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBlcmM3MjEgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gSG9sZXNreSB0ZXN0IG5ldHdvcmsuXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVyYzcyMShcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEV0aGVyZXVtTmV0d29yayA9IE5ldHdvcmtzLnRlc3QuaG9sZXNreSxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBlcmM3MjEoaWQsIG5hbWUsIGZ1bGxOYW1lLCBjb250cmFjdEFkZHJlc3MsIGZlYXR1cmVzLCBwcmVmaXgsIHN1ZmZpeCwgbmV0d29yaywgcHJpbWFyeUtleUN1cnZlKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBub25zdGFuZGFyZCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byBFdGhlcmV1bSBtYWluIG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9uc3RhbmRhcmRUb2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEV0aGVyZXVtTmV0d29yayA9IE5ldHdvcmtzLm1haW4uZXRoZXJldW0sXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgQ29udHJhY3RBZGRyZXNzRGVmaW5lZFRva2VuKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlczogMCxcbiAgICAgIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQuTk9OU1RBTkRBUkQsXG4gICAgICBpc1Rva2VuOiB0cnVlLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkVUSCxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGVyYzExNTUgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gRXRoZXJldW0gbWFpbiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVyYzExNTUoXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBFdGhlcmV1bU5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmV0aGVyZXVtLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEVyYzExNTVDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlczogMCxcbiAgICAgIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQuRVJDMTE1NSxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuRVRILFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBlcmMxMTU1IHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIEhvbGVza3kgdGVzdCBuZXR3b3JrLlxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlcmMxMTU1KFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogRXRoZXJldW1OZXR3b3JrID0gTmV0d29ya3MudGVzdC5ob2xlc2t5LFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIGVyYzExNTUoaWQsIG5hbWUsIGZ1bGxOYW1lLCBjb250cmFjdEFkZHJlc3MsIGZlYXR1cmVzLCBwcmVmaXgsIHN1ZmZpeCwgbmV0d29yaywgcHJpbWFyeUtleUN1cnZlKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBFUkMyMC1jb21wYXRpYmxlIGFjY291bnQgY29pbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gZXJjMjBDb21wYXRpYmxlQWNjb3VudENvaW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgbmV0d29yazogRXRoZXJldW1OZXR3b3JrLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBiYXNlVW5pdDogQmFzZVVuaXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEVyYzIwQ29tcGF0aWJsZUFjY291bnRDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogZmFsc2UsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdCxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGNlbG8gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIENFTE8gbWFpbiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNlbG9Ub2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogRXRoZXJldW1OZXR3b3JrID0gTmV0d29ya3MubWFpbi5jZWxvLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IENlbG9Db2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5FVEgsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IGNlbG8gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIHRoZSB0ZXN0bmV0IENFTE8gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRjZWxvVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEV0aGVyZXVtTmV0d29yayA9IE5ldHdvcmtzLnRlc3QuY2Vsb1xuKSB7XG4gIHJldHVybiBjZWxvVG9rZW4oaWQsIG5hbWUsIGZ1bGxOYW1lLCBkZWNpbWFsUGxhY2VzLCBjb250cmFjdEFkZHJlc3MsIGFzc2V0LCBmZWF0dXJlcywgcHJlZml4LCBzdWZmaXgsIG5ldHdvcmspO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGNlbG8gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIEJTQyBtYWluIG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gYnNjVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEV0aGVyZXVtTmV0d29yayA9IE5ldHdvcmtzLm1haW4uYnNjLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEJzY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgYXNzZXQsXG4gICAgICBpc1Rva2VuOiB0cnVlLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkJTQyxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgYnNjIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byB0aGUgdGVzdG5ldCBCU0MgbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRic2NUb2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogRXRoZXJldW1OZXR3b3JrID0gTmV0d29ya3MudGVzdC5ic2Ncbikge1xuICByZXR1cm4gYnNjVG9rZW4oaWQsIG5hbWUsIGZ1bGxOYW1lLCBkZWNpbWFsUGxhY2VzLCBjb250cmFjdEFkZHJlc3MsIGFzc2V0LCBmZWF0dXJlcywgcHJlZml4LCBzdWZmaXgsIG5ldHdvcmspO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIFN0ZWxsYXIgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBkb21haW4gRG9tYWluIG9mIHRoZSB0b2tlbiBpc3N1ZXIgKHVzZWQgdG8gYWNjZXNzIHRva2VuIGluZm9ybWF0aW9uIGZyb20gdGhlIGlzc3VlcidzIHN0ZWxsYXIudG9tbCBmaWxlKVxuICogU2VlIGh0dHBzOi8vd3d3LnN0ZWxsYXIub3JnL2RldmVsb3BlcnMvZ3VpZGVzL2NvbmNlcHRzL3N0ZWxsYXItdG9tbC5odG1sXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIFN0ZWxsYXIgbWFpbm5ldC5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGVsbGFyVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBkb21haW4gPSAnJyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrID0gTmV0d29ya3MubWFpbi5zdGVsbGFyLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuRWQyNTUxOVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBTdGVsbGFyQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIGRvbWFpbixcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgbmV0d29yayxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuWExNLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBTdGVsbGFyIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gZG9tYWluIERvbWFpbiBvZiB0aGUgdG9rZW4gaXNzdWVyICh1c2VkIHRvIGFjY2VzcyB0b2tlbiBpbmZvcm1hdGlvbiBmcm9tIHRoZSBpc3N1ZXIncyBzdGVsbGFyLnRvbWwgZmlsZSlcbiAqIFNlZSBodHRwczovL3d3dy5zdGVsbGFyLm9yZy9kZXZlbG9wZXJzL2d1aWRlcy9jb25jZXB0cy9zdGVsbGFyLXRvbWwuaHRtbFxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byBTdGVsbGFyIHRlc3RuZXQuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0c3RlbGxhclRva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZG9tYWluID0gJycsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLnRlc3Quc3RlbGxhclxuKSB7XG4gIHJldHVybiBzdGVsbGFyVG9rZW4oaWQsIG5hbWUsIGZ1bGxOYW1lLCBkZWNpbWFsUGxhY2VzLCBhc3NldCwgZG9tYWluLCBmZWF0dXJlcywgcHJlZml4LCBzdWZmaXgsIG5ldHdvcmspO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRyb24gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIFRST04gbWFpbiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyb25Ub2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogVHJvbk5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLnRyeCxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBUcm9uRXJjMjBDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5UUlgsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IHRyb24gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIHRoZSB0ZXN0bmV0IFRST04gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0dHJvblRva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBUcm9uTmV0d29yayA9IE5ldHdvcmtzLnRlc3QudHJ4LFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIHRyb25Ub2tlbihcbiAgICBpZCxcbiAgICBuYW1lLFxuICAgIGZ1bGxOYW1lLFxuICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIGFzc2V0LFxuICAgIGZlYXR1cmVzLFxuICAgIHByZWZpeCxcbiAgICBzdWZmaXgsXG4gICAgbmV0d29yayxcbiAgICBwcmltYXJ5S2V5Q3VydmVcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBIZWRlcmEgY29pbiBpbnN0YW5jZXNcbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBub2RlQWNjb3VudElkIG5vZGUgYWNjb3VudCBJZCBmcm9tIHdoaWNoIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHNlbnRcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gSGVkZXJhIG1haW5uZXQuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaGVkZXJhQ29pbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBub2RlQWNjb3VudElkID0gJzAuMC4zJyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5FZDI1NTE5XG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEhlZGVyYUNvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgYXNzZXQsXG4gICAgICBub2RlQWNjb3VudElkLFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBuZXR3b3JrLFxuICAgICAgaXNUb2tlbjogZmFsc2UsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuSEJBUixcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIEhlZGVyYSB0b2tlbiBpbnN0YW5jZXNcbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBub2RlQWNjb3VudElkIG5vZGUgYWNjb3VudCBJZCBmcm9tIHdoaWNoIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHNlbnRcbiAqIEBwYXJhbSB0b2tlbklkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIEhlZGVyYSBtYWlubmV0LlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhlZGVyYVRva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIG5vZGVBY2NvdW50SWQgPSAnMC4wLjMnLFxuICB0b2tlbklkOiBzdHJpbmcsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuRWQyNTUxOVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBIZWRlcmFUb2tlbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIG5vZGVBY2NvdW50SWQsXG4gICAgICB0b2tlbklkLFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBuZXR3b3JrLFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5IQkFSLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgQUxHTyB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuXG4gKiBAcGFyYW0gYWxpYXMgKG9wdGlvbmFsKSBhbHRlcm5hdGl2ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHRva2VuVVJMIE9wdGlvbmFsIGFzc2V0IFVybCBmb3IgbW9yZSBpbmZvcm1hdGlvbmEgYWJvdXQgdGhlIGFzc2V0XG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYWxnb3JhbmQub3JnL2RvY3MvcmVmZXJlbmNlL3RyYW5zYWN0aW9ucy8jdXJsXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIEFMR08gbWFpbm5ldC5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGdvVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgYWxpYXM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICB0b2tlblVSTCA9ICcnLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmFsZ29yYW5kLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuRWQyNTUxOVxuKTogUmVhZG9ubHk8QWxnb0NvaW4+IHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEFsZ29Db2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGFsaWFzLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgYXNzZXQsXG4gICAgICB0b2tlblVSTDogdG9rZW5VUkwsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIG5ldHdvcmssXG4gICAgICBpc1Rva2VuOiB0cnVlLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkFMR08sXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IEFMR08gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBhbGlhcyAob3B0aW9uYWwpIGFsdGVybmF0aXZlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gdG9rZW5VUkwgT3B0aW9uYWwgYXNzZXQgVXJsIGZvciBtb3JlIGluZm9ybWF0aW9uYSBhYm91dCB0aGUgYXNzZXRcbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5hbGdvcmFuZC5vcmcvZG9jcy9yZWZlcmVuY2UvdHJhbnNhY3Rpb25zLyN1cmxcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gQWxnbyB0ZXN0bmV0LlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFsZ29Ub2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBhbGlhczogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIHRva2VuVVJMID0gJycsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLnRlc3QuYWxnb3JhbmRcbik6IFJlYWRvbmx5PEFsZ29Db2luPiB7XG4gIHJldHVybiBhbGdvVG9rZW4oaWQsIG5hbWUsIGFsaWFzLCBmdWxsTmFtZSwgZGVjaW1hbFBsYWNlcywgYXNzZXQsIHRva2VuVVJMLCBmZWF0dXJlcywgcHJlZml4LCBzdWZmaXgsIG5ldHdvcmspO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGVvcyB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0TmFtZSBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gRU9TIG1haW4gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlb3NUb2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0TmFtZTogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmVvcyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBFb3NDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIGNvbnRyYWN0TmFtZSxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5FT1MsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IGVvcyB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gdGhlIHRlc3RuZXQgRU9TIG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZW9zVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBjb250cmFjdE5hbWU6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrID0gTmV0d29ya3MudGVzdC5lb3Ncbikge1xuICByZXR1cm4gZW9zVG9rZW4oaWQsIG5hbWUsIGZ1bGxOYW1lLCBkZWNpbWFsUGxhY2VzLCBjb250cmFjdE5hbWUsIGFzc2V0LCBmZWF0dXJlcywgcHJlZml4LCBzdWZmaXgsIG5ldHdvcmspO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHNvbCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIHRva2VuQWRkcmVzcyBUb2tlbiBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gU09MIG1haW4gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBhbmQgUkVRVUlSRVNfUkVTRVJWRSBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb2xUb2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIHRva2VuQWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IFsuLi5BY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLCBDb2luRmVhdHVyZS5SRVFVSVJFU19SRVNFUlZFXSxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLm1haW4uc29sLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuRWQyNTUxOVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBTb2xDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHRva2VuQWRkcmVzcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5TT0wsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IHNvbGFuYSB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIHRva2VuQWRkcmVzcyBUb2tlbiBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gdGhlIHRlc3RuZXQgU29sYW5hIG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgYW5kIFJFUVVJUkVTX1JFU0VSVkUgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0c29sVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICB0b2tlbkFkZHJlc3M6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBbLi4uQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUywgQ29pbkZlYXR1cmUuUkVRVUlSRVNfUkVTRVJWRV0sXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0LnNvbFxuKSB7XG4gIHJldHVybiBzb2xUb2tlbihpZCwgbmFtZSwgZnVsbE5hbWUsIGRlY2ltYWxQbGFjZXMsIHRva2VuQWRkcmVzcywgYXNzZXQsIGZlYXR1cmVzLCBwcmVmaXgsIHN1ZmZpeCwgbmV0d29yayk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgYWRhIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gdG9rZW5TeW1ib2wgVG9rZW4gc3ltYm9sIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gQ2FyZGFubyBtYWluIG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgYW5kIFJFUVVJUkVTX1JFU0VSVkUgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRhVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBwb2xpY3lJZDogc3RyaW5nLFxuICBhc3NldE5hbWU6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBbLi4uQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUywgQ29pbkZlYXR1cmUuUkVRVUlSRVNfUkVTRVJWRV0sXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmFkYSxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLkVkMjU1MTlcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgQWRhQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwb2xpY3lJZCxcbiAgICAgIGFzc2V0TmFtZSxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5BREEsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IGNhcmRhbm8gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSB0b2tlblN5bWJvbCBUb2tlbiBzeW1ib2wgb2YgdGhpcyB0b2tlbiBpLmU6IEFVU0RcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gdGhlIHRlc3RuZXQgQ2FyZGFubyBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGFuZCBSRVFVSVJFU19SRVNFUlZFIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFkYVRva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgcG9saWN5SWQ6IHN0cmluZyxcbiAgYXNzZXROYW1lOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gWy4uLkFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsIENvaW5GZWF0dXJlLlJFUVVJUkVTX1JFU0VSVkVdLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrID0gTmV0d29ya3MudGVzdC5hZGFcbikge1xuICByZXR1cm4gYWRhVG9rZW4oaWQsIG5hbWUsIGZ1bGxOYW1lLCBkZWNpbWFsUGxhY2VzLCBwb2xpY3lJZCwgYXNzZXROYW1lLCBhc3NldCwgZmVhdHVyZXMsIHByZWZpeCwgc3VmZml4LCBuZXR3b3JrKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBhdmF4RXJjMjAgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIEF2YWxhbmNoZUMgbWFpbiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF2YXhFcmMyMChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmF2YWxhbmNoZUMsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgQXZheEVSQzIwVG9rZW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgYXNzZXQsXG4gICAgICBpc1Rva2VuOiB0cnVlLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkVUSCxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgYXZheEVyYzIwIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byB0aGUgQXZhbGFuY2hlQyB0ZXN0IG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gdGF2YXhFcmMyMChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0LmF2YWxhbmNoZUMsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gYXZheEVyYzIwKFxuICAgIGlkLFxuICAgIG5hbWUsXG4gICAgZnVsbE5hbWUsXG4gICAgZGVjaW1hbFBsYWNlcyxcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgYXNzZXQsXG4gICAgZmVhdHVyZXMsXG4gICAgcHJlZml4LFxuICAgIHN1ZmZpeCxcbiAgICBuZXR3b3JrLFxuICAgIHByaW1hcnlLZXlDdXJ2ZVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHBvbHlnb25FcmMyMCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gUG9seWdvbiBtYWluIG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbkVyYzIwKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLm1haW4ucG9seWdvbixcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBQb2x5Z29uRVJDMjBUb2tlbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuRVRILFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgQW1veSB0ZXN0bmV0IHBvbHlnb25FcmMyMCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gdGhlIFBvbHlnb24gdGVzdCBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRwb2x5Z29uRXJjMjAoXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrID0gTmV0d29ya3MudGVzdC5wb2x5Z29uLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIHBvbHlnb25FcmMyMChcbiAgICBpZCxcbiAgICBuYW1lLFxuICAgIGZ1bGxOYW1lLFxuICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIGFzc2V0LFxuICAgIGZlYXR1cmVzLFxuICAgIHByZWZpeCxcbiAgICBzdWZmaXgsXG4gICAgbmV0d29yayxcbiAgICBwcmltYXJ5S2V5Q3VydmVcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBhcmJldGhFcmMyMCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gQXJiaXRydW0gbWFpbiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFyYmV0aEVyYzIwKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLm1haW4uYXJiaXRydW0sXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgQXJiZXRoRVJDMjBUb2tlbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuRVRILFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgQXJiaXRydW0gU2Vwb2xpYSB0ZXN0bmV0IGFyYmV0aEVyYzIwIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byB0aGUgQXJiaXRydW0gdGVzdCBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhcmJldGhFcmMyMChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0LmFyYml0cnVtLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIGFyYmV0aEVyYzIwKFxuICAgIGlkLFxuICAgIG5hbWUsXG4gICAgZnVsbE5hbWUsXG4gICAgZGVjaW1hbFBsYWNlcyxcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgYXNzZXQsXG4gICAgZmVhdHVyZXMsXG4gICAgcHJlZml4LFxuICAgIHN1ZmZpeCxcbiAgICBuZXR3b3JrLFxuICAgIHByaW1hcnlLZXlDdXJ2ZVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIG9wZXRoRXJjMjAgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIE9wdGltaXNtIG1haW4gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcGV0aEVyYzIwKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLm1haW4ub3B0aW1pc20sXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT3BldGhFUkMyMFRva2VuKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5FVEgsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBPcHRpbWlzbSBTZXBvbGlhIHRlc3RuZXQgb3BldGhFcmMyMCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gdGhlIE9wdGltaXNtIHRlc3QgbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b3BldGhFcmMyMChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0Lm9wdGltaXNtLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIG9wZXRoRXJjMjAoXG4gICAgaWQsXG4gICAgbmFtZSxcbiAgICBmdWxsTmFtZSxcbiAgICBkZWNpbWFsUGxhY2VzLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICBhc3NldCxcbiAgICBmZWF0dXJlcyxcbiAgICBwcmVmaXgsXG4gICAgc3VmZml4LFxuICAgIG5ldHdvcmssXG4gICAgcHJpbWFyeUtleUN1cnZlXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgemtldGhFcmMyMCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gemtTeW5jIG1haW5uZXQgbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6a2V0aEVyYzIwKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLm1haW4uemtTeW5jLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IFprZXRoRVJDMjBUb2tlbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuRVRILFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgemtTeW5jIFNlcG9saWEgdGVzdG5ldCB6a2V0aEVyYzIwIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byB0aGUgemtTeW5jIHNlcG9saWEgdGVzdCBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR6a2V0aEVyYzIwKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLnRlc3QuemtTeW5jLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIHprZXRoRXJjMjAoXG4gICAgaWQsXG4gICAgbmFtZSxcbiAgICBmdWxsTmFtZSxcbiAgICBkZWNpbWFsUGxhY2VzLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICBhc3NldCxcbiAgICBmZWF0dXJlcyxcbiAgICBwcmVmaXgsXG4gICAgc3VmZml4LFxuICAgIG5ldHdvcmssXG4gICAgcHJpbWFyeUtleUN1cnZlXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgeHJwIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gaXNzdWVyQWRkcmVzczogVGhlIGFkZHJlc3Mgb2YgdGhlIGlzc3VlciBvZiB0aGUgdG9rZW4sXG4gKiBAcGFyYW0gY3VycmVuY3lDb2RlIFRoZSB0b2tlbiBzeW1ib2wuIEV4YW1wbGU6IFVTRCwgQlRDLCBFVEgsIGV0Yy5cbiAqIEBwYXJhbSBkb21haW4/IHRoZSBkb21haW4gb2YgdGhlIGlzc3VlciBvZiB0aGUgdG9rZW4sXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIENhcmRhbm8gbWFpbiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHhycFRva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgaXNzdWVyQWRkcmVzczogc3RyaW5nLFxuICBjdXJyZW5jeUNvZGU6IHN0cmluZyxcbiAgZG9tYWluID0gJycsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLm1haW4ueHJwLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IFhycENvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgaXNzdWVyQWRkcmVzcyxcbiAgICAgIGN1cnJlbmN5Q29kZSxcbiAgICAgIGRvbWFpbixcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5YUlAsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IGNhcmRhbm8gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBpc3N1ZXJBZGRyZXNzOiBUaGUgYWRkcmVzcyBvZiB0aGUgaXNzdWVyIG9mIHRoZSB0b2tlbixcbiAqIEBwYXJhbSBjdXJyZW5jeUNvZGUgVGhlIHRva2VuIHN5bWJvbC4gRXhhbXBsZTogVVNELCBCVEMsIEVUSCwgZXRjLlxuICogQHBhcmFtIGRvbWFpbj8gdGhlIGRvbWFpbiBvZiB0aGUgaXNzdWVyIG9mIHRoZSB0b2tlbixcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gdGhlIHRlc3RuZXQgQ2FyZGFubyBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHhycFRva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgaXNzdWVyQWRkcmVzczogc3RyaW5nLFxuICBjdXJyZW5jeUNvZGU6IHN0cmluZyxcbiAgZG9tYWluID0gJycsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLnRlc3QueHJwXG4pIHtcbiAgcmV0dXJuIHhycFRva2VuKFxuICAgIGlkLFxuICAgIG5hbWUsXG4gICAgZnVsbE5hbWUsXG4gICAgZGVjaW1hbFBsYWNlcyxcbiAgICBpc3N1ZXJBZGRyZXNzLFxuICAgIGN1cnJlbmN5Q29kZSxcbiAgICBkb21haW4sXG4gICAgYXNzZXQsXG4gICAgZmVhdHVyZXMsXG4gICAgcHJlZml4LFxuICAgIHN1ZmZpeCxcbiAgICBuZXR3b3JrXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgZmlhdCBjb2luIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW4sIHNob3VsZCBzdGFydCB3aXRoICdmaWF0JyBvciAndGZpYXQnIGZvbGxvd2VkIGJ5IHRoZSAzLWNoYXIgSVNPLTQyMTcgYWxwaGFiZXRpY2FsIGNvZGVcbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgRmlhdENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlPyBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIGNvaW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIGNvaW4gc3VmZml4LiBEZWZhdWx0cyB0byBjb2luIG5hbWUuXG4gKiBAcGFyYW0gaXNUb2tlbj8gV2hldGhlciBvciBub3QgdGhpcyBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWF0KFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBGaWF0Q29pbk5hbWUsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIG5ldHdvcms6IEJhc2VOZXR3b3JrLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gRmlhdENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMSxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBpc1Rva2VuID0gZmFsc2Vcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgRmlhdENvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkZJQVQsXG4gICAgfSlcbiAgKTtcbn1cbiJdfQ==