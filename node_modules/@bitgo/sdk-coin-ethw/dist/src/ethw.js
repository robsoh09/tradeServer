"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ethw = void 0;
const superagent_1 = __importDefault(require("superagent"));
const sdk_core_1 = require("@bitgo/sdk-core");
const statics_1 = require("@bitgo/statics");
const sdk_coin_eth_1 = require("@bitgo/sdk-coin-eth");
class Ethw extends sdk_coin_eth_1.Eth {
    constructor(bitgo, staticsCoin) {
        super(bitgo, staticsCoin);
    }
    static createInstance(bitgo, staticsCoin) {
        return new Ethw(bitgo, staticsCoin);
    }
    verifyTransaction(params) {
        throw new Error('Method not implemented.');
    }
    async isWalletAddress(params) {
        throw new Error('Method not implemented.');
    }
    parseTransaction(params) {
        throw new Error('Method not implemented.');
    }
    generateKeyPair(seed) {
        throw new Error('Method not implemented.');
    }
    /**
     * Query full node for the balance of an address
     * @param {string} address the ETHw address
     * @returns {Promise<BN>} address balance
     */
    async queryAddressBalance(address) {
        const result = await this.recoveryFullNodeRPCQuery('eth_getBalance', [address, 'latest']);
        // throw if the result does not exist or the result is not a valid number
        if (!result || !result.result) {
            throw new Error(`Could not obtain address balance for ${address} from full node, got: ${result.result}`);
        }
        return new sdk_coin_eth_1.optionalDeps.ethUtil.BN(result.result.slice(2), 16);
    }
    /**
     * Queries the contract (via RPC) for the next sequence ID
     * @param {string} address address of the contract
     * @returns {Promise<number>} sequence ID
     */
    async querySequenceId(address) {
        // Get sequence ID using contract call
        const sequenceIdMethodSignature = sdk_coin_eth_1.optionalDeps.ethAbi.methodID('getNextSequenceId', []);
        const sequenceIdArgs = sdk_coin_eth_1.optionalDeps.ethAbi.rawEncode([], []);
        const sequenceIdData = Buffer.concat([sequenceIdMethodSignature, sequenceIdArgs]).toString('hex');
        const sequenceIdDataHex = sdk_coin_eth_1.optionalDeps.ethUtil.addHexPrefix(sequenceIdData);
        const result = await this.recoveryFullNodeRPCQuery('eth_call', [
            { to: address, data: sequenceIdDataHex },
            'latest',
        ]);
        if (!result || !result.result) {
            throw new Error('Could not obtain sequence ID from full node, got: ' + result.result);
        }
        const sequenceIdHex = result.result;
        return new sdk_coin_eth_1.optionalDeps.ethUtil.BN(sequenceIdHex.slice(2), 16).toNumber();
    }
    /**
     * Queries public full node to get the next ETHw nonce that should be used for the given ETH address
     * @param {string} address
     * @returns {Promise<number>} next ETHw nonce
     */
    async getAddressNonce(address) {
        const result = await this.recoveryFullNodeRPCQuery('eth_getTransactionCount', [address, 'latest']);
        if (!result || !result.result) {
            throw new Error('Unable to find next nonce from full node, got: ' + JSON.stringify(result));
        }
        return new sdk_coin_eth_1.optionalDeps.ethUtil.BN(result.result.slice(2), 16).toNumber();
    }
    /**
     * Make a RPC query to full node for information such as balance, token balance, solidity calls
     * @param {string} method RPC method to execute
     * @param {Array} params params to include in the RPC request
     * @returns {Promise<FullNodeResponseBody>} response from full node
     */
    async recoveryFullNodeRPCQuery(method, params) {
        const response = await superagent_1.default.post(sdk_core_1.common.Environments[this.bitgo.getEnv()].ethwFullNodeRPCBaseUrl).send({
            method,
            params,
            id: 0,
            jsonrpc: '2.0',
        });
        if (!response.ok) {
            throw new Error('could not reach ETHW full node');
        }
        if (response.body.error) {
            throw new Error(`ETHW full node error: ${response.body.error.code} - ${response.body.error.message}`);
        }
        return response.body;
    }
    /**
     * Create a new transaction builder for the current chain
     * @return a new transaction builder
     */
    getTransactionBuilder() {
        return new sdk_coin_eth_1.TransactionBuilder(statics_1.coins.get(this.getChain()));
    }
}
exports.Ethw = Ethw;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXRody5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ldGh3LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDREQUFpQztBQUlqQyw4Q0FTeUI7QUFDekIsNENBQW9FO0FBQ3BFLHNEQUE0RTtBQVk1RSxNQUFhLElBQUssU0FBUSxrQkFBRztJQUMzQixZQUFzQixLQUFnQixFQUFFLFdBQXVDO1FBQzdFLEtBQUssQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUVELE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBZ0IsRUFBRSxXQUF1QztRQUM3RSxPQUFPLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQsaUJBQWlCLENBQUMsTUFBZ0M7UUFDaEQsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFDRCxLQUFLLENBQUMsZUFBZSxDQUFDLE1BQTRCO1FBQ2hELE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBQ0QsZ0JBQWdCLENBQUMsTUFBK0I7UUFDOUMsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFDRCxlQUFlLENBQUMsSUFBeUI7UUFDdkMsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLG1CQUFtQixDQUFDLE9BQWU7UUFDdkMsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsd0JBQXdCLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUMxRix5RUFBeUU7UUFDekUsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDN0IsTUFBTSxJ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QUFJLEtBQUssQ0FBQyx5QkFBeUIsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxNQUFNLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7U0FDdkc7UUFDRCxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7T0FHRztJQUNPLHFCQUFxQjtRQUM3QixPQUFPLElBQUksaUNBQWtCLENBQUMsZUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzVELENBQUM7Q0FDRjtBQXRHRCxvQkFzR0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcmVxdWVzdCBmcm9tICdzdXBlcmFnZW50JztcblxuaW1wb3J0IHsgQk4gfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuXG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgQml0R29CYXNlLFxuICBjb21tb24sXG4gIEtleVBhaXIsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IEJhc2VDb2luIGFzIFN0YXRpY3NCYXNlQ29pbiwgY29pbnMgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBFdGgsIG9wdGlvbmFsRGVwcywgVHJhbnNhY3Rpb25CdWlsZGVyIH0gZnJvbSAnQGJpdGdvL3Nkay1jb2luLWV0aCc7XG5cbnR5cGUgRnVsbE5vZGVSZXNwb25zZUJvZHkgPSB7XG4gIGpzb25ycGM6IHN0cmluZztcbiAgaWQ6IHN0cmluZztcbiAgcmVzdWx0Pzogc3RyaW5nO1xuICBlcnJvcj86IHtcbiAgICBjb2RlOiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICB9O1xufTtcblxuZXhwb3J0IGNsYXNzIEV0aHcgZXh0ZW5kcyBFdGgge1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSwgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KSB7XG4gICAgc3VwZXIoYml0Z28sIHN0YXRpY3NDb2luKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R29CYXNlLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBFdGh3KGJpdGdvLCBzdGF0aWNzQ29pbik7XG4gIH1cblxuICB2ZXJpZnlUcmFuc2FjdGlvbihwYXJhbXM6IFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuICBhc3luYyBpc1dhbGxldEFkZHJlc3MocGFyYW1zOiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuICBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkPzogQnVmZmVyIHwgdW5kZWZpbmVkKTogS2V5UGFpciB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJ5IGZ1bGwgbm9kZSBmb3IgdGhlIGJhbGFuY2Ugb2YgYW4gYWRkcmVzc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyB0aGUgRVRIdyBhZGRyZXNzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJOPn0gYWRkcmVzcyBiYWxhbmNlXG4gICAqL1xuICBhc3luYyBxdWVyeUFkZHJlc3NCYWxhbmNlKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8Qk4+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlY292ZXJ5RnVsbE5vZGVSUENRdWVyeSgnZXRoX2dldEJhbGFuY2UnLCBbYWRkcmVzcywgJ2xhdGVzdCddKTtcbiAgICAvLyB0aHJvdyBpZiB0aGUgcmVzdWx0IGRvZXMgbm90IGV4aXN0IG9yIHRoZSByZXN1bHQgaXMgbm90IGEgdmFsaWQgbnVtYmVyXG4gICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC5yZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IG9idGFpbiBhZGRyZXNzIGJhbGFuY2UgZm9yICR7YWRkcmVzc30gZnJvbSBmdWxsIG5vZGUsIGdvdDogJHtyZXN1bHQucmVzdWx0fWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKHJlc3VsdC5yZXN1bHQuc2xpY2UoMiksIDE2KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyaWVzIHRoZSBjb250cmFjdCAodmlhIFJQQykgZm9yIHRoZSBuZXh0IHNlcXVlbmNlIElEXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IHNlcXVlbmNlIElEXG4gICAqL1xuICBhc3luYyBxdWVyeVNlcXVlbmNlSWQoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAvLyBHZXQgc2VxdWVuY2UgSUQgdXNpbmcgY29udHJhY3QgY2FsbFxuICAgIGNvbnN0IHNlcXVlbmNlSWRNZXRob2RTaWduYXR1cmUgPSBvcHRpb25hbERlcHMuZXRoQWJpLm1ldGhvZElEKCdnZXROZXh0U2VxdWVuY2VJZCcsIFtdKTtcbiAgICBjb25zdCBzZXF1ZW5jZUlkQXJncyA9IG9wdGlvbmFsRGVwcy5ldGhBYmkucmF3RW5jb2RlKFtdLCBbXSk7XG4gICAgY29uc3Qgc2VxdWVuY2VJZERhdGEgPSBCdWZmZXIuY29uY2F0KFtzZXF1ZW5jZUlkTWV0aG9kU2lnbmF0dXJlLCBzZXF1ZW5jZUlkQXJnc10pLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCBzZXF1ZW5jZUlkRGF0YUhleCA9IG9wdGlvbmFsRGVwcy5ldGhVdGlsLmFkZEhleFByZWZpeChzZXF1ZW5jZUlkRGF0YSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWNvdmVyeUZ1bGxOb2RlUlBDUXVlcnkoJ2V0aF9jYWxsJywgW1xuICAgICAgeyB0bzogYWRkcmVzcywgZGF0YTogc2VxdWVuY2VJZERhdGFIZXggfSxcbiAgICAgICdsYXRlc3QnLFxuICAgIF0pO1xuICAgIGlmICghcmVzdWx0IHx8ICFyZXN1bHQucmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBvYnRhaW4gc2VxdWVuY2UgSUQgZnJvbSBmdWxsIG5vZGUsIGdvdDogJyArIHJlc3VsdC5yZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBzZXF1ZW5jZUlkSGV4ID0gcmVzdWx0LnJlc3VsdDtcbiAgICByZXR1cm4gbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKHNlcXVlbmNlSWRIZXguc2xpY2UoMiksIDE2KS50b051bWJlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJpZXMgcHVibGljIGZ1bGwgbm9kZSB0byBnZXQgdGhlIG5leHQgRVRIdyBub25jZSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciB0aGUgZ2l2ZW4gRVRIIGFkZHJlc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gbmV4dCBFVEh3IG5vbmNlXG4gICAqL1xuICBhc3luYyBnZXRBZGRyZXNzTm9uY2UoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlY292ZXJ5RnVsbE5vZGVSUENRdWVyeSgnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnLCBbYWRkcmVzcywgJ2xhdGVzdCddKTtcbiAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LnJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBuZXh0IG5vbmNlIGZyb20gZnVsbCBub2RlLCBnb3Q6ICcgKyBKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTihyZXN1bHQucmVzdWx0LnNsaWNlKDIpLCAxNikudG9OdW1iZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgUlBDIHF1ZXJ5IHRvIGZ1bGwgbm9kZSBmb3IgaW5mb3JtYXRpb24gc3VjaCBhcyBiYWxhbmNlLCB0b2tlbiBiYWxhbmNlLCBzb2xpZGl0eSBjYWxsc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIFJQQyBtZXRob2QgdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgcGFyYW1zIHRvIGluY2x1ZGUgaW4gdGhlIFJQQyByZXF1ZXN0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEZ1bGxOb2RlUmVzcG9uc2VCb2R5Pn0gcmVzcG9uc2UgZnJvbSBmdWxsIG5vZGVcbiAgICovXG4gIGFzeW5jIHJlY292ZXJ5RnVsbE5vZGVSUENRdWVyeShtZXRob2Q6IHN0cmluZywgcGFyYW1zOiBBcnJheTx1bmtub3duPik6IFByb21pc2U8RnVsbE5vZGVSZXNwb25zZUJvZHk+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QucG9zdChjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZ2V0RW52KCldLmV0aHdGdWxsTm9kZVJQQ0Jhc2VVcmwpLnNlbmQoe1xuICAgICAgbWV0aG9kLFxuICAgICAgcGFyYW1zLFxuICAgICAgaWQ6IDAsXG4gICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWNoIEVUSFcgZnVsbCBub2RlJyk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNlLmJvZHkuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRVRIVyBmdWxsIG5vZGUgZXJyb3I6ICR7cmVzcG9uc2UuYm9keS5lcnJvci5jb2RlfSAtICR7cmVzcG9uc2UuYm9keS5lcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UuYm9keTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNhY3Rpb24gYnVpbGRlciBmb3IgdGhlIGN1cnJlbnQgY2hhaW5cbiAgICogQHJldHVybiBhIG5ldyB0cmFuc2FjdGlvbiBidWlsZGVyXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VHJhbnNhY3Rpb25CdWlsZGVyKCk6IFRyYW5zYWN0aW9uQnVpbGRlciB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkJ1aWxkZXIoY29pbnMuZ2V0KHRoaXMuZ2V0Q2hhaW4oKSkpO1xuICB9XG59XG4iXX0=