/// <reference types="node" />
/**
 * @prettier
 */
import { CoinFamily, BaseCoin as StaticsBaseCoin } from '@bitgo/statics';
import { BaseCoin, BitGoBase, KeyPair, ParsedTransaction, ParseTransactionOptions, SignedTransaction, SignTransactionOptions, VerifyAddressOptions as BaseVerifyAddressOptions, VerifyTransactionOptions, TransactionFee, TransactionRecipient as Recipient, TransactionPrebuild as BaseTransactionPrebuild, TransactionExplanation, Memo, TokenEnablementConfig, BaseBroadcastTransactionOptions, BaseBroadcastTransactionResult } from '@bitgo/sdk-core';
import { Client, Transaction as HbarTransaction, AccountBalanceJson } from '@hashgraph/sdk';
export interface HbarSignTransactionOptions extends SignTransactionOptions {
    txPrebuild: TransactionPrebuild;
    prv: string;
}
export interface TxInfo {
    recipients: Recipient[];
    from: string;
    txid: string;
}
export interface TransactionPrebuild extends BaseTransactionPrebuild {
    txHex: string;
    txInfo: TxInfo;
    feeInfo: TransactionFee;
    source: string;
}
export interface ExplainTransactionOptions {
    txHex?: string;
    halfSigned?: {
        txHex: string;
    };
    feeInfo?: TransactionFee;
    memo?: {
        type: string;
        value: string;
    };
}
export interface HbarVerifyTransactionOptions extends VerifyTransactionOptions {
    txPrebuild: TransactionPrebuild;
    memo?: Memo;
}
interface VerifyAddressOptions extends BaseVerifyAddressOptions {
    baseAddress: string;
}
export interface RecoveryOptions {
    backupKey: string;
    userKey: string;
    rootAddress: string;
    recoveryDestination: string;
    bitgoKey?: string;
    walletPassphrase?: string;
    maxFee?: string;
    nodeId?: string;
    startTime?: string;
}
interface RecoveryInfo {
    id: string;
    tx: string;
    coin: string;
    startTime: string;
    nodeId: string;
}
export interface OfflineVaultTxInfo {
    txHex: string;
    userKey: string;
    backupKey: string;
    bitgoKey?: string;
    address: string;
    coin: string;
    maxFee: string;
    recipients: Recipient[];
    amount: string;
    startTime: string;
    validDuration: string;
    nodeId: string;
    memo: string;
    json?: any;
}
export interface BroadcastTransactionOptions extends BaseBroadcastTransactionOptions {
    startTime?: string;
}
export interface BroadcastTransactionResult extends BaseBroadcastTransactionResult {
    status?: string;
}
export declare class Hbar extends BaseCoin {
    protected readonly _staticsCoin: Readonly<StaticsBaseCoin>;
    constructor(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>);
    getChain(): string;
    getFamily(): CoinFamily;
    getFullName(): string;
    getBaseFactor(): number;
    static createInstance(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>): BaseCoin;
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed(): boolean;
    /**
     * Checks if this is a valid base58 or hex address
     * @param address
     */
    isValidAddress(address: string): boolean;
    /** inheritdoc */
    deriveKeyWithSeed(): {
        derivationPath: string;
        key: string;
    };
    /** inheritdoc */
    generateKeyPair(seed?: Buffer): KeyPair;
    /** inheritdoc */
    generateRootKeyPair(seed?: Buffer): KeyPair;
    parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
    /**
     * Check if address is valid, then make sure it matches the base address.
     *
     * @param {VerifyAddressOptions} params
     * @param {String} params.address - the address to verify
     * @param {String} params.baseAddress - the base address from the wallet
     */
    isWalletAddress(params: VerifyAddressOptions): Promise<boolean>;
    verifyTransaction(params: HbarVerifyTransactionOptions): Promise<boolean>;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param params.wallet.addressVersion {String} this is the version of the Algorand multisig address generation format
     * @returns Promise<SignedTransaction>
     */
    signTransaction(params: HbarSignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     * @return {Buffer} A signature over the given message using the given key
     */
    signMessage(key: KeyPair, message: string | Buffer): Promise<Buffer>;
    /**
     * Builds a funds recovery transaction without BitGo.
     * We need to do three queries during this:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     * @param params
     */
    recover(params: RecoveryOptions): Promise<RecoveryInfo | OfflineVaultTxInfo>;
    /**
     * Explain a Hedera transaction from txHex
     * @param params
     */
    explainTransaction(params: ExplainTransactionOptions): Promise<TransactionExplanation>;
    isStellarSeed(seed: string): boolean;
    convertFromStellarSeed(seed: string): string | null;
    isValidPub(pub: string): boolean;
    supportsDeriveKeyWithSeed(): boolean;
    getTokenEnablementConfig(): TokenEnablementConfig;
    private getBuilderFactory;
    private getHbarClient;
    getAccountBalance(accountId: string, client: Client): Promise<AccountBalanceJson>;
    broadcastTransaction({ serializedSignedTransaction, startTime, }: BroadcastTransactionOptions): Promise<BroadcastTransactionResult>;
    clientBroadcastTransaction(hbarTx: HbarTransaction): Promise<{
        txId: string;
        status: string;
    }>;
}
export {};
//# sourceMappingURL=hbar.d.ts.map