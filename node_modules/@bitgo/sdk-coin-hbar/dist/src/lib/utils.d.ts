import { PrivateKey } from '@hashgraph/sdk';
import { proto } from '@hashgraph/proto';
import { AddressDetails } from './iface';
import { toHex, toUint8Array } from '@bitgo/sdk-core';
import { BaseCoin } from '@bitgo/statics';
export { toHex, toUint8Array };
/**
 * Returns whether the string is a valid Hedera account address
 *
 * In any form, `shard` and `realm` are assumed to be 0 if not provided.
 *
 * @param {string} address - The address to be validated
 * @returns {boolean} - The validation result
 */
export declare function isValidAddress(address: string): boolean;
/**
 * Returns whether the string is a valid Hedera transaction id
 *
 * @param {string} txId - The transaction id to be validated
 * @returns {boolean} - The validation result
 */
export declare function isValidTransactionId(txId: string): boolean;
/**
 Returns whether the string is a valid Hedera public key
 *
 * @param {string} key - The public key to be validated
 * @returns {boolean} - The validation result
 */
export declare function isValidPublicKey(key: string): boolean;
/**
 * Checks whether nodeJS.process exist and if a node version is defined to determine if this is an nodeJS environment
 *
 * @returns {boolean} - The validation result
 */
export declare function isNodeEnvironment(): boolean;
/**
 * Calculate the current time with nanoseconds precision
 *
 * @returns {string} - The current time in seconds
 */
export declare function getCurrentTime(): string;
/**
 * Returns whether the string is a valid timestamp
 *
 * Nanoseconds are optional and can be passed after a dot, for example: 1595374723.356981689
 *
 * @param {string} time - The timestamp to be validated
 * @returns {boolean} - The validation result
 */
export declare function isValidTimeString(time: string): boolean;
/**
 * Returns whether the string is a valid amount number
 *
 * @param {string} amount - The string to validate
 * @returns {boolean} - The validation result
 */
export declare function isValidAmount(amount: string): boolean;
/**
 * Returns whether the provided raw transaction accommodates to bitgo's preferred format
 *
 * @param {any} rawTransaction - The raw transaction to be checked
 * @returns {boolean} - The validation result
 */
export declare function isValidRawTransactionFormat(rawTransaction: any): boolean;
/**
 * Returns a string representation of an {proto.IAccountID} object
 *
 * @param {proto.IAccountID} accountId - Account id to be cast to string
 * @returns {string} - The string representation of the {proto.IAccountID}
 */
export declare function stringifyAccountId({ shardNum, realmNum, accountNum }: proto.IAccountID): string;
/**
 * Returns a string representation of an {proto.ITokenID} object
 *
 * @param {proto.ITokenID} - token id to be cast to string
 * @returns {string} - the string representation of the {proto.ITokenID}
 */
export declare function stringifyTokenId({ shardNum, realmNum, tokenNum }: proto.ITokenID): string;
/**
 * Returns a string representation of an {proto.ITimestamp} object
 *
 * @param {proto.ITimestamp} timestamp - Timestamp to be cast to string
 * @returns {string} - The string representation of the {proto.ITimestamp}
 */
export declare function stringifyTxTime({ seconds, nanos }: proto.ITimestamp): string;
/**
 * Remove the specified prefix from a string only if it starts with that prefix
 *
 * @param {string} prefix - The prefix to be removed
 * @param {string} key - The original string, usually a private or public key
 * @returns {string} - The string without prefix
 */
export declare function removePrefix(prefix: string, key: string): string;
/**
 * Check if this is a valid memo
 *
 * @param {string} memo
 * @returns {boolean}
 */
export declare function isValidMemo(memo: string): boolean;
/**
 * Uses the native hashgraph SDK function to get a raw key.
 *
 * @param {string} prv - Private key
 * @returns {PrivateKey}
 */
export declare function createRawKey(prv: string): PrivateKey;
/**
 * Converts a stellar public key to ed25519 hex format
 *
 * @param {string} stellarPub
 * @returns {string}
 */
export declare function convertFromStellarPub(stellarPub: string): string;
/**
 * Checks if two addresses have the same base address
 *
 * @param {String} address
 * @param {String} baseAddress
 * @returns {boolean}
 */
export declare function isSameBaseAddress(address: string, baseAddress: string): boolean;
/**
 * Returns the base address portion of an address
 *
 * @param {String} address
 * @returns {String} - the base address
 */
export declare function getBaseAddress(address: string): string;
/**
 * Process address into address and memo id
 *
 * @param {string} rawAddress
 * @returns {AddressDetails} - object containing address and memo id
 */
export declare function getAddressDetails(rawAddress: string): AddressDetails;
/**
 * Validate and return address with appended memo id
 *
 * @param {AddressDetails} addressDetails - Address which to append memo id
 * @returns {string} - Address with appended memo id
 */
export declare function normalizeAddress({ address, memoId }: AddressDetails): string;
/**
 * Return boolean indicating whether input is a valid address with memo id
 *
 * @param {string} address - Address in the form <address>?memoId=<memoId>
 * @returns {boolean} - True if input is a valid address
 */
export declare function isValidAddressWithPaymentId(address: string): boolean;
/**
 * Build hedera {proto.TokenID} object from token ID string
 *
 * @param {string} tokenID - The token ID to build
 * @returns {proto.TokenID} - The resulting proto TokenID object
 */
export declare function buildHederaTokenID(tokenID: string): proto.TokenID;
/**
 * Build hedera {proto.AccountID} object from account ID string
 *
 * @param {string} accountID - The account ID to build
 * @returns {proto} - The resulting proto AccountID object
 */
export declare function buildHederaAccountID(accountID: string): proto.AccountID;
/**
 * Check if Hedera token ID is valid and supported
 *
 * @param {string} tokenId - The token ID to validate
 * @returns {boolean} - True if tokenId is valid and supported
 */
export declare function isValidHederaTokenID(tokenId: string): boolean;
/**
 * Get the associated hedera token ID from token name, if supported
 *
 * @param {string} tokenName - The hedera token name
 * @returns {boolean} - The associated token ID or undefined if not supported
 */
export declare function getHederaTokenIdFromName(tokenName: string): string | undefined;
/**
 * Get the associated hedera token from token ID, if supported
 *
 * @param tokenId - The token address
 * @returns {BaseCoin} - BaseCoin object for the matching token
 */
export declare function getHederaTokenNameFromId(tokenId: string): Readonly<BaseCoin> | undefined;
/**
 * Return boolean indicating whether input is a valid token transfer transaction
 *
 * @param {proto.ICryptoTransferTransactionBody | null} transferTxBody is a transfer transaction body
 * @returns {boolean} true is input is a valid token transfer transaction
 */
export declare function isTokenTransfer(transferTxBody: proto.ICryptoTransferTransactionBody | null): boolean;
/** validates a startTime string to be a valid timestamp and in the future
 * @param {string} startTime - The startTime to be validated
 * @throws {Error} - if startTime is not a valid timestamp or is in the past
 * @returns {void}
 * */
export declare function validateStartTime(startTime: string): void;
export declare function normalizeStarttime(startTime: string): string;
/**
 * Await for a given amount of time in milliseconds
 * @param ms - The amount of time to wait in milliseconds
 * @returns {Promise<void>} - A promise that resolves after the given amount of time
 */
export declare function sleep(ms: number): Promise<void>;
/**
 * Check if the startTime is within the broadcast window (5 seconds after and 175 seconds after the startTime)
 */
export declare function shouldBroadcastNow(startTime: string): boolean;
//# sourceMappingURL=utils.d.ts.map