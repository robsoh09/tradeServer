"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenAssociateBuilder = void 0;
const proto_1 = require("@hashgraph/proto");
const sdk_core_1 = require("@bitgo/sdk-core");
const utils_1 = require("./utils");
const transactionBuilder_1 = require("./transactionBuilder");
const constants_1 = require("./constants");
class TokenAssociateBuilder extends transactionBuilder_1.TransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
        this._tokenIds = [];
        this._txBodyData = new proto_1.proto.TokenAssociateTransactionBody();
        this._txBody.tokenAssociate = this._txBodyData;
    }
    /** @inheritdoc */
    initBuilder(tx) {
        super.initBuilder(tx);
        const tokenAssociateAccount = tx.txBody.tokenAssociate;
        if (tokenAssociateAccount && tokenAssociateAccount.tokens) {
            this.initTokenAssociation(tokenAssociateAccount);
        }
    }
    initTokenAssociation(tokenAssociateAccount) {
        tokenAssociateAccount.tokens.forEach((tokenId) => {
            const token = (0, utils_1.stringifyTokenId)(tokenId);
            this.validateToken(token);
            this._tokenIds.push(token);
        });
        if (tokenAssociateAccount.account) {
            const accountId = (0, utils_1.stringifyAccountId)(tokenAssociateAccount.account);
            this.account(accountId);
        }
    }
    /** @inheritdoc */
    signImplementation(key) {
        if (this._multiSignerKeyPairs.length >= constants_1.DEFAULT_SIGNER_NUMBER) {
            throw new sdk_core_1.SigningError('A maximum of ' + constants_1.DEFAULT_SIGNER_NUMBER + ' can sign the transaction.');
        }
        return super.signImplementation(key);
    }
    /** @inheritdoc */
    async buildImplementation() {
        this._txBodyData.tokens = this.buildTokenData();
        this._txBodyData.account = this.buildAccountData();
        this.transaction.setTransactionType(sdk_core_1.TransactionType.AssociatedTokenAccountInitialization);
        return await super.buildImplementation();
    }
    /** @inheritdoc */
    validateMandatoryFields() {
        if (!this._tokenIds || this._tokenIds.length < 1) {
            throw new sdk_core_1.BuildTransactionError('Invalid transaction: missing tokens to associate');
        }
        super.validateMandatoryFields();
    }
    /**
     * Set account to associate with tokens, defaults to this._source.address value
     *
     * @param {string} accountID - The name of the account to associate to the transaction
     * @returns {TokenAssociateBuilder} - This token association builder
     */
    account(accountID) {
        this.validateAccount(accountID);
        this._account = accountID;
        return this;
    }
    /**
     * Add a token to associate to the multisig wallet.
     *
     * @param {string} tokenName - The name of the token to associate to the transaction
     * @returns {TokenAssociateBuilder} - This token association builder
     */
    tokens(tokenName) {
        const tokenId = (0, utils_1.getHederaTokenIdFromName)(tokenName);
        if (!tokenId) {
            throw new sdk_core_1.BuildTransactionError('Unsupported token: ' + tokenName);
        }
        this.validateToken(tokenId);
        this._tokenIds.push(tokenId);
        return this;
    }
    buildTokenData() {
        return this._tokenIds.map(utils_1.buildHederaTokenID);
    }
    buildAccountData() {
        let accountId = this._account;
        if (!accountId) {
            accountId = this._source.address;
        }
        return (0, utils_1.buildHederaAccountID)(accountId);
    }
    validateAccount(accountID) {
        if (!(0, utils_1.isValidAddress)(accountID)) {
            throw new sdk_core_1.BuildTransactionError('Unsupported account address: ' + accountID);
        }
    }
    validateToken(tokenId) {
        if (this._tokenIds.includes(tokenId)) {
            throw new sdk_core_1.BuildTransactionError('Repeated token ID: ' + tokenId);
        }
        else if (!(0, utils_1.isValidHederaTokenID)(tokenId)) {
            throw new sdk_core_1.BuildTransactionError('Invalid token ID: ' + tokenId);
        }
    }
}
exports.TokenAssociateBuilder = TokenAssociateBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW5Bc3NvY2lhdGVCdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi90b2tlbkFzc29jaWF0ZUJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsNENBQXlDO0FBQ3pDLDhDQUFnRztBQUVoRyxtQ0FRaUI7QUFDakIsNkRBQTBEO0FBQzFELDJDQUFvRDtBQUVwRCxNQUFhLHFCQUFzQixTQUFRLHVDQUFrQjtJQUszRCxZQUFZLFdBQWlDO1FBQzNDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUhiLGNBQVMsR0FBYSxFQUFFLENBQUM7UUFJL0IsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLGFBQUssQ0FBQyw2QkFBNkIsRUFBRSxDQUFDO1FBQzdELElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDakQsQ0FBQztJQUVELGtCQUFrQjtJQUNsQixXQUFXLENBQUMsRUFBZTtRQUN6QixLQUFLLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3RCLE1BQU0scUJBQXFCLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUM7UUFDdkQsSUFBSSxxQkFBcUIsSUFBSSxxQkFBcUIsQ0FBQyxNQUFNLEVBQUU7WUFDekQsSUFBSSxDQUFDLG9CQUFvQixDQUFDLHFCQUE0RCxDQUFDLENBQUM7U0FDekY7SUFDSCxDQUFDO0lBRU8sb0JBQW9CLENBQUMscUJBQTJEO1FBQ3RGLHFCQUFxQixDQUFDLE1BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUF1QixFQUFFLEVBQUU7WUFDaEUsTUFBTSxLQUFLLEdBQUcsSUFBQSx3QkFBZ0IsRUFBQyxPQUFPLENBQUMsQ0FBQztZQUN4QyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzFCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FB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QXFCLENBQUMscUJBQXFCLEdBQUcsT0FBTyxDQUFDLENBQUM7U0FDbEU7YUFBTSxJQUFJLENBQUMsSUFBQSw0QkFBb0IsRUFBQyxPQUFPLENBQUMsRUFBRTtZQUN6QyxNQUFNLElBQUksZ0NBQXFCLENBQUMsb0JBQW9CLEdBQUcsT0FBTyxDQUFDLENBQUM7U0FDakU7SUFDSCxDQUFDO0NBQ0Y7QUFoSEQsc0RBZ0hDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IHByb3RvIH0gZnJvbSAnQGhhc2hncmFwaC9wcm90byc7XG5pbXBvcnQgeyBCYXNlS2V5LCBCdWlsZFRyYW5zYWN0aW9uRXJyb3IsIFNpZ25pbmdFcnJvciwgVHJhbnNhY3Rpb25UeXBlIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi90cmFuc2FjdGlvbic7XG5pbXBvcnQge1xuICBidWlsZEhlZGVyYUFjY291bnRJRCxcbiAgYnVpbGRIZWRlcmFUb2tlbklELFxuICBnZXRIZWRlcmFUb2tlbklkRnJvbU5hbWUsXG4gIGlzVmFsaWRBZGRyZXNzLFxuICBpc1ZhbGlkSGVkZXJhVG9rZW5JRCxcbiAgc3RyaW5naWZ5QWNjb3VudElkLFxuICBzdHJpbmdpZnlUb2tlbklkLFxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uQnVpbGRlciB9IGZyb20gJy4vdHJhbnNhY3Rpb25CdWlsZGVyJztcbmltcG9ydCB7IERFRkFVTFRfU0lHTkVSX05VTUJFUiB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGNsYXNzIFRva2VuQXNzb2NpYXRlQnVpbGRlciBleHRlbmRzIFRyYW5zYWN0aW9uQnVpbGRlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgX3R4Qm9keURhdGE6IHByb3RvLlRva2VuQXNzb2NpYXRlVHJhbnNhY3Rpb25Cb2R5O1xuICBwcml2YXRlIF9hY2NvdW50OiBzdHJpbmc7XG4gIHByaXZhdGUgX3Rva2VuSWRzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKF9jb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xuICAgIHN1cGVyKF9jb2luQ29uZmlnKTtcbiAgICB0aGlzLl90eEJvZHlEYXRhID0gbmV3IHByb3RvLlRva2VuQXNzb2NpYXRlVHJhbnNhY3Rpb25Cb2R5KCk7XG4gICAgdGhpcy5fdHhCb2R5LnRva2VuQXNzb2NpYXRlID0gdGhpcy5fdHhCb2R5RGF0YTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpbml0QnVpbGRlcih0eDogVHJhbnNhY3Rpb24pOiB2b2lkIHtcbiAgICBzdXBlci5pbml0QnVpbGRlcih0eCk7XG4gICAgY29uc3QgdG9rZW5Bc3NvY2lhdGVBY2NvdW50ID0gdHgudHhCb2R5LnRva2VuQXNzb2NpYXRlO1xuICAgIGlmICh0b2tlbkFzc29jaWF0ZUFjY291bnQgJiYgdG9rZW5Bc3NvY2lhdGVBY2NvdW50LnRva2Vucykge1xuICAgICAgdGhpcy5pbml0VG9rZW5Bc3NvY2lhdGlvbih0b2tlbkFzc29jaWF0ZUFjY291bnQgYXMgcHJvdG8uVG9rZW5Bc3NvY2lhdGVUcmFuc2FjdGlvbkJvZHkpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaW5pdFRva2VuQXNzb2NpYXRpb24odG9rZW5Bc3NvY2lhdGVBY2NvdW50OiBwcm90by5JVG9rZW5Bc3NvY2lhdGVUcmFuc2FjdGlvbkJvZHkpOiB2b2lkIHtcbiAgICB0b2tlbkFzc29jaWF0ZUFjY291bnQudG9rZW5zIS5mb3JFYWNoKCh0b2tlbklkOiBwcm90by5JVG9rZW5JRCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW4gPSBzdHJpbmdpZnlUb2tlbklkKHRva2VuSWQpO1xuICAgICAgdGhpcy52YWxpZGF0ZVRva2VuKHRva2VuKTtcbiAgICAgIHRoaXMuX3Rva2VuSWRzLnB1c2godG9rZW4pO1xuICAgIH0pO1xuXG4gICAgaWYgKHRva2VuQXNzb2NpYXRlQWNjb3VudC5hY2NvdW50KSB7XG4gICAgICBjb25zdCBhY2NvdW50SWQgPSBzdHJpbmdpZnlBY2NvdW50SWQodG9rZW5Bc3NvY2lhdGVBY2NvdW50LmFjY291bnQpO1xuICAgICAgdGhpcy5hY2NvdW50KGFjY291bnRJZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBzaWduSW1wbGVtZW50YXRpb24oa2V5OiBCYXNlS2V5KTogVHJhbnNhY3Rpb24ge1xuICAgIGlmICh0aGlzLl9tdWx0aVNpZ25lcktleVBhaXJzLmxlbmd0aCA+PSBERUZBVUxUX1NJR05FUl9OVU1CRVIpIHtcbiAgICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ0EgbWF4aW11bSBvZiAnICsgREVGQVVMVF9TSUdORVJfTlVNQkVSICsgJyBjYW4gc2lnbiB0aGUgdHJhbnNhY3Rpb24uJyk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5zaWduSW1wbGVtZW50YXRpb24oa2V5KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgYnVpbGRJbXBsZW1lbnRhdGlvbigpOiBQcm9taXNlPFRyYW5zYWN0aW9uPiB7XG4gICAgdGhpcy5fdHhCb2R5RGF0YS50b2tlbnMgPSB0aGlzLmJ1aWxkVG9rZW5EYXRhKCk7XG4gICAgdGhpcy5fdHhCb2R5RGF0YS5hY2NvdW50ID0gdGhpcy5idWlsZEFjY291bnREYXRhKCk7XG4gICAgdGhpcy50cmFuc2FjdGlvbi5zZXRUcmFuc2FjdGlvblR5cGUoVHJhbnNhY3Rpb25UeXBlLkFzc29jaWF0ZWRUb2tlbkFjY291bnRJbml0aWFsaXphdGlvbik7XG4gICAgcmV0dXJuIGF3YWl0IHN1cGVyLmJ1aWxkSW1wbGVtZW50YXRpb24oKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZU1hbmRhdG9yeUZpZWxkcygpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX3Rva2VuSWRzIHx8IHRoaXMuX3Rva2VuSWRzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb246IG1pc3NpbmcgdG9rZW5zIHRvIGFzc29jaWF0ZScpO1xuICAgIH1cblxuICAgIHN1cGVyLnZhbGlkYXRlTWFuZGF0b3J5RmllbGRzKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGFjY291bnQgdG8gYXNzb2NpYXRlIHdpdGggdG9rZW5zLCBkZWZhdWx0cyB0byB0aGlzLl9zb3VyY2UuYWRkcmVzcyB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudElEIC0gVGhlIG5hbWUgb2YgdGhlIGFjY291bnQgdG8gYXNzb2NpYXRlIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJucyB7VG9rZW5Bc3NvY2lhdGVCdWlsZGVyfSAtIFRoaXMgdG9rZW4gYXNzb2NpYXRpb24gYnVpbGRlclxuICAgKi9cbiAgYWNjb3VudChhY2NvdW50SUQ6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudmFsaWRhdGVBY2NvdW50KGFjY291bnRJRCk7XG4gICAgdGhpcy5fYWNjb3VudCA9IGFjY291bnRJRDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB0b2tlbiB0byBhc3NvY2lhdGUgdG8gdGhlIG11bHRpc2lnIHdhbGxldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB0b2tlbiB0byBhc3NvY2lhdGUgdG8gdGhlIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtUb2tlbkFzc29jaWF0ZUJ1aWxkZXJ9IC0gVGhpcyB0b2tlbiBhc3NvY2lhdGlvbiBidWlsZGVyXG4gICAqL1xuICB0b2tlbnModG9rZW5OYW1lOiBzdHJpbmcpOiB0aGlzIHtcbiAgICBjb25zdCB0b2tlbklkID0gZ2V0SGVkZXJhVG9rZW5JZEZyb21OYW1lKHRva2VuTmFtZSk7XG4gICAgaWYgKCF0b2tlbklkKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdVbnN1cHBvcnRlZCB0b2tlbjogJyArIHRva2VuTmFtZSk7XG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGVUb2tlbih0b2tlbklkKTtcbiAgICB0aGlzLl90b2tlbklkcy5wdXNoKHRva2VuSWQhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRUb2tlbkRhdGEoKTogcHJvdG8uVG9rZW5JRFtdIHtcbiAgICByZXR1cm4gdGhpcy5fdG9rZW5JZHMubWFwKGJ1aWxkSGVkZXJhVG9rZW5JRCk7XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkQWNjb3VudERhdGEoKTogcHJvdG8uQWNjb3VudElEIHtcbiAgICBsZXQgYWNjb3VudElkID0gdGhpcy5fYWNjb3VudDtcbiAgICBpZiAoIWFjY291bnRJZCkge1xuICAgICAgYWNjb3VudElkID0gdGhpcy5fc291cmNlLmFkZHJlc3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1aWxkSGVkZXJhQWNjb3VudElEKGFjY291bnRJZCk7XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlQWNjb3VudChhY2NvdW50SUQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghaXNWYWxpZEFkZHJlc3MoYWNjb3VudElEKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignVW5zdXBwb3J0ZWQgYWNjb3VudCBhZGRyZXNzOiAnICsgYWNjb3VudElEKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlVG9rZW4odG9rZW5JZDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3Rva2VuSWRzLmluY2x1ZGVzKHRva2VuSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdSZXBlYXRlZCB0b2tlbiBJRDogJyArIHRva2VuSWQpO1xuICAgIH0gZWxzZSBpZiAoIWlzVmFsaWRIZWRlcmFUb2tlbklEKHRva2VuSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRva2VuIElEOiAnICsgdG9rZW5JZCk7XG4gICAgfVxuICB9XG59XG4iXX0=