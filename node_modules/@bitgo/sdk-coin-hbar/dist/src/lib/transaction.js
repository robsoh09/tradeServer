"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const sha384_1 = require("@stablelib/sha384");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const nacl = __importStar(require("tweetnacl"));
const Long = __importStar(require("long"));
const proto_1 = require("@hashgraph/proto");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
class Transaction extends sdk_core_1.BaseTransaction {
    constructor(_coinConfig) {
        super(_coinConfig);
    }
    /** @inheritdoc */
    canSign(key) {
        return true;
    }
    async sign(keyPair) {
        const keys = keyPair.getKeys(true);
        if (!keys.prv) {
            throw new sdk_core_1.SigningError('Missing private key');
        }
        const secretKey = (0, sdk_core_1.toUint8Array)(keys.prv + keys.pub);
        const signature = nacl.sign.detached(this._hederaTx.bodyBytes, secretKey);
        this.addSignature((0, sdk_core_1.toHex)(signature), keyPair);
    }
    /**
     * Add a signature to this transaction
     *
     * @param {string} signature - The signature to add, in string hex format
     * @param {KeyPair} key - The key of the key that created the signature
     */
    addSignature(signature, key) {
        const sigPair = new proto_1.proto.SignaturePair();
        sigPair.pubKeyPrefix = (0, sdk_core_1.toUint8Array)(key.getKeys(true).pub);
        sigPair.ed25519 = (0, sdk_core_1.toUint8Array)(signature);
        const sigMap = this._hederaTx.sigMap || new proto_1.proto.SignatureMap();
        sigMap.sigPair.push(sigPair);
        this._hederaTx.sigMap = sigMap;
        this._signatures.push(signature);
    }
    /** @inheritdoc */
    toBroadcastFormat() {
        const encoder = proto_1.proto.Transaction;
        return (0, sdk_core_1.toHex)(this.encode(this._hederaTx, encoder));
    }
    /**
     * Sets this transaction payload
     *
     * @param rawTransaction
     */
    fromRawTransaction(rawTransaction) {
        const buffer = typeof rawTransaction === 'string' ? (0, sdk_core_1.toUint8Array)(rawTransaction) : rawTransaction;
        this.bodyBytes(buffer);
        switch (this.txBody.data) {
            case constants_1.HederaTransactionTypes.Transfer:
                this.setTransactionType(sdk_core_1.TransactionType.Send);
                break;
            case constants_1.HederaTransactionTypes.CreateAccount:
                this.setTransactionType(sdk_core_1.TransactionType.WalletInitialization);
                break;
            case constants_1.HederaTransactionTypes.TokenAssociateToAccount:
                this.setTransactionType(sdk_core_1.TransactionType.AssociatedTokenAccountInitialization);
                break;
        }
    }
    /** @inheritdoc */
    toJson() {
        const [acc, time] = this.getTxIdParts();
        const result = {
            id: acc + '@' + time,
            hash: this.getTxHash(),
            data: (0, sdk_core_1.toHex)(this._hederaTx.bodyBytes),
            fee: new bignumber_js_1.default(this._txBody.transactionFee.toString()).toNumber(),
            from: acc,
            startTime: time,
            validDuration: this._txBody.transactionValidDuration.seconds.toString(),
            node: (0, utils_1.stringifyAccountId)(this._txBody.nodeAccountID),
            memo: this._txBody.memo,
        };
        switch (this._txBody.data) {
            case constants_1.HederaTransactionTypes.Transfer:
                result.instructionsData = {
                    type: constants_1.HederaTransactionTypes.Transfer,
                    params: this.getTransferData(),
                };
                result.to = result.instructionsData.params.recipients[0].address;
                result.amount = result.instructionsData.params.recipients[0].amount;
                break;
            case constants_1.HederaTransactionTypes.TokenAssociateToAccount:
                result.instructionsData = {
                    type: constants_1.HederaTransactionTypes.TokenAssociateToAccount,
                    params: this.getAccountAssociateData(),
                };
                break;
        }
        return result;
    }
    /**
     * Get the recipient account and the amount
     * transferred on this transaction
     *
     * @returns { tokenName, Recipient[]} is object consisting of tokenName if it's a token transfer and recipients consisting
     *  the recipient address, the transfer amount, and the token name for token transfer
     */
    getTransferData() {
        var _a, _b, _c, _d, _e;
        const [acc] = this.getTxIdParts();
        const transferData = [];
        const tokenTransfers = ((_a = this._txBody.cryptoTransfer) === null || _a === void 0 ? void 0 : _a.tokenTransfers) || [];
        const transfers = ((_b = tokenTransfers[0]) === null || _b === void 0 ? void 0 : _b.transfers) || ((_d = (_c = this._txBody.cryptoTransfer) === null || _c === void 0 ? void 0 : _c.transfers) === null || _d === void 0 ? void 0 : _d.accountAmounts) || [];
        const tokenName = tokenTransfers.length
            ? (_e = (0, utils_1.getHederaTokenNameFromId)((0, utils_1.stringifyTokenId)(tokenTransfers[0].token))) === null || _e === void 0 ? void 0 : _e.name
            : undefined;
        transfers.forEach((transfer) => {
            const amount = Long.fromValue(transfer.amount);
            if (amount.isPositive() && (0, utils_1.stringifyAccountId)(transfer.accountID) !== acc) {
                transferData.push({
                    address: (0, utils_1.stringifyAccountId)(transfer.accountID),
                    amount: amount.toString(),
                    ...(tokenTransfers.length && {
                        tokenName: tokenName,
                    }),
                });
            }
        });
        return {
            ...(tokenTransfers.length && {
                tokenName: tokenName,
            }),
            recipients: transferData,
        };
    }
    /**
     * Get the recipient account and the amount
     * transferred on this transaction
     *
     * @returns { accountId: string; tokenNames[]} is an object consisting of accountId for the token owner
     *  and list of tokenNames that will be enabled
     */
    getAccountAssociateData() {
        const tokens = this._txBody.tokenAssociate.tokens || [];
        return {
            accountId: (0, utils_1.stringifyAccountId)(this._txBody.tokenAssociate.account),
            tokenNames: tokens.map((token) => (0, utils_1.getHederaTokenNameFromId)((0, utils_1.stringifyTokenId)(token)).name),
        };
    }
    // region getters & setters
    get txBody() {
        return this._txBody;
    }
    get hederaTx() {
        return this._hederaTx;
    }
    /**
     * Sets this transaction body components
     *
     * @param {proto.Transaction} tx - Body Transaction
     */
    body(tx) {
        this._txBody = proto_1.proto.TransactionBody.decode(tx.bodyBytes);
        this._hederaTx = tx;
        this.loadInputsAndOutputs();
    }
    /**
     * Set the transaction type
     *
     * @param {TransactionType} transactionType - The transaction type to be set
     */
    setTransactionType(transactionType) {
        this._type = transactionType;
    }
    /**
     * Decode previous signatures from the inner hedera transaction
     * and save them into the base transaction signature list.
     */
    loadPreviousSignatures() {
        if (this._hederaTx.sigMap && this._hederaTx.sigMap.sigPair) {
            const sigPairs = this._hederaTx.sigMap.sigPair;
            sigPairs.forEach((sigPair) => {
                const signature = sigPair.ed25519;
                if (signature) {
                    this._signatures.push((0, sdk_core_1.toHex)(signature));
                }
            });
        }
    }
    /**
     * Load the input and output data on this transaction using the transaction json
     * if there are outputs. For transactions without outputs (e.g. wallet initializations),
     * this function will not do anything
     */
    loadInputsAndOutputs() {
        const txJson = this.toJson();
        const instruction = txJson.instructionsData;
        const outputs = [];
        const inputs = [];
        switch (instruction === null || instruction === void 0 ? void 0 : instruction.type) {
            case constants_1.HederaTransactionTypes.Transfer:
                let totalAmount = new bignumber_js_1.default(0);
                instruction.params.recipients.forEach((recipient) => {
                    totalAmount = totalAmount.plus(recipient.amount);
                    outputs.push({
                        address: recipient.address,
                        value: recipient.amount,
                        coin: recipient.tokenName || this._coinConfig.name,
                    });
                });
                inputs.push({
                    address: txJson.from,
                    value: totalAmount.toString(),
                    coin: instruction.params.tokenName || this._coinConfig.name,
                });
                break;
            case constants_1.HederaTransactionTypes.TokenAssociateToAccount:
                instruction.params.tokenNames.forEach((tokenName) => {
                    const tokenEntry = {
                        address: instruction.params.accountId,
                        value: '0',
                        coin: tokenName,
                    };
                    inputs.push(tokenEntry);
                    outputs.push(tokenEntry);
                });
                break;
        }
        this._inputs = inputs;
        this._outputs = outputs;
    }
    /**
     * Sets this transaction body components
     *
     * @param {Uint8Array} bytes - Encoded body transaction
     */
    bodyBytes(bytes) {
        this.body(proto_1.proto.Transaction.decode(bytes));
    }
    // endregion
    // region helpers
    /**
     * Returns this hedera transaction id components in a readable format
     *
     * @returns {[string, string]} - Transaction id parts [<account id>, <startTime in seconds>]
     */
    getTxIdParts() {
        if (this._txBody &&
            this._txBody.transactionID &&
            this._txBody.transactionID.accountID &&
            this._txBody.transactionID.transactionValidStart) {
            return [
                (0, utils_1.stringifyAccountId)(this._txBody.transactionID.accountID),
                (0, utils_1.stringifyTxTime)(this._txBody.transactionID.transactionValidStart),
            ];
        }
        throw new Error('Missing transaction id information');
    }
    /**
     * Returns this transaction hash
     *
     * @returns {string} - The transaction hash
     */
    getTxHash() {
        if (!this._txBody.nodeAccountID) {
            throw new Error('Missing transaction node id');
        }
        const _signedTx = new proto_1.proto.SignedTransaction();
        _signedTx.sigMap = this._hederaTx.sigMap;
        _signedTx.bodyBytes = this._hederaTx.bodyBytes;
        const encoder = proto_1.proto.SignedTransaction;
        return this.sha(this.encode(_signedTx, encoder));
    }
    /**
     * Encode an object using the given encoder class
     *
     * @param {proto} obj - The object to be encoded, must be in proto namespace
     * @param encoder - Object encoder
     * @returns {Uint8Array} - Encoded object byte array
     */
    encode(obj, encoder) {
        return encoder.encode(obj).finish();
    }
    /**
     * Returns a sha-384 hash
     *
     * @param {Uint8Array} bytes - Bytes to be hashed
     * @returns {string} - The resulting hash string
     */
    sha(bytes) {
        return (0, sdk_core_1.toHex)((0, sha384_1.hash)(bytes));
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3RyYW5zYWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsOENBQXNIO0FBQ3RILDhDQUF5QztBQUN6QyxnRUFBcUM7QUFFckMsZ0RBQWtDO0FBQ2xDLDJDQUE2QjtBQUM3Qiw0Q0FBeUM7QUFFekMsbUNBQTBHO0FBRTFHLDJDQUFxRDtBQUVyRCxNQUFhLFdBQVksU0FBUSwwQkFBZTtJQUs5QyxZQUFZLFdBQWlDO1FBQzNDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLE9BQU8sQ0FBQyxHQUFZO1FBQ2xCLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBZ0I7UUFDekIsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNiLE1BQU0sSUFBSSx1QkFBWSxDQUFDLHFCQUFxQixDQUFDLENBQUM7U0FDL0M7UUFDRCxNQUFNLFNBQVMsR0FBRyxJQUFBLHVCQUFZLEVBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDcEQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDMUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFBLGdCQUFLLEVBQUMsU0FBUyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsWUFBWSxDQUFDLFNBQWlCLEVBQUUsR0FBWTtRQUMxQyxNQUFNLE9BQU8sR0FB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RDtRQUNELE1BQU0sU0FBUyxHQUFHLElBQUksYUFBSyxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDaEQsU0FBUyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQztRQUN6QyxTQUFTLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDO1FBRS9DLE1BQU0sT0FBTyxHQUFHLGFBQUssQ0FBQyxpQkFBaUIsQ0FBQztRQUN4QyxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ssTUFBTSxDQUNaLEdBQU0sRUFDTixPQUFtQztRQUVuQyxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDdEMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsR0FBRyxDQUFDLEtBQWlCO1FBQ25CLE9BQU8sSUFBQSxnQkFBSyxFQUFDLElBQUEsYUFBSSxFQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDNUIsQ0FBQztDQUNGO0FBN1RELGtDQTZUQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBCYXNlS2V5LCBCYXNlVHJhbnNhY3Rpb24sIEVudHJ5LCBTaWduaW5nRXJyb3IsIHRvSGV4LCB0b1VpbnQ4QXJyYXksIFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBoYXNoIH0gZnJvbSAnQHN0YWJsZWxpYi9zaGEzODQnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgV3JpdGVyIH0gZnJvbSAncHJvdG9idWZqcyc7XG5pbXBvcnQgKiBhcyBuYWNsIGZyb20gJ3R3ZWV0bmFjbCc7XG5pbXBvcnQgKiBhcyBMb25nIGZyb20gJ2xvbmcnO1xuaW1wb3J0IHsgcHJvdG8gfSBmcm9tICdAaGFzaGdyYXBoL3Byb3RvJztcbmltcG9ydCB7IFR4RGF0YSwgUmVjaXBpZW50IH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBzdHJpbmdpZnlBY2NvdW50SWQsIHN0cmluZ2lmeVR4VGltZSwgc3RyaW5naWZ5VG9rZW5JZCwgZ2V0SGVkZXJhVG9rZW5OYW1lRnJvbUlkIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLi8nO1xuaW1wb3J0IHsgSGVkZXJhVHJhbnNhY3Rpb25UeXBlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uIHtcbiAgcHJpdmF0ZSBfaGVkZXJhVHg6IHByb3RvLlRyYW5zYWN0aW9uO1xuICBwcml2YXRlIF90eEJvZHk6IHByb3RvLlRyYW5zYWN0aW9uQm9keTtcbiAgcHJvdGVjdGVkIF90eXBlOiBUcmFuc2FjdGlvblR5cGU7XG5cbiAgY29uc3RydWN0b3IoX2NvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+KSB7XG4gICAgc3VwZXIoX2NvaW5Db25maWcpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGNhblNpZ24oa2V5OiBCYXNlS2V5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBhc3luYyBzaWduKGtleVBhaXI6IEtleVBhaXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBrZXlzID0ga2V5UGFpci5nZXRLZXlzKHRydWUpO1xuICAgIGlmICgha2V5cy5wcnYpIHtcbiAgICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gICAgY29uc3Qgc2VjcmV0S2V5ID0gdG9VaW50OEFycmF5KGtleXMucHJ2ICsga2V5cy5wdWIpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IG5hY2wuc2lnbi5kZXRhY2hlZCh0aGlzLl9oZWRlcmFUeC5ib2R5Qnl0ZXMsIHNlY3JldEtleSk7XG4gICAgdGhpcy5hZGRTaWduYXR1cmUodG9IZXgoc2lnbmF0dXJlKSwga2V5UGFpcik7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgc2lnbmF0dXJlIHRvIHRoaXMgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gYWRkLCBpbiBzdHJpbmcgaGV4IGZvcm1hdFxuICAgKiBAcGFyYW0ge0tleVBhaXJ9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGtleSB0aGF0IGNyZWF0ZWQgdGhlIHNpZ25hdHVyZVxuICAgKi9cbiAgYWRkU2lnbmF0dXJlKHNpZ25hdHVyZTogc3RyaW5nLCBrZXk6IEtleVBhaXIpOiB2b2lkIHtcbiAgICBjb25zdCBzaWdQYWlyID0gbmV3IHByb3RvLlNpZ25hdHVyZVBhaXIoKTtcbiAgICBzaWdQYWlyLnB1YktleVByZWZpeCA9IHRvVWludDhBcnJheShrZXkuZ2V0S2V5cyh0cnVlKS5wdWIpO1xuICAgIHNpZ1BhaXIuZWQyNTUxOSA9IHRvVWludDhBcnJheShzaWduYXR1cmUpO1xuXG4gICAgY29uc3Qgc2lnTWFwID0gdGhpcy5faGVkZXJhVHguc2lnTWFwIHx8IG5ldyBwcm90by5TaWduYXR1cmVNYXAoKTtcbiAgICBzaWdNYXAuc2lnUGFpciEucHVzaChzaWdQYWlyKTtcbiAgICB0aGlzLl9oZWRlcmFUeC5zaWdNYXAgPSBzaWdNYXA7XG4gICAgdGhpcy5fc2lnbmF0dXJlcy5wdXNoKHNpZ25hdHVyZSk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdG9Ccm9hZGNhc3RGb3JtYXQoKTogc3RyaW5nIHtcbiAgICBjb25zdCBlbmNvZGVyID0gcHJvdG8uVHJhbnNhY3Rpb247XG4gICAgcmV0dXJuIHRvSGV4KHRoaXMuZW5jb2RlKHRoaXMuX2hlZGVyYVR4LCBlbmNvZGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIHRyYW5zYWN0aW9uIHBheWxvYWRcbiAgICpcbiAgICogQHBhcmFtIHJhd1RyYW5zYWN0aW9uXG4gICAqL1xuICBmcm9tUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb246IFVpbnQ4QXJyYXkgfCBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBidWZmZXIgPSB0eXBlb2YgcmF3VHJhbnNhY3Rpb24gPT09ICdzdHJpbmcnID8gdG9VaW50OEFycmF5KHJhd1RyYW5zYWN0aW9uKSA6IHJhd1RyYW5zYWN0aW9uO1xuICAgIHRoaXMuYm9keUJ5dGVzKGJ1ZmZlcik7XG4gICAgc3dpdGNoICh0aGlzLnR4Qm9keS5kYXRhKSB7XG4gICAgICBjYXNlIEhlZGVyYVRyYW5zYWN0aW9uVHlwZXMuVHJhbnNmZXI6XG4gICAgICAgIHRoaXMuc2V0VHJhbnNhY3Rpb25UeXBlKFRyYW5zYWN0aW9uVHlwZS5TZW5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhlZGVyYVRyYW5zYWN0aW9uVHlwZXMuQ3JlYXRlQWNjb3VudDpcbiAgICAgICAgdGhpcy5zZXRUcmFuc2FjdGlvblR5cGUoVHJhbnNhY3Rpb25UeXBlLldhbGxldEluaXRpYWxpemF0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhlZGVyYVRyYW5zYWN0aW9uVHlwZXMuVG9rZW5Bc3NvY2lhdGVUb0FjY291bnQ6XG4gICAgICAgIHRoaXMuc2V0VHJhbnNhY3Rpb25UeXBlKFRyYW5zYWN0aW9uVHlwZS5Bc3NvY2lhdGVkVG9rZW5BY2NvdW50SW5pdGlhbGl6YXRpb24pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdG9Kc29uKCk6IFR4RGF0YSB7XG4gICAgY29uc3QgW2FjYywgdGltZV0gPSB0aGlzLmdldFR4SWRQYXJ0cygpO1xuICAgIGNvbnN0IHJlc3VsdDogVHhEYXRhID0ge1xuICAgICAgaWQ6IGFjYyArICdAJyArIHRpbWUsXG4gICAgICBoYXNoOiB0aGlzLmdldFR4SGFzaCgpLCAvLyBUT0RPOiBVcGRhdGUgb25jZSBoZWRlcmEtc2RrIHJlbGVhc2UgdGhpcyBmdW5jdGlvbmFsaXR5IEJHQS0yODRcbiAgICAgIGRhdGE6IHRvSGV4KHRoaXMuX2hlZGVyYVR4LmJvZHlCeXRlcyksXG4gICAgICBmZWU6IG5ldyBCaWdOdW1iZXIodGhpcy5fdHhCb2R5LnRyYW5zYWN0aW9uRmVlIS50b1N0cmluZygpKS50b051bWJlcigpLFxuICAgICAgZnJvbTogYWNjLFxuICAgICAgc3RhcnRUaW1lOiB0aW1lLFxuICAgICAgdmFsaWREdXJhdGlvbjogdGhpcy5fdHhCb2R5LnRyYW5zYWN0aW9uVmFsaWREdXJhdGlvbiEuc2Vjb25kcyEudG9TdHJpbmcoKSxcbiAgICAgIG5vZGU6IHN0cmluZ2lmeUFjY291bnRJZCh0aGlzLl90eEJvZHkubm9kZUFjY291bnRJRCEpLFxuICAgICAgbWVtbzogdGhpcy5fdHhCb2R5Lm1lbW8sXG4gICAgfTtcblxuICAgIHN3aXRjaCAodGhpcy5fdHhCb2R5LmRhdGEpIHtcbiAgICAgIGNhc2UgSGVkZXJhVHJhbnNhY3Rpb25UeXBlcy5UcmFuc2ZlcjpcbiAgICAgICAgcmVzdWx0Lmluc3RydWN0aW9uc0RhdGEgPSB7XG4gICAgICAgICAgdHlwZTogSGVkZXJhVHJhbnNhY3Rpb25UeXBlcy5UcmFuc2ZlcixcbiAgICAgICAgICBwYXJhbXM6IHRoaXMuZ2V0VHJhbnNmZXJEYXRhKCksXG4gICAgICAgIH07XG4gICAgICAgIHJlc3VsdC50byA9IHJlc3VsdC5pbnN0cnVjdGlvbnNEYXRhLnBhcmFtcy5yZWNpcGllbnRzWzBdLmFkZHJlc3M7XG4gICAgICAgIHJlc3VsdC5hbW91bnQgPSByZXN1bHQuaW5zdHJ1Y3Rpb25zRGF0YS5wYXJhbXMucmVjaXBpZW50c1swXS5hbW91bnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIZWRlcmFUcmFuc2FjdGlvblR5cGVzLlRva2VuQXNzb2NpYXRlVG9BY2NvdW50OlxuICAgICAgICByZXN1bHQuaW5zdHJ1Y3Rpb25zRGF0YSA9IHtcbiAgICAgICAgICB0eXBlOiBIZWRlcmFUcmFuc2FjdGlvblR5cGVzLlRva2VuQXNzb2NpYXRlVG9BY2NvdW50LFxuICAgICAgICAgIHBhcmFtczogdGhpcy5nZXRBY2NvdW50QXNzb2NpYXRlRGF0YSgpLFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVjaXBpZW50IGFjY291bnQgYW5kIHRoZSBhbW91bnRcbiAgICogdHJhbnNmZXJyZWQgb24gdGhpcyB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7IHRva2VuTmFtZSwgUmVjaXBpZW50W119IGlzIG9iamVjdCBjb25zaXN0aW5nIG9mIHRva2VuTmFtZSBpZiBpdCdzIGEgdG9rZW4gdHJhbnNmZXIgYW5kIHJlY2lwaWVudHMgY29uc2lzdGluZ1xuICAgKiAgdGhlIHJlY2lwaWVudCBhZGRyZXNzLCB0aGUgdHJhbnNmZXIgYW1vdW50LCBhbmQgdGhlIHRva2VuIG5hbWUgZm9yIHRva2VuIHRyYW5zZmVyXG4gICAqL1xuICBwcml2YXRlIGdldFRyYW5zZmVyRGF0YSgpOiB7IHRva2VuTmFtZT86IHN0cmluZzsgcmVjaXBpZW50czogUmVjaXBpZW50W10gfSB7XG4gICAgY29uc3QgW2FjY10gPSB0aGlzLmdldFR4SWRQYXJ0cygpO1xuICAgIGNvbnN0IHRyYW5zZmVyRGF0YTogUmVjaXBpZW50W10gPSBbXTtcbiAgICBjb25zdCB0b2tlblRyYW5zZmVyczogcHJvdG8uSVRva2VuVHJhbnNmZXJMaXN0W10gPSB0aGlzLl90eEJvZHkuY3J5cHRvVHJhbnNmZXI/LnRva2VuVHJhbnNmZXJzIHx8IFtdO1xuICAgIGNvbnN0IHRyYW5zZmVyczogcHJvdG8uSUFjY291bnRBbW91bnRbXSA9XG4gICAgICB0b2tlblRyYW5zZmVyc1swXT8udHJhbnNmZXJzIHx8IHRoaXMuX3R4Qm9keS5jcnlwdG9UcmFuc2Zlcj8udHJhbnNmZXJzPy5hY2NvdW50QW1vdW50cyB8fCBbXTtcbiAgICBjb25zdCB0b2tlbk5hbWUgPSB0b2tlblRyYW5zZmVycy5sZW5ndGhcbiAgICAgID8gZ2V0SGVkZXJhVG9rZW5OYW1lRnJvbUlkKHN0cmluZ2lmeVRva2VuSWQodG9rZW5UcmFuc2ZlcnNbMF0udG9rZW4hKSk/Lm5hbWVcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgdHJhbnNmZXJzLmZvckVhY2goKHRyYW5zZmVyKSA9PiB7XG4gICAgICBjb25zdCBhbW91bnQgPSBMb25nLmZyb21WYWx1ZSh0cmFuc2Zlci5hbW91bnQhKTtcbiAgICAgIGlmIChhbW91bnQuaXNQb3NpdGl2ZSgpICYmIHN0cmluZ2lmeUFjY291bnRJZCh0cmFuc2Zlci5hY2NvdW50SUQhKSAhPT0gYWNjKSB7XG4gICAgICAgIHRyYW5zZmVyRGF0YS5wdXNoKHtcbiAgICAgICAgICBhZGRyZXNzOiBzdHJpbmdpZnlBY2NvdW50SWQodHJhbnNmZXIuYWNjb3VudElEISksXG4gICAgICAgICAgYW1vdW50OiBhbW91bnQudG9TdHJpbmcoKSxcbiAgICAgICAgICAuLi4odG9rZW5UcmFuc2ZlcnMubGVuZ3RoICYmIHtcbiAgICAgICAgICAgIHRva2VuTmFtZTogdG9rZW5OYW1lLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi4odG9rZW5UcmFuc2ZlcnMubGVuZ3RoICYmIHtcbiAgICAgICAgdG9rZW5OYW1lOiB0b2tlbk5hbWUsXG4gICAgICB9KSxcbiAgICAgIHJlY2lwaWVudHM6IHRyYW5zZmVyRGF0YSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVjaXBpZW50IGFjY291bnQgYW5kIHRoZSBhbW91bnRcbiAgICogdHJhbnNmZXJyZWQgb24gdGhpcyB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7IGFjY291bnRJZDogc3RyaW5nOyB0b2tlbk5hbWVzW119IGlzIGFuIG9iamVjdCBjb25zaXN0aW5nIG9mIGFjY291bnRJZCBmb3IgdGhlIHRva2VuIG93bmVyXG4gICAqICBhbmQgbGlzdCBvZiB0b2tlbk5hbWVzIHRoYXQgd2lsbCBiZSBlbmFibGVkXG4gICAqL1xuICBwcml2YXRlIGdldEFjY291bnRBc3NvY2lhdGVEYXRhKCk6IHsgYWNjb3VudElkOiBzdHJpbmc7IHRva2VuTmFtZXM6IHN0cmluZ1tdIH0ge1xuICAgIGNvbnN0IHRva2VuczogcHJvdG8uSVRva2VuSURbXSA9IHRoaXMuX3R4Qm9keS50b2tlbkFzc29jaWF0ZSEudG9rZW5zIHx8IFtdO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50SWQ6IHN0cmluZ2lmeUFjY291bnRJZCh0aGlzLl90eEJvZHkudG9rZW5Bc3NvY2lhdGUhLmFjY291bnQhKSxcbiAgICAgIHRva2VuTmFtZXM6IHRva2Vucy5tYXAoKHRva2VuOiBwcm90by5JVG9rZW5JRCkgPT4gZ2V0SGVkZXJhVG9rZW5OYW1lRnJvbUlkKHN0cmluZ2lmeVRva2VuSWQodG9rZW4pKSEubmFtZSksXG4gICAgfTtcbiAgfVxuXG4gIC8vIHJlZ2lvbiBnZXR0ZXJzICYgc2V0dGVyc1xuICBnZXQgdHhCb2R5KCk6IHByb3RvLlRyYW5zYWN0aW9uQm9keSB7XG4gICAgcmV0dXJuIHRoaXMuX3R4Qm9keTtcbiAgfVxuXG4gIGdldCBoZWRlcmFUeCgpOiBwcm90by5UcmFuc2FjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuX2hlZGVyYVR4O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyB0cmFuc2FjdGlvbiBib2R5IGNvbXBvbmVudHNcbiAgICpcbiAgICogQHBhcmFtIHtwcm90by5UcmFuc2FjdGlvbn0gdHggLSBCb2R5IFRyYW5zYWN0aW9uXG4gICAqL1xuICBib2R5KHR4OiBwcm90by5UcmFuc2FjdGlvbik6IHZvaWQge1xuICAgIHRoaXMuX3R4Qm9keSA9IHByb3RvLlRyYW5zYWN0aW9uQm9keS5kZWNvZGUodHguYm9keUJ5dGVzKTtcbiAgICB0aGlzLl9oZWRlcmFUeCA9IHR4O1xuICAgIHRoaXMubG9hZElucHV0c0FuZE91dHB1dHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRyYW5zYWN0aW9uIHR5cGVcbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvblR5cGV9IHRyYW5zYWN0aW9uVHlwZSAtIFRoZSB0cmFuc2FjdGlvbiB0eXBlIHRvIGJlIHNldFxuICAgKi9cbiAgc2V0VHJhbnNhY3Rpb25UeXBlKHRyYW5zYWN0aW9uVHlwZTogVHJhbnNhY3Rpb25UeXBlKTogdm9pZCB7XG4gICAgdGhpcy5fdHlwZSA9IHRyYW5zYWN0aW9uVHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgcHJldmlvdXMgc2lnbmF0dXJlcyBmcm9tIHRoZSBpbm5lciBoZWRlcmEgdHJhbnNhY3Rpb25cbiAgICogYW5kIHNhdmUgdGhlbSBpbnRvIHRoZSBiYXNlIHRyYW5zYWN0aW9uIHNpZ25hdHVyZSBsaXN0LlxuICAgKi9cbiAgbG9hZFByZXZpb3VzU2lnbmF0dXJlcygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5faGVkZXJhVHguc2lnTWFwICYmIHRoaXMuX2hlZGVyYVR4LnNpZ01hcC5zaWdQYWlyKSB7XG4gICAgICBjb25zdCBzaWdQYWlycyA9IHRoaXMuX2hlZGVyYVR4LnNpZ01hcC5zaWdQYWlyO1xuICAgICAgc2lnUGFpcnMuZm9yRWFjaCgoc2lnUGFpcikgPT4ge1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWdQYWlyLmVkMjU1MTk7XG4gICAgICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgICB0aGlzLl9zaWduYXR1cmVzLnB1c2godG9IZXgoc2lnbmF0dXJlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSBpbnB1dCBhbmQgb3V0cHV0IGRhdGEgb24gdGhpcyB0cmFuc2FjdGlvbiB1c2luZyB0aGUgdHJhbnNhY3Rpb24ganNvblxuICAgKiBpZiB0aGVyZSBhcmUgb3V0cHV0cy4gRm9yIHRyYW5zYWN0aW9ucyB3aXRob3V0IG91dHB1dHMgKGUuZy4gd2FsbGV0IGluaXRpYWxpemF0aW9ucyksXG4gICAqIHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgZG8gYW55dGhpbmdcbiAgICovXG4gIGxvYWRJbnB1dHNBbmRPdXRwdXRzKCk6IHZvaWQge1xuICAgIGNvbnN0IHR4SnNvbiA9IHRoaXMudG9Kc29uKCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSB0eEpzb24uaW5zdHJ1Y3Rpb25zRGF0YTtcbiAgICBjb25zdCBvdXRwdXRzOiBFbnRyeVtdID0gW107XG4gICAgY29uc3QgaW5wdXRzOiBFbnRyeVtdID0gW107XG5cbiAgICBzd2l0Y2ggKGluc3RydWN0aW9uPy50eXBlKSB7XG4gICAgICBjYXNlIEhlZGVyYVRyYW5zYWN0aW9uVHlwZXMuVHJhbnNmZXI6XG4gICAgICAgIGxldCB0b3RhbEFtb3VudCA9IG5ldyBCaWdOdW1iZXIoMCk7XG4gICAgICAgIGluc3RydWN0aW9uLnBhcmFtcy5yZWNpcGllbnRzLmZvckVhY2goKHJlY2lwaWVudCkgPT4ge1xuICAgICAgICAgIHRvdGFsQW1vdW50ID0gdG90YWxBbW91bnQucGx1cyhyZWNpcGllbnQuYW1vdW50KTtcbiAgICAgICAgICBvdXRwdXRzLnB1c2goe1xuICAgICAgICAgICAgYWRkcmVzczogcmVjaXBpZW50LmFkZHJlc3MsXG4gICAgICAgICAgICB2YWx1ZTogcmVjaXBpZW50LmFtb3VudCxcbiAgICAgICAgICAgIGNvaW46IHJlY2lwaWVudC50b2tlbk5hbWUgfHwgdGhpcy5fY29pbkNvbmZpZy5uYW1lLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaW5wdXRzLnB1c2goe1xuICAgICAgICAgIGFkZHJlc3M6IHR4SnNvbi5mcm9tLFxuICAgICAgICAgIHZhbHVlOiB0b3RhbEFtb3VudC50b1N0cmluZygpLFxuICAgICAgICAgIGNvaW46IGluc3RydWN0aW9uLnBhcmFtcy50b2tlbk5hbWUgfHwgdGhpcy5fY29pbkNvbmZpZy5uYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgSGVkZXJhVHJhbnNhY3Rpb25UeXBlcy5Ub2tlbkFzc29jaWF0ZVRvQWNjb3VudDpcbiAgICAgICAgaW5zdHJ1Y3Rpb24ucGFyYW1zLnRva2VuTmFtZXMuZm9yRWFjaCgodG9rZW5OYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgdG9rZW5FbnRyeTogRW50cnkgPSB7XG4gICAgICAgICAgICBhZGRyZXNzOiBpbnN0cnVjdGlvbi5wYXJhbXMuYWNjb3VudElkLFxuICAgICAgICAgICAgdmFsdWU6ICcwJyxcbiAgICAgICAgICAgIGNvaW46IHRva2VuTmFtZSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlucHV0cy5wdXNoKHRva2VuRW50cnkpO1xuICAgICAgICAgIG91dHB1dHMucHVzaCh0b2tlbkVudHJ5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl9pbnB1dHMgPSBpbnB1dHM7XG4gICAgdGhpcy5fb3V0cHV0cyA9IG91dHB1dHM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIHRyYW5zYWN0aW9uIGJvZHkgY29tcG9uZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzIC0gRW5jb2RlZCBib2R5IHRyYW5zYWN0aW9uXG4gICAqL1xuICBib2R5Qnl0ZXMoYnl0ZXM6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICB0aGlzLmJvZHkocHJvdG8uVHJhbnNhY3Rpb24uZGVjb2RlKGJ5dGVzKSk7XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIGhlbHBlcnNcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBoZWRlcmEgdHJhbnNhY3Rpb24gaWQgY29tcG9uZW50cyBpbiBhIHJlYWRhYmxlIGZvcm1hdFxuICAgKlxuICAgKiBAcmV0dXJucyB7W3N0cmluZywgc3RyaW5nXX0gLSBUcmFuc2FjdGlvbiBpZCBwYXJ0cyBbPGFjY291bnQgaWQ+LCA8c3RhcnRUaW1lIGluIHNlY29uZHM+XVxuICAgKi9cbiAgZ2V0VHhJZFBhcnRzKCk6IFtzdHJpbmcsIHN0cmluZ10ge1xuICAgIGlmIChcbiAgICAgIHRoaXMuX3R4Qm9keSAmJlxuICAgICAgdGhpcy5fdHhCb2R5LnRyYW5zYWN0aW9uSUQgJiZcbiAgICAgIHRoaXMuX3R4Qm9keS50cmFuc2FjdGlvbklELmFjY291bnRJRCAmJlxuICAgICAgdGhpcy5fdHhCb2R5LnRyYW5zYWN0aW9uSUQudHJhbnNhY3Rpb25WYWxpZFN0YXJ0XG4gICAgKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBzdHJpbmdpZnlBY2NvdW50SWQodGhpcy5fdHhCb2R5LnRyYW5zYWN0aW9uSUQuYWNjb3VudElEKSxcbiAgICAgICAgc3RyaW5naWZ5VHhUaW1lKHRoaXMuX3R4Qm9keS50cmFuc2FjdGlvbklELnRyYW5zYWN0aW9uVmFsaWRTdGFydCksXG4gICAgICBdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdHJhbnNhY3Rpb24gaWQgaW5mb3JtYXRpb24nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgdHJhbnNhY3Rpb24gaGFzaFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAqL1xuICBnZXRUeEhhc2goKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuX3R4Qm9keS5ub2RlQWNjb3VudElEKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdHJhbnNhY3Rpb24gbm9kZSBpZCcpO1xuICAgIH1cbiAgICBjb25zdCBfc2lnbmVkVHggPSBuZXcgcHJvdG8uU2lnbmVkVHJhbnNhY3Rpb24oKTtcbiAgICBfc2lnbmVkVHguc2lnTWFwID0gdGhpcy5faGVkZXJhVHguc2lnTWFwO1xuICAgIF9zaWduZWRUeC5ib2R5Qnl0ZXMgPSB0aGlzLl9oZWRlcmFUeC5ib2R5Qnl0ZXM7XG5cbiAgICBjb25zdCBlbmNvZGVyID0gcHJvdG8uU2lnbmVkVHJhbnNhY3Rpb247XG4gICAgcmV0dXJuIHRoaXMuc2hhKHRoaXMuZW5jb2RlKF9zaWduZWRUeCwgZW5jb2RlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhbiBvYmplY3QgdXNpbmcgdGhlIGdpdmVuIGVuY29kZXIgY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtwcm90b30gb2JqIC0gVGhlIG9iamVjdCB0byBiZSBlbmNvZGVkLCBtdXN0IGJlIGluIHByb3RvIG5hbWVzcGFjZVxuICAgKiBAcGFyYW0gZW5jb2RlciAtIE9iamVjdCBlbmNvZGVyXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSAtIEVuY29kZWQgb2JqZWN0IGJ5dGUgYXJyYXlcbiAgICovXG4gIHByaXZhdGUgZW5jb2RlPEN0b3JGbiBleHRlbmRzIHsgbmV3ICgpOiBUIH0sIFQgZXh0ZW5kcyB7IGNvbnN0cnVjdG9yOiBDdG9yRm4gfT4oXG4gICAgb2JqOiBULFxuICAgIGVuY29kZXI6IHsgZW5jb2RlKGFyZzogVCk6IFdyaXRlciB9XG4gICk6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiBlbmNvZGVyLmVuY29kZShvYmopLmZpbmlzaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzaGEtMzg0IGhhc2hcbiAgICpcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlcyAtIEJ5dGVzIHRvIGJlIGhhc2hlZFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSByZXN1bHRpbmcgaGFzaCBzdHJpbmdcbiAgICovXG4gIHNoYShieXRlczogVWludDhBcnJheSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRvSGV4KGhhc2goYnl0ZXMpKTtcbiAgfVxufVxuIl19