"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hbar = void 0;
/**
 * @prettier
 */
const statics_1 = require("@bitgo/statics");
const sdk_core_1 = require("@bitgo/sdk-core");
const bignumber_js_1 = require("bignumber.js");
const stellar = __importStar(require("stellar-sdk"));
const seedValidator_1 = require("./seedValidator");
const lib_1 = require("./lib");
const Utils = __importStar(require("./lib/utils"));
const _ = __importStar(require("lodash"));
const sdk_1 = require("@hashgraph/sdk");
const keyPair_1 = require("./lib/keyPair");
class Hbar extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    getChain() {
        return this._staticsCoin.name;
    }
    getFamily() {
        return this._staticsCoin.family;
    }
    getFullName() {
        return this._staticsCoin.fullName;
    }
    getBaseFactor() {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    }
    static createInstance(bitgo, staticsCoin) {
        return new Hbar(bitgo, staticsCoin);
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return false;
    }
    /**
     * Checks if this is a valid base58 or hex address
     * @param address
     */
    isValidAddress(address) {
        try {
            return Utils.isValidAddressWithPaymentId(address);
        }
        catch (e) {
            return false;
        }
    }
    /** inheritdoc */
    deriveKeyWithSeed() {
        throw new sdk_core_1.NotSupported('method deriveKeyWithSeed not supported for eddsa curve');
    }
    /** inheritdoc */
    generateKeyPair(seed) {
        const keyPair = seed ? new lib_1.KeyPair({ seed }) : new lib_1.KeyPair();
        const keys = keyPair.getKeys();
        if (!keys.prv) {
            throw new Error('Keypair generation failed to generate a prv');
        }
        return {
            pub: keys.pub,
            prv: keys.prv,
        };
    }
    /** inheritdoc */
    generateRootKeyPair(seed) {
        const keyPair = seed ? new lib_1.KeyPair({ seed }) : new lib_1.KeyPair();
        const keys = keyPair.getKeys(true);
        if (!keys.prv) {
            throw new Error('Missing prv in key generation.');
        }
        return { prv: keys.prv + keys.pub, pub: keys.pub };
    }
    async parseTransaction(params) {
        return {};
    }
    /**
     * Check if address is valid, then make sure it matches the base address.
     *
     * @param {VerifyAddressOptions} params
     * @param {String} params.address - the address to verify
     * @param {String} params.baseAddress - the base address from the wallet
     */
    async isWalletAddress(params) {
        const { address, baseAddress } = params;
        return Utils.isSameBaseAddress(address, baseAddress);
    }
    async verifyTransaction(params) {
        // asset name to transfer amount map
        const coinConfig = statics_1.coins.get(this.getChain());
        const { txParams: txParams, txPrebuild: txPrebuild, memo: memo } = params;
        const transaction = new lib_1.Transaction(coinConfig);
        if (!txPrebuild.txHex) {
            throw new Error('missing required tx prebuild property txHex');
        }
        transaction.fromRawTransaction(txPrebuild.txHex);
        const explainTxParams = {
            txHex: txPrebuild.txHex,
            feeInfo: txPrebuild.feeInfo,
            memo: memo,
        };
        const explainedTx = await this.explainTransaction(explainTxParams);
        if (!txParams.recipients) {
            throw new Error('missing required tx params property recipients');
        }
        // for enabletoken, recipient output amount is 0
        const recipients = txParams.recipients.map((recipient) => ({
            ...recipient,
            amount: txParams.type === 'enabletoken' ? '0' : recipient.amount,
        }));
        if (coinConfig.isToken) {
            recipients.forEach((recipient) => {
                if (recipient.tokenName !== undefined && recipient.tokenName !== coinConfig.name) {
                    throw new Error('Incorrect token name specified in recipients');
                }
                recipient.tokenName = coinConfig.name;
            });
        }
        // verify recipients from params and explainedTx
        const filteredRecipients = recipients === null || recipients === void 0 ? void 0 : recipients.map((recipient) => _.pick(recipient, ['address', 'amount', 'tokenName']));
        const filteredOutputs = explainedTx.outputs.map((output) => _.pick(output, ['address', 'amount', 'tokenName']));
        if (!_.isEqual(filteredOutputs, filteredRecipients)) {
            throw new Error('Tx outputs does not match with expected txParams recipients');
        }
        return true;
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param params.wallet.addressVersion {String} this is the version of the Algorand multisig address generation format
     * @returns Promise<SignedTransaction>
     */
    async signTransaction(params) {
        const factory = this.getBuilderFactory();
        const txBuilder = factory.from(params.txPrebuild.txHex);
        txBuilder.sign({ key: params.prv });
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new Error('Invalid messaged passed to signMessage');
        }
        const response = {
            txHex: transaction.toBroadcastFormat(),
        };
        return transaction.signature.length >= 2 ? response : { halfSigned: response };
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     * @return {Buffer} A signature over the given message using the given key
     */
    async signMessage(key, message) {
        const msg = Buffer.isBuffer(message) ? message.toString('utf8') : message;
        // reconstitute keys and sign
        return Buffer.from(new lib_1.KeyPair({ prv: key.prv }).signMessage(msg));
    }
    /**
     * Builds a funds recovery transaction without BitGo.
     * We need to do three queries during this:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     * @param params
     */
    async recover(params) {
        const isUnsignedSweep = (params.backupKey.startsWith(keyPair_1.PUBLIC_KEY_PREFIX) && params.userKey.startsWith(keyPair_1.PUBLIC_KEY_PREFIX)) ||
            (Utils.isValidPublicKey(params.userKey) && Utils.isValidPublicKey(params.backupKey));
        // Validate the root address
        if (!this.isValidAddress(params.rootAddress)) {
            throw new Error('invalid rootAddress, got: ' + params.rootAddress);
        }
        // Validate the destination address
        if (!this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination, got: ' + params.recoveryDestination);
        }
        // Validate nodeId
        if (params.nodeId && !Utils.isValidAddress(params.nodeId)) {
            throw new Error('invalid nodeId, got: ' + params.nodeId);
        }
        // validate fee
        if (params.maxFee && !Utils.isValidAmount(params.maxFee)) {
            throw new Error('invalid maxFee, got: ' + params.maxFee);
        }
        // validate startTime
        if (params.startTime) {
            Utils.validateStartTime(params.startTime);
        }
        if (isUnsignedSweep && !params.startTime) {
            throw new Error('start time is required for unsigned sweep');
        }
        if (!isUnsignedSweep && !params.walletPassphrase) {
            throw new Error('walletPassphrase is required for non-bitgo recovery');
        }
        let userPrv;
        let backUp;
        if (!isUnsignedSweep) {
            try {
                userPrv = this.bitgo.decrypt({ input: params.userKey, password: params.walletPassphrase });
                backUp = this.bitgo.decrypt({ input: params.backupKey, password: params.walletPassphrase });
            }
            catch (e) {
                throw new Error('unable to decrypt userKey or backupKey with the walletPassphrase provided, got error: ' + e.message);
            }
        }
        // validate userKey for unsigned sweep
        if (isUnsignedSweep && !Utils.isValidPublicKey(params.userKey)) {
            throw new Error('invalid userKey, got: ' + params.userKey);
        }
        // validate backupKey for unsigned sweep
        if (isUnsignedSweep && !Utils.isValidPublicKey(params.backupKey)) {
            throw new Error('invalid backupKey, got: ' + params.backupKey);
        }
        const { address: destinationAddress, memoId } = Utils.getAddressDetails(params.recoveryDestination);
        const client = this.getHbarClient();
        const balance = await this.getAccountBalance(params.rootAddress, client);
        const nativeBalance = sdk_1.Hbar.fromString(balance.hbars).toTinybars().toString();
        const fee = params.maxFee ? params.maxFee : '10000000';
        if (new bignumber_js_1.BigNumber(nativeBalance).isZero() || new bignumber_js_1.BigNumber(nativeBalance).isLessThanOrEqualTo(fee)) {
            throw new Error('Insufficient balance to recover, got balance: ' + nativeBalance + ' fee: ' + fee);
        }
        const nodeId = params.nodeId ? params.nodeId : '0.0.3';
        const spendableAmount = new bignumber_js_1.BigNumber(nativeBalance).minus(fee).toString();
        const txBuilder = this.getBuilderFactory().getTransferBuilder();
        txBuilder.node({ nodeId });
        txBuilder.fee({ fee });
        txBuilder.source({ address: params.rootAddress });
        txBuilder.send({ address: destinationAddress, amount: spendableAmount });
        txBuilder.validDuration(180);
        if (memoId) {
            txBuilder.memo(memoId);
        }
        if (params.startTime) {
            txBuilder.startTime(Utils.normalizeStarttime(params.startTime));
        }
        if (isUnsignedSweep) {
            const tx = await txBuilder.build();
            const txJson = tx.toJson();
            return {
                txHex: tx.toBroadcastFormat(),
                coin: this.getChain(),
                id: txJson.id,
                startTime: txJson.startTime,
                validDuration: txJson.validDuration,
                nodeId: txJson.node,
                memo: txJson.memo,
                userKey: params.userKey,
                backupKey: params.backupKey,
                bitgoKey: params.bitgoKey,
                maxFee: fee,
                address: params.rootAddress,
                recipients: txJson.instructionsData.params.recipients,
                amount: txJson.amount,
                json: txJson,
            };
        }
        txBuilder.sign({ key: userPrv });
        txBuilder.sign({ key: backUp });
        const tx = await txBuilder.build();
        return {
            tx: tx.toBroadcastFormat(),
            id: tx.toJson().id,
            coin: this.getChain(),
            startTime: tx.toJson().startTime,
            nodeId: tx.toJson().node,
        };
    }
    /**
     * Explain a Hedera transaction from txHex
     * @param params
     */
    async explainTransaction(params) {
        var _a;
        const txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
        if (!txHex) {
            throw new Error('missing explain tx parameters');
        }
        const factory = this.getBuilderFactory();
        const txBuilder = factory.from(txHex);
        const tx = await txBuilder.build();
        const txJson = tx.toJson();
        let outputAmount = new bignumber_js_1.BigNumber(0);
        const outputs = [];
        // TODO(BG-24809): get the memo from the toJson
        let memo = '';
        if (params.memo) {
            memo = params.memo.value;
        }
        switch (txJson.instructionsData.type) {
            case 'cryptoTransfer':
                const recipients = txJson.instructionsData.params.recipients || [];
                recipients.forEach((recipient) => {
                    if (!recipient.tokenName) {
                        // token transfer doesn't change outputAmount
                        outputAmount = outputAmount.plus(recipient.amount);
                    }
                    outputs.push({
                        address: recipient.address,
                        amount: recipient.amount.toString(),
                        memo,
                        ...(recipient.tokenName && {
                            tokenName: recipient.tokenName,
                        }),
                    });
                });
                break;
            case 'tokenAssociate':
                const tokens = txJson.instructionsData.params.tokenNames || [];
                const accountId = txJson.instructionsData.params.accountId;
                tokens.forEach((token) => {
                    outputs.push({
                        address: accountId,
                        amount: '0',
                        memo,
                        tokenName: token,
                    });
                });
                break;
            default:
                throw new Error('Transaction format outside of cryptoTransfer not supported for explanation.');
        }
        const displayOrder = [
            'id',
            'outputAmount',
            'changeAmount',
            'outputs',
            'changeOutputs',
            'fee',
            'timestamp',
            'expiration',
            'memo',
        ];
        return {
            displayOrder,
            id: txJson.id,
            outputs,
            outputAmount: outputAmount.toString(),
            changeOutputs: [],
            changeAmount: '0',
            fee: ((_a = params.feeInfo) === null || _a === void 0 ? void 0 : _a.fee) || txJson.fee,
            timestamp: txJson.startTime,
            expiration: txJson.validDuration,
        };
    }
    isStellarSeed(seed) {
        return seedValidator_1.SeedValidator.isValidEd25519SeedForCoin(seed, statics_1.CoinFamily.XLM);
    }
    convertFromStellarSeed(seed) {
        // assume this is a trust custodial seed if its a valid ed25519 prv
        if (!this.isStellarSeed(seed) || seedValidator_1.SeedValidator.hasCompetingSeedFormats(seed)) {
            return null;
        }
        if (seedValidator_1.SeedValidator.isValidEd25519SeedForCoin(seed, statics_1.CoinFamily.XLM)) {
            const keyFromSeed = new lib_1.KeyPair({ seed: stellar.StrKey.decodeEd25519SecretSeed(seed) });
            const keys = keyFromSeed.getKeys();
            if (keys !== undefined && keys.prv) {
                return keys.prv;
            }
        }
        return null;
    }
    isValidPub(pub) {
        return Utils.isValidPublicKey(pub);
    }
    supportsDeriveKeyWithSeed() {
        return false;
    }
    getTokenEnablementConfig() {
        return {
            requiresTokenEnablement: true,
            supportsMultipleTokenEnablements: true,
        };
    }
    getBuilderFactory() {
        return new lib_1.TransactionBuilderFactory(statics_1.coins.get(this.getChain()));
    }
    getHbarClient() {
        const client = this.bitgo.getEnv() === 'prod' ? sdk_1.Client.forMainnet() : sdk_1.Client.forTestnet();
        return client;
    }
    async getAccountBalance(accountId, client) {
        try {
            const balance = await new sdk_1.AccountBalanceQuery().setAccountId(accountId).execute(client);
            return balance.toJSON();
        }
        catch (e) {
            throw new Error('Failed to get account balance, error: ' + e.message);
        }
    }
    async broadcastTransaction({ serializedSignedTransaction, startTime, }) {
        try {
            const hbarTx = sdk_1.Transaction.fromBytes(Utils.toUint8Array(serializedSignedTransaction));
            if (startTime) {
                Utils.isValidTimeString(startTime);
                while (!Utils.shouldBroadcastNow(startTime)) {
                    await Utils.sleep(1000);
                }
            }
            return this.clientBroadcastTransaction(hbarTx);
        }
        catch (e) {
            throw new Error('Failed to broadcast transaction, error: ' + e.message);
        }
    }
    async clientBroadcastTransaction(hbarTx) {
        const client = this.getHbarClient();
        const transactionResponse = await hbarTx.execute(client);
        const transactionReceipt = await transactionResponse.getReceipt(client);
        return { txId: transactionResponse.transactionId.toString(), status: transactionReceipt.status.toString() };
    }
}
exports.Hbar = Hbar;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGJhci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9oYmFyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0dBRUc7QUFDSCw0Q0FBZ0Y7QUFDaEYsOENBbUJ5QjtBQUN6QiwrQ0FBeUM7QUFDekMscURBQXVDO0FBQ3ZDLG1EQUFnRDtBQUNoRCwrQkFBdUY7QUFDdkYsbURBQXFDO0FBQ3JDLDBDQUE0QjtBQUM1Qix3Q0FNd0I7QUFDeEIsMkNBQWtEO0FBdUZsRCxNQUFhLElBQUssU0FBUSxtQkFBUTtJQUdoQyxZQUFZLEtBQWdCLEVBQUUsV0FBdUM7UUFDbkUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRWIsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7U0FDdkU7UUFFRCxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztJQUNsQyxDQUFDO0lBRUQsUUFBUTtRQUNOLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7SUFDaEMsQ0FBQztJQUVELFNBQVM7UUFDUCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDO0lBQ2xDLENBQUM7SUFFRCxXQUFXO1FBQ1QsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQztJQUNwQyxDQUFDO0lBRUQsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFnQixFQUFFLFdBQXVDO1FBQzdFLE9BQU8sSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRDs7O09BR0c7SUFDSCx3QkFBd0I7UUFDdEIsT0FBTyxLQUFLLENB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LEVBQUU7b0JBQzNDLE1BQU0sS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDekI7YUFDRjtZQUVELE9BQU8sSUFBSSxDQUFDLDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ2hEO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixNQUFNLElBQUksS0FBSyxDQUFDLDBDQUEwQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUN6RTtJQUNILENBQUM7SUFFRCxLQUFLLENBQUMsMEJBQTBCLENBQUMsTUFBdUI7UUFDdEQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3BDLE1BQU0sbUJBQW1CLEdBQUcsTUFBTSxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3pELE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFeEUsT0FBTyxFQUFFLElBQUksRUFBRSxtQkFBbUIsQ0FBQyxhQUFhLENBQUMsUUFBUSxFQUFFLEVBQUUsTUFBTSxFQUFFLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDO0lBQzlHLENBQUM7Q0FDRjtBQXRlRCxvQkFzZUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgeyBDb2luRmFtaWx5LCBCYXNlQ29pbiBhcyBTdGF0aWNzQmFzZUNvaW4sIGNvaW5zIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHtcbiAgQmFzZUNvaW4sXG4gIEJpdEdvQmFzZSxcbiAgS2V5UGFpcixcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBTaWduZWRUcmFuc2FjdGlvbixcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMgYXMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zLFxuICBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFRyYW5zYWN0aW9uRmVlLFxuICBUcmFuc2FjdGlvblJlY2lwaWVudCBhcyBSZWNpcGllbnQsXG4gIFRyYW5zYWN0aW9uUHJlYnVpbGQgYXMgQmFzZVRyYW5zYWN0aW9uUHJlYnVpbGQsXG4gIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24sXG4gIE1lbW8sXG4gIFRva2VuRW5hYmxlbWVudENvbmZpZyxcbiAgQmFzZUJyb2FkY2FzdFRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgQmFzZUJyb2FkY2FzdFRyYW5zYWN0aW9uUmVzdWx0LFxuICBOb3RTdXBwb3J0ZWQsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0ICogYXMgc3RlbGxhciBmcm9tICdzdGVsbGFyLXNkayc7XG5pbXBvcnQgeyBTZWVkVmFsaWRhdG9yIH0gZnJvbSAnLi9zZWVkVmFsaWRhdG9yJztcbmltcG9ydCB7IEtleVBhaXIgYXMgSGJhcktleVBhaXIsIFRyYW5zYWN0aW9uQnVpbGRlckZhY3RvcnksIFRyYW5zYWN0aW9uIH0gZnJvbSAnLi9saWInO1xuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi9saWIvdXRpbHMnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHtcbiAgQ2xpZW50LFxuICBUcmFuc2FjdGlvbiBhcyBIYmFyVHJhbnNhY3Rpb24sXG4gIEFjY291bnRCYWxhbmNlUXVlcnksXG4gIEFjY291bnRCYWxhbmNlSnNvbixcbiAgSGJhciBhcyBIYmFyVW5pdCxcbn0gZnJvbSAnQGhhc2hncmFwaC9zZGsnO1xuaW1wb3J0IHsgUFVCTElDX0tFWV9QUkVGSVggfSBmcm9tICcuL2xpYi9rZXlQYWlyJztcblxuZXhwb3J0IGludGVyZmFjZSBIYmFyU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwcnY6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUeEluZm8ge1xuICByZWNpcGllbnRzOiBSZWNpcGllbnRbXTtcbiAgZnJvbTogc3RyaW5nO1xuICB0eGlkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhIZXg6IHN0cmluZztcbiAgdHhJbmZvOiBUeEluZm87XG4gIGZlZUluZm86IFRyYW5zYWN0aW9uRmVlO1xuICBzb3VyY2U6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhIZXg/OiBzdHJpbmc7XG4gIGhhbGZTaWduZWQ/OiB7XG4gICAgdHhIZXg6IHN0cmluZztcbiAgfTtcbiAgZmVlSW5mbz86IFRyYW5zYWN0aW9uRmVlO1xuICAvLyBUT0RPKEJHLTI0ODA5KTogZ2V0IHRoZSBtZW1vIGZyb20gdGhlIHRvSnNvblxuICBtZW1vPzoge1xuICAgIHR5cGU6IHN0cmluZztcbiAgICB2YWx1ZTogc3RyaW5nO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhiYXJWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBtZW1vPzogTWVtbztcbn1cblxuaW50ZXJmYWNlIFZlcmlmeUFkZHJlc3NPcHRpb25zIGV4dGVuZHMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zIHtcbiAgYmFzZUFkZHJlc3M6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyeU9wdGlvbnMge1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgdXNlcktleTogc3RyaW5nO1xuICByb290QWRkcmVzczogc3RyaW5nO1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7XG4gIGJpdGdvS2V5Pzogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICBtYXhGZWU/OiBzdHJpbmc7XG4gIG5vZGVJZD86IHN0cmluZztcbiAgc3RhcnRUaW1lPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUmVjb3ZlcnlJbmZvIHtcbiAgaWQ6IHN0cmluZztcbiAgdHg6IHN0cmluZztcbiAgY29pbjogc3RyaW5nO1xuICBzdGFydFRpbWU6IHN0cmluZztcbiAgbm9kZUlkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT2ZmbGluZVZhdWx0VHhJbmZvIHtcbiAgdHhIZXg6IHN0cmluZztcbiAgdXNlcktleTogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgYml0Z29LZXk/OiBzdHJpbmc7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgY29pbjogc3RyaW5nO1xuICBtYXhGZWU6IHN0cmluZztcbiAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gIGFtb3VudDogc3RyaW5nO1xuICBzdGFydFRpbWU6IHN0cmluZztcbiAgdmFsaWREdXJhdGlvbjogc3RyaW5nO1xuICBub2RlSWQ6IHN0cmluZztcbiAgbWVtbzogc3RyaW5nO1xuICBqc29uPzogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJyb2FkY2FzdFRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIEJhc2VCcm9hZGNhc3RUcmFuc2FjdGlvbk9wdGlvbnMge1xuICBzdGFydFRpbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnJvYWRjYXN0VHJhbnNhY3Rpb25SZXN1bHQgZXh0ZW5kcyBCYXNlQnJvYWRjYXN0VHJhbnNhY3Rpb25SZXN1bHQge1xuICBzdGF0dXM/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBIYmFyIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3N0YXRpY3NDb2luOiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+O1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHb0Jhc2UsIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPikge1xuICAgIHN1cGVyKGJpdGdvKTtcblxuICAgIGlmICghc3RhdGljc0NvaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgc3RhdGljc0NvaW4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0aWNzQ29pbiA9IHN0YXRpY3NDb2luO1xuICB9XG5cbiAgZ2V0Q2hhaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLm5hbWU7XG4gIH1cblxuICBnZXRGYW1pbHkoKTogQ29pbkZhbWlseSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZhbWlseTtcbiAgfVxuXG4gIGdldEZ1bGxOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5mdWxsTmFtZTtcbiAgfVxuXG4gIGdldEJhc2VGYWN0b3IoKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGF0aWNzQ29pbi5kZWNpbWFsUGxhY2VzKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R29CYXNlLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBIYmFyKGJpdGdvLCBzdGF0aWNzQ29pbik7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBmb3Igc2VuZGluZyB2YWx1ZSBvZiAwXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gc2VuZCAwIHZhbHVlLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHZhbHVlbGVzc1RyYW5zZmVyQWxsb3dlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgaXMgYSB2YWxpZCBiYXNlNTggb3IgaGV4IGFkZHJlc3NcbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gVXRpbHMuaXNWYWxpZEFkZHJlc3NXaXRoUGF5bWVudElkKGFkZHJlc3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKiogaW5oZXJpdGRvYyAqL1xuICBkZXJpdmVLZXlXaXRoU2VlZCgpOiB7IGRlcml2YXRpb25QYXRoOiBzdHJpbmc7IGtleTogc3RyaW5nIH0ge1xuICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQoJ21ldGhvZCBkZXJpdmVLZXlXaXRoU2VlZCBub3Qgc3VwcG9ydGVkIGZvciBlZGRzYSBjdXJ2ZScpO1xuICB9XG5cbiAgLyoqIGluaGVyaXRkb2MgKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBjb25zdCBrZXlQYWlyID0gc2VlZCA/IG5ldyBIYmFyS2V5UGFpcih7IHNlZWQgfSkgOiBuZXcgSGJhcktleVBhaXIoKTtcbiAgICBjb25zdCBrZXlzID0ga2V5UGFpci5nZXRLZXlzKCk7XG5cbiAgICBpZiAoIWtleXMucHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXBhaXIgZ2VuZXJhdGlvbiBmYWlsZWQgdG8gZ2VuZXJhdGUgYSBwcnYnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHViOiBrZXlzLnB1YixcbiAgICAgIHBydjoga2V5cy5wcnYsXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBpbmhlcml0ZG9jICovXG4gIGdlbmVyYXRlUm9vdEtleVBhaXIoc2VlZD86IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIGNvbnN0IGtleVBhaXIgPSBzZWVkID8gbmV3IEhiYXJLZXlQYWlyKHsgc2VlZCB9KSA6IG5ldyBIYmFyS2V5UGFpcigpO1xuICAgIGNvbnN0IGtleXMgPSBrZXlQYWlyLmdldEtleXModHJ1ZSk7XG4gICAgaWYgKCFrZXlzLnBydikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHBydiBpbiBrZXkgZ2VuZXJhdGlvbi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcHJ2OiBrZXlzLnBydiArIGtleXMucHViLCBwdWI6IGtleXMucHViIH07XG4gIH1cblxuICBhc3luYyBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFkZHJlc3MgaXMgdmFsaWQsIHRoZW4gbWFrZSBzdXJlIGl0IG1hdGNoZXMgdGhlIGJhc2UgYWRkcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIHtWZXJpZnlBZGRyZXNzT3B0aW9uc30gcGFyYW1zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuYWRkcmVzcyAtIHRoZSBhZGRyZXNzIHRvIHZlcmlmeVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmJhc2VBZGRyZXNzIC0gdGhlIGJhc2UgYWRkcmVzcyBmcm9tIHRoZSB3YWxsZXRcbiAgICovXG4gIGFzeW5jIGlzV2FsbGV0QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBiYXNlQWRkcmVzcyB9ID0gcGFyYW1zO1xuICAgIHJldHVybiBVdGlscy5pc1NhbWVCYXNlQWRkcmVzcyhhZGRyZXNzLCBiYXNlQWRkcmVzcyk7XG4gIH1cblxuICBhc3luYyB2ZXJpZnlUcmFuc2FjdGlvbihwYXJhbXM6IEhiYXJWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAvLyBhc3NldCBuYW1lIHRvIHRyYW5zZmVyIGFtb3VudCBtYXBcbiAgICBjb25zdCBjb2luQ29uZmlnID0gY29pbnMuZ2V0KHRoaXMuZ2V0Q2hhaW4oKSk7XG4gICAgY29uc3QgeyB0eFBhcmFtczogdHhQYXJhbXMsIHR4UHJlYnVpbGQ6IHR4UHJlYnVpbGQsIG1lbW86IG1lbW8gfSA9IHBhcmFtcztcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbihjb2luQ29uZmlnKTtcbiAgICBpZiAoIXR4UHJlYnVpbGQudHhIZXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCB0eCBwcmVidWlsZCBwcm9wZXJ0eSB0eEhleCcpO1xuICAgIH1cblxuICAgIHRyYW5zYWN0aW9uLmZyb21SYXdUcmFuc2FjdGlvbih0eFByZWJ1aWxkLnR4SGV4KTtcbiAgICBjb25zdCBleHBsYWluVHhQYXJhbXM6IEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMgPSB7XG4gICAgICB0eEhleDogdHhQcmVidWlsZC50eEhleCxcbiAgICAgIGZlZUluZm86IHR4UHJlYnVpbGQuZmVlSW5mbyxcbiAgICAgIG1lbW86IG1lbW8sXG4gICAgfTtcbiAgICBjb25zdCBleHBsYWluZWRUeCA9IGF3YWl0IHRoaXMuZXhwbGFpblRyYW5zYWN0aW9uKGV4cGxhaW5UeFBhcmFtcyk7XG5cbiAgICBpZiAoIXR4UGFyYW1zLnJlY2lwaWVudHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCB0eCBwYXJhbXMgcHJvcGVydHkgcmVjaXBpZW50cycpO1xuICAgIH1cblxuICAgIC8vIGZvciBlbmFibGV0b2tlbiwgcmVjaXBpZW50IG91dHB1dCBhbW91bnQgaXMgMFxuICAgIGNvbnN0IHJlY2lwaWVudHMgPSB0eFBhcmFtcy5yZWNpcGllbnRzLm1hcCgocmVjaXBpZW50KSA9PiAoe1xuICAgICAgLi4ucmVjaXBpZW50LFxuICAgICAgYW1vdW50OiB0eFBhcmFtcy50eXBlID09PSAnZW5hYmxldG9rZW4nID8gJzAnIDogcmVjaXBpZW50LmFtb3VudCxcbiAgICB9KSk7XG4gICAgaWYgKGNvaW5Db25maWcuaXNUb2tlbikge1xuICAgICAgcmVjaXBpZW50cy5mb3JFYWNoKChyZWNpcGllbnQpID0+IHtcbiAgICAgICAgaWYgKHJlY2lwaWVudC50b2tlbk5hbWUgIT09IHVuZGVmaW5lZCAmJiByZWNpcGllbnQudG9rZW5OYW1lICE9PSBjb2luQ29uZmlnLm5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCB0b2tlbiBuYW1lIHNwZWNpZmllZCBpbiByZWNpcGllbnRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjaXBpZW50LnRva2VuTmFtZSA9IGNvaW5Db25maWcubmFtZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHZlcmlmeSByZWNpcGllbnRzIGZyb20gcGFyYW1zIGFuZCBleHBsYWluZWRUeFxuICAgIGNvbnN0IGZpbHRlcmVkUmVjaXBpZW50cyA9IHJlY2lwaWVudHM/Lm1hcCgocmVjaXBpZW50KSA9PiBfLnBpY2socmVjaXBpZW50LCBbJ2FkZHJlc3MnLCAnYW1vdW50JywgJ3Rva2VuTmFtZSddKSk7XG4gICAgY29uc3QgZmlsdGVyZWRPdXRwdXRzID0gZXhwbGFpbmVkVHgub3V0cHV0cy5tYXAoKG91dHB1dCkgPT4gXy5waWNrKG91dHB1dCwgWydhZGRyZXNzJywgJ2Ftb3VudCcsICd0b2tlbk5hbWUnXSkpO1xuXG4gICAgaWYgKCFfLmlzRXF1YWwoZmlsdGVyZWRPdXRwdXRzLCBmaWx0ZXJlZFJlY2lwaWVudHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R4IG91dHB1dHMgZG9lcyBub3QgbWF0Y2ggd2l0aCBleHBlY3RlZCB0eFBhcmFtcyByZWNpcGllbnRzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZCB7T2JqZWN0fSBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgcGxhdGZvcm1cbiAgICogQHBhcmFtIHBhcmFtcy5wcnYge1N0cmluZ30gdXNlciBwcnZcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXQuYWRkcmVzc1ZlcnNpb24ge1N0cmluZ30gdGhpcyBpcyB0aGUgdmVyc2lvbiBvZiB0aGUgQWxnb3JhbmQgbXVsdGlzaWcgYWRkcmVzcyBnZW5lcmF0aW9uIGZvcm1hdFxuICAgKiBAcmV0dXJucyBQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPlxuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogSGJhclNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuZ2V0QnVpbGRlckZhY3RvcnkoKTtcbiAgICBjb25zdCB0eEJ1aWxkZXIgPSBmYWN0b3J5LmZyb20ocGFyYW1zLnR4UHJlYnVpbGQudHhIZXgpO1xuICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiBwYXJhbXMucHJ2IH0pO1xuXG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcblxuICAgIGlmICghdHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlZCBwYXNzZWQgdG8gc2lnbk1lc3NhZ2UnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgIHR4SGV4OiB0cmFuc2FjdGlvbi50b0Jyb2FkY2FzdEZvcm1hdCgpLFxuICAgIH07XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLnNpZ25hdHVyZS5sZW5ndGggPj0gMiA/IHJlc3BvbnNlIDogeyBoYWxmU2lnbmVkOiByZXNwb25zZSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gbWVzc2FnZSB3aXRoIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICogQHJldHVybiB7QnVmZmVyfSBBIHNpZ25hdHVyZSBvdmVyIHRoZSBnaXZlbiBtZXNzYWdlIHVzaW5nIHRoZSBnaXZlbiBrZXlcbiAgICovXG4gIGFzeW5jIHNpZ25NZXNzYWdlKGtleTogS2V5UGFpciwgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgICBjb25zdCBtc2cgPSBCdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkgPyBtZXNzYWdlLnRvU3RyaW5nKCd1dGY4JykgOiBtZXNzYWdlO1xuICAgIC8vIHJlY29uc3RpdHV0ZSBrZXlzIGFuZCBzaWduXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ldyBIYmFyS2V5UGFpcih7IHBydjoga2V5LnBydiB9KS5zaWduTWVzc2FnZShtc2cpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBmdW5kcyByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRob3V0IEJpdEdvLlxuICAgKiBXZSBuZWVkIHRvIGRvIHRocmVlIHF1ZXJpZXMgZHVyaW5nIHRoaXM6XG4gICAqIDEpIE5vZGUgcXVlcnkgLSBob3cgbXVjaCBtb25leSBpcyBpbiB0aGUgYWNjb3VudFxuICAgKiAyKSBCdWlsZCB0cmFuc2FjdGlvbiAtIGJ1aWxkIG91ciB0cmFuc2FjdGlvbiBmb3IgdGhlIGFtb3VudFxuICAgKiAzKSBTZW5kIHNpZ25lZCBidWlsZCAtIHNlbmQgb3VyIHNpZ25lZCBidWlsZCB0byBhIHB1YmxpYyBub2RlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIHB1YmxpYyBhc3luYyByZWNvdmVyKHBhcmFtczogUmVjb3ZlcnlPcHRpb25zKTogUHJvbWlzZTxSZWNvdmVyeUluZm8gfCBPZmZsaW5lVmF1bHRUeEluZm8+IHtcbiAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPVxuICAgICAgKHBhcmFtcy5iYWNrdXBLZXkuc3RhcnRzV2l0aChQVUJMSUNfS0VZX1BSRUZJWCkgJiYgcGFyYW1zLnVzZXJLZXkuc3RhcnRzV2l0aChQVUJMSUNfS0VZX1BSRUZJWCkpIHx8XG4gICAgICAoVXRpbHMuaXNWYWxpZFB1YmxpY0tleShwYXJhbXMudXNlcktleSkgJiYgVXRpbHMuaXNWYWxpZFB1YmxpY0tleShwYXJhbXMuYmFja3VwS2V5KSk7XG5cbiAgICAvLyBWYWxpZGF0ZSB0aGUgcm9vdCBhZGRyZXNzXG4gICAgaWYgKCF0aGlzLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yb290QWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByb290QWRkcmVzcywgZ290OiAnICsgcGFyYW1zLnJvb3RBZGRyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSB0aGUgZGVzdGluYXRpb24gYWRkcmVzc1xuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZWNvdmVyeURlc3RpbmF0aW9uLCBnb3Q6ICcgKyBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbik7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgbm9kZUlkXG4gICAgaWYgKHBhcmFtcy5ub2RlSWQgJiYgIVV0aWxzLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5ub2RlSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbm9kZUlkLCBnb3Q6ICcgKyBwYXJhbXMubm9kZUlkKTtcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBmZWVcbiAgICBpZiAocGFyYW1zLm1heEZlZSAmJiAhVXRpbHMuaXNWYWxpZEFtb3VudChwYXJhbXMubWF4RmVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1heEZlZSwgZ290OiAnICsgcGFyYW1zLm1heEZlZSk7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgc3RhcnRUaW1lXG5cbiAgICBpZiAocGFyYW1zLnN0YXJ0VGltZSkge1xuICAgICAgVXRpbHMudmFsaWRhdGVTdGFydFRpbWUocGFyYW1zLnN0YXJ0VGltZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5zaWduZWRTd2VlcCAmJiAhcGFyYW1zLnN0YXJ0VGltZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCB0aW1lIGlzIHJlcXVpcmVkIGZvciB1bnNpZ25lZCBzd2VlcCcpO1xuICAgIH1cblxuICAgIGlmICghaXNVbnNpZ25lZFN3ZWVwICYmICFwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3YWxsZXRQYXNzcGhyYXNlIGlzIHJlcXVpcmVkIGZvciBub24tYml0Z28gcmVjb3ZlcnknKTtcbiAgICB9XG5cbiAgICBsZXQgdXNlclBydjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGxldCBiYWNrVXA6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBpZiAoIWlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdXNlclBydiA9IHRoaXMuYml0Z28uZGVjcnlwdCh7IGlucHV0OiBwYXJhbXMudXNlcktleSwgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIH0pO1xuICAgICAgICBiYWNrVXAgPSB0aGlzLmJpdGdvLmRlY3J5cHQoeyBpbnB1dDogcGFyYW1zLmJhY2t1cEtleSwgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ3VuYWJsZSB0byBkZWNyeXB0IHVzZXJLZXkgb3IgYmFja3VwS2V5IHdpdGggdGhlIHdhbGxldFBhc3NwaHJhc2UgcHJvdmlkZWQsIGdvdCBlcnJvcjogJyArIGUubWVzc2FnZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIHVzZXJLZXkgZm9yIHVuc2lnbmVkIHN3ZWVwXG4gICAgaWYgKGlzVW5zaWduZWRTd2VlcCAmJiAhVXRpbHMuaXNWYWxpZFB1YmxpY0tleShwYXJhbXMudXNlcktleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB1c2VyS2V5LCBnb3Q6ICcgKyBwYXJhbXMudXNlcktleSk7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgYmFja3VwS2V5IGZvciB1bnNpZ25lZCBzd2VlcFxuICAgIGlmIChpc1Vuc2lnbmVkU3dlZXAgJiYgIVV0aWxzLmlzVmFsaWRQdWJsaWNLZXkocGFyYW1zLmJhY2t1cEtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiYWNrdXBLZXksIGdvdDogJyArIHBhcmFtcy5iYWNrdXBLZXkpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgYWRkcmVzczogZGVzdGluYXRpb25BZGRyZXNzLCBtZW1vSWQgfSA9IFV0aWxzLmdldEFkZHJlc3NEZXRhaWxzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKTtcblxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0SGJhckNsaWVudCgpO1xuXG4gICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEJhbGFuY2UocGFyYW1zLnJvb3RBZGRyZXNzLCBjbGllbnQpO1xuICAgIGNvbnN0IG5hdGl2ZUJhbGFuY2UgPSBIYmFyVW5pdC5mcm9tU3RyaW5nKGJhbGFuY2UuaGJhcnMpLnRvVGlueWJhcnMoKS50b1N0cmluZygpO1xuICAgIGNvbnN0IGZlZSA9IHBhcmFtcy5tYXhGZWUgPyBwYXJhbXMubWF4RmVlIDogJzEwMDAwMDAwJztcblxuICAgIGlmIChuZXcgQmlnTnVtYmVyKG5hdGl2ZUJhbGFuY2UpLmlzWmVybygpIHx8IG5ldyBCaWdOdW1iZXIobmF0aXZlQmFsYW5jZSkuaXNMZXNzVGhhbk9yRXF1YWxUbyhmZWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3VmZmljaWVudCBiYWxhbmNlIHRvIHJlY292ZXIsIGdvdCBiYWxhbmNlOiAnICsgbmF0aXZlQmFsYW5jZSArICcgZmVlOiAnICsgZmVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlSWQgPSBwYXJhbXMubm9kZUlkID8gcGFyYW1zLm5vZGVJZCA6ICcwLjAuMyc7XG5cbiAgICBjb25zdCBzcGVuZGFibGVBbW91bnQgPSBuZXcgQmlnTnVtYmVyKG5hdGl2ZUJhbGFuY2UpLm1pbnVzKGZlZSkudG9TdHJpbmcoKTtcblxuICAgIGNvbnN0IHR4QnVpbGRlciA9IHRoaXMuZ2V0QnVpbGRlckZhY3RvcnkoKS5nZXRUcmFuc2ZlckJ1aWxkZXIoKTtcbiAgICB0eEJ1aWxkZXIubm9kZSh7IG5vZGVJZCB9KTtcbiAgICB0eEJ1aWxkZXIuZmVlKHsgZmVlIH0pO1xuICAgIHR4QnVpbGRlci5zb3VyY2UoeyBhZGRyZXNzOiBwYXJhbXMucm9vdEFkZHJlc3MgfSk7XG4gICAgdHhCdWlsZGVyLnNlbmQoeyBhZGRyZXNzOiBkZXN0aW5hdGlvbkFkZHJlc3MsIGFtb3VudDogc3BlbmRhYmxlQW1vdW50IH0pO1xuICAgIHR4QnVpbGRlci52YWxpZER1cmF0aW9uKDE4MCk7XG5cbiAgICBpZiAobWVtb0lkKSB7XG4gICAgICB0eEJ1aWxkZXIubWVtbyhtZW1vSWQpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuc3RhcnRUaW1lKSB7XG4gICAgICB0eEJ1aWxkZXIuc3RhcnRUaW1lKFV0aWxzLm5vcm1hbGl6ZVN0YXJ0dGltZShwYXJhbXMuc3RhcnRUaW1lKSk7XG4gICAgfVxuICAgIGlmIChpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgICBjb25zdCB0eEpzb24gPSB0eC50b0pzb24oKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR4SGV4OiB0eC50b0Jyb2FkY2FzdEZvcm1hdCgpLFxuICAgICAgICBjb2luOiB0aGlzLmdldENoYWluKCksXG4gICAgICAgIGlkOiB0eEpzb24uaWQsXG4gICAgICAgIHN0YXJ0VGltZTogdHhKc29uLnN0YXJ0VGltZSxcbiAgICAgICAgdmFsaWREdXJhdGlvbjogdHhKc29uLnZhbGlkRHVyYXRpb24sXG4gICAgICAgIG5vZGVJZDogdHhKc29uLm5vZGUsXG4gICAgICAgIG1lbW86IHR4SnNvbi5tZW1vLFxuICAgICAgICB1c2VyS2V5OiBwYXJhbXMudXNlcktleSxcbiAgICAgICAgYmFja3VwS2V5OiBwYXJhbXMuYmFja3VwS2V5LFxuICAgICAgICBiaXRnb0tleTogcGFyYW1zLmJpdGdvS2V5LFxuICAgICAgICBtYXhGZWU6IGZlZSxcbiAgICAgICAgYWRkcmVzczogcGFyYW1zLnJvb3RBZGRyZXNzLFxuICAgICAgICByZWNpcGllbnRzOiB0eEpzb24uaW5zdHJ1Y3Rpb25zRGF0YS5wYXJhbXMucmVjaXBpZW50cyxcbiAgICAgICAgYW1vdW50OiB0eEpzb24uYW1vdW50LFxuICAgICAgICBqc29uOiB0eEpzb24sXG4gICAgICB9O1xuICAgIH1cblxuICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiB1c2VyUHJ2IH0pO1xuICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiBiYWNrVXAgfSk7XG5cbiAgICBjb25zdCB0eCA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR4OiB0eC50b0Jyb2FkY2FzdEZvcm1hdCgpLFxuICAgICAgaWQ6IHR4LnRvSnNvbigpLmlkLFxuICAgICAgY29pbjogdGhpcy5nZXRDaGFpbigpLFxuICAgICAgc3RhcnRUaW1lOiB0eC50b0pzb24oKS5zdGFydFRpbWUsXG4gICAgICBub2RlSWQ6IHR4LnRvSnNvbigpLm5vZGUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluIGEgSGVkZXJhIHRyYW5zYWN0aW9uIGZyb20gdHhIZXhcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgZXhwbGFpblRyYW5zYWN0aW9uKHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IHR4SGV4ID0gcGFyYW1zLnR4SGV4IHx8IChwYXJhbXMuaGFsZlNpZ25lZCAmJiBwYXJhbXMuaGFsZlNpZ25lZC50eEhleCk7XG4gICAgaWYgKCF0eEhleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGV4cGxhaW4gdHggcGFyYW1ldGVycycpO1xuICAgIH1cblxuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmdldEJ1aWxkZXJGYWN0b3J5KCk7XG4gICAgY29uc3QgdHhCdWlsZGVyID0gZmFjdG9yeS5mcm9tKHR4SGV4KTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgIGNvbnN0IHR4SnNvbiA9IHR4LnRvSnNvbigpO1xuXG4gICAgbGV0IG91dHB1dEFtb3VudCA9IG5ldyBCaWdOdW1iZXIoMCk7XG4gICAgY29uc3Qgb3V0cHV0czogeyBhZGRyZXNzOiBzdHJpbmc7IGFtb3VudDogc3RyaW5nOyBtZW1vOiBzdHJpbmc7IHRva2VuTmFtZT86IHN0cmluZyB9W10gPSBbXTtcbiAgICAvLyBUT0RPKEJHLTI0ODA5KTogZ2V0IHRoZSBtZW1vIGZyb20gdGhlIHRvSnNvblxuICAgIGxldCBtZW1vID0gJyc7XG4gICAgaWYgKHBhcmFtcy5tZW1vKSB7XG4gICAgICBtZW1vID0gcGFyYW1zLm1lbW8udmFsdWU7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eEpzb24uaW5zdHJ1Y3Rpb25zRGF0YS50eXBlKSB7XG4gICAgICBjYXNlICdjcnlwdG9UcmFuc2Zlcic6XG4gICAgICAgIGNvbnN0IHJlY2lwaWVudHMgPSB0eEpzb24uaW5zdHJ1Y3Rpb25zRGF0YS5wYXJhbXMucmVjaXBpZW50cyB8fCBbXTtcbiAgICAgICAgcmVjaXBpZW50cy5mb3JFYWNoKChyZWNpcGllbnQpID0+IHtcbiAgICAgICAgICBpZiAoIXJlY2lwaWVudC50b2tlbk5hbWUpIHtcbiAgICAgICAgICAgIC8vIHRva2VuIHRyYW5zZmVyIGRvZXNuJ3QgY2hhbmdlIG91dHB1dEFtb3VudFxuICAgICAgICAgICAgb3V0cHV0QW1vdW50ID0gb3V0cHV0QW1vdW50LnBsdXMocmVjaXBpZW50LmFtb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dHMucHVzaCh7XG4gICAgICAgICAgICBhZGRyZXNzOiByZWNpcGllbnQuYWRkcmVzcyxcbiAgICAgICAgICAgIGFtb3VudDogcmVjaXBpZW50LmFtb3VudC50b1N0cmluZygpLFxuICAgICAgICAgICAgbWVtbyxcbiAgICAgICAgICAgIC4uLihyZWNpcGllbnQudG9rZW5OYW1lICYmIHtcbiAgICAgICAgICAgICAgdG9rZW5OYW1lOiByZWNpcGllbnQudG9rZW5OYW1lLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndG9rZW5Bc3NvY2lhdGUnOlxuICAgICAgICBjb25zdCB0b2tlbnMgPSB0eEpzb24uaW5zdHJ1Y3Rpb25zRGF0YS5wYXJhbXMudG9rZW5OYW1lcyB8fCBbXTtcbiAgICAgICAgY29uc3QgYWNjb3VudElkID0gdHhKc29uLmluc3RydWN0aW9uc0RhdGEucGFyYW1zLmFjY291bnRJZDtcbiAgICAgICAgdG9rZW5zLmZvckVhY2goKHRva2VuKSA9PiB7XG4gICAgICAgICAgb3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGFjY291bnRJZCxcbiAgICAgICAgICAgIGFtb3VudDogJzAnLFxuICAgICAgICAgICAgbWVtbyxcbiAgICAgICAgICAgIHRva2VuTmFtZTogdG9rZW4sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBmb3JtYXQgb3V0c2lkZSBvZiBjcnlwdG9UcmFuc2ZlciBub3Qgc3VwcG9ydGVkIGZvciBleHBsYW5hdGlvbi4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBkaXNwbGF5T3JkZXIgPSBbXG4gICAgICAnaWQnLFxuICAgICAgJ291dHB1dEFtb3VudCcsXG4gICAgICAnY2hhbmdlQW1vdW50JyxcbiAgICAgICdvdXRwdXRzJyxcbiAgICAgICdjaGFuZ2VPdXRwdXRzJyxcbiAgICAgICdmZWUnLFxuICAgICAgJ3RpbWVzdGFtcCcsXG4gICAgICAnZXhwaXJhdGlvbicsXG4gICAgICAnbWVtbycsXG4gICAgXTtcblxuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5T3JkZXIsXG4gICAgICBpZDogdHhKc29uLmlkLFxuICAgICAgb3V0cHV0cyxcbiAgICAgIG91dHB1dEFtb3VudDogb3V0cHV0QW1vdW50LnRvU3RyaW5nKCksXG4gICAgICBjaGFuZ2VPdXRwdXRzOiBbXSwgLy8gYWNjb3VudCBiYXNlZCBkb2VzIG5vdCB1c2UgY2hhbmdlIG91dHB1dHNcbiAgICAgIGNoYW5nZUFtb3VudDogJzAnLCAvLyBhY2NvdW50IGJhc2UgZG9lcyBub3QgbWFrZSBjaGFuZ2VcbiAgICAgIGZlZTogcGFyYW1zLmZlZUluZm8/LmZlZSB8fCB0eEpzb24uZmVlLCAvLyBpbiB0aGUgaW5zdGFuY2Ugbm8gZmVlSW5mbyBpcyBwYXNzZWQgaW4gYXMgYSBwYXJhbSwgc2hvdyB0aGUgZmVlIGdpdmVuIGJ5IHRoZSB0eEpTT05cbiAgICAgIHRpbWVzdGFtcDogdHhKc29uLnN0YXJ0VGltZSxcbiAgICAgIGV4cGlyYXRpb246IHR4SnNvbi52YWxpZER1cmF0aW9uLFxuICAgIH0gYXMgYW55O1xuICB9XG5cbiAgaXNTdGVsbGFyU2VlZChzZWVkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gU2VlZFZhbGlkYXRvci5pc1ZhbGlkRWQyNTUxOVNlZWRGb3JDb2luKHNlZWQsIENvaW5GYW1pbHkuWExNKTtcbiAgfVxuXG4gIGNvbnZlcnRGcm9tU3RlbGxhclNlZWQoc2VlZDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgLy8gYXNzdW1lIHRoaXMgaXMgYSB0cnVzdCBjdXN0b2RpYWwgc2VlZCBpZiBpdHMgYSB2YWxpZCBlZDI1NTE5IHBydlxuICAgIGlmICghdGhpcy5pc1N0ZWxsYXJTZWVkKHNlZWQpIHx8IFNlZWRWYWxpZGF0b3IuaGFzQ29tcGV0aW5nU2VlZEZvcm1hdHMoc2VlZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChTZWVkVmFsaWRhdG9yLmlzVmFsaWRFZDI1NTE5U2VlZEZvckNvaW4oc2VlZCwgQ29pbkZhbWlseS5YTE0pKSB7XG4gICAgICBjb25zdCBrZXlGcm9tU2VlZCA9IG5ldyBIYmFyS2V5UGFpcih7IHNlZWQ6IHN0ZWxsYXIuU3RyS2V5LmRlY29kZUVkMjU1MTlTZWNyZXRTZWVkKHNlZWQpIH0pO1xuICAgICAgY29uc3Qga2V5cyA9IGtleUZyb21TZWVkLmdldEtleXMoKTtcbiAgICAgIGlmIChrZXlzICE9PSB1bmRlZmluZWQgJiYga2V5cy5wcnYpIHtcbiAgICAgICAgcmV0dXJuIGtleXMucHJ2O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBVdGlscy5pc1ZhbGlkUHVibGljS2V5KHB1Yik7XG4gIH1cblxuICBzdXBwb3J0c0Rlcml2ZUtleVdpdGhTZWVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRUb2tlbkVuYWJsZW1lbnRDb25maWcoKTogVG9rZW5FbmFibGVtZW50Q29uZmlnIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWlyZXNUb2tlbkVuYWJsZW1lbnQ6IHRydWUsXG4gICAgICBzdXBwb3J0c011bHRpcGxlVG9rZW5FbmFibGVtZW50czogdHJ1ZSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRCdWlsZGVyRmFjdG9yeSgpOiBUcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5IHtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uQnVpbGRlckZhY3RvcnkoY29pbnMuZ2V0KHRoaXMuZ2V0Q2hhaW4oKSkpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRIYmFyQ2xpZW50KCk6IENsaWVudCB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5iaXRnby5nZXRFbnYoKSA9PT0gJ3Byb2QnID8gQ2xpZW50LmZvck1haW5uZXQoKSA6IENsaWVudC5mb3JUZXN0bmV0KCk7XG4gICAgcmV0dXJuIGNsaWVudDtcbiAgfVxuXG4gIGFzeW5jIGdldEFjY291bnRCYWxhbmNlKGFjY291bnRJZDogc3RyaW5nLCBjbGllbnQ6IENsaWVudCk6IFByb21pc2U8QWNjb3VudEJhbGFuY2VKc29uPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBuZXcgQWNjb3VudEJhbGFuY2VRdWVyeSgpLnNldEFjY291bnRJZChhY2NvdW50SWQpLmV4ZWN1dGUoY2xpZW50KTtcblxuICAgICAgcmV0dXJuIGJhbGFuY2UudG9KU09OKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IGFjY291bnQgYmFsYW5jZSwgZXJyb3I6ICcgKyBlLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGJyb2FkY2FzdFRyYW5zYWN0aW9uKHtcbiAgICBzZXJpYWxpemVkU2lnbmVkVHJhbnNhY3Rpb24sXG4gICAgc3RhcnRUaW1lLFxuICB9OiBCcm9hZGNhc3RUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPEJyb2FkY2FzdFRyYW5zYWN0aW9uUmVzdWx0PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhiYXJUeCA9IEhiYXJUcmFuc2FjdGlvbi5mcm9tQnl0ZXMoVXRpbHMudG9VaW50OEFycmF5KHNlcmlhbGl6ZWRTaWduZWRUcmFuc2FjdGlvbikpO1xuXG4gICAgICBpZiAoc3RhcnRUaW1lKSB7XG4gICAgICAgIFV0aWxzLmlzVmFsaWRUaW1lU3RyaW5nKHN0YXJ0VGltZSk7XG4gICAgICAgIHdoaWxlICghVXRpbHMuc2hvdWxkQnJvYWRjYXN0Tm93KHN0YXJ0VGltZSkpIHtcbiAgICAgICAgICBhd2FpdCBVdGlscy5zbGVlcCgxMDAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jbGllbnRCcm9hZGNhc3RUcmFuc2FjdGlvbihoYmFyVHgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGJyb2FkY2FzdCB0cmFuc2FjdGlvbiwgZXJyb3I6ICcgKyBlLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNsaWVudEJyb2FkY2FzdFRyYW5zYWN0aW9uKGhiYXJUeDogSGJhclRyYW5zYWN0aW9uKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRIYmFyQ2xpZW50KCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25SZXNwb25zZSA9IGF3YWl0IGhiYXJUeC5leGVjdXRlKGNsaWVudCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25SZWNlaXB0ID0gYXdhaXQgdHJhbnNhY3Rpb25SZXNwb25zZS5nZXRSZWNlaXB0KGNsaWVudCk7XG5cbiAgICByZXR1cm4geyB0eElkOiB0cmFuc2FjdGlvblJlc3BvbnNlLnRyYW5zYWN0aW9uSWQudG9TdHJpbmcoKSwgc3RhdHVzOiB0cmFuc2FjdGlvblJlY2VpcHQuc3RhdHVzLnRvU3RyaW5nKCkgfTtcbiAgfVxufVxuIl19