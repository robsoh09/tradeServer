"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Xlm = void 0;
const assert_1 = __importDefault(require("assert"));
const _ = __importStar(require("lodash"));
const querystring = __importStar(require("querystring"));
const url = __importStar(require("url"));
const request = __importStar(require("superagent"));
const stellar = __importStar(require("stellar-sdk"));
const bignumber_js_1 = require("bignumber.js");
const sdk_core_1 = require("@bitgo/sdk-core");
const sdk_api_1 = require("@bitgo/sdk-api");
const getStellarKeys_1 = require("./getStellarKeys");
class Xlm extends sdk_core_1.BaseCoin {
    constructor(bitgo) {
        super(bitgo);
        this.homeDomain = 'bitgo.com'; // used for reverse federation lookup
    }
    static createInstance(bitgo) {
        return new Xlm(bitgo);
    }
    getStellarNetwork() {
        return stellar.Networks.PUBLIC;
    }
    /**
     * Factor between the base unit and its smallest subdivison
     */
    getBaseFactor() {
        return 1e7;
    }
    /**
     * Identifier for the blockchain which supports this coin
     */
    getChain() {
        return 'xlm';
    }
    /**
     * Identifier for the coin family
     */
    getFamily() {
        return 'xlm';
    }
    /**
     * Complete human-readable name of this coin
     */
    getFullName() {
        return 'Stellar';
    }
    /**
     * Url at which the stellar federation server can be reached
     */
    getFederationServerUrl() {
        return sdk_core_1.common.Environments[this.bitgo.getEnv()].stellarFederationServerUrl;
    }
    /**
     * Url at which horizon can be reached
     */
    getHorizonUrl() {
        return 'https://horizon.stellar.org';
    }
    /** inheritdoc */
    generateKeyPair(seed) {
        const pair = seed ? stellar.Keypair.fromRawEd25519Seed(seed) : stellar.Keypair.random();
        return {
            pub: pair.publicKey(),
            prv: pair.secret(),
        };
    }
    /**
     * Get decoded ed25519 public key from raw data
     *
     * @param pub Raw public key
     * @returns Encoded public key
     */
    getPubFromRaw(pub) {
        return stellar.StrKey.encodeEd25519PublicKey(Buffer.from(pub, 'hex'));
    }
    /**
     * Get decoded ed25519 private key from raw data
     *
     * @param prv Raw private key
     * @returns Encoded private key
     */
    getPrvFromRaw(prv) {
        return stellar.StrKey.encodeEd25519SecretSeed(Buffer.from(prv, 'hex'));
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param pub the pub to be checked
     * @returns is it valid?
     */
    isValidPub(pub) {
        return stellar.StrKey.isValidEd25519PublicKey(pub);
    }
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param prv the prv to be checked
     * @returns is it valid?
     */
    isValidPrv(prv) {
        return stellar.StrKey.isValidEd25519SecretSeed(prv);
    }
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId memo id
     * @returns true if memo id is valid
     */
    isValidMemoId(memoId) {
        let memoIdNumber;
        try {
            stellar.Memo.id(memoId); // throws if the value is not valid memo id
            memoIdNumber = new bignumber_js_1.BigNumber(memoId);
        }
        catch (e) {
            return false;
        }
        return memoIdNumber.gte(0) && memoIdNumber.lt(Xlm.maxMemoId);
    }
    supportsDeriveKeyWithSeed() {
        return false;
    }
    /**
     * Evaluates whether a memo is valid
     *
     * @param value value of the memo
     * @param type type of the memo
     * @returns true if value and type are a valid
     */
    isValidMemo({ value, type }) {
        if (!value || !type) {
            return false;
        }
        try {
            // throws if the value is not valid for the type
            // valid types are: 'id', 'text', 'hash', 'return'
            // See https://www.stellar.org/developers/guides/concepts/transactions.html#memo
            stellar.Memo[type](value);
        }
        catch (e) {
            return false;
        }
        return true;
    }
    /**
     * Create instance of stellar.MuxedAccount from M address
     * See: https://developers.stellar.org/docs/glossary/muxed-accounts
     */
    getMuxedAccount(address) {
        try {
            return stellar.MuxedAccount.fromAddress(address, '0');
        }
        catch (e) {
            throw new Error(`invalid muxed address: ${address}`);
        }
    }
    /**
     * Return boolean indicating whether a muxed address is valid
     * See: https://developers.stellar.org/docs/glossary/muxed-accounts
     *
     * @param address
     * @returns {boolean}
     */
    isValidMuxedAddress(address) {
        if (!_.isString(address) || !address.startsWith('M')) {
            return false;
        }
        try {
            // return true if muxed account is valid or throw
            return !!stellar.MuxedAccount.fromAddress(address, '0');
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Minimum balance of a 2-of-3 multisig wallet
     * @returns minimum balance in stroops
     */
    async getMinimumReserve() {
        const server = new stellar.Server(this.getHorizonUrl());
        const horizonLedgerInfo = await server.ledgers().order('desc').limit(1).call();
        if (!horizonLedgerInfo) {
            throw new Error('unable to connect to Horizon for reserve requirement data');
        }
        const baseReserve = horizonLedgerInfo.records[0].base_reserve_in_stroops;
        // 2-of-3 wallets have a minimum reserve of 5x the base reserve
        return 5 * baseReserve;
    }
    /**
     * Transaction fee for each operation
     * @returns transaction fee in stroops
     */
    async getBaseTransactionFee() {
        const server = new stellar.Server(this.getHorizonUrl());
        const horizonLedgerInfo = await server.ledgers().order('desc').limit(1).call();
        if (!horizonLedgerInfo) {
            throw new Error('unable to connect to Horizon for reserve requirement data');
        }
        return horizonLedgerInfo.records[0].base_fee_in_stroops;
    }
    /**
     * Process address into address and memo id
     *
     * @param address the address
     * @returns object containing address and memo id
     */
    getAddressDetails(address) {
        if (address.startsWith('M')) {
            if (this.isValidMuxedAddress(address)) {
                const muxedAccount = this.getMuxedAccount(address);
                return {
                    baseAddress: muxedAccount.baseAccount().accountId(),
                    address,
                    id: muxedAccount.id(),
                    memoId: undefined,
                };
            }
            else {
                throw new sdk_core_1.InvalidAddressError(`invalid muxed address: ${address}`);
            }
        }
        const destinationDetails = url.parse(address);
        const destinationAddress = destinationDetails.pathname || '';
        if (!destinationAddress || !stellar.StrKey.isValidEd25519PublicKey(destinationAddress)) {
            throw new Error(`invalid address: ${address}`);
        }
        // address doesn't have a memo id
        if (destinationDetails.pathname === address) {
            return {
                baseAddress: address,
                address: address,
                id: undefined,
                memoId: undefined,
            };
        }
        if (!destinationDetails.query) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        const queryDetails = querystring.parse(destinationDetails.query);
        if (!queryDetails.memoId) {
            // if there are more properties, the query details need to contain the memo id property
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        if (Array.isArray(queryDetails.memoId)) {
            throw new sdk_core_1.InvalidAddressError(`memoId may only be given at most once, but found ${queryDetails.memoId.length} instances in address ${address}`);
        }
        if (Array.isArray(queryDetails.memoId) && queryDetails.memoId.length !== 1) {
            // valid addresses can only contain one memo id
            throw new sdk_core_1.InvalidAddressError(`invalid address '${address}', must contain exactly one memoId`);
        }
        const [memoId] = _.castArray(queryDetails.memoId) || undefined;
        if (!this.isValidMemoId(memoId)) {
            throw new sdk_core_1.InvalidMemoIdError(`invalid address: '${address}', memoId is not valid`);
        }
        return {
            baseAddress: destinationAddress,
            address: destinationAddress,
            id: undefined,
            memoId,
        };
    }
    /**
     * Validate and return address with appended memo id or muxed address
     *
     * @param address address
     * @param memoId memo id
     * @returns address with memo id
     */
    normalizeAddress({ address, memoId }) {
        if (this.isValidMuxedAddress(address)) {
            return address;
        }
        if (!stellar.StrKey.isValidEd25519PublicKey(address)) {
            throw new Error(`invalid address details: ${address}`);
        }
        if (memoId && this.isValidMemoId(memoId)) {
            return `${address}?memoId=${memoId}`;
        }
        return address;
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param address the pub to be checked
     * @returns is it valid?
     */
    isValidAddress(address) {
        try {
            const addressDetails = this.getAddressDetails(address);
            return address === this.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Return a Stellar Asset in coin:token form (i.e. (t)xlm:<code>-<issuer>)
     * If the asset is XLM, return the chain
     * @param {stellar.Asset} asset - instance of Stellar Asset
     */
    getTokenNameFromStellarAsset(asset) {
        const code = asset.getCode();
        const issuer = asset.getIssuer();
        if (asset.isNative()) {
            return this.getChain();
        }
        return `${this.getChain()}${sdk_core_1.BaseCoin.coinTokenPatternSeparator}${code}${Xlm.tokenPatternSeparator}${issuer}`;
    }
    /**
     * Evaluate whether a stellar username has valid format
     * This method is used by the client when a stellar address is being added to a wallet
     * Example of a common stellar username: foo@bar.baz
     * The above example would result in the Stellar address: foo@bar.baz*bitgo.com
     *
     * @param username - stellar username
     * @return true if stellar username is valid
     */
    isValidStellarUsername(username) {
        return /^[a-z0-9\-_.+@]+$/.test(username);
    }
    /**
     * Get an instance of FederationServer for BitGo lookups
     *
     * @returns instance of BitGo Federation Server
     */
    getBitGoFederationServer() {
        // Identify the URI scheme in case we need to allow connecting to HTTP server.
        const isNonSecureEnv = !_.startsWith(sdk_core_1.common.Environments[this.bitgo.env].uri, 'https');
        const federationServerOptions = { allowHttp: isNonSecureEnv };
        return new stellar.FederationServer(this.getFederationServerUrl(), 'bitgo.com', federationServerOptions);
    }
    /**
     * Perform federation lookups
     * Our federation server handles lookups for bitgo as well as for other federation domains
     *
     * @param {String} [address] - address to look up
     * @param {String} [accountId] - account id to look up
     */
    async federationLookup({ address, accountId, }) {
        try {
            const federationServer = this.getBitGoFederationServer();
            if (address) {
                return await federationServer.resolveAddress(address);
            }
            else if (accountId) {
                return await federationServer.resolveAccountId(accountId);
            }
            else {
                throw new Error('invalid argument - must provide Stellar address or account id');
            }
        }
        catch (e) {
            const error = _.get(e, 'response.data.detail');
            if (error) {
                throw new sdk_core_1.StellarFederationUserNotFoundError(error);
            }
            else {
                throw e;
            }
        }
    }
    /**
     * Attempt to resolve a stellar address into a stellar account
     *
     * @param {String} address - stellar address to look for
     */
    async federationLookupByName(address) {
        if (!address) {
            throw new Error('invalid Stellar address');
        }
        return this.federationLookup({ address });
    }
    /**
     * Attempt to resolve an account id into a stellar account
     * Only works for accounts that can be resolved by our federation server
     *
     * @param {String} accountId - stellar account id
     */
    async federationLookupByAccountId(accountId) {
        if (!accountId) {
            throw new Error('invalid Stellar account');
        }
        return this.federationLookup({ accountId });
    }
    /**
     * Check if address is a valid XLM address, and then make sure it matches the root address.
     *
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     */
    async isWalletAddress({ address, rootAddress }) {
        if (!this.isValidAddress(address)) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        const addressDetails = this.getAddressDetails(address);
        const rootAddressDetails = this.getAddressDetails(rootAddress);
        if (addressDetails.baseAddress !== rootAddressDetails.address) {
            throw new sdk_core_1.UnexpectedAddressError(`address validation failure: ${addressDetails.baseAddress} vs ${rootAddressDetails.address}`);
        }
        return true;
    }
    /**
     * Get extra parameters for prebuilding a tx
     * Set empty recipients array in trustline txs
     */
    async getExtraPrebuildParams(buildParams) {
        const params = {};
        if (buildParams.type === 'trustline') {
            params.recipients = [];
        }
        return params;
    }
    /**
     * @deprecated
     */
    initiateRecovery(params) {
        throw new Error('deprecated method');
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - userKey: [encrypted] Stellar private key
     * - backupKey: [encrypted] Stellar private key, or public key if the private key is held by a KRS provider
     * - walletPassphrase: necessary if one of the private keys is encrypted
     * - rootAddress: base address of the wallet to recover funds from
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     */
    async recover(params) {
        // Stellar's Ed25519 public keys start with a G, while private keys start with an S
        const isKrsRecovery = params.backupKey.startsWith('G') && !params.userKey.startsWith('G');
        const isUnsignedSweep = params.backupKey.startsWith('G') && params.userKey.startsWith('G');
        if (isKrsRecovery) {
            (0, sdk_core_1.checkKrsProvider)(this, params.krsProvider);
        }
        if (!this.isValidAddress(params.recoveryDestination)) {
            throw new sdk_core_1.InvalidAddressError('Invalid destination address!');
        }
        const [userKey, backupKey] = (0, getStellarKeys_1.getStellarKeys)(this.bitgo, params);
        if (!params.rootAddress || !stellar.StrKey.isValidEd25519PublicKey(params.rootAddress)) {
            throw new Error(`Invalid wallet address: ${params.rootAddress}`);
        }
        const accountDataUrl = `${this.getHorizonUrl()}/accounts/${params.rootAddress}`;
        const destinationUrl = `${this.getHorizonUrl()}/accounts/${params.recoveryDestination}`;
        let accountData;
        try {
            accountData = await (0, sdk_api_1.toBitgoRequest)(request.get(accountDataUrl)).result();
        }
        catch (e) {
            throw new Error('Unable to reach the Stellar network via Horizon.');
        }
        // Now check if the destination account is empty or not
        let unfundedDestination = false;
        try {
            await request.get(destinationUrl);
        }
        catch (e) {
            if (e.status === 404) {
                // If the destination account does not yet exist, horizon responds with 404
                unfundedDestination = true;
            }
        }
        if (!accountData.sequence || !accountData.balances) {
            throw new Error('Horizon server error - unable to retrieve sequence ID or account balance');
        }
        const account = new stellar.Account(params.rootAddress, accountData.sequence);
        // Stellar supports multiple assets on chain, we're only interested in the balances entry whose type is "native" (XLM)
        const nativeBalanceInfo = accountData.balances.find((assetBalance) => assetBalance['asset_type'] === 'native');
        if (!nativeBalanceInfo) {
            throw new Error('Provided wallet has a balance of 0 XLM, recovery aborted');
        }
        const walletBalance = Number(this.bigUnitsToBaseUnits(nativeBalanceInfo.balance));
        const minimumReserve = await this.getMinimumReserve();
        const baseTxFee = await this.getBaseTransactionFee();
        const recoveryAmount = walletBalance - minimumReserve - baseTxFee;
        const formattedRecoveryAmount = this.baseUnitsToBigUnits(recoveryAmount).toString();
        const txBuilder = new stellar.TransactionBuilder(account, {
            fee: baseTxFee.toFixed(0),
            networkPassphrase: this.getStellarNetwork(),
        });
        const operation = unfundedDestination
            ? // In this case, we need to create the account
                stellar.Operation.createAccount({
                    destination: params.recoveryDestination,
                    startingBalance: formattedRecoveryAmount,
                })
            : // Otherwise if the account already exists, we do a normal send
                stellar.Operation.payment({
                    destination: params.recoveryDestination,
                    asset: stellar.Asset.native(),
                    amount: formattedRecoveryAmount,
                });
        const tx = txBuilder.addOperation(operation).setTimeout(stellar.TimeoutInfinite).build();
        const feeInfo = {
            fee: new bignumber_js_1.BigNumber(tx.fee).toNumber(),
            feeString: tx.fee,
        };
        if (!isUnsignedSweep) {
            tx.sign(userKey);
        }
        if (!isKrsRecovery && !isUnsignedSweep) {
            tx.sign(backupKey);
        }
        const transaction = {
            txBase64: Xlm.txToString(tx),
            recoveryAmount,
        };
        if (isKrsRecovery) {
            transaction.backupKey = params.backupKey;
        }
        transaction.coin = this.getChain();
        transaction.feeInfo = feeInfo;
        return transaction;
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @returns {Promise<HalfSignedTransaction>}
     */
    async signTransaction(params) {
        var _a, _b;
        const { txPrebuild, prv } = params;
        if (_.isUndefined(txPrebuild)) {
            throw new Error('missing txPrebuild parameter');
        }
        if (!_.isObject(txPrebuild)) {
            throw new Error(`txPrebuild must be an object, got type ${typeof txPrebuild}`);
        }
        if (_.isUndefined(prv)) {
            throw new Error('missing prv parameter to sign transaction');
        }
        if (!_.isString(prv)) {
            throw new Error(`prv must be a string, got type ${typeof prv}`);
        }
        const keyPair = stellar.Keypair.fromSecret(prv);
        const tx = new stellar.Transaction(txPrebuild.txBase64, this.getStellarNetwork());
        tx.sign(keyPair);
        const txBase64 = Xlm.txToString(tx);
        const type = (_a = txPrebuild === null || txPrebuild === void 0 ? void 0 : txPrebuild.buildParams) === null || _a === void 0 ? void 0 : _a.type;
        const recipients = (_b = txPrebuild === null || txPrebuild === void 0 ? void 0 : txPrebuild.buildParams) === null || _b === void 0 ? void 0 : _b.recipients;
        if (type === 'enabletoken') {
            return {
                halfSigned: { txBase64 },
                type,
                recipients,
            };
        }
        else {
            return { halfSigned: { txBase64 } };
        }
    }
    /**
     * Extend walletParams with extra params required for generating an XLM wallet
     *
     * Stellar wallets have three keychains on them. Two are generated by the platform, and the last is generated by the user.
     * Initially, we need a root prv to generate the account, which must be distinct from all three keychains on the wallet.
     * If a root prv is not provided, a random one is generated.
     */
    async supplementGenerateWallet(walletParams) {
        let seed;
        const rootPrv = walletParams.rootPrivateKey;
        if (rootPrv) {
            if (!this.isValidPrv(rootPrv)) {
                throw new Error('rootPrivateKey needs to be valid ed25519 secret seed');
            }
            seed = stellar.StrKey.decodeEd25519SecretSeed(rootPrv);
        }
        const keyPair = this.generateKeyPair(seed);
        // extend the wallet initialization params
        walletParams.rootPrivateKey = keyPair.prv;
        return walletParams;
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        if (!this.isValidPrv(key.prv)) {
            throw new Error(`invalid prv: ${key.prv}`);
        }
        if (!Buffer.isBuffer(message)) {
            message = Buffer.from(message);
        }
        const keypair = stellar.Keypair.fromSecret(key.prv);
        return keypair.sign(message);
    }
    /**
     * Verifies if signature for message is valid.
     *
     * @param pub public key
     * @param message signed message
     * @param signature signature to verify
     * @returns true if signature is valid.
     */
    verifySignature(pub, message, signature) {
        if (!this.isValidPub(pub)) {
            throw new Error(`invalid pub: ${pub}`);
        }
        if (!Buffer.isBuffer(message)) {
            message = Buffer.from(message);
        }
        const keyPair = stellar.Keypair.fromPublicKey(pub);
        return keyPair.verify(message, signature);
    }
    /**
     * Explain/parse transaction
     * @param params
     */
    async explainTransaction(params) {
        const { txHex, txBase64 } = params;
        let tx = undefined;
        if (!txHex && !txBase64) {
            throw new Error('explainTransaction missing txHex or txBase64 parameter, must have at least one');
        }
        try {
            if (txHex) {
                tx = new stellar.Transaction(Buffer.from(txHex, 'hex').toString('base64'), this.getStellarNetwork());
            }
            else if (txBase64) {
                tx = new stellar.Transaction(txBase64, this.getStellarNetwork());
            }
        }
        catch (e) {
            throw new Error('txBase64 needs to be a valid tx encoded as base64 string');
        }
        if (!tx) {
            throw new Error('tx needs to be defined in order to explain transaction');
        }
        const id = tx.hash().toString('hex');
        // In a Stellar tx, the _memo property is an object with the methods:
        // value() and arm() that provide memo value and type, respectively.
        const memo = _.result(tx, '_memo.value') && _.result(tx, '_memo.arm')
            ? {
                value: _.result(tx, '_memo.value').toString(),
                type: _.result(tx, '_memo.arm'),
            }
            : {};
        let spendAmount = new bignumber_js_1.BigNumber(0); // amount of XLM used in XLM-only txs
        const spendAmounts = {}; // track both xlm and token amounts
        if (_.isEmpty(tx.operations)) {
            throw new Error('missing operations');
        }
        const outputs = [];
        const operations = []; // non-payment operations
        _.forEach(tx.operations, (op) => {
            if (op.type === 'createAccount' || op.type === 'payment') {
                // TODO Remove memoId from address
                // Get memo to attach to address, if type is 'id'
                const memoId = _.get(memo, 'type') === 'id' && !_.get(memo, 'value') ? `?memoId=${memo.value}` : '';
                let asset;
                if (op.type === 'payment') {
                    if (op.asset.getAssetType() === 'liquidity_pool_shares') {
                        throw new Error('Invalid asset type');
                    }
                    asset = op.asset;
                }
                else {
                    asset = stellar.Asset.native();
                }
                const coin = this.getTokenNameFromStellarAsset(asset); // coin or token id
                const output = {
                    amount: this.bigUnitsToBaseUnits(op.startingBalance || op.amount),
                    address: op.destination + memoId,
                    coin,
                };
                if (!_.isUndefined(spendAmounts[coin])) {
                    spendAmounts[coin] = spendAmounts[coin].plus(output.amount);
                }
                else {
                    spendAmounts[coin] = new bignumber_js_1.BigNumber(output.amount);
                }
                if (asset.isNative()) {
                    spendAmount = spendAmount.plus(output.amount);
                }
                outputs.push(output);
            }
            else if (op.type === 'changeTrust') {
                if (op.line.getAssetType() === 'liquidity_pool_shares') {
                    throw new Error('Invalid asset type');
                }
                const asset = op.line;
                operations.push({
                    type: op.type,
                    coin: this.getTokenNameFromStellarAsset(asset),
                    asset,
                    limit: this.bigUnitsToBaseUnits(op.limit),
                });
            }
        });
        const outputAmount = spendAmount.toFixed(0);
        const outputAmounts = _.mapValues(spendAmounts, (amount) => amount.toFixed(0));
        const fee = {
            fee: new bignumber_js_1.BigNumber(tx.fee).toFixed(0),
            feeRate: null,
            size: null,
        };
        return {
            displayOrder: [
                'id',
                'outputAmount',
                'outputAmounts',
                'changeAmount',
                'outputs',
                'changeOutputs',
                'fee',
                'memo',
                'operations',
            ],
            id,
            outputs,
            outputAmount,
            outputAmounts,
            changeOutputs: [],
            changeAmount: '0',
            memo,
            fee,
            operations,
        };
    }
    /**
     * Verify that a tx prebuild's operations comply with the original intention
     * @param {stellar.Operation} operations - tx operations
     * @param {TransactionParams} txParams - params used to build the tx
     */
    verifyEnableTokenTxOperations(operations, txParams) {
        const trustlineOperations = _.filter(operations, ['type', 'changeTrust']);
        if (trustlineOperations.length !== _.get(txParams, 'recipients', []).length) {
            throw new Error('transaction prebuild does not match expected trustline operations');
        }
        _.forEach(trustlineOperations, (op) => {
            if (op.type !== 'changeTrust') {
                throw new Error('Invalid asset type');
            }
            if (op.line.getAssetType() === 'liquidity_pool_shares') {
                throw new Error('Invalid asset type');
            }
            const asset = op.line;
            const opToken = this.getTokenNameFromStellarAsset(asset);
            const tokenTrustline = _.find(txParams.recipients, (recipient) => {
                // trustline params use limits in base units
                const opLimitBaseUnits = this.bigUnitsToBaseUnits(op.limit);
                // Enable token limit is set to Xlm.maxTrustlineLimit by default
                return recipient.tokenName === opToken && opLimitBaseUnits === Xlm.maxTrustlineLimit;
            });
            if (!tokenTrustline) {
                throw new Error('transaction prebuild does not match expected trustline tokens');
            }
        });
    }
    /**
     * Verify that a tx prebuild's operations comply with the original intention
     * @param {stellar.Operation} operations - tx operations
     * @param {TransactionParams} txParams - params used to build the tx
     */
    verifyTrustlineTxOperations(operations, txParams) {
        const trustlineOperations = _.filter(operations, ['type', 'changeTrust']);
        if (trustlineOperations.length !== _.get(txParams, 'trustlines', []).length) {
            throw new Error('transaction prebuild does not match expected trustline operations');
        }
        _.forEach(trustlineOperations, (op) => {
            if (op.type !== 'changeTrust') {
                throw new Error('Invalid asset type');
            }
            if (op.line.getAssetType() === 'liquidity_pool_shares') {
                throw new Error('Invalid asset type');
            }
            const asset = op.line;
            const opToken = this.getTokenNameFromStellarAsset(asset);
            const tokenTrustline = _.find(txParams.trustlines, (trustline) => {
                // trustline params use limits in base units
                const opLimitBaseUnits = this.bigUnitsToBaseUnits(op.limit);
                // Prepare the conditions to check for
                // Limit will always be set in the operation, even if it was omitted from txParams in the following cases:
                // 1. Action is 'add' - limit is set to Xlm.maxTrustlineLimit by default
                // 2. Action is 'remove' - limit is set to '0'
                const noLimit = _.isUndefined(trustline.limit);
                const addTrustlineWithDefaultLimit = trustline.action === 'add' && opLimitBaseUnits === Xlm.maxTrustlineLimit;
                const removeTrustline = trustline.action === 'remove' && opLimitBaseUnits === '0';
                return (trustline.token === opToken &&
                    (trustline.limit === opLimitBaseUnits || (noLimit && (addTrustlineWithDefaultLimit || removeTrustline))));
            });
            if (!tokenTrustline) {
                throw new Error('transaction prebuild does not match expected trustline tokens');
            }
        });
    }
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param options
     * @param options.txPrebuild prebuild object returned by platform
     * @param options.txPrebuild.txBase64 prebuilt transaction encoded as base64 string
     * @param options.wallet wallet object to obtain keys to verify against
     * @param options.verification specifying some verification parameters
     * @param options.verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param options.verification.keychains Pass keychains manually rather than fetching them by id
     */
    async verifyTransaction(options) {
        // TODO BG-5600 Add parseTransaction / improve verification
        const { txParams, txPrebuild, wallet, verification = {} } = options;
        const disableNetworking = !!verification.disableNetworking;
        if (!txPrebuild.txBase64) {
            throw new Error('missing required tx prebuild property txBase64');
        }
        const tx = new stellar.Transaction(txPrebuild.txBase64, this.getStellarNetwork());
        if (txParams.recipients && txParams.recipients.length > 1) {
            throw new Error('cannot specify more than 1 recipient');
        }
        // Stellar txs are made up of operations. We only care about Create Account and Payment for sending funds.
        const outputOperations = _.filter(tx.operations, (operation) => operation.type === 'createAccount' || operation.type === 'payment');
        if (txParams.type === 'enabletoken') {
            this.verifyEnableTokenTxOperations(tx.operations, txParams);
        }
        else if (txParams.type === 'trustline') {
            this.verifyTrustlineTxOperations(tx.operations, txParams);
        }
        else {
            if (_.isEmpty(outputOperations)) {
                throw new Error('transaction prebuild does not have any operations');
            }
            _.forEach(txParams.recipients, (expectedOutput, index) => {
                const expectedOutputAddressDetails = this.getAddressDetails(expectedOutput.address);
                const expectedOutputAddress = expectedOutputAddressDetails.address;
                const output = outputOperations[index];
                if (output.destination !== expectedOutputAddress) {
                    throw new Error('transaction prebuild does not match expected recipient');
                }
                const expectedOutputAmount = new bignumber_js_1.BigNumber(expectedOutput.amount);
                // The output amount is expressed as startingBalance in createAccount operations and as amount in payment operations.
                const outputAmountString = output.type === 'createAccount' ? output.startingBalance : output.amount;
                const outputAmount = new bignumber_js_1.BigNumber(this.bigUnitsToBaseUnits(outputAmountString));
                if (!outputAmount.eq(expectedOutputAmount)) {
                    throw new Error('transaction prebuild does not match expected amount');
                }
            });
        }
        // Verify the user signature, if the tx is half-signed
        if (!_.isEmpty(tx.signatures)) {
            const userSignature = tx.signatures[0].signature();
            // obtain the keychains and key signatures
            let keychains = verification.keychains;
            if (!keychains && disableNetworking) {
                throw new Error('cannot fetch keychains without networking');
            }
            else if (!keychains) {
                keychains = await (0, sdk_core_1.promiseProps)({
                    user: this.keychains().get({ id: wallet.keyIds()[sdk_core_1.KeyIndices.USER] }),
                    backup: this.keychains().get({ id: wallet.keyIds()[sdk_core_1.KeyIndices.BACKUP] }),
                });
            }
            if (!keychains || !keychains.backup || !keychains.user) {
                throw new Error('keychains are required, but could not be fetched');
            }
            (0, assert_1.default)(keychains.backup.pub);
            if (this.verifySignature(keychains.backup.pub, tx.hash(), userSignature)) {
                throw new Error('transaction signed with wrong key');
            }
            (0, assert_1.default)(keychains.user.pub);
            if (!this.verifySignature(keychains.user.pub, tx.hash(), userSignature)) {
                throw new Error('transaction signature invalid');
            }
        }
        return true;
    }
    /** inheritdoc */
    deriveKeyWithSeed() {
        throw new sdk_core_1.NotSupported('method deriveKeyWithSeed not supported for eddsa curve');
    }
    async parseTransaction(params) {
        return {};
    }
    /**
     * Gets config for how token enablements work for this coin
     * @returns
     *    requiresTokenEnablement: True if tokens need to be enabled for this coin
     *    supportsMultipleTokenEnablements: True if multiple tokens can be enabled in one transaction
     */
    getTokenEnablementConfig() {
        return {
            requiresTokenEnablement: true,
            supportsMultipleTokenEnablements: false,
        };
    }
}
exports.Xlm = Xlm;
Xlm.tokenPatternSeparator = '-'; // separator for token code and issuer
Xlm.maxMemoId = '0xFFFFFFFFFFFFFFFF'; // max unsigned 64-bit number = 18446744073709551615
// max int64 number supported by the network (2^63)-1
// See: https://www.stellar.org/developers/guides/concepts/assets.html#amount-precision-and-representation
Xlm.maxTrustlineLimit = '9223372036854775807';
/**
 * stellar-sdk has two overloads for toXDR, and typescript can't seem to figure out the
 * correct one to use, so we have to be very explicit as to which one we want.
 * @param tx transaction to convert
 */
Xlm.txToString = (tx) => tx.toEnvelope().toXDR('base64');
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieGxtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3hsbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9EQUE0QjtBQUM1QiwwQ0FBNEI7QUFDNUIseURBQTJDO0FBQzNDLHlDQUEyQjtBQUMzQixvREFBc0M7QUFDdEMscURBQXVDO0FBQ3ZDLCtDQUF5QztBQUV6Qyw4Q0EwQnlCO0FBQ3pCLDRDQUFnRDtBQUNoRCxxREFBa0Q7QUFpSGxELE1BQWEsR0FBSSxTQUFRLG1CQUFRO0lBUS9CLFlBQVksS0FBZ0I7UUFDMUIsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2IsSUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUMsQ0FBQyxxQ0FBcUM7SUFDdEUsQ0FBQztJQUVELE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBZ0I7UUFDcEMsT0FBTyxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRVMsaUJBQWlCO1FBQ3pCLE9BQU8sT0FBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUM7SUFDakMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsYUFBYTtRQUNYLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVEOztPQUVHO0lBQ0gsUUFBUTtRQUNOLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOztPQUVHO0lBQ0gsU0FBUztRQUNQLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOztPQUVHO0lBQ0gsV0FBVztRQUNULE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRDs7T0FFRztJQUNILHNCQUFzQjtRQUNwQixPQUFPLGlCQUFNLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQywwQkFBMEIsQ0FBQztJQUM3RSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxhQUFhO1FBQ1gsT0FBTyw2QkFBNkIs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Q0FBQyxLQUErQixDQUFDLFFBQVEsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgcXVlcnlzdHJpbmcgZnJvbSAncXVlcnlzdHJpbmcnO1xuaW1wb3J0ICogYXMgdXJsIGZyb20gJ3VybCc7XG5pbXBvcnQgKiBhcyByZXF1ZXN0IGZyb20gJ3N1cGVyYWdlbnQnO1xuaW1wb3J0ICogYXMgc3RlbGxhciBmcm9tICdzdGVsbGFyLXNkayc7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuXG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgQml0R29CYXNlLFxuICBjaGVja0tyc1Byb3ZpZGVyLFxuICBjb21tb24sXG4gIEV4dHJhUHJlYnVpbGRQYXJhbXNPcHRpb25zLFxuICBJbnZhbGlkQWRkcmVzc0Vycm9yLFxuICBJbnZhbGlkTWVtb0lkRXJyb3IsXG4gIElUcmFuc2FjdGlvblJlY2lwaWVudCxcbiAgS2V5SW5kaWNlcyxcbiAgS2V5UGFpcixcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBwcm9taXNlUHJvcHMsXG4gIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgYXMgQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFN0ZWxsYXJGZWRlcmF0aW9uVXNlck5vdEZvdW5kRXJyb3IsXG4gIFRva2VuRW5hYmxlbWVudENvbmZpZyxcbiAgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiBhcyBCYXNlVHJhbnNhY3Rpb25FeHBsYW5hdGlvbixcbiAgVHJhbnNhY3Rpb25QYXJhbXMgYXMgQmFzZVRyYW5zYWN0aW9uUGFyYW1zLFxuICBUcmFuc2FjdGlvblByZWJ1aWxkIGFzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBUcmFuc2FjdGlvblJlY2lwaWVudCBhcyBCYXNlVHJhbnNhY3Rpb25PdXRwdXQsXG4gIFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IsXG4gIFZlcmlmeUFkZHJlc3NPcHRpb25zIGFzIEJhc2VWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFdhbGxldCxcbiAgTm90U3VwcG9ydGVkLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgdG9CaXRnb1JlcXVlc3QgfSBmcm9tICdAYml0Z28vc2RrLWFwaSc7XG5pbXBvcnQgeyBnZXRTdGVsbGFyS2V5cyB9IGZyb20gJy4vZ2V0U3RlbGxhcktleXMnO1xuXG4vKipcbiAqIFhMTSBhY2NvdW50cyBzdXBwb3J0IHZpcnR1YWwgKG11eGVkKSBhZGRyZXNzZXNcbiAqIEEgYmFzZSBhZGRyZXNzIHN0YXJ0cyB3aXRoIFwiR1wiIGFuZCBpcyB0aWVkIHRvIHRoZSB1bmRlcmx5aW5nIFwicmVhbFwiIGFjY291bnRcbiAqIEEgbXV4ZWQgYWRkcmVzcyBzdGFydHMgd2l0aCBcIk1cIiBhbmQgY29tYmluZXMgdGhlIGJhc2UgYWRkcmVzcyB3aXRoIGEgNjQtYml0IGludGVnZXIgSUQgaW4gb3JkZXIgdG8gcHJvdmlkZVxuICogYW4gYWx0ZXJuYXRpdmUgdG8gbWVtbyBpZHMuXG4gKi9cbmludGVyZmFjZSBBZGRyZXNzRGV0YWlscyB7XG4gIGJhc2VBZGRyZXNzOiBzdHJpbmc7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgaWQ/OiBzdHJpbmc7XG4gIG1lbW9JZD86IHN0cmluZyB8IHVuZGVmaW5lZDtcbn1cblxuaW50ZXJmYWNlIE1lbW8ge1xuICB0eXBlOiBzdGVsbGFyLk1lbW9UeXBlO1xuICB2YWx1ZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMge1xuICB1c2VyS2V5OiBzdHJpbmc7XG4gIGJhY2t1cEtleTogc3RyaW5nO1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7XG4gIGtyc1Byb3ZpZGVyPzogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUmVjb3ZlcnlPcHRpb25zIGV4dGVuZHMgSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMge1xuICByb290QWRkcmVzcz86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlY292ZXJ5VHJhbnNhY3Rpb24ge1xuICB0eEJhc2U2NDogc3RyaW5nO1xuICByZWNvdmVyeUFtb3VudDogbnVtYmVyO1xuICBjb2luPzogc3RyaW5nO1xuICBiYWNrdXBLZXk/OiBzdHJpbmc7XG4gIHR4SW5mbz86IGFueTtcbiAgZmVlSW5mbz86IGFueTtcbn1cblxuaW50ZXJmYWNlIEJ1aWxkT3B0aW9ucyB7XG4gIHdhbGxldD86IFdhbGxldDtcbiAgcmVjaXBpZW50cz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5bXTtcbiAgdHlwZT86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgW2luZGV4OiBzdHJpbmddOiB1bmtub3duO1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhCYXNlNjQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHBydjogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgSGFsZlNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgaGFsZlNpZ25lZDoge1xuICAgIHR4QmFzZTY0OiBzdHJpbmc7XG4gIH07XG4gIHJlY2lwaWVudHM/OiBJVHJhbnNhY3Rpb25SZWNpcGllbnRbXTtcbiAgdHlwZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMge1xuICByb290UHJpdmF0ZUtleT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEhleD86IHN0cmluZztcbiAgdHhCYXNlNjQ/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbk1lbW8ge1xuICB2YWx1ZT86IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uT3BlcmF0aW9uIHtcbiAgdHlwZTogc3RyaW5nO1xuICBjb2luOiBzdHJpbmc7XG4gIGxpbWl0Pzogc3RyaW5nO1xuICBhc3NldD86IHN0ZWxsYXIuQXNzZXQ7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbk91dHB1dCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbk91dHB1dCB7XG4gIGNvaW46IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24gZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiB7XG4gIG1lbW86IFRyYW5zYWN0aW9uTWVtbztcbn1cblxuaW50ZXJmYWNlIFZlcmlmeUFkZHJlc3NPcHRpb25zIGV4dGVuZHMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zIHtcbiAgcm9vdEFkZHJlc3M6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRydXN0bGluZU9wdGlvbnMge1xuICB0b2tlbjogc3RyaW5nO1xuICBhY3Rpb246IHN0cmluZztcbiAgbGltaXQ/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvblBhcmFtcyBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblBhcmFtcyB7XG4gIHRydXN0bGluZXM/OiBUcnVzdGxpbmVPcHRpb25zW107XG59XG5cbmludGVyZmFjZSBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBCYXNlVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQYXJhbXM6IFRyYW5zYWN0aW9uUGFyYW1zO1xufVxuXG5leHBvcnQgY2xhc3MgWGxtIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwdWJsaWMgcmVhZG9ubHkgaG9tZURvbWFpbjogc3RyaW5nO1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHRva2VuUGF0dGVyblNlcGFyYXRvciA9ICctJzsgLy8gc2VwYXJhdG9yIGZvciB0b2tlbiBjb2RlIGFuZCBpc3N1ZXJcbiAgc3RhdGljIHJlYWRvbmx5IG1heE1lbW9JZDogc3RyaW5nID0gJzB4RkZGRkZGRkZGRkZGRkZGRic7IC8vIG1heCB1bnNpZ25lZCA2NC1iaXQgbnVtYmVyID0gMTg0NDY3NDQwNzM3MDk1NTE2MTVcbiAgLy8gbWF4IGludDY0IG51bWJlciBzdXBwb3J0ZWQgYnkgdGhlIG5ldHdvcmsgKDJeNjMpLTFcbiAgLy8gU2VlOiBodHRwczovL3d3dy5zdGVsbGFyLm9yZy9kZXZlbG9wZXJzL2d1aWRlcy9jb25jZXB0cy9hc3NldHMuaHRtbCNhbW91bnQtcHJlY2lzaW9uLWFuZC1yZXByZXNlbnRhdGlvblxuICBzdGF0aWMgcmVhZG9ubHkgbWF4VHJ1c3RsaW5lTGltaXQ6IHN0cmluZyA9ICc5MjIzMzcyMDM2ODU0Nzc1ODA3JztcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlKSB7XG4gICAgc3VwZXIoYml0Z28pO1xuICAgIHRoaXMuaG9tZURvbWFpbiA9ICdiaXRnby5jb20nOyAvLyB1c2VkIGZvciByZXZlcnNlIGZlZGVyYXRpb24gbG9va3VwXG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvQmFzZSk6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IFhsbShiaXRnbyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0U3RlbGxhck5ldHdvcmsoKTogc3RlbGxhci5OZXR3b3JrcyB7XG4gICAgcmV0dXJuIHN0ZWxsYXIuTmV0d29ya3MuUFVCTElDO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhY3RvciBiZXR3ZWVuIHRoZSBiYXNlIHVuaXQgYW5kIGl0cyBzbWFsbGVzdCBzdWJkaXZpc29uXG4gICAqL1xuICBnZXRCYXNlRmFjdG9yKCkge1xuICAgIHJldHVybiAxZTc7XG4gIH1cblxuICAvKipcbiAgICogSWRlbnRpZmllciBmb3IgdGhlIGJsb2NrY2hhaW4gd2hpY2ggc3VwcG9ydHMgdGhpcyBjb2luXG4gICAqL1xuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAneGxtJztcbiAgfVxuXG4gIC8qKlxuICAgKiBJZGVudGlmaWVyIGZvciB0aGUgY29pbiBmYW1pbHlcbiAgICovXG4gIGdldEZhbWlseSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAneGxtJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoaXMgY29pblxuICAgKi9cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ1N0ZWxsYXInO1xuICB9XG5cbiAgLyoqXG4gICAqIFVybCBhdCB3aGljaCB0aGUgc3RlbGxhciBmZWRlcmF0aW9uIHNlcnZlciBjYW4gYmUgcmVhY2hlZFxuICAgKi9cbiAgZ2V0RmVkZXJhdGlvblNlcnZlclVybCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZ2V0RW52KCldLnN0ZWxsYXJGZWRlcmF0aW9uU2VydmVyVXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFVybCBhdCB3aGljaCBob3Jpem9uIGNhbiBiZSByZWFjaGVkXG4gICAqL1xuICBnZXRIb3Jpem9uVXJsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdodHRwczovL2hvcml6b24uc3RlbGxhci5vcmcnO1xuICB9XG5cbiAgLyoqIGluaGVyaXRkb2MgKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBjb25zdCBwYWlyID0gc2VlZCA/IHN0ZWxsYXIuS2V5cGFpci5mcm9tUmF3RWQyNTUxOVNlZWQoc2VlZCkgOiBzdGVsbGFyLktleXBhaXIucmFuZG9tKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YjogcGFpci5wdWJsaWNLZXkoKSxcbiAgICAgIHBydjogcGFpci5zZWNyZXQoKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBkZWNvZGVkIGVkMjU1MTkgcHVibGljIGtleSBmcm9tIHJhdyBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSBwdWIgUmF3IHB1YmxpYyBrZXlcbiAgICogQHJldHVybnMgRW5jb2RlZCBwdWJsaWMga2V5XG4gICAqL1xuICBnZXRQdWJGcm9tUmF3KHB1Yjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gc3RlbGxhci5TdHJLZXkuZW5jb2RlRWQyNTUxOVB1YmxpY0tleShCdWZmZXIuZnJvbShwdWIsICdoZXgnKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRlY29kZWQgZWQyNTUxOSBwcml2YXRlIGtleSBmcm9tIHJhdyBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSBwcnYgUmF3IHByaXZhdGUga2V5XG4gICAqIEByZXR1cm5zIEVuY29kZWQgcHJpdmF0ZSBrZXlcbiAgICovXG4gIGdldFBydkZyb21SYXcocHJ2OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBzdGVsbGFyLlN0cktleS5lbmNvZGVFZDI1NTE5U2VjcmV0U2VlZChCdWZmZXIuZnJvbShwcnYsICdoZXgnKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luLlxuICAgKlxuICAgKiBAcGFyYW0gcHViIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkocHViKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHJpdmF0ZSBrZXkgZm9yIHRoZSBjb2luXG4gICAqXG4gICAqIEBwYXJhbSBwcnYgdGhlIHBydiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzdGVsbGFyLlN0cktleS5pc1ZhbGlkRWQyNTUxOVNlY3JldFNlZWQocHJ2KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYSBtZW1vIGlkIGlzIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSBtZW1vSWQgbWVtbyBpZFxuICAgKiBAcmV0dXJucyB0cnVlIGlmIG1lbW8gaWQgaXMgdmFsaWRcbiAgICovXG4gIGlzVmFsaWRNZW1vSWQobWVtb0lkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBsZXQgbWVtb0lkTnVtYmVyO1xuICAgIHRyeSB7XG4gICAgICBzdGVsbGFyLk1lbW8uaWQobWVtb0lkKTsgLy8gdGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3QgdmFsaWQgbWVtbyBpZFxuICAgICAgbWVtb0lkTnVtYmVyID0gbmV3IEJpZ051bWJlcihtZW1vSWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb0lkTnVtYmVyLmd0ZSgwKSAmJiBtZW1vSWROdW1iZXIubHQoWGxtLm1heE1lbW9JZCk7XG4gIH1cblxuICBzdXBwb3J0c0Rlcml2ZUtleVdpdGhTZWVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZXMgd2hldGhlciBhIG1lbW8gaXMgdmFsaWRcbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIHZhbHVlIG9mIHRoZSBtZW1vXG4gICAqIEBwYXJhbSB0eXBlIHR5cGUgb2YgdGhlIG1lbW9cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBhbmQgdHlwZSBhcmUgYSB2YWxpZFxuICAgKi9cbiAgaXNWYWxpZE1lbW8oeyB2YWx1ZSwgdHlwZSB9OiBNZW1vKTogYm9vbGVhbiB7XG4gICAgaWYgKCF2YWx1ZSB8fCAhdHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gdGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3QgdmFsaWQgZm9yIHRoZSB0eXBlXG4gICAgICAvLyB2YWxpZCB0eXBlcyBhcmU6ICdpZCcsICd0ZXh0JywgJ2hhc2gnLCAncmV0dXJuJ1xuICAgICAgLy8gU2VlIGh0dHBzOi8vd3d3LnN0ZWxsYXIub3JnL2RldmVsb3BlcnMvZ3VpZGVzL2NvbmNlcHRzL3RyYW5zYWN0aW9ucy5odG1sI21lbW9cbiAgICAgIHN0ZWxsYXIuTWVtb1t0eXBlXSh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgaW5zdGFuY2Ugb2Ygc3RlbGxhci5NdXhlZEFjY291bnQgZnJvbSBNIGFkZHJlc3NcbiAgICogU2VlOiBodHRwczovL2RldmVsb3BlcnMuc3RlbGxhci5vcmcvZG9jcy9nbG9zc2FyeS9tdXhlZC1hY2NvdW50c1xuICAgKi9cbiAgZ2V0TXV4ZWRBY2NvdW50KGFkZHJlc3M6IHN0cmluZyk6IHN0ZWxsYXIuTXV4ZWRBY2NvdW50IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN0ZWxsYXIuTXV4ZWRBY2NvdW50LmZyb21BZGRyZXNzKGFkZHJlc3MsICcwJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG11eGVkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGEgbXV4ZWQgYWRkcmVzcyBpcyB2YWxpZFxuICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVycy5zdGVsbGFyLm9yZy9kb2NzL2dsb3NzYXJ5L211eGVkLWFjY291bnRzXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNWYWxpZE11eGVkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIV8uaXNTdHJpbmcoYWRkcmVzcykgfHwgIWFkZHJlc3Muc3RhcnRzV2l0aCgnTScpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIHJldHVybiB0cnVlIGlmIG11eGVkIGFjY291bnQgaXMgdmFsaWQgb3IgdGhyb3dcbiAgICAgIHJldHVybiAhIXN0ZWxsYXIuTXV4ZWRBY2NvdW50LmZyb21BZGRyZXNzKGFkZHJlc3MsICcwJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNaW5pbXVtIGJhbGFuY2Ugb2YgYSAyLW9mLTMgbXVsdGlzaWcgd2FsbGV0XG4gICAqIEByZXR1cm5zIG1pbmltdW0gYmFsYW5jZSBpbiBzdHJvb3BzXG4gICAqL1xuICBhc3luYyBnZXRNaW5pbXVtUmVzZXJ2ZSgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IHNlcnZlciA9IG5ldyBzdGVsbGFyLlNlcnZlcih0aGlzLmdldEhvcml6b25VcmwoKSk7XG5cbiAgICBjb25zdCBob3Jpem9uTGVkZ2VySW5mbyA9IGF3YWl0IHNlcnZlci5sZWRnZXJzKCkub3JkZXIoJ2Rlc2MnKS5saW1pdCgxKS5jYWxsKCk7XG5cbiAgICBpZiAoIWhvcml6b25MZWRnZXJJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBjb25uZWN0IHRvIEhvcml6b24gZm9yIHJlc2VydmUgcmVxdWlyZW1lbnQgZGF0YScpO1xuICAgIH1cblxuICAgIGNvbnN0IGJhc2VSZXNlcnZlID0gaG9yaXpvbkxlZGdlckluZm8ucmVjb3Jkc1swXS5iYXNlX3Jlc2VydmVfaW5fc3Ryb29wcztcblxuICAgIC8vIDItb2YtMyB3YWxsZXRzIGhhdmUgYSBtaW5pbXVtIHJlc2VydmUgb2YgNXggdGhlIGJhc2UgcmVzZXJ2ZVxuICAgIHJldHVybiA1ICogYmFzZVJlc2VydmU7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNhY3Rpb24gZmVlIGZvciBlYWNoIG9wZXJhdGlvblxuICAgKiBAcmV0dXJucyB0cmFuc2FjdGlvbiBmZWUgaW4gc3Ryb29wc1xuICAgKi9cbiAgYXN5bmMgZ2V0QmFzZVRyYW5zYWN0aW9uRmVlKCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3Qgc2VydmVyID0gbmV3IHN0ZWxsYXIuU2VydmVyKHRoaXMuZ2V0SG9yaXpvblVybCgpKTtcblxuICAgIGNvbnN0IGhvcml6b25MZWRnZXJJbmZvID0gYXdhaXQgc2VydmVyLmxlZGdlcnMoKS5vcmRlcignZGVzYycpLmxpbWl0KDEpLmNhbGwoKTtcblxuICAgIGlmICghaG9yaXpvbkxlZGdlckluZm8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGNvbm5lY3QgdG8gSG9yaXpvbiBmb3IgcmVzZXJ2ZSByZXF1aXJlbWVudCBkYXRhJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvcml6b25MZWRnZXJJbmZvLnJlY29yZHNbMF0uYmFzZV9mZWVfaW5fc3Ryb29wcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGFkZHJlc3MgaW50byBhZGRyZXNzIGFuZCBtZW1vIGlkXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHRoZSBhZGRyZXNzXG4gICAqIEByZXR1cm5zIG9iamVjdCBjb250YWluaW5nIGFkZHJlc3MgYW5kIG1lbW8gaWRcbiAgICovXG4gIGdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3M6IHN0cmluZyk6IEFkZHJlc3NEZXRhaWxzIHtcbiAgICBpZiAoYWRkcmVzcy5zdGFydHNXaXRoKCdNJykpIHtcbiAgICAgIGlmICh0aGlzLmlzVmFsaWRNdXhlZEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgY29uc3QgbXV4ZWRBY2NvdW50ID0gdGhpcy5nZXRNdXhlZEFjY291bnQoYWRkcmVzcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYmFzZUFkZHJlc3M6IG11eGVkQWNjb3VudC5iYXNlQWNjb3VudCgpLmFjY291bnRJZCgpLFxuICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgaWQ6IG11eGVkQWNjb3VudC5pZCgpLFxuICAgICAgICAgIG1lbW9JZDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgbXV4ZWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGRlc3RpbmF0aW9uRGV0YWlscyA9IHVybC5wYXJzZShhZGRyZXNzKTtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkFkZHJlc3MgPSBkZXN0aW5hdGlvbkRldGFpbHMucGF0aG5hbWUgfHwgJyc7XG4gICAgaWYgKCFkZXN0aW5hdGlvbkFkZHJlc3MgfHwgIXN0ZWxsYXIuU3RyS2V5LmlzVmFsaWRFZDI1NTE5UHVibGljS2V5KGRlc3RpbmF0aW9uQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICAgIC8vIGFkZHJlc3MgZG9lc24ndCBoYXZlIGEgbWVtbyBpZFxuICAgIGlmIChkZXN0aW5hdGlvbkRldGFpbHMucGF0aG5hbWUgPT09IGFkZHJlc3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VBZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICBpZDogdW5kZWZpbmVkLFxuICAgICAgICBtZW1vSWQ6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFkZXN0aW5hdGlvbkRldGFpbHMucXVlcnkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyeURldGFpbHMgPSBxdWVyeXN0cmluZy5wYXJzZShkZXN0aW5hdGlvbkRldGFpbHMucXVlcnkpO1xuICAgIGlmICghcXVlcnlEZXRhaWxzLm1lbW9JZCkge1xuICAgICAgLy8gaWYgdGhlcmUgYXJlIG1vcmUgcHJvcGVydGllcywgdGhlIHF1ZXJ5IGRldGFpbHMgbmVlZCB0byBjb250YWluIHRoZSBtZW1vIGlkIHByb3BlcnR5XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlEZXRhaWxzLm1lbW9JZCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKFxuICAgICAgICBgbWVtb0lkIG1heSBvbmx5IGJlIGdpdmVuIGF0IG1vc3Qgb25jZSwgYnV0IGZvdW5kICR7cXVlcnlEZXRhaWxzLm1lbW9JZC5sZW5ndGh9IGluc3RhbmNlcyBpbiBhZGRyZXNzICR7YWRkcmVzc31gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5RGV0YWlscy5tZW1vSWQpICYmIHF1ZXJ5RGV0YWlscy5tZW1vSWQubGVuZ3RoICE9PSAxKSB7XG4gICAgICAvLyB2YWxpZCBhZGRyZXNzZXMgY2FuIG9ubHkgY29udGFpbiBvbmUgbWVtbyBpZFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzcyAnJHthZGRyZXNzfScsIG11c3QgY29udGFpbiBleGFjdGx5IG9uZSBtZW1vSWRgKTtcbiAgICB9XG5cbiAgICBjb25zdCBbbWVtb0lkXSA9IF8uY2FzdEFycmF5KHF1ZXJ5RGV0YWlscy5tZW1vSWQpIHx8IHVuZGVmaW5lZDtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZE1lbW9JZChtZW1vSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZE1lbW9JZEVycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICcke2FkZHJlc3N9JywgbWVtb0lkIGlzIG5vdCB2YWxpZGApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBiYXNlQWRkcmVzczogZGVzdGluYXRpb25BZGRyZXNzLFxuICAgICAgYWRkcmVzczogZGVzdGluYXRpb25BZGRyZXNzLFxuICAgICAgaWQ6IHVuZGVmaW5lZCxcbiAgICAgIG1lbW9JZCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGFuZCByZXR1cm4gYWRkcmVzcyB3aXRoIGFwcGVuZGVkIG1lbW8gaWQgb3IgbXV4ZWQgYWRkcmVzc1xuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyBhZGRyZXNzXG4gICAqIEBwYXJhbSBtZW1vSWQgbWVtbyBpZFxuICAgKiBAcmV0dXJucyBhZGRyZXNzIHdpdGggbWVtbyBpZFxuICAgKi9cbiAgbm9ybWFsaXplQWRkcmVzcyh7IGFkZHJlc3MsIG1lbW9JZCB9OiBBZGRyZXNzRGV0YWlscyk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZE11eGVkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgfVxuICAgIGlmICghc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkoYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhZGRyZXNzIGRldGFpbHM6ICR7YWRkcmVzc31gKTtcbiAgICB9XG4gICAgaWYgKG1lbW9JZCAmJiB0aGlzLmlzVmFsaWRNZW1vSWQobWVtb0lkKSkge1xuICAgICAgcmV0dXJuIGAke2FkZHJlc3N9P21lbW9JZD0ke21lbW9JZH1gO1xuICAgIH1cbiAgICByZXR1cm4gYWRkcmVzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW5cbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFkZHJlc3NEZXRhaWxzID0gdGhpcy5nZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKTtcbiAgICAgIHJldHVybiBhZGRyZXNzID09PSB0aGlzLm5vcm1hbGl6ZUFkZHJlc3MoYWRkcmVzc0RldGFpbHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgU3RlbGxhciBBc3NldCBpbiBjb2luOnRva2VuIGZvcm0gKGkuZS4gKHQpeGxtOjxjb2RlPi08aXNzdWVyPilcbiAgICogSWYgdGhlIGFzc2V0IGlzIFhMTSwgcmV0dXJuIHRoZSBjaGFpblxuICAgKiBAcGFyYW0ge3N0ZWxsYXIuQXNzZXR9IGFzc2V0IC0gaW5zdGFuY2Ugb2YgU3RlbGxhciBBc3NldFxuICAgKi9cbiAgZ2V0VG9rZW5OYW1lRnJvbVN0ZWxsYXJBc3NldChhc3NldDogc3RlbGxhci5Bc3NldCk6IHN0cmluZyB7XG4gICAgY29uc3QgY29kZSA9IGFzc2V0LmdldENvZGUoKTtcbiAgICBjb25zdCBpc3N1ZXIgPSBhc3NldC5nZXRJc3N1ZXIoKTtcbiAgICBpZiAoYXNzZXQuaXNOYXRpdmUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hhaW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3RoaXMuZ2V0Q2hhaW4oKX0ke0Jhc2VDb2luLmNvaW5Ub2tlblBhdHRlcm5TZXBhcmF0b3J9JHtjb2RlfSR7WGxtLnRva2VuUGF0dGVyblNlcGFyYXRvcn0ke2lzc3Vlcn1gO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIHdoZXRoZXIgYSBzdGVsbGFyIHVzZXJuYW1lIGhhcyB2YWxpZCBmb3JtYXRcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCBieSB0aGUgY2xpZW50IHdoZW4gYSBzdGVsbGFyIGFkZHJlc3MgaXMgYmVpbmcgYWRkZWQgdG8gYSB3YWxsZXRcbiAgICogRXhhbXBsZSBvZiBhIGNvbW1vbiBzdGVsbGFyIHVzZXJuYW1lOiBmb29AYmFyLmJhelxuICAgKiBUaGUgYWJvdmUgZXhhbXBsZSB3b3VsZCByZXN1bHQgaW4gdGhlIFN0ZWxsYXIgYWRkcmVzczogZm9vQGJhci5iYXoqYml0Z28uY29tXG4gICAqXG4gICAqIEBwYXJhbSB1c2VybmFtZSAtIHN0ZWxsYXIgdXNlcm5hbWVcbiAgICogQHJldHVybiB0cnVlIGlmIHN0ZWxsYXIgdXNlcm5hbWUgaXMgdmFsaWRcbiAgICovXG4gIGlzVmFsaWRTdGVsbGFyVXNlcm5hbWUodXNlcm5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAvXlthLXowLTlcXC1fLitAXSskLy50ZXN0KHVzZXJuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugb2YgRmVkZXJhdGlvblNlcnZlciBmb3IgQml0R28gbG9va3Vwc1xuICAgKlxuICAgKiBAcmV0dXJucyBpbnN0YW5jZSBvZiBCaXRHbyBGZWRlcmF0aW9uIFNlcnZlclxuICAgKi9cbiAgZ2V0Qml0R29GZWRlcmF0aW9uU2VydmVyKCk6IHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlciB7XG4gICAgLy8gSWRlbnRpZnkgdGhlIFVSSSBzY2hlbWUgaW4gY2FzZSB3ZSBuZWVkIHRvIGFsbG93IGNvbm5lY3RpbmcgdG8gSFRUUCBzZXJ2ZXIuXG4gICAgY29uc3QgaXNOb25TZWN1cmVFbnYgPSAhXy5zdGFydHNXaXRoKGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5iaXRnby5lbnZdLnVyaSwgJ2h0dHBzJyk7XG4gICAgY29uc3QgZmVkZXJhdGlvblNlcnZlck9wdGlvbnMgPSB7IGFsbG93SHR0cDogaXNOb25TZWN1cmVFbnYgfTtcbiAgICByZXR1cm4gbmV3IHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlcih0aGlzLmdldEZlZGVyYXRpb25TZXJ2ZXJVcmwoKSwgJ2JpdGdvLmNvbScsIGZlZGVyYXRpb25TZXJ2ZXJPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGZlZGVyYXRpb24gbG9va3Vwc1xuICAgKiBPdXIgZmVkZXJhdGlvbiBzZXJ2ZXIgaGFuZGxlcyBsb29rdXBzIGZvciBiaXRnbyBhcyB3ZWxsIGFzIGZvciBvdGhlciBmZWRlcmF0aW9uIGRvbWFpbnNcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFthZGRyZXNzXSAtIGFkZHJlc3MgdG8gbG9vayB1cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2FjY291bnRJZF0gLSBhY2NvdW50IGlkIHRvIGxvb2sgdXBcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZmVkZXJhdGlvbkxvb2t1cCh7XG4gICAgYWRkcmVzcyxcbiAgICBhY2NvdW50SWQsXG4gIH06IHtcbiAgICBhZGRyZXNzPzogc3RyaW5nO1xuICAgIGFjY291bnRJZD86IHN0cmluZztcbiAgfSk6IFByb21pc2U8c3RlbGxhci5GZWRlcmF0aW9uU2VydmVyLlJlY29yZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmZWRlcmF0aW9uU2VydmVyID0gdGhpcy5nZXRCaXRHb0ZlZGVyYXRpb25TZXJ2ZXIoKTtcbiAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBmZWRlcmF0aW9uU2VydmVyLnJlc29sdmVBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgfSBlbHNlIGlmIChhY2NvdW50SWQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZlZGVyYXRpb25TZXJ2ZXIucmVzb2x2ZUFjY291bnRJZChhY2NvdW50SWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IC0gbXVzdCBwcm92aWRlIFN0ZWxsYXIgYWRkcmVzcyBvciBhY2NvdW50IGlkJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgZXJyb3IgPSBfLmdldChlLCAncmVzcG9uc2UuZGF0YS5kZXRhaWwnKTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgU3RlbGxhckZlZGVyYXRpb25Vc2VyTm90Rm91bmRFcnJvcihlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIHJlc29sdmUgYSBzdGVsbGFyIGFkZHJlc3MgaW50byBhIHN0ZWxsYXIgYWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyAtIHN0ZWxsYXIgYWRkcmVzcyB0byBsb29rIGZvclxuICAgKi9cbiAgYXN5bmMgZmVkZXJhdGlvbkxvb2t1cEJ5TmFtZShhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlci5SZWNvcmQ+IHtcbiAgICBpZiAoIWFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTdGVsbGFyIGFkZHJlc3MnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mZWRlcmF0aW9uTG9va3VwKHsgYWRkcmVzcyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIHJlc29sdmUgYW4gYWNjb3VudCBpZCBpbnRvIGEgc3RlbGxhciBhY2NvdW50XG4gICAqIE9ubHkgd29ya3MgZm9yIGFjY291bnRzIHRoYXQgY2FuIGJlIHJlc29sdmVkIGJ5IG91ciBmZWRlcmF0aW9uIHNlcnZlclxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIC0gc3RlbGxhciBhY2NvdW50IGlkXG4gICAqL1xuICBhc3luYyBmZWRlcmF0aW9uTG9va3VwQnlBY2NvdW50SWQoYWNjb3VudElkOiBzdHJpbmcpOiBQcm9taXNlPHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlci5SZWNvcmQ+IHtcbiAgICBpZiAoIWFjY291bnRJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFN0ZWxsYXIgYWNjb3VudCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mZWRlcmF0aW9uTG9va3VwKHsgYWNjb3VudElkIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFkZHJlc3MgaXMgYSB2YWxpZCBYTE0gYWRkcmVzcywgYW5kIHRoZW4gbWFrZSBzdXJlIGl0IG1hdGNoZXMgdGhlIHJvb3QgYWRkcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3Mge1N0cmluZ30gdGhlIGFkZHJlc3MgdG8gdmVyaWZ5XG4gICAqIEBwYXJhbSByb290QWRkcmVzcyB7U3RyaW5nfSB0aGUgd2FsbGV0J3Mgcm9vdCBhZGRyZXNzXG4gICAqL1xuICBhc3luYyBpc1dhbGxldEFkZHJlc3MoeyBhZGRyZXNzLCByb290QWRkcmVzcyB9OiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGFkZHJlc3NEZXRhaWxzID0gdGhpcy5nZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKTtcbiAgICBjb25zdCByb290QWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKHJvb3RBZGRyZXNzKTtcbiAgICBpZiAoYWRkcmVzc0RldGFpbHMuYmFzZUFkZHJlc3MgIT09IHJvb3RBZGRyZXNzRGV0YWlscy5hZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZEFkZHJlc3NFcnJvcihcbiAgICAgICAgYGFkZHJlc3MgdmFsaWRhdGlvbiBmYWlsdXJlOiAke2FkZHJlc3NEZXRhaWxzLmJhc2VBZGRyZXNzfSB2cyAke3Jvb3RBZGRyZXNzRGV0YWlscy5hZGRyZXNzfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGV4dHJhIHBhcmFtZXRlcnMgZm9yIHByZWJ1aWxkaW5nIGEgdHhcbiAgICogU2V0IGVtcHR5IHJlY2lwaWVudHMgYXJyYXkgaW4gdHJ1c3RsaW5lIHR4c1xuICAgKi9cbiAgYXN5bmMgZ2V0RXh0cmFQcmVidWlsZFBhcmFtcyhidWlsZFBhcmFtczogRXh0cmFQcmVidWlsZFBhcmFtc09wdGlvbnMpOiBQcm9taXNlPEJ1aWxkT3B0aW9ucz4ge1xuICAgIGNvbnN0IHBhcmFtczogeyByZWNpcGllbnRzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPltdIH0gPSB7fTtcbiAgICBpZiAoYnVpbGRQYXJhbXMudHlwZSA9PT0gJ3RydXN0bGluZScpIHtcbiAgICAgIHBhcmFtcy5yZWNpcGllbnRzID0gW107XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGluaXRpYXRlUmVjb3ZlcnkocGFyYW1zOiBSZWNvdmVyeU9wdGlvbnMpOiBuZXZlciB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZXByZWNhdGVkIG1ldGhvZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R29cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHVzZXJLZXk6IFtlbmNyeXB0ZWRdIFN0ZWxsYXIgcHJpdmF0ZSBrZXlcbiAgICogLSBiYWNrdXBLZXk6IFtlbmNyeXB0ZWRdIFN0ZWxsYXIgcHJpdmF0ZSBrZXksIG9yIHB1YmxpYyBrZXkgaWYgdGhlIHByaXZhdGUga2V5IGlzIGhlbGQgYnkgYSBLUlMgcHJvdmlkZXJcbiAgICogLSB3YWxsZXRQYXNzcGhyYXNlOiBuZWNlc3NhcnkgaWYgb25lIG9mIHRoZSBwcml2YXRlIGtleXMgaXMgZW5jcnlwdGVkXG4gICAqIC0gcm9vdEFkZHJlc3M6IGJhc2UgYWRkcmVzcyBvZiB0aGUgd2FsbGV0IHRvIHJlY292ZXIgZnVuZHMgZnJvbVxuICAgKiAtIGtyc1Byb3ZpZGVyOiBuZWNlc3NhcnkgaWYgYmFja3VwIGtleSBpcyBoZWxkIGJ5IEtSU1xuICAgKiAtIHJlY292ZXJ5RGVzdGluYXRpb246IHRhcmdldCBhZGRyZXNzIHRvIHNlbmQgcmVjb3ZlcmVkIGZ1bmRzIHRvXG4gICAqL1xuICBhc3luYyByZWNvdmVyKHBhcmFtczogUmVjb3ZlcnlPcHRpb25zKTogUHJvbWlzZTxSZWNvdmVyeVRyYW5zYWN0aW9uPiB7XG4gICAgLy8gU3RlbGxhcidzIEVkMjU1MTkgcHVibGljIGtleXMgc3RhcnQgd2l0aCBhIEcsIHdoaWxlIHByaXZhdGUga2V5cyBzdGFydCB3aXRoIGFuIFNcbiAgICBjb25zdCBpc0tyc1JlY292ZXJ5ID0gcGFyYW1zLmJhY2t1cEtleS5zdGFydHNXaXRoKCdHJykgJiYgIXBhcmFtcy51c2VyS2V5LnN0YXJ0c1dpdGgoJ0cnKTtcbiAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBwYXJhbXMuYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ0cnKSAmJiBwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCdHJyk7XG5cbiAgICBpZiAoaXNLcnNSZWNvdmVyeSkge1xuICAgICAgY2hlY2tLcnNQcm92aWRlcih0aGlzLCBwYXJhbXMua3JzUHJvdmlkZXIpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKCdJbnZhbGlkIGRlc3RpbmF0aW9uIGFkZHJlc3MhJyk7XG4gICAgfVxuXG4gICAgY29uc3QgW3VzZXJLZXksIGJhY2t1cEtleV0gPSBnZXRTdGVsbGFyS2V5cyh0aGlzLmJpdGdvLCBwYXJhbXMpO1xuXG4gICAgaWYgKCFwYXJhbXMucm9vdEFkZHJlc3MgfHwgIXN0ZWxsYXIuU3RyS2V5LmlzVmFsaWRFZDI1NTE5UHVibGljS2V5KHBhcmFtcy5yb290QWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3YWxsZXQgYWRkcmVzczogJHtwYXJhbXMucm9vdEFkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgYWNjb3VudERhdGFVcmwgPSBgJHt0aGlzLmdldEhvcml6b25VcmwoKX0vYWNjb3VudHMvJHtwYXJhbXMucm9vdEFkZHJlc3N9YDtcbiAgICBjb25zdCBkZXN0aW5hdGlvblVybCA9IGAke3RoaXMuZ2V0SG9yaXpvblVybCgpfS9hY2NvdW50cy8ke3BhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9ufWA7XG5cbiAgICBsZXQgYWNjb3VudERhdGE7XG4gICAgdHJ5IHtcbiAgICAgIGFjY291bnREYXRhID0gYXdhaXQgdG9CaXRnb1JlcXVlc3QocmVxdWVzdC5nZXQoYWNjb3VudERhdGFVcmwpKS5yZXN1bHQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byByZWFjaCB0aGUgU3RlbGxhciBuZXR3b3JrIHZpYSBIb3Jpem9uLicpO1xuICAgIH1cblxuICAgIC8vIE5vdyBjaGVjayBpZiB0aGUgZGVzdGluYXRpb24gYWNjb3VudCBpcyBlbXB0eSBvciBub3RcbiAgICBsZXQgdW5mdW5kZWREZXN0aW5hdGlvbiA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCByZXF1ZXN0LmdldChkZXN0aW5hdGlvblVybCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGRlc3RpbmF0aW9uIGFjY291bnQgZG9lcyBub3QgeWV0IGV4aXN0LCBob3Jpem9uIHJlc3BvbmRzIHdpdGggNDA0XG4gICAgICAgIHVuZnVuZGVkRGVzdGluYXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYWNjb3VudERhdGEuc2VxdWVuY2UgfHwgIWFjY291bnREYXRhLmJhbGFuY2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hvcml6b24gc2VydmVyIGVycm9yIC0gdW5hYmxlIHRvIHJldHJpZXZlIHNlcXVlbmNlIElEIG9yIGFjY291bnQgYmFsYW5jZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGFjY291bnQgPSBuZXcgc3RlbGxhci5BY2NvdW50KHBhcmFtcy5yb290QWRkcmVzcywgYWNjb3VudERhdGEuc2VxdWVuY2UpO1xuXG4gICAgLy8gU3RlbGxhciBzdXBwb3J0cyBtdWx0aXBsZSBhc3NldHMgb24gY2hhaW4sIHdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiB0aGUgYmFsYW5jZXMgZW50cnkgd2hvc2UgdHlwZSBpcyBcIm5hdGl2ZVwiIChYTE0pXG4gICAgY29uc3QgbmF0aXZlQmFsYW5jZUluZm8gPSBhY2NvdW50RGF0YS5iYWxhbmNlcy5maW5kKChhc3NldEJhbGFuY2UpID0+IGFzc2V0QmFsYW5jZVsnYXNzZXRfdHlwZSddID09PSAnbmF0aXZlJyk7XG5cbiAgICBpZiAoIW5hdGl2ZUJhbGFuY2VJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIHdhbGxldCBoYXMgYSBiYWxhbmNlIG9mIDAgWExNLCByZWNvdmVyeSBhYm9ydGVkJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgd2FsbGV0QmFsYW5jZSA9IE51bWJlcih0aGlzLmJpZ1VuaXRzVG9CYXNlVW5pdHMobmF0aXZlQmFsYW5jZUluZm8uYmFsYW5jZSkpO1xuICAgIGNvbnN0IG1pbmltdW1SZXNlcnZlID0gYXdhaXQgdGhpcy5nZXRNaW5pbXVtUmVzZXJ2ZSgpO1xuICAgIGNvbnN0IGJhc2VUeEZlZSA9IGF3YWl0IHRoaXMuZ2V0QmFzZVRyYW5zYWN0aW9uRmVlKCk7XG4gICAgY29uc3QgcmVjb3ZlcnlBbW91bnQgPSB3YWxsZXRCYWxhbmNlIC0gbWluaW11bVJlc2VydmUgLSBiYXNlVHhGZWU7XG4gICAgY29uc3QgZm9ybWF0dGVkUmVjb3ZlcnlBbW91bnQgPSB0aGlzLmJhc2VVbml0c1RvQmlnVW5pdHMocmVjb3ZlcnlBbW91bnQpLnRvU3RyaW5nKCk7XG5cbiAgICBjb25zdCB0eEJ1aWxkZXIgPSBuZXcgc3RlbGxhci5UcmFuc2FjdGlvbkJ1aWxkZXIoYWNjb3VudCwge1xuICAgICAgZmVlOiBiYXNlVHhGZWUudG9GaXhlZCgwKSxcbiAgICAgIG5ldHdvcmtQYXNzcGhyYXNlOiB0aGlzLmdldFN0ZWxsYXJOZXR3b3JrKCksXG4gICAgfSk7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdW5mdW5kZWREZXN0aW5hdGlvblxuICAgICAgPyAvLyBJbiB0aGlzIGNhc2UsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBhY2NvdW50XG4gICAgICAgIHN0ZWxsYXIuT3BlcmF0aW9uLmNyZWF0ZUFjY291bnQoe1xuICAgICAgICAgIGRlc3RpbmF0aW9uOiBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbixcbiAgICAgICAgICBzdGFydGluZ0JhbGFuY2U6IGZvcm1hdHRlZFJlY292ZXJ5QW1vdW50LFxuICAgICAgICB9KVxuICAgICAgOiAvLyBPdGhlcndpc2UgaWYgdGhlIGFjY291bnQgYWxyZWFkeSBleGlzdHMsIHdlIGRvIGEgbm9ybWFsIHNlbmRcbiAgICAgICAgc3RlbGxhci5PcGVyYXRpb24ucGF5bWVudCh7XG4gICAgICAgICAgZGVzdGluYXRpb246IHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uLFxuICAgICAgICAgIGFzc2V0OiBzdGVsbGFyLkFzc2V0Lm5hdGl2ZSgpLFxuICAgICAgICAgIGFtb3VudDogZm9ybWF0dGVkUmVjb3ZlcnlBbW91bnQsXG4gICAgICAgIH0pO1xuICAgIGNvbnN0IHR4ID0gdHhCdWlsZGVyLmFkZE9wZXJhdGlvbihvcGVyYXRpb24pLnNldFRpbWVvdXQoc3RlbGxhci5UaW1lb3V0SW5maW5pdGUpLmJ1aWxkKCk7XG5cbiAgICBjb25zdCBmZWVJbmZvID0ge1xuICAgICAgZmVlOiBuZXcgQmlnTnVtYmVyKHR4LmZlZSkudG9OdW1iZXIoKSxcbiAgICAgIGZlZVN0cmluZzogdHguZmVlLFxuICAgIH07XG5cbiAgICBpZiAoIWlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgdHguc2lnbih1c2VyS2V5KTtcbiAgICB9XG5cbiAgICBpZiAoIWlzS3JzUmVjb3ZlcnkgJiYgIWlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgdHguc2lnbihiYWNrdXBLZXkpO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zYWN0aW9uOiBSZWNvdmVyeVRyYW5zYWN0aW9uID0ge1xuICAgICAgdHhCYXNlNjQ6IFhsbS50eFRvU3RyaW5nKHR4KSxcbiAgICAgIHJlY292ZXJ5QW1vdW50LFxuICAgIH07XG5cbiAgICBpZiAoaXNLcnNSZWNvdmVyeSkge1xuICAgICAgdHJhbnNhY3Rpb24uYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleTtcbiAgICB9XG5cbiAgICB0cmFuc2FjdGlvbi5jb2luID0gdGhpcy5nZXRDaGFpbigpO1xuICAgIHRyYW5zYWN0aW9uLmZlZUluZm8gPSBmZWVJbmZvO1xuXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VtYmxlIGtleWNoYWluIGFuZCBoYWxmLXNpZ24gcHJlYnVpbHQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnR4UHJlYnVpbGQge09iamVjdH0gcHJlYnVpbGQgb2JqZWN0IHJldHVybmVkIGJ5IHBsYXRmb3JtXG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2IHtTdHJpbmd9IHVzZXIgcHJ2XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEhhbGZTaWduZWRUcmFuc2FjdGlvbj59XG4gICAqL1xuICBhc3luYyBzaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxIYWxmU2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCB7IHR4UHJlYnVpbGQsIHBydiB9ID0gcGFyYW1zO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodHhQcmVidWlsZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB0eFByZWJ1aWxkIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBpZiAoIV8uaXNPYmplY3QodHhQcmVidWlsZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHhQcmVidWlsZCBtdXN0IGJlIGFuIG9iamVjdCwgZ290IHR5cGUgJHt0eXBlb2YgdHhQcmVidWlsZH1gKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHJ2IHBhcmFtZXRlciB0byBzaWduIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGlmICghXy5pc1N0cmluZyhwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHBydiBtdXN0IGJlIGEgc3RyaW5nLCBnb3QgdHlwZSAke3R5cGVvZiBwcnZ9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5UGFpciA9IHN0ZWxsYXIuS2V5cGFpci5mcm9tU2VjcmV0KHBydik7XG4gICAgY29uc3QgdHggPSBuZXcgc3RlbGxhci5UcmFuc2FjdGlvbih0eFByZWJ1aWxkLnR4QmFzZTY0LCB0aGlzLmdldFN0ZWxsYXJOZXR3b3JrKCkpO1xuICAgIHR4LnNpZ24oa2V5UGFpcik7XG4gICAgY29uc3QgdHhCYXNlNjQgPSBYbG0udHhUb1N0cmluZyh0eCk7XG5cbiAgICBjb25zdCB0eXBlID0gdHhQcmVidWlsZD8uYnVpbGRQYXJhbXM/LnR5cGU7XG4gICAgY29uc3QgcmVjaXBpZW50cyA9IHR4UHJlYnVpbGQ/LmJ1aWxkUGFyYW1zPy5yZWNpcGllbnRzO1xuICAgIGlmICh0eXBlID09PSAnZW5hYmxldG9rZW4nKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYWxmU2lnbmVkOiB7IHR4QmFzZTY0IH0sXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHJlY2lwaWVudHMsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBoYWxmU2lnbmVkOiB7IHR4QmFzZTY0IH0gfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXh0ZW5kIHdhbGxldFBhcmFtcyB3aXRoIGV4dHJhIHBhcmFtcyByZXF1aXJlZCBmb3IgZ2VuZXJhdGluZyBhbiBYTE0gd2FsbGV0XG4gICAqXG4gICAqIFN0ZWxsYXIgd2FsbGV0cyBoYXZlIHRocmVlIGtleWNoYWlucyBvbiB0aGVtLiBUd28gYXJlIGdlbmVyYXRlZCBieSB0aGUgcGxhdGZvcm0sIGFuZCB0aGUgbGFzdCBpcyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXIuXG4gICAqIEluaXRpYWxseSwgd2UgbmVlZCBhIHJvb3QgcHJ2IHRvIGdlbmVyYXRlIHRoZSBhY2NvdW50LCB3aGljaCBtdXN0IGJlIGRpc3RpbmN0IGZyb20gYWxsIHRocmVlIGtleWNoYWlucyBvbiB0aGUgd2FsbGV0LlxuICAgKiBJZiBhIHJvb3QgcHJ2IGlzIG5vdCBwcm92aWRlZCwgYSByYW5kb20gb25lIGlzIGdlbmVyYXRlZC5cbiAgICovXG4gIGFzeW5jIHN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldChcbiAgICB3YWxsZXRQYXJhbXM6IFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnNcbiAgKTogUHJvbWlzZTxTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zPiB7XG4gICAgbGV0IHNlZWQ7XG4gICAgY29uc3Qgcm9vdFBydiA9IHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleTtcbiAgICBpZiAocm9vdFBydikge1xuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRQcnYocm9vdFBydikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyb290UHJpdmF0ZUtleSBuZWVkcyB0byBiZSB2YWxpZCBlZDI1NTE5IHNlY3JldCBzZWVkJyk7XG4gICAgICB9XG4gICAgICBzZWVkID0gc3RlbGxhci5TdHJLZXkuZGVjb2RlRWQyNTUxOVNlY3JldFNlZWQocm9vdFBydik7XG4gICAgfVxuICAgIGNvbnN0IGtleVBhaXIgPSB0aGlzLmdlbmVyYXRlS2V5UGFpcihzZWVkKTtcbiAgICAvLyBleHRlbmQgdGhlIHdhbGxldCBpbml0aWFsaXphdGlvbiBwYXJhbXNcbiAgICB3YWxsZXRQYXJhbXMucm9vdFByaXZhdGVLZXkgPSBrZXlQYWlyLnBydjtcbiAgICByZXR1cm4gd2FsbGV0UGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gbWVzc2FnZSB3aXRoIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICovXG4gIGFzeW5jIHNpZ25NZXNzYWdlKGtleTogS2V5UGFpciwgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZFBydihrZXkucHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHBydjogJHtrZXkucHJ2fWApO1xuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihtZXNzYWdlKSkge1xuICAgICAgbWVzc2FnZSA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBrZXlwYWlyID0gc3RlbGxhci5LZXlwYWlyLmZyb21TZWNyZXQoa2V5LnBydik7XG4gICAgcmV0dXJuIGtleXBhaXIuc2lnbihtZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyBpZiBzaWduYXR1cmUgZm9yIG1lc3NhZ2UgaXMgdmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSBwdWIgcHVibGljIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZSBzaWduZWQgbWVzc2FnZVxuICAgKiBAcGFyYW0gc2lnbmF0dXJlIHNpZ25hdHVyZSB0byB2ZXJpZnlcbiAgICogQHJldHVybnMgdHJ1ZSBpZiBzaWduYXR1cmUgaXMgdmFsaWQuXG4gICAqL1xuICB2ZXJpZnlTaWduYXR1cmUocHViOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlciwgc2lnbmF0dXJlOiBCdWZmZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZFB1YihwdWIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgcHViOiAke3B1Yn1gKTtcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkpIHtcbiAgICAgIG1lc3NhZ2UgPSBCdWZmZXIuZnJvbShtZXNzYWdlKTtcbiAgICB9XG4gICAgY29uc3Qga2V5UGFpciA9IHN0ZWxsYXIuS2V5cGFpci5mcm9tUHVibGljS2V5KHB1Yik7XG4gICAgcmV0dXJuIGtleVBhaXIudmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGFpbi9wYXJzZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBleHBsYWluVHJhbnNhY3Rpb24ocGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPiB7XG4gICAgY29uc3QgeyB0eEhleCwgdHhCYXNlNjQgfSA9IHBhcmFtcztcbiAgICBsZXQgdHg6IHN0ZWxsYXIuVHJhbnNhY3Rpb24gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIXR4SGV4ICYmICF0eEJhc2U2NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBsYWluVHJhbnNhY3Rpb24gbWlzc2luZyB0eEhleCBvciB0eEJhc2U2NCBwYXJhbWV0ZXIsIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHR4SGV4KSB7XG4gICAgICAgIHR4ID0gbmV3IHN0ZWxsYXIuVHJhbnNhY3Rpb24oQnVmZmVyLmZyb20odHhIZXgsICdoZXgnKS50b1N0cmluZygnYmFzZTY0JyksIHRoaXMuZ2V0U3RlbGxhck5ldHdvcmsoKSk7XG4gICAgICB9IGVsc2UgaWYgKHR4QmFzZTY0KSB7XG4gICAgICAgIHR4ID0gbmV3IHN0ZWxsYXIuVHJhbnNhY3Rpb24odHhCYXNlNjQsIHRoaXMuZ2V0U3RlbGxhck5ldHdvcmsoKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eEJhc2U2NCBuZWVkcyB0byBiZSBhIHZhbGlkIHR4IGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghdHgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHggbmVlZHMgdG8gYmUgZGVmaW5lZCBpbiBvcmRlciB0byBleHBsYWluIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gdHguaGFzaCgpLnRvU3RyaW5nKCdoZXgnKTtcblxuICAgIC8vIEluIGEgU3RlbGxhciB0eCwgdGhlIF9tZW1vIHByb3BlcnR5IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBtZXRob2RzOlxuICAgIC8vIHZhbHVlKCkgYW5kIGFybSgpIHRoYXQgcHJvdmlkZSBtZW1vIHZhbHVlIGFuZCB0eXBlLCByZXNwZWN0aXZlbHkuXG4gICAgY29uc3QgbWVtbzogVHJhbnNhY3Rpb25NZW1vID1cbiAgICAgIF8ucmVzdWx0KHR4LCAnX21lbW8udmFsdWUnKSAmJiBfLnJlc3VsdCh0eCwgJ19tZW1vLmFybScpXG4gICAgICAgID8ge1xuICAgICAgICAgICAgdmFsdWU6IChfLnJlc3VsdCh0eCwgJ19tZW1vLnZhbHVlJykgYXMgYW55KS50b1N0cmluZygpLFxuICAgICAgICAgICAgdHlwZTogXy5yZXN1bHQodHgsICdfbWVtby5hcm0nKSxcbiAgICAgICAgICB9XG4gICAgICAgIDoge307XG5cbiAgICBsZXQgc3BlbmRBbW91bnQgPSBuZXcgQmlnTnVtYmVyKDApOyAvLyBhbW91bnQgb2YgWExNIHVzZWQgaW4gWExNLW9ubHkgdHhzXG4gICAgY29uc3Qgc3BlbmRBbW91bnRzID0ge307IC8vIHRyYWNrIGJvdGggeGxtIGFuZCB0b2tlbiBhbW91bnRzXG4gICAgaWYgKF8uaXNFbXB0eSh0eC5vcGVyYXRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIG9wZXJhdGlvbnMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRwdXRzOiBUcmFuc2FjdGlvbk91dHB1dFtdID0gW107XG4gICAgY29uc3Qgb3BlcmF0aW9uczogVHJhbnNhY3Rpb25PcGVyYXRpb25bXSA9IFtdOyAvLyBub24tcGF5bWVudCBvcGVyYXRpb25zXG5cbiAgICBfLmZvckVhY2godHgub3BlcmF0aW9ucywgKG9wOiBzdGVsbGFyLk9wZXJhdGlvbikgPT4ge1xuICAgICAgaWYgKG9wLnR5cGUgPT09ICdjcmVhdGVBY2NvdW50JyB8fCBvcC50eXBlID09PSAncGF5bWVudCcpIHtcbiAgICAgICAgLy8gVE9ETyBSZW1vdmUgbWVtb0lkIGZyb20gYWRkcmVzc1xuICAgICAgICAvLyBHZXQgbWVtbyB0byBhdHRhY2ggdG8gYWRkcmVzcywgaWYgdHlwZSBpcyAnaWQnXG4gICAgICAgIGNvbnN0IG1lbW9JZCA9IF8uZ2V0KG1lbW8sICd0eXBlJykgPT09ICdpZCcgJiYgIV8uZ2V0KG1lbW8sICd2YWx1ZScpID8gYD9tZW1vSWQ9JHttZW1vLnZhbHVlfWAgOiAnJztcbiAgICAgICAgbGV0IGFzc2V0O1xuICAgICAgICBpZiAob3AudHlwZSA9PT0gJ3BheW1lbnQnKSB7XG4gICAgICAgICAgaWYgKG9wLmFzc2V0LmdldEFzc2V0VHlwZSgpID09PSAnbGlxdWlkaXR5X3Bvb2xfc2hhcmVzJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFzc2V0IHR5cGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzZXQgPSBvcC5hc3NldCBhcyBzdGVsbGFyLkFzc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2V0ID0gc3RlbGxhci5Bc3NldC5uYXRpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2luID0gdGhpcy5nZXRUb2tlbk5hbWVGcm9tU3RlbGxhckFzc2V0KGFzc2V0KTsgLy8gY29pbiBvciB0b2tlbiBpZFxuICAgICAgICBjb25zdCBvdXRwdXQ6IFRyYW5zYWN0aW9uT3V0cHV0ID0ge1xuICAgICAgICAgIGFtb3VudDogdGhpcy5iaWdVbml0c1RvQmFzZVVuaXRzKFxuICAgICAgICAgICAgKG9wIGFzIHN0ZWxsYXIuT3BlcmF0aW9uLkNyZWF0ZUFjY291bnQpLnN0YXJ0aW5nQmFsYW5jZSB8fCAob3AgYXMgc3RlbGxhci5PcGVyYXRpb24uUGF5bWVudCkuYW1vdW50XG4gICAgICAgICAgKSxcbiAgICAgICAgICBhZGRyZXNzOiBvcC5kZXN0aW5hdGlvbiArIG1lbW9JZCxcbiAgICAgICAgICBjb2luLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChzcGVuZEFtb3VudHNbY29pbl0pKSB7XG4gICAgICAgICAgc3BlbmRBbW91bnRzW2NvaW5dID0gc3BlbmRBbW91bnRzW2NvaW5dLnBsdXMob3V0cHV0LmFtb3VudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3BlbmRBbW91bnRzW2NvaW5dID0gbmV3IEJpZ051bWJlcihvdXRwdXQuYW1vdW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXNzZXQuaXNOYXRpdmUoKSkge1xuICAgICAgICAgIHNwZW5kQW1vdW50ID0gc3BlbmRBbW91bnQucGx1cyhvdXRwdXQuYW1vdW50KTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRzLnB1c2gob3V0cHV0KTtcbiAgICAgIH0gZWxzZSBpZiAob3AudHlwZSA9PT0gJ2NoYW5nZVRydXN0Jykge1xuICAgICAgICBpZiAob3AubGluZS5nZXRBc3NldFR5cGUoKSA9PT0gJ2xpcXVpZGl0eV9wb29sX3NoYXJlcycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXNzZXQgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFzc2V0ID0gb3AubGluZSBhcyBzdGVsbGFyLkFzc2V0O1xuXG4gICAgICAgIG9wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogb3AudHlwZSxcbiAgICAgICAgICBjb2luOiB0aGlzLmdldFRva2VuTmFtZUZyb21TdGVsbGFyQXNzZXQoYXNzZXQpLFxuICAgICAgICAgIGFzc2V0LFxuICAgICAgICAgIGxpbWl0OiB0aGlzLmJpZ1VuaXRzVG9CYXNlVW5pdHMob3AubGltaXQpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IG91dHB1dEFtb3VudCA9IHNwZW5kQW1vdW50LnRvRml4ZWQoMCk7XG4gICAgY29uc3Qgb3V0cHV0QW1vdW50cyA9IF8ubWFwVmFsdWVzKHNwZW5kQW1vdW50cywgKGFtb3VudDogQmlnTnVtYmVyKSA9PiBhbW91bnQudG9GaXhlZCgwKSk7XG4gICAgY29uc3QgZmVlID0ge1xuICAgICAgZmVlOiBuZXcgQmlnTnVtYmVyKHR4LmZlZSkudG9GaXhlZCgwKSxcbiAgICAgIGZlZVJhdGU6IG51bGwsXG4gICAgICBzaXplOiBudWxsLFxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlzcGxheU9yZGVyOiBbXG4gICAgICAgICdpZCcsXG4gICAgICAgICdvdXRwdXRBbW91bnQnLFxuICAgICAgICAnb3V0cHV0QW1vdW50cycsXG4gICAgICAgICdjaGFuZ2VBbW91bnQnLFxuICAgICAgICAnb3V0cHV0cycsXG4gICAgICAgICdjaGFuZ2VPdXRwdXRzJyxcbiAgICAgICAgJ2ZlZScsXG4gICAgICAgICdtZW1vJyxcbiAgICAgICAgJ29wZXJhdGlvbnMnLFxuICAgICAgXSxcbiAgICAgIGlkLFxuICAgICAgb3V0cHV0cyxcbiAgICAgIG91dHB1dEFtb3VudCxcbiAgICAgIG91dHB1dEFtb3VudHMsXG4gICAgICBjaGFuZ2VPdXRwdXRzOiBbXSxcbiAgICAgIGNoYW5nZUFtb3VudDogJzAnLFxuICAgICAgbWVtbyxcbiAgICAgIGZlZSxcbiAgICAgIG9wZXJhdGlvbnMsXG4gICAgfSBhcyBhbnk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgYSB0eCBwcmVidWlsZCdzIG9wZXJhdGlvbnMgY29tcGx5IHdpdGggdGhlIG9yaWdpbmFsIGludGVudGlvblxuICAgKiBAcGFyYW0ge3N0ZWxsYXIuT3BlcmF0aW9ufSBvcGVyYXRpb25zIC0gdHggb3BlcmF0aW9uc1xuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uUGFyYW1zfSB0eFBhcmFtcyAtIHBhcmFtcyB1c2VkIHRvIGJ1aWxkIHRoZSB0eFxuICAgKi9cbiAgdmVyaWZ5RW5hYmxlVG9rZW5UeE9wZXJhdGlvbnMob3BlcmF0aW9uczogc3RlbGxhci5PcGVyYXRpb25bXSwgdHhQYXJhbXM6IFRyYW5zYWN0aW9uUGFyYW1zKTogdm9pZCB7XG4gICAgY29uc3QgdHJ1c3RsaW5lT3BlcmF0aW9ucyA9IF8uZmlsdGVyKG9wZXJhdGlvbnMsIFsndHlwZScsICdjaGFuZ2VUcnVzdCddKSBhcyBzdGVsbGFyLk9wZXJhdGlvbi5DaGFuZ2VUcnVzdFtdO1xuICAgIGlmICh0cnVzdGxpbmVPcGVyYXRpb25zLmxlbmd0aCAhPT0gXy5nZXQodHhQYXJhbXMsICdyZWNpcGllbnRzJywgW10pLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBwcmVidWlsZCBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCB0cnVzdGxpbmUgb3BlcmF0aW9ucycpO1xuICAgIH1cbiAgICBfLmZvckVhY2godHJ1c3RsaW5lT3BlcmF0aW9ucywgKG9wOiBzdGVsbGFyLk9wZXJhdGlvbikgPT4ge1xuICAgICAgaWYgKG9wLnR5cGUgIT09ICdjaGFuZ2VUcnVzdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFzc2V0IHR5cGUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcC5saW5lLmdldEFzc2V0VHlwZSgpID09PSAnbGlxdWlkaXR5X3Bvb2xfc2hhcmVzJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXNzZXQgdHlwZScpO1xuICAgICAgfVxuICAgICAgY29uc3QgYXNzZXQgPSBvcC5saW5lIGFzIHN0ZWxsYXIuQXNzZXQ7XG4gICAgICBjb25zdCBvcFRva2VuID0gdGhpcy5nZXRUb2tlbk5hbWVGcm9tU3RlbGxhckFzc2V0KGFzc2V0KTtcbiAgICAgIGNvbnN0IHRva2VuVHJ1c3RsaW5lID0gXy5maW5kKHR4UGFyYW1zLnJlY2lwaWVudHMsIChyZWNpcGllbnQpID0+IHtcbiAgICAgICAgLy8gdHJ1c3RsaW5lIHBhcmFtcyB1c2UgbGltaXRzIGluIGJhc2UgdW5pdHNcbiAgICAgICAgY29uc3Qgb3BMaW1pdEJhc2VVbml0cyA9IHRoaXMuYmlnVW5pdHNUb0Jhc2VVbml0cyhvcC5saW1pdCk7XG4gICAgICAgIC8vIEVuYWJsZSB0b2tlbiBsaW1pdCBpcyBzZXQgdG8gWGxtLm1heFRydXN0bGluZUxpbWl0IGJ5IGRlZmF1bHRcbiAgICAgICAgcmV0dXJuIHJlY2lwaWVudC50b2tlbk5hbWUgPT09IG9wVG9rZW4gJiYgb3BMaW1pdEJhc2VVbml0cyA9PT0gWGxtLm1heFRydXN0bGluZUxpbWl0O1xuICAgICAgfSk7XG4gICAgICBpZiAoIXRva2VuVHJ1c3RsaW5lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgdHJ1c3RsaW5lIHRva2VucycpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGF0IGEgdHggcHJlYnVpbGQncyBvcGVyYXRpb25zIGNvbXBseSB3aXRoIHRoZSBvcmlnaW5hbCBpbnRlbnRpb25cbiAgICogQHBhcmFtIHtzdGVsbGFyLk9wZXJhdGlvbn0gb3BlcmF0aW9ucyAtIHR4IG9wZXJhdGlvbnNcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvblBhcmFtc30gdHhQYXJhbXMgLSBwYXJhbXMgdXNlZCB0byBidWlsZCB0aGUgdHhcbiAgICovXG4gIHZlcmlmeVRydXN0bGluZVR4T3BlcmF0aW9ucyhvcGVyYXRpb25zOiBzdGVsbGFyLk9wZXJhdGlvbltdLCB0eFBhcmFtczogVHJhbnNhY3Rpb25QYXJhbXMpOiB2b2lkIHtcbiAgICBjb25zdCB0cnVzdGxpbmVPcGVyYXRpb25zID0gXy5maWx0ZXIob3BlcmF0aW9ucywgWyd0eXBlJywgJ2NoYW5nZVRydXN0J10pIGFzIHN0ZWxsYXIuT3BlcmF0aW9uLkNoYW5nZVRydXN0W107XG4gICAgaWYgKHRydXN0bGluZU9wZXJhdGlvbnMubGVuZ3RoICE9PSBfLmdldCh0eFBhcmFtcywgJ3RydXN0bGluZXMnLCBbXSkubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHRydXN0bGluZSBvcGVyYXRpb25zJyk7XG4gICAgfVxuICAgIF8uZm9yRWFjaCh0cnVzdGxpbmVPcGVyYXRpb25zLCAob3A6IHN0ZWxsYXIuT3BlcmF0aW9uKSA9PiB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gJ2NoYW5nZVRydXN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXNzZXQgdHlwZScpO1xuICAgICAgfVxuICAgICAgaWYgKG9wLmxpbmUuZ2V0QXNzZXRUeXBlKCkgPT09ICdsaXF1aWRpdHlfcG9vbF9zaGFyZXMnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhc3NldCB0eXBlJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBhc3NldCA9IG9wLmxpbmUgYXMgc3RlbGxhci5Bc3NldDtcbiAgICAgIGNvbnN0IG9wVG9rZW4gPSB0aGlzLmdldFRva2VuTmFtZUZyb21TdGVsbGFyQXNzZXQoYXNzZXQpO1xuICAgICAgY29uc3QgdG9rZW5UcnVzdGxpbmUgPSBfLmZpbmQodHhQYXJhbXMudHJ1c3RsaW5lcywgKHRydXN0bGluZSkgPT4ge1xuICAgICAgICAvLyB0cnVzdGxpbmUgcGFyYW1zIHVzZSBsaW1pdHMgaW4gYmFzZSB1bml0c1xuICAgICAgICBjb25zdCBvcExpbWl0QmFzZVVuaXRzID0gdGhpcy5iaWdVbml0c1RvQmFzZVVuaXRzKG9wLmxpbWl0KTtcbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgY29uZGl0aW9ucyB0byBjaGVjayBmb3JcbiAgICAgICAgLy8gTGltaXQgd2lsbCBhbHdheXMgYmUgc2V0IGluIHRoZSBvcGVyYXRpb24sIGV2ZW4gaWYgaXQgd2FzIG9taXR0ZWQgZnJvbSB0eFBhcmFtcyBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxLiBBY3Rpb24gaXMgJ2FkZCcgLSBsaW1pdCBpcyBzZXQgdG8gWGxtLm1heFRydXN0bGluZUxpbWl0IGJ5IGRlZmF1bHRcbiAgICAgICAgLy8gMi4gQWN0aW9uIGlzICdyZW1vdmUnIC0gbGltaXQgaXMgc2V0IHRvICcwJ1xuICAgICAgICBjb25zdCBub0xpbWl0ID0gXy5pc1VuZGVmaW5lZCh0cnVzdGxpbmUubGltaXQpO1xuICAgICAgICBjb25zdCBhZGRUcnVzdGxpbmVXaXRoRGVmYXVsdExpbWl0ID0gdHJ1c3RsaW5lLmFjdGlvbiA9PT0gJ2FkZCcgJiYgb3BMaW1pdEJhc2VVbml0cyA9PT0gWGxtLm1heFRydXN0bGluZUxpbWl0O1xuICAgICAgICBjb25zdCByZW1vdmVUcnVzdGxpbmUgPSB0cnVzdGxpbmUuYWN0aW9uID09PSAncmVtb3ZlJyAmJiBvcExpbWl0QmFzZVVuaXRzID09PSAnMCc7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgdHJ1c3RsaW5lLnRva2VuID09PSBvcFRva2VuICYmXG4gICAgICAgICAgKHRydXN0bGluZS5saW1pdCA9PT0gb3BMaW1pdEJhc2VVbml0cyB8fCAobm9MaW1pdCAmJiAoYWRkVHJ1c3RsaW5lV2l0aERlZmF1bHRMaW1pdCB8fCByZW1vdmVUcnVzdGxpbmUpKSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0b2tlblRydXN0bGluZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHRydXN0bGluZSB0b2tlbnMnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhhdCBhIHRyYW5zYWN0aW9uIHByZWJ1aWxkIGNvbXBsaWVzIHdpdGggdGhlIG9yaWdpbmFsIGludGVudGlvblxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy50eFByZWJ1aWxkIHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBwbGF0Zm9ybVxuICAgKiBAcGFyYW0gb3B0aW9ucy50eFByZWJ1aWxkLnR4QmFzZTY0IHByZWJ1aWx0IHRyYW5zYWN0aW9uIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ1xuICAgKiBAcGFyYW0gb3B0aW9ucy53YWxsZXQgd2FsbGV0IG9iamVjdCB0byBvYnRhaW4ga2V5cyB0byB2ZXJpZnkgYWdhaW5zdFxuICAgKiBAcGFyYW0gb3B0aW9ucy52ZXJpZmljYXRpb24gc3BlY2lmeWluZyBzb21lIHZlcmlmaWNhdGlvbiBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLnZlcmlmaWNhdGlvbi5kaXNhYmxlTmV0d29ya2luZyBEaXNhbGxvdyBmZXRjaGluZyBhbnkgZGF0YSBmcm9tIHRoZSBpbnRlcm5ldCBmb3IgdmVyaWZpY2F0aW9uIHB1cnBvc2VzXG4gICAqIEBwYXJhbSBvcHRpb25zLnZlcmlmaWNhdGlvbi5rZXljaGFpbnMgUGFzcyBrZXljaGFpbnMgbWFudWFsbHkgcmF0aGVyIHRoYW4gZmV0Y2hpbmcgdGhlbSBieSBpZFxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ob3B0aW9uczogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgLy8gVE9ETyBCRy01NjAwIEFkZCBwYXJzZVRyYW5zYWN0aW9uIC8gaW1wcm92ZSB2ZXJpZmljYXRpb25cbiAgICBjb25zdCB7IHR4UGFyYW1zLCB0eFByZWJ1aWxkLCB3YWxsZXQsIHZlcmlmaWNhdGlvbiA9IHt9IH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGRpc2FibGVOZXR3b3JraW5nID0gISF2ZXJpZmljYXRpb24uZGlzYWJsZU5ldHdvcmtpbmc7XG5cbiAgICBpZiAoIXR4UHJlYnVpbGQudHhCYXNlNjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCB0eCBwcmVidWlsZCBwcm9wZXJ0eSB0eEJhc2U2NCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHR4ID0gbmV3IHN0ZWxsYXIuVHJhbnNhY3Rpb24odHhQcmVidWlsZC50eEJhc2U2NCwgdGhpcy5nZXRTdGVsbGFyTmV0d29yaygpKTtcblxuICAgIGlmICh0eFBhcmFtcy5yZWNpcGllbnRzICYmIHR4UGFyYW1zLnJlY2lwaWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3BlY2lmeSBtb3JlIHRoYW4gMSByZWNpcGllbnQnKTtcbiAgICB9XG5cbiAgICAvLyBTdGVsbGFyIHR4cyBhcmUgbWFkZSB1cCBvZiBvcGVyYXRpb25zLiBXZSBvbmx5IGNhcmUgYWJvdXQgQ3JlYXRlIEFjY291bnQgYW5kIFBheW1lbnQgZm9yIHNlbmRpbmcgZnVuZHMuXG4gICAgY29uc3Qgb3V0cHV0T3BlcmF0aW9ucyA9IF8uZmlsdGVyKFxuICAgICAgdHgub3BlcmF0aW9ucyxcbiAgICAgIChvcGVyYXRpb24pID0+IG9wZXJhdGlvbi50eXBlID09PSAnY3JlYXRlQWNjb3VudCcgfHwgb3BlcmF0aW9uLnR5cGUgPT09ICdwYXltZW50J1xuICAgICk7XG5cbiAgICBpZiAodHhQYXJhbXMudHlwZSA9PT0gJ2VuYWJsZXRva2VuJykge1xuICAgICAgdGhpcy52ZXJpZnlFbmFibGVUb2tlblR4T3BlcmF0aW9ucyh0eC5vcGVyYXRpb25zLCB0eFBhcmFtcyk7XG4gICAgfSBlbHNlIGlmICh0eFBhcmFtcy50eXBlID09PSAndHJ1c3RsaW5lJykge1xuICAgICAgdGhpcy52ZXJpZnlUcnVzdGxpbmVUeE9wZXJhdGlvbnModHgub3BlcmF0aW9ucywgdHhQYXJhbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoXy5pc0VtcHR5KG91dHB1dE9wZXJhdGlvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgaGF2ZSBhbnkgb3BlcmF0aW9ucycpO1xuICAgICAgfVxuXG4gICAgICBfLmZvckVhY2godHhQYXJhbXMucmVjaXBpZW50cywgKGV4cGVjdGVkT3V0cHV0LCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBleHBlY3RlZE91dHB1dEFkZHJlc3NEZXRhaWxzID0gdGhpcy5nZXRBZGRyZXNzRGV0YWlscyhleHBlY3RlZE91dHB1dC5hZGRyZXNzKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRPdXRwdXRBZGRyZXNzID0gZXhwZWN0ZWRPdXRwdXRBZGRyZXNzRGV0YWlscy5hZGRyZXNzO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRPcGVyYXRpb25zW2luZGV4XSBhcyBzdGVsbGFyLk9wZXJhdGlvbi5QYXltZW50IHwgc3RlbGxhci5PcGVyYXRpb24uQ3JlYXRlQWNjb3VudDtcbiAgICAgICAgaWYgKG91dHB1dC5kZXN0aW5hdGlvbiAhPT0gZXhwZWN0ZWRPdXRwdXRBZGRyZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBwcmVidWlsZCBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCByZWNpcGllbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkT3V0cHV0QW1vdW50ID0gbmV3IEJpZ051bWJlcihleHBlY3RlZE91dHB1dC5hbW91bnQpO1xuICAgICAgICAvLyBUaGUgb3V0cHV0IGFtb3VudCBpcyBleHByZXNzZWQgYXMgc3RhcnRpbmdCYWxhbmNlIGluIGNyZWF0ZUFjY291bnQgb3BlcmF0aW9ucyBhbmQgYXMgYW1vdW50IGluIHBheW1lbnQgb3BlcmF0aW9ucy5cbiAgICAgICAgY29uc3Qgb3V0cHV0QW1vdW50U3RyaW5nID0gb3V0cHV0LnR5cGUgPT09ICdjcmVhdGVBY2NvdW50JyA/IG91dHB1dC5zdGFydGluZ0JhbGFuY2UgOiBvdXRwdXQuYW1vdW50O1xuICAgICAgICBjb25zdCBvdXRwdXRBbW91bnQgPSBuZXcgQmlnTnVtYmVyKHRoaXMuYmlnVW5pdHNUb0Jhc2VVbml0cyhvdXRwdXRBbW91bnRTdHJpbmcpKTtcblxuICAgICAgICBpZiAoIW91dHB1dEFtb3VudC5lcShleHBlY3RlZE91dHB1dEFtb3VudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIGFtb3VudCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgdGhlIHVzZXIgc2lnbmF0dXJlLCBpZiB0aGUgdHggaXMgaGFsZi1zaWduZWRcbiAgICBpZiAoIV8uaXNFbXB0eSh0eC5zaWduYXR1cmVzKSkge1xuICAgICAgY29uc3QgdXNlclNpZ25hdHVyZSA9IHR4LnNpZ25hdHVyZXNbMF0uc2lnbmF0dXJlKCk7XG5cbiAgICAgIC8vIG9idGFpbiB0aGUga2V5Y2hhaW5zIGFuZCBrZXkgc2lnbmF0dXJlc1xuICAgICAgbGV0IGtleWNoYWlucyA9IHZlcmlmaWNhdGlvbi5rZXljaGFpbnM7XG4gICAgICBpZiAoIWtleWNoYWlucyAmJiBkaXNhYmxlTmV0d29ya2luZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBmZXRjaCBrZXljaGFpbnMgd2l0aG91dCBuZXR3b3JraW5nJyk7XG4gICAgICB9IGVsc2UgaWYgKCFrZXljaGFpbnMpIHtcbiAgICAgICAga2V5Y2hhaW5zID0gYXdhaXQgcHJvbWlzZVByb3BzKHtcbiAgICAgICAgICB1c2VyOiB0aGlzLmtleWNoYWlucygpLmdldCh7IGlkOiB3YWxsZXQua2V5SWRzKClbS2V5SW5kaWNlcy5VU0VSXSB9KSxcbiAgICAgICAgICBiYWNrdXA6IHRoaXMua2V5Y2hhaW5zKCkuZ2V0KHsgaWQ6IHdhbGxldC5rZXlJZHMoKVtLZXlJbmRpY2VzLkJBQ0tVUF0gfSksXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWtleWNoYWlucyB8fCAha2V5Y2hhaW5zLmJhY2t1cCB8fCAha2V5Y2hhaW5zLnVzZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXljaGFpbnMgYXJlIHJlcXVpcmVkLCBidXQgY291bGQgbm90IGJlIGZldGNoZWQnKTtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KGtleWNoYWlucy5iYWNrdXAucHViKTtcbiAgICAgIGlmICh0aGlzLnZlcmlmeVNpZ25hdHVyZShrZXljaGFpbnMuYmFja3VwLnB1YiwgdHguaGFzaCgpLCB1c2VyU2lnbmF0dXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHNpZ25lZCB3aXRoIHdyb25nIGtleScpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGtleWNoYWlucy51c2VyLnB1Yik7XG4gICAgICBpZiAoIXRoaXMudmVyaWZ5U2lnbmF0dXJlKGtleWNoYWlucy51c2VyLnB1YiwgdHguaGFzaCgpLCB1c2VyU2lnbmF0dXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHNpZ25hdHVyZSBpbnZhbGlkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogaW5oZXJpdGRvYyAqL1xuICBkZXJpdmVLZXlXaXRoU2VlZCgpOiB7IGRlcml2YXRpb25QYXRoOiBzdHJpbmc7IGtleTogc3RyaW5nIH0ge1xuICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQoJ21ldGhvZCBkZXJpdmVLZXlXaXRoU2VlZCBub3Qgc3VwcG9ydGVkIGZvciBlZGRzYSBjdXJ2ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIHN0ZWxsYXItc2RrIGhhcyB0d28gb3ZlcmxvYWRzIGZvciB0b1hEUiwgYW5kIHR5cGVzY3JpcHQgY2FuJ3Qgc2VlbSB0byBmaWd1cmUgb3V0IHRoZVxuICAgKiBjb3JyZWN0IG9uZSB0byB1c2UsIHNvIHdlIGhhdmUgdG8gYmUgdmVyeSBleHBsaWNpdCBhcyB0byB3aGljaCBvbmUgd2Ugd2FudC5cbiAgICogQHBhcmFtIHR4IHRyYW5zYWN0aW9uIHRvIGNvbnZlcnRcbiAgICovXG4gIHByb3RlY3RlZCBzdGF0aWMgdHhUb1N0cmluZyA9ICh0eDogc3RlbGxhci5UcmFuc2FjdGlvbik6IHN0cmluZyA9PlxuICAgICh0eC50b0VudmVsb3BlKCkudG9YRFIgYXMgKF86IHN0cmluZykgPT4gc3RyaW5nKSgnYmFzZTY0Jyk7XG5cbiAgYXN5bmMgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNvbmZpZyBmb3IgaG93IHRva2VuIGVuYWJsZW1lbnRzIHdvcmsgZm9yIHRoaXMgY29pblxuICAgKiBAcmV0dXJuc1xuICAgKiAgICByZXF1aXJlc1Rva2VuRW5hYmxlbWVudDogVHJ1ZSBpZiB0b2tlbnMgbmVlZCB0byBiZSBlbmFibGVkIGZvciB0aGlzIGNvaW5cbiAgICogICAgc3VwcG9ydHNNdWx0aXBsZVRva2VuRW5hYmxlbWVudHM6IFRydWUgaWYgbXVsdGlwbGUgdG9rZW5zIGNhbiBiZSBlbmFibGVkIGluIG9uZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZ2V0VG9rZW5FbmFibGVtZW50Q29uZmlnKCk6IFRva2VuRW5hYmxlbWVudENvbmZpZyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcXVpcmVzVG9rZW5FbmFibGVtZW50OiB0cnVlLFxuICAgICAgc3VwcG9ydHNNdWx0aXBsZVRva2VuRW5hYmxlbWVudHM6IGZhbHNlLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==