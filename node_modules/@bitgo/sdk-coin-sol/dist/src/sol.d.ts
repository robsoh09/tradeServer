/**
 * @prettier
 */
/// <reference types="node" />
import { BaseBroadcastTransactionOptions, BaseBroadcastTransactionResult, BaseCoin, ParseTransactionOptions as BaseParseTransactionOptions, TransactionPrebuild as BaseTransactionPrebuild, BitGoBase, KeyPair, Memo, MPCAlgorithm, MPCConsolidationRecoveryOptions, MPCRecoveryOptions, MPCSweepRecoveryOptions, MPCSweepTxs, MPCTx, MPCTxs, ParsedTransaction, PresignTransactionOptions, SignedTransaction, SignTransactionOptions, TokenEnablementConfig, TransactionExplanation, TransactionRecipient, VerifyAddressOptions, VerifyTransactionOptions } from '@bitgo/sdk-core';
import { BaseNetwork, CoinFamily, BaseCoin as StaticsBaseCoin } from '@bitgo/statics';
import * as request from 'superagent';
export declare const DEFAULT_SCAN_FACTOR = 20;
export interface TransactionFee {
    fee: string;
}
export declare type SolTransactionExplanation = TransactionExplanation;
export interface ExplainTransactionOptions {
    txBase64: string;
    feeInfo: TransactionFee;
    tokenAccountRentExemptAmount?: string;
}
export interface TxInfo {
    recipients: TransactionRecipient[];
    from: string;
    txid: string;
}
export interface SolSignTransactionOptions extends SignTransactionOptions {
    txPrebuild: TransactionPrebuild;
    prv: string | string[];
    pubKeys?: string[];
}
export interface TransactionPrebuild extends BaseTransactionPrebuild {
    txBase64: string;
    txInfo: TxInfo;
    source: string;
}
export interface SolVerifyTransactionOptions extends VerifyTransactionOptions {
    memo?: Memo;
    feePayer: string;
    blockhash: string;
    durableNonce?: {
        walletNonceAddress: string;
        authWalletAddress: number;
    };
}
interface TransactionOutput {
    address: string;
    amount: number | string;
    tokenName?: string;
}
declare type TransactionInput = TransactionOutput;
export interface SolParsedTransaction extends ParsedTransaction {
    inputs: TransactionInput[];
    outputs: TransactionOutput[];
}
export interface SolParseTransactionOptions extends BaseParseTransactionOptions {
    txBase64: string;
    feeInfo: TransactionFee;
    tokenAccountRentExemptAmount?: string;
}
interface SolDurableNonceFromNode {
    authority: string;
    blockhash: string;
}
interface TokenAmount {
    amount: string;
    decimals: number;
    uiAmount: number;
    uiAmountString: string;
}
interface TokenAccountInfo {
    isNative: boolean;
    mint: string;
    owner: string;
    state: string;
    tokenAmount: TokenAmount;
}
interface TokenAccount {
    info: TokenAccountInfo;
    pubKey: string;
    tokenName?: string;
}
export interface SolRecoveryOptions extends MPCRecoveryOptions {
    durableNonce?: {
        publicKey: string;
        secretKey: string;
    };
    tokenContractAddress?: string;
    closeAtaAddress?: string;
}
export interface SolConsolidationRecoveryOptions extends MPCConsolidationRecoveryOptions {
    durableNonces: {
        publicKeys: string[];
        secretKey: string;
    };
    tokenContractAddress?: string;
}
export declare class Sol extends BaseCoin {
    protected readonly _staticsCoin: Readonly<StaticsBaseCoin>;
    constructor(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>);
    static createInstance(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>): BaseCoin;
    allowsAccountConsolidations(): boolean;
    supportsTss(): boolean;
    getMPCAlgorithm(): MPCAlgorithm;
    getChain(): string;
    getFamily(): CoinFamily;
    getFullName(): string;
    getNetwork(): BaseNetwork;
    getBaseFactor(): string | number;
    verifyTransaction(params: SolVerifyTransactionOptions): Promise<any>;
    isWalletAddress(params: VerifyAddressOptions): Promise<boolean>;
    /**
     * Generate Solana key pair
     *
     * @param {Buffer} seed - Seed from which the new SolKeyPair should be generated, otherwise a random seed is used
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed?: Buffer | undefined): KeyPair;
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {string} pub the prv to be checked
     * @returns is it valid?
     */
    isValidPub(pub: string): boolean;
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param {string} prv the prv to be checked
     * @returns is it valid?
     */
    isValidPrv(prv: string): boolean;
    isValidAddress(address: string): boolean;
    signMessage(key: KeyPair, message: string | Buffer): Promise<Buffer>;
    /**
     * Signs Solana transaction
     * @param params
     * @param callback
     */
    signTransaction(params: SolSignTransactionOptions): Promise<SignedTransaction>;
    parseTransaction(params: SolParseTransactionOptions): Promise<SolParsedTransaction>;
    /**
     * Explain a Solana transaction from txBase64
     * @param params
     */
    explainTransaction(params: ExplainTransactionOptions): Promise<SolTransactionExplanation>;
    /** @inheritDoc */
    getSignablePayload(serializedTx: string): Promise<Buffer>;
    /** @inheritDoc */
    presignTransaction(params: PresignTransactionOptions): Promise<PresignTransactionOptions>;
    protected getPublicNodeUrl(): string;
    /**
     * Make a request to one of the public SOL nodes available
     * @param params.payload
     */
    protected getDataFromNode(params: {
        payload?: Record<string, unknown>;
    }): Promise<request.Response>;
    protected getBlockhash(): Promise<string>;
    /** TODO Update to getFeeForMessage and make necssary changes in fee calculation, GetFees is deprecated */
    protected getFees(): Promise<number>;
    protected getRentExemptAmount(): Promise<number>;
    protected getAccountBalance(pubKey: string): Promise<number>;
    protected getAccountInfo(pubKey: string): Promise<SolDurableNonceFromNode>;
    protected getTokenAccountsByOwner(pubKey?: string): Promise<[] | TokenAccount[]>;
    /**
     * Creates funds sweep recovery transaction(s) without BitGo
     *
     * @param {SweepRecoveryOptions} params parameters needed to combine the signatures
     * and transactions to create broadcastable transactions
     *
     * @returns {MPCTxs} array of the serialized transaction hex strings and indices
     * of the addresses being swept
     */
    createBroadcastableSweepTransaction(params: MPCSweepRecoveryOptions): Promise<MPCTxs>;
    /**
     * Builds a funds recovery transaction without BitGo
     * @param {SolRecoveryOptions} params parameters needed to construct and
     * (maybe) sign the transaction
     *
     * @returns {MPCTx | MPCSweepTxs} the serialized transaction hex string and index
     * of the address being swept
     */
    recover(params: SolRecoveryOptions): Promise<MPCTx | MPCSweepTxs>;
    /**
     * Builds a funds recovery transaction without BitGo
     * @param {SolRecoveryOptions} params parameters needed to construct and
     * (maybe) sign the transaction
     *
     * @returns {MPCTx | MPCSweepTxs} the serialized transaction hex string and index
     * of the address being swept
     */
    recoverCloseATA(params: SolRecoveryOptions): Promise<MPCTx | MPCSweepTxs>;
    /**
     * Builds native SOL recoveries of receive addresses in batch without BitGo.
     * Funds will be recovered to base address first. You need to initiate another sweep txn after that.
     *
     * @param {SolConsolidationRecoveryOptions} params - options for consolidation recovery.
     * @param {string} [params.startingScanIndex] - receive address index to start scanning from. default to 1 (inclusive).
     * @param {string} [params.endingScanIndex] - receive address index to end scanning at. default to startingScanIndex + 20 (exclusive).
     */
    recoverConsolidations(params: SolConsolidationRecoveryOptions): Promise<MPCTxs | MPCSweepTxs>;
    getTokenEnablementConfig(): TokenEnablementConfig;
    private getBuilder;
    broadcastTransaction({ serializedSignedTransaction, }: BaseBroadcastTransactionOptions): Promise<BaseBroadcastTransactionResult>;
}
export {};
//# sourceMappingURL=sol.d.ts.map