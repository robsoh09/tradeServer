"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenTransferBuilder = void 0;
const statics_1 = require("@bitgo/statics");
const sdk_core_1 = require("@bitgo/sdk-core");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const assert_1 = __importDefault(require("assert"));
const transactionBuilder_1 = require("./transactionBuilder");
const lodash_1 = __importDefault(require("lodash"));
const UNSIGNED_BIGINT_MAX = BigInt('18446744073709551615');
class TokenTransferBuilder extends transactionBuilder_1.TransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
        this._sendParams = [];
        this._createAtaParams = [];
    }
    get transactionType() {
        return sdk_core_1.TransactionType.Send;
    }
    initBuilder(tx) {
        super.initBuilder(tx);
        for (const instruction of this._instructionsData) {
            if (instruction.type === constants_1.InstructionBuilderTypes.TokenTransfer) {
                const transferInstruction = instruction;
                this.sender(transferInstruction.params.fromAddress);
                this.send({
                    address: transferInstruction.params.toAddress,
                    amount: transferInstruction.params.amount,
                    tokenName: transferInstruction.params.tokenName,
                });
            }
            if (instruction.type === constants_1.InstructionBuilderTypes.CreateAssociatedTokenAccount) {
                const ataInitInstruction = instruction;
                this._createAtaParams.push({
                    ownerAddress: ataInitInstruction.params.ownerAddress,
                    tokenName: ataInitInstruction.params.tokenName,
                });
            }
        }
    }
    /**
     *  Set a transfer
     *
     * @param {SendParams} params - params for the transfer
     * @param {string} params.address - the receiver token address
     * @param {string} params.amount - the amount sent
     * @param {string} params.tokenName - name of token that is intended to send
     * @returns {TransactionBuilder} This transaction builder
     */
    send({ address, amount, tokenName }) {
        (0, utils_1.validateAddress)(address, 'address');
        if (!amount || !(0, utils_1.isValidAmount)(amount)) {
            throw new sdk_core_1.BuildTransactionError('Invalid or missing amount, got: ' + amount);
        }
        if (BigInt(amount) > UNSIGNED_BIGINT_MAX) {
            throw new sdk_core_1.BuildTransactionError(`input amount ${amount} exceeds big int limit ${UNSIGNED_BIGINT_MAX}`);
        }
        this._sendParams.push({ address, amount, tokenName: tokenName });
        return this;
    }
    /**
     *
     * @param {TokenAssociateRecipient} recipient - recipient of the associated token account creation
     * @param {string} recipient.ownerAddress - owner of the associated token account
     * @param {string} recipient.tokenName - name of the token that is intended to associate
     * @returns {TransactionBuilder} This transaction builder
     */
    createAssociatedTokenAccount(recipient) {
        (0, utils_1.validateOwnerAddress)(recipient.ownerAddress);
        const token = (0, utils_1.getSolTokenFromTokenName)(recipient.tokenName);
        if (!token) {
            throw new sdk_core_1.BuildTransactionError('Invalid token name, got: ' + recipient.tokenName);
        }
        (0, utils_1.validateMintAddress)(token.tokenAddress);
        this._createAtaParams.push(recipient);
        return this;
    }
    /** @inheritdoc */
    async buildImplementation() {
        (0, assert_1.default)(this._sender, 'Sender must be set before building the transaction');
        const sendInstructions = await Promise.all(this._sendParams.map(async (sendParams) => {
            const coin = (0, utils_1.getSolTokenFromTokenName)(sendParams.tokenName);
            (0, assert_1.default)(coin instanceof statics_1.SolCoin);
            const sourceAddress = await (0, utils_1.getAssociatedTokenAccountAddress)(coin.tokenAddress, this._sender);
            return {
                type: constants_1.InstructionBuilderTypes.TokenTransfer,
                params: {
                    fromAddress: this._sender,
                    toAddress: sendParams.address,
                    amount: sendParams.amount,
                    tokenName: coin.name,
                    sourceAddress: sourceAddress,
                },
            };
        }));
        const uniqueCreateAtaParams = lodash_1.default.uniqBy(this._createAtaParams, (recipient) => {
            return recipient.ownerAddress + recipient.tokenName;
        });
        const createAtaInstructions = await Promise.all(uniqueCreateAtaParams.map(async (recipient) => {
            const coin = (0, utils_1.getSolTokenFromTokenName)(recipient.tokenName);
            (0, assert_1.default)(coin instanceof statics_1.SolCoin);
            const recipientTokenAddress = await (0, utils_1.getAssociatedTokenAccountAddress)(coin.tokenAddress, recipient.ownerAddress);
            return {
                type: constants_1.InstructionBuilderTypes.CreateAssociatedTokenAccount,
                params: {
                    ownerAddress: recipient.ownerAddress,
                    tokenName: coin.name,
                    mintAddress: coin.tokenAddress,
                    ataAddress: recipientTokenAddress,
                    payerAddress: this._sender,
                },
            };
        }));
        // order is important, createAtaInstructions must be before sendInstructions
        this._instructionsData = [...createAtaInstructions, ...sendInstructions];
        return await super.buildImplementation();
    }
}
exports.TokenTransferBuilder = TokenTransferBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW5UcmFuc2ZlckJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3Rva2VuVHJhbnNmZXJCdWlsZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDRDQUFpRTtBQUNqRSw4Q0FBeUU7QUFFekUsbUNBT2lCO0FBQ2pCLDJDQUFzRDtBQUV0RCxvREFBNEI7QUFDNUIsNkRBQTBEO0FBQzFELG9EQUF1QjtBQVF2QixNQUFNLG1CQUFtQixHQUFHLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBRTNELE1BQWEsb0JBQXFCLFNBQVEsdUNBQWtCO0lBSTFELFlBQVksV0FBaUM7UUFDM0MsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBSmIsZ0JBQVcsR0FBaUIsRUFBRSxDQUFDO1FBS3JDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLENBQUM7SUFDN0IsQ0FBQztJQUVELElBQWMsZUFBZTtRQUMzQixPQUFPLDBCQUFlLENBQUMsSUFBSSxDQUFDO0lBQzlCLENBQUM7SUFFRCxXQUFXLENBQUMsRUFBZTtRQUN6QixLQUFLLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXRCLEtBQUssTUFBTSxXQUFXLElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFO1lBQ2hELElBQUksV0FBVyxDQUFDLElBQUksS0FBSyxtQ0FBdUIsQ0FBQyxhQUFhLEVBQUU7Z0JBQzlELE1BQU0sbUJBQW1CLEdBQWtCLFdBQVcsQ0FBQztnQkFDdkQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBQ3BELElBQUksQ0FBQyxJQUFJLENBQUM7b0JBQ1IsT0FBTyxFQUFFLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxTQUFTO29CQUM3QyxNQUFNLEVBQUUsbUJBQW1CLENBQUMsTUFBTSxDQUFDLE1BQU07b0JBQ3pDLFNBQVMsRUFBRSxtQkFBbUIsQ0FB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aW4gYXMgQ29pbkNvbmZpZywgU29sQ29pbiB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IEJ1aWxkVHJhbnNhY3Rpb25FcnJvciwgVHJhbnNhY3Rpb25UeXBlIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi90cmFuc2FjdGlvbic7XG5pbXBvcnQge1xuICBnZXRBc3NvY2lhdGVkVG9rZW5BY2NvdW50QWRkcmVzcyxcbiAgZ2V0U29sVG9rZW5Gcm9tVG9rZW5OYW1lLFxuICBpc1ZhbGlkQW1vdW50LFxuICB2YWxpZGF0ZUFkZHJlc3MsXG4gIHZhbGlkYXRlTWludEFkZHJlc3MsXG4gIHZhbGlkYXRlT3duZXJBZGRyZXNzLFxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IEluc3RydWN0aW9uQnVpbGRlclR5cGVzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQXRhSW5pdCwgVG9rZW5Bc3NvY2lhdGVSZWNpcGllbnQsIFRva2VuVHJhbnNmZXIgfSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7IFRyYW5zYWN0aW9uQnVpbGRlciB9IGZyb20gJy4vdHJhbnNhY3Rpb25CdWlsZGVyJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VuZFBhcmFtcyB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgYW1vdW50OiBzdHJpbmc7XG4gIHRva2VuTmFtZTogc3RyaW5nO1xufVxuXG5jb25zdCBVTlNJR05FRF9CSUdJTlRfTUFYID0gQmlnSW50KCcxODQ0Njc0NDA3MzcwOTU1MTYxNScpO1xuXG5leHBvcnQgY2xhc3MgVG9rZW5UcmFuc2ZlckJ1aWxkZXIgZXh0ZW5kcyBUcmFuc2FjdGlvbkJ1aWxkZXIge1xuICBwcml2YXRlIF9zZW5kUGFyYW1zOiBTZW5kUGFyYW1zW10gPSBbXTtcbiAgcHJpdmF0ZSBfY3JlYXRlQXRhUGFyYW1zOiBUb2tlbkFzc29jaWF0ZVJlY2lwaWVudFtdO1xuXG4gIGNvbnN0cnVjdG9yKF9jb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xuICAgIHN1cGVyKF9jb2luQ29uZmlnKTtcbiAgICB0aGlzLl9jcmVhdGVBdGFQYXJhbXMgPSBbXTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgdHJhbnNhY3Rpb25UeXBlKCk6IFRyYW5zYWN0aW9uVHlwZSB7XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZS5TZW5kO1xuICB9XG5cbiAgaW5pdEJ1aWxkZXIodHg6IFRyYW5zYWN0aW9uKTogdm9pZCB7XG4gICAgc3VwZXIuaW5pdEJ1aWxkZXIodHgpO1xuXG4gICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiB0aGlzLl9pbnN0cnVjdGlvbnNEYXRhKSB7XG4gICAgICBpZiAoaW5zdHJ1Y3Rpb24udHlwZSA9PT0gSW5zdHJ1Y3Rpb25CdWlsZGVyVHlwZXMuVG9rZW5UcmFuc2Zlcikge1xuICAgICAgICBjb25zdCB0cmFuc2Zlckluc3RydWN0aW9uOiBUb2tlblRyYW5zZmVyID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgIHRoaXMuc2VuZGVyKHRyYW5zZmVySW5zdHJ1Y3Rpb24ucGFyYW1zLmZyb21BZGRyZXNzKTtcbiAgICAgICAgdGhpcy5zZW5kKHtcbiAgICAgICAgICBhZGRyZXNzOiB0cmFuc2Zlckluc3RydWN0aW9uLnBhcmFtcy50b0FkZHJlc3MsXG4gICAgICAgICAgYW1vdW50OiB0cmFuc2Zlckluc3RydWN0aW9uLnBhcmFtcy5hbW91bnQsXG4gICAgICAgICAgdG9rZW5OYW1lOiB0cmFuc2Zlckluc3RydWN0aW9uLnBhcmFtcy50b2tlbk5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGluc3RydWN0aW9uLnR5cGUgPT09IEluc3RydWN0aW9uQnVpbGRlclR5cGVzLkNyZWF0ZUFzc29jaWF0ZWRUb2tlbkFjY291bnQpIHtcbiAgICAgICAgY29uc3QgYXRhSW5pdEluc3RydWN0aW9uOiBBdGFJbml0ID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgIHRoaXMuX2NyZWF0ZUF0YVBhcmFtcy5wdXNoKHtcbiAgICAgICAgICBvd25lckFkZHJlc3M6IGF0YUluaXRJbnN0cnVjdGlvbi5wYXJhbXMub3duZXJBZGRyZXNzLFxuICAgICAgICAgIHRva2VuTmFtZTogYXRhSW5pdEluc3RydWN0aW9uLnBhcmFtcy50b2tlbk5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAgU2V0IGEgdHJhbnNmZXJcbiAgICpcbiAgICogQHBhcmFtIHtTZW5kUGFyYW1zfSBwYXJhbXMgLSBwYXJhbXMgZm9yIHRoZSB0cmFuc2ZlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmFkZHJlc3MgLSB0aGUgcmVjZWl2ZXIgdG9rZW4gYWRkcmVzc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmFtb3VudCAtIHRoZSBhbW91bnQgc2VudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnRva2VuTmFtZSAtIG5hbWUgb2YgdG9rZW4gdGhhdCBpcyBpbnRlbmRlZCB0byBzZW5kXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbkJ1aWxkZXJ9IFRoaXMgdHJhbnNhY3Rpb24gYnVpbGRlclxuICAgKi9cbiAgc2VuZCh7IGFkZHJlc3MsIGFtb3VudCwgdG9rZW5OYW1lIH06IFNlbmRQYXJhbXMpOiB0aGlzIHtcbiAgICB2YWxpZGF0ZUFkZHJlc3MoYWRkcmVzcywgJ2FkZHJlc3MnKTtcbiAgICBpZiAoIWFtb3VudCB8fCAhaXNWYWxpZEFtb3VudChhbW91bnQpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIG9yIG1pc3NpbmcgYW1vdW50LCBnb3Q6ICcgKyBhbW91bnQpO1xuICAgIH1cbiAgICBpZiAoQmlnSW50KGFtb3VudCkgPiBVTlNJR05FRF9CSUdJTlRfTUFYKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBpbnB1dCBhbW91bnQgJHthbW91bnR9IGV4Y2VlZHMgYmlnIGludCBsaW1pdCAke1VOU0lHTkVEX0JJR0lOVF9NQVh9YCk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2VuZFBhcmFtcy5wdXNoKHsgYWRkcmVzcywgYW1vdW50LCB0b2tlbk5hbWU6IHRva2VuTmFtZSB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1Rva2VuQXNzb2NpYXRlUmVjaXBpZW50fSByZWNpcGllbnQgLSByZWNpcGllbnQgb2YgdGhlIGFzc29jaWF0ZWQgdG9rZW4gYWNjb3VudCBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVjaXBpZW50Lm93bmVyQWRkcmVzcyAtIG93bmVyIG9mIHRoZSBhc3NvY2lhdGVkIHRva2VuIGFjY291bnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlY2lwaWVudC50b2tlbk5hbWUgLSBuYW1lIG9mIHRoZSB0b2tlbiB0aGF0IGlzIGludGVuZGVkIHRvIGFzc29jaWF0ZVxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25CdWlsZGVyfSBUaGlzIHRyYW5zYWN0aW9uIGJ1aWxkZXJcbiAgICovXG4gIGNyZWF0ZUFzc29jaWF0ZWRUb2tlbkFjY291bnQocmVjaXBpZW50OiBUb2tlbkFzc29jaWF0ZVJlY2lwaWVudCk6IHRoaXMge1xuICAgIHZhbGlkYXRlT3duZXJBZGRyZXNzKHJlY2lwaWVudC5vd25lckFkZHJlc3MpO1xuICAgIGNvbnN0IHRva2VuID0gZ2V0U29sVG9rZW5Gcm9tVG9rZW5OYW1lKHJlY2lwaWVudC50b2tlbk5hbWUpO1xuICAgIGlmICghdG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdG9rZW4gbmFtZSwgZ290OiAnICsgcmVjaXBpZW50LnRva2VuTmFtZSk7XG4gICAgfVxuICAgIHZhbGlkYXRlTWludEFkZHJlc3ModG9rZW4udG9rZW5BZGRyZXNzKTtcblxuICAgIHRoaXMuX2NyZWF0ZUF0YVBhcmFtcy5wdXNoKHJlY2lwaWVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGJ1aWxkSW1wbGVtZW50YXRpb24oKTogUHJvbWlzZTxUcmFuc2FjdGlvbj4ge1xuICAgIGFzc2VydCh0aGlzLl9zZW5kZXIsICdTZW5kZXIgbXVzdCBiZSBzZXQgYmVmb3JlIGJ1aWxkaW5nIHRoZSB0cmFuc2FjdGlvbicpO1xuICAgIGNvbnN0IHNlbmRJbnN0cnVjdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMuX3NlbmRQYXJhbXMubWFwKGFzeW5jIChzZW5kUGFyYW1zOiBTZW5kUGFyYW1zKTogUHJvbWlzZTxUb2tlblRyYW5zZmVyPiA9PiB7XG4gICAgICAgIGNvbnN0IGNvaW4gPSBnZXRTb2xUb2tlbkZyb21Ub2tlbk5hbWUoc2VuZFBhcmFtcy50b2tlbk5hbWUpO1xuICAgICAgICBhc3NlcnQoY29pbiBpbnN0YW5jZW9mIFNvbENvaW4pO1xuICAgICAgICBjb25zdCBzb3VyY2VBZGRyZXNzID0gYXdhaXQgZ2V0QXNzb2NpYXRlZFRva2VuQWNjb3VudEFkZHJlc3MoY29pbi50b2tlbkFkZHJlc3MsIHRoaXMuX3NlbmRlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogSW5zdHJ1Y3Rpb25CdWlsZGVyVHlwZXMuVG9rZW5UcmFuc2ZlcixcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIGZyb21BZGRyZXNzOiB0aGlzLl9zZW5kZXIsXG4gICAgICAgICAgICB0b0FkZHJlc3M6IHNlbmRQYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICAgIGFtb3VudDogc2VuZFBhcmFtcy5hbW91bnQsXG4gICAgICAgICAgICB0b2tlbk5hbWU6IGNvaW4ubmFtZSxcbiAgICAgICAgICAgIHNvdXJjZUFkZHJlc3M6IHNvdXJjZUFkZHJlc3MsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICBjb25zdCB1bmlxdWVDcmVhdGVBdGFQYXJhbXMgPSBfLnVuaXFCeSh0aGlzLl9jcmVhdGVBdGFQYXJhbXMsIChyZWNpcGllbnQ6IFRva2VuQXNzb2NpYXRlUmVjaXBpZW50KSA9PiB7XG4gICAgICByZXR1cm4gcmVjaXBpZW50Lm93bmVyQWRkcmVzcyArIHJlY2lwaWVudC50b2tlbk5hbWU7XG4gICAgfSk7XG4gICAgY29uc3QgY3JlYXRlQXRhSW5zdHJ1Y3Rpb25zID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICB1bmlxdWVDcmVhdGVBdGFQYXJhbXMubWFwKGFzeW5jIChyZWNpcGllbnQ6IFRva2VuQXNzb2NpYXRlUmVjaXBpZW50KTogUHJvbWlzZTxBdGFJbml0PiA9PiB7XG4gICAgICAgIGNvbnN0IGNvaW4gPSBnZXRTb2xUb2tlbkZyb21Ub2tlbk5hbWUocmVjaXBpZW50LnRva2VuTmFtZSk7XG4gICAgICAgIGFzc2VydChjb2luIGluc3RhbmNlb2YgU29sQ29pbik7XG4gICAgICAgIGNvbnN0IHJlY2lwaWVudFRva2VuQWRkcmVzcyA9IGF3YWl0IGdldEFzc29jaWF0ZWRUb2tlbkFjY291bnRBZGRyZXNzKGNvaW4udG9rZW5BZGRyZXNzLCByZWNpcGllbnQub3duZXJBZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBJbnN0cnVjdGlvbkJ1aWxkZXJUeXBlcy5DcmVhdGVBc3NvY2lhdGVkVG9rZW5BY2NvdW50LFxuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgb3duZXJBZGRyZXNzOiByZWNpcGllbnQub3duZXJBZGRyZXNzLFxuICAgICAgICAgICAgdG9rZW5OYW1lOiBjb2luLm5hbWUsXG4gICAgICAgICAgICBtaW50QWRkcmVzczogY29pbi50b2tlbkFkZHJlc3MsXG4gICAgICAgICAgICBhdGFBZGRyZXNzOiByZWNpcGllbnRUb2tlbkFkZHJlc3MsXG4gICAgICAgICAgICBwYXllckFkZHJlc3M6IHRoaXMuX3NlbmRlcixcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApO1xuICAgIC8vIG9yZGVyIGlzIGltcG9ydGFudCwgY3JlYXRlQXRhSW5zdHJ1Y3Rpb25zIG11c3QgYmUgYmVmb3JlIHNlbmRJbnN0cnVjdGlvbnNcbiAgICB0aGlzLl9pbnN0cnVjdGlvbnNEYXRhID0gWy4uLmNyZWF0ZUF0YUluc3RydWN0aW9ucywgLi4uc2VuZEluc3RydWN0aW9uc107XG4gICAgcmV0dXJuIGF3YWl0IHN1cGVyLmJ1aWxkSW1wbGVtZW50YXRpb24oKTtcbiAgfVxufVxuIl19