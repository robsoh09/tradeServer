"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateOwnerAddress = exports.validateMintAddress = exports.getAssociatedTokenAccountAddress = exports.getSolTokenFromTokenName = exports.getSolTokenFromAddress = exports.validateAddress = exports.validateRawTransaction = exports.validateRawMsgInstruction = exports.validateIntructionTypes = exports.getInstructionType = exports.getTransactionType = exports.matchTransactionTypeByInstructionsOrder = exports.requiresAllSignatures = exports.countNotNullSignatures = exports.Uint8ArrayTobase58 = exports.base58ToUint8Array = exports.verifySignature = exports.isValidRawTransaction = exports.isValidMemo = exports.isValidStakingAmount = exports.isValidAmount = exports.isValidTransactionId = exports.isValidSignature = exports.isValidPublicKey = exports.isValidPrivateKey = exports.isValidBlockId = exports.isValidAddress = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const statics_1 = require("@bitgo/statics");
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const assert_1 = __importDefault(require("assert"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bs58_1 = __importDefault(require("bs58"));
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const constants_1 = require("./constants");
const DECODED_BLOCK_HASH_LENGTH = 32; // https://docs.solana.com/developing/programming-model/transactions#blockhash-format
const DECODED_SIGNATURE_LENGTH = 64; // https://docs.solana.com/terminology#signature
const BASE_58_ENCONDING_REGEX = '[1-9A-HJ-NP-Za-km-z]';
/** @inheritdoc */
function isValidAddress(address) {
    return isValidPublicKey(address);
}
exports.isValidAddress = isValidAddress;
/** @inheritdoc */
function isValidBlockId(hash) {
    try {
        return (!!hash && new RegExp(BASE_58_ENCONDING_REGEX).test(hash) && bs58_1.default.decode(hash).length === DECODED_BLOCK_HASH_LENGTH);
    }
    catch (e) {
        return false;
    }
}
exports.isValidBlockId = isValidBlockId;
/** @inheritdoc */
function isValidPrivateKey(prvKey) {
    try {
        const key = typeof prvKey === 'string' ? base58ToUint8Array(prvKey) : prvKey;
        return !!web3_js_1.Keypair.fromSecretKey(key);
    }
    catch (e) {
        return false;
    }
}
exports.isValidPrivateKey = isValidPrivateKey;
/** @inheritdoc */
function isValidPublicKey(pubKey) {
    try {
        if ((0, sdk_core_1.isValidXpub)(pubKey))
            return true;
        new web3_js_1.PublicKey(pubKey);
        return true;
    }
    catch {
        return false;
    }
}
exports.isValidPublicKey = isValidPublicKey;
/** @inheritdoc */
function isValidSignature(signature) {
    try {
        return !!signature && bs58_1.default.decode(signature).length === DECODED_SIGNATURE_LENGTH;
    }
    catch (e) {
        return false;
    }
}
exports.isValidSignature = isValidSignature;
/** @inheritdoc */
// TransactionId are the first signature on a Transaction
function isValidTransactionId(txId) {
    return isValidSignature(txId);
}
exports.isValidTransactionId = isValidTransactionId;
/**
 * Returns whether or not the string is a valid amount of lamports number
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
function isValidAmount(amount) {
    const bigNumberAmount = new bignumber_js_1.default(amount);
    return bigNumberAmount.isInteger() && bigNumberAmount.isGreaterThanOrEqualTo(0);
}
exports.isValidAmount = isValidAmount;
/**
 * Check if the string is a valid amount of lamports number on staking
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
function isValidStakingAmount(amount) {
    const bigNumberAmount = new bignumber_js_1.default(amount);
    return bigNumberAmount.isInteger() && bigNumberAmount.isGreaterThan(0);
}
exports.isValidStakingAmount = isValidStakingAmount;
/**
 * Check if this is a valid memo or not.
 *
 * @param memo - the memo string
 * @returns {boolean} - the validation result
 */
function isValidMemo(memo) {
    return Buffer.from(memo).length <= constants_1.MAX_MEMO_LENGTH;
}
exports.isValidMemo = isValidMemo;
/**
 * Checks if raw transaction can be deserialized
 *
 * @param {string} rawTransaction - transaction in base64 string format
 * @param {boolean} requireAllSignatures - require all signatures to be present
 * @param {boolean} verifySignatures - verify signatures
 * @returns {boolean} - the validation result
 */
function isValidRawTransaction(rawTransaction, requireAllSignatures = false, verifySignatures = false) {
    try {
        const tx = web3_js_1.Transaction.from(Buffer.from(rawTransaction, 'base64'));
        tx.serialize({ requireAllSignatures, verifySignatures });
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.isValidRawTransaction = isValidRawTransaction;
/**
 * Verifies if signature for message is valid.
 *
 * @param {Buffer} serializedTx - tx as a base64 string
 * @param {string} signature - signature as a string
 * @param {string} publicKey - public key as base 58
 * @returns {Boolean} true if signature is valid.
 */
function verifySignature(serializedTx, signature, publicKey) {
    if (!isValidRawTransaction(serializedTx)) {
        throw new sdk_core_1.UtilsError('Invalid serializedTx');
    }
    if (!isValidPublicKey(publicKey)) {
        throw new sdk_core_1.UtilsError('Invalid publicKey');
    }
    if (!isValidSignature(signature)) {
        throw new sdk_core_1.UtilsError('Invalid signature');
    }
    const msg = web3_js_1.Transaction.from(Buffer.from(serializedTx, 'base64')).serializeMessage();
    const sig = base58ToUint8Array(signature);
    const pub = new web3_js_1.PublicKey(publicKey);
    return tweetnacl_1.default.sign.detached.verify(msg, sig, pub.toBuffer());
}
exports.verifySignature = verifySignature;
/**
 * Converts a base58 string into a Uint8Array.
 *
 * @param {string} input - a string in base58
 * @returns {Uint8Array} - an Uint8Array
 */
function base58ToUint8Array(input) {
    return new Uint8Array(bs58_1.default.decode(input));
}
exports.base58ToUint8Array = base58ToUint8Array;
/**
 * Converts a Uint8Array to a base58 string.
 *
 * @param {Uint8Array} input - an Uint8Array
 * @returns {string} - a string in base58
 */
function Uint8ArrayTobase58(input) {
    return bs58_1.default.encode(input);
}
exports.Uint8ArrayTobase58 = Uint8ArrayTobase58;
/**
 * Count the amount of signatures are not null.
 *
 * @param {SignaturePubkeyPair[]} signatures - an array of SignaturePubkeyPair
 * @returns {number} - the amount of valid signatures
 */
function countNotNullSignatures(signatures) {
    return signatures.filter((sig) => !!sig.signature).length;
}
exports.countNotNullSignatures = countNotNullSignatures;
/**
 * Check if all signatures are completed.
 *
 * @param {SignaturePubkeyPair[]} signatures - signatures
 * @returns {boolean}
 */
function requiresAllSignatures(signatures) {
    return signatures.length > 0 && countNotNullSignatures(signatures) === signatures.length;
}
exports.requiresAllSignatures = requiresAllSignatures;
/**
 * Check the transaction type matching instructions by order. Memo and AdvanceNonceAccount instructions
 * are ignored.
 *
 * @param {TransactionInstruction[]} instructions - the array of supported Solana instructions to be parsed
 * @param {Record<string, number>} instructionIndexes - the instructions indexes of the current transaction
 * @returns true if it matches by order.
 */
function matchTransactionTypeByInstructionsOrder(instructions, instructionIndexes) {
    const instructionsCopy = [...instructions]; // Make a copy since we may modify the array below
    // AdvanceNonceAccount is optional and the first instruction added, it does not matter to match the type
    if (instructionsCopy.length > 0) {
        if (getInstructionType(instructions[0]) === 'AdvanceNonceAccount') {
            instructionsCopy.shift();
        }
    }
    // Memo is optional and the last instruction added, it does not matter to match the type
    // Why have it in instructionKeys if we are going to ignore it?
    const instructionsKeys = Object.keys(instructionIndexes);
    if (instructionsKeys[instructionsKeys.length - 1] === 'Memo') {
        instructionsKeys.pop();
    }
    // Check instructions by order using the index.
    for (const keyName of instructionsKeys) {
        const result = getInstructionType(instructionsCopy[instructionIndexes[keyName]]);
        if (result !== keyName) {
            return false;
        }
    }
    return true;
}
exports.matchTransactionTypeByInstructionsOrder = matchTransactionTypeByInstructionsOrder;
/**
 * Returns the transaction Type based on the  transaction instructions.
 * Wallet initialization, Transfer and Staking transactions are supported.
 *
 * @param {SolTransaction} transaction - the solana transaction
 * @returns {TransactionType} - the type of transaction
 */
function getTransactionType(transaction) {
    const { instructions } = transaction;
    if (validateRawMsgInstruction(instructions)) {
        return sdk_core_1.TransactionType.StakingAuthorizeRaw;
    }
    validateIntructionTypes(instructions);
    // check if deactivate instruction does not exist because deactivate can be include a transfer instruction
    if (instructions.filter((instruction) => getInstructionType(instruction) === 'Deactivate').length == 0) {
        for (const instruction of instructions) {
            const instructionType = getInstructionType(instruction);
            if (instructionType === constants_1.ValidInstructionTypesEnum.Transfer ||
                instructionType === constants_1.ValidInstructionTypesEnum.TokenTransfer) {
                return sdk_core_1.TransactionType.Send;
            }
        }
    }
    if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.walletInitInstructionIndexes)) {
        return sdk_core_1.TransactionType.WalletInitialization;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.stakingActivateInstructionsIndexes)) {
        return sdk_core_1.TransactionType.StakingActivate;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.stakingAuthorizeInstructionsIndexes)) {
        return sdk_core_1.TransactionType.StakingAuthorize;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.stakingDelegateInstructionsIndexes)) {
        return sdk_core_1.TransactionType.StakingDelegate;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.stakingDeactivateInstructionsIndexes) ||
        matchTransactionTypeByInstructionsOrder(instructions, constants_1.stakingPartialDeactivateInstructionsIndexes)) {
        return sdk_core_1.TransactionType.StakingDeactivate;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.stakingWithdrawInstructionsIndexes)) {
        return sdk_core_1.TransactionType.StakingWithdraw;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.ataInitInstructionIndexes)) {
        return sdk_core_1.TransactionType.AssociatedTokenAccountInitialization;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.ataCloseInstructionIndexes)) {
        return sdk_core_1.TransactionType.CloseAssociatedTokenAccount;
    }
    else {
        throw new sdk_core_1.NotSupported('Invalid transaction, transaction not supported or invalid');
    }
}
exports.getTransactionType = getTransactionType;
/**
 * Returns the instruction Type based on the solana instructions.
 * Throws if the solana instruction program is not supported
 *
 * @param {TransactionInstruction} instruction - a solana instruction
 * @returns {ValidInstructionTypes} - a solana instruction type
 */
function getInstructionType(instruction) {
    switch (instruction.programId.toString()) {
        case new web3_js_1.PublicKey(constants_1.MEMO_PROGRAM_PK).toString():
            return 'Memo';
        case web3_js_1.SystemProgram.programId.toString():
            return web3_js_1.SystemInstruction.decodeInstructionType(instruction);
        case spl_token_1.TOKEN_PROGRAM_ID.toString():
            return 'TokenTransfer';
        case web3_js_1.StakeProgram.programId.toString():
            return web3_js_1.StakeInstruction.decodeInstructionType(instruction);
        case spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID.toString():
            // TODO: change this when @spl-token supports decoding associated token instructions
            if (instruction.data.length === 0) {
                return 'InitializeAssociatedTokenAccount';
            }
            else {
                throw new sdk_core_1.NotSupported('Invalid transaction, instruction program id not supported: ' + instruction.programId.toString());
            }
        default:
            throw new sdk_core_1.NotSupported('Invalid transaction, instruction program id not supported: ' + instruction.programId.toString());
    }
}
exports.getInstructionType = getInstructionType;
/**
 * Validate solana instructions types to see if they are supported by the builder.
 * Throws if the instruction type is invalid.
 *
 * @param {TransactionInstruction} instructions - a solana instruction
 * @returns {void}
 */
function validateIntructionTypes(instructions) {
    for (const instruction of instructions) {
        if (!constants_1.VALID_SYSTEM_INSTRUCTION_TYPES.includes(getInstructionType(instruction))) {
            throw new sdk_core_1.NotSupported('Invalid transaction, instruction type not supported: ' + getInstructionType(instruction));
        }
    }
}
exports.validateIntructionTypes = validateIntructionTypes;
/**
 * Validate solana instructions match raw msg authorize transaction
 *
 * @param {TransactionInstruction} instructions - a solana instruction
 * @returns {boolean} true if the instructions match the raw msg authorize transaction
 */
function validateRawMsgInstruction(instructions) {
    // as web3.js cannot decode authorize instruction from CLI, we need to check it manually first
    if (instructions.length === 2) {
        const programId1 = instructions[0].programId.toString();
        const programId2 = instructions[1].programId.toString();
        if (programId1 === web3_js_1.SystemProgram.programId.toString() && programId2 === web3_js_1.StakeProgram.programId.toString()) {
            const instructionName1 = web3_js_1.SystemInstruction.decodeInstructionType(instructions[0]);
            const data = instructions[1].data.toString('hex');
            if (instructionName1 === constants_1.nonceAdvanceInstruction &&
                (data === constants_1.validInstructionData || data === constants_1.validInstructionData2)) {
                return true;
            }
        }
    }
    if (instructions.length === 3) {
        const programId1 = instructions[0].programId.toString();
        const programId2 = instructions[1].programId.toString();
        const programId3 = instructions[2].programId.toString();
        if (programId1 === web3_js_1.SystemProgram.programId.toString() &&
            programId2 === web3_js_1.StakeProgram.programId.toString() &&
            programId3 === web3_js_1.StakeProgram.programId.toString()) {
            const instructionName1 = web3_js_1.SystemInstruction.decodeInstructionType(instructions[0]);
            const data = instructions[1].data.toString('hex');
            const data2 = instructions[2].data.toString('hex');
            if (instructionName1 === constants_1.nonceAdvanceInstruction &&
                (data === constants_1.validInstructionData || data === constants_1.validInstructionData2) &&
                (data2 === constants_1.validInstructionData || data2 === constants_1.validInstructionData2)) {
                return true;
            }
        }
    }
    return false;
}
exports.validateRawMsgInstruction = validateRawMsgInstruction;
/**
 * Check the raw transaction has a valid format in the blockchain context, throw otherwise.
 *
 * @param {string} rawTransaction - Transaction in base64 string  format
 */
function validateRawTransaction(rawTransaction, requireAllSignatures = false, verifySignatures = false) {
    if (!rawTransaction) {
        throw new sdk_core_1.ParseTransactionError('Invalid raw transaction: Undefined');
    }
    if (!isValidRawTransaction(rawTransaction, requireAllSignatures, verifySignatures)) {
        throw new sdk_core_1.ParseTransactionError('Invalid raw transaction');
    }
}
exports.validateRawTransaction = validateRawTransaction;
/**
 * Validates address to check if it exists and is a valid Solana public key
 *
 * @param {string} address The address to be validated
 * @param {string} fieldName Name of the field to validate, its needed to return which field is failing on case of error.
 */
function validateAddress(address, fieldName) {
    if (!address || !isValidPublicKey(address)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid or missing ${fieldName}, got: ${address}`);
    }
}
exports.validateAddress = validateAddress;
/**
 * Get the statics coin object matching a given Solana token address if it exists
 *
 * @param tokenAddress The token address to match against
 * @param network Solana Mainnet or Testnet
 * @returns statics BaseCoin object for the matching token
 */
function getSolTokenFromAddress(tokenAddress, network) {
    const tokens = statics_1.coins.filter((coin) => {
        if (coin instanceof statics_1.SolCoin) {
            return coin.network.type === network.type && coin.tokenAddress.toLowerCase() === tokenAddress.toLowerCase();
        }
        return false;
    });
    const tokensArray = tokens.map((token) => token);
    if (tokensArray.length >= 1) {
        // there should never be two tokens with the same contract address, so we assert that here
        (0, assert_1.default)(tokensArray.length === 1);
        return tokensArray[0];
    }
    return undefined;
}
exports.getSolTokenFromAddress = getSolTokenFromAddress;
/**
 * Get the solana token object from token name
 * @param tokenName The token name to match against
 * */
function getSolTokenFromTokenName(tokenName) {
    try {
        const token = statics_1.coins.get(tokenName);
        if (!(token.isToken && token instanceof statics_1.SolCoin)) {
            return undefined;
        }
        return token;
    }
    catch (e) {
        if (!(e instanceof statics_1.CoinNotDefinedError)) {
            throw e;
        }
        return undefined;
    }
}
exports.getSolTokenFromTokenName = getSolTokenFromTokenName;
/**
 * Get the solana associated token account address
 * @param tokenAddress The token address
 * @param ownerAddress The owner of the associated token account
 * @returns The associated token account address
 * */
async function getAssociatedTokenAccountAddress(tokenAddress, ownerAddress) {
    const ownerPublicKey = new web3_js_1.PublicKey(ownerAddress);
    // tokenAddress are not on ed25519 curve, so they can't be used as ownerAddress
    if (!web3_js_1.PublicKey.isOnCurve(ownerPublicKey.toBuffer())) {
        throw new sdk_core_1.UtilsError('Invalid ownerAddress - address off ed25519 curve, got: ' + ownerAddress);
    }
    const ataAddress = await (0, spl_token_1.getAssociatedTokenAddress)(new web3_js_1.PublicKey(tokenAddress), ownerPublicKey);
    return ataAddress.toString();
}
exports.getAssociatedTokenAccountAddress = getAssociatedTokenAccountAddress;
function validateMintAddress(mintAddress) {
    if (!mintAddress || !isValidAddress(mintAddress)) {
        throw new sdk_core_1.BuildTransactionError('Invalid or missing mintAddress, got: ' + mintAddress);
    }
}
exports.validateMintAddress = validateMintAddress;
function validateOwnerAddress(ownerAddress) {
    if (!ownerAddress || !isValidAddress(ownerAddress)) {
        throw new sdk_core_1.BuildTransactionError('Invalid or missing ownerAddress, got: ' + ownerAddress);
    }
}
exports.validateOwnerAddress = validateOwnerAddress;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDhDQU95QjtBQUN6Qiw0Q0FBNEY7QUFDNUYsaURBQTZHO0FBQzdHLDZDQVV5QjtBQUN6QixvREFBNEI7QUFDNUIsZ0VBQXFDO0FBQ3JDLGdEQUF3QjtBQUN4QiwwREFBNkI7QUFDN0IsMkNBaUJxQjtBQUdyQixNQUFNLHlCQUF5QixHQUFHLEVBQUUsQ0FBQyxDQUFDLHFGQUFxRjtBQUMzSCxNQUFNLHdCQUF3QixHQUFHLEVBQUUsQ0FBQyxDQUFDLGdEQUFnRDtBQUNyRixNQUFNLHVCQUF1QixHQUFHLHNCQUFzQixDQUFDO0FBRXZELGtCQUFrQjtBQUNsQixTQUFnQixjQUFjLENBQUMsT0FBZTtJQUM1QyxPQUFPLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ25DLENBQUM7QUFGRCx3Q0FFQztBQUVELGtCQUFrQjtBQUNsQixTQUFnQixjQUFjLENBQUMsSUFBWTtJQUN6QyxJQUFJO1FBQ0YsT0FBTyxDQUNMLENBQUMsQ0FBQyxJQUFJLElBQUksSUFBSSxNQUFNLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksY0FBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEtBQUsseUJBQXlCLENBQ25ILENBQUM7S0FDSDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsT0FBTyxLQUFLLENBQUM7S0FDZDtBQUNILENBQUM7QUFSRCx3Q0FRQztBQUVELGtCQUFrQjtBQUNsQixTQUFnQixpQkFBaUIsQ0FBQyxNQUEyQjtJQUMzRCxJQUFJO1FBQ0YsTUFBTSxHQUFHLEdBQWUsT0FBTyxNQUFNLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQ3pGLE9BQU8sQ0FBQyxDQUFDLGlCQUFPLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ3JDO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixPQUFPLEtBQUssQ0FBQztLQUNkO0FBQ0gsQ0FBQztBQVBELDhDQU9DO0FBRUQsa0JBQWtCO0FBQ2xCLFNBQWdCLGdCQUFnQixDQUFDLE1BQWM7SUFDN0MsSUFBSTtRQUNGLElBQUksSUFBQSxzQkFBVyxFQUFDLE1BQU0sQ0FBQztZQUFFLE9BQU8sSUFBSSxDQUFDO1FBQ3JDLElBQUksbUJBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN0QixPQUFPLElBQUksQ0FBQztLQUNiO0lBQUMsTUFBTTtRQUNOLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7QUFDSCxDQUFDO0FBUkQsNENBUUM7QUFFRCxrQkFBa0I7QUFDbEIsU0FBZ0IsZ0JBQWdCLENBQUMsU0FBaUI7SUFDaEQsSUFBSTtRQUNGLE9BQU8sQ0FBQyxDQUFDLFNBQVMsSUFBSSxjQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLE1BQU0sS0FBSyx3QkFBd0IsQ0FBQztLQUNsRjtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsT0FBTyxLQUFLLENBQUM7S0FDZDtBQUNILENBQUM7QUFORCw0Q0FNQztBQUVELGtCQUFrQjtBQUNsQix5REFBeUQ7QUFDekQsU0FBZ0Isb0JBQW9CLENBQUMsSUFBWTtJQUMvQyxPQUFPLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2hDLENBQUM7QUFGRCxvREFFQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsYUFBYSxDQUFDLE1BQWM7SUFDMUMsTUFBTSxlQUFlLEdBQUcsSUFBSSxzQkFBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzlDLE9BQU8sZUFBZSxDQUFDLFNBQVMsRUFBRSxJQUFJLGVBQWUsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsRixDQUFDO0FBSEQsc0NBR0M7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLG9CQUFvQixDQUFDLE1BQWM7SUFDakQsTUFBTSxlQUFlLEdBQUcsSUFBSSxzQkFBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzlDLE9BQU8sZUFBZSxDQUFDLFNBQVMsRUFBRSxJQUFJLGVBQWUsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDekUsQ0FBQztBQUhELG9EQUdDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixXQUFXLENBQUMsSUFBWTtJQUN0QyxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxJQUFJLDJCQUFlLENBQUM7QUFDckQsQ0FBQztBQUZELGtDQUVDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILFNBQWdCLHFCQUFxQixDQUNuQyxjQUFzQixFQUN0QixvQkFBb0IsR0FBRyxLQUFLLEVBQzVCLGdCQUFnQixHQUFHLEtBQUs7SUFFeEIsSUFBSTtRQUNGLE1BQU0sRUFBRSxHQUFHLHFCQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDdEUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLG9CQUFvQixFQUFFLGdCQUFnQixFQUFFLENBQUMsQ0FBQztRQUN6RCxPQUFPLElBQUksQ0FBQztLQUNiO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixPQUFPLEtBQUssQ0FBQztLQUNkO0FBQ0gsQ0FBQztBQVpELHNEQVlDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILFNBQWdCLGVBQWUsQ0FBQyxZQUFvQixFQUFFLFNBQWlCLEVBQUUsU0FBaUI7SUFDeEYsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFlBQVksQ0FBQyxFQUFFO1FBQ3hDLE1BQU0sSUFBSSxxQkFBVSxDQUFDLHNCQUFzQixDQUFDLENBQUM7S0FDOUM7SUFDRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLEVBQUU7UUFDaEMsTUFBTSxJQUFJLHFCQUFVLENBQUMsbUJBQW1CLENBQUMsQ0FBQztLQUMzQztJQUNELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUNoQyxNQUFNLElBQUkscUJBQVUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0tBQzNDO0lBQ0QsTUFBTSxHQUFHLEdBQUcscUJBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0lBQ3hGLE1BQU0sR0FBRyxHQUFHLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzFDLE1BQU0sR0FBRyxHQUFHLElBQUksbUJBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNyQyxPQUFPLG1CQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztBQUM3RCxDQUFDO0FBZEQsMENBY0M7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLGtCQUFrQixDQUFDLEtBQWE7SUFDOUMsT0FBTyxJQUFJLFVBQVUsQ0FBQyxjQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDNUMsQ0FBQztBQUZELGdEQUVDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixrQkFBa0IsQ0FBQyxLQUFpQjtJQUNsRCxPQUFPLGNBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDNUIsQ0FBQztBQUZELGdEQUVDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixzQkFBc0IsQ0FBQyxVQUFpQztJQUN0RSxPQUFPLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQzVELENBQUM7QUFGRCx3REFFQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IscUJBQXFCLENBQUMsVUFBaUM7SUFDckUsT0FBTyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxzQkFBc0IsQ0FBQyxVQUFVLENBQUMsS0FBSyxVQUFVLENBQUMsTUFBTSxDQUFDO0FBQzNGLENBQUM7QUFGRCxzREFFQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxTQUFnQix1Q0FBdUMsQ0FDckQsWUFBc0MsRUFDdEMsa0JBQTBDO0lBRTFDLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsa0RBQWtEO0lBQzlGLHdHQUF3RztJQUN4RyxJQUFJLGdCQUFnQixDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDL0IsSUFBSSxrQkFBa0IsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxxQkFBcUIsRUFBRTtZQUNqRSxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUMxQjtLQUNGO0lBRUQsd0ZBQXdGO0lBQ3hGLCtEQUErRDtJQUMvRCxNQUFNLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUN6RCxJQUFJLGdCQUFnQixDQUFDLGdCQUFnQixDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsS0FBSyxNQUFNLEVBQUU7UUFDNUQsZ0JBQWdCLENBQUMsR0FBRyxFQUFFLENBQUM7S0FDeEI7SUFFRCwrQ0FBK0M7SUFDL0MsS0FBSyxNQUFNLE9BQU8sSUFBSSxnQkFBZ0IsRUFBRTtRQUN0QyxNQUFNLE1BQU0sR0FBRyxrQkFBa0IsQ0FBQyxnQkFBZ0IsQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakYsSUFBSSxNQUFNLEtBQUssT0FBTyxFQUFFO1lBQ3RCLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7S0FDRjtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQTNCRCwwRkEyQkM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixrQkFBa0IsQ0FBQyxXQUEyQjtJQUM1RCxNQUFNLEVBQUUsWUFBWSxFQUFFLEdBQUcsV0FBVyxDQUFDO0lBQ3JDLElBQUkseUJBQXlCLENBQUMsWUFBWSxDQUFDLEVBQUU7UUFDM0MsT0FBTywwQkFBZSxDQUFDLG1CQUFtQixDQUFDO0tBQzVDO0lBQ0QsdUJBQXVCLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDdEMsMEdBQTBHO0lBQzFHLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDLEtBQUssWUFBWSxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtRQUN0RyxLQUFLLE1BQU0sV0FBVyxJQUFJLFlBQVksRUFBRTtZQUN0QyxNQUFNLGVBQWUsR0FBRyxrQkFBa0IsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUN4RCxJQUNFLGVBQWUsS0FBSyxxQ0FBeUIsQ0FBQyxRQUFRO2dCQUN0RCxlQUFlLEtBQUsscUNBQXlCLENBQUMsYUFBYSxFQUMzRDtnQkFDQSxPQUFPLDBCQUFlLENBQUMsSUFBSSxDQUFDO2FBQzdCO1NBQ0Y7S0FDRjtJQUNELElBQUksdUNBQXVDLENBQUMsWUFBWSxFQUFFLHdDQUE0QixDQUFDLEVBQUU7UUFDdkYsT0FBTywwQkFBZSxDQUFDLG9CQUFvQixDQUFDO0tBQzdDO1NBQU0sSUFBSSx1Q0FBdUMsQ0FBQyxZQUFZLEVBQUUsOENBQWtDLENBQUMsRUFBRTtRQUNwRyxPQUFPLDBCQUFlLENBQUMsZUFBZSxDQUFDO0tBQ3hDO1NBQU0sSUFBSSx1Q0FBdUMsQ0FBQyxZQUFZLEVBQUUsK0NBQW1DLENBQUMsRUFBRTtRQUNyRyxPQUFPLDBCQUFlLENBQUMsZ0JBQWdCLENBQUM7S0FDekM7U0FBTSxJQUFJLHVDQUF1QyxDQUFDLFlBQVksRUFBRSw4Q0FBa0MsQ0FBQyxFQUFFO1FBQ3BHLE9BQU8sMEJBQWUsQ0FBQyxlQUFlLENBQUM7S0FDeEM7U0FBTSxJQUNMLHVDQUF1QyxDQUFDLFlBQVksRUFBRSxnREFBb0MsQ0FBQztRQUMzRix1Q0FBdUMsQ0FBQyxZQUFZLEVBQUUsdURBQTJDLENBQUMsRUFDbEc7UUFDQSxPQUFPLDBCQUFlLENBQUMsaUJBQWlCLENBQUM7S0FDMUM7U0FBTSxJQUFJLHVDQUF1QyxDQUFDLFlBQVksRUFBRSw4Q0FBa0MsQ0FBQyxFQUFFO1FBQ3BHLE9BQU8sMEJBQWUsQ0FBQyxlQUFlLENBQUM7S0FDeEM7U0FBTSxJQUFJLHVDQUF1QyxDQUFDLFlBQVksRUFBRSxxQ0FBeUIsQ0FBQyxFQUFFO1FBQzNGLE9BQU8sMEJBQWUsQ0FBQyxvQ0FBb0MsQ0FBQztLQUM3RDtTQUFNLElBQUksdUNBQXVDLENBQUMsWUFBWSxFQUFFLHNDQUEwQixDQUFDLEVBQUU7UUFDNUYsT0FBTywwQkFBZSxDQUFDLDJCQUEyQixDQUFDO0tBQ3BEO1NBQU07UUFDTCxNQUFNLElBQUksdUJBQVksQ0FBQywyREFBMkQsQ0FBQyxDQUFDO0tBQ3JGO0FBQ0gsQ0FBQztBQXhDRCxnREF3Q0M7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixrQkFBa0IsQ0FBQyxXQUFtQztJQUNwRSxRQUFRLFdBQVcsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLEVBQUU7UUFDeEMsS0FBSyxJQUFJLG1CQUFTLENBQUMsMkJBQWUsQ0FBQyxDQUFDLFFBQVEsRUFBRTtZQUM1QyxPQUFPLE1BQU0sQ0FBQztRQUNoQixLQUFLLHVCQUFhLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRTtZQUNyQyxPQUFPLDJCQUFpQixDQUFDLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzlELEtBQUssNEJBQWdCLENBQUMsUUFBUSxFQUFFO1lBQzlCLE9BQU8sZUFBZSxDQUFDO1FBQ3pCLEtBQUssc0JBQVksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFO1lBQ3BDLE9BQU8sMEJBQWdCLENBQUMscUJBQXFCLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDN0QsS0FBSyx1Q0FBMkIsQ0FBQyxRQUFRLEVBQUU7WUFDekMsb0ZBQW9GO1lBQ3BGLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO2dCQUNqQyxPQUFPLGtDQUFrQyxDQUFDO2FBQzNDO2lCQUFNO2dCQUNMLE1BQU0sSUFBSSx1QkFBWSxDQUNwQiw2REFBNkQsR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxDQUNqRyxDQUFDO2FBQ0g7UUFDSDtZQUNFLE1BQU0sSUFBSSx1QkFBWSxDQUNwQiw2REFBNkQsR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxDQUNqRyxDQUFDO0tBQ0w7QUFDSCxDQUFDO0FBeEJELGdEQXdCQztBQUVEOzs7Ozs7R0FNRztBQUNILFNBQWdCLHVCQUF1QixDQUFDLFlBQXNDO0lBQzVFLEtBQUssTUFBTSxXQUFXLElBQUksWUFBWSxFQUFFO1FBQ3RDLElBQUksQ0FBQywwQ0FBOEIsQ0FBQyxRQUFRLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRTtZQUM3RSxNQUFNLElBQUksdUJBQVksQ0FBQyx1REFBdUQsR0FBRyxrQkFBa0IsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1NBQ25IO0tBQ0Y7QUFDSCxDQUFDO0FBTkQsMERBTUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLHlCQUF5QixDQUFDLFlBQXNDO0lBQzlFLDhGQUE4RjtJQUM5RixJQUFJLFlBQVksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQzdCLE1BQU0sVUFBVSxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDeEQsTUFBTSxVQUFVLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUN4RCxJQUFJLFVBQVUsS0FBSyx1QkFBYSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsSUFBSSxVQUFVLEtBQUssc0JBQVksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLEVBQUU7WUFDekcsTUFBTSxnQkFBZ0IsR0FBRywyQkFBaUIsQ0FBQyxxQkFBcUIsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsRixNQUFNLElBQUksR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNsRCxJQUNFLGdCQUFnQixLQUFLLG1DQUF1QjtnQkFDNUMsQ0FBQyxJQUFJLEtBQUssZ0NBQW9CLElBQUksSUFBSSxLQUFLLGlDQUFxQixDQUFDLEVBQ2pFO2dCQUNBLE9BQU8sSUFBSSxDQUFDO2FBQ2I7U0FDRjtLQUNGO0lBQ0QsSUFBSSxZQUFZLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUM3QixNQUFNLFVBQVUsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3hELE1BQU0sVUFBVSxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDeEQsTUFBTSxVQUFVLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUN4RCxJQUNFLFVBQVUsS0FBSyx1QkFBYSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUU7WUFDakQsVUFBVSxLQUFLLHNCQUFZLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRTtZQUNoRCxVQUFVLEtBQUssc0JBQVksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLEVBQ2hEO1lBQ0EsTUFBTSxnQkFBZ0IsR0FBRywyQkFBaUIsQ0FBQyxxQkFBcUIsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsRixNQUFNLElBQUksR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNsRCxNQUFNLEtBQUssR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNuRCxJQUNFLGdCQUFnQixLQUFLLG1DQUF1QjtnQkFDNUMsQ0FBQyxJQUFJLEtBQUssZ0NBQW9CLElBQUksSUFBSSxLQUFLLGlDQUFxQixDQUFDO2dCQUNqRSxDQUFDLEtBQUssS0FBSyxnQ0FBb0IsSUFBSSxLQUFLLEtBQUssaUNBQXFCLENBQUMsRUFDbkU7Z0JBQ0EsT0FBTyxJQUFJLENBQUM7YUFDYjtTQUNGO0tBQ0Y7SUFDRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUF0Q0QsOERBc0NDO0FBQ0Q7Ozs7R0FJRztBQUNILFNBQWdCLHNCQUFzQixDQUNwQyxjQUFzQixFQUN0QixvQkFBb0IsR0FBRyxLQUFLLEVBQzVCLGdCQUFnQixHQUFHLEtBQUs7SUFFeEIsSUFBSSxDQUFDLGNBQWMsRUFBRTtRQUNuQixNQUFNLElBQUksZ0NBQXFCLENBQUMsb0NBQW9DLENBQUMsQ0FBQztLQUN2RTtJQUNELElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxjQUFjLEVBQUUsb0JBQW9CLEVBQUUsZ0JBQWdCLENBQUMsRUFBRTtRQUNsRixNQUFNLElBQUksZ0NBQXFCLENBQUMseUJBQXlCLENBQUMsQ0FBQztLQUM1RDtBQUNILENBQUM7QUFYRCx3REFXQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsZUFBZSxDQUFDLE9BQWUsRUFBRSxTQUFpQjtJQUNoRSxJQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDMUMsTUFBTSxJQUFJLGdDQUFxQixDQUFDLHNCQUFzQixTQUFTLFVBQVUsT0FBTyxFQUFFLENBQUMsQ0FBQztLQUNyRjtBQUNILENBQUM7QUFKRCwwQ0FJQztBQUVEOzs7Ozs7R0FNRztBQUNILFNBQWdCLHNCQUFzQixDQUFDLFlBQW9CLEVBQUUsT0FBb0I7SUFDL0UsTUFBTSxNQUFNLEdBQUcsZUFBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1FBQ25DLElBQUksSUFBSSxZQUFZLGlCQUFPLEVBQUU7WUFDM0IsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLEtBQUssWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQzdHO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDLENBQUMsQ0FBQztJQUNILE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2pELElBQUksV0FBVyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7UUFDM0IsMEZBQTBGO1FBQzFGLElBQUEsZ0JBQU0sRUFBQyxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLE9BQU8sV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3ZCO0lBQ0QsT0FBTyxTQUFTLENBQUM7QUFDbkIsQ0FBQztBQWRELHdEQWNDO0FBRUQ7OztLQUdLO0FBQ0wsU0FBZ0Isd0JBQXdCLENBQUMsU0FBaUI7SUFDeEQsSUFBSTtRQUNGLE1BQU0sS0FBSyxHQUFHLGVBQUssQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sSUFBSSxLQUFLLFlBQVksaUJBQU8sQ0FBQyxFQUFFO1lBQ2hELE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBQ0QsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsSUFBSSxDQUFDLENBQUMsQ0FBQyxZQUFZLDZCQUFtQixDQUFDLEVBQUU7WUFDdkMsTUFBTSxDQUFDLENBQUM7U0FDVDtRQUNELE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0FBQ0gsQ0FBQztBQWJELDREQWFDO0FBRUQ7Ozs7O0tBS0s7QUFDRSxLQUFLLFVBQVUsZ0NBQWdDLENBQUMsWUFBb0IsRUFBRSxZQUFvQjtJQUMvRixNQUFNLGNBQWMsR0FBRyxJQUFJLG1CQUFTLENBQUMsWUFBWSxDQUFDLENBQUM7SUFFbkQsK0VBQStFO0lBQy9FLElBQUksQ0FBQyxtQkFBUyxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRTtRQUNuRCxNQUFNLElBQUkscUJBQVUsQ0FBQyx5REFBeUQsR0FBRyxZQUFZLENBQUMsQ0FBQztLQUNoRztJQUNELE1BQU0sVUFBVSxHQUFHLE1BQU0sSUFBQSxxQ0FBeUIsRUFBQyxJQUFJLG1CQUFTLENBQUMsWUFBWSxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFDaEcsT0FBTyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDL0IsQ0FBQztBQVRELDRFQVNDO0FBRUQsU0FBZ0IsbUJBQW1CLENBQUMsV0FBbUI7SUFDckQsSUFBSSxDQUFDLFdBQVcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsRUFBRTtRQUNoRCxNQUFNLElBQUksZ0NBQXFCLENBQUMsdUNBQXVDLEdBQUcsV0FBVyxDQUFDLENBQUM7S0FDeEY7QUFDSCxDQUFDO0FBSkQsa0RBSUM7QUFFRCxTQUFnQixvQkFBb0IsQ0FBQyxZQUFvQjtJQUN2RCxJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxFQUFFO1FBQ2xELE1BQU0sSUFBSSxnQ0FBcUIsQ0FBQyx3Q0FBd0MsR0FBRyxZQUFZLENBQUMsQ0FBQztLQUMxRjtBQUNILENBQUM7QUFKRCxvREFJQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEJ1aWxkVHJhbnNhY3Rpb25FcnJvcixcbiAgaXNWYWxpZFhwdWIsXG4gIE5vdFN1cHBvcnRlZCxcbiAgUGFyc2VUcmFuc2FjdGlvbkVycm9yLFxuICBUcmFuc2FjdGlvblR5cGUsXG4gIFV0aWxzRXJyb3IsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBCYXNlQ29pbiwgQmFzZU5ldHdvcmssIENvaW5Ob3REZWZpbmVkRXJyb3IsIGNvaW5zLCBTb2xDb2luIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHsgQVNTT0NJQVRFRF9UT0tFTl9QUk9HUkFNX0lELCBnZXRBc3NvY2lhdGVkVG9rZW5BZGRyZXNzLCBUT0tFTl9QUk9HUkFNX0lEIH0gZnJvbSAnQHNvbGFuYS9zcGwtdG9rZW4nO1xuaW1wb3J0IHtcbiAgS2V5cGFpcixcbiAgUHVibGljS2V5LFxuICBTaWduYXR1cmVQdWJrZXlQYWlyLFxuICBUcmFuc2FjdGlvbiBhcyBTb2xUcmFuc2FjdGlvbixcbiAgU3Rha2VJbnN0cnVjdGlvbixcbiAgU3Rha2VQcm9ncmFtLFxuICBTeXN0ZW1JbnN0cnVjdGlvbixcbiAgU3lzdGVtUHJvZ3JhbSxcbiAgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbn0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCBiczU4IGZyb20gJ2JzNTgnO1xuaW1wb3J0IG5hY2wgZnJvbSAndHdlZXRuYWNsJztcbmltcG9ydCB7XG4gIGF0YUNsb3NlSW5zdHJ1Y3Rpb25JbmRleGVzLFxuICBhdGFJbml0SW5zdHJ1Y3Rpb25JbmRleGVzLFxuICBNQVhfTUVNT19MRU5HVEgsXG4gIE1FTU9fUFJPR1JBTV9QSyxcbiAgbm9uY2VBZHZhbmNlSW5zdHJ1Y3Rpb24sXG4gIHN0YWtpbmdBY3RpdmF0ZUluc3RydWN0aW9uc0luZGV4ZXMsXG4gIHN0YWtpbmdBdXRob3JpemVJbnN0cnVjdGlvbnNJbmRleGVzLFxuICBzdGFraW5nRGVhY3RpdmF0ZUluc3RydWN0aW9uc0luZGV4ZXMsXG4gIHN0YWtpbmdEZWxlZ2F0ZUluc3RydWN0aW9uc0luZGV4ZXMsXG4gIHN0YWtpbmdQYXJ0aWFsRGVhY3RpdmF0ZUluc3RydWN0aW9uc0luZGV4ZXMsXG4gIHN0YWtpbmdXaXRoZHJhd0luc3RydWN0aW9uc0luZGV4ZXMsXG4gIFZBTElEX1NZU1RFTV9JTlNUUlVDVElPTl9UWVBFUyxcbiAgdmFsaWRJbnN0cnVjdGlvbkRhdGEsXG4gIHZhbGlkSW5zdHJ1Y3Rpb25EYXRhMixcbiAgVmFsaWRJbnN0cnVjdGlvblR5cGVzRW51bSxcbiAgd2FsbGV0SW5pdEluc3RydWN0aW9uSW5kZXhlcyxcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgVmFsaWRJbnN0cnVjdGlvblR5cGVzIH0gZnJvbSAnLi9pZmFjZSc7XG5cbmNvbnN0IERFQ09ERURfQkxPQ0tfSEFTSF9MRU5HVEggPSAzMjsgLy8gaHR0cHM6Ly9kb2NzLnNvbGFuYS5jb20vZGV2ZWxvcGluZy9wcm9ncmFtbWluZy1tb2RlbC90cmFuc2FjdGlvbnMjYmxvY2toYXNoLWZvcm1hdFxuY29uc3QgREVDT0RFRF9TSUdOQVRVUkVfTEVOR1RIID0gNjQ7IC8vIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3Rlcm1pbm9sb2d5I3NpZ25hdHVyZVxuY29uc3QgQkFTRV81OF9FTkNPTkRJTkdfUkVHRVggPSAnWzEtOUEtSEotTlAtWmEta20tel0nO1xuXG4vKiogQGluaGVyaXRkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzVmFsaWRQdWJsaWNLZXkoYWRkcmVzcyk7XG59XG5cbi8qKiBAaW5oZXJpdGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRCbG9ja0lkKGhhc2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIHJldHVybiAoXG4gICAgICAhIWhhc2ggJiYgbmV3IFJlZ0V4cChCQVNFXzU4X0VOQ09ORElOR19SRUdFWCkudGVzdChoYXNoKSAmJiBiczU4LmRlY29kZShoYXNoKS5sZW5ndGggPT09IERFQ09ERURfQkxPQ0tfSEFTSF9MRU5HVEhcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKiBAaW5oZXJpdGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRQcml2YXRlS2V5KHBydktleTogc3RyaW5nIHwgVWludDhBcnJheSk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGNvbnN0IGtleTogVWludDhBcnJheSA9IHR5cGVvZiBwcnZLZXkgPT09ICdzdHJpbmcnID8gYmFzZTU4VG9VaW50OEFycmF5KHBydktleSkgOiBwcnZLZXk7XG4gICAgcmV0dXJuICEhS2V5cGFpci5mcm9tU2VjcmV0S2V5KGtleSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqIEBpbmhlcml0ZG9jICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFB1YmxpY0tleShwdWJLZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGlmIChpc1ZhbGlkWHB1YihwdWJLZXkpKSByZXR1cm4gdHJ1ZTtcbiAgICBuZXcgUHVibGljS2V5KHB1YktleSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKiogQGluaGVyaXRkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkU2lnbmF0dXJlKHNpZ25hdHVyZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhc2lnbmF0dXJlICYmIGJzNTguZGVjb2RlKHNpZ25hdHVyZSkubGVuZ3RoID09PSBERUNPREVEX1NJR05BVFVSRV9MRU5HVEg7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqIEBpbmhlcml0ZG9jICovXG4vLyBUcmFuc2FjdGlvbklkIGFyZSB0aGUgZmlyc3Qgc2lnbmF0dXJlIG9uIGEgVHJhbnNhY3Rpb25cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkVHJhbnNhY3Rpb25JZCh0eElkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzVmFsaWRTaWduYXR1cmUodHhJZCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgYW1vdW50IG9mIGxhbXBvcnRzIG51bWJlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbW91bnQgLSB0aGUgc3RyaW5nIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRBbW91bnQoYW1vdW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgYmlnTnVtYmVyQW1vdW50ID0gbmV3IEJpZ051bWJlcihhbW91bnQpO1xuICByZXR1cm4gYmlnTnVtYmVyQW1vdW50LmlzSW50ZWdlcigpICYmIGJpZ051bWJlckFtb3VudC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvKDApO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBhbW91bnQgb2YgbGFtcG9ydHMgbnVtYmVyIG9uIHN0YWtpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYW1vdW50IC0gdGhlIHN0cmluZyB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkU3Rha2luZ0Ftb3VudChhbW91bnQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBiaWdOdW1iZXJBbW91bnQgPSBuZXcgQmlnTnVtYmVyKGFtb3VudCk7XG4gIHJldHVybiBiaWdOdW1iZXJBbW91bnQuaXNJbnRlZ2VyKCkgJiYgYmlnTnVtYmVyQW1vdW50LmlzR3JlYXRlclRoYW4oMCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBpcyBhIHZhbGlkIG1lbW8gb3Igbm90LlxuICpcbiAqIEBwYXJhbSBtZW1vIC0gdGhlIG1lbW8gc3RyaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRNZW1vKG1lbW86IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gQnVmZmVyLmZyb20obWVtbykubGVuZ3RoIDw9IE1BWF9NRU1PX0xFTkdUSDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgcmF3IHRyYW5zYWN0aW9uIGNhbiBiZSBkZXNlcmlhbGl6ZWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmF3VHJhbnNhY3Rpb24gLSB0cmFuc2FjdGlvbiBpbiBiYXNlNjQgc3RyaW5nIGZvcm1hdFxuICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlQWxsU2lnbmF0dXJlcyAtIHJlcXVpcmUgYWxsIHNpZ25hdHVyZXMgdG8gYmUgcHJlc2VudFxuICogQHBhcmFtIHtib29sZWFufSB2ZXJpZnlTaWduYXR1cmVzIC0gdmVyaWZ5IHNpZ25hdHVyZXNcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFJhd1RyYW5zYWN0aW9uKFxuICByYXdUcmFuc2FjdGlvbjogc3RyaW5nLFxuICByZXF1aXJlQWxsU2lnbmF0dXJlcyA9IGZhbHNlLFxuICB2ZXJpZnlTaWduYXR1cmVzID0gZmFsc2Vcbik6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGNvbnN0IHR4ID0gU29sVHJhbnNhY3Rpb24uZnJvbShCdWZmZXIuZnJvbShyYXdUcmFuc2FjdGlvbiwgJ2Jhc2U2NCcpKTtcbiAgICB0eC5zZXJpYWxpemUoeyByZXF1aXJlQWxsU2lnbmF0dXJlcywgdmVyaWZ5U2lnbmF0dXJlcyB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFZlcmlmaWVzIGlmIHNpZ25hdHVyZSBmb3IgbWVzc2FnZSBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2VyaWFsaXplZFR4IC0gdHggYXMgYSBiYXNlNjQgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlIC0gc2lnbmF0dXJlIGFzIGEgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljS2V5IC0gcHVibGljIGtleSBhcyBiYXNlIDU4XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBzaWduYXR1cmUgaXMgdmFsaWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUoc2VyaWFsaXplZFR4OiBzdHJpbmcsIHNpZ25hdHVyZTogc3RyaW5nLCBwdWJsaWNLZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAoIWlzVmFsaWRSYXdUcmFuc2FjdGlvbihzZXJpYWxpemVkVHgpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ0ludmFsaWQgc2VyaWFsaXplZFR4Jyk7XG4gIH1cbiAgaWYgKCFpc1ZhbGlkUHVibGljS2V5KHB1YmxpY0tleSkpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignSW52YWxpZCBwdWJsaWNLZXknKTtcbiAgfVxuICBpZiAoIWlzVmFsaWRTaWduYXR1cmUoc2lnbmF0dXJlKSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdJbnZhbGlkIHNpZ25hdHVyZScpO1xuICB9XG4gIGNvbnN0IG1zZyA9IFNvbFRyYW5zYWN0aW9uLmZyb20oQnVmZmVyLmZyb20oc2VyaWFsaXplZFR4LCAnYmFzZTY0JykpLnNlcmlhbGl6ZU1lc3NhZ2UoKTtcbiAgY29uc3Qgc2lnID0gYmFzZTU4VG9VaW50OEFycmF5KHNpZ25hdHVyZSk7XG4gIGNvbnN0IHB1YiA9IG5ldyBQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgcmV0dXJuIG5hY2wuc2lnbi5kZXRhY2hlZC52ZXJpZnkobXNnLCBzaWcsIHB1Yi50b0J1ZmZlcigpKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2U1OCBzdHJpbmcgaW50byBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IC0gYSBzdHJpbmcgaW4gYmFzZTU4XG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gLSBhbiBVaW50OEFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNThUb1VpbnQ4QXJyYXkoaW5wdXQ6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnM1OC5kZWNvZGUoaW5wdXQpKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVpbnQ4QXJyYXkgdG8gYSBiYXNlNTggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gaW5wdXQgLSBhbiBVaW50OEFycmF5XG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIGEgc3RyaW5nIGluIGJhc2U1OFxuICovXG5leHBvcnQgZnVuY3Rpb24gVWludDhBcnJheVRvYmFzZTU4KGlucHV0OiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgcmV0dXJuIGJzNTguZW5jb2RlKGlucHV0KTtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgYW1vdW50IG9mIHNpZ25hdHVyZXMgYXJlIG5vdCBudWxsLlxuICpcbiAqIEBwYXJhbSB7U2lnbmF0dXJlUHVia2V5UGFpcltdfSBzaWduYXR1cmVzIC0gYW4gYXJyYXkgb2YgU2lnbmF0dXJlUHVia2V5UGFpclxuICogQHJldHVybnMge251bWJlcn0gLSB0aGUgYW1vdW50IG9mIHZhbGlkIHNpZ25hdHVyZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvdW50Tm90TnVsbFNpZ25hdHVyZXMoc2lnbmF0dXJlczogU2lnbmF0dXJlUHVia2V5UGFpcltdKTogbnVtYmVyIHtcbiAgcmV0dXJuIHNpZ25hdHVyZXMuZmlsdGVyKChzaWcpID0+ICEhc2lnLnNpZ25hdHVyZSkubGVuZ3RoO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFsbCBzaWduYXR1cmVzIGFyZSBjb21wbGV0ZWQuXG4gKlxuICogQHBhcmFtIHtTaWduYXR1cmVQdWJrZXlQYWlyW119IHNpZ25hdHVyZXMgLSBzaWduYXR1cmVzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcXVpcmVzQWxsU2lnbmF0dXJlcyhzaWduYXR1cmVzOiBTaWduYXR1cmVQdWJrZXlQYWlyW10pOiBib29sZWFuIHtcbiAgcmV0dXJuIHNpZ25hdHVyZXMubGVuZ3RoID4gMCAmJiBjb3VudE5vdE51bGxTaWduYXR1cmVzKHNpZ25hdHVyZXMpID09PSBzaWduYXR1cmVzLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBDaGVjayB0aGUgdHJhbnNhY3Rpb24gdHlwZSBtYXRjaGluZyBpbnN0cnVjdGlvbnMgYnkgb3JkZXIuIE1lbW8gYW5kIEFkdmFuY2VOb25jZUFjY291bnQgaW5zdHJ1Y3Rpb25zXG4gKiBhcmUgaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uSW5zdHJ1Y3Rpb25bXX0gaW5zdHJ1Y3Rpb25zIC0gdGhlIGFycmF5IG9mIHN1cHBvcnRlZCBTb2xhbmEgaW5zdHJ1Y3Rpb25zIHRvIGJlIHBhcnNlZFxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fSBpbnN0cnVjdGlvbkluZGV4ZXMgLSB0aGUgaW5zdHJ1Y3Rpb25zIGluZGV4ZXMgb2YgdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb25cbiAqIEByZXR1cm5zIHRydWUgaWYgaXQgbWF0Y2hlcyBieSBvcmRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoVHJhbnNhY3Rpb25UeXBlQnlJbnN0cnVjdGlvbnNPcmRlcihcbiAgaW5zdHJ1Y3Rpb25zOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uW10sXG4gIGluc3RydWN0aW9uSW5kZXhlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPlxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGluc3RydWN0aW9uc0NvcHkgPSBbLi4uaW5zdHJ1Y3Rpb25zXTsgLy8gTWFrZSBhIGNvcHkgc2luY2Ugd2UgbWF5IG1vZGlmeSB0aGUgYXJyYXkgYmVsb3dcbiAgLy8gQWR2YW5jZU5vbmNlQWNjb3VudCBpcyBvcHRpb25hbCBhbmQgdGhlIGZpcnN0IGluc3RydWN0aW9uIGFkZGVkLCBpdCBkb2VzIG5vdCBtYXR0ZXIgdG8gbWF0Y2ggdGhlIHR5cGVcbiAgaWYgKGluc3RydWN0aW9uc0NvcHkubGVuZ3RoID4gMCkge1xuICAgIGlmIChnZXRJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb25zWzBdKSA9PT0gJ0FkdmFuY2VOb25jZUFjY291bnQnKSB7XG4gICAgICBpbnN0cnVjdGlvbnNDb3B5LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gTWVtbyBpcyBvcHRpb25hbCBhbmQgdGhlIGxhc3QgaW5zdHJ1Y3Rpb24gYWRkZWQsIGl0IGRvZXMgbm90IG1hdHRlciB0byBtYXRjaCB0aGUgdHlwZVxuICAvLyBXaHkgaGF2ZSBpdCBpbiBpbnN0cnVjdGlvbktleXMgaWYgd2UgYXJlIGdvaW5nIHRvIGlnbm9yZSBpdD9cbiAgY29uc3QgaW5zdHJ1Y3Rpb25zS2V5cyA9IE9iamVjdC5rZXlzKGluc3RydWN0aW9uSW5kZXhlcyk7XG4gIGlmIChpbnN0cnVjdGlvbnNLZXlzW2luc3RydWN0aW9uc0tleXMubGVuZ3RoIC0gMV0gPT09ICdNZW1vJykge1xuICAgIGluc3RydWN0aW9uc0tleXMucG9wKCk7XG4gIH1cblxuICAvLyBDaGVjayBpbnN0cnVjdGlvbnMgYnkgb3JkZXIgdXNpbmcgdGhlIGluZGV4LlxuICBmb3IgKGNvbnN0IGtleU5hbWUgb2YgaW5zdHJ1Y3Rpb25zS2V5cykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGdldEluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbnNDb3B5W2luc3RydWN0aW9uSW5kZXhlc1trZXlOYW1lXV0pO1xuICAgIGlmIChyZXN1bHQgIT09IGtleU5hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gVHlwZSBiYXNlZCBvbiB0aGUgIHRyYW5zYWN0aW9uIGluc3RydWN0aW9ucy5cbiAqIFdhbGxldCBpbml0aWFsaXphdGlvbiwgVHJhbnNmZXIgYW5kIFN0YWtpbmcgdHJhbnNhY3Rpb25zIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogQHBhcmFtIHtTb2xUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gLSB0aGUgc29sYW5hIHRyYW5zYWN0aW9uXG4gKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25UeXBlfSAtIHRoZSB0eXBlIG9mIHRyYW5zYWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2FjdGlvblR5cGUodHJhbnNhY3Rpb246IFNvbFRyYW5zYWN0aW9uKTogVHJhbnNhY3Rpb25UeXBlIHtcbiAgY29uc3QgeyBpbnN0cnVjdGlvbnMgfSA9IHRyYW5zYWN0aW9uO1xuICBpZiAodmFsaWRhdGVSYXdNc2dJbnN0cnVjdGlvbihpbnN0cnVjdGlvbnMpKSB7XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nQXV0aG9yaXplUmF3O1xuICB9XG4gIHZhbGlkYXRlSW50cnVjdGlvblR5cGVzKGluc3RydWN0aW9ucyk7XG4gIC8vIGNoZWNrIGlmIGRlYWN0aXZhdGUgaW5zdHJ1Y3Rpb24gZG9lcyBub3QgZXhpc3QgYmVjYXVzZSBkZWFjdGl2YXRlIGNhbiBiZSBpbmNsdWRlIGEgdHJhbnNmZXIgaW5zdHJ1Y3Rpb25cbiAgaWYgKGluc3RydWN0aW9ucy5maWx0ZXIoKGluc3RydWN0aW9uKSA9PiBnZXRJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pID09PSAnRGVhY3RpdmF0ZScpLmxlbmd0aCA9PSAwKSB7XG4gICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiBpbnN0cnVjdGlvbnMpIHtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZSA9IGdldEluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbik7XG4gICAgICBpZiAoXG4gICAgICAgIGluc3RydWN0aW9uVHlwZSA9PT0gVmFsaWRJbnN0cnVjdGlvblR5cGVzRW51bS5UcmFuc2ZlciB8fFxuICAgICAgICBpbnN0cnVjdGlvblR5cGUgPT09IFZhbGlkSW5zdHJ1Y3Rpb25UeXBlc0VudW0uVG9rZW5UcmFuc2ZlclxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU2VuZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoVHJhbnNhY3Rpb25UeXBlQnlJbnN0cnVjdGlvbnNPcmRlcihpbnN0cnVjdGlvbnMsIHdhbGxldEluaXRJbnN0cnVjdGlvbkluZGV4ZXMpKSB7XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZS5XYWxsZXRJbml0aWFsaXphdGlvbjtcbiAgfSBlbHNlIGlmIChtYXRjaFRyYW5zYWN0aW9uVHlwZUJ5SW5zdHJ1Y3Rpb25zT3JkZXIoaW5zdHJ1Y3Rpb25zLCBzdGFraW5nQWN0aXZhdGVJbnN0cnVjdGlvbnNJbmRleGVzKSkge1xuICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0FjdGl2YXRlO1xuICB9IGVsc2UgaWYgKG1hdGNoVHJhbnNhY3Rpb25UeXBlQnlJbnN0cnVjdGlvbnNPcmRlcihpbnN0cnVjdGlvbnMsIHN0YWtpbmdBdXRob3JpemVJbnN0cnVjdGlvbnNJbmRleGVzKSkge1xuICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0F1dGhvcml6ZTtcbiAgfSBlbHNlIGlmIChtYXRjaFRyYW5zYWN0aW9uVHlwZUJ5SW5zdHJ1Y3Rpb25zT3JkZXIoaW5zdHJ1Y3Rpb25zLCBzdGFraW5nRGVsZWdhdGVJbnN0cnVjdGlvbnNJbmRleGVzKSkge1xuICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0RlbGVnYXRlO1xuICB9IGVsc2UgaWYgKFxuICAgIG1hdGNoVHJhbnNhY3Rpb25UeXBlQnlJbnN0cnVjdGlvbnNPcmRlcihpbnN0cnVjdGlvbnMsIHN0YWtpbmdEZWFjdGl2YXRlSW5zdHJ1Y3Rpb25zSW5kZXhlcykgfHxcbiAgICBtYXRjaFRyYW5zYWN0aW9uVHlwZUJ5SW5zdHJ1Y3Rpb25zT3JkZXIoaW5zdHJ1Y3Rpb25zLCBzdGFraW5nUGFydGlhbERlYWN0aXZhdGVJbnN0cnVjdGlvbnNJbmRleGVzKVxuICApIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdEZWFjdGl2YXRlO1xuICB9IGVsc2UgaWYgKG1hdGNoVHJhbnNhY3Rpb25UeXBlQnlJbnN0cnVjdGlvbnNPcmRlcihpbnN0cnVjdGlvbnMsIHN0YWtpbmdXaXRoZHJhd0luc3RydWN0aW9uc0luZGV4ZXMpKSB7XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nV2l0aGRyYXc7XG4gIH0gZWxzZSBpZiAobWF0Y2hUcmFuc2FjdGlvblR5cGVCeUluc3RydWN0aW9uc09yZGVyKGluc3RydWN0aW9ucywgYXRhSW5pdEluc3RydWN0aW9uSW5kZXhlcykpIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLkFzc29jaWF0ZWRUb2tlbkFjY291bnRJbml0aWFsaXphdGlvbjtcbiAgfSBlbHNlIGlmIChtYXRjaFRyYW5zYWN0aW9uVHlwZUJ5SW5zdHJ1Y3Rpb25zT3JkZXIoaW5zdHJ1Y3Rpb25zLCBhdGFDbG9zZUluc3RydWN0aW9uSW5kZXhlcykpIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLkNsb3NlQXNzb2NpYXRlZFRva2VuQWNjb3VudDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkKCdJbnZhbGlkIHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbiBub3Qgc3VwcG9ydGVkIG9yIGludmFsaWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGluc3RydWN0aW9uIFR5cGUgYmFzZWQgb24gdGhlIHNvbGFuYSBpbnN0cnVjdGlvbnMuXG4gKiBUaHJvd3MgaWYgdGhlIHNvbGFuYSBpbnN0cnVjdGlvbiBwcm9ncmFtIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uSW5zdHJ1Y3Rpb259IGluc3RydWN0aW9uIC0gYSBzb2xhbmEgaW5zdHJ1Y3Rpb25cbiAqIEByZXR1cm5zIHtWYWxpZEluc3RydWN0aW9uVHlwZXN9IC0gYSBzb2xhbmEgaW5zdHJ1Y3Rpb24gdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uKTogVmFsaWRJbnN0cnVjdGlvblR5cGVzIHtcbiAgc3dpdGNoIChpbnN0cnVjdGlvbi5wcm9ncmFtSWQudG9TdHJpbmcoKSkge1xuICAgIGNhc2UgbmV3IFB1YmxpY0tleShNRU1PX1BST0dSQU1fUEspLnRvU3RyaW5nKCk6XG4gICAgICByZXR1cm4gJ01lbW8nO1xuICAgIGNhc2UgU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQudG9TdHJpbmcoKTpcbiAgICAgIHJldHVybiBTeXN0ZW1JbnN0cnVjdGlvbi5kZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pO1xuICAgIGNhc2UgVE9LRU5fUFJPR1JBTV9JRC50b1N0cmluZygpOlxuICAgICAgcmV0dXJuICdUb2tlblRyYW5zZmVyJztcbiAgICBjYXNlIFN0YWtlUHJvZ3JhbS5wcm9ncmFtSWQudG9TdHJpbmcoKTpcbiAgICAgIHJldHVybiBTdGFrZUluc3RydWN0aW9uLmRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbik7XG4gICAgY2FzZSBBU1NPQ0lBVEVEX1RPS0VOX1BST0dSQU1fSUQudG9TdHJpbmcoKTpcbiAgICAgIC8vIFRPRE86IGNoYW5nZSB0aGlzIHdoZW4gQHNwbC10b2tlbiBzdXBwb3J0cyBkZWNvZGluZyBhc3NvY2lhdGVkIHRva2VuIGluc3RydWN0aW9uc1xuICAgICAgaWYgKGluc3RydWN0aW9uLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnSW5pdGlhbGl6ZUFzc29jaWF0ZWRUb2tlbkFjY291bnQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZChcbiAgICAgICAgICAnSW52YWxpZCB0cmFuc2FjdGlvbiwgaW5zdHJ1Y3Rpb24gcHJvZ3JhbSBpZCBub3Qgc3VwcG9ydGVkOiAnICsgaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkLnRvU3RyaW5nKClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZChcbiAgICAgICAgJ0ludmFsaWQgdHJhbnNhY3Rpb24sIGluc3RydWN0aW9uIHByb2dyYW0gaWQgbm90IHN1cHBvcnRlZDogJyArIGluc3RydWN0aW9uLnByb2dyYW1JZC50b1N0cmluZygpXG4gICAgICApO1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGUgc29sYW5hIGluc3RydWN0aW9ucyB0eXBlcyB0byBzZWUgaWYgdGhleSBhcmUgc3VwcG9ydGVkIGJ5IHRoZSBidWlsZGVyLlxuICogVGhyb3dzIGlmIHRoZSBpbnN0cnVjdGlvbiB0eXBlIGlzIGludmFsaWQuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbkluc3RydWN0aW9ufSBpbnN0cnVjdGlvbnMgLSBhIHNvbGFuYSBpbnN0cnVjdGlvblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUludHJ1Y3Rpb25UeXBlcyhpbnN0cnVjdGlvbnM6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb25bXSk6IHZvaWQge1xuICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIGluc3RydWN0aW9ucykge1xuICAgIGlmICghVkFMSURfU1lTVEVNX0lOU1RSVUNUSU9OX1RZUEVTLmluY2x1ZGVzKGdldEluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikpKSB7XG4gICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkKCdJbnZhbGlkIHRyYW5zYWN0aW9uLCBpbnN0cnVjdGlvbiB0eXBlIG5vdCBzdXBwb3J0ZWQ6ICcgKyBnZXRJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBzb2xhbmEgaW5zdHJ1Y3Rpb25zIG1hdGNoIHJhdyBtc2cgYXV0aG9yaXplIHRyYW5zYWN0aW9uXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbkluc3RydWN0aW9ufSBpbnN0cnVjdGlvbnMgLSBhIHNvbGFuYSBpbnN0cnVjdGlvblxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGluc3RydWN0aW9ucyBtYXRjaCB0aGUgcmF3IG1zZyBhdXRob3JpemUgdHJhbnNhY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUmF3TXNnSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25zOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uW10pOiBib29sZWFuIHtcbiAgLy8gYXMgd2ViMy5qcyBjYW5ub3QgZGVjb2RlIGF1dGhvcml6ZSBpbnN0cnVjdGlvbiBmcm9tIENMSSwgd2UgbmVlZCB0byBjaGVjayBpdCBtYW51YWxseSBmaXJzdFxuICBpZiAoaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHByb2dyYW1JZDEgPSBpbnN0cnVjdGlvbnNbMF0ucHJvZ3JhbUlkLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgcHJvZ3JhbUlkMiA9IGluc3RydWN0aW9uc1sxXS5wcm9ncmFtSWQudG9TdHJpbmcoKTtcbiAgICBpZiAocHJvZ3JhbUlkMSA9PT0gU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQudG9TdHJpbmcoKSAmJiBwcm9ncmFtSWQyID09PSBTdGFrZVByb2dyYW0ucHJvZ3JhbUlkLnRvU3RyaW5nKCkpIHtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uTmFtZTEgPSBTeXN0ZW1JbnN0cnVjdGlvbi5kZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb25zWzBdKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBpbnN0cnVjdGlvbnNbMV0uZGF0YS50b1N0cmluZygnaGV4Jyk7XG4gICAgICBpZiAoXG4gICAgICAgIGluc3RydWN0aW9uTmFtZTEgPT09IG5vbmNlQWR2YW5jZUluc3RydWN0aW9uICYmXG4gICAgICAgIChkYXRhID09PSB2YWxpZEluc3RydWN0aW9uRGF0YSB8fCBkYXRhID09PSB2YWxpZEluc3RydWN0aW9uRGF0YTIpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpbnN0cnVjdGlvbnMubGVuZ3RoID09PSAzKSB7XG4gICAgY29uc3QgcHJvZ3JhbUlkMSA9IGluc3RydWN0aW9uc1swXS5wcm9ncmFtSWQudG9TdHJpbmcoKTtcbiAgICBjb25zdCBwcm9ncmFtSWQyID0gaW5zdHJ1Y3Rpb25zWzFdLnByb2dyYW1JZC50b1N0cmluZygpO1xuICAgIGNvbnN0IHByb2dyYW1JZDMgPSBpbnN0cnVjdGlvbnNbMl0ucHJvZ3JhbUlkLnRvU3RyaW5nKCk7XG4gICAgaWYgKFxuICAgICAgcHJvZ3JhbUlkMSA9PT0gU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQudG9TdHJpbmcoKSAmJlxuICAgICAgcHJvZ3JhbUlkMiA9PT0gU3Rha2VQcm9ncmFtLnByb2dyYW1JZC50b1N0cmluZygpICYmXG4gICAgICBwcm9ncmFtSWQzID09PSBTdGFrZVByb2dyYW0ucHJvZ3JhbUlkLnRvU3RyaW5nKClcbiAgICApIHtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uTmFtZTEgPSBTeXN0ZW1JbnN0cnVjdGlvbi5kZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb25zWzBdKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBpbnN0cnVjdGlvbnNbMV0uZGF0YS50b1N0cmluZygnaGV4Jyk7XG4gICAgICBjb25zdCBkYXRhMiA9IGluc3RydWN0aW9uc1syXS5kYXRhLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIGlmIChcbiAgICAgICAgaW5zdHJ1Y3Rpb25OYW1lMSA9PT0gbm9uY2VBZHZhbmNlSW5zdHJ1Y3Rpb24gJiZcbiAgICAgICAgKGRhdGEgPT09IHZhbGlkSW5zdHJ1Y3Rpb25EYXRhIHx8IGRhdGEgPT09IHZhbGlkSW5zdHJ1Y3Rpb25EYXRhMikgJiZcbiAgICAgICAgKGRhdGEyID09PSB2YWxpZEluc3RydWN0aW9uRGF0YSB8fCBkYXRhMiA9PT0gdmFsaWRJbnN0cnVjdGlvbkRhdGEyKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIENoZWNrIHRoZSByYXcgdHJhbnNhY3Rpb24gaGFzIGEgdmFsaWQgZm9ybWF0IGluIHRoZSBibG9ja2NoYWluIGNvbnRleHQsIHRocm93IG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmF3VHJhbnNhY3Rpb24gLSBUcmFuc2FjdGlvbiBpbiBiYXNlNjQgc3RyaW5nICBmb3JtYXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUmF3VHJhbnNhY3Rpb24oXG4gIHJhd1RyYW5zYWN0aW9uOiBzdHJpbmcsXG4gIHJlcXVpcmVBbGxTaWduYXR1cmVzID0gZmFsc2UsXG4gIHZlcmlmeVNpZ25hdHVyZXMgPSBmYWxzZVxuKTogdm9pZCB7XG4gIGlmICghcmF3VHJhbnNhY3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHJhdyB0cmFuc2FjdGlvbjogVW5kZWZpbmVkJyk7XG4gIH1cbiAgaWYgKCFpc1ZhbGlkUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb24sIHJlcXVpcmVBbGxTaWduYXR1cmVzLCB2ZXJpZnlTaWduYXR1cmVzKSkge1xuICAgIHRocm93IG5ldyBQYXJzZVRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgcmF3IHRyYW5zYWN0aW9uJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgYWRkcmVzcyB0byBjaGVjayBpZiBpdCBleGlzdHMgYW5kIGlzIGEgdmFsaWQgU29sYW5hIHB1YmxpYyBrZXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyBUaGUgYWRkcmVzcyB0byBiZSB2YWxpZGF0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE5hbWUgTmFtZSBvZiB0aGUgZmllbGQgdG8gdmFsaWRhdGUsIGl0cyBuZWVkZWQgdG8gcmV0dXJuIHdoaWNoIGZpZWxkIGlzIGZhaWxpbmcgb24gY2FzZSBvZiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcsIGZpZWxkTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmICghYWRkcmVzcyB8fCAhaXNWYWxpZFB1YmxpY0tleShhZGRyZXNzKSkge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgb3IgbWlzc2luZyAke2ZpZWxkTmFtZX0sIGdvdDogJHthZGRyZXNzfWApO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBzdGF0aWNzIGNvaW4gb2JqZWN0IG1hdGNoaW5nIGEgZ2l2ZW4gU29sYW5hIHRva2VuIGFkZHJlc3MgaWYgaXQgZXhpc3RzXG4gKlxuICogQHBhcmFtIHRva2VuQWRkcmVzcyBUaGUgdG9rZW4gYWRkcmVzcyB0byBtYXRjaCBhZ2FpbnN0XG4gKiBAcGFyYW0gbmV0d29yayBTb2xhbmEgTWFpbm5ldCBvciBUZXN0bmV0XG4gKiBAcmV0dXJucyBzdGF0aWNzIEJhc2VDb2luIG9iamVjdCBmb3IgdGhlIG1hdGNoaW5nIHRva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTb2xUb2tlbkZyb21BZGRyZXNzKHRva2VuQWRkcmVzczogc3RyaW5nLCBuZXR3b3JrOiBCYXNlTmV0d29yayk6IFJlYWRvbmx5PEJhc2VDb2luPiB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHRva2VucyA9IGNvaW5zLmZpbHRlcigoY29pbikgPT4ge1xuICAgIGlmIChjb2luIGluc3RhbmNlb2YgU29sQ29pbikge1xuICAgICAgcmV0dXJuIGNvaW4ubmV0d29yay50eXBlID09PSBuZXR3b3JrLnR5cGUgJiYgY29pbi50b2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gdG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIGNvbnN0IHRva2Vuc0FycmF5ID0gdG9rZW5zLm1hcCgodG9rZW4pID0+IHRva2VuKTtcbiAgaWYgKHRva2Vuc0FycmF5Lmxlbmd0aCA+PSAxKSB7XG4gICAgLy8gdGhlcmUgc2hvdWxkIG5ldmVyIGJlIHR3byB0b2tlbnMgd2l0aCB0aGUgc2FtZSBjb250cmFjdCBhZGRyZXNzLCBzbyB3ZSBhc3NlcnQgdGhhdCBoZXJlXG4gICAgYXNzZXJ0KHRva2Vuc0FycmF5Lmxlbmd0aCA9PT0gMSk7XG4gICAgcmV0dXJuIHRva2Vuc0FycmF5WzBdO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzb2xhbmEgdG9rZW4gb2JqZWN0IGZyb20gdG9rZW4gbmFtZVxuICogQHBhcmFtIHRva2VuTmFtZSBUaGUgdG9rZW4gbmFtZSB0byBtYXRjaCBhZ2FpbnN0XG4gKiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNvbFRva2VuRnJvbVRva2VuTmFtZSh0b2tlbk5hbWU6IHN0cmluZyk6IFJlYWRvbmx5PFNvbENvaW4+IHwgdW5kZWZpbmVkIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0b2tlbiA9IGNvaW5zLmdldCh0b2tlbk5hbWUpO1xuICAgIGlmICghKHRva2VuLmlzVG9rZW4gJiYgdG9rZW4gaW5zdGFuY2VvZiBTb2xDb2luKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKCEoZSBpbnN0YW5jZW9mIENvaW5Ob3REZWZpbmVkRXJyb3IpKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBzb2xhbmEgYXNzb2NpYXRlZCB0b2tlbiBhY2NvdW50IGFkZHJlc3NcbiAqIEBwYXJhbSB0b2tlbkFkZHJlc3MgVGhlIHRva2VuIGFkZHJlc3NcbiAqIEBwYXJhbSBvd25lckFkZHJlc3MgVGhlIG93bmVyIG9mIHRoZSBhc3NvY2lhdGVkIHRva2VuIGFjY291bnRcbiAqIEByZXR1cm5zIFRoZSBhc3NvY2lhdGVkIHRva2VuIGFjY291bnQgYWRkcmVzc1xuICogKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBc3NvY2lhdGVkVG9rZW5BY2NvdW50QWRkcmVzcyh0b2tlbkFkZHJlc3M6IHN0cmluZywgb3duZXJBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBvd25lclB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXkob3duZXJBZGRyZXNzKTtcblxuICAvLyB0b2tlbkFkZHJlc3MgYXJlIG5vdCBvbiBlZDI1NTE5IGN1cnZlLCBzbyB0aGV5IGNhbid0IGJlIHVzZWQgYXMgb3duZXJBZGRyZXNzXG4gIGlmICghUHVibGljS2V5LmlzT25DdXJ2ZShvd25lclB1YmxpY0tleS50b0J1ZmZlcigpKSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdJbnZhbGlkIG93bmVyQWRkcmVzcyAtIGFkZHJlc3Mgb2ZmIGVkMjU1MTkgY3VydmUsIGdvdDogJyArIG93bmVyQWRkcmVzcyk7XG4gIH1cbiAgY29uc3QgYXRhQWRkcmVzcyA9IGF3YWl0IGdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3MobmV3IFB1YmxpY0tleSh0b2tlbkFkZHJlc3MpLCBvd25lclB1YmxpY0tleSk7XG4gIHJldHVybiBhdGFBZGRyZXNzLnRvU3RyaW5nKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU1pbnRBZGRyZXNzKG1pbnRBZGRyZXNzOiBzdHJpbmcpIHtcbiAgaWYgKCFtaW50QWRkcmVzcyB8fCAhaXNWYWxpZEFkZHJlc3MobWludEFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBvciBtaXNzaW5nIG1pbnRBZGRyZXNzLCBnb3Q6ICcgKyBtaW50QWRkcmVzcyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlT3duZXJBZGRyZXNzKG93bmVyQWRkcmVzczogc3RyaW5nKSB7XG4gIGlmICghb3duZXJBZGRyZXNzIHx8ICFpc1ZhbGlkQWRkcmVzcyhvd25lckFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBvciBtaXNzaW5nIG93bmVyQWRkcmVzcywgZ290OiAnICsgb3duZXJBZGRyZXNzKTtcbiAgfVxufVxuIl19