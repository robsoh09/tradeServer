"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StakingDelegateBuilder = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const transactionBuilder_1 = require("./transactionBuilder");
const constants_1 = require("./constants");
const assert_1 = __importDefault(require("assert"));
const utils_1 = require("./utils");
class StakingDelegateBuilder extends transactionBuilder_1.TransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
    }
    get transactionType() {
        return sdk_core_1.TransactionType.StakingDelegate;
    }
    /** @inheritdoc */
    initBuilder(tx) {
        super.initBuilder(tx);
        const stakingAddresses = [];
        for (const instruction of this._instructionsData) {
            if (instruction.type === constants_1.InstructionBuilderTypes.StakingDelegate) {
                const activateInstruction = instruction;
                this.sender(activateInstruction.params.fromAddress);
                stakingAddresses.push(activateInstruction.params.stakingAddress);
                this.validator(activateInstruction.params.validator);
            }
        }
        if (stakingAddresses.length > 1) {
            this.stakingAddresses(stakingAddresses);
        }
        else {
            this.stakingAddress(stakingAddresses[0]);
        }
    }
    /**
     * The address of the staking account.
     *
     * @param {string} stakingAddress public address of the staking account.
     * @returns {StakingDelegateBuilder} This staking delegate builder.
     *
     * @see https://docs.solana.com/staking/stake-accounts#account-address
     */
    stakingAddress(stakingAddress) {
        (0, utils_1.validateAddress)(stakingAddress, 'stakingAddress');
        this._stakingAddress = stakingAddress;
        return this;
    }
    /**
     * The staking addresses of the staking account.
     *
     * @param {string[]} stakingAddresses public address of the staking accounts
     * @returns {StakingDelegateBuilder} This staking delegate builder.
     *
     * @see https://docs.solana.com/staking/stake-accounts#account-address
     */
    stakingAddresses(stakingAddresses) {
        (0, assert_1.default)(stakingAddresses.length > 0, 'stakingAddresses must not be empty');
        for (const stakingAddress of stakingAddresses) {
            (0, utils_1.validateAddress)(stakingAddress, 'stakingAddress');
        }
        this._stakingAddresses = stakingAddresses;
        return this;
    }
    /**
     * Set validator address to delegate funds to.
     *
     * @param {string} validator Validator address to delegate funds to.
     * @returns {StakingDelegateBuilder} This staking builder.
     *
     */
    validator(validator) {
        (0, utils_1.validateAddress)(validator, 'validator');
        this._validator = validator;
        return this;
    }
    /** @inheritdoc */
    async buildImplementation() {
        (0, assert_1.default)(this._sender, 'Sender must be set before building the transaction');
        (0, assert_1.default)(this._validator, 'Validator must be set before building the transaction');
        if (this._stakingAddresses && this._stakingAddresses.length > 0) {
            this._instructionsData = [];
            for (const stakingAddress of this._stakingAddresses) {
                (0, assert_1.default)(stakingAddress, 'Staking Address must be set before building the transaction');
                if (this._sender === stakingAddress) {
                    throw new sdk_core_1.BuildTransactionError('Sender address cannot be the same as the Staking address');
                }
                const stakingAccountData = {
                    type: constants_1.InstructionBuilderTypes.StakingDelegate,
                    params: {
                        fromAddress: this._sender,
                        stakingAddress: stakingAddress,
                        validator: this._validator,
                    },
                };
                this._instructionsData.push(stakingAccountData);
            }
        }
        else {
            (0, assert_1.default)(this._stakingAddress, 'Staking Address must be set before building the transaction');
            if (this._sender === this._stakingAddress) {
                throw new sdk_core_1.BuildTransactionError('Sender address cannot be the same as the Staking address');
            }
            const stakingAccountData = {
                type: constants_1.InstructionBuilderTypes.StakingDelegate,
                params: {
                    fromAddress: this._sender,
                    stakingAddress: this._stakingAddress,
                    validator: this._validator,
                },
            };
            this._instructionsData = [stakingAccountData];
        }
        return await super.buildImplementation();
    }
}
exports.StakingDelegateBuilder = StakingDelegateBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3Rha2luZ0RlbGVnYXRlQnVpbGRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvc3Rha2luZ0RlbGVnYXRlQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSw4Q0FBeUU7QUFFekUsNkRBQTBEO0FBQzFELDJDQUFzRDtBQUV0RCxvREFBNEI7QUFFNUIsbUNBQTBDO0FBRTFDLE1BQWEsc0JBQXVCLFNBQVEsdUNBQWtCO0lBSzVELFlBQVksV0FBaUM7UUFDM0MsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFFRCxJQUFjLGVBQWU7UUFDM0IsT0FBTywwQkFBZSxDQUFDLGVBQWUsQ0FBQztJQUN6QyxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLFdBQVcsQ0FBQyxFQUFlO1FBQ3pCLEtBQUssQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdEIsTUFBTSxnQkFBZ0IsR0FBYSxFQUFFLENBQUM7UUFDdEMsS0FBSyxNQUFNLFdBQVcsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDaEQsSUFBSSxXQUFXLENBQUMsSUFBSSxLQUFLLG1DQUF1QixDQUFDLGVBQWUsRUFBRTtnQkFDaEUsTUFBTSxtQkFBbUIsR0FBb0IsV0FBVyxDQUFDO2dCQUN6RCxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDcEQsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDakUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDdEQ7U0FDRjtRQUNELElBQUksZ0JBQWdCLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUMvQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztTQUN6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QUUsQ0FBQztJQUMzQyxDQUFDO0NBQ0Y7QUFwSEQsd0RBb0hDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IEJ1aWxkVHJhbnNhY3Rpb25FcnJvciwgVHJhbnNhY3Rpb25UeXBlIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbkJ1aWxkZXIgfSBmcm9tICcuL3RyYW5zYWN0aW9uQnVpbGRlcic7XG5pbXBvcnQgeyBJbnN0cnVjdGlvbkJ1aWxkZXJUeXBlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHsgU3Rha2luZ0RlbGVnYXRlIH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyB2YWxpZGF0ZUFkZHJlc3MgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGNsYXNzIFN0YWtpbmdEZWxlZ2F0ZUJ1aWxkZXIgZXh0ZW5kcyBUcmFuc2FjdGlvbkJ1aWxkZXIge1xuICBwcm90ZWN0ZWQgX3N0YWtpbmdBZGRyZXNzOiBzdHJpbmc7XG4gIHByb3RlY3RlZCBfc3Rha2luZ0FkZHJlc3Nlczogc3RyaW5nW107XG4gIHByb3RlY3RlZCBfdmFsaWRhdG9yOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoX2NvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+KSB7XG4gICAgc3VwZXIoX2NvaW5Db25maWcpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldCB0cmFuc2FjdGlvblR5cGUoKTogVHJhbnNhY3Rpb25UeXBlIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdEZWxlZ2F0ZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpbml0QnVpbGRlcih0eDogVHJhbnNhY3Rpb24pOiB2b2lkIHtcbiAgICBzdXBlci5pbml0QnVpbGRlcih0eCk7XG4gICAgY29uc3Qgc3Rha2luZ0FkZHJlc3Nlczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIHRoaXMuX2luc3RydWN0aW9uc0RhdGEpIHtcbiAgICAgIGlmIChpbnN0cnVjdGlvbi50eXBlID09PSBJbnN0cnVjdGlvbkJ1aWxkZXJUeXBlcy5TdGFraW5nRGVsZWdhdGUpIHtcbiAgICAgICAgY29uc3QgYWN0aXZhdGVJbnN0cnVjdGlvbjogU3Rha2luZ0RlbGVnYXRlID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgIHRoaXMuc2VuZGVyKGFjdGl2YXRlSW5zdHJ1Y3Rpb24ucGFyYW1zLmZyb21BZGRyZXNzKTtcbiAgICAgICAgc3Rha2luZ0FkZHJlc3Nlcy5wdXNoKGFjdGl2YXRlSW5zdHJ1Y3Rpb24ucGFyYW1zLnN0YWtpbmdBZGRyZXNzKTtcbiAgICAgICAgdGhpcy52YWxpZGF0b3IoYWN0aXZhdGVJbnN0cnVjdGlvbi5wYXJhbXMudmFsaWRhdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YWtpbmdBZGRyZXNzZXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5zdGFraW5nQWRkcmVzc2VzKHN0YWtpbmdBZGRyZXNzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YWtpbmdBZGRyZXNzKHN0YWtpbmdBZGRyZXNzZXNbMF0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYWRkcmVzcyBvZiB0aGUgc3Rha2luZyBhY2NvdW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2luZ0FkZHJlc3MgcHVibGljIGFkZHJlc3Mgb2YgdGhlIHN0YWtpbmcgYWNjb3VudC5cbiAgICogQHJldHVybnMge1N0YWtpbmdEZWxlZ2F0ZUJ1aWxkZXJ9IFRoaXMgc3Rha2luZyBkZWxlZ2F0ZSBidWlsZGVyLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3N0YWtpbmcvc3Rha2UtYWNjb3VudHMjYWNjb3VudC1hZGRyZXNzXG4gICAqL1xuICBzdGFraW5nQWRkcmVzcyhzdGFraW5nQWRkcmVzczogc3RyaW5nKTogdGhpcyB7XG4gICAgdmFsaWRhdGVBZGRyZXNzKHN0YWtpbmdBZGRyZXNzLCAnc3Rha2luZ0FkZHJlc3MnKTtcbiAgICB0aGlzLl9zdGFraW5nQWRkcmVzcyA9IHN0YWtpbmdBZGRyZXNzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdGFraW5nIGFkZHJlc3NlcyBvZiB0aGUgc3Rha2luZyBhY2NvdW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBzdGFraW5nQWRkcmVzc2VzIHB1YmxpYyBhZGRyZXNzIG9mIHRoZSBzdGFraW5nIGFjY291bnRzXG4gICAqIEByZXR1cm5zIHtTdGFraW5nRGVsZWdhdGVCdWlsZGVyfSBUaGlzIHN0YWtpbmcgZGVsZWdhdGUgYnVpbGRlci5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS9zdGFraW5nL3N0YWtlLWFjY291bnRzI2FjY291bnQtYWRkcmVzc1xuICAgKi9cbiAgc3Rha2luZ0FkZHJlc3NlcyhzdGFraW5nQWRkcmVzc2VzOiBzdHJpbmdbXSk6IHRoaXMge1xuICAgIGFzc2VydChzdGFraW5nQWRkcmVzc2VzLmxlbmd0aCA+IDAsICdzdGFraW5nQWRkcmVzc2VzIG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gICAgZm9yIChjb25zdCBzdGFraW5nQWRkcmVzcyBvZiBzdGFraW5nQWRkcmVzc2VzKSB7XG4gICAgICB2YWxpZGF0ZUFkZHJlc3Moc3Rha2luZ0FkZHJlc3MsICdzdGFraW5nQWRkcmVzcycpO1xuICAgIH1cbiAgICB0aGlzLl9zdGFraW5nQWRkcmVzc2VzID0gc3Rha2luZ0FkZHJlc3NlcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdmFsaWRhdG9yIGFkZHJlc3MgdG8gZGVsZWdhdGUgZnVuZHMgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3IgVmFsaWRhdG9yIGFkZHJlc3MgdG8gZGVsZWdhdGUgZnVuZHMgdG8uXG4gICAqIEByZXR1cm5zIHtTdGFraW5nRGVsZWdhdGVCdWlsZGVyfSBUaGlzIHN0YWtpbmcgYnVpbGRlci5cbiAgICpcbiAgICovXG4gIHZhbGlkYXRvcih2YWxpZGF0b3I6IHN0cmluZyk6IHRoaXMge1xuICAgIHZhbGlkYXRlQWRkcmVzcyh2YWxpZGF0b3IsICd2YWxpZGF0b3InKTtcbiAgICB0aGlzLl92YWxpZGF0b3IgPSB2YWxpZGF0b3I7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGJ1aWxkSW1wbGVtZW50YXRpb24oKTogUHJvbWlzZTxUcmFuc2FjdGlvbj4ge1xuICAgIGFzc2VydCh0aGlzLl9zZW5kZXIsICdTZW5kZXIgbXVzdCBiZSBzZXQgYmVmb3JlIGJ1aWxkaW5nIHRoZSB0cmFuc2FjdGlvbicpO1xuICAgIGFzc2VydCh0aGlzLl92YWxpZGF0b3IsICdWYWxpZGF0b3IgbXVzdCBiZSBzZXQgYmVmb3JlIGJ1aWxkaW5nIHRoZSB0cmFuc2FjdGlvbicpO1xuXG4gICAgaWYgKHRoaXMuX3N0YWtpbmdBZGRyZXNzZXMgJiYgdGhpcy5fc3Rha2luZ0FkZHJlc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9pbnN0cnVjdGlvbnNEYXRhID0gW107XG4gICAgICBmb3IgKGNvbnN0IHN0YWtpbmdBZGRyZXNzIG9mIHRoaXMuX3N0YWtpbmdBZGRyZXNzZXMpIHtcbiAgICAgICAgYXNzZXJ0KHN0YWtpbmdBZGRyZXNzLCAnU3Rha2luZyBBZGRyZXNzIG11c3QgYmUgc2V0IGJlZm9yZSBidWlsZGluZyB0aGUgdHJhbnNhY3Rpb24nKTtcbiAgICAgICAgaWYgKHRoaXMuX3NlbmRlciA9PT0gc3Rha2luZ0FkZHJlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdTZW5kZXIgYWRkcmVzcyBjYW5ub3QgYmUgdGhlIHNhbWUgYXMgdGhlIFN0YWtpbmcgYWRkcmVzcycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YWtpbmdBY2NvdW50RGF0YTogU3Rha2luZ0RlbGVnYXRlID0ge1xuICAgICAgICAgIHR5cGU6IEluc3RydWN0aW9uQnVpbGRlclR5cGVzLlN0YWtpbmdEZWxlZ2F0ZSxcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIGZyb21BZGRyZXNzOiB0aGlzLl9zZW5kZXIsXG4gICAgICAgICAgICBzdGFraW5nQWRkcmVzczogc3Rha2luZ0FkZHJlc3MsXG4gICAgICAgICAgICB2YWxpZGF0b3I6IHRoaXMuX3ZhbGlkYXRvcixcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pbnN0cnVjdGlvbnNEYXRhLnB1c2goc3Rha2luZ0FjY291bnREYXRhKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHRoaXMuX3N0YWtpbmdBZGRyZXNzLCAnU3Rha2luZyBBZGRyZXNzIG11c3QgYmUgc2V0IGJlZm9yZSBidWlsZGluZyB0aGUgdHJhbnNhY3Rpb24nKTtcbiAgICAgIGlmICh0aGlzLl9zZW5kZXIgPT09IHRoaXMuX3N0YWtpbmdBZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ1NlbmRlciBhZGRyZXNzIGNhbm5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgU3Rha2luZyBhZGRyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YWtpbmdBY2NvdW50RGF0YTogU3Rha2luZ0RlbGVnYXRlID0ge1xuICAgICAgICB0eXBlOiBJbnN0cnVjdGlvbkJ1aWxkZXJUeXBlcy5TdGFraW5nRGVsZWdhdGUsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGZyb21BZGRyZXNzOiB0aGlzLl9zZW5kZXIsXG4gICAgICAgICAgc3Rha2luZ0FkZHJlc3M6IHRoaXMuX3N0YWtpbmdBZGRyZXNzLFxuICAgICAgICAgIHZhbGlkYXRvcjogdGhpcy5fdmFsaWRhdG9yLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIHRoaXMuX2luc3RydWN0aW9uc0RhdGEgPSBbc3Rha2luZ0FjY291bnREYXRhXTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHN1cGVyLmJ1aWxkSW1wbGVtZW50YXRpb24oKTtcbiAgfVxufVxuIl19