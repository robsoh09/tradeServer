"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StakingActivateBuilder = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const transactionBuilder_1 = require("./transactionBuilder");
const constants_1 = require("./constants");
const assert_1 = __importDefault(require("assert"));
const utils_1 = require("./utils");
class StakingActivateBuilder extends transactionBuilder_1.TransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
    }
    get transactionType() {
        return sdk_core_1.TransactionType.StakingActivate;
    }
    /** @inheritdoc */
    initBuilder(tx) {
        super.initBuilder(tx);
        for (const instruction of this._instructionsData) {
            if (instruction.type === constants_1.InstructionBuilderTypes.StakingActivate) {
                const activateInstruction = instruction;
                this.sender(activateInstruction.params.fromAddress);
                this.stakingAddress(activateInstruction.params.stakingAddress);
                this.amount(activateInstruction.params.amount);
                this.validator(activateInstruction.params.validator);
            }
        }
    }
    /**
     * The amount to stake expressed in Lamports, 1 SOL = 1_000_000_000 lamports.
     *
     * @param {string} amount expressed in Lamports.
     * @returns {StakeBuilder} This staking builder.
     *
     */
    amount(amount) {
        if (!(0, utils_1.isValidStakingAmount)(amount)) {
            throw new sdk_core_1.BuildTransactionError('Value cannot be zero or less');
        }
        this._amount = amount;
        return this;
    }
    /**
     * The address of the staking account.
     *
     * @param {string} stakingAddress public address of the staking account.
     * @returns {StakingActivateBuilder} This staking builder.
     *
     * @see https://docs.solana.com/staking/stake-accounts#account-address
     */
    stakingAddress(stakingAddress) {
        (0, utils_1.validateAddress)(stakingAddress, 'stakingAddress');
        this._stakingAddress = stakingAddress;
        return this;
    }
    /**
     * Set validator address to delegate funds to.
     *
     * @param {string} validator Validator address to delegate funds to.
     * @returns {StakingActivateBuilder} This staking builder.
     *
     */
    validator(validator) {
        (0, utils_1.validateAddress)(validator, 'validator');
        this._validator = validator;
        return this;
    }
    /** @inheritdoc */
    async buildImplementation() {
        (0, assert_1.default)(this._sender, 'Sender must be set before building the transaction');
        (0, assert_1.default)(this._stakingAddress, 'Staking Address must be set before building the transaction');
        (0, assert_1.default)(this._validator, 'Validator must be set before building the transaction');
        (0, assert_1.default)(this._amount, 'Amount must be set before building the transaction');
        if (this._sender === this._stakingAddress) {
            throw new sdk_core_1.BuildTransactionError('Sender address cannot be the same as the Staking address');
        }
        const stakingAccountData = {
            type: constants_1.InstructionBuilderTypes.StakingActivate,
            params: {
                fromAddress: this._sender,
                stakingAddress: this._stakingAddress,
                amount: this._amount,
                validator: this._validator,
            },
        };
        this._instructionsData = [stakingAccountData];
        return await super.buildImplementation();
    }
}
exports.StakingActivateBuilder = StakingActivateBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3Rha2luZ0FjdGl2YXRlQnVpbGRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvc3Rha2luZ0FjdGl2YXRlQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSw4Q0FBeUU7QUFFekUsNkRBQTBEO0FBQzFELDJDQUFzRDtBQUV0RCxvREFBNEI7QUFFNUIsbUNBQWdFO0FBRWhFLE1BQWEsc0JBQXVCLFNBQVEsdUNBQWtCO0lBSzVELFlBQVksV0FBaUM7UUFDM0MsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFFRCxJQUFjLGVBQWU7UUFDM0IsT0FBTywwQkFBZSxDQUFDLGVBQWUsQ0FBQztJQUN6QyxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLFdBQVcsQ0FBQyxFQUFlO1FBQ3pCLEtBQUssQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdEIsS0FBSyxNQUFNLFdBQVcsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDaEQsSUFBSSxXQUFXLENBQUMsSUFBSSxLQUFLLG1DQUF1QixDQUFDLGVBQWUsRUFBRTtnQkFDaEUsTUFBTSxtQkFBbUIsR0FBb0IsV0FBVyxDQUFDO2dCQUN6RCxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDcEQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUM7Z0JBQy9ELElBQUksQ0FBQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUMvQyxJQUFJLENBQUMsU0FBUyxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUN0RDtTQUNGO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILE1BQU0sQ0FBQyxNQUFjO1FBQ25CLElBQUksQ0FBQyxJQUFBLDRCQUFvQixFQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2pDLE1BQU0sSUFBSSxnQ0FBcUIsQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO1NBQ2pFO1FBQ0QsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7UUFDdEIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILGNBQWMsQ0FBQyxjQUFzQjtRQUNuQyxJQUFBLHVCQUFlLEVBQUMsY0FBYyxFQUFFLGdCQUFnQixDQUFDLENBQUM7UUFDbEQsSUFBSSxDQUFDLGVBQWUsR0FBRyxjQUFjLENBQUM7UUFDdEMsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsU0FBUyxDQUFDLFNBQWlCO1FBQ3pCLElBQUEsdUJBQWUsRUFBQyxTQUFTLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDeEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUM7UUFDNUIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsa0JBQWtCO0lBQ1IsS0FBSyxDQUFDLG1CQUFtQjtRQUNqQyxJQUFBLGdCQUFNLEVBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxvREFBb0QsQ0FBQyxDQUFDO1FBQzNFLElBQUEsZ0JBQU0sRUFBQyxJQUFJLENBQUMsZUFBZSxFQUFFLDZEQUE2RCxDQUFDLENBQUM7UUFDNUYsSUFBQSxnQkFBTSxFQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsdURBQXVELENBQUMsQ0FBQztRQUNqRixJQUFBLGdCQUFNLEVBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxvREFBb0QsQ0FBQyxDQUFDO1FBRTNFLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3pDLE1BQU0sSUFBSSxnQ0FBcUIsQ0FBQywwREFBMEQsQ0FBQyxDQUFDO1NBQzdGO1FBRUQsTUFBTSxrQkFBa0IsR0FBb0I7WUFDMUMsSUFBSSxFQUFFLG1DQUF1QixDQUFDLGVBQWU7WUFDN0MsTUFBTSxFQUFFO2dCQUNOLFdBQVcsRUFBRSxJQUFJLENBQUMsT0FBTztnQkFDekIsY0FBYyxFQUFFLElBQUksQ0FBQyxlQUFlO2dCQUNwQyxNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU87Z0JBQ3BCLFNBQVMsRUFBRSxJQUFJLENBQUMsVUFBVTthQUMzQjtTQUNGLENBQUM7UUFDRixJQUFJLENBQUMsaUJBQWlCLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBRTlDLE9BQU8sTUFBTSxLQUFLLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztJQUMzQyxDQUFDO0NBQ0Y7QUE3RkQsd0RBNkZDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IEJ1aWxkVHJhbnNhY3Rpb25FcnJvciwgVHJhbnNhY3Rpb25UeXBlIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbkJ1aWxkZXIgfSBmcm9tICcuL3RyYW5zYWN0aW9uQnVpbGRlcic7XG5pbXBvcnQgeyBJbnN0cnVjdGlvbkJ1aWxkZXJUeXBlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHsgU3Rha2luZ0FjdGl2YXRlIH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBpc1ZhbGlkU3Rha2luZ0Ftb3VudCwgdmFsaWRhdGVBZGRyZXNzIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBTdGFraW5nQWN0aXZhdGVCdWlsZGVyIGV4dGVuZHMgVHJhbnNhY3Rpb25CdWlsZGVyIHtcbiAgcHJvdGVjdGVkIF9hbW91bnQ6IHN0cmluZztcbiAgcHJvdGVjdGVkIF9zdGFraW5nQWRkcmVzczogc3RyaW5nO1xuICBwcm90ZWN0ZWQgX3ZhbGlkYXRvcjogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKF9jb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xuICAgIHN1cGVyKF9jb2luQ29uZmlnKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgdHJhbnNhY3Rpb25UeXBlKCk6IFRyYW5zYWN0aW9uVHlwZSB7XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nQWN0aXZhdGU7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaW5pdEJ1aWxkZXIodHg6IFRyYW5zYWN0aW9uKTogdm9pZCB7XG4gICAgc3VwZXIuaW5pdEJ1aWxkZXIodHgpO1xuICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgdGhpcy5faW5zdHJ1Y3Rpb25zRGF0YSkge1xuICAgICAgaWYgKGluc3RydWN0aW9uLnR5cGUgPT09IEluc3RydWN0aW9uQnVpbGRlclR5cGVzLlN0YWtpbmdBY3RpdmF0ZSkge1xuICAgICAgICBjb25zdCBhY3RpdmF0ZUluc3RydWN0aW9uOiBTdGFraW5nQWN0aXZhdGUgPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgdGhpcy5zZW5kZXIoYWN0aXZhdGVJbnN0cnVjdGlvbi5wYXJhbXMuZnJvbUFkZHJlc3MpO1xuICAgICAgICB0aGlzLnN0YWtpbmdBZGRyZXNzKGFjdGl2YXRlSW5zdHJ1Y3Rpb24ucGFyYW1zLnN0YWtpbmdBZGRyZXNzKTtcbiAgICAgICAgdGhpcy5hbW91bnQoYWN0aXZhdGVJbnN0cnVjdGlvbi5wYXJhbXMuYW1vdW50KTtcbiAgICAgICAgdGhpcy52YWxpZGF0b3IoYWN0aXZhdGVJbnN0cnVjdGlvbi5wYXJhbXMudmFsaWRhdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIGFtb3VudCB0byBzdGFrZSBleHByZXNzZWQgaW4gTGFtcG9ydHMsIDEgU09MID0gMV8wMDBfMDAwXzAwMCBsYW1wb3J0cy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFtb3VudCBleHByZXNzZWQgaW4gTGFtcG9ydHMuXG4gICAqIEByZXR1cm5zIHtTdGFrZUJ1aWxkZXJ9IFRoaXMgc3Rha2luZyBidWlsZGVyLlxuICAgKlxuICAgKi9cbiAgYW1vdW50KGFtb3VudDogc3RyaW5nKTogdGhpcyB7XG4gICAgaWYgKCFpc1ZhbGlkU3Rha2luZ0Ftb3VudChhbW91bnQpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdWYWx1ZSBjYW5ub3QgYmUgemVybyBvciBsZXNzJyk7XG4gICAgfVxuICAgIHRoaXMuX2Ftb3VudCA9IGFtb3VudDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYWRkcmVzcyBvZiB0aGUgc3Rha2luZyBhY2NvdW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2luZ0FkZHJlc3MgcHVibGljIGFkZHJlc3Mgb2YgdGhlIHN0YWtpbmcgYWNjb3VudC5cbiAgICogQHJldHVybnMge1N0YWtpbmdBY3RpdmF0ZUJ1aWxkZXJ9IFRoaXMgc3Rha2luZyBidWlsZGVyLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3N0YWtpbmcvc3Rha2UtYWNjb3VudHMjYWNjb3VudC1hZGRyZXNzXG4gICAqL1xuICBzdGFraW5nQWRkcmVzcyhzdGFraW5nQWRkcmVzczogc3RyaW5nKTogdGhpcyB7XG4gICAgdmFsaWRhdGVBZGRyZXNzKHN0YWtpbmdBZGRyZXNzLCAnc3Rha2luZ0FkZHJlc3MnKTtcbiAgICB0aGlzLl9zdGFraW5nQWRkcmVzcyA9IHN0YWtpbmdBZGRyZXNzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB2YWxpZGF0b3IgYWRkcmVzcyB0byBkZWxlZ2F0ZSBmdW5kcyB0by5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvciBWYWxpZGF0b3IgYWRkcmVzcyB0byBkZWxlZ2F0ZSBmdW5kcyB0by5cbiAgICogQHJldHVybnMge1N0YWtpbmdBY3RpdmF0ZUJ1aWxkZXJ9IFRoaXMgc3Rha2luZyBidWlsZGVyLlxuICAgKlxuICAgKi9cbiAgdmFsaWRhdG9yKHZhbGlkYXRvcjogc3RyaW5nKTogdGhpcyB7XG4gICAgdmFsaWRhdGVBZGRyZXNzKHZhbGlkYXRvciwgJ3ZhbGlkYXRvcicpO1xuICAgIHRoaXMuX3ZhbGlkYXRvciA9IHZhbGlkYXRvcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgYnVpbGRJbXBsZW1lbnRhdGlvbigpOiBQcm9taXNlPFRyYW5zYWN0aW9uPiB7XG4gICAgYXNzZXJ0KHRoaXMuX3NlbmRlciwgJ1NlbmRlciBtdXN0IGJlIHNldCBiZWZvcmUgYnVpbGRpbmcgdGhlIHRyYW5zYWN0aW9uJyk7XG4gICAgYXNzZXJ0KHRoaXMuX3N0YWtpbmdBZGRyZXNzLCAnU3Rha2luZyBBZGRyZXNzIG11c3QgYmUgc2V0IGJlZm9yZSBidWlsZGluZyB0aGUgdHJhbnNhY3Rpb24nKTtcbiAgICBhc3NlcnQodGhpcy5fdmFsaWRhdG9yLCAnVmFsaWRhdG9yIG11c3QgYmUgc2V0IGJlZm9yZSBidWlsZGluZyB0aGUgdHJhbnNhY3Rpb24nKTtcbiAgICBhc3NlcnQodGhpcy5fYW1vdW50LCAnQW1vdW50IG11c3QgYmUgc2V0IGJlZm9yZSBidWlsZGluZyB0aGUgdHJhbnNhY3Rpb24nKTtcblxuICAgIGlmICh0aGlzLl9zZW5kZXIgPT09IHRoaXMuX3N0YWtpbmdBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdTZW5kZXIgYWRkcmVzcyBjYW5ub3QgYmUgdGhlIHNhbWUgYXMgdGhlIFN0YWtpbmcgYWRkcmVzcycpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YWtpbmdBY2NvdW50RGF0YTogU3Rha2luZ0FjdGl2YXRlID0ge1xuICAgICAgdHlwZTogSW5zdHJ1Y3Rpb25CdWlsZGVyVHlwZXMuU3Rha2luZ0FjdGl2YXRlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGZyb21BZGRyZXNzOiB0aGlzLl9zZW5kZXIsXG4gICAgICAgIHN0YWtpbmdBZGRyZXNzOiB0aGlzLl9zdGFraW5nQWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiB0aGlzLl9hbW91bnQsXG4gICAgICAgIHZhbGlkYXRvcjogdGhpcy5fdmFsaWRhdG9yLFxuICAgICAgfSxcbiAgICB9O1xuICAgIHRoaXMuX2luc3RydWN0aW9uc0RhdGEgPSBbc3Rha2luZ0FjY291bnREYXRhXTtcblxuICAgIHJldHVybiBhd2FpdCBzdXBlci5idWlsZEltcGxlbWVudGF0aW9uKCk7XG4gIH1cbn1cbiJdfQ==