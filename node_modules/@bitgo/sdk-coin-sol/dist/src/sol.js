"use strict";
/**
 * @prettier
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sol = exports.DEFAULT_SCAN_FACTOR = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const base58 = __importStar(require("bs58"));
const sdk_core_1 = require("@bitgo/sdk-core");
const sdk_lib_mpc_1 = require("@bitgo/sdk-lib-mpc");
const statics_1 = require("@bitgo/statics");
const _ = __importStar(require("lodash"));
const request = __importStar(require("superagent"));
const lib_1 = require("./lib");
const utils_1 = require("./lib/utils");
exports.DEFAULT_SCAN_FACTOR = 20; // default number of receive addresses to scan for funds
const HEX_REGEX = /^[0-9a-fA-F]+$/;
class Sol extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new Sol(bitgo, staticsCoin);
    }
    allowsAccountConsolidations() {
        return true;
    }
    supportsTss() {
        return true;
    }
    getMPCAlgorithm() {
        return 'eddsa';
    }
    getChain() {
        return this._staticsCoin.name;
    }
    getFamily() {
        return this._staticsCoin.family;
    }
    getFullName() {
        return this._staticsCoin.fullName;
    }
    getNetwork() {
        return this._staticsCoin.network;
    }
    getBaseFactor() {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    }
    async verifyTransaction(params) {
        var _a, _b;
        // asset name to transfer amount map
        const totalAmount = {};
        const coinConfig = statics_1.coins.get(this.getChain());
        const { txParams: txParams, txPrebuild: txPrebuild, memo: memo, durableNonce: durableNonce } = params;
        const transaction = new lib_1.Transaction(coinConfig);
        const rawTx = txPrebuild.txBase64 || txPrebuild.txHex;
        const consolidateId = txPrebuild.consolidateId;
        const walletRootAddress = (_a = params.wallet.coinSpecific()) === null || _a === void 0 ? void 0 : _a.rootAddress;
        if (!rawTx) {
            throw new Error('missing required tx prebuild property txBase64 or txHex');
        }
        let rawTxBase64 = rawTx;
        if (HEX_REGEX.test(rawTx)) {
            rawTxBase64 = Buffer.from(rawTx, 'hex').toString('base64');
        }
        transaction.fromRawTransaction(rawTxBase64);
        const explainedTx = transaction.explainTransaction();
        // users do not input recipients for consolidation requests as they are generated by the server
        if (txParams.recipients !== undefined) {
            const filteredRecipients = (_b = txParams.recipients) === null || _b === void 0 ? void 0 : _b.map((recipient) => _.pick(recipient, ['address', 'amount', 'tokenName']));
            const filteredOutputs = explainedTx.outputs.map((output) => _.pick(output, ['address', 'amount', 'tokenName']));
            if (filteredRecipients.length !== filteredOutputs.length) {
                throw new Error('Number of tx outputs does not match with number of txParams recipients');
            }
            // For each recipient, check if it's a token tx (tokenName will exist if so)
            // If it is a token tx, verify that the recipient address equals the derived address from explainedTx
            // Derive the ATA if it is a native address and confirm it is equal to the explained tx recipient
            const recipientChecks = await Promise.all(filteredRecipients.map(async (recipientFromUser, index) => {
                const recipientFromTx = filteredOutputs[index]; // This address should be an ATA
                // Compare the BigNumber values because amount is (string | number)
                const userAmount = new bignumber_js_1.default(recipientFromUser.amount);
                const txAmount = new bignumber_js_1.default(recipientFromTx.amount);
                if (!userAmount.isEqualTo(txAmount)) {
                    return false;
                }
                // Compare the addresses and tokenNames
                // Else if the addresses are not the same, check the derived ATA for parity
                if (recipientFromUser.address === recipientFromTx.address &&
                    recipientFromUser.tokenName === recipientFromTx.tokenName) {
                    return true;
                }
                else if (recipientFromUser.address !== recipientFromTx.address && recipientFromUser.tokenName) {
                    // Try to check if the user's derived ATA is equal to the tx recipient address
                    // If getAssociatedTokenAccountAddress throws an error, then we are unable to derive the ATA for that address.
                    // Return false and throw an error if that is the case.
                    try {
                        const tokenMintAddress = (0, utils_1.getSolTokenFromTokenName)(recipientFromUser.tokenName);
                        return (0, utils_1.getAssociatedTokenAccountAddress)(tokenMintAddress.tokenAddress, recipientFromUser.address).then((ata) => {
                            return ata === recipientFromTx.address;
                        });
                    }
                    catch {
                        // Unable to derive ATA
                        return false;
                    }
                }
                return false;
            }));
            if (recipientChecks.includes(false)) {
                throw new Error('Tx outputs does not match with expected txParams recipients');
            }
        }
        const transactionJson = transaction.toJson();
        if (memo && memo.value !== explainedTx.memo) {
            throw new Error('Tx memo does not match with expected txParams recipient memo');
        }
        if (txParams.recipients) {
            for (const recipients of txParams.recipients) {
                // totalAmount based on each token
                const assetName = recipients.tokenName || this.getChain();
                const amount = totalAmount[assetName] || new bignumber_js_1.default(0);
                totalAmount[assetName] = amount.plus(recipients.amount);
            }
            // total output amount from explainedTx
            const explainedTxTotal = {};
            for (const output of explainedTx.outputs) {
                // total output amount based on each token
                const assetName = output.tokenName || this.getChain();
                const amount = explainedTxTotal[assetName] || new bignumber_js_1.default(0);
                explainedTxTotal[assetName] = amount.plus(output.amount);
            }
            if (!_.isEqual(explainedTxTotal, totalAmount)) {
                throw new Error('Tx total amount does not match with expected total amount field');
            }
        }
        // For non-consolidate transactions, feePayer must be the wallet's root address
        if (consolidateId === undefined && transactionJson.feePayer !== walletRootAddress) {
            throw new Error('Tx fee payer is not the wallet root address');
        }
        if (durableNonce && !_.isEqual(explainedTx.durableNonce, durableNonce)) {
            throw new Error('Tx durableNonce does not match with param durableNonce');
        }
        return true;
    }
    async isWalletAddress(params) {
        throw new sdk_core_1.MethodNotImplementedError();
    }
    /**
     * Generate Solana key pair
     *
     * @param {Buffer} seed - Seed from which the new SolKeyPair should be generated, otherwise a random seed is used
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed) {
        const result = seed ? new lib_1.KeyPair({ seed }).getKeys() : new lib_1.KeyPair().getKeys();
        return result;
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {string} pub the prv to be checked
     * @returns is it valid?
     */
    isValidPub(pub) {
        return (0, utils_1.isValidPublicKey)(pub);
    }
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param {string} prv the prv to be checked
     * @returns is it valid?
     */
    isValidPrv(prv) {
        return (0, utils_1.isValidPrivateKey)(prv);
    }
    isValidAddress(address) {
        return (0, utils_1.isValidAddress)(address);
    }
    async signMessage(key, message) {
        const solKeypair = new lib_1.KeyPair({ prv: key.prv });
        if (Buffer.isBuffer(message)) {
            message = base58.encode(message);
        }
        return Buffer.from(solKeypair.signMessage(message));
    }
    /**
     * Signs Solana transaction
     * @param params
     * @param callback
     */
    async signTransaction(params) {
        const factory = this.getBuilder();
        const rawTx = params.txPrebuild.txHex || params.txPrebuild.txBase64;
        const txBuilder = factory.from(rawTx);
        txBuilder.sign({ key: params.prv });
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new Error('Invalid transaction');
        }
        const serializedTx = transaction.toBroadcastFormat();
        return {
            txHex: serializedTx,
        };
    }
    async parseTransaction(params) {
        const transactionExplanation = await this.explainTransaction({
            txBase64: params.txBase64,
            feeInfo: params.feeInfo,
            tokenAccountRentExemptAmount: params.tokenAccountRentExemptAmount,
        });
        if (!transactionExplanation) {
            throw new Error('Invalid transaction');
        }
        const solTransaction = transactionExplanation;
        if (solTransaction.outputs.length <= 0) {
            return {
                inputs: [],
                outputs: [],
            };
        }
        const senderAddress = solTransaction.outputs[0].address;
        const feeAmount = new bignumber_js_1.default(solTransaction.fee.fee);
        // assume 1 sender, who is also the fee payer
        const inputs = [
            {
                address: senderAddress,
                amount: new bignumber_js_1.default(solTransaction.outputAmount).plus(feeAmount).toNumber(),
            },
        ];
        const outputs = solTransaction.outputs.map(({ address, amount, tokenName }) => {
            const output = { address, amount };
            if (tokenName) {
                output.tokenName = tokenName;
            }
            return output;
        });
        return {
            inputs,
            outputs,
        };
    }
    /**
     * Explain a Solana transaction from txBase64
     * @param params
     */
    async explainTransaction(params) {
        const factory = this.getBuilder();
        let rebuiltTransaction;
        try {
            const transactionBuilder = factory.from(params.txBase64);
            if (transactionBuilder instanceof lib_1.TransactionBuilder) {
                const txBuilder = transactionBuilder;
                txBuilder.fee({ amount: params.feeInfo.fee });
                if (params.tokenAccountRentExemptAmount) {
                    txBuilder.associatedTokenAccountRent(params.tokenAccountRentExemptAmount);
                }
            }
            rebuiltTransaction = await transactionBuilder.build();
        }
        catch (e) {
            console.log(e);
            throw new Error('Invalid transaction');
        }
        const explainedTransaction = rebuiltTransaction.explainTransaction();
        return explainedTransaction;
    }
    /** @inheritDoc */
    async getSignablePayload(serializedTx) {
        const factory = this.getBuilder();
        const rebuiltTransaction = await factory.from(serializedTx).build();
        return rebuiltTransaction.signablePayload;
    }
    /** @inheritDoc */
    async presignTransaction(params) {
        var _a, _b, _c;
        // Hot wallet txns are only valid for 1-2 minutes.
        // To buy more time, we rebuild the transaction with a new blockhash right before we sign.
        if (params.walletData.type !== 'hot') {
            return Promise.resolve(params);
        }
        const txRequestId = (_a = params.txPrebuild) === null || _a === void 0 ? void 0 : _a.txRequestId;
        if (txRequestId === undefined) {
            throw new Error('Missing txRequestId');
        }
        const { tssUtils } = params;
        await tssUtils.deleteSignatureShares(txRequestId);
        const recreated = await tssUtils.getTxRequest(txRequestId);
        let txHex = '';
        if (recreated.unsignedTxs) {
            txHex = (_b = recreated.unsignedTxs[0]) === null || _b === void 0 ? void 0 : _b.serializedTxHex;
        }
        else {
            txHex = recreated.transactions ? (_c = recreated.transactions[0]) === null || _c === void 0 ? void 0 : _c.unsignedTx.serializedTxHex : '';
        }
        if (!txHex) {
            throw new Error('Missing serialized tx hex');
        }
        return Promise.resolve({
            ...params,
            txPrebuild: recreated,
            txHex,
        });
    }
    getPublicNodeUrl() {
        return sdk_core_1.Environments[this.bitgo.getEnv()].solNodeUrl;
    }
    /**
     * Make a request to one of the public SOL nodes available
     * @param params.payload
     */
    async getDataFromNode(params) {
        const nodeUrl = this.getPublicNodeUrl();
        try {
            return await request.post(nodeUrl).send(params.payload);
        }
        catch (e) {
            console.debug(e);
        }
        throw new Error(`Unable to call endpoint: '/' from node: ${nodeUrl}`);
    }
    async getBlockhash() {
        const response = await this.getDataFromNode({
            payload: {
                id: '1',
                jsonrpc: '2.0',
                method: 'getLatestBlockhash',
                params: [
                    {
                        commitment: 'finalized',
                    },
                ],
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return response.body.result.value.blockhash;
    }
    /** TODO Update to getFeeForMessage and make necssary changes in fee calculation, GetFees is deprecated */
    async getFees() {
        const response = await this.getDataFromNode({
            payload: {
                id: '1',
                jsonrpc: '2.0',
                method: 'getFees',
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return response.body.result.value.feeCalculator.lamportsPerSignature;
    }
    async getRentExemptAmount() {
        const response = await this.getDataFromNode({
            payload: {
                jsonrpc: '2.0',
                id: '1',
                method: 'getMinimumBalanceForRentExemption',
                params: [165],
            },
        });
        if (response.status !== 200 || response.error) {
            throw new Error(JSON.stringify(response.error));
        }
        return response.body.result;
    }
    async getAccountBalance(pubKey) {
        const response = await this.getDataFromNode({
            payload: {
                id: '1',
                jsonrpc: '2.0',
                method: 'getBalance',
                params: [pubKey],
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return response.body.result.value;
    }
    async getAccountInfo(pubKey) {
        const response = await this.getDataFromNode({
            payload: {
                id: '1',
                jsonrpc: '2.0',
                method: 'getAccountInfo',
                params: [
                    pubKey,
                    {
                        encoding: 'jsonParsed',
                    },
                ],
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return {
            authority: response.body.result.value.data.parsed.info.authority,
            blockhash: response.body.result.value.data.parsed.info.blockhash,
        };
    }
    async getTokenAccountsByOwner(pubKey = '') {
        const response = await this.getDataFromNode({
            payload: {
                id: '1',
                jsonrpc: '2.0',
                method: 'getTokenAccountsByOwner',
                params: [
                    pubKey,
                    {
                        programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
                    },
                    {
                        encoding: 'jsonParsed',
                    },
                ],
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        if (response.body.result.value.length !== 0) {
            const tokenAccounts = [];
            for (const tokenAccount of response.body.result.value) {
                tokenAccounts.push({ info: tokenAccount.account.data.parsed.info, pubKey: tokenAccount.pubKey });
            }
            return tokenAccounts;
        }
        return [];
    }
    /**
     * Creates funds sweep recovery transaction(s) without BitGo
     *
     * @param {SweepRecoveryOptions} params parameters needed to combine the signatures
     * and transactions to create broadcastable transactions
     *
     * @returns {MPCTxs} array of the serialized transaction hex strings and indices
     * of the addresses being swept
     */
    async createBroadcastableSweepTransaction(params) {
        var _a;
        if (!params.signatureShares) {
            ('Missing transaction(s)');
        }
        const req = params.signatureShares;
        const broadcastableTransactions = [];
        let lastScanIndex = 0;
        for (let i = 0; i < req.length; i++) {
            const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
            const transaction = req[i].txRequest.transactions[0].unsignedTx;
            if (!req[i].ovc || !req[i].ovc[0].eddsaSignature) {
                throw new Error('Missing signature(s)');
            }
            const signature = req[i].ovc[0].eddsaSignature;
            if (!transaction.signableHex) {
                throw new Error('Missing signable hex');
            }
            const messageBuffer = Buffer.from(transaction.signableHex, 'hex');
            const result = MPC.verify(messageBuffer, signature);
            if (!result) {
                throw new Error('Invalid signature');
            }
            const signatureHex = Buffer.concat([Buffer.from(signature.R, 'hex'), Buffer.from(signature.sigma, 'hex')]);
            const txBuilder = this.getBuilder().from(transaction.serializedTx);
            if (!((_a = transaction.coinSpecific) === null || _a === void 0 ? void 0 : _a.commonKeychain)) {
                throw new Error('Missing common keychain');
            }
            const commonKeychain = transaction.coinSpecific.commonKeychain;
            if (!transaction.derivationPath) {
                throw new Error('Missing derivation path');
            }
            const derivationPath = transaction.derivationPath;
            const accountId = MPC.deriveUnhardened(commonKeychain, derivationPath).slice(0, 64);
            const bs58EncodedPublicKey = new lib_1.KeyPair({ pub: accountId }).getAddress();
            // add combined signature from ovc
            const publicKeyObj = { pub: bs58EncodedPublicKey };
            txBuilder.addSignature(publicKeyObj, signatureHex);
            const signedTransaction = await txBuilder.build();
            const serializedTx = signedTransaction.toBroadcastFormat();
            broadcastableTransactions.push({
                serializedTx: serializedTx,
                scanIndex: transaction.scanIndex,
            });
            if (i === req.length - 1 && transaction.coinSpecific.lastScanIndex) {
                lastScanIndex = transaction.coinSpecific.lastScanIndex;
            }
        }
        return { transactions: broadcastableTransactions, lastScanIndex };
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param {SolRecoveryOptions} params parameters needed to construct and
     * (maybe) sign the transaction
     *
     * @returns {MPCTx | MPCSweepTxs} the serialized transaction hex string and index
     * of the address being swept
     */
    async recover(params) {
        if (!params.bitgoKey) {
            throw new Error('missing bitgoKey');
        }
        if (!params.recoveryDestination || !this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination');
        }
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        const isUnsignedSweep = !params.userKey && !params.backupKey && !params.walletPassphrase;
        // Build the transaction
        const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
        let balance = 0;
        const feePerSignature = await this.getFees();
        const baseFee = params.durableNonce ? feePerSignature * 2 : feePerSignature;
        let totalFee = new bignumber_js_1.default(baseFee);
        const index = params.index || 0;
        const currPath = params.seed ? (0, sdk_lib_mpc_1.getDerivationPath)(params.seed) + `/${index}` : `m/${index}`;
        const accountId = MPC.deriveUnhardened(bitgoKey, currPath).slice(0, 64);
        const bs58EncodedPublicKey = new lib_1.KeyPair({ pub: accountId }).getAddress();
        balance = await this.getAccountBalance(bs58EncodedPublicKey);
        if (totalFee.gt(balance)) {
            throw Error('Did not find address with funds to recover');
        }
        const factory = this.getBuilder();
        const walletCoin = this.getChain();
        let txBuilder;
        let blockhash = await this.getBlockhash();
        let rentExemptAmount;
        let authority = '';
        // if this is closeATA recovery
        if (params.closeAtaAddress) {
            if (!params.closeAtaAddress || !this.isValidAddress(params.closeAtaAddress)) {
                throw new Error('invalid closeAtaAddress');
            }
            balance = await this.getAccountBalance(params.closeAtaAddress);
            if (balance <= 0) {
                throw Error('Did not find closeAtaAddress with sol funds to recover');
            }
            rentExemptAmount = await this.getRentExemptAmount();
            const ataCloseBuilder = () => {
                var _a;
                const txBuilder = factory.getCloseAtaInitializationBuilder();
                txBuilder.nonce(blockhash);
                txBuilder.sender(bs58EncodedPublicKey);
                txBuilder.accountAddress((_a = params.closeAtaAddress) !== null && _a !== void 0 ? _a : '');
                txBuilder.destinationAddress(params.recoveryDestination);
                txBuilder.authorityAddress(bs58EncodedPublicKey);
                txBuilder.associatedTokenAccountRent(rentExemptAmount.toString());
                return txBuilder;
            };
            txBuilder = ataCloseBuilder();
        }
        if (params.durableNonce) {
            const durableNonceInfo = await this.getAccountInfo(params.durableNonce.publicKey);
            blockhash = durableNonceInfo.blockhash;
            authority = durableNonceInfo.authority;
        }
        // check for possible token recovery, recover the token provide by user
        if (params.tokenContractAddress) {
            const tokenAccounts = await this.getTokenAccountsByOwner(bs58EncodedPublicKey);
            if (tokenAccounts.length !== 0) {
                // there exists token accounts on the given address, but need to check certain conditions:
                // 1. if there is a recoverable balance
                // 2. if the token is supported by bitgo
                const recovereableTokenAccounts = [];
                for (const tokenAccount of tokenAccounts) {
                    if (params.tokenContractAddress === tokenAccount.info.mint) {
                        const tokenAmount = new bignumber_js_1.default(tokenAccount.info.tokenAmount.amount);
                        const network = this.getNetwork();
                        const token = (0, utils_1.getSolTokenFromAddress)(tokenAccount.info.mint, network);
                        if (!_.isUndefined(token) && tokenAmount.gt(new bignumber_js_1.default(0))) {
                            tokenAccount.tokenName = token.name;
                            recovereableTokenAccounts.push(tokenAccount);
                        }
                        break;
                    }
                }
                if (recovereableTokenAccounts.length !== 0) {
                    rentExemptAmount = await this.getRentExemptAmount();
                    txBuilder = factory
                        .getTokenTransferBuilder()
                        .nonce(blockhash)
                        .sender(bs58EncodedPublicKey)
                        .fee({ amount: feePerSignature })
                        .associatedTokenAccountRent(rentExemptAmount.toString())
                        .feePayer(bs58EncodedPublicKey);
                    // need to get all token accounts of the recipient address and need to create them if they do not exist
                    const recipientTokenAccounts = await this.getTokenAccountsByOwner(params.recoveryDestination);
                    for (const tokenAccount of recovereableTokenAccounts) {
                        let recipientTokenAccountExists = false;
                        for (const recipientTokenAccount of recipientTokenAccounts) {
                            if (recipientTokenAccount.info.mint === tokenAccount.info.mint) {
                                recipientTokenAccountExists = true;
                                break;
                            }
                        }
                        const recipientTokenAccount = await (0, utils_1.getAssociatedTokenAccountAddress)(tokenAccount.info.mint, params.recoveryDestination);
                        const tokenName = tokenAccount.tokenName;
                        txBuilder.send({
                            address: recipientTokenAccount,
                            amount: tokenAccount.info.tokenAmount.amount,
                            tokenName: tokenName,
                        });
                        if (!recipientTokenAccountExists) {
                            // recipient token account does not exist for token and must be created
                            txBuilder.createAssociatedTokenAccount({
                                ownerAddress: params.recoveryDestination,
                                tokenName: tokenName,
                            });
                            // add rent exempt amount to total fee for each token account that has to be created
                            totalFee = totalFee.plus(rentExemptAmount);
                        }
                    }
                    // there are recoverable token accounts, need to check if there is sufficient native solana to recover tokens
                    if (new bignumber_js_1.default(balance).lt(totalFee)) {
                        throw Error('Not enough funds to pay for recover tokens fees, have: ' + balance + ' need: ' + totalFee.toString());
                    }
                }
                else {
                    throw Error('Not enough token funds to recover');
                }
            }
            else {
                // there are no recoverable token accounts , need to check if there are tokens to recover
                throw Error('Did not find token account to recover tokens, please check token account');
            }
        }
        else {
            const netAmount = new bignumber_js_1.default(balance).minus(totalFee);
            txBuilder = factory
                .getTransferBuilder()
                .nonce(blockhash)
                .sender(bs58EncodedPublicKey)
                .send({ address: params.recoveryDestination, amount: netAmount.toString() })
                .fee({ amount: feePerSignature })
                .feePayer(bs58EncodedPublicKey);
        }
        if (params.durableNonce) {
            txBuilder.nonce(blockhash, {
                walletNonceAddress: params.durableNonce.publicKey,
                authWalletAddress: authority,
            });
        }
        if (!isUnsignedSweep) {
            // Sign the txn
            if (!params.userKey) {
                throw new Error('missing userKey');
            }
            if (!params.backupKey) {
                throw new Error('missing backupKey');
            }
            if (!params.walletPassphrase) {
                throw new Error('missing wallet passphrase');
            }
            const unsignedTransaction = (await txBuilder.build());
            const userKey = params.userKey.replace(/\s/g, '');
            const backupKey = params.backupKey.replace(/\s/g, '');
            // Decrypt private keys from KeyCard values
            let userPrv;
            try {
                userPrv = this.bitgo.decrypt({
                    input: userKey,
                    password: params.walletPassphrase,
                });
            }
            catch (e) {
                throw new Error(`Error decrypting user keychain: ${e.message}`);
            }
            const userSigningMaterial = JSON.parse(userPrv);
            let backupPrv;
            try {
                backupPrv = this.bitgo.decrypt({
                    input: backupKey,
                    password: params.walletPassphrase,
                });
            }
            catch (e) {
                throw new Error(`Error decrypting backup keychain: ${e.message}`);
            }
            const backupSigningMaterial = JSON.parse(backupPrv);
            const signatureHex = await sdk_core_1.EDDSAMethods.getTSSSignature(userSigningMaterial, backupSigningMaterial, currPath, unsignedTransaction);
            const publicKeyObj = { pub: bs58EncodedPublicKey };
            txBuilder.addSignature(publicKeyObj, signatureHex);
        }
        if (params.durableNonce) {
            // add durable nonce account signature
            txBuilder.sign({ key: params.durableNonce.secretKey });
        }
        const completedTransaction = await txBuilder.build();
        const serializedTx = completedTransaction.toBroadcastFormat();
        const derivationPath = params.seed ? (0, sdk_lib_mpc_1.getDerivationPath)(params.seed) + `/${index}` : `m/${index}`;
        const inputs = [];
        for (const input of completedTransaction.inputs) {
            inputs.push({
                address: input.address,
                valueString: input.value,
                value: new bignumber_js_1.default(input.value).toNumber(),
            });
        }
        const outputs = [];
        for (const output of completedTransaction.outputs) {
            outputs.push({
                address: output.address,
                valueString: output.value,
                coinName: output.coin ? output.coin : walletCoin,
            });
        }
        const spendAmount = completedTransaction.inputs.length === 1 ? completedTransaction.inputs[0].value : 0;
        const parsedTx = { inputs: inputs, outputs: outputs, spendAmount: spendAmount, type: '' };
        const feeInfo = { fee: totalFee.toNumber(), feeString: totalFee.toString() };
        const coinSpecific = { commonKeychain: bitgoKey };
        if (isUnsignedSweep) {
            const transaction = {
                serializedTx: serializedTx,
                scanIndex: index,
                coin: walletCoin,
                signableHex: completedTransaction.signablePayload.toString('hex'),
                derivationPath: derivationPath,
                parsedTx: parsedTx,
                feeInfo: feeInfo,
                coinSpecific: coinSpecific,
            };
            const unsignedTx = { unsignedTx: transaction, signatureShares: [] };
            const transactions = [unsignedTx];
            const txRequest = {
                transactions: transactions,
                walletCoin: walletCoin,
            };
            const txRequests = { txRequests: [txRequest] };
            return txRequests;
        }
        const transaction = {
            serializedTx: serializedTx,
            scanIndex: index,
        };
        return transaction;
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param {SolRecoveryOptions} params parameters needed to construct and
     * (maybe) sign the transaction
     *
     * @returns {MPCTx | MPCSweepTxs} the serialized transaction hex string and index
     * of the address being swept
     */
    async recoverCloseATA(params) {
        if (!params.bitgoKey) {
            throw new Error('missing bitgoKey');
        }
        if (!params.recoveryDestination || !this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination');
        }
        if (!params.closeAtaAddress || !this.isValidAddress(params.closeAtaAddress)) {
            throw new Error('invalid closeAtaAddress');
        }
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        const isUnsignedSweep = !params.userKey && !params.backupKey && !params.walletPassphrase;
        // Build the transaction
        const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
        let balance = 0;
        const feePerSignature = await this.getFees();
        const baseFee = params.durableNonce ? feePerSignature * 2 : feePerSignature;
        const totalFee = new bignumber_js_1.default(baseFee);
        const index = params.index || 0;
        const currPath = params.seed ? (0, sdk_lib_mpc_1.getDerivationPath)(params.seed) + `/${index}` : `m/${index}`;
        const accountId = MPC.deriveUnhardened(bitgoKey, currPath).slice(0, 64);
        const bs58EncodedPublicKey = new lib_1.KeyPair({ pub: accountId }).getAddress();
        balance = await this.getAccountBalance(bs58EncodedPublicKey);
        if (totalFee.gt(balance)) {
            throw Error('Did not find address with funds to recover');
        }
        balance = await this.getAccountBalance(params.closeAtaAddress);
        if (balance <= 0) {
            throw Error('Did not find closeAtaAddress with sol funds to recover');
        }
        const factory = this.getBuilder();
        const walletCoin = this.getChain();
        let txBuilder;
        const blockhash = await this.getBlockhash();
        const rentExemptAmount = await this.getRentExemptAmount();
        // if this is closeATA recovery
        if (params.closeAtaAddress) {
            const ataCloseBuilder = () => {
                var _a;
                const txBuilder = factory.getCloseAtaInitializationBuilder();
                txBuilder.nonce(blockhash);
                txBuilder.sender(bs58EncodedPublicKey);
                txBuilder.accountAddress((_a = params.closeAtaAddress) !== null && _a !== void 0 ? _a : '');
                txBuilder.destinationAddress(params.recoveryDestination);
                txBuilder.authorityAddress(bs58EncodedPublicKey);
                txBuilder.associatedTokenAccountRent(rentExemptAmount.toString());
                return txBuilder;
            };
            txBuilder = ataCloseBuilder();
        }
        if (!isUnsignedSweep) {
            // Sign the txn
            if (!params.userKey) {
                throw new Error('missing userKey');
            }
            if (!params.backupKey) {
                throw new Error('missing backupKey');
            }
            if (!params.walletPassphrase) {
                throw new Error('missing wallet passphrase');
            }
            const unsignedTransaction = (await txBuilder.build());
            const userKey = params.userKey.replace(/\s/g, '');
            const backupKey = params.backupKey.replace(/\s/g, '');
            // Decrypt private keys from KeyCard values
            let userPrv;
            try {
                userPrv = this.bitgo.decrypt({
                    input: userKey,
                    password: params.walletPassphrase,
                });
            }
            catch (e) {
                throw new Error(`Error decrypting user keychain: ${e.message}`);
            }
            const userSigningMaterial = JSON.parse(userPrv);
            let backupPrv;
            try {
                backupPrv = this.bitgo.decrypt({
                    input: backupKey,
                    password: params.walletPassphrase,
                });
            }
            catch (e) {
                throw new Error(`Error decrypting backup keychain: ${e.message}`);
            }
            const backupSigningMaterial = JSON.parse(backupPrv);
            const signatureHex = await sdk_core_1.EDDSAMethods.getTSSSignature(userSigningMaterial, backupSigningMaterial, currPath, unsignedTransaction);
            const publicKeyObj = { pub: bs58EncodedPublicKey };
            txBuilder.addSignature(publicKeyObj, signatureHex);
        }
        const completedTransaction = await txBuilder.build();
        const serializedTx = completedTransaction.toBroadcastFormat();
        const derivationPath = params.seed ? (0, sdk_lib_mpc_1.getDerivationPath)(params.seed) + `/${index}` : `m/${index}`;
        const inputs = [];
        for (const input of completedTransaction.inputs) {
            inputs.push({
                address: input.address,
                valueString: input.value,
                value: new bignumber_js_1.default(input.value).toNumber(),
            });
        }
        const outputs = [];
        for (const output of completedTransaction.outputs) {
            outputs.push({
                address: output.address,
                valueString: output.value,
                coinName: output.coin ? output.coin : walletCoin,
            });
        }
        const spendAmount = completedTransaction.inputs.length === 1 ? completedTransaction.inputs[0].value : 0;
        const parsedTx = { inputs: inputs, outputs: outputs, spendAmount: spendAmount, type: '' };
        const feeInfo = { fee: totalFee.toNumber(), feeString: totalFee.toString() };
        const coinSpecific = { commonKeychain: bitgoKey };
        if (isUnsignedSweep) {
            const transaction = {
                serializedTx: serializedTx,
                scanIndex: index,
                coin: walletCoin,
                signableHex: completedTransaction.signablePayload.toString('hex'),
                derivationPath: derivationPath,
                parsedTx: parsedTx,
                feeInfo: feeInfo,
                coinSpecific: coinSpecific,
            };
            const unsignedTx = { unsignedTx: transaction, signatureShares: [] };
            const transactions = [unsignedTx];
            const txRequest = {
                transactions: transactions,
                walletCoin: walletCoin,
            };
            const txRequests = { txRequests: [txRequest] };
            return txRequests;
        }
        const transaction = {
            serializedTx: serializedTx,
            scanIndex: index,
        };
        return transaction;
    }
    /**
     * Builds native SOL recoveries of receive addresses in batch without BitGo.
     * Funds will be recovered to base address first. You need to initiate another sweep txn after that.
     *
     * @param {SolConsolidationRecoveryOptions} params - options for consolidation recovery.
     * @param {string} [params.startingScanIndex] - receive address index to start scanning from. default to 1 (inclusive).
     * @param {string} [params.endingScanIndex] - receive address index to end scanning at. default to startingScanIndex + 20 (exclusive).
     */
    async recoverConsolidations(params) {
        const isUnsignedSweep = !params.userKey && !params.backupKey && !params.walletPassphrase;
        const startIdx = params.startingScanIndex || 1;
        const endIdx = params.endingScanIndex || startIdx + exports.DEFAULT_SCAN_FACTOR;
        if (startIdx < 1 || endIdx <= startIdx || endIdx - startIdx > 10 * exports.DEFAULT_SCAN_FACTOR) {
            throw new Error(`Invalid starting or ending index to scan for addresses. startingScanIndex: ${startIdx}, endingScanIndex: ${endIdx}.`);
        }
        // validate durable nonces array
        if (!params.durableNonces) {
            throw new Error('Missing durable nonces');
        }
        if (!params.durableNonces.publicKeys) {
            throw new Error('Invalid durable nonces: missing public keys');
        }
        if (!params.durableNonces.secretKey) {
            throw new Error('Invalid durable nonces array: missing secret key');
        }
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
        const baseAddressIndex = 0;
        const baseAddressPath = params.seed
            ? (0, sdk_lib_mpc_1.getDerivationPath)(params.seed) + `/${baseAddressIndex}`
            : `m/${baseAddressIndex}`;
        const accountId = MPC.deriveUnhardened(bitgoKey, baseAddressPath).slice(0, 64);
        const baseAddress = new lib_1.KeyPair({ pub: accountId }).getAddress();
        let durableNoncePubKeysIndex = 0;
        const durableNoncePubKeysLength = params.durableNonces.publicKeys.length;
        const consolidationTransactions = [];
        let lastScanIndex = startIdx;
        for (let i = startIdx; i < endIdx; i++) {
            const recoverParams = {
                userKey: params.userKey,
                backupKey: params.backupKey,
                bitgoKey: params.bitgoKey,
                walletPassphrase: params.walletPassphrase,
                recoveryDestination: baseAddress,
                seed: params.seed,
                index: i,
                durableNonce: {
                    publicKey: params.durableNonces.publicKeys[durableNoncePubKeysIndex],
                    secretKey: params.durableNonces.secretKey,
                },
                tokenContractAddress: params.tokenContractAddress,
            };
            let recoveryTransaction;
            try {
                recoveryTransaction = await this.recover(recoverParams);
            }
            catch (e) {
                if (e.message === 'Did not find address with funds to recover' ||
                    e.message === 'Did not find token account to recover tokens, please check token account' ||
                    e.message === 'Not enough token funds to recover') {
                    lastScanIndex = i;
                    continue;
                }
                throw e;
            }
            if (isUnsignedSweep) {
                consolidationTransactions.push(recoveryTransaction.txRequests[0]);
            }
            else {
                consolidationTransactions.push(recoveryTransaction);
            }
            lastScanIndex = i;
            durableNoncePubKeysIndex++;
            if (durableNoncePubKeysIndex >= durableNoncePubKeysLength) {
                // no more available nonce accounts to create transactions
                break;
            }
        }
        if (consolidationTransactions.length === 0) {
            throw new Error('Did not find an address with funds to recover');
        }
        if (isUnsignedSweep) {
            // lastScanIndex will be used to inform user the last address index scanned for available funds (so they can
            // appropriately adjust the scan range on the next iteration of consolidation recoveries). In the case of unsigned
            // sweep consolidations, this lastScanIndex will be provided in the coinSpecific of the last txn made.
            const lastTransactionCoinSpecific = {
                commonKeychain: consolidationTransactions[consolidationTransactions.length - 1].transactions[0].unsignedTx.coinSpecific
                    .commonKeychain,
                lastScanIndex: lastScanIndex,
            };
            consolidationTransactions[consolidationTransactions.length - 1].transactions[0].unsignedTx.coinSpecific =
                lastTransactionCoinSpecific;
            const consolidationSweepTransactions = { txRequests: consolidationTransactions };
            return consolidationSweepTransactions;
        }
        return { transactions: consolidationTransactions, lastScanIndex };
    }
    getTokenEnablementConfig() {
        return {
            requiresTokenEnablement: true,
            supportsMultipleTokenEnablements: true,
        };
    }
    getBuilder() {
        return new lib_1.TransactionBuilderFactory(statics_1.coins.get(this.getChain()));
    }
    async broadcastTransaction({ serializedSignedTransaction, }) {
        (0, utils_1.validateRawTransaction)(serializedSignedTransaction, true, true);
        const response = await this.getDataFromNode({
            payload: {
                id: '1',
                jsonrpc: '2.0',
                method: 'sendTransaction',
                params: [
                    serializedSignedTransaction,
                    {
                        encoding: 'base64',
                    },
                ],
            },
        });
        if (response.body.error) {
            throw new Error('Error broadcasting transaction: ' + response.body.error.message);
        }
        return { txId: response.body.result };
    }
}
exports.Sol = Sol;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29sLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3NvbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUgsZ0VBQXFDO0FBQ3JDLDZDQUErQjtBQUUvQiw4Q0FtQ3lCO0FBQ3pCLG9EQUF1RDtBQUN2RCw0Q0FBNkY7QUFDN0YsMENBQTRCO0FBQzVCLG9EQUFzQztBQUN0QywrQkFBMEc7QUFDMUcsdUNBUXFCO0FBQ1IsUUFBQSxtQkFBbUIsR0FBRyxFQUFFLENBQUMsQ0FBQyx3REFBd0Q7QUF3Ry9GLE1BQU0sU0FBUyxHQUFHLGdCQUFnQixDQUFDO0FBRW5DLE1BQWEsR0FBSSxTQUFRLG1CQUFRO0lBRy9CLFlBQVksS0FBZ0IsRUFBRSxXQUF1QztRQUNuRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFYixJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztTQUN2RTtRQUVELElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO0lBQ2xDLENBQUM7SUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLEtBQWdCLEVBQUUsV0FBdUM7UUFDN0UsT0FBTyxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVELDJCQUEyQjtRQUN6QixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxXQUFXO1FBQ1QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsZUFBZTtRQUNiLE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQztJQUNoQyxDQUFDO0lBRUQsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUM7SUFDbEMsQ0FBQztJQUVELFdBQVc7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STtTQUN2QyxDQUFDO0lBQ0osQ0FBQztJQUVPLFVBQVU7UUFDaEIsT0FBTyxJQUFJLCtCQUF5QixDQUFDLGVBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRUQsS0FBSyxDQUFDLG9CQUFvQixDQUFDLEVBQ3pCLDJCQUEyQixHQUNLO1FBQ2hDLElBQUEsOEJBQXNCLEVBQUMsMkJBQTJCLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ2hFLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQztZQUMxQyxPQUFPLEVBQUU7Z0JBQ1AsRUFBRSxFQUFFLEdBQUc7Z0JBQ1AsT0FBTyxFQUFFLEtBQUs7Z0JBQ2QsTUFBTSxFQUFFLGlCQUFpQjtnQkFDekIsTUFBTSxFQUFFO29CQUNOLDJCQUEyQjtvQkFDM0I7d0JBQ0UsUUFBUSxFQUFFLFFBQVE7cUJBQ25CO2lCQUNGO2FBQ0Y7U0FDRixDQUFDLENBQUM7UUFFSCxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsa0NBQWtDLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDbkY7UUFFRCxPQUFPLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDeEMsQ0FBQztDQUNGO0FBM29DRCxrQkEyb0NDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuXG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgKiBhcyBiYXNlNTggZnJvbSAnYnM1OCc7XG5cbmltcG9ydCB7XG4gIEJhc2VCcm9hZGNhc3RUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIEJhc2VCcm9hZGNhc3RUcmFuc2FjdGlvblJlc3VsdCxcbiAgQmFzZUNvaW4sXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgQmFzZVRyYW5zYWN0aW9uLFxuICBUcmFuc2FjdGlvblByZWJ1aWxkIGFzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBCaXRHb0Jhc2UsXG4gIEVERFNBTWV0aG9kcyxcbiAgRUREU0FNZXRob2RUeXBlcyxcbiAgRW52aXJvbm1lbnRzLFxuICBLZXlQYWlyLFxuICBNZW1vLFxuICBNZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yLFxuICBNUENBbGdvcml0aG0sXG4gIE1QQ0NvbnNvbGlkYXRpb25SZWNvdmVyeU9wdGlvbnMsXG4gIE1QQ1JlY292ZXJ5T3B0aW9ucyxcbiAgTVBDU3dlZXBSZWNvdmVyeU9wdGlvbnMsXG4gIE1QQ1N3ZWVwVHhzLFxuICBNUENUeCxcbiAgTVBDVHhzLFxuICBNUENVbnNpZ25lZFR4LFxuICBPdmNJbnB1dCxcbiAgT3ZjT3V0cHV0LFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgUHVibGljS2V5LFxuICBSZWNvdmVyeVR4UmVxdWVzdCxcbiAgU2lnbmVkVHJhbnNhY3Rpb24sXG4gIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFRva2VuRW5hYmxlbWVudENvbmZpZyxcbiAgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbixcbiAgVHJhbnNhY3Rpb25SZWNpcGllbnQsXG4gIFZlcmlmeUFkZHJlc3NPcHRpb25zLFxuICBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBnZXREZXJpdmF0aW9uUGF0aCB9IGZyb20gJ0BiaXRnby9zZGstbGliLW1wYyc7XG5pbXBvcnQgeyBCYXNlTmV0d29yaywgQ29pbkZhbWlseSwgY29pbnMsIEJhc2VDb2luIGFzIFN0YXRpY3NCYXNlQ29pbiB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIHJlcXVlc3QgZnJvbSAnc3VwZXJhZ2VudCc7XG5pbXBvcnQgeyBLZXlQYWlyIGFzIFNvbEtleVBhaXIsIFRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvbkJ1aWxkZXIsIFRyYW5zYWN0aW9uQnVpbGRlckZhY3RvcnkgfSBmcm9tICcuL2xpYic7XG5pbXBvcnQge1xuICBnZXRBc3NvY2lhdGVkVG9rZW5BY2NvdW50QWRkcmVzcyxcbiAgZ2V0U29sVG9rZW5Gcm9tQWRkcmVzcyxcbiAgZ2V0U29sVG9rZW5Gcm9tVG9rZW5OYW1lLFxuICBpc1ZhbGlkQWRkcmVzcyxcbiAgaXNWYWxpZFByaXZhdGVLZXksXG4gIGlzVmFsaWRQdWJsaWNLZXksXG4gIHZhbGlkYXRlUmF3VHJhbnNhY3Rpb24sXG59IGZyb20gJy4vbGliL3V0aWxzJztcbmV4cG9ydCBjb25zdCBERUZBVUxUX1NDQU5fRkFDVE9SID0gMjA7IC8vIGRlZmF1bHQgbnVtYmVyIG9mIHJlY2VpdmUgYWRkcmVzc2VzIHRvIHNjYW4gZm9yIGZ1bmRzXG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25GZWUge1xuICBmZWU6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgU29sVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiA9IFRyYW5zYWN0aW9uRXhwbGFuYXRpb247XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4QmFzZTY0OiBzdHJpbmc7XG4gIGZlZUluZm86IFRyYW5zYWN0aW9uRmVlO1xuICB0b2tlbkFjY291bnRSZW50RXhlbXB0QW1vdW50Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFR4SW5mbyB7XG4gIHJlY2lwaWVudHM6IFRyYW5zYWN0aW9uUmVjaXBpZW50W107XG4gIGZyb206IHN0cmluZztcbiAgdHhpZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNvbFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcHJ2OiBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgcHViS2V5cz86IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHR4QmFzZTY0OiBzdHJpbmc7XG4gIHR4SW5mbzogVHhJbmZvO1xuICBzb3VyY2U6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTb2xWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMge1xuICBtZW1vPzogTWVtbztcbiAgZmVlUGF5ZXI6IHN0cmluZztcbiAgYmxvY2toYXNoOiBzdHJpbmc7XG4gIGR1cmFibGVOb25jZT86IHsgd2FsbGV0Tm9uY2VBZGRyZXNzOiBzdHJpbmc7IGF1dGhXYWxsZXRBZGRyZXNzOiBudW1iZXIgfTtcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uT3V0cHV0IHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBhbW91bnQ6IG51bWJlciB8IHN0cmluZztcbiAgdG9rZW5OYW1lPzogc3RyaW5nO1xufVxuXG50eXBlIFRyYW5zYWN0aW9uSW5wdXQgPSBUcmFuc2FjdGlvbk91dHB1dDtcblxuZXhwb3J0IGludGVyZmFjZSBTb2xQYXJzZWRUcmFuc2FjdGlvbiBleHRlbmRzIFBhcnNlZFRyYW5zYWN0aW9uIHtcbiAgLy8gdG90YWwgYXNzZXRzIGJlaW5nIG1vdmVkLCBpbmNsdWRpbmcgZmVlc1xuICBpbnB1dHM6IFRyYW5zYWN0aW9uSW5wdXRbXTtcblxuICAvLyB3aGVyZSBhc3NldHMgYXJlIG1vdmVkIHRvXG4gIG91dHB1dHM6IFRyYW5zYWN0aW9uT3V0cHV0W107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU29sUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBCYXNlUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEJhc2U2NDogc3RyaW5nO1xuICBmZWVJbmZvOiBUcmFuc2FjdGlvbkZlZTtcbiAgdG9rZW5BY2NvdW50UmVudEV4ZW1wdEFtb3VudD86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFNvbER1cmFibGVOb25jZUZyb21Ob2RlIHtcbiAgYXV0aG9yaXR5OiBzdHJpbmc7XG4gIGJsb2NraGFzaDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVG9rZW5BbW91bnQge1xuICBhbW91bnQ6IHN0cmluZztcbiAgZGVjaW1hbHM6IG51bWJlcjtcbiAgdWlBbW91bnQ6IG51bWJlcjtcbiAgdWlBbW91bnRTdHJpbmc6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRva2VuQWNjb3VudEluZm8ge1xuICBpc05hdGl2ZTogYm9vbGVhbjtcbiAgbWludDogc3RyaW5nO1xuICBvd25lcjogc3RyaW5nO1xuICBzdGF0ZTogc3RyaW5nO1xuICB0b2tlbkFtb3VudDogVG9rZW5BbW91bnQ7XG59XG5cbmludGVyZmFjZSBUb2tlbkFjY291bnQge1xuICBpbmZvOiBUb2tlbkFjY291bnRJbmZvO1xuICBwdWJLZXk6IHN0cmluZztcbiAgdG9rZW5OYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNvbFJlY292ZXJ5T3B0aW9ucyBleHRlbmRzIE1QQ1JlY292ZXJ5T3B0aW9ucyB7XG4gIGR1cmFibGVOb25jZT86IHtcbiAgICBwdWJsaWNLZXk6IHN0cmluZztcbiAgICBzZWNyZXRLZXk6IHN0cmluZztcbiAgfTtcbiAgdG9rZW5Db250cmFjdEFkZHJlc3M/OiBzdHJpbmc7XG4gIGNsb3NlQXRhQWRkcmVzcz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTb2xDb25zb2xpZGF0aW9uUmVjb3ZlcnlPcHRpb25zIGV4dGVuZHMgTVBDQ29uc29saWRhdGlvblJlY292ZXJ5T3B0aW9ucyB7XG4gIGR1cmFibGVOb25jZXM6IHtcbiAgICBwdWJsaWNLZXlzOiBzdHJpbmdbXTtcbiAgICBzZWNyZXRLZXk6IHN0cmluZztcbiAgfTtcbiAgdG9rZW5Db250cmFjdEFkZHJlc3M/OiBzdHJpbmc7XG59XG5cbmNvbnN0IEhFWF9SRUdFWCA9IC9eWzAtOWEtZkEtRl0rJC87XG5cbmV4cG9ydCBjbGFzcyBTb2wgZXh0ZW5kcyBCYXNlQ29pbiB7XG4gIHByb3RlY3RlZCByZWFkb25seSBfc3RhdGljc0NvaW46IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj47XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSwgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KSB7XG4gICAgc3VwZXIoYml0Z28pO1xuXG4gICAgaWYgKCFzdGF0aWNzQ29pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBzdGF0aWNzQ29pbicpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRpY3NDb2luID0gc3RhdGljc0NvaW47XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvQmFzZSwgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgU29sKGJpdGdvLCBzdGF0aWNzQ29pbik7XG4gIH1cblxuICBhbGxvd3NBY2NvdW50Q29uc29saWRhdGlvbnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzdXBwb3J0c1RzcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldE1QQ0FsZ29yaXRobSgpOiBNUENBbGdvcml0aG0ge1xuICAgIHJldHVybiAnZWRkc2EnO1xuICB9XG5cbiAgZ2V0Q2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4ubmFtZTtcbiAgfVxuXG4gIGdldEZhbWlseSgpOiBDb2luRmFtaWx5IHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZmFtaWx5O1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZnVsbE5hbWU7XG4gIH1cblxuICBnZXROZXR3b3JrKCk6IEJhc2VOZXR3b3JrIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4ubmV0d29yaztcbiAgfVxuXG4gIGdldEJhc2VGYWN0b3IoKTogc3RyaW5nIHwgbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXRpY3NDb2luLmRlY2ltYWxQbGFjZXMpO1xuICB9XG5cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBTb2xWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIC8vIGFzc2V0IG5hbWUgdG8gdHJhbnNmZXIgYW1vdW50IG1hcFxuICAgIGNvbnN0IHRvdGFsQW1vdW50OiBSZWNvcmQ8c3RyaW5nLCBCaWdOdW1iZXI+ID0ge307XG4gICAgY29uc3QgY29pbkNvbmZpZyA9IGNvaW5zLmdldCh0aGlzLmdldENoYWluKCkpO1xuICAgIGNvbnN0IHsgdHhQYXJhbXM6IHR4UGFyYW1zLCB0eFByZWJ1aWxkOiB0eFByZWJ1aWxkLCBtZW1vOiBtZW1vLCBkdXJhYmxlTm9uY2U6IGR1cmFibGVOb25jZSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKGNvaW5Db25maWcpO1xuICAgIGNvbnN0IHJhd1R4ID0gdHhQcmVidWlsZC50eEJhc2U2NCB8fCB0eFByZWJ1aWxkLnR4SGV4O1xuICAgIGNvbnN0IGNvbnNvbGlkYXRlSWQgPSB0eFByZWJ1aWxkLmNvbnNvbGlkYXRlSWQ7XG5cbiAgICBjb25zdCB3YWxsZXRSb290QWRkcmVzcyA9IHBhcmFtcy53YWxsZXQuY29pblNwZWNpZmljKCk/LnJvb3RBZGRyZXNzO1xuXG4gICAgaWYgKCFyYXdUeCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR4IHByZWJ1aWxkIHByb3BlcnR5IHR4QmFzZTY0IG9yIHR4SGV4Jyk7XG4gICAgfVxuXG4gICAgbGV0IHJhd1R4QmFzZTY0ID0gcmF3VHg7XG4gICAgaWYgKEhFWF9SRUdFWC50ZXN0KHJhd1R4KSkge1xuICAgICAgcmF3VHhCYXNlNjQgPSBCdWZmZXIuZnJvbShyYXdUeCwgJ2hleCcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG4gICAgdHJhbnNhY3Rpb24uZnJvbVJhd1RyYW5zYWN0aW9uKHJhd1R4QmFzZTY0KTtcbiAgICBjb25zdCBleHBsYWluZWRUeCA9IHRyYW5zYWN0aW9uLmV4cGxhaW5UcmFuc2FjdGlvbigpO1xuXG4gICAgLy8gdXNlcnMgZG8gbm90IGlucHV0IHJlY2lwaWVudHMgZm9yIGNvbnNvbGlkYXRpb24gcmVxdWVzdHMgYXMgdGhleSBhcmUgZ2VuZXJhdGVkIGJ5IHRoZSBzZXJ2ZXJcbiAgICBpZiAodHhQYXJhbXMucmVjaXBpZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBmaWx0ZXJlZFJlY2lwaWVudHMgPSB0eFBhcmFtcy5yZWNpcGllbnRzPy5tYXAoKHJlY2lwaWVudCkgPT5cbiAgICAgICAgXy5waWNrKHJlY2lwaWVudCwgWydhZGRyZXNzJywgJ2Ftb3VudCcsICd0b2tlbk5hbWUnXSlcbiAgICAgICk7XG4gICAgICBjb25zdCBmaWx0ZXJlZE91dHB1dHMgPSBleHBsYWluZWRUeC5vdXRwdXRzLm1hcCgob3V0cHV0KSA9PiBfLnBpY2sob3V0cHV0LCBbJ2FkZHJlc3MnLCAnYW1vdW50JywgJ3Rva2VuTmFtZSddKSk7XG5cbiAgICAgIGlmIChmaWx0ZXJlZFJlY2lwaWVudHMubGVuZ3RoICE9PSBmaWx0ZXJlZE91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIG9mIHR4IG91dHB1dHMgZG9lcyBub3QgbWF0Y2ggd2l0aCBudW1iZXIgb2YgdHhQYXJhbXMgcmVjaXBpZW50cycpO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3IgZWFjaCByZWNpcGllbnQsIGNoZWNrIGlmIGl0J3MgYSB0b2tlbiB0eCAodG9rZW5OYW1lIHdpbGwgZXhpc3QgaWYgc28pXG4gICAgICAvLyBJZiBpdCBpcyBhIHRva2VuIHR4LCB2ZXJpZnkgdGhhdCB0aGUgcmVjaXBpZW50IGFkZHJlc3MgZXF1YWxzIHRoZSBkZXJpdmVkIGFkZHJlc3MgZnJvbSBleHBsYWluZWRUeFxuICAgICAgLy8gRGVyaXZlIHRoZSBBVEEgaWYgaXQgaXMgYSBuYXRpdmUgYWRkcmVzcyBhbmQgY29uZmlybSBpdCBpcyBlcXVhbCB0byB0aGUgZXhwbGFpbmVkIHR4IHJlY2lwaWVudFxuICAgICAgY29uc3QgcmVjaXBpZW50Q2hlY2tzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIGZpbHRlcmVkUmVjaXBpZW50cy5tYXAoYXN5bmMgKHJlY2lwaWVudEZyb21Vc2VyLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlY2lwaWVudEZyb21UeCA9IGZpbHRlcmVkT3V0cHV0c1tpbmRleF07IC8vIFRoaXMgYWRkcmVzcyBzaG91bGQgYmUgYW4gQVRBXG5cbiAgICAgICAgICAvLyBDb21wYXJlIHRoZSBCaWdOdW1iZXIgdmFsdWVzIGJlY2F1c2UgYW1vdW50IGlzIChzdHJpbmcgfCBudW1iZXIpXG4gICAgICAgICAgY29uc3QgdXNlckFtb3VudCA9IG5ldyBCaWdOdW1iZXIocmVjaXBpZW50RnJvbVVzZXIuYW1vdW50KTtcbiAgICAgICAgICBjb25zdCB0eEFtb3VudCA9IG5ldyBCaWdOdW1iZXIocmVjaXBpZW50RnJvbVR4LmFtb3VudCk7XG4gICAgICAgICAgaWYgKCF1c2VyQW1vdW50LmlzRXF1YWxUbyh0eEFtb3VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb21wYXJlIHRoZSBhZGRyZXNzZXMgYW5kIHRva2VuTmFtZXNcbiAgICAgICAgICAvLyBFbHNlIGlmIHRoZSBhZGRyZXNzZXMgYXJlIG5vdCB0aGUgc2FtZSwgY2hlY2sgdGhlIGRlcml2ZWQgQVRBIGZvciBwYXJpdHlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICByZWNpcGllbnRGcm9tVXNlci5hZGRyZXNzID09PSByZWNpcGllbnRGcm9tVHguYWRkcmVzcyAmJlxuICAgICAgICAgICAgcmVjaXBpZW50RnJvbVVzZXIudG9rZW5OYW1lID09PSByZWNpcGllbnRGcm9tVHgudG9rZW5OYW1lXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlY2lwaWVudEZyb21Vc2VyLmFkZHJlc3MgIT09IHJlY2lwaWVudEZyb21UeC5hZGRyZXNzICYmIHJlY2lwaWVudEZyb21Vc2VyLnRva2VuTmFtZSkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGNoZWNrIGlmIHRoZSB1c2VyJ3MgZGVyaXZlZCBBVEEgaXMgZXF1YWwgdG8gdGhlIHR4IHJlY2lwaWVudCBhZGRyZXNzXG4gICAgICAgICAgICAvLyBJZiBnZXRBc3NvY2lhdGVkVG9rZW5BY2NvdW50QWRkcmVzcyB0aHJvd3MgYW4gZXJyb3IsIHRoZW4gd2UgYXJlIHVuYWJsZSB0byBkZXJpdmUgdGhlIEFUQSBmb3IgdGhhdCBhZGRyZXNzLlxuICAgICAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGFuZCB0aHJvdyBhbiBlcnJvciBpZiB0aGF0IGlzIHRoZSBjYXNlLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9rZW5NaW50QWRkcmVzcyA9IGdldFNvbFRva2VuRnJvbVRva2VuTmFtZShyZWNpcGllbnRGcm9tVXNlci50b2tlbk5hbWUpO1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0QXNzb2NpYXRlZFRva2VuQWNjb3VudEFkZHJlc3ModG9rZW5NaW50QWRkcmVzcyEudG9rZW5BZGRyZXNzLCByZWNpcGllbnRGcm9tVXNlci5hZGRyZXNzKS50aGVuKFxuICAgICAgICAgICAgICAgIChhdGE6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0YSA9PT0gcmVjaXBpZW50RnJvbVR4LmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIC8vIFVuYWJsZSB0byBkZXJpdmUgQVRBXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgaWYgKHJlY2lwaWVudENoZWNrcy5pbmNsdWRlcyhmYWxzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCBvdXRwdXRzIGRvZXMgbm90IG1hdGNoIHdpdGggZXhwZWN0ZWQgdHhQYXJhbXMgcmVjaXBpZW50cycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zYWN0aW9uSnNvbiA9IHRyYW5zYWN0aW9uLnRvSnNvbigpO1xuICAgIGlmIChtZW1vICYmIG1lbW8udmFsdWUgIT09IGV4cGxhaW5lZFR4Lm1lbW8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHggbWVtbyBkb2VzIG5vdCBtYXRjaCB3aXRoIGV4cGVjdGVkIHR4UGFyYW1zIHJlY2lwaWVudCBtZW1vJyk7XG4gICAgfVxuICAgIGlmICh0eFBhcmFtcy5yZWNpcGllbnRzKSB7XG4gICAgICBmb3IgKGNvbnN0IHJlY2lwaWVudHMgb2YgdHhQYXJhbXMucmVjaXBpZW50cykge1xuICAgICAgICAvLyB0b3RhbEFtb3VudCBiYXNlZCBvbiBlYWNoIHRva2VuXG4gICAgICAgIGNvbnN0IGFzc2V0TmFtZSA9IHJlY2lwaWVudHMudG9rZW5OYW1lIHx8IHRoaXMuZ2V0Q2hhaW4oKTtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gdG90YWxBbW91bnRbYXNzZXROYW1lXSB8fCBuZXcgQmlnTnVtYmVyKDApO1xuICAgICAgICB0b3RhbEFtb3VudFthc3NldE5hbWVdID0gYW1vdW50LnBsdXMocmVjaXBpZW50cy5hbW91bnQpO1xuICAgICAgfVxuXG4gICAgICAvLyB0b3RhbCBvdXRwdXQgYW1vdW50IGZyb20gZXhwbGFpbmVkVHhcbiAgICAgIGNvbnN0IGV4cGxhaW5lZFR4VG90YWw6IFJlY29yZDxzdHJpbmcsIEJpZ051bWJlcj4gPSB7fTtcblxuICAgICAgZm9yIChjb25zdCBvdXRwdXQgb2YgZXhwbGFpbmVkVHgub3V0cHV0cykge1xuICAgICAgICAvLyB0b3RhbCBvdXRwdXQgYW1vdW50IGJhc2VkIG9uIGVhY2ggdG9rZW5cbiAgICAgICAgY29uc3QgYXNzZXROYW1lID0gb3V0cHV0LnRva2VuTmFtZSB8fCB0aGlzLmdldENoYWluKCk7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IGV4cGxhaW5lZFR4VG90YWxbYXNzZXROYW1lXSB8fCBuZXcgQmlnTnVtYmVyKDApO1xuICAgICAgICBleHBsYWluZWRUeFRvdGFsW2Fzc2V0TmFtZV0gPSBhbW91bnQucGx1cyhvdXRwdXQuYW1vdW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzRXF1YWwoZXhwbGFpbmVkVHhUb3RhbCwgdG90YWxBbW91bnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHggdG90YWwgYW1vdW50IGRvZXMgbm90IG1hdGNoIHdpdGggZXhwZWN0ZWQgdG90YWwgYW1vdW50IGZpZWxkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIG5vbi1jb25zb2xpZGF0ZSB0cmFuc2FjdGlvbnMsIGZlZVBheWVyIG11c3QgYmUgdGhlIHdhbGxldCdzIHJvb3QgYWRkcmVzc1xuICAgIGlmIChjb25zb2xpZGF0ZUlkID09PSB1bmRlZmluZWQgJiYgdHJhbnNhY3Rpb25Kc29uLmZlZVBheWVyICE9PSB3YWxsZXRSb290QWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCBmZWUgcGF5ZXIgaXMgbm90IHRoZSB3YWxsZXQgcm9vdCBhZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgaWYgKGR1cmFibGVOb25jZSAmJiAhXy5pc0VxdWFsKGV4cGxhaW5lZFR4LmR1cmFibGVOb25jZSwgZHVyYWJsZU5vbmNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCBkdXJhYmxlTm9uY2UgZG9lcyBub3QgbWF0Y2ggd2l0aCBwYXJhbSBkdXJhYmxlTm9uY2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGFzeW5jIGlzV2FsbGV0QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBTb2xhbmEga2V5IHBhaXJcbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IHNlZWQgLSBTZWVkIGZyb20gd2hpY2ggdGhlIG5ldyBTb2xLZXlQYWlyIHNob3VsZCBiZSBnZW5lcmF0ZWQsIG90aGVyd2lzZSBhIHJhbmRvbSBzZWVkIGlzIHVzZWRcbiAgICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IHdpdGggZ2VuZXJhdGVkIHB1YiBhbmQgcHJ2XG4gICAqL1xuICBnZW5lcmF0ZUtleVBhaXIoc2VlZD86IEJ1ZmZlciB8IHVuZGVmaW5lZCk6IEtleVBhaXIge1xuICAgIGNvbnN0IHJlc3VsdCA9IHNlZWQgPyBuZXcgU29sS2V5UGFpcih7IHNlZWQgfSkuZ2V0S2V5cygpIDogbmV3IFNvbEtleVBhaXIoKS5nZXRLZXlzKCk7XG4gICAgcmV0dXJuIHJlc3VsdCBhcyBLZXlQYWlyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHViIHRoZSBwcnYgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNWYWxpZFB1YmxpY0tleShwdWIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwcml2YXRlIGtleSBmb3IgdGhlIGNvaW5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBydiB0aGUgcHJ2IHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMgaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHJ2KHBydjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzVmFsaWRQcml2YXRlS2V5KHBydik7XG4gIH1cblxuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNWYWxpZEFkZHJlc3MoYWRkcmVzcyk7XG4gIH1cblxuICBhc3luYyBzaWduTWVzc2FnZShrZXk6IEtleVBhaXIsIG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlcik6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgY29uc3Qgc29sS2V5cGFpciA9IG5ldyBTb2xLZXlQYWlyKHsgcHJ2OiBrZXkucHJ2IH0pO1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkpIHtcbiAgICAgIG1lc3NhZ2UgPSBiYXNlNTguZW5jb2RlKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBCdWZmZXIuZnJvbShzb2xLZXlwYWlyLnNpZ25NZXNzYWdlKG1lc3NhZ2UpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyBTb2xhbmEgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFNvbFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuZ2V0QnVpbGRlcigpO1xuICAgIGNvbnN0IHJhd1R4ID0gcGFyYW1zLnR4UHJlYnVpbGQudHhIZXggfHwgcGFyYW1zLnR4UHJlYnVpbGQudHhCYXNlNjQ7XG4gICAgY29uc3QgdHhCdWlsZGVyID0gZmFjdG9yeS5mcm9tKHJhd1R4KTtcbiAgICB0eEJ1aWxkZXIuc2lnbih7IGtleTogcGFyYW1zLnBydiB9KTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbjogQmFzZVRyYW5zYWN0aW9uID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG5cbiAgICBpZiAoIXRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJpYWxpemVkVHggPSAodHJhbnNhY3Rpb24gYXMgQmFzZVRyYW5zYWN0aW9uKS50b0Jyb2FkY2FzdEZvcm1hdCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR4SGV4OiBzZXJpYWxpemVkVHgsXG4gICAgfSBhcyBhbnk7XG4gIH1cblxuICBhc3luYyBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogU29sUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFNvbFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25FeHBsYW5hdGlvbiA9IGF3YWl0IHRoaXMuZXhwbGFpblRyYW5zYWN0aW9uKHtcbiAgICAgIHR4QmFzZTY0OiBwYXJhbXMudHhCYXNlNjQsXG4gICAgICBmZWVJbmZvOiBwYXJhbXMuZmVlSW5mbyxcbiAgICAgIHRva2VuQWNjb3VudFJlbnRFeGVtcHRBbW91bnQ6IHBhcmFtcy50b2tlbkFjY291bnRSZW50RXhlbXB0QW1vdW50LFxuICAgIH0pO1xuXG4gICAgaWYgKCF0cmFuc2FjdGlvbkV4cGxhbmF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBzb2xUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uRXhwbGFuYXRpb24gYXMgU29sVHJhbnNhY3Rpb25FeHBsYW5hdGlvbjtcbiAgICBpZiAoc29sVHJhbnNhY3Rpb24ub3V0cHV0cy5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHNlbmRlckFkZHJlc3MgPSBzb2xUcmFuc2FjdGlvbi5vdXRwdXRzWzBdLmFkZHJlc3M7XG4gICAgY29uc3QgZmVlQW1vdW50ID0gbmV3IEJpZ051bWJlcihzb2xUcmFuc2FjdGlvbi5mZWUuZmVlKTtcblxuICAgIC8vIGFzc3VtZSAxIHNlbmRlciwgd2hvIGlzIGFsc28gdGhlIGZlZSBwYXllclxuICAgIGNvbnN0IGlucHV0cyA9IFtcbiAgICAgIHtcbiAgICAgICAgYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBuZXcgQmlnTnVtYmVyKHNvbFRyYW5zYWN0aW9uLm91dHB1dEFtb3VudCkucGx1cyhmZWVBbW91bnQpLnRvTnVtYmVyKCksXG4gICAgICB9LFxuICAgIF07XG5cbiAgICBjb25zdCBvdXRwdXRzOiBUcmFuc2FjdGlvbk91dHB1dFtdID0gc29sVHJhbnNhY3Rpb24ub3V0cHV0cy5tYXAoKHsgYWRkcmVzcywgYW1vdW50LCB0b2tlbk5hbWUgfSkgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0OiBUcmFuc2FjdGlvbk91dHB1dCA9IHsgYWRkcmVzcywgYW1vdW50IH07XG4gICAgICBpZiAodG9rZW5OYW1lKSB7XG4gICAgICAgIG91dHB1dC50b2tlbk5hbWUgPSB0b2tlbk5hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0cyxcbiAgICAgIG91dHB1dHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluIGEgU29sYW5hIHRyYW5zYWN0aW9uIGZyb20gdHhCYXNlNjRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgZXhwbGFpblRyYW5zYWN0aW9uKHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8U29sVHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmdldEJ1aWxkZXIoKTtcbiAgICBsZXQgcmVidWlsdFRyYW5zYWN0aW9uO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uQnVpbGRlciA9IGZhY3RvcnkuZnJvbShwYXJhbXMudHhCYXNlNjQpO1xuICAgICAgaWYgKHRyYW5zYWN0aW9uQnVpbGRlciBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uQnVpbGRlcikge1xuICAgICAgICBjb25zdCB0eEJ1aWxkZXIgPSB0cmFuc2FjdGlvbkJ1aWxkZXIgYXMgVHJhbnNhY3Rpb25CdWlsZGVyO1xuICAgICAgICB0eEJ1aWxkZXIuZmVlKHsgYW1vdW50OiBwYXJhbXMuZmVlSW5mby5mZWUgfSk7XG4gICAgICAgIGlmIChwYXJhbXMudG9rZW5BY2NvdW50UmVudEV4ZW1wdEFtb3VudCkge1xuICAgICAgICAgIHR4QnVpbGRlci5hc3NvY2lhdGVkVG9rZW5BY2NvdW50UmVudChwYXJhbXMudG9rZW5BY2NvdW50UmVudEV4ZW1wdEFtb3VudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlYnVpbHRUcmFuc2FjdGlvbiA9IGF3YWl0IHRyYW5zYWN0aW9uQnVpbGRlci5idWlsZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZXhwbGFpbmVkVHJhbnNhY3Rpb24gPSAocmVidWlsdFRyYW5zYWN0aW9uIGFzIEJhc2VUcmFuc2FjdGlvbikuZXhwbGFpblRyYW5zYWN0aW9uKCk7XG5cbiAgICByZXR1cm4gZXhwbGFpbmVkVHJhbnNhY3Rpb24gYXMgU29sVHJhbnNhY3Rpb25FeHBsYW5hdGlvbjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBhc3luYyBnZXRTaWduYWJsZVBheWxvYWQoc2VyaWFsaXplZFR4OiBzdHJpbmcpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmdldEJ1aWxkZXIoKTtcbiAgICBjb25zdCByZWJ1aWx0VHJhbnNhY3Rpb24gPSBhd2FpdCBmYWN0b3J5LmZyb20oc2VyaWFsaXplZFR4KS5idWlsZCgpO1xuICAgIHJldHVybiByZWJ1aWx0VHJhbnNhY3Rpb24uc2lnbmFibGVQYXlsb2FkO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGFzeW5jIHByZXNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnM+IHtcbiAgICAvLyBIb3Qgd2FsbGV0IHR4bnMgYXJlIG9ubHkgdmFsaWQgZm9yIDEtMiBtaW51dGVzLlxuICAgIC8vIFRvIGJ1eSBtb3JlIHRpbWUsIHdlIHJlYnVpbGQgdGhlIHRyYW5zYWN0aW9uIHdpdGggYSBuZXcgYmxvY2toYXNoIHJpZ2h0IGJlZm9yZSB3ZSBzaWduLlxuICAgIGlmIChwYXJhbXMud2FsbGV0RGF0YS50eXBlICE9PSAnaG90Jykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYXJhbXMpO1xuICAgIH1cblxuICAgIGNvbnN0IHR4UmVxdWVzdElkID0gcGFyYW1zLnR4UHJlYnVpbGQ/LnR4UmVxdWVzdElkO1xuICAgIGlmICh0eFJlcXVlc3RJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdHhSZXF1ZXN0SWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHRzc1V0aWxzIH0gPSBwYXJhbXM7XG5cbiAgICBhd2FpdCB0c3NVdGlscyEuZGVsZXRlU2lnbmF0dXJlU2hhcmVzKHR4UmVxdWVzdElkKTtcbiAgICBjb25zdCByZWNyZWF0ZWQgPSBhd2FpdCB0c3NVdGlscyEuZ2V0VHhSZXF1ZXN0KHR4UmVxdWVzdElkKTtcbiAgICBsZXQgdHhIZXggPSAnJztcbiAgICBpZiAocmVjcmVhdGVkLnVuc2lnbmVkVHhzKSB7XG4gICAgICB0eEhleCA9IHJlY3JlYXRlZC51bnNpZ25lZFR4c1swXT8uc2VyaWFsaXplZFR4SGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0eEhleCA9IHJlY3JlYXRlZC50cmFuc2FjdGlvbnMgPyByZWNyZWF0ZWQudHJhbnNhY3Rpb25zWzBdPy51bnNpZ25lZFR4LnNlcmlhbGl6ZWRUeEhleCA6ICcnO1xuICAgIH1cblxuICAgIGlmICghdHhIZXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzZXJpYWxpemVkIHR4IGhleCcpO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgdHhQcmVidWlsZDogcmVjcmVhdGVkLFxuICAgICAgdHhIZXgsXG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0UHVibGljTm9kZVVybCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBFbnZpcm9ubWVudHNbdGhpcy5iaXRnby5nZXRFbnYoKV0uc29sTm9kZVVybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgcmVxdWVzdCB0byBvbmUgb2YgdGhlIHB1YmxpYyBTT0wgbm9kZXMgYXZhaWxhYmxlXG4gICAqIEBwYXJhbSBwYXJhbXMucGF5bG9hZFxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGdldERhdGFGcm9tTm9kZShwYXJhbXM6IHsgcGF5bG9hZD86IFJlY29yZDxzdHJpbmcsIHVua25vd24+IH0pOiBQcm9taXNlPHJlcXVlc3QuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBub2RlVXJsID0gdGhpcy5nZXRQdWJsaWNOb2RlVXJsKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCByZXF1ZXN0LnBvc3Qobm9kZVVybCkuc2VuZChwYXJhbXMucGF5bG9hZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5kZWJ1ZyhlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY2FsbCBlbmRwb2ludDogJy8nIGZyb20gbm9kZTogJHtub2RlVXJsfWApO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGdldEJsb2NraGFzaCgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXREYXRhRnJvbU5vZGUoe1xuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBpZDogJzEnLFxuICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgbWV0aG9kOiAnZ2V0TGF0ZXN0QmxvY2toYXNoJyxcbiAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29tbWl0bWVudDogJ2ZpbmFsaXplZCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmJvZHkucmVzdWx0LnZhbHVlLmJsb2NraGFzaDtcbiAgfVxuXG4gIC8qKiBUT0RPIFVwZGF0ZSB0byBnZXRGZWVGb3JNZXNzYWdlIGFuZCBtYWtlIG5lY3NzYXJ5IGNoYW5nZXMgaW4gZmVlIGNhbGN1bGF0aW9uLCBHZXRGZWVzIGlzIGRlcHJlY2F0ZWQgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGdldEZlZXMoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKHtcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgaWQ6ICcxJyxcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIG1ldGhvZDogJ2dldEZlZXMnLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWNjb3VudCBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuYm9keS5yZXN1bHQudmFsdWUuZmVlQ2FsY3VsYXRvci5sYW1wb3J0c1BlclNpZ25hdHVyZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBnZXRSZW50RXhlbXB0QW1vdW50KCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldERhdGFGcm9tTm9kZSh7XG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBpZDogJzEnLFxuICAgICAgICBtZXRob2Q6ICdnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24nLFxuICAgICAgICBwYXJhbXM6IFsxNjVdLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDAgfHwgcmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShyZXNwb25zZS5lcnJvcikpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZS5ib2R5LnJlc3VsdDtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBnZXRBY2NvdW50QmFsYW5jZShwdWJLZXk6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldERhdGFGcm9tTm9kZSh7XG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGlkOiAnMScsXG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBtZXRob2Q6ICdnZXRCYWxhbmNlJyxcbiAgICAgICAgcGFyYW1zOiBbcHViS2V5XSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS5ib2R5LnJlc3VsdC52YWx1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBnZXRBY2NvdW50SW5mbyhwdWJLZXk6IHN0cmluZyk6IFByb21pc2U8U29sRHVyYWJsZU5vbmNlRnJvbU5vZGU+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKHtcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgaWQ6ICcxJyxcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIG1ldGhvZDogJ2dldEFjY291bnRJbmZvJyxcbiAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgcHViS2V5LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVuY29kaW5nOiAnanNvblBhcnNlZCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhdXRob3JpdHk6IHJlc3BvbnNlLmJvZHkucmVzdWx0LnZhbHVlLmRhdGEucGFyc2VkLmluZm8uYXV0aG9yaXR5LFxuICAgICAgYmxvY2toYXNoOiByZXNwb25zZS5ib2R5LnJlc3VsdC52YWx1ZS5kYXRhLnBhcnNlZC5pbmZvLmJsb2NraGFzaCxcbiAgICB9O1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGdldFRva2VuQWNjb3VudHNCeU93bmVyKHB1YktleSA9ICcnKTogUHJvbWlzZTxbXSB8IFRva2VuQWNjb3VudFtdPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldERhdGFGcm9tTm9kZSh7XG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGlkOiAnMScsXG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBtZXRob2Q6ICdnZXRUb2tlbkFjY291bnRzQnlPd25lcicsXG4gICAgICAgIHBhcmFtczogW1xuICAgICAgICAgIHB1YktleSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwcm9ncmFtSWQ6ICdUb2tlbmtlZ1FmZVp5aU53QUpiTmJHS1BGWENXdUJ2ZjlTczYyM1ZRNURBJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVuY29kaW5nOiAnanNvblBhcnNlZCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNlLmJvZHkucmVzdWx0LnZhbHVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3QgdG9rZW5BY2NvdW50czogVG9rZW5BY2NvdW50W10gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgdG9rZW5BY2NvdW50IG9mIHJlc3BvbnNlLmJvZHkucmVzdWx0LnZhbHVlKSB7XG4gICAgICAgIHRva2VuQWNjb3VudHMucHVzaCh7IGluZm86IHRva2VuQWNjb3VudC5hY2NvdW50LmRhdGEucGFyc2VkLmluZm8sIHB1YktleTogdG9rZW5BY2NvdW50LnB1YktleSB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlbkFjY291bnRzO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGZ1bmRzIHN3ZWVwIHJlY292ZXJ5IHRyYW5zYWN0aW9uKHMpIHdpdGhvdXQgQml0R29cbiAgICpcbiAgICogQHBhcmFtIHtTd2VlcFJlY292ZXJ5T3B0aW9uc30gcGFyYW1zIHBhcmFtZXRlcnMgbmVlZGVkIHRvIGNvbWJpbmUgdGhlIHNpZ25hdHVyZXNcbiAgICogYW5kIHRyYW5zYWN0aW9ucyB0byBjcmVhdGUgYnJvYWRjYXN0YWJsZSB0cmFuc2FjdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge01QQ1R4c30gYXJyYXkgb2YgdGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gaGV4IHN0cmluZ3MgYW5kIGluZGljZXNcbiAgICogb2YgdGhlIGFkZHJlc3NlcyBiZWluZyBzd2VwdFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQnJvYWRjYXN0YWJsZVN3ZWVwVHJhbnNhY3Rpb24ocGFyYW1zOiBNUENTd2VlcFJlY292ZXJ5T3B0aW9ucyk6IFByb21pc2U8TVBDVHhzPiB7XG4gICAgaWYgKCFwYXJhbXMuc2lnbmF0dXJlU2hhcmVzKSB7XG4gICAgICAoJ01pc3NpbmcgdHJhbnNhY3Rpb24ocyknKTtcbiAgICB9XG4gICAgY29uc3QgcmVxID0gcGFyYW1zLnNpZ25hdHVyZVNoYXJlcztcbiAgICBjb25zdCBicm9hZGNhc3RhYmxlVHJhbnNhY3Rpb25zOiBNUENUeFtdID0gW107XG4gICAgbGV0IGxhc3RTY2FuSW5kZXggPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IE1QQyA9IGF3YWl0IEVERFNBTWV0aG9kcy5nZXRJbml0aWFsaXplZE1wY0luc3RhbmNlKCk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHJlcVtpXS50eFJlcXVlc3QudHJhbnNhY3Rpb25zWzBdLnVuc2lnbmVkVHg7XG4gICAgICBpZiAoIXJlcVtpXS5vdmMgfHwgIXJlcVtpXS5vdmNbMF0uZWRkc2FTaWduYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNpZ25hdHVyZShzKScpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gcmVxW2ldLm92Y1swXS5lZGRzYVNpZ25hdHVyZTtcbiAgICAgIGlmICghdHJhbnNhY3Rpb24uc2lnbmFibGVIZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNpZ25hYmxlIGhleCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHRyYW5zYWN0aW9uLnNpZ25hYmxlSGV4ISwgJ2hleCcpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gTVBDLnZlcmlmeShtZXNzYWdlQnVmZmVyLCBzaWduYXR1cmUpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmF0dXJlSGV4ID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oc2lnbmF0dXJlLlIsICdoZXgnKSwgQnVmZmVyLmZyb20oc2lnbmF0dXJlLnNpZ21hLCAnaGV4JyldKTtcbiAgICAgIGNvbnN0IHR4QnVpbGRlciA9IHRoaXMuZ2V0QnVpbGRlcigpLmZyb20odHJhbnNhY3Rpb24uc2VyaWFsaXplZFR4IGFzIHN0cmluZyk7XG4gICAgICBpZiAoIXRyYW5zYWN0aW9uLmNvaW5TcGVjaWZpYz8uY29tbW9uS2V5Y2hhaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNvbW1vbiBrZXljaGFpbicpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tbW9uS2V5Y2hhaW4gPSB0cmFuc2FjdGlvbi5jb2luU3BlY2lmaWMhLmNvbW1vbktleWNoYWluISBhcyBzdHJpbmc7XG4gICAgICBpZiAoIXRyYW5zYWN0aW9uLmRlcml2YXRpb25QYXRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkZXJpdmF0aW9uIHBhdGgnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlcml2YXRpb25QYXRoID0gdHJhbnNhY3Rpb24uZGVyaXZhdGlvblBhdGggYXMgc3RyaW5nO1xuICAgICAgY29uc3QgYWNjb3VudElkID0gTVBDLmRlcml2ZVVuaGFyZGVuZWQoY29tbW9uS2V5Y2hhaW4sIGRlcml2YXRpb25QYXRoKS5zbGljZSgwLCA2NCk7XG4gICAgICBjb25zdCBiczU4RW5jb2RlZFB1YmxpY0tleSA9IG5ldyBTb2xLZXlQYWlyKHsgcHViOiBhY2NvdW50SWQgfSkuZ2V0QWRkcmVzcygpO1xuXG4gICAgICAvLyBhZGQgY29tYmluZWQgc2lnbmF0dXJlIGZyb20gb3ZjXG4gICAgICBjb25zdCBwdWJsaWNLZXlPYmogPSB7IHB1YjogYnM1OEVuY29kZWRQdWJsaWNLZXkgfTtcbiAgICAgIHR4QnVpbGRlci5hZGRTaWduYXR1cmUocHVibGljS2V5T2JqIGFzIFB1YmxpY0tleSwgc2lnbmF0dXJlSGV4KTtcblxuICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb24gPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRUeCA9IHNpZ25lZFRyYW5zYWN0aW9uLnRvQnJvYWRjYXN0Rm9ybWF0KCk7XG5cbiAgICAgIGJyb2FkY2FzdGFibGVUcmFuc2FjdGlvbnMucHVzaCh7XG4gICAgICAgIHNlcmlhbGl6ZWRUeDogc2VyaWFsaXplZFR4LFxuICAgICAgICBzY2FuSW5kZXg6IHRyYW5zYWN0aW9uLnNjYW5JbmRleCxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaSA9PT0gcmVxLmxlbmd0aCAtIDEgJiYgdHJhbnNhY3Rpb24uY29pblNwZWNpZmljIS5sYXN0U2NhbkluZGV4KSB7XG4gICAgICAgIGxhc3RTY2FuSW5kZXggPSB0cmFuc2FjdGlvbi5jb2luU3BlY2lmaWMhLmxhc3RTY2FuSW5kZXggYXMgbnVtYmVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHRyYW5zYWN0aW9uczogYnJvYWRjYXN0YWJsZVRyYW5zYWN0aW9ucywgbGFzdFNjYW5JbmRleCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R29cbiAgICogQHBhcmFtIHtTb2xSZWNvdmVyeU9wdGlvbnN9IHBhcmFtcyBwYXJhbWV0ZXJzIG5lZWRlZCB0byBjb25zdHJ1Y3QgYW5kXG4gICAqIChtYXliZSkgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge01QQ1R4IHwgTVBDU3dlZXBUeHN9IHRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIGhleCBzdHJpbmcgYW5kIGluZGV4XG4gICAqIG9mIHRoZSBhZGRyZXNzIGJlaW5nIHN3ZXB0XG4gICAqL1xuICBhc3luYyByZWNvdmVyKHBhcmFtczogU29sUmVjb3ZlcnlPcHRpb25zKTogUHJvbWlzZTxNUENUeCB8IE1QQ1N3ZWVwVHhzPiB7XG4gICAgaWYgKCFwYXJhbXMuYml0Z29LZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBiaXRnb0tleScpO1xuICAgIH1cblxuICAgIGlmICghcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24gfHwgIXRoaXMuaXNWYWxpZEFkZHJlc3MocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVjb3ZlcnlEZXN0aW5hdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IGJpdGdvS2V5ID0gcGFyYW1zLmJpdGdvS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gIXBhcmFtcy51c2VyS2V5ICYmICFwYXJhbXMuYmFja3VwS2V5ICYmICFwYXJhbXMud2FsbGV0UGFzc3BocmFzZTtcblxuICAgIC8vIEJ1aWxkIHRoZSB0cmFuc2FjdGlvblxuICAgIGNvbnN0IE1QQyA9IGF3YWl0IEVERFNBTWV0aG9kcy5nZXRJbml0aWFsaXplZE1wY0luc3RhbmNlKCk7XG4gICAgbGV0IGJhbGFuY2UgPSAwO1xuICAgIGNvbnN0IGZlZVBlclNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuZ2V0RmVlcygpO1xuICAgIGNvbnN0IGJhc2VGZWUgPSBwYXJhbXMuZHVyYWJsZU5vbmNlID8gZmVlUGVyU2lnbmF0dXJlICogMiA6IGZlZVBlclNpZ25hdHVyZTtcbiAgICBsZXQgdG90YWxGZWUgPSBuZXcgQmlnTnVtYmVyKGJhc2VGZWUpO1xuXG4gICAgY29uc3QgaW5kZXggPSBwYXJhbXMuaW5kZXggfHwgMDtcbiAgICBjb25zdCBjdXJyUGF0aCA9IHBhcmFtcy5zZWVkID8gZ2V0RGVyaXZhdGlvblBhdGgocGFyYW1zLnNlZWQpICsgYC8ke2luZGV4fWAgOiBgbS8ke2luZGV4fWA7XG4gICAgY29uc3QgYWNjb3VudElkID0gTVBDLmRlcml2ZVVuaGFyZGVuZWQoYml0Z29LZXksIGN1cnJQYXRoKS5zbGljZSgwLCA2NCk7XG4gICAgY29uc3QgYnM1OEVuY29kZWRQdWJsaWNLZXkgPSBuZXcgU29sS2V5UGFpcih7IHB1YjogYWNjb3VudElkIH0pLmdldEFkZHJlc3MoKTtcblxuICAgIGJhbGFuY2UgPSBhd2FpdCB0aGlzLmdldEFjY291bnRCYWxhbmNlKGJzNThFbmNvZGVkUHVibGljS2V5KTtcbiAgICBpZiAodG90YWxGZWUuZ3QoYmFsYW5jZSkpIHtcbiAgICAgIHRocm93IEVycm9yKCdEaWQgbm90IGZpbmQgYWRkcmVzcyB3aXRoIGZ1bmRzIHRvIHJlY292ZXInKTtcbiAgICB9XG5cbiAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5nZXRCdWlsZGVyKCk7XG4gICAgY29uc3Qgd2FsbGV0Q29pbiA9IHRoaXMuZ2V0Q2hhaW4oKTtcblxuICAgIGxldCB0eEJ1aWxkZXI7XG4gICAgbGV0IGJsb2NraGFzaCA9IGF3YWl0IHRoaXMuZ2V0QmxvY2toYXNoKCk7XG4gICAgbGV0IHJlbnRFeGVtcHRBbW91bnQ7XG4gICAgbGV0IGF1dGhvcml0eSA9ICcnO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBjbG9zZUFUQSByZWNvdmVyeVxuICAgIGlmIChwYXJhbXMuY2xvc2VBdGFBZGRyZXNzKSB7XG4gICAgICBpZiAoIXBhcmFtcy5jbG9zZUF0YUFkZHJlc3MgfHwgIXRoaXMuaXNWYWxpZEFkZHJlc3MocGFyYW1zLmNsb3NlQXRhQWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNsb3NlQXRhQWRkcmVzcycpO1xuICAgICAgfVxuXG4gICAgICBiYWxhbmNlID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50QmFsYW5jZShwYXJhbXMuY2xvc2VBdGFBZGRyZXNzKTtcbiAgICAgIGlmIChiYWxhbmNlIDw9IDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0RpZCBub3QgZmluZCBjbG9zZUF0YUFkZHJlc3Mgd2l0aCBzb2wgZnVuZHMgdG8gcmVjb3ZlcicpO1xuICAgICAgfVxuXG4gICAgICByZW50RXhlbXB0QW1vdW50ID0gYXdhaXQgdGhpcy5nZXRSZW50RXhlbXB0QW1vdW50KCk7XG5cbiAgICAgIGNvbnN0IGF0YUNsb3NlQnVpbGRlciA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdHhCdWlsZGVyID0gZmFjdG9yeS5nZXRDbG9zZUF0YUluaXRpYWxpemF0aW9uQnVpbGRlcigpO1xuICAgICAgICB0eEJ1aWxkZXIubm9uY2UoYmxvY2toYXNoKTtcbiAgICAgICAgdHhCdWlsZGVyLnNlbmRlcihiczU4RW5jb2RlZFB1YmxpY0tleSk7XG4gICAgICAgIHR4QnVpbGRlci5hY2NvdW50QWRkcmVzcyhwYXJhbXMuY2xvc2VBdGFBZGRyZXNzID8/ICcnKTtcbiAgICAgICAgdHhCdWlsZGVyLmRlc3RpbmF0aW9uQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbik7XG4gICAgICAgIHR4QnVpbGRlci5hdXRob3JpdHlBZGRyZXNzKGJzNThFbmNvZGVkUHVibGljS2V5KTtcbiAgICAgICAgdHhCdWlsZGVyLmFzc29jaWF0ZWRUb2tlbkFjY291bnRSZW50KHJlbnRFeGVtcHRBbW91bnQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0eEJ1aWxkZXI7XG4gICAgICB9O1xuICAgICAgdHhCdWlsZGVyID0gYXRhQ2xvc2VCdWlsZGVyKCk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5kdXJhYmxlTm9uY2UpIHtcbiAgICAgIGNvbnN0IGR1cmFibGVOb25jZUluZm8gPSBhd2FpdCB0aGlzLmdldEFjY291bnRJbmZvKHBhcmFtcy5kdXJhYmxlTm9uY2UucHVibGljS2V5KTtcbiAgICAgIGJsb2NraGFzaCA9IGR1cmFibGVOb25jZUluZm8uYmxvY2toYXNoO1xuICAgICAgYXV0aG9yaXR5ID0gZHVyYWJsZU5vbmNlSW5mby5hdXRob3JpdHk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIHBvc3NpYmxlIHRva2VuIHJlY292ZXJ5LCByZWNvdmVyIHRoZSB0b2tlbiBwcm92aWRlIGJ5IHVzZXJcbiAgICBpZiAocGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzKSB7XG4gICAgICBjb25zdCB0b2tlbkFjY291bnRzID0gYXdhaXQgdGhpcy5nZXRUb2tlbkFjY291bnRzQnlPd25lcihiczU4RW5jb2RlZFB1YmxpY0tleSk7XG4gICAgICBpZiAodG9rZW5BY2NvdW50cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgLy8gdGhlcmUgZXhpc3RzIHRva2VuIGFjY291bnRzIG9uIHRoZSBnaXZlbiBhZGRyZXNzLCBidXQgbmVlZCB0byBjaGVjayBjZXJ0YWluIGNvbmRpdGlvbnM6XG4gICAgICAgIC8vIDEuIGlmIHRoZXJlIGlzIGEgcmVjb3ZlcmFibGUgYmFsYW5jZVxuICAgICAgICAvLyAyLiBpZiB0aGUgdG9rZW4gaXMgc3VwcG9ydGVkIGJ5IGJpdGdvXG4gICAgICAgIGNvbnN0IHJlY292ZXJlYWJsZVRva2VuQWNjb3VudHM6IFRva2VuQWNjb3VudFtdID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW5BY2NvdW50IG9mIHRva2VuQWNjb3VudHMpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzID09PSB0b2tlbkFjY291bnQuaW5mby5taW50KSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkFtb3VudCA9IG5ldyBCaWdOdW1iZXIodG9rZW5BY2NvdW50LmluZm8udG9rZW5BbW91bnQuYW1vdW50KTtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gZ2V0U29sVG9rZW5Gcm9tQWRkcmVzcyh0b2tlbkFjY291bnQuaW5mby5taW50LCBuZXR3b3JrKTtcblxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRva2VuKSAmJiB0b2tlbkFtb3VudC5ndChuZXcgQmlnTnVtYmVyKDApKSkge1xuICAgICAgICAgICAgICB0b2tlbkFjY291bnQudG9rZW5OYW1lID0gdG9rZW4ubmFtZTtcbiAgICAgICAgICAgICAgcmVjb3ZlcmVhYmxlVG9rZW5BY2NvdW50cy5wdXNoKHRva2VuQWNjb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb3ZlcmVhYmxlVG9rZW5BY2NvdW50cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICByZW50RXhlbXB0QW1vdW50ID0gYXdhaXQgdGhpcy5nZXRSZW50RXhlbXB0QW1vdW50KCk7XG5cbiAgICAgICAgICB0eEJ1aWxkZXIgPSBmYWN0b3J5XG4gICAgICAgICAgICAuZ2V0VG9rZW5UcmFuc2ZlckJ1aWxkZXIoKVxuICAgICAgICAgICAgLm5vbmNlKGJsb2NraGFzaClcbiAgICAgICAgICAgIC5zZW5kZXIoYnM1OEVuY29kZWRQdWJsaWNLZXkpXG4gICAgICAgICAgICAuZmVlKHsgYW1vdW50OiBmZWVQZXJTaWduYXR1cmUgfSlcbiAgICAgICAgICAgIC5hc3NvY2lhdGVkVG9rZW5BY2NvdW50UmVudChyZW50RXhlbXB0QW1vdW50LnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAuZmVlUGF5ZXIoYnM1OEVuY29kZWRQdWJsaWNLZXkpO1xuXG4gICAgICAgICAgLy8gbmVlZCB0byBnZXQgYWxsIHRva2VuIGFjY291bnRzIG9mIHRoZSByZWNpcGllbnQgYWRkcmVzcyBhbmQgbmVlZCB0byBjcmVhdGUgdGhlbSBpZiB0aGV5IGRvIG5vdCBleGlzdFxuICAgICAgICAgIGNvbnN0IHJlY2lwaWVudFRva2VuQWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldFRva2VuQWNjb3VudHNCeU93bmVyKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKTtcblxuICAgICAgICAgIGZvciAoY29uc3QgdG9rZW5BY2NvdW50IG9mIHJlY292ZXJlYWJsZVRva2VuQWNjb3VudHMpIHtcbiAgICAgICAgICAgIGxldCByZWNpcGllbnRUb2tlbkFjY291bnRFeGlzdHMgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVjaXBpZW50VG9rZW5BY2NvdW50IG9mIHJlY2lwaWVudFRva2VuQWNjb3VudHMgYXMgVG9rZW5BY2NvdW50W10pIHtcbiAgICAgICAgICAgICAgaWYgKHJlY2lwaWVudFRva2VuQWNjb3VudC5pbmZvLm1pbnQgPT09IHRva2VuQWNjb3VudC5pbmZvLm1pbnQpIHtcbiAgICAgICAgICAgICAgICByZWNpcGllbnRUb2tlbkFjY291bnRFeGlzdHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlY2lwaWVudFRva2VuQWNjb3VudCA9IGF3YWl0IGdldEFzc29jaWF0ZWRUb2tlbkFjY291bnRBZGRyZXNzKFxuICAgICAgICAgICAgICB0b2tlbkFjY291bnQuaW5mby5taW50LFxuICAgICAgICAgICAgICBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuTmFtZSA9IHRva2VuQWNjb3VudC50b2tlbk5hbWUgYXMgc3RyaW5nO1xuICAgICAgICAgICAgdHhCdWlsZGVyLnNlbmQoe1xuICAgICAgICAgICAgICBhZGRyZXNzOiByZWNpcGllbnRUb2tlbkFjY291bnQsXG4gICAgICAgICAgICAgIGFtb3VudDogdG9rZW5BY2NvdW50LmluZm8udG9rZW5BbW91bnQuYW1vdW50LFxuICAgICAgICAgICAgICB0b2tlbk5hbWU6IHRva2VuTmFtZSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXJlY2lwaWVudFRva2VuQWNjb3VudEV4aXN0cykge1xuICAgICAgICAgICAgICAvLyByZWNpcGllbnQgdG9rZW4gYWNjb3VudCBkb2VzIG5vdCBleGlzdCBmb3IgdG9rZW4gYW5kIG11c3QgYmUgY3JlYXRlZFxuICAgICAgICAgICAgICB0eEJ1aWxkZXIuY3JlYXRlQXNzb2NpYXRlZFRva2VuQWNjb3VudCh7XG4gICAgICAgICAgICAgICAgb3duZXJBZGRyZXNzOiBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICB0b2tlbk5hbWU6IHRva2VuTmFtZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIC8vIGFkZCByZW50IGV4ZW1wdCBhbW91bnQgdG8gdG90YWwgZmVlIGZvciBlYWNoIHRva2VuIGFjY291bnQgdGhhdCBoYXMgdG8gYmUgY3JlYXRlZFxuICAgICAgICAgICAgICB0b3RhbEZlZSA9IHRvdGFsRmVlLnBsdXMocmVudEV4ZW1wdEFtb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdGhlcmUgYXJlIHJlY292ZXJhYmxlIHRva2VuIGFjY291bnRzLCBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHN1ZmZpY2llbnQgbmF0aXZlIHNvbGFuYSB0byByZWNvdmVyIHRva2Vuc1xuICAgICAgICAgIGlmIChuZXcgQmlnTnVtYmVyKGJhbGFuY2UpLmx0KHRvdGFsRmVlKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICdOb3QgZW5vdWdoIGZ1bmRzIHRvIHBheSBmb3IgcmVjb3ZlciB0b2tlbnMgZmVlcywgaGF2ZTogJyArIGJhbGFuY2UgKyAnIG5lZWQ6ICcgKyB0b3RhbEZlZS50b1N0cmluZygpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignTm90IGVub3VnaCB0b2tlbiBmdW5kcyB0byByZWNvdmVyJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZXJlIGFyZSBubyByZWNvdmVyYWJsZSB0b2tlbiBhY2NvdW50cyAsIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgYXJlIHRva2VucyB0byByZWNvdmVyXG4gICAgICAgIHRocm93IEVycm9yKCdEaWQgbm90IGZpbmQgdG9rZW4gYWNjb3VudCB0byByZWNvdmVyIHRva2VucywgcGxlYXNlIGNoZWNrIHRva2VuIGFjY291bnQnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmV0QW1vdW50ID0gbmV3IEJpZ051bWJlcihiYWxhbmNlKS5taW51cyh0b3RhbEZlZSk7XG5cbiAgICAgIHR4QnVpbGRlciA9IGZhY3RvcnlcbiAgICAgICAgLmdldFRyYW5zZmVyQnVpbGRlcigpXG4gICAgICAgIC5ub25jZShibG9ja2hhc2gpXG4gICAgICAgIC5zZW5kZXIoYnM1OEVuY29kZWRQdWJsaWNLZXkpXG4gICAgICAgIC5zZW5kKHsgYWRkcmVzczogcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24sIGFtb3VudDogbmV0QW1vdW50LnRvU3RyaW5nKCkgfSlcbiAgICAgICAgLmZlZSh7IGFtb3VudDogZmVlUGVyU2lnbmF0dXJlIH0pXG4gICAgICAgIC5mZWVQYXllcihiczU4RW5jb2RlZFB1YmxpY0tleSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5kdXJhYmxlTm9uY2UpIHtcbiAgICAgIHR4QnVpbGRlci5ub25jZShibG9ja2hhc2gsIHtcbiAgICAgICAgd2FsbGV0Tm9uY2VBZGRyZXNzOiBwYXJhbXMuZHVyYWJsZU5vbmNlLnB1YmxpY0tleSxcbiAgICAgICAgYXV0aFdhbGxldEFkZHJlc3M6IGF1dGhvcml0eSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAvLyBTaWduIHRoZSB0eG5cbiAgICAgIGlmICghcGFyYW1zLnVzZXJLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHVzZXJLZXknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXJhbXMuYmFja3VwS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBiYWNrdXBLZXknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgd2FsbGV0IHBhc3NwaHJhc2UnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdW5zaWduZWRUcmFuc2FjdGlvbiA9IChhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKSkgYXMgVHJhbnNhY3Rpb247XG5cbiAgICAgIGNvbnN0IHVzZXJLZXkgPSBwYXJhbXMudXNlcktleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgICAgY29uc3QgYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuXG4gICAgICAvLyBEZWNyeXB0IHByaXZhdGUga2V5cyBmcm9tIEtleUNhcmQgdmFsdWVzXG4gICAgICBsZXQgdXNlclBydjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdXNlclBydiA9IHRoaXMuYml0Z28uZGVjcnlwdCh7XG4gICAgICAgICAgaW5wdXQ6IHVzZXJLZXksXG4gICAgICAgICAgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBkZWNyeXB0aW5nIHVzZXIga2V5Y2hhaW46ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1c2VyU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZSh1c2VyUHJ2KSBhcyBFRERTQU1ldGhvZFR5cGVzLlVzZXJTaWduaW5nTWF0ZXJpYWw7XG5cbiAgICAgIGxldCBiYWNrdXBQcnY7XG4gICAgICB0cnkge1xuICAgICAgICBiYWNrdXBQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICAgIGlucHV0OiBiYWNrdXBLZXksXG4gICAgICAgICAgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBkZWNyeXB0aW5nIGJhY2t1cCBrZXljaGFpbjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBiYWNrdXBTaWduaW5nTWF0ZXJpYWwgPSBKU09OLnBhcnNlKGJhY2t1cFBydikgYXMgRUREU0FNZXRob2RUeXBlcy5CYWNrdXBTaWduaW5nTWF0ZXJpYWw7XG5cbiAgICAgIGNvbnN0IHNpZ25hdHVyZUhleCA9IGF3YWl0IEVERFNBTWV0aG9kcy5nZXRUU1NTaWduYXR1cmUoXG4gICAgICAgIHVzZXJTaWduaW5nTWF0ZXJpYWwsXG4gICAgICAgIGJhY2t1cFNpZ25pbmdNYXRlcmlhbCxcbiAgICAgICAgY3VyclBhdGgsXG4gICAgICAgIHVuc2lnbmVkVHJhbnNhY3Rpb25cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHB1YmxpY0tleU9iaiA9IHsgcHViOiBiczU4RW5jb2RlZFB1YmxpY0tleSB9O1xuICAgICAgdHhCdWlsZGVyLmFkZFNpZ25hdHVyZShwdWJsaWNLZXlPYmogYXMgUHVibGljS2V5LCBzaWduYXR1cmVIZXgpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuZHVyYWJsZU5vbmNlKSB7XG4gICAgICAvLyBhZGQgZHVyYWJsZSBub25jZSBhY2NvdW50IHNpZ25hdHVyZVxuICAgICAgdHhCdWlsZGVyLnNpZ24oeyBrZXk6IHBhcmFtcy5kdXJhYmxlTm9uY2Uuc2VjcmV0S2V5IH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXBsZXRlZFRyYW5zYWN0aW9uID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZFR4ID0gY29tcGxldGVkVHJhbnNhY3Rpb24udG9Ccm9hZGNhc3RGb3JtYXQoKTtcbiAgICBjb25zdCBkZXJpdmF0aW9uUGF0aCA9IHBhcmFtcy5zZWVkID8gZ2V0RGVyaXZhdGlvblBhdGgocGFyYW1zLnNlZWQpICsgYC8ke2luZGV4fWAgOiBgbS8ke2luZGV4fWA7XG4gICAgY29uc3QgaW5wdXRzOiBPdmNJbnB1dFtdID0gW107XG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBjb21wbGV0ZWRUcmFuc2FjdGlvbi5pbnB1dHMpIHtcbiAgICAgIGlucHV0cy5wdXNoKHtcbiAgICAgICAgYWRkcmVzczogaW5wdXQuYWRkcmVzcyxcbiAgICAgICAgdmFsdWVTdHJpbmc6IGlucHV0LnZhbHVlLFxuICAgICAgICB2YWx1ZTogbmV3IEJpZ051bWJlcihpbnB1dC52YWx1ZSkudG9OdW1iZXIoKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXRzOiBPdmNPdXRwdXRbXSA9IFtdO1xuICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIGNvbXBsZXRlZFRyYW5zYWN0aW9uLm91dHB1dHMpIHtcbiAgICAgIG91dHB1dHMucHVzaCh7XG4gICAgICAgIGFkZHJlc3M6IG91dHB1dC5hZGRyZXNzLFxuICAgICAgICB2YWx1ZVN0cmluZzogb3V0cHV0LnZhbHVlLFxuICAgICAgICBjb2luTmFtZTogb3V0cHV0LmNvaW4gPyBvdXRwdXQuY29pbiA6IHdhbGxldENvaW4sXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc3BlbmRBbW91bnQgPSBjb21wbGV0ZWRUcmFuc2FjdGlvbi5pbnB1dHMubGVuZ3RoID09PSAxID8gY29tcGxldGVkVHJhbnNhY3Rpb24uaW5wdXRzWzBdLnZhbHVlIDogMDtcbiAgICBjb25zdCBwYXJzZWRUeCA9IHsgaW5wdXRzOiBpbnB1dHMsIG91dHB1dHM6IG91dHB1dHMsIHNwZW5kQW1vdW50OiBzcGVuZEFtb3VudCwgdHlwZTogJycgfTtcbiAgICBjb25zdCBmZWVJbmZvID0geyBmZWU6IHRvdGFsRmVlLnRvTnVtYmVyKCksIGZlZVN0cmluZzogdG90YWxGZWUudG9TdHJpbmcoKSB9O1xuICAgIGNvbnN0IGNvaW5TcGVjaWZpYyA9IHsgY29tbW9uS2V5Y2hhaW46IGJpdGdvS2V5IH07XG4gICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb246IE1QQ1R4ID0ge1xuICAgICAgICBzZXJpYWxpemVkVHg6IHNlcmlhbGl6ZWRUeCxcbiAgICAgICAgc2NhbkluZGV4OiBpbmRleCxcbiAgICAgICAgY29pbjogd2FsbGV0Q29pbixcbiAgICAgICAgc2lnbmFibGVIZXg6IGNvbXBsZXRlZFRyYW5zYWN0aW9uLnNpZ25hYmxlUGF5bG9hZC50b1N0cmluZygnaGV4JyksXG4gICAgICAgIGRlcml2YXRpb25QYXRoOiBkZXJpdmF0aW9uUGF0aCxcbiAgICAgICAgcGFyc2VkVHg6IHBhcnNlZFR4LFxuICAgICAgICBmZWVJbmZvOiBmZWVJbmZvLFxuICAgICAgICBjb2luU3BlY2lmaWM6IGNvaW5TcGVjaWZpYyxcbiAgICAgIH07XG4gICAgICBjb25zdCB1bnNpZ25lZFR4OiBNUENVbnNpZ25lZFR4ID0geyB1bnNpZ25lZFR4OiB0cmFuc2FjdGlvbiwgc2lnbmF0dXJlU2hhcmVzOiBbXSB9O1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25zOiBNUENVbnNpZ25lZFR4W10gPSBbdW5zaWduZWRUeF07XG4gICAgICBjb25zdCB0eFJlcXVlc3Q6IFJlY292ZXJ5VHhSZXF1ZXN0ID0ge1xuICAgICAgICB0cmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9ucyxcbiAgICAgICAgd2FsbGV0Q29pbjogd2FsbGV0Q29pbixcbiAgICAgIH07XG4gICAgICBjb25zdCB0eFJlcXVlc3RzOiBNUENTd2VlcFR4cyA9IHsgdHhSZXF1ZXN0czogW3R4UmVxdWVzdF0gfTtcbiAgICAgIHJldHVybiB0eFJlcXVlc3RzO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2FjdGlvbjogTVBDVHggPSB7XG4gICAgICBzZXJpYWxpemVkVHg6IHNlcmlhbGl6ZWRUeCxcbiAgICAgIHNjYW5JbmRleDogaW5kZXgsXG4gICAgfTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHb1xuICAgKiBAcGFyYW0ge1NvbFJlY292ZXJ5T3B0aW9uc30gcGFyYW1zIHBhcmFtZXRlcnMgbmVlZGVkIHRvIGNvbnN0cnVjdCBhbmRcbiAgICogKG1heWJlKSBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7TVBDVHggfCBNUENTd2VlcFR4c30gdGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gaGV4IHN0cmluZyBhbmQgaW5kZXhcbiAgICogb2YgdGhlIGFkZHJlc3MgYmVpbmcgc3dlcHRcbiAgICovXG4gIGFzeW5jIHJlY292ZXJDbG9zZUFUQShwYXJhbXM6IFNvbFJlY292ZXJ5T3B0aW9ucyk6IFByb21pc2U8TVBDVHggfCBNUENTd2VlcFR4cz4ge1xuICAgIGlmICghcGFyYW1zLmJpdGdvS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYml0Z29LZXknKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uIHx8ICF0aGlzLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlY292ZXJ5RGVzdGluYXRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5jbG9zZUF0YUFkZHJlc3MgfHwgIXRoaXMuaXNWYWxpZEFkZHJlc3MocGFyYW1zLmNsb3NlQXRhQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjbG9zZUF0YUFkZHJlc3MnKTtcbiAgICB9XG5cbiAgICBjb25zdCBiaXRnb0tleSA9IHBhcmFtcy5iaXRnb0tleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgIGNvbnN0IGlzVW5zaWduZWRTd2VlcCA9ICFwYXJhbXMudXNlcktleSAmJiAhcGFyYW1zLmJhY2t1cEtleSAmJiAhcGFyYW1zLndhbGxldFBhc3NwaHJhc2U7XG5cbiAgICAvLyBCdWlsZCB0aGUgdHJhbnNhY3Rpb25cbiAgICBjb25zdCBNUEMgPSBhd2FpdCBFRERTQU1ldGhvZHMuZ2V0SW5pdGlhbGl6ZWRNcGNJbnN0YW5jZSgpO1xuICAgIGxldCBiYWxhbmNlID0gMDtcbiAgICBjb25zdCBmZWVQZXJTaWduYXR1cmUgPSBhd2FpdCB0aGlzLmdldEZlZXMoKTtcbiAgICBjb25zdCBiYXNlRmVlID0gcGFyYW1zLmR1cmFibGVOb25jZSA/IGZlZVBlclNpZ25hdHVyZSAqIDIgOiBmZWVQZXJTaWduYXR1cmU7XG4gICAgY29uc3QgdG90YWxGZWUgPSBuZXcgQmlnTnVtYmVyKGJhc2VGZWUpO1xuXG4gICAgY29uc3QgaW5kZXggPSBwYXJhbXMuaW5kZXggfHwgMDtcbiAgICBjb25zdCBjdXJyUGF0aCA9IHBhcmFtcy5zZWVkID8gZ2V0RGVyaXZhdGlvblBhdGgocGFyYW1zLnNlZWQpICsgYC8ke2luZGV4fWAgOiBgbS8ke2luZGV4fWA7XG4gICAgY29uc3QgYWNjb3VudElkID0gTVBDLmRlcml2ZVVuaGFyZGVuZWQoYml0Z29LZXksIGN1cnJQYXRoKS5zbGljZSgwLCA2NCk7XG4gICAgY29uc3QgYnM1OEVuY29kZWRQdWJsaWNLZXkgPSBuZXcgU29sS2V5UGFpcih7IHB1YjogYWNjb3VudElkIH0pLmdldEFkZHJlc3MoKTtcblxuICAgIGJhbGFuY2UgPSBhd2FpdCB0aGlzLmdldEFjY291bnRCYWxhbmNlKGJzNThFbmNvZGVkUHVibGljS2V5KTtcbiAgICBpZiAodG90YWxGZWUuZ3QoYmFsYW5jZSkpIHtcbiAgICAgIHRocm93IEVycm9yKCdEaWQgbm90IGZpbmQgYWRkcmVzcyB3aXRoIGZ1bmRzIHRvIHJlY292ZXInKTtcbiAgICB9XG5cbiAgICBiYWxhbmNlID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50QmFsYW5jZShwYXJhbXMuY2xvc2VBdGFBZGRyZXNzKTtcbiAgICBpZiAoYmFsYW5jZSA8PSAwKSB7XG4gICAgICB0aHJvdyBFcnJvcignRGlkIG5vdCBmaW5kIGNsb3NlQXRhQWRkcmVzcyB3aXRoIHNvbCBmdW5kcyB0byByZWNvdmVyJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuZ2V0QnVpbGRlcigpO1xuICAgIGNvbnN0IHdhbGxldENvaW4gPSB0aGlzLmdldENoYWluKCk7XG5cbiAgICBsZXQgdHhCdWlsZGVyO1xuICAgIGNvbnN0IGJsb2NraGFzaCA9IGF3YWl0IHRoaXMuZ2V0QmxvY2toYXNoKCk7XG5cbiAgICBjb25zdCByZW50RXhlbXB0QW1vdW50ID0gYXdhaXQgdGhpcy5nZXRSZW50RXhlbXB0QW1vdW50KCk7XG5cbiAgICAvLyBpZiB0aGlzIGlzIGNsb3NlQVRBIHJlY292ZXJ5XG4gICAgaWYgKHBhcmFtcy5jbG9zZUF0YUFkZHJlc3MpIHtcbiAgICAgIGNvbnN0IGF0YUNsb3NlQnVpbGRlciA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdHhCdWlsZGVyID0gZmFjdG9yeS5nZXRDbG9zZUF0YUluaXRpYWxpemF0aW9uQnVpbGRlcigpO1xuICAgICAgICB0eEJ1aWxkZXIubm9uY2UoYmxvY2toYXNoKTtcbiAgICAgICAgdHhCdWlsZGVyLnNlbmRlcihiczU4RW5jb2RlZFB1YmxpY0tleSk7XG4gICAgICAgIHR4QnVpbGRlci5hY2NvdW50QWRkcmVzcyhwYXJhbXMuY2xvc2VBdGFBZGRyZXNzID8/ICcnKTtcbiAgICAgICAgdHhCdWlsZGVyLmRlc3RpbmF0aW9uQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbik7XG4gICAgICAgIHR4QnVpbGRlci5hdXRob3JpdHlBZGRyZXNzKGJzNThFbmNvZGVkUHVibGljS2V5KTtcbiAgICAgICAgdHhCdWlsZGVyLmFzc29jaWF0ZWRUb2tlbkFjY291bnRSZW50KHJlbnRFeGVtcHRBbW91bnQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0eEJ1aWxkZXI7XG4gICAgICB9O1xuICAgICAgdHhCdWlsZGVyID0gYXRhQ2xvc2VCdWlsZGVyKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgIC8vIFNpZ24gdGhlIHR4blxuICAgICAgaWYgKCFwYXJhbXMudXNlcktleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdXNlcktleScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhcmFtcy5iYWNrdXBLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGJhY2t1cEtleScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB3YWxsZXQgcGFzc3BocmFzZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1bnNpZ25lZFRyYW5zYWN0aW9uID0gKGF3YWl0IHR4QnVpbGRlci5idWlsZCgpKSBhcyBUcmFuc2FjdGlvbjtcblxuICAgICAgY29uc3QgdXNlcktleSA9IHBhcmFtcy51c2VyS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICBjb25zdCBiYWNrdXBLZXkgPSBwYXJhbXMuYmFja3VwS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cbiAgICAgIC8vIERlY3J5cHQgcHJpdmF0ZSBrZXlzIGZyb20gS2V5Q2FyZCB2YWx1ZXNcbiAgICAgIGxldCB1c2VyUHJ2O1xuXG4gICAgICB0cnkge1xuICAgICAgICB1c2VyUHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgICBpbnB1dDogdXNlcktleSxcbiAgICAgICAgICBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY3J5cHRpbmcgdXNlciBrZXljaGFpbjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVzZXJTaWduaW5nTWF0ZXJpYWwgPSBKU09OLnBhcnNlKHVzZXJQcnYpIGFzIEVERFNBTWV0aG9kVHlwZXMuVXNlclNpZ25pbmdNYXRlcmlhbDtcblxuICAgICAgbGV0IGJhY2t1cFBydjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGJhY2t1cFBydiA9IHRoaXMuYml0Z28uZGVjcnlwdCh7XG4gICAgICAgICAgaW5wdXQ6IGJhY2t1cEtleSxcbiAgICAgICAgICBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY3J5cHRpbmcgYmFja3VwIGtleWNoYWluOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJhY2t1cFNpZ25pbmdNYXRlcmlhbCA9IEpTT04ucGFyc2UoYmFja3VwUHJ2KSBhcyBFRERTQU1ldGhvZFR5cGVzLkJhY2t1cFNpZ25pbmdNYXRlcmlhbDtcblxuICAgICAgY29uc3Qgc2lnbmF0dXJlSGV4ID0gYXdhaXQgRUREU0FNZXRob2RzLmdldFRTU1NpZ25hdHVyZShcbiAgICAgICAgdXNlclNpZ25pbmdNYXRlcmlhbCxcbiAgICAgICAgYmFja3VwU2lnbmluZ01hdGVyaWFsLFxuICAgICAgICBjdXJyUGF0aCxcbiAgICAgICAgdW5zaWduZWRUcmFuc2FjdGlvblxuICAgICAgKTtcblxuICAgICAgY29uc3QgcHVibGljS2V5T2JqID0geyBwdWI6IGJzNThFbmNvZGVkUHVibGljS2V5IH07XG4gICAgICB0eEJ1aWxkZXIuYWRkU2lnbmF0dXJlKHB1YmxpY0tleU9iaiBhcyBQdWJsaWNLZXksIHNpZ25hdHVyZUhleCk7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcGxldGVkVHJhbnNhY3Rpb24gPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICBjb25zdCBzZXJpYWxpemVkVHggPSBjb21wbGV0ZWRUcmFuc2FjdGlvbi50b0Jyb2FkY2FzdEZvcm1hdCgpO1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoID0gcGFyYW1zLnNlZWQgPyBnZXREZXJpdmF0aW9uUGF0aChwYXJhbXMuc2VlZCkgKyBgLyR7aW5kZXh9YCA6IGBtLyR7aW5kZXh9YDtcbiAgICBjb25zdCBpbnB1dHM6IE92Y0lucHV0W10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGNvbXBsZXRlZFRyYW5zYWN0aW9uLmlucHV0cykge1xuICAgICAgaW5wdXRzLnB1c2goe1xuICAgICAgICBhZGRyZXNzOiBpbnB1dC5hZGRyZXNzLFxuICAgICAgICB2YWx1ZVN0cmluZzogaW5wdXQudmFsdWUsXG4gICAgICAgIHZhbHVlOiBuZXcgQmlnTnVtYmVyKGlucHV0LnZhbHVlKS50b051bWJlcigpLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dHM6IE92Y091dHB1dFtdID0gW107XG4gICAgZm9yIChjb25zdCBvdXRwdXQgb2YgY29tcGxldGVkVHJhbnNhY3Rpb24ub3V0cHV0cykge1xuICAgICAgb3V0cHV0cy5wdXNoKHtcbiAgICAgICAgYWRkcmVzczogb3V0cHV0LmFkZHJlc3MsXG4gICAgICAgIHZhbHVlU3RyaW5nOiBvdXRwdXQudmFsdWUsXG4gICAgICAgIGNvaW5OYW1lOiBvdXRwdXQuY29pbiA/IG91dHB1dC5jb2luIDogd2FsbGV0Q29pbixcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzcGVuZEFtb3VudCA9IGNvbXBsZXRlZFRyYW5zYWN0aW9uLmlucHV0cy5sZW5ndGggPT09IDEgPyBjb21wbGV0ZWRUcmFuc2FjdGlvbi5pbnB1dHNbMF0udmFsdWUgOiAwO1xuICAgIGNvbnN0IHBhcnNlZFR4ID0geyBpbnB1dHM6IGlucHV0cywgb3V0cHV0czogb3V0cHV0cywgc3BlbmRBbW91bnQ6IHNwZW5kQW1vdW50LCB0eXBlOiAnJyB9O1xuICAgIGNvbnN0IGZlZUluZm8gPSB7IGZlZTogdG90YWxGZWUudG9OdW1iZXIoKSwgZmVlU3RyaW5nOiB0b3RhbEZlZS50b1N0cmluZygpIH07XG4gICAgY29uc3QgY29pblNwZWNpZmljID0geyBjb21tb25LZXljaGFpbjogYml0Z29LZXkgfTtcbiAgICBpZiAoaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbjogTVBDVHggPSB7XG4gICAgICAgIHNlcmlhbGl6ZWRUeDogc2VyaWFsaXplZFR4LFxuICAgICAgICBzY2FuSW5kZXg6IGluZGV4LFxuICAgICAgICBjb2luOiB3YWxsZXRDb2luLFxuICAgICAgICBzaWduYWJsZUhleDogY29tcGxldGVkVHJhbnNhY3Rpb24uc2lnbmFibGVQYXlsb2FkLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgZGVyaXZhdGlvblBhdGg6IGRlcml2YXRpb25QYXRoLFxuICAgICAgICBwYXJzZWRUeDogcGFyc2VkVHgsXG4gICAgICAgIGZlZUluZm86IGZlZUluZm8sXG4gICAgICAgIGNvaW5TcGVjaWZpYzogY29pblNwZWNpZmljLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHVuc2lnbmVkVHg6IE1QQ1Vuc2lnbmVkVHggPSB7IHVuc2lnbmVkVHg6IHRyYW5zYWN0aW9uLCBzaWduYXR1cmVTaGFyZXM6IFtdIH07XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbnM6IE1QQ1Vuc2lnbmVkVHhbXSA9IFt1bnNpZ25lZFR4XTtcbiAgICAgIGNvbnN0IHR4UmVxdWVzdDogUmVjb3ZlcnlUeFJlcXVlc3QgPSB7XG4gICAgICAgIHRyYW5zYWN0aW9uczogdHJhbnNhY3Rpb25zLFxuICAgICAgICB3YWxsZXRDb2luOiB3YWxsZXRDb2luLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHR4UmVxdWVzdHM6IE1QQ1N3ZWVwVHhzID0geyB0eFJlcXVlc3RzOiBbdHhSZXF1ZXN0XSB9O1xuICAgICAgcmV0dXJuIHR4UmVxdWVzdHM7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uOiBNUENUeCA9IHtcbiAgICAgIHNlcmlhbGl6ZWRUeDogc2VyaWFsaXplZFR4LFxuICAgICAgc2NhbkluZGV4OiBpbmRleCxcbiAgICB9O1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgbmF0aXZlIFNPTCByZWNvdmVyaWVzIG9mIHJlY2VpdmUgYWRkcmVzc2VzIGluIGJhdGNoIHdpdGhvdXQgQml0R28uXG4gICAqIEZ1bmRzIHdpbGwgYmUgcmVjb3ZlcmVkIHRvIGJhc2UgYWRkcmVzcyBmaXJzdC4gWW91IG5lZWQgdG8gaW5pdGlhdGUgYW5vdGhlciBzd2VlcCB0eG4gYWZ0ZXIgdGhhdC5cbiAgICpcbiAgICogQHBhcmFtIHtTb2xDb25zb2xpZGF0aW9uUmVjb3ZlcnlPcHRpb25zfSBwYXJhbXMgLSBvcHRpb25zIGZvciBjb25zb2xpZGF0aW9uIHJlY292ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5zdGFydGluZ1NjYW5JbmRleF0gLSByZWNlaXZlIGFkZHJlc3MgaW5kZXggdG8gc3RhcnQgc2Nhbm5pbmcgZnJvbS4gZGVmYXVsdCB0byAxIChpbmNsdXNpdmUpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5lbmRpbmdTY2FuSW5kZXhdIC0gcmVjZWl2ZSBhZGRyZXNzIGluZGV4IHRvIGVuZCBzY2FubmluZyBhdC4gZGVmYXVsdCB0byBzdGFydGluZ1NjYW5JbmRleCArIDIwIChleGNsdXNpdmUpLlxuICAgKi9cbiAgYXN5bmMgcmVjb3ZlckNvbnNvbGlkYXRpb25zKHBhcmFtczogU29sQ29uc29saWRhdGlvblJlY292ZXJ5T3B0aW9ucyk6IFByb21pc2U8TVBDVHhzIHwgTVBDU3dlZXBUeHM+IHtcbiAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSAhcGFyYW1zLnVzZXJLZXkgJiYgIXBhcmFtcy5iYWNrdXBLZXkgJiYgIXBhcmFtcy53YWxsZXRQYXNzcGhyYXNlO1xuICAgIGNvbnN0IHN0YXJ0SWR4ID0gcGFyYW1zLnN0YXJ0aW5nU2NhbkluZGV4IHx8IDE7XG4gICAgY29uc3QgZW5kSWR4ID0gcGFyYW1zLmVuZGluZ1NjYW5JbmRleCB8fCBzdGFydElkeCArIERFRkFVTFRfU0NBTl9GQUNUT1I7XG5cbiAgICBpZiAoc3RhcnRJZHggPCAxIHx8IGVuZElkeCA8PSBzdGFydElkeCB8fCBlbmRJZHggLSBzdGFydElkeCA+IDEwICogREVGQVVMVF9TQ0FOX0ZBQ1RPUikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBzdGFydGluZyBvciBlbmRpbmcgaW5kZXggdG8gc2NhbiBmb3IgYWRkcmVzc2VzLiBzdGFydGluZ1NjYW5JbmRleDogJHtzdGFydElkeH0sIGVuZGluZ1NjYW5JbmRleDogJHtlbmRJZHh9LmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgZHVyYWJsZSBub25jZXMgYXJyYXlcbiAgICBpZiAoIXBhcmFtcy5kdXJhYmxlTm9uY2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZHVyYWJsZSBub25jZXMnKTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMuZHVyYWJsZU5vbmNlcy5wdWJsaWNLZXlzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZHVyYWJsZSBub25jZXM6IG1pc3NpbmcgcHVibGljIGtleXMnKTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMuZHVyYWJsZU5vbmNlcy5zZWNyZXRLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkdXJhYmxlIG5vbmNlcyBhcnJheTogbWlzc2luZyBzZWNyZXQga2V5Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgYml0Z29LZXkgPSBwYXJhbXMuYml0Z29LZXkucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICBjb25zdCBNUEMgPSBhd2FpdCBFRERTQU1ldGhvZHMuZ2V0SW5pdGlhbGl6ZWRNcGNJbnN0YW5jZSgpO1xuICAgIGNvbnN0IGJhc2VBZGRyZXNzSW5kZXggPSAwO1xuICAgIGNvbnN0IGJhc2VBZGRyZXNzUGF0aCA9IHBhcmFtcy5zZWVkXG4gICAgICA/IGdldERlcml2YXRpb25QYXRoKHBhcmFtcy5zZWVkKSArIGAvJHtiYXNlQWRkcmVzc0luZGV4fWBcbiAgICAgIDogYG0vJHtiYXNlQWRkcmVzc0luZGV4fWA7XG4gICAgY29uc3QgYWNjb3VudElkID0gTVBDLmRlcml2ZVVuaGFyZGVuZWQoYml0Z29LZXksIGJhc2VBZGRyZXNzUGF0aCkuc2xpY2UoMCwgNjQpO1xuICAgIGNvbnN0IGJhc2VBZGRyZXNzID0gbmV3IFNvbEtleVBhaXIoeyBwdWI6IGFjY291bnRJZCB9KS5nZXRBZGRyZXNzKCk7XG5cbiAgICBsZXQgZHVyYWJsZU5vbmNlUHViS2V5c0luZGV4ID0gMDtcbiAgICBjb25zdCBkdXJhYmxlTm9uY2VQdWJLZXlzTGVuZ3RoID0gcGFyYW1zLmR1cmFibGVOb25jZXMucHVibGljS2V5cy5sZW5ndGg7XG4gICAgY29uc3QgY29uc29saWRhdGlvblRyYW5zYWN0aW9uczogYW55W10gPSBbXTtcbiAgICBsZXQgbGFzdFNjYW5JbmRleCA9IHN0YXJ0SWR4O1xuICAgIGZvciAobGV0IGkgPSBzdGFydElkeDsgaSA8IGVuZElkeDsgaSsrKSB7XG4gICAgICBjb25zdCByZWNvdmVyUGFyYW1zID0ge1xuICAgICAgICB1c2VyS2V5OiBwYXJhbXMudXNlcktleSxcbiAgICAgICAgYmFja3VwS2V5OiBwYXJhbXMuYmFja3VwS2V5LFxuICAgICAgICBiaXRnb0tleTogcGFyYW1zLmJpdGdvS2V5LFxuICAgICAgICB3YWxsZXRQYXNzcGhyYXNlOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgcmVjb3ZlcnlEZXN0aW5hdGlvbjogYmFzZUFkZHJlc3MsXG4gICAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgZHVyYWJsZU5vbmNlOiB7XG4gICAgICAgICAgcHVibGljS2V5OiBwYXJhbXMuZHVyYWJsZU5vbmNlcy5wdWJsaWNLZXlzW2R1cmFibGVOb25jZVB1YktleXNJbmRleF0sXG4gICAgICAgICAgc2VjcmV0S2V5OiBwYXJhbXMuZHVyYWJsZU5vbmNlcy5zZWNyZXRLZXksXG4gICAgICAgIH0sXG4gICAgICAgIHRva2VuQ29udHJhY3RBZGRyZXNzOiBwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MsXG4gICAgICB9O1xuXG4gICAgICBsZXQgcmVjb3ZlcnlUcmFuc2FjdGlvbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlY292ZXJ5VHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLnJlY292ZXIocmVjb3ZlclBhcmFtcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBlLm1lc3NhZ2UgPT09ICdEaWQgbm90IGZpbmQgYWRkcmVzcyB3aXRoIGZ1bmRzIHRvIHJlY292ZXInIHx8XG4gICAgICAgICAgZS5tZXNzYWdlID09PSAnRGlkIG5vdCBmaW5kIHRva2VuIGFjY291bnQgdG8gcmVjb3ZlciB0b2tlbnMsIHBsZWFzZSBjaGVjayB0b2tlbiBhY2NvdW50JyB8fFxuICAgICAgICAgIGUubWVzc2FnZSA9PT0gJ05vdCBlbm91Z2ggdG9rZW4gZnVuZHMgdG8gcmVjb3ZlcidcbiAgICAgICAgKSB7XG4gICAgICAgICAgbGFzdFNjYW5JbmRleCA9IGk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICBjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zLnB1c2goKHJlY292ZXJ5VHJhbnNhY3Rpb24gYXMgTVBDU3dlZXBUeHMpLnR4UmVxdWVzdHNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29saWRhdGlvblRyYW5zYWN0aW9ucy5wdXNoKHJlY292ZXJ5VHJhbnNhY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICBsYXN0U2NhbkluZGV4ID0gaTtcbiAgICAgIGR1cmFibGVOb25jZVB1YktleXNJbmRleCsrO1xuICAgICAgaWYgKGR1cmFibGVOb25jZVB1YktleXNJbmRleCA+PSBkdXJhYmxlTm9uY2VQdWJLZXlzTGVuZ3RoKSB7XG4gICAgICAgIC8vIG5vIG1vcmUgYXZhaWxhYmxlIG5vbmNlIGFjY291bnRzIHRvIGNyZWF0ZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgZmluZCBhbiBhZGRyZXNzIHdpdGggZnVuZHMgdG8gcmVjb3ZlcicpO1xuICAgIH1cblxuICAgIGlmIChpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgIC8vIGxhc3RTY2FuSW5kZXggd2lsbCBiZSB1c2VkIHRvIGluZm9ybSB1c2VyIHRoZSBsYXN0IGFkZHJlc3MgaW5kZXggc2Nhbm5lZCBmb3IgYXZhaWxhYmxlIGZ1bmRzIChzbyB0aGV5IGNhblxuICAgICAgLy8gYXBwcm9wcmlhdGVseSBhZGp1c3QgdGhlIHNjYW4gcmFuZ2Ugb24gdGhlIG5leHQgaXRlcmF0aW9uIG9mIGNvbnNvbGlkYXRpb24gcmVjb3ZlcmllcykuIEluIHRoZSBjYXNlIG9mIHVuc2lnbmVkXG4gICAgICAvLyBzd2VlcCBjb25zb2xpZGF0aW9ucywgdGhpcyBsYXN0U2NhbkluZGV4IHdpbGwgYmUgcHJvdmlkZWQgaW4gdGhlIGNvaW5TcGVjaWZpYyBvZiB0aGUgbGFzdCB0eG4gbWFkZS5cbiAgICAgIGNvbnN0IGxhc3RUcmFuc2FjdGlvbkNvaW5TcGVjaWZpYyA9IHtcbiAgICAgICAgY29tbW9uS2V5Y2hhaW46XG4gICAgICAgICAgY29uc29saWRhdGlvblRyYW5zYWN0aW9uc1tjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zLmxlbmd0aCAtIDFdLnRyYW5zYWN0aW9uc1swXS51bnNpZ25lZFR4LmNvaW5TcGVjaWZpY1xuICAgICAgICAgICAgLmNvbW1vbktleWNoYWluLFxuICAgICAgICBsYXN0U2NhbkluZGV4OiBsYXN0U2NhbkluZGV4LFxuICAgICAgfTtcbiAgICAgIGNvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnNbY29uc29saWRhdGlvblRyYW5zYWN0aW9ucy5sZW5ndGggLSAxXS50cmFuc2FjdGlvbnNbMF0udW5zaWduZWRUeC5jb2luU3BlY2lmaWMgPVxuICAgICAgICBsYXN0VHJhbnNhY3Rpb25Db2luU3BlY2lmaWM7XG4gICAgICBjb25zdCBjb25zb2xpZGF0aW9uU3dlZXBUcmFuc2FjdGlvbnM6IE1QQ1N3ZWVwVHhzID0geyB0eFJlcXVlc3RzOiBjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zIH07XG4gICAgICByZXR1cm4gY29uc29saWRhdGlvblN3ZWVwVHJhbnNhY3Rpb25zO1xuICAgIH1cblxuICAgIHJldHVybiB7IHRyYW5zYWN0aW9uczogY29uc29saWRhdGlvblRyYW5zYWN0aW9ucywgbGFzdFNjYW5JbmRleCB9O1xuICB9XG5cbiAgZ2V0VG9rZW5FbmFibGVtZW50Q29uZmlnKCk6IFRva2VuRW5hYmxlbWVudENvbmZpZyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcXVpcmVzVG9rZW5FbmFibGVtZW50OiB0cnVlLFxuICAgICAgc3VwcG9ydHNNdWx0aXBsZVRva2VuRW5hYmxlbWVudHM6IHRydWUsXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0QnVpbGRlcigpOiBUcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5IHtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uQnVpbGRlckZhY3RvcnkoY29pbnMuZ2V0KHRoaXMuZ2V0Q2hhaW4oKSkpO1xuICB9XG5cbiAgYXN5bmMgYnJvYWRjYXN0VHJhbnNhY3Rpb24oe1xuICAgIHNlcmlhbGl6ZWRTaWduZWRUcmFuc2FjdGlvbixcbiAgfTogQmFzZUJyb2FkY2FzdFRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8QmFzZUJyb2FkY2FzdFRyYW5zYWN0aW9uUmVzdWx0PiB7XG4gICAgdmFsaWRhdGVSYXdUcmFuc2FjdGlvbihzZXJpYWxpemVkU2lnbmVkVHJhbnNhY3Rpb24sIHRydWUsIHRydWUpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXREYXRhRnJvbU5vZGUoe1xuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBpZDogJzEnLFxuICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgbWV0aG9kOiAnc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgc2VyaWFsaXplZFNpZ25lZFRyYW5zYWN0aW9uLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVuY29kaW5nOiAnYmFzZTY0JyxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGlmIChyZXNwb25zZS5ib2R5LmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGJyb2FkY2FzdGluZyB0cmFuc2FjdGlvbjogJyArIHJlc3BvbnNlLmJvZHkuZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHhJZDogcmVzcG9uc2UuYm9keS5yZXN1bHQgfTtcbiAgfVxufVxuIl19