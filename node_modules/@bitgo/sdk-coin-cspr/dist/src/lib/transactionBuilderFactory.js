"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilderFactory = void 0;
const casper_js_sdk_1 = require("casper-js-sdk");
const sdk_core_1 = require("@bitgo/sdk-core");
const walletInitializationBuilder_1 = require("./walletInitializationBuilder");
const transferBuilder_1 = require("./transferBuilder");
const transaction_1 = require("./transaction");
const utils_1 = require("./utils");
const delegateBuilder_1 = require("./delegateBuilder");
const undelegateBuilder_1 = require("./undelegateBuilder");
class TransactionBuilderFactory extends sdk_core_1.BaseTransactionBuilderFactory {
    constructor(_coinConfig) {
        super(_coinConfig);
    }
    /** @inheritdoc */
    getWalletInitializationBuilder(tx) {
        return this.initializeBuilder(tx, new walletInitializationBuilder_1.WalletInitializationBuilder(this._coinConfig));
    }
    /**
     * Initialize an undelegate builder
     *
     * @param {Transaction | undefined} tx - the transaction used to initialize the builder
     * @returns {UndelegateBuilder} the builder initialized
     */
    getUndelegateBuilder(tx) {
        return this.initializeBuilder(tx, new undelegateBuilder_1.UndelegateBuilder(this._coinConfig));
    }
    /**
     * Initialize an delegate builder
     *
     * @param {Transaction | undefined} tx - the transaction used to initialize the builder
     * @returns {DelegateBuilder} the builder initialized
     */
    getDelegateBuilder(tx) {
        return this.initializeBuilder(tx, new delegateBuilder_1.DelegateBuilder(this._coinConfig));
    }
    /** @inheritDoc */
    getTransferBuilder(tx) {
        return this.initializeBuilder(tx, new transferBuilder_1.TransferBuilder(this._coinConfig));
    }
    /** @inheritDoc */
    from(raw) {
        this.validateRawTransaction(raw);
        const tx = new transaction_1.Transaction(this._coinConfig);
        const deployJson = JSON.parse(raw);
        try {
            tx.casperTx = casper_js_sdk_1.DeployUtil.deployFromJson(deployJson).unwrap();
        }
        catch (e) {
            throw new sdk_core_1.InvalidTransactionError('Invalid transaction: ' + e);
        }
        const casperDeployType = (0, utils_1.getDeployType)(tx.casperTx.session);
        switch (casperDeployType) {
            case sdk_core_1.TransactionType.Send:
                return this.getTransferBuilder(tx);
            case sdk_core_1.TransactionType.WalletInitialization:
                return this.getWalletInitializationBuilder(tx);
            case sdk_core_1.TransactionType.StakingLock:
                return this.getDelegateBuilder(tx);
            case sdk_core_1.TransactionType.StakingUnlock:
                return this.getUndelegateBuilder(tx);
            default:
                throw new sdk_core_1.InvalidTransactionError('Invalid transaction ' + tx.casperTx);
        }
    }
    /**
     * Initialize the builder with the given transaction
     *
     * @param {Transaction | undefined} tx - the transaction used to initialize the builder
     * @param {TransactionBuilder} builder - the builder to be initialized
     * @returns {TransactionBuilder} the builder initialized
     */
    initializeBuilder(tx, builder) {
        if (tx) {
            builder.initBuilder(tx);
        }
        return builder;
    }
    /**
     * Check the raw transaction has a valid format in the blockchain context, throw otherwise.
     *
     * @param {any} rawTransaction - Transaction in any format
     */
    validateRawTransaction(rawTransaction) {
        if (!rawTransaction) {
            throw new sdk_core_1.ParseTransactionError('Invalid raw transaction: Undefined');
        }
        try {
            JSON.parse(rawTransaction);
        }
        catch (e) {
            throw new sdk_core_1.ParseTransactionError('Invalid raw transaction format');
        }
    }
}
exports.TransactionBuilderFactory = TransactionBuilderFactory;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSxpREFBMkM7QUFDM0MsOENBS3lCO0FBQ3pCLCtFQUE0RTtBQUM1RSx1REFBb0Q7QUFFcEQsK0NBQTRDO0FBQzVDLG1DQUF3QztBQUN4Qyx1REFBb0Q7QUFDcEQsMkRBQXdEO0FBRXhELE1BQWEseUJBQTBCLFNBQVEsd0NBQTZCO0lBQzFFLFlBQVksV0FBaUM7UUFDM0MsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsOEJBQThCLENBQUMsRUFBZ0I7UUFDN0MsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsRUFBRSxFQUFFLElBQUkseURBQTJCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7SUFDdkYsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsb0JBQW9CLENBQUMsRUFBZ0I7UUFDbkMsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsRUFBRSxFQUFFLElBQUkscUNBQWlCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7SUFDN0UsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsa0JBQWtCLENBQUMsRUFBZ0I7UUFDakMsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsRUFBRSxFQUFFLElBQUksaUNBQWUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztJQUMzRSxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLGtCQUFrQixDQUFDLEVBQWdCO1FBQ2pDLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxJQUFJLGlDQUFlLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7SUFDM0UsQ0FBQztJQUVELGtCQUFrQjtJQUNsQixJQUFJLENBQUMsR0FBVztRQUNkLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNqQyxNQUFNLEVBQUUsR0FBRyxJQUFJLHlCQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzdDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbkMsSUFBSTtZQUNGLEVBQUUsQ0FBQyxRQUFRLEdBQUcsMEJBQVUsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDOUQ7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLE1BQU0sSUFBSSxrQ0FBdUIsQ0FBQyx1QkFBdUIsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUNoRTtRQUVELE1BQU0sZ0JBQWdCLEdBQUcsSUFBQSxxQkFBYSxFQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDNUQsUUFBUSxnQkFBZ0IsRUFBRTtZQUN4QixLQUFLLDBCQUFlLENBQUMsSUFBSTtnQkFDdkIsT0FBTyxJQUFJLENBQUMsa0JBQWtCLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDckMsS0FBSywwQkFBZSxDQUFDLG9CQUFvQjtnQkFDdkMsT0FBTyxJQUFJLENBQUMsOEJBQThCLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDakQsS0FBSywwQkFBZSxDQUFDLFdBQVc7Z0JBQzlCLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3JDLEtBQUssMEJBQWUsQ0FBQyxhQUFhO2dCQUNoQyxPQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUN2QztnQkFDRSxNQUFNLElBQUksa0NBQXVCLENBQUMsc0JBQXNCLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQzNFO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNLLGlCQUFpQixDQUErQixFQUEyQixFQUFFLE9BQVU7UUFDN0YsSUFBSSxFQUFFLEVBQUU7WUFDTixPQUFPLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3pCO1FBQ0QsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxzQkFBc0IsQ0FBQyxjQUFzQjtRQUNuRCxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ25CLE1BQU0sSUFBSSxnQ0FBcUIsQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO1NBQ3ZFO1FBQ0QsSUFBSTtZQUNGLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7U0FDNUI7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLE1BQU0sSUFBSSxnQ0FBcUIsQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO1NBQ25FO0lBQ0gsQ0FBQztDQUNGO0FBMUZELDhEQTBGQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBEZXBsb3lVdGlsIH0gZnJvbSAnY2FzcGVyLWpzLXNkayc7XG5pbXBvcnQge1xuICBCYXNlVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeSxcbiAgVHJhbnNhY3Rpb25UeXBlLFxuICBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcixcbiAgUGFyc2VUcmFuc2FjdGlvbkVycm9yLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgV2FsbGV0SW5pdGlhbGl6YXRpb25CdWlsZGVyIH0gZnJvbSAnLi93YWxsZXRJbml0aWFsaXphdGlvbkJ1aWxkZXInO1xuaW1wb3J0IHsgVHJhbnNmZXJCdWlsZGVyIH0gZnJvbSAnLi90cmFuc2ZlckJ1aWxkZXInO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25CdWlsZGVyIH0gZnJvbSAnLi90cmFuc2FjdGlvbkJ1aWxkZXInO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IGdldERlcGxveVR5cGUgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IERlbGVnYXRlQnVpbGRlciB9IGZyb20gJy4vZGVsZWdhdGVCdWlsZGVyJztcbmltcG9ydCB7IFVuZGVsZWdhdGVCdWlsZGVyIH0gZnJvbSAnLi91bmRlbGVnYXRlQnVpbGRlcic7XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5IGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uQnVpbGRlckZhY3Rvcnkge1xuICBjb25zdHJ1Y3RvcihfY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihfY29pbkNvbmZpZyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgZ2V0V2FsbGV0SW5pdGlhbGl6YXRpb25CdWlsZGVyKHR4PzogVHJhbnNhY3Rpb24pOiBXYWxsZXRJbml0aWFsaXphdGlvbkJ1aWxkZXIge1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVCdWlsZGVyKHR4LCBuZXcgV2FsbGV0SW5pdGlhbGl6YXRpb25CdWlsZGVyKHRoaXMuX2NvaW5Db25maWcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGFuIHVuZGVsZWdhdGUgYnVpbGRlclxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uIHwgdW5kZWZpbmVkfSB0eCAtIHRoZSB0cmFuc2FjdGlvbiB1c2VkIHRvIGluaXRpYWxpemUgdGhlIGJ1aWxkZXJcbiAgICogQHJldHVybnMge1VuZGVsZWdhdGVCdWlsZGVyfSB0aGUgYnVpbGRlciBpbml0aWFsaXplZFxuICAgKi9cbiAgZ2V0VW5kZWxlZ2F0ZUJ1aWxkZXIodHg/OiBUcmFuc2FjdGlvbik6IFVuZGVsZWdhdGVCdWlsZGVyIHtcbiAgICByZXR1cm4gdGhpcy5pbml0aWFsaXplQnVpbGRlcih0eCwgbmV3IFVuZGVsZWdhdGVCdWlsZGVyKHRoaXMuX2NvaW5Db25maWcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGFuIGRlbGVnYXRlIGJ1aWxkZXJcbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbiB8IHVuZGVmaW5lZH0gdHggLSB0aGUgdHJhbnNhY3Rpb24gdXNlZCB0byBpbml0aWFsaXplIHRoZSBidWlsZGVyXG4gICAqIEByZXR1cm5zIHtEZWxlZ2F0ZUJ1aWxkZXJ9IHRoZSBidWlsZGVyIGluaXRpYWxpemVkXG4gICAqL1xuICBnZXREZWxlZ2F0ZUJ1aWxkZXIodHg/OiBUcmFuc2FjdGlvbik6IERlbGVnYXRlQnVpbGRlciB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZUJ1aWxkZXIodHgsIG5ldyBEZWxlZ2F0ZUJ1aWxkZXIodGhpcy5fY29pbkNvbmZpZykpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGdldFRyYW5zZmVyQnVpbGRlcih0eD86IFRyYW5zYWN0aW9uKTogVHJhbnNmZXJCdWlsZGVyIHtcbiAgICByZXR1cm4gdGhpcy5pbml0aWFsaXplQnVpbGRlcih0eCwgbmV3IFRyYW5zZmVyQnVpbGRlcih0aGlzLl9jb2luQ29uZmlnKSk7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgZnJvbShyYXc6IHN0cmluZyk6IFRyYW5zYWN0aW9uQnVpbGRlciB7XG4gICAgdGhpcy52YWxpZGF0ZVJhd1RyYW5zYWN0aW9uKHJhdyk7XG4gICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb24odGhpcy5fY29pbkNvbmZpZyk7XG4gICAgY29uc3QgZGVwbG95SnNvbiA9IEpTT04ucGFyc2UocmF3KTtcbiAgICB0cnkge1xuICAgICAgdHguY2FzcGVyVHggPSBEZXBsb3lVdGlsLmRlcGxveUZyb21Kc29uKGRlcGxveUpzb24pLnVud3JhcCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbjogJyArIGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGNhc3BlckRlcGxveVR5cGUgPSBnZXREZXBsb3lUeXBlKHR4LmNhc3BlclR4LnNlc3Npb24pO1xuICAgIHN3aXRjaCAoY2FzcGVyRGVwbG95VHlwZSkge1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU2VuZDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNmZXJCdWlsZGVyKHR4KTtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLldhbGxldEluaXRpYWxpemF0aW9uOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRXYWxsZXRJbml0aWFsaXphdGlvbkJ1aWxkZXIodHgpO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0xvY2s6XG4gICAgICAgIHJldHVybiB0aGlzLmdldERlbGVnYXRlQnVpbGRlcih0eCk7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nVW5sb2NrOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbmRlbGVnYXRlQnVpbGRlcih0eCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24gJyArIHR4LmNhc3BlclR4KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgYnVpbGRlciB3aXRoIHRoZSBnaXZlbiB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uIHwgdW5kZWZpbmVkfSB0eCAtIHRoZSB0cmFuc2FjdGlvbiB1c2VkIHRvIGluaXRpYWxpemUgdGhlIGJ1aWxkZXJcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbkJ1aWxkZXJ9IGJ1aWxkZXIgLSB0aGUgYnVpbGRlciB0byBiZSBpbml0aWFsaXplZFxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25CdWlsZGVyfSB0aGUgYnVpbGRlciBpbml0aWFsaXplZFxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplQnVpbGRlcjxUIGV4dGVuZHMgVHJhbnNhY3Rpb25CdWlsZGVyPih0eDogVHJhbnNhY3Rpb24gfCB1bmRlZmluZWQsIGJ1aWxkZXI6IFQpOiBUIHtcbiAgICBpZiAodHgpIHtcbiAgICAgIGJ1aWxkZXIuaW5pdEJ1aWxkZXIodHgpO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbGRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgcmF3IHRyYW5zYWN0aW9uIGhhcyBhIHZhbGlkIGZvcm1hdCBpbiB0aGUgYmxvY2tjaGFpbiBjb250ZXh0LCB0aHJvdyBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSByYXdUcmFuc2FjdGlvbiAtIFRyYW5zYWN0aW9uIGluIGFueSBmb3JtYXRcbiAgICovXG4gIHByaXZhdGUgdmFsaWRhdGVSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbjogc3RyaW5nKSB7XG4gICAgaWYgKCFyYXdUcmFuc2FjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCByYXcgdHJhbnNhY3Rpb246IFVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgSlNPTi5wYXJzZShyYXdUcmFuc2FjdGlvbik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCByYXcgdHJhbnNhY3Rpb24gZm9ybWF0Jyk7XG4gICAgfVxuICB9XG59XG4iXX0=