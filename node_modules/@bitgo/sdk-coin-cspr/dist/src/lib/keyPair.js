"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyPair = void 0;
const crypto_1 = require("crypto");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const sdk_core_1 = require("@bitgo/sdk-core");
const constants_1 = require("./constants");
const DEFAULT_SEED_SIZE_BYTES = 16;
class KeyPair extends sdk_core_1.Secp256k1ExtendedKeyPair {
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param { KeyPairOptions } source Either a master seed, a private key, or a public key
     */
    constructor(source) {
        super(source);
        if (!source) {
            const seed = (0, crypto_1.randomBytes)(DEFAULT_SEED_SIZE_BYTES);
            this.hdNode = utxo_lib_1.bip32.fromSeed(seed);
        }
        else if ((0, sdk_core_1.isSeed)(source)) {
            this.hdNode = utxo_lib_1.bip32.fromSeed(source.seed);
        }
        else if ((0, sdk_core_1.isPrivateKey)(source)) {
            this.recordKeysFromPrivateKey(source.prv);
        }
        else if ((0, sdk_core_1.isPublicKey)(source)) {
            this.recordKeysFromPublicKey(source.pub);
        }
        else {
            throw new Error('Invalid key pair options');
        }
        if (this.hdNode) {
            this.keyPair = sdk_core_1.Secp256k1ExtendedKeyPair.toKeyPair(this.hdNode);
        }
    }
    /**
     * Default keys format is a pair of Uint8Array keys
     *
     * @returns { DefaultKeys } The keys in the defined format
     */
    getKeys() {
        var _a;
        return {
            pub: this.getPublicKey({ compressed: true }).toString('hex'),
            prv: (_a = this.getPrivateKey()) === null || _a === void 0 ? void 0 : _a.toString('hex'),
        };
    }
    /** @inheritdoc */
    getAddress() {
        const keys = this.getKeys();
        return constants_1.SECP256K1_PREFIX + keys.pub;
    }
}
exports.KeyPair = KeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIva2V5UGFpci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxtQ0FBcUM7QUFDckMsOENBQXdDO0FBQ3hDLDhDQU95QjtBQUN6QiwyQ0FBK0M7QUFDL0MsTUFBTSx1QkFBdUIsR0FBRyxFQUFFLENBQUM7QUFFbkMsTUFBYSxPQUFRLFNBQVEsbUNBQXdCO0lBQ25EOzs7O09BSUc7SUFDSCxZQUFZLE1BQXVCO1FBQ2pDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNkLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDWCxNQUFNLElBQUksR0FBRyxJQUFBLG9CQUFXLEVBQUMsdUJBQXVCLENBQUMsQ0FBQztZQUNsRCxJQUFJLENBQUMsTUFBTSxHQUFHLGdCQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3BDO2FBQU0sSUFBSSxJQUFBLGlCQUFNLEVBQUMsTUFBTSxDQUFDLEVBQUU7WUFDekIsSUFBSSxDQUFDLE1BQU0sR0FBRyxnQkFBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDM0M7YUFBTSxJQUFJLElBQUEsdUJBQVksRUFBQyxNQUFNLENBQUMsRUFBRTtZQUMvQixJQUFJLENBQUMsd0JBQXdCLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNDO2FBQU0sSUFBSSxJQUFBLHNCQUFXLEVBQUMsTUFBTSxDQUFDLEVBQUU7WUFDOUIsSUFBSSxDQUFDLHVCQUF1QixDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUMxQzthQUFNO1lBQ0wsTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO1NBQzdDO1FBRUQsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2YsSUFBSSxDQUFDLE9BQU8sR0FBRyxtQ0FBd0IsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ2hFO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxPQUFPOztRQUNMLE9BQU87WUFDTCxHQUFHLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUM7WUFDNUQsR0FBRyxFQUFFLE1BQUEsSUFBSSxDQUFDLGFBQWEsRUFBRSwwQ0FBRSxRQUFRLENBQUMsS0FBSyxDQUFDO1NBQzNDLENBQUM7SUFDSixDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLFVBQVU7UUFDUixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDNUIsT0FBTyw0QkFBZ0IsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO0lBQ3JDLENBQUM7Q0FDRjtBQTNDRCwwQkEyQ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBiaXAzMiB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQge1xuICBLZXlQYWlyT3B0aW9ucyxcbiAgaXNQcml2YXRlS2V5LFxuICBpc1B1YmxpY0tleSxcbiAgaXNTZWVkLFxuICBEZWZhdWx0S2V5cyxcbiAgU2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgU0VDUDI1NksxX1BSRUZJWCB9IGZyb20gJy4vY29uc3RhbnRzJztcbmNvbnN0IERFRkFVTFRfU0VFRF9TSVpFX0JZVEVTID0gMTY7XG5cbmV4cG9ydCBjbGFzcyBLZXlQYWlyIGV4dGVuZHMgU2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyIHtcbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci4gQnkgZGVmYXVsdCwgY3JlYXRlcyBhIGtleSBwYWlyIHdpdGggYSByYW5kb20gbWFzdGVyIHNlZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7IEtleVBhaXJPcHRpb25zIH0gc291cmNlIEVpdGhlciBhIG1hc3RlciBzZWVkLCBhIHByaXZhdGUga2V5LCBvciBhIHB1YmxpYyBrZXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZT86IEtleVBhaXJPcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlKTtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgY29uc3Qgc2VlZCA9IHJhbmRvbUJ5dGVzKERFRkFVTFRfU0VFRF9TSVpFX0JZVEVTKTtcbiAgICAgIHRoaXMuaGROb2RlID0gYmlwMzIuZnJvbVNlZWQoc2VlZCk7XG4gICAgfSBlbHNlIGlmIChpc1NlZWQoc291cmNlKSkge1xuICAgICAgdGhpcy5oZE5vZGUgPSBiaXAzMi5mcm9tU2VlZChzb3VyY2Uuc2VlZCk7XG4gICAgfSBlbHNlIGlmIChpc1ByaXZhdGVLZXkoc291cmNlKSkge1xuICAgICAgdGhpcy5yZWNvcmRLZXlzRnJvbVByaXZhdGVLZXkoc291cmNlLnBydik7XG4gICAgfSBlbHNlIGlmIChpc1B1YmxpY0tleShzb3VyY2UpKSB7XG4gICAgICB0aGlzLnJlY29yZEtleXNGcm9tUHVibGljS2V5KHNvdXJjZS5wdWIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IHBhaXIgb3B0aW9ucycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhkTm9kZSkge1xuICAgICAgdGhpcy5rZXlQYWlyID0gU2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyLnRvS2V5UGFpcih0aGlzLmhkTm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQga2V5cyBmb3JtYXQgaXMgYSBwYWlyIG9mIFVpbnQ4QXJyYXkga2V5c1xuICAgKlxuICAgKiBAcmV0dXJucyB7IERlZmF1bHRLZXlzIH0gVGhlIGtleXMgaW4gdGhlIGRlZmluZWQgZm9ybWF0XG4gICAqL1xuICBnZXRLZXlzKCk6IERlZmF1bHRLZXlzIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiB0aGlzLmdldFB1YmxpY0tleSh7IGNvbXByZXNzZWQ6IHRydWUgfSkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgcHJ2OiB0aGlzLmdldFByaXZhdGVLZXkoKT8udG9TdHJpbmcoJ2hleCcpLFxuICAgIH07XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgZ2V0QWRkcmVzcygpOiBzdHJpbmcge1xuICAgIGNvbnN0IGtleXMgPSB0aGlzLmdldEtleXMoKTtcbiAgICByZXR1cm4gU0VDUDI1NksxX1BSRUZJWCArIGtleXMucHViO1xuICB9XG59XG4iXX0=