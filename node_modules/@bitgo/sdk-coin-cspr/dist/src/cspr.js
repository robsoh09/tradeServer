"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cspr = void 0;
/**
 * @prettier
 */
const CsprLib = __importStar(require("./lib"));
const utxo_lib_1 = require("@bitgo/utxo-lib");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const statics_1 = require("@bitgo/statics");
const sdk_core_1 = require("@bitgo/sdk-core");
class Cspr extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new Cspr(bitgo, staticsCoin);
    }
    getChain() {
        return this._staticsCoin.name;
    }
    getFamily() {
        return this._staticsCoin.family;
    }
    getFullName() {
        return this._staticsCoin.fullName;
    }
    getBaseFactor() {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    }
    async verifyTransaction(params) {
        // TODO: Implement when available on the SDK.
        return true;
    }
    /**
     * Check if address is valid, then make sure it matches the root address.
     *
     * @param {VerifyAddressOptions} params address and rootAddress to verify
     */
    async isWalletAddress(params) {
        const { address, rootAddress } = params;
        if (!this.isValidAddress(address)) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        if (!this.isValidAddress(rootAddress)) {
            throw new sdk_core_1.InvalidAddressError('wallet root address is not valid');
        }
        const newAddressDetails = CsprLib.Utils.getAddressDetails(address);
        const rootAddressDetails = CsprLib.Utils.getAddressDetails(rootAddress);
        if (newAddressDetails.address.toLowerCase() !== rootAddressDetails.address.toLowerCase()) {
            throw new sdk_core_1.UnexpectedAddressError(`address validation failure: ${newAddressDetails.address} vs ${rootAddress}`);
        }
        return true;
    }
    /**
     * Generate Casper key pair - BitGo xpub format
     *
     * @param {Buffer} seed - Seed from which the new keypair should be generated, otherwise a random seed is used
     * @returns {Object} object with generated xpub and xprv
     */
    generateKeyPair(seed) {
        const keyPair = seed ? new CsprLib.KeyPair({ seed }) : new CsprLib.KeyPair();
        const keys = keyPair.getExtendedKeys();
        if (!keys.xprv) {
            throw new Error('Missing xprv in key generation.');
        }
        return {
            pub: keys.xpub,
            prv: keys.xprv,
        };
    }
    isValidPub(pub) {
        // TODO(STLX-1344): Validate using account-lib when available
        //  return accountLib.Cspr.Utils.isValidPublicKey(pub);
        try {
            new CsprLib.KeyPair({ pub });
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param prv the prv to be checked
     * @returns is it valid?
     */
    isValidPrv(prv) {
        // TODO(STLX-1345): Validate using account-lib when available
        //  return accountLib.Cspr.Utils.isValidPrivateKey(prv);
        try {
            new CsprLib.KeyPair({ prv });
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Return boolean indicating whether input is valid CSPR address
     *
     * @param address the pub to be checked
     * @returns true if the address is valid
     */
    isValidAddress(address) {
        try {
            const addressDetails = CsprLib.Utils.getAddressDetails(address);
            return address === CsprLib.Utils.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param {SignTransactionOptions} params data required to rebuild and sign the transaction
     * @param {TransactionPrebuild} params.txPrebuild prebuild object returned by platform
     * @param {String} params.prv user prv used to sign the transaction
     * @returns Bluebird<SignedTransaction>
     */
    async signTransaction(params) {
        const txBuilder = this.getBuilder().from(params.txPrebuild.txHex);
        const key = params.prv;
        txBuilder.sign({ key });
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new sdk_core_1.InvalidTransactionError('Error while trying to build transaction');
        }
        const response = {
            txHex: transaction.toBroadcastFormat(),
        };
        return transaction.signature.length >= 2 ? response : { halfSigned: response };
    }
    async parseTransaction(params) {
        return {};
    }
    /**
     * Extend walletParams with extra params required for generating a Casper wallet
     *
     * Casper wallets have three three keys, user, backup and bitgo.
     * Initially, we need a root prv to generate the account, which must be distinct from all three keychains on the wallet.
     * If a root private key is not provided, a random one is generated.
     * The root public key is the basis for the wallet root address.
     */
    async supplementGenerateWallet(walletParams) {
        if (walletParams.rootPrivateKey) {
            if (!this.isValidPrv(walletParams.rootPrivateKey) || walletParams.rootPrivateKey.length !== 64) {
                throw new Error('rootPrivateKey needs to be a hexadecimal private key string');
            }
        }
        else {
            const keyPair = utxo_lib_1.ECPair.makeRandom();
            if (!keyPair.privateKey) {
                throw new Error('no privateKey');
            }
            walletParams.rootPrivateKey = keyPair.privateKey.toString('hex');
        }
        return walletParams;
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        const keyPair = new CsprLib.KeyPair({ prv: key.prv });
        const messageHex = message instanceof Buffer ? message.toString('hex') : message;
        const signatureData = CsprLib.Utils.signMessage(keyPair, messageHex);
        return Buffer.from(signatureData.signature);
    }
    /**
     * Explain a Casper transaction from Raw Tx
     *
     * @param {ExplainTransactionOptions} params given explain transaction params
     * @param {String} params.txHex raw transaction
     * @param {String} params.halfSigned.txHex raw half signed transaction
     * @param {TransactionFee} fee fee information
     * @returns Bluebird<TransactionExplanation>
     */
    async explainTransaction(params) {
        const txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
        if (!txHex || !params.feeInfo) {
            throw new Error('missing explain tx parameters');
        }
        const txBuilder = this.getBuilder().from(txHex);
        const tx = await txBuilder.build();
        if (!tx) {
            throw new sdk_core_1.InvalidTransactionError('Error while trying to build transaction');
        }
        const id = Buffer.from(tx.casperTx.hash).toString('hex');
        const amount = CsprLib.Utils.getTransferAmount(tx.casperTx.session);
        let transferId;
        const outputs = [];
        const operations = [];
        switch (tx.type) {
            case sdk_core_1.TransactionType.Send: {
                transferId = CsprLib.Utils.getTransferId(tx.casperTx.session);
                const toAddress = CsprLib.Utils.getTransferDestinationAddress(tx._deploy.session);
                outputs.push({
                    address: toAddress,
                    amount,
                    coin: this.getChain(),
                });
                break;
            }
            case sdk_core_1.TransactionType.StakingLock: {
                const validator = CsprLib.Utils.getValidatorAddress(tx._deploy.session);
                operations.push({
                    type: sdk_core_1.TransactionType.StakingLock,
                    amount,
                    coin: this.getChain(),
                    validator: validator,
                });
                break;
            }
            case sdk_core_1.TransactionType.StakingUnlock: {
                const validator = CsprLib.Utils.getValidatorAddress(tx._deploy.session);
                operations.push({
                    type: sdk_core_1.TransactionType.StakingUnlock,
                    amount,
                    coin: this.getChain(),
                    validator: validator,
                });
                break;
            }
            default: {
                throw new sdk_core_1.InvalidTransactionError('Error while trying to get transaction type');
            }
        }
        const outputAmount = outputs
            .reduce((acumulator, output) => {
            const currentValue = new bignumber_js_1.default(output.amount);
            return acumulator.plus(currentValue);
        }, new bignumber_js_1.default(0))
            .toFixed(0);
        const displayOrder = [
            'id',
            'outputAmount',
            'changeAmount',
            'outputs',
            'changeOutputs',
            'transferId',
            'fee',
            'operations',
        ];
        return {
            displayOrder,
            id,
            outputs,
            outputAmount,
            changeOutputs: [],
            changeAmount: '0',
            transferId,
            fee: params.feeInfo,
            operations,
        };
    }
    getBuilder() {
        return new CsprLib.TransactionBuilderFactory(statics_1.coins.get(this.getChain()));
    }
}
exports.Cspr = Cspr;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3Nwci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jc3ByLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0dBRUc7QUFDSCwrQ0FBaUM7QUFDakMsOENBQXlDO0FBQ3pDLGdFQUFxQztBQUVyQyw0Q0FBZ0Y7QUFDaEYsOENBZ0J5QjtBQTZDekIsTUFBYSxJQUFLLFNBQVEsbUJBQVE7SUFHaEMsWUFBWSxLQUFnQixFQUFFLFdBQXVDO1FBQ25FLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUViLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvREFBb0QsQ0FBQyxDQUFDO1NBQ3ZFO1FBRUQsSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7SUFDbEMsQ0FBQztJQUVELE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBZ0IsRUFBRSxXQUF1QztRQUM3RSxPQUFPLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQsUUFBUTtRQUNOLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7SUFDaEMsQ0FBQztJQUNELFNBQVM7UUFDUCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDO0lBQ2xDLENBQUM7SUFDRCxXQUFXO1FBQ1QsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQztJQUNwQyxDQUFDO0lBQ0QsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQsS0FBSyxDQUFDLGlCQUFpQixDQUFDLE1BQWdDO1FBQ3RELDZDQUE2QztRQUM3QyxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFD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TyxVQUFVO1FBQ2hCLE9BQU8sSUFBSSxPQUFPLENBQUMseUJBQXlCLENBQUMsZUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzNFLENBQUM7Q0FDRjtBQXpSRCxvQkF5UkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgKiBhcyBDc3ByTGliIGZyb20gJy4vbGliJztcbmltcG9ydCB7IEVDUGFpciB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5cbmltcG9ydCB7IEJhc2VDb2luIGFzIFN0YXRpY3NCYXNlQ29pbiwgQ29pbkZhbWlseSwgY29pbnMgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgQml0R29CYXNlLFxuICBJbnZhbGlkQWRkcmVzc0Vycm9yLFxuICBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcixcbiAgS2V5UGFpcixcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBTaWduZWRUcmFuc2FjdGlvbixcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbixcbiAgVHJhbnNhY3Rpb25QcmVidWlsZCBhcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgVHJhbnNhY3Rpb25UeXBlLFxuICBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuXG5pbnRlcmZhY2UgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcHJ2OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhIZXg6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbkZlZSB7XG4gIGdhc0xpbWl0OiBzdHJpbmc7XG4gIGdhc1ByaWNlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4SGV4Pzogc3RyaW5nO1xuICBoYWxmU2lnbmVkPzoge1xuICAgIHR4SGV4OiBzdHJpbmc7XG4gIH07XG4gIGZlZUluZm86IFRyYW5zYWN0aW9uRmVlO1xufVxuXG5pbnRlcmZhY2UgU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyB7XG4gIHJvb3RQcml2YXRlS2V5Pzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25PdXRwdXQge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGFtb3VudDogc3RyaW5nO1xuICBjb2luOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbk9wZXJhdGlvbiB7XG4gIHR5cGU6IG51bWJlcjtcbiAgYW1vdW50OiBzdHJpbmc7XG4gIGNvaW46IHN0cmluZztcbiAgdmFsaWRhdG9yOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBDc3ByVmVyaWZ5QWRkcmVzc09wdGlvbnMgZXh0ZW5kcyBWZXJpZnlBZGRyZXNzT3B0aW9ucyB7XG4gIHJvb3RBZGRyZXNzOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBDc3ByIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3N0YXRpY3NDb2luOiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+O1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHb0Jhc2UsIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPikge1xuICAgIHN1cGVyKGJpdGdvKTtcblxuICAgIGlmICghc3RhdGljc0NvaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgc3RhdGljc0NvaW4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0aWNzQ29pbiA9IHN0YXRpY3NDb2luO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHb0Jhc2UsIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPik6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IENzcHIoYml0Z28sIHN0YXRpY3NDb2luKTtcbiAgfVxuXG4gIGdldENoYWluKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLm5hbWU7XG4gIH1cbiAgZ2V0RmFtaWx5KCk6IENvaW5GYW1pbHkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5mYW1pbHk7XG4gIH1cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZnVsbE5hbWU7XG4gIH1cbiAgZ2V0QmFzZUZhY3RvcigpOiBzdHJpbmcgfCBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhdGljc0NvaW4uZGVjaW1hbFBsYWNlcyk7XG4gIH1cblxuICBhc3luYyB2ZXJpZnlUcmFuc2FjdGlvbihwYXJhbXM6IFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIC8vIFRPRE86IEltcGxlbWVudCB3aGVuIGF2YWlsYWJsZSBvbiB0aGUgU0RLLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFkZHJlc3MgaXMgdmFsaWQsIHRoZW4gbWFrZSBzdXJlIGl0IG1hdGNoZXMgdGhlIHJvb3QgYWRkcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIHtWZXJpZnlBZGRyZXNzT3B0aW9uc30gcGFyYW1zIGFkZHJlc3MgYW5kIHJvb3RBZGRyZXNzIHRvIHZlcmlmeVxuICAgKi9cbiAgYXN5bmMgaXNXYWxsZXRBZGRyZXNzKHBhcmFtczogQ3NwclZlcmlmeUFkZHJlc3NPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCByb290QWRkcmVzcyB9ID0gcGFyYW1zO1xuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3Mocm9vdEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcignd2FsbGV0IHJvb3QgYWRkcmVzcyBpcyBub3QgdmFsaWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdBZGRyZXNzRGV0YWlscyA9IENzcHJMaWIuVXRpbHMuZ2V0QWRkcmVzc0RldGFpbHMoYWRkcmVzcyk7XG4gICAgY29uc3Qgcm9vdEFkZHJlc3NEZXRhaWxzID0gQ3NwckxpYi5VdGlscy5nZXRBZGRyZXNzRGV0YWlscyhyb290QWRkcmVzcyk7XG4gICAgaWYgKG5ld0FkZHJlc3NEZXRhaWxzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSAhPT0gcm9vdEFkZHJlc3NEZXRhaWxzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IoYGFkZHJlc3MgdmFsaWRhdGlvbiBmYWlsdXJlOiAke25ld0FkZHJlc3NEZXRhaWxzLmFkZHJlc3N9IHZzICR7cm9vdEFkZHJlc3N9YCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIENhc3BlciBrZXkgcGFpciAtIEJpdEdvIHhwdWIgZm9ybWF0XG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBzZWVkIC0gU2VlZCBmcm9tIHdoaWNoIHRoZSBuZXcga2V5cGFpciBzaG91bGQgYmUgZ2VuZXJhdGVkLCBvdGhlcndpc2UgYSByYW5kb20gc2VlZCBpcyB1c2VkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGdlbmVyYXRlZCB4cHViIGFuZCB4cHJ2XG4gICAqL1xuICBnZW5lcmF0ZUtleVBhaXIoc2VlZD86IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIGNvbnN0IGtleVBhaXIgPSBzZWVkID8gbmV3IENzcHJMaWIuS2V5UGFpcih7IHNlZWQgfSkgOiBuZXcgQ3NwckxpYi5LZXlQYWlyKCk7XG4gICAgY29uc3Qga2V5cyA9IGtleVBhaXIuZ2V0RXh0ZW5kZWRLZXlzKCk7XG5cbiAgICBpZiAoIWtleXMueHBydikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHhwcnYgaW4ga2V5IGdlbmVyYXRpb24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHB1Yjoga2V5cy54cHViLFxuICAgICAgcHJ2OiBrZXlzLnhwcnYsXG4gICAgfTtcbiAgfVxuXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAvLyBUT0RPKFNUTFgtMTM0NCk6IFZhbGlkYXRlIHVzaW5nIGFjY291bnQtbGliIHdoZW4gYXZhaWxhYmxlXG4gICAgLy8gIHJldHVybiBhY2NvdW50TGliLkNzcHIuVXRpbHMuaXNWYWxpZFB1YmxpY0tleShwdWIpO1xuICAgIHRyeSB7XG4gICAgICBuZXcgQ3NwckxpYi5LZXlQYWlyKHsgcHViIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHJpdmF0ZSBrZXkgZm9yIHRoZSBjb2luXG4gICAqXG4gICAqIEBwYXJhbSBwcnYgdGhlIHBydiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIC8vIFRPRE8oU1RMWC0xMzQ1KTogVmFsaWRhdGUgdXNpbmcgYWNjb3VudC1saWIgd2hlbiBhdmFpbGFibGVcbiAgICAvLyAgcmV0dXJuIGFjY291bnRMaWIuQ3Nwci5VdGlscy5pc1ZhbGlkUHJpdmF0ZUtleShwcnYpO1xuICAgIHRyeSB7XG4gICAgICBuZXcgQ3NwckxpYi5LZXlQYWlyKHsgcHJ2IH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgQ1NQUiBhZGRyZXNzXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBhZGRyZXNzIGlzIHZhbGlkXG4gICAqL1xuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSBDc3ByTGliLlV0aWxzLmdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3MpO1xuICAgICAgcmV0dXJuIGFkZHJlc3MgPT09IENzcHJMaWIuVXRpbHMubm9ybWFsaXplQWRkcmVzcyhhZGRyZXNzRGV0YWlscyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7U2lnblRyYW5zYWN0aW9uT3B0aW9uc30gcGFyYW1zIGRhdGEgcmVxdWlyZWQgdG8gcmVidWlsZCBhbmQgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvblByZWJ1aWxkfSBwYXJhbXMudHhQcmVidWlsZCBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgcGxhdGZvcm1cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5wcnYgdXNlciBwcnYgdXNlZCB0byBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJucyBCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj5cbiAgICovXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgdHhCdWlsZGVyID0gdGhpcy5nZXRCdWlsZGVyKCkuZnJvbShwYXJhbXMudHhQcmVidWlsZC50eEhleCk7XG4gICAgY29uc3Qga2V5ID0gcGFyYW1zLnBydjtcbiAgICB0eEJ1aWxkZXIuc2lnbih7IGtleSB9KTtcblxuICAgIGNvbnN0IHRyYW5zYWN0aW9uOiBhbnkgPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICBpZiAoIXRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ0Vycm9yIHdoaWxlIHRyeWluZyB0byBidWlsZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgIHR4SGV4OiB0cmFuc2FjdGlvbi50b0Jyb2FkY2FzdEZvcm1hdCgpLFxuICAgIH07XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLnNpZ25hdHVyZS5sZW5ndGggPj0gMiA/IHJlc3BvbnNlIDogeyBoYWxmU2lnbmVkOiByZXNwb25zZSB9O1xuICB9XG5cbiAgYXN5bmMgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmQgd2FsbGV0UGFyYW1zIHdpdGggZXh0cmEgcGFyYW1zIHJlcXVpcmVkIGZvciBnZW5lcmF0aW5nIGEgQ2FzcGVyIHdhbGxldFxuICAgKlxuICAgKiBDYXNwZXIgd2FsbGV0cyBoYXZlIHRocmVlIHRocmVlIGtleXMsIHVzZXIsIGJhY2t1cCBhbmQgYml0Z28uXG4gICAqIEluaXRpYWxseSwgd2UgbmVlZCBhIHJvb3QgcHJ2IHRvIGdlbmVyYXRlIHRoZSBhY2NvdW50LCB3aGljaCBtdXN0IGJlIGRpc3RpbmN0IGZyb20gYWxsIHRocmVlIGtleWNoYWlucyBvbiB0aGUgd2FsbGV0LlxuICAgKiBJZiBhIHJvb3QgcHJpdmF0ZSBrZXkgaXMgbm90IHByb3ZpZGVkLCBhIHJhbmRvbSBvbmUgaXMgZ2VuZXJhdGVkLlxuICAgKiBUaGUgcm9vdCBwdWJsaWMga2V5IGlzIHRoZSBiYXNpcyBmb3IgdGhlIHdhbGxldCByb290IGFkZHJlc3MuXG4gICAqL1xuICBhc3luYyBzdXBwbGVtZW50R2VuZXJhdGVXYWxsZXQoXG4gICAgd2FsbGV0UGFyYW1zOiBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zXG4gICk6IFByb21pc2U8U3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucz4ge1xuICAgIGlmICh3YWxsZXRQYXJhbXMucm9vdFByaXZhdGVLZXkpIHtcbiAgICAgIGlmICghdGhpcy5pc1ZhbGlkUHJ2KHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleSkgfHwgd2FsbGV0UGFyYW1zLnJvb3RQcml2YXRlS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyb290UHJpdmF0ZUtleSBuZWVkcyB0byBiZSBhIGhleGFkZWNpbWFsIHByaXZhdGUga2V5IHN0cmluZycpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBrZXlQYWlyID0gRUNQYWlyLm1ha2VSYW5kb20oKTtcbiAgICAgIGlmICgha2V5UGFpci5wcml2YXRlS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gcHJpdmF0ZUtleScpO1xuICAgICAgfVxuICAgICAgd2FsbGV0UGFyYW1zLnJvb3RQcml2YXRlS2V5ID0ga2V5UGFpci5wcml2YXRlS2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9XG4gICAgcmV0dXJuIHdhbGxldFBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIG1lc3NhZ2Ugd2l0aCBwcml2YXRlIGtleVxuICAgKlxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBtZXNzYWdlXG4gICAqL1xuICBhc3luYyBzaWduTWVzc2FnZShrZXk6IEtleVBhaXIsIG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlcik6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgY29uc3Qga2V5UGFpciA9IG5ldyBDc3ByTGliLktleVBhaXIoeyBwcnY6IGtleS5wcnYgfSk7XG4gICAgY29uc3QgbWVzc2FnZUhleCA9IG1lc3NhZ2UgaW5zdGFuY2VvZiBCdWZmZXIgPyBtZXNzYWdlLnRvU3RyaW5nKCdoZXgnKSA6IG1lc3NhZ2U7XG4gICAgY29uc3Qgc2lnbmF0dXJlRGF0YSA9IENzcHJMaWIuVXRpbHMuc2lnbk1lc3NhZ2Uoa2V5UGFpciwgbWVzc2FnZUhleCk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZURhdGEuc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluIGEgQ2FzcGVyIHRyYW5zYWN0aW9uIGZyb20gUmF3IFR4XG4gICAqXG4gICAqIEBwYXJhbSB7RXhwbGFpblRyYW5zYWN0aW9uT3B0aW9uc30gcGFyYW1zIGdpdmVuIGV4cGxhaW4gdHJhbnNhY3Rpb24gcGFyYW1zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMudHhIZXggcmF3IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuaGFsZlNpZ25lZC50eEhleCByYXcgaGFsZiBzaWduZWQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbkZlZX0gZmVlIGZlZSBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJucyBCbHVlYmlyZDxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPlxuICAgKi9cbiAgYXN5bmMgZXhwbGFpblRyYW5zYWN0aW9uKHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IHR4SGV4ID0gcGFyYW1zLnR4SGV4IHx8IChwYXJhbXMuaGFsZlNpZ25lZCAmJiBwYXJhbXMuaGFsZlNpZ25lZC50eEhleCk7XG4gICAgaWYgKCF0eEhleCB8fCAhcGFyYW1zLmZlZUluZm8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBleHBsYWluIHR4IHBhcmFtZXRlcnMnKTtcbiAgICB9XG4gICAgY29uc3QgdHhCdWlsZGVyID0gdGhpcy5nZXRCdWlsZGVyKCkuZnJvbSh0eEhleCk7XG5cbiAgICBjb25zdCB0eDogYW55ID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgaWYgKCF0eCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdFcnJvciB3aGlsZSB0cnlpbmcgdG8gYnVpbGQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBCdWZmZXIuZnJvbSh0eC5jYXNwZXJUeC5oYXNoKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgYW1vdW50ID0gQ3NwckxpYi5VdGlscy5nZXRUcmFuc2ZlckFtb3VudCh0eC5jYXNwZXJUeC5zZXNzaW9uKTtcbiAgICBsZXQgdHJhbnNmZXJJZDtcbiAgICBjb25zdCBvdXRwdXRzOiBUcmFuc2FjdGlvbk91dHB1dFtdID0gW107XG4gICAgY29uc3Qgb3BlcmF0aW9uczogVHJhbnNhY3Rpb25PcGVyYXRpb25bXSA9IFtdO1xuXG4gICAgc3dpdGNoICh0eC50eXBlKSB7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5TZW5kOiB7XG4gICAgICAgIHRyYW5zZmVySWQgPSBDc3ByTGliLlV0aWxzLmdldFRyYW5zZmVySWQodHguY2FzcGVyVHguc2Vzc2lvbik7XG4gICAgICAgIGNvbnN0IHRvQWRkcmVzcyA9IENzcHJMaWIuVXRpbHMuZ2V0VHJhbnNmZXJEZXN0aW5hdGlvbkFkZHJlc3ModHguX2RlcGxveS5zZXNzaW9uKTtcbiAgICAgICAgb3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICBhZGRyZXNzOiB0b0FkZHJlc3MsXG4gICAgICAgICAgYW1vdW50LFxuICAgICAgICAgIGNvaW46IHRoaXMuZ2V0Q2hhaW4oKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0xvY2s6IHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gQ3NwckxpYi5VdGlscy5nZXRWYWxpZGF0b3JBZGRyZXNzKHR4Ll9kZXBsb3kuc2Vzc2lvbik7XG4gICAgICAgIG9wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdMb2NrLFxuICAgICAgICAgIGFtb3VudCxcbiAgICAgICAgICBjb2luOiB0aGlzLmdldENoYWluKCksXG4gICAgICAgICAgdmFsaWRhdG9yOiB2YWxpZGF0b3IsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdVbmxvY2s6IHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gQ3NwckxpYi5VdGlscy5nZXRWYWxpZGF0b3JBZGRyZXNzKHR4Ll9kZXBsb3kuc2Vzc2lvbik7XG4gICAgICAgIG9wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdVbmxvY2ssXG4gICAgICAgICAgYW1vdW50LFxuICAgICAgICAgIGNvaW46IHRoaXMuZ2V0Q2hhaW4oKSxcbiAgICAgICAgICB2YWxpZGF0b3I6IHZhbGlkYXRvcixcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ0Vycm9yIHdoaWxlIHRyeWluZyB0byBnZXQgdHJhbnNhY3Rpb24gdHlwZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dEFtb3VudCA9IG91dHB1dHNcbiAgICAgIC5yZWR1Y2UoKGFjdW11bGF0b3IsIG91dHB1dCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBuZXcgQmlnTnVtYmVyKG91dHB1dC5hbW91bnQpO1xuICAgICAgICByZXR1cm4gYWN1bXVsYXRvci5wbHVzKGN1cnJlbnRWYWx1ZSk7XG4gICAgICB9LCBuZXcgQmlnTnVtYmVyKDApKVxuICAgICAgLnRvRml4ZWQoMCk7XG5cbiAgICBjb25zdCBkaXNwbGF5T3JkZXIgPSBbXG4gICAgICAnaWQnLFxuICAgICAgJ291dHB1dEFtb3VudCcsXG4gICAgICAnY2hhbmdlQW1vdW50JyxcbiAgICAgICdvdXRwdXRzJyxcbiAgICAgICdjaGFuZ2VPdXRwdXRzJyxcbiAgICAgICd0cmFuc2ZlcklkJyxcbiAgICAgICdmZWUnLFxuICAgICAgJ29wZXJhdGlvbnMnLFxuICAgIF07XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlzcGxheU9yZGVyLFxuICAgICAgaWQsXG4gICAgICBvdXRwdXRzLFxuICAgICAgb3V0cHV0QW1vdW50LFxuICAgICAgY2hhbmdlT3V0cHV0czogW10sIC8vIGFjY291bnQgYmFzZWQgZG9lcyBub3QgdXNlIGNoYW5nZSBvdXRwdXRzXG4gICAgICBjaGFuZ2VBbW91bnQ6ICcwJywgLy8gYWNjb3VudCBiYXNlIGRvZXMgbm90IG1ha2UgY2hhbmdlXG4gICAgICB0cmFuc2ZlcklkLFxuICAgICAgZmVlOiBwYXJhbXMuZmVlSW5mbyxcbiAgICAgIG9wZXJhdGlvbnMsXG4gICAgfSBhcyBhbnk7XG4gIH1cblxuICBwcml2YXRlIGdldEJ1aWxkZXIoKTogQ3NwckxpYi5UcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5IHtcbiAgICByZXR1cm4gbmV3IENzcHJMaWIuVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeShjb2lucy5nZXQodGhpcy5nZXRDaGFpbigpKSk7XG4gIH1cbn1cbiJdfQ==