"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
const algosdk_1 = __importDefault(require("algosdk"));
const stellar_sdk_1 = __importDefault(require("stellar-sdk"));
const hex = __importStar(require("@stablelib/hex"));
const nacl = __importStar(require("tweetnacl"));
const hi_base32_1 = __importDefault(require("hi-base32"));
const js_sha512_1 = __importDefault(require("js-sha512"));
const lodash_1 = __importDefault(require("lodash"));
const keyPair_1 = require("./keyPair");
const seedEncoding_1 = require("./seedEncoding");
const algoNacl = __importStar(require("algosdk/dist/cjs/src/nacl/naclWrappers"));
const encoding = __importStar(require("algosdk/dist/cjs/src/encoding/encoding"));
const sdk_core_1 = require("@bitgo/sdk-core");
const ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
const ALGORAND_SEED_LENGTH = 58;
const ALGORAND_SEED_BYTE_LENGTH = 36;
const ALGORAND_TRANSACTION_LENGTH = 52;
const SEED_BYTES_LENGTH = 32;
/**
 * Determines whether the string is only composed of hex chars.
 *
 * @param {string} maybe The string to be validated.
 * @returns {boolean} true if the string consists of only hex characters, otherwise false.
 */
function allHexChars(maybe) {
    return /^([0-9a-f]{2})+$/i.test(maybe);
}
/**
 * ConcatArrays takes two array and returns a joint array of both
 *
 * @param a {Uint8Array} first array to concat
 * @param b {Uint8Array} second array
 * @returns {Uint8Array} a new array containing all elements of 'a' followed by all elements of 'b'
 */
function concatArrays(a, b) {
    const c = new Uint8Array(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
}
class Utils {
    /** @inheritdoc */
    isValidAddress(address) {
        return algosdk_1.default.isValidAddress(address);
    }
    /** @inheritdoc */
    isValidTransactionId(txId) {
        if (txId.length !== 104) {
            return false;
        }
        return allHexChars(txId);
    }
    /** @inheritdoc */
    isValidPublicKey(key) {
        return (0, sdk_core_1.isValidEd25519PublicKey)(key);
    }
    /** @inheritdoc */
    isValidPrivateKey(key) {
        return (0, sdk_core_1.isValidEd25519SecretKey)(key);
    }
    /**
     * Returns an hex string of the given buffer
     *
     * @param {Uint8Array} buffer - the buffer to be converted to hex
     * @returns {string} - the hex value
     */
    toHex(buffer) {
        return hex.encode(buffer, true);
    }
    /** @inheritdoc */
    isValidSignature(signature) {
        throw new sdk_core_1.NotImplementedError('isValidSignature not implemented.');
    }
    /** @inheritdoc */
    isValidBlockId(hash) {
        throw new sdk_core_1.NotImplementedError('hash not implemented.');
    }
    /**
     * Compare two Keys
     *
     * @param {Uint8Array} key1 - key to be compare
     * @param {Uint8Array} key2 - key to be compare
     * @returns {boolean} - returns true if both keys are equal
     */
    areKeysEqual(key1, key2) {
        return nacl.verify(key1, key2);
    }
    /**
     * Returns a Uint8Array of the given hex string
     *
     * @param {string} str - the hex string to be converted
     * @returns {string} - the Uint8Array value
     */
    toUint8Array(str) {
        return Buffer.from(str, 'hex');
    }
    /**
     * Determines whether a seed is valid.
     *
     * @param {string} seed - the seed to be validated
     * @returns {boolean} - true if the seed is valid
     */
    isValidSeed(seed) {
        if (typeof seed !== 'string')
            return false;
        if (seed.length !== ALGORAND_SEED_LENGTH)
            return false;
        // Try to decode
        let decoded;
        try {
            decoded = this.decodeSeed(seed);
        }
        catch (e) {
            return false;
        }
        // Compute checksum
        const checksum = new Uint8Array(js_sha512_1.default.sha512_256.array(decoded.seed).slice(SEED_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, SEED_BYTES_LENGTH));
        // Check if the checksum matches the one from the decoded seed
        return lodash_1.default.isEqual(checksum, decoded.checksum);
    }
    /**
     * Encode an algo seed
     *
     * @param  {Buffer} secretKey - the valid secretKey .
     * @returns {string} - the seed to be validated.
     */
    encodeSeed(secretKey) {
        // get seed
        const seed = secretKey.slice(0, SEED_BYTES_LENGTH);
        // compute checksum
        const checksum = Buffer.from(js_sha512_1.default.sha512_256.array(seed).slice(SEED_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, SEED_BYTES_LENGTH));
        const encodedSeed = hi_base32_1.default.encode(concatArrays(seed, checksum));
        return encodedSeed.toString().slice(0, ALGORAND_SEED_LENGTH); // removing the extra '===='
    }
    /**
     * decodeSeed decodes an algo seed
     *
     * Decoding algo seed is same as decoding address.
     * Latest version of algo sdk (1.9, at this writing) does not expose explicit method for decoding seed.
     * Parameter is decoded and split into seed and checksum.
     *
     * @param {string} seed - hex or base64 encoded seed to be validated
     * @returns {Seed} - validated object Seed
     */
    decodeSeed(seed) {
        // try to decode
        const decoded = hi_base32_1.default.decode.asBytes(seed);
        // Sanity check
        if (decoded.length !== ALGORAND_SEED_BYTE_LENGTH)
            throw new Error('seed seems to be malformed');
        return {
            seed: new Uint8Array(decoded.slice(0, ALGORAND_SEED_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH)),
            checksum: new Uint8Array(decoded.slice(SEED_BYTES_LENGTH, ALGORAND_SEED_BYTE_LENGTH)),
        };
    }
    /**
     * Verifies if signature for message is valid.
     *
     * @param pub {Uint8Array} public key
     * @param message {Uint8Array} signed message
     * @param signature {Buffer} signature to verify
     * @returns {Boolean} true if signature is valid.
     */
    verifySignature(message, signature, pub) {
        return nacl.sign.detached.verify(message, signature, pub);
    }
    /**
     * Transforms an Ed25519 public key into an algorand address.
     *
     * @param {Uint8Array} pk The Ed25519 public key.
     * @see https://developer.algorand.org/docs/features/accounts/#transformation-public-key-to-algorand-address
     *
     * @returns {string} The algorand address.
     */
    publicKeyToAlgoAddress(pk) {
        return new keyPair_1.KeyPair({ pub: Buffer.from(pk).toString('hex') }).getAddress();
    }
    /**
     Transforms a decrypted Ed25519 private key into an algorand address.
     @param {string} privateKey The Ed25519 private key.
     @returns {string} The algorand address.
     **/
    privateKeyToAlgoAddress(privateKey) {
        // Derive the account from the private key
        const keypair = new keyPair_1.KeyPair({ prv: privateKey });
        return keypair.getAddress();
    }
    /**
     * Checks if a unsigned algo transaction can be decoded.
     *
     * @param {Uint8Array} txn The encoded unsigned transaction.
     * @returns {boolean} true if the transaction can be decoded, otherwise false
     */
    isDecodableUnsignedAlgoTxn(txn) {
        try {
            algosdk_1.default.decodeUnsignedTransaction(txn);
            return true;
        }
        catch {
            return false;
        }
    }
    /**
     * Checks if a signed algo transaction can be decoded.
     *
     * @param {Uint8Array} txn The encoded signed transaction.
     * @returns {boolean} true if the transaction can be decoded, otherwise false
     */
    isDecodableSignedTransaction(txn) {
        try {
            algosdk_1.default.decodeSignedTransaction(txn);
            return true;
        }
        catch {
            return false;
        }
    }
    /**
     * Decodes a signed or unsigned algo transaction.
     *
     * @param {Uint8Array | string} txnBytes The encoded unsigned or signed txn.
     * @returns {EncodedTx} The decoded transaction.
     */
    decodeAlgoTxn(txnBytes) {
        let buffer = typeof txnBytes === 'string'
            ? Buffer.from(txnBytes, allHexChars(txnBytes) ? 'hex' : 'base64')
            : Buffer.from(txnBytes);
        // In order to maintain backward compatibility with old keyreg transactions encoded with
        // forked algosdk 1.2.0 (https://github.com/BitGo/algosdk-bitgo),
        // the relevant information is extracted and parsed following the latest algosdk
        // release standard.
        // This way we can decode transactions successfully by still maintaining backward compatibility.
        const decodedTx = encoding.decode(buffer);
        if (decodedTx.txn &&
            decodedTx.txn.type === 'keyreg' &&
            decodedTx.txn.votefst &&
            decodedTx.txn.votelst &&
            decodedTx.txn.votekd) {
            decodedTx.txn.votekey = decodedTx.txn.votekey || decodedTx.msig.subsig[0].pk;
            decodedTx.txn.selkey = decodedTx.txn.selkey || decodedTx.msig.subsig[0].pk;
            buffer = decodedTx.msig || decodedTx.sig ? encoding.encode(decodedTx) : encoding.encode(decodedTx.txn);
        }
        try {
            return this.tryToDecodeUnsignedTransaction(buffer);
        }
        catch {
            // Ignore error to try different format
        }
        try {
            return this.tryToDecodeSignedTransaction(buffer);
        }
        catch {
            throw new sdk_core_1.InvalidTransactionError('Transaction cannot be decoded');
        }
    }
    /**
     * Try to decode a signed Algo transaction
     * @param buffer the encoded transaction
     * @returns { EncodedTx } the decoded signed transaction
     * @throws error if it is not a valid encoded signed transaction
     */
    tryToDecodeSignedTransaction(buffer) {
        // TODO: Replace with
        // return algosdk.Transaction.from_obj_for_encoding(algosdk.decodeSignedTransaction(buffer).txn);
        // see: https://github.com/algorand/js-algorand-sdk/issues/364
        // "...some parts of the codebase treat the output of Transaction.from_obj_for_encoding as EncodedTransaction.
        // They need to be fixed(or we at least need to make it so Transaction conforms to EncodedTransaction)."
        const tx = algosdk_1.default.decodeSignedTransaction(buffer);
        const signers = [];
        const signedBy = [];
        if (tx.msig && tx.msig.subsig) {
            for (const sig of tx.msig.subsig) {
                const addr = algosdk_1.default.encodeAddress(sig.pk);
                signers.push(addr);
                if (sig.s) {
                    signedBy.push(addr);
                }
            }
        }
        return {
            rawTransaction: new Uint8Array(buffer),
            txn: tx.txn,
            signed: true,
            signers: signers,
            signedBy: signedBy,
        };
    }
    /**
     * Try to decode an unsigned Algo transaction
     * @param buffer the encoded transaction
     * @returns {EncodedTx} the decoded unsigned transaction
     * @throws error if it is not a valid encoded unsigned transaction
     */
    tryToDecodeUnsignedTransaction(buffer) {
        const txn = algosdk_1.default.decodeUnsignedTransaction(buffer);
        return {
            rawTransaction: new Uint8Array(buffer),
            txn,
            signed: false,
        };
    }
    /*
     * encodeObj takes a javascript object and returns its msgpack encoding
     * Note that the encoding sorts the fields alphabetically
     *
     * @param {Record<string | number | symbol, any>} obj js obj
     * @returns {Uint8Array} Uint8Array binary representation
     */
    encodeObj(obj) {
        return algosdk_1.default.encodeObj(obj);
    }
    /**
     * decodeObj takes a Uint8Array and returns its javascript obj
     * @param o - Uint8Array to decode
     * @returns object
     */
    decodeObj(o) {
        return algosdk_1.default.decodeObj(o);
    }
    /**
     * secretKeyToMnemonic takes an Algorant secret key and returns the corresponding mnemonic
     *
     * @param sk - Algorant secret key
     * @return Secret key is associated mnemonic
     */
    secretKeyToMnemonic(sk) {
        const skValid = Buffer.from(sk.toString('hex'));
        if (!this.isValidPrivateKey(skValid.toString('hex'))) {
            throw new sdk_core_1.InvalidKey(`The secret key: ${sk.toString('hex')} is invalid`);
        }
        const skUnit8Array = Buffer.from(sk);
        return algosdk_1.default.secretKeyToMnemonic(skUnit8Array);
    }
    /**
     * seedFromMnemonic converts a mnemonic generated using this library into the source key used to create it
     * It returns an error if the passed mnemonic has an incorrect checksum, if the number of words is unexpected, or if one
     * of the passed words is not found in the words list
     *
     * @param mnemonic - 25 words mnemonic
     * @returns 32 bytes long seed
     */
    seedFromMnemonic(mnemonic) {
        return algosdk_1.default.mnemonicToMasterDerivationKey(mnemonic);
    }
    /**
     * keyPairFromSeed generates an object with secretKey and publicKey using the algosdk
     * @param seed 32 bytes long seed
     * @returns KeyPair
     */
    keyPairFromSeed(seed) {
        const mn = this.mnemonicFromSeed(seed);
        const base64PrivateKey = algosdk_1.default.mnemonicToSecretKey(mn).sk;
        return this.createKeyPair(base64PrivateKey);
    }
    /**
     * Generate a new `KeyPair` object from the given private key.
     *
     * @param base64PrivateKey 64 bytes long privateKey
     * @returns KeyPair
     */
    createKeyPair(base64PrivateKey) {
        const sk = base64PrivateKey.slice(0, 32);
        return new keyPair_1.KeyPair({ prv: Buffer.from(sk).toString('hex') });
    }
    /**
     * decodePrivateKey generates a seed with a mnemonic and using algosdk.
     *
     * @param seed 32 bytes long seed
     * @returns mnemonic - 25 words mnemonic - 25 words mnemonic
     */
    mnemonicFromSeed(seed) {
        return algosdk_1.default.masterDerivationKeyToMnemonic(seed);
    }
    /**
     * Validates the key with the stellar-sdk
     *
     * @param publicKey
     * @returns boolean
     */
    isValidEd25519PublicKeyStellar(publicKey) {
        return stellar_sdk_1.default.StrKey.isValidEd25519PublicKey(publicKey);
    }
    /**
     * Decodes the key with the stellar-sdk
     *
     * @param publicKey
     * @returns Buffer
     */
    decodeEd25519PublicKeyStellar(publicKey) {
        return stellar_sdk_1.default.StrKey.decodeEd25519PublicKey(publicKey);
    }
    /**
     * Convert a stellar seed to algorand encoding
     *
     * @param seed
     * @returns string the encoded seed
     */
    convertFromStellarSeed(seed) {
        return seedEncoding_1.SeedEncoding.encode(stellar_sdk_1.default.StrKey.decodeEd25519SecretSeed(seed));
    }
    /**
     * Returns an address encoded with algosdk
     *
     * @param addr
     * @returns string
     */
    encodeAddress(addr) {
        return algosdk_1.default.encodeAddress(addr);
    }
    /**
     * Return an address decoded with algosdk
     *
     * @param addr
     * @returns Address
     */
    decodeAddress(addr) {
        return algosdk_1.default.decodeAddress(addr);
    }
    /**
     * Converts an address into an ALGO one
     * If the given data is a Stellar address or public key, it is converted to ALGO address.
     *
     * @param addressOrPubKey an ALGO address, or an Stellar address or public key
     * @returns address algo address string
     */
    stellarAddressToAlgoAddress(addressOrPubKey) {
        // we have an Algorand address
        if (this.isValidAddress(addressOrPubKey)) {
            return addressOrPubKey;
        }
        // we have a stellar key
        if (this.isValidEd25519PublicKeyStellar(addressOrPubKey)) {
            const stellarPub = this.decodeEd25519PublicKeyStellar(addressOrPubKey);
            const algoAddress = this.encodeAddress(stellarPub);
            if (this.isValidAddress(algoAddress)) {
                return algoAddress;
            }
            throw new Error('Cannot convert Stellar address to an Algorand address via pubkey.');
        }
        throw new Error('Neither an Algorand address nor a stellar pubkey.');
    }
    /**
     * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.
     *
     * @param {number} version mutlisig version
     * @param {number} threshold multisig threshold
     * @param {string[]} addrs list of Algorand addresses
     * @returns {string} human readable Algorand address.
     */
    multisigAddress(version, threshold, addrs) {
        return algosdk_1.default.multisigAddress({
            version,
            threshold,
            addrs,
        });
    }
    /**
     * generateAccount generates un account with a secretKey and an address
     *
     * Function has not params
     * @returns Account
     */
    generateAccount() {
        return algosdk_1.default.generateAccount();
    }
    generateAccountFromSeed(seed) {
        const keys = nacl.sign.keyPair.fromSeed(seed);
        return {
            addr: algosdk_1.default.encodeAddress(keys.publicKey),
            sk: keys.secretKey,
        };
    }
    /**
     * Generates Tx ID from an encoded multisig transaction
     *
     * This is done because of a change made on version 1.10.1 on algosdk so method txID() only supports SignedTransaction type.
     * (https://github.com/algorand/js-algorand-sdk/blob/develop/CHANGELOG.md#1101)
     *
     * @param {string} txBase64 - encoded base64 multisig transaction
     * @returns {string} - transaction ID
     */
    getMultisigTxID(txBase64) {
        const txBytes = Buffer.from(txBase64, 'base64');
        const decodeSignTx = algosdk_1.default.decodeSignedTransaction(txBytes);
        const wellFormedDecodedSignTx = decodeSignTx.txn.get_obj_for_encoding();
        const txForEncoding = { msig: decodeSignTx.msig, txn: wellFormedDecodedSignTx };
        const en_msg = encoding.encode(txForEncoding);
        const tag = Buffer.from([84, 88]);
        const gh = Buffer.from(concatArrays(tag, en_msg));
        const hash = Buffer.from(algoNacl.genericHash(gh));
        return hi_base32_1.default.encode(hash).slice(0, ALGORAND_TRANSACTION_LENGTH);
    }
    /**
     * Determines if a given transaction data is to enable or disable a token
     * @param amount the amount in transaction
     * @param from the originated address
     * @param to the target address
     * @param closeRemainderTo (optional) address to send remaining units in originated address
     * @returns 'enableToken' or 'disableToken'
     */
    getTokenTxType(amount, from, to, closeRemainderTo) {
        let type = 'transferToken';
        if (amount === '0' && from === to) {
            type = !closeRemainderTo ? 'enableToken' : 'disableToken';
        }
        return type;
    }
    /**
     * Validate if the key is a valid base64 string
     * @param key the key to validate
     */
    validateBase64(key) {
        if (!key || typeof key !== 'string') {
            throw new Error('Invalid base64 string');
        }
        const base64RegExp = /^(?:[a-zA-Z0-9+\/]{4})*(?:|(?:[a-zA-Z0-9+\/]{3}=)|(?:[a-zA-Z0-9+\/]{2}==)|(?:[a-zA-Z0-9+\/]{1}===))$/;
        if (!base64RegExp.test(key)) {
            throw new Error('Invalid base64 string');
        }
    }
}
exports.Utils = Utils;
const utils = new Utils();
exports.default = utils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsc0RBQThCO0FBQzlCLDhEQUFrQztBQUNsQyxvREFBc0M7QUFDdEMsZ0RBQWtDO0FBQ2xDLDBEQUErQjtBQUMvQiwwREFBK0I7QUFDL0Isb0RBQXVCO0FBRXZCLHVDQUFvQztBQUNwQyxpREFBOEM7QUFDOUMsaUZBQW1FO0FBQ25FLGlGQUFtRTtBQUNuRSw4Q0FPeUI7QUFFekIsTUFBTSw2QkFBNkIsR0FBRyxDQUFDLENBQUM7QUFDeEMsTUFBTSxvQkFBb0IsR0FBRyxFQUFFLENBQUM7QUFDaEMsTUFBTSx5QkFBeUIsR0FBRyxFQUFFLENBQUM7QUFDckMsTUFBTSwyQkFBMkIsR0FBRyxFQUFFLENBQUM7QUFDdkMsTUFBTSxpQkFBaUIsR0FBRyxFQUFFLENBQUM7QUFFN0I7Ozs7O0dBS0c7QUFDSCxTQUFTLFdBQVcsQ0FBQyxLQUFhO0lBQ2hDLE9BQU8sbUJBQW1CLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFTLFlBQVksQ0FBQyxDQUFhLEVBQUUsQ0FBYTtJQUNoRCxNQUFNLENBQUMsR0FBRyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM5QyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ1QsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25CLE9BQU8sQ0FBQyxDQUFDO0FBQ1gsQ0FBQztBQUVELE1BQWEsS0FBSztJQUNoQixrQkFBa0I7SUFDbEIsY0FBYyxDQUFDLE9BQWU7UUFDNUIsT0FBTyxpQkFBTyxDQUFDLGNBQWMsQ0FB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MUM7SUFDSCxDQUFDO0NBQ0Y7QUFsaEJELHNCQWtoQkM7QUFFRCxNQUFNLEtBQUssR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO0FBRTFCLGtCQUFlLEtBQUssQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhbGdvc2RrIGZyb20gJ2FsZ29zZGsnO1xuaW1wb3J0IHN0ZWxsYXIgZnJvbSAnc3RlbGxhci1zZGsnO1xuaW1wb3J0ICogYXMgaGV4IGZyb20gJ0BzdGFibGVsaWIvaGV4JztcbmltcG9ydCAqIGFzIG5hY2wgZnJvbSAndHdlZXRuYWNsJztcbmltcG9ydCBiYXNlMzIgZnJvbSAnaGktYmFzZTMyJztcbmltcG9ydCBzaGE1MTIgZnJvbSAnanMtc2hhNTEyJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBBZGRyZXNzLCBFbmNvZGVkVHgsIFNlZWQgfSBmcm9tICcuL2lmYWNlcyc7XG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLi9rZXlQYWlyJztcbmltcG9ydCB7IFNlZWRFbmNvZGluZyB9IGZyb20gJy4vc2VlZEVuY29kaW5nJztcbmltcG9ydCAqIGFzIGFsZ29OYWNsIGZyb20gJ2FsZ29zZGsvZGlzdC9janMvc3JjL25hY2wvbmFjbFdyYXBwZXJzJztcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2FsZ29zZGsvZGlzdC9janMvc3JjL2VuY29kaW5nL2VuY29kaW5nJztcbmltcG9ydCB7XG4gIEJhc2VVdGlscyxcbiAgTm90SW1wbGVtZW50ZWRFcnJvcixcbiAgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IsXG4gIEludmFsaWRLZXksXG4gIGlzVmFsaWRFZDI1NTE5UHVibGljS2V5LFxuICBpc1ZhbGlkRWQyNTUxOVNlY3JldEtleSxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcblxuY29uc3QgQUxHT1JBTkRfQ0hFQ0tTVU1fQllURV9MRU5HVEggPSA0O1xuY29uc3QgQUxHT1JBTkRfU0VFRF9MRU5HVEggPSA1ODtcbmNvbnN0IEFMR09SQU5EX1NFRURfQllURV9MRU5HVEggPSAzNjtcbmNvbnN0IEFMR09SQU5EX1RSQU5TQUNUSU9OX0xFTkdUSCA9IDUyO1xuY29uc3QgU0VFRF9CWVRFU19MRU5HVEggPSAzMjtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHN0cmluZyBpcyBvbmx5IGNvbXBvc2VkIG9mIGhleCBjaGFycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWF5YmUgVGhlIHN0cmluZyB0byBiZSB2YWxpZGF0ZWQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc3RyaW5nIGNvbnNpc3RzIG9mIG9ubHkgaGV4IGNoYXJhY3RlcnMsIG90aGVyd2lzZSBmYWxzZS5cbiAqL1xuZnVuY3Rpb24gYWxsSGV4Q2hhcnMobWF5YmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gL14oWzAtOWEtZl17Mn0pKyQvaS50ZXN0KG1heWJlKTtcbn1cblxuLyoqXG4gKiBDb25jYXRBcnJheXMgdGFrZXMgdHdvIGFycmF5IGFuZCByZXR1cm5zIGEgam9pbnQgYXJyYXkgb2YgYm90aFxuICpcbiAqIEBwYXJhbSBhIHtVaW50OEFycmF5fSBmaXJzdCBhcnJheSB0byBjb25jYXRcbiAqIEBwYXJhbSBiIHtVaW50OEFycmF5fSBzZWNvbmQgYXJyYXlcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBhIG5ldyBhcnJheSBjb250YWluaW5nIGFsbCBlbGVtZW50cyBvZiAnYScgZm9sbG93ZWQgYnkgYWxsIGVsZW1lbnRzIG9mICdiJ1xuICovXG5mdW5jdGlvbiBjb25jYXRBcnJheXMoYTogVWludDhBcnJheSwgYjogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGggKyBiLmxlbmd0aCk7XG4gIGMuc2V0KGEpO1xuICBjLnNldChiLCBhLmxlbmd0aCk7XG4gIHJldHVybiBjO1xufVxuXG5leHBvcnQgY2xhc3MgVXRpbHMgaW1wbGVtZW50cyBCYXNlVXRpbHMge1xuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGFsZ29zZGsuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZFRyYW5zYWN0aW9uSWQodHhJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKHR4SWQubGVuZ3RoICE9PSAxMDQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWxsSGV4Q2hhcnModHhJZCk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZFB1YmxpY0tleShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc1ZhbGlkRWQyNTUxOVB1YmxpY0tleShrZXkpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRQcml2YXRlS2V5KGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzVmFsaWRFZDI1NTE5U2VjcmV0S2V5KGtleSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBoZXggc3RyaW5nIG9mIHRoZSBnaXZlbiBidWZmZXJcbiAgICpcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgLSB0aGUgYnVmZmVyIHRvIGJlIGNvbnZlcnRlZCB0byBoZXhcbiAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgaGV4IHZhbHVlXG4gICAqL1xuICB0b0hleChidWZmZXI6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICAgIHJldHVybiBoZXguZW5jb2RlKGJ1ZmZlciwgdHJ1ZSk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZFNpZ25hdHVyZShzaWduYXR1cmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCdpc1ZhbGlkU2lnbmF0dXJlIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkQmxvY2tJZChoYXNoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignaGFzaCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZSB0d28gS2V5c1xuICAgKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGtleTEgLSBrZXkgdG8gYmUgY29tcGFyZVxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGtleTIgLSBrZXkgdG8gYmUgY29tcGFyZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSByZXR1cm5zIHRydWUgaWYgYm90aCBrZXlzIGFyZSBlcXVhbFxuICAgKi9cbiAgYXJlS2V5c0VxdWFsKGtleTE6IFVpbnQ4QXJyYXksIGtleTI6IFVpbnQ4QXJyYXkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gbmFjbC52ZXJpZnkoa2V5MSwga2V5Mik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIFVpbnQ4QXJyYXkgb2YgdGhlIGdpdmVuIGhleCBzdHJpbmdcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIHRoZSBoZXggc3RyaW5nIHRvIGJlIGNvbnZlcnRlZFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBVaW50OEFycmF5IHZhbHVlXG4gICAqL1xuICB0b1VpbnQ4QXJyYXkoc3RyOiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCAnaGV4Jyk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc2VlZCBpcyB2YWxpZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlZWQgLSB0aGUgc2VlZCB0byBiZSB2YWxpZGF0ZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgc2VlZCBpcyB2YWxpZFxuICAgKi9cbiAgaXNWYWxpZFNlZWQoc2VlZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKHR5cGVvZiBzZWVkICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHNlZWQubGVuZ3RoICE9PSBBTEdPUkFORF9TRUVEX0xFTkdUSCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gVHJ5IHRvIGRlY29kZVxuICAgIGxldCBkZWNvZGVkO1xuICAgIHRyeSB7XG4gICAgICBkZWNvZGVkID0gdGhpcy5kZWNvZGVTZWVkKHNlZWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGNoZWNrc3VtXG4gICAgY29uc3QgY2hlY2tzdW0gPSBuZXcgVWludDhBcnJheShcbiAgICAgIHNoYTUxMi5zaGE1MTJfMjU2LmFycmF5KGRlY29kZWQuc2VlZCkuc2xpY2UoU0VFRF9CWVRFU19MRU5HVEggLSBBTEdPUkFORF9DSEVDS1NVTV9CWVRFX0xFTkdUSCwgU0VFRF9CWVRFU19MRU5HVEgpXG4gICAgKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBjaGVja3N1bSBtYXRjaGVzIHRoZSBvbmUgZnJvbSB0aGUgZGVjb2RlZCBzZWVkXG4gICAgcmV0dXJuIF8uaXNFcXVhbChjaGVja3N1bSwgZGVjb2RlZC5jaGVja3N1bSk7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIGFuIGFsZ28gc2VlZFxuICAgKlxuICAgKiBAcGFyYW0gIHtCdWZmZXJ9IHNlY3JldEtleSAtIHRoZSB2YWxpZCBzZWNyZXRLZXkgLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBzZWVkIHRvIGJlIHZhbGlkYXRlZC5cbiAgICovXG4gIGVuY29kZVNlZWQoc2VjcmV0S2V5OiBCdWZmZXIpOiBzdHJpbmcge1xuICAgIC8vIGdldCBzZWVkXG4gICAgY29uc3Qgc2VlZCA9IHNlY3JldEtleS5zbGljZSgwLCBTRUVEX0JZVEVTX0xFTkdUSCk7XG4gICAgLy8gY29tcHV0ZSBjaGVja3N1bVxuICAgIGNvbnN0IGNoZWNrc3VtID0gQnVmZmVyLmZyb20oXG4gICAgICBzaGE1MTIuc2hhNTEyXzI1Ni5hcnJheShzZWVkKS5zbGljZShTRUVEX0JZVEVTX0xFTkdUSCAtIEFMR09SQU5EX0NIRUNLU1VNX0JZVEVfTEVOR1RILCBTRUVEX0JZVEVTX0xFTkdUSClcbiAgICApO1xuICAgIGNvbnN0IGVuY29kZWRTZWVkID0gYmFzZTMyLmVuY29kZShjb25jYXRBcnJheXMoc2VlZCwgY2hlY2tzdW0pKTtcblxuICAgIHJldHVybiBlbmNvZGVkU2VlZC50b1N0cmluZygpLnNsaWNlKDAsIEFMR09SQU5EX1NFRURfTEVOR1RIKTsgLy8gcmVtb3ZpbmcgdGhlIGV4dHJhICc9PT09J1xuICB9XG5cbiAgLyoqXG4gICAqIGRlY29kZVNlZWQgZGVjb2RlcyBhbiBhbGdvIHNlZWRcbiAgICpcbiAgICogRGVjb2RpbmcgYWxnbyBzZWVkIGlzIHNhbWUgYXMgZGVjb2RpbmcgYWRkcmVzcy5cbiAgICogTGF0ZXN0IHZlcnNpb24gb2YgYWxnbyBzZGsgKDEuOSwgYXQgdGhpcyB3cml0aW5nKSBkb2VzIG5vdCBleHBvc2UgZXhwbGljaXQgbWV0aG9kIGZvciBkZWNvZGluZyBzZWVkLlxuICAgKiBQYXJhbWV0ZXIgaXMgZGVjb2RlZCBhbmQgc3BsaXQgaW50byBzZWVkIGFuZCBjaGVja3N1bS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlZWQgLSBoZXggb3IgYmFzZTY0IGVuY29kZWQgc2VlZCB0byBiZSB2YWxpZGF0ZWRcbiAgICogQHJldHVybnMge1NlZWR9IC0gdmFsaWRhdGVkIG9iamVjdCBTZWVkXG4gICAqL1xuICBkZWNvZGVTZWVkKHNlZWQ6IHN0cmluZyk6IFNlZWQge1xuICAgIC8vIHRyeSB0byBkZWNvZGVcbiAgICBjb25zdCBkZWNvZGVkID0gYmFzZTMyLmRlY29kZS5hc0J5dGVzKHNlZWQpO1xuXG4gICAgLy8gU2FuaXR5IGNoZWNrXG4gICAgaWYgKGRlY29kZWQubGVuZ3RoICE9PSBBTEdPUkFORF9TRUVEX0JZVEVfTEVOR1RIKSB0aHJvdyBuZXcgRXJyb3IoJ3NlZWQgc2VlbXMgdG8gYmUgbWFsZm9ybWVkJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlZWQ6IG5ldyBVaW50OEFycmF5KGRlY29kZWQuc2xpY2UoMCwgQUxHT1JBTkRfU0VFRF9CWVRFX0xFTkdUSCAtIEFMR09SQU5EX0NIRUNLU1VNX0JZVEVfTEVOR1RIKSksXG4gICAgICBjaGVja3N1bTogbmV3IFVpbnQ4QXJyYXkoZGVjb2RlZC5zbGljZShTRUVEX0JZVEVTX0xFTkdUSCwgQUxHT1JBTkRfU0VFRF9CWVRFX0xFTkdUSCkpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpZXMgaWYgc2lnbmF0dXJlIGZvciBtZXNzYWdlIGlzIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0gcHViIHtVaW50OEFycmF5fSBwdWJsaWMga2V5XG4gICAqIEBwYXJhbSBtZXNzYWdlIHtVaW50OEFycmF5fSBzaWduZWQgbWVzc2FnZVxuICAgKiBAcGFyYW0gc2lnbmF0dXJlIHtCdWZmZXJ9IHNpZ25hdHVyZSB0byB2ZXJpZnlcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgc2lnbmF0dXJlIGlzIHZhbGlkLlxuICAgKi9cbiAgdmVyaWZ5U2lnbmF0dXJlKG1lc3NhZ2U6IFVpbnQ4QXJyYXksIHNpZ25hdHVyZTogQnVmZmVyLCBwdWI6IFVpbnQ4QXJyYXkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gbmFjbC5zaWduLmRldGFjaGVkLnZlcmlmeShtZXNzYWdlLCBzaWduYXR1cmUsIHB1Yik7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBhbiBFZDI1NTE5IHB1YmxpYyBrZXkgaW50byBhbiBhbGdvcmFuZCBhZGRyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHBrIFRoZSBFZDI1NTE5IHB1YmxpYyBrZXkuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYWxnb3JhbmQub3JnL2RvY3MvZmVhdHVyZXMvYWNjb3VudHMvI3RyYW5zZm9ybWF0aW9uLXB1YmxpYy1rZXktdG8tYWxnb3JhbmQtYWRkcmVzc1xuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYWxnb3JhbmQgYWRkcmVzcy5cbiAgICovXG4gIHB1YmxpY0tleVRvQWxnb0FkZHJlc3MocGs6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICAgIHJldHVybiBuZXcgS2V5UGFpcih7IHB1YjogQnVmZmVyLmZyb20ocGspLnRvU3RyaW5nKCdoZXgnKSB9KS5nZXRBZGRyZXNzKCk7XG4gIH1cblxuICAvKipcbiAgIFRyYW5zZm9ybXMgYSBkZWNyeXB0ZWQgRWQyNTUxOSBwcml2YXRlIGtleSBpbnRvIGFuIGFsZ29yYW5kIGFkZHJlc3MuXG4gICBAcGFyYW0ge3N0cmluZ30gcHJpdmF0ZUtleSBUaGUgRWQyNTUxOSBwcml2YXRlIGtleS5cbiAgIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBhbGdvcmFuZCBhZGRyZXNzLlxuICAgKiovXG4gIHByaXZhdGVLZXlUb0FsZ29BZGRyZXNzKHByaXZhdGVLZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgLy8gRGVyaXZlIHRoZSBhY2NvdW50IGZyb20gdGhlIHByaXZhdGUga2V5XG4gICAgY29uc3Qga2V5cGFpciA9IG5ldyBLZXlQYWlyKHsgcHJ2OiBwcml2YXRlS2V5IH0pO1xuICAgIHJldHVybiBrZXlwYWlyLmdldEFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSB1bnNpZ25lZCBhbGdvIHRyYW5zYWN0aW9uIGNhbiBiZSBkZWNvZGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHR4biBUaGUgZW5jb2RlZCB1bnNpZ25lZCB0cmFuc2FjdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGNhbiBiZSBkZWNvZGVkLCBvdGhlcndpc2UgZmFsc2VcbiAgICovXG4gIHByb3RlY3RlZCBpc0RlY29kYWJsZVVuc2lnbmVkQWxnb1R4bih0eG46IFVpbnQ4QXJyYXkpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgYWxnb3Nkay5kZWNvZGVVbnNpZ25lZFRyYW5zYWN0aW9uKHR4bik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgc2lnbmVkIGFsZ28gdHJhbnNhY3Rpb24gY2FuIGJlIGRlY29kZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdHhuIFRoZSBlbmNvZGVkIHNpZ25lZCB0cmFuc2FjdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGNhbiBiZSBkZWNvZGVkLCBvdGhlcndpc2UgZmFsc2VcbiAgICovXG4gIHByb3RlY3RlZCBpc0RlY29kYWJsZVNpZ25lZFRyYW5zYWN0aW9uKHR4bjogVWludDhBcnJheSk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBhbGdvc2RrLmRlY29kZVNpZ25lZFRyYW5zYWN0aW9uKHR4bik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlcyBhIHNpZ25lZCBvciB1bnNpZ25lZCBhbGdvIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCBzdHJpbmd9IHR4bkJ5dGVzIFRoZSBlbmNvZGVkIHVuc2lnbmVkIG9yIHNpZ25lZCB0eG4uXG4gICAqIEByZXR1cm5zIHtFbmNvZGVkVHh9IFRoZSBkZWNvZGVkIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgZGVjb2RlQWxnb1R4bih0eG5CeXRlczogVWludDhBcnJheSB8IHN0cmluZyk6IEVuY29kZWRUeCB7XG4gICAgbGV0IGJ1ZmZlciA9XG4gICAgICB0eXBlb2YgdHhuQnl0ZXMgPT09ICdzdHJpbmcnXG4gICAgICAgID8gQnVmZmVyLmZyb20odHhuQnl0ZXMsIGFsbEhleENoYXJzKHR4bkJ5dGVzKSA/ICdoZXgnIDogJ2Jhc2U2NCcpXG4gICAgICAgIDogQnVmZmVyLmZyb20odHhuQnl0ZXMpO1xuXG4gICAgLy8gSW4gb3JkZXIgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBrZXlyZWcgdHJhbnNhY3Rpb25zIGVuY29kZWQgd2l0aFxuICAgIC8vIGZvcmtlZCBhbGdvc2RrIDEuMi4wIChodHRwczovL2dpdGh1Yi5jb20vQml0R28vYWxnb3Nkay1iaXRnbyksXG4gICAgLy8gdGhlIHJlbGV2YW50IGluZm9ybWF0aW9uIGlzIGV4dHJhY3RlZCBhbmQgcGFyc2VkIGZvbGxvd2luZyB0aGUgbGF0ZXN0IGFsZ29zZGtcbiAgICAvLyByZWxlYXNlIHN0YW5kYXJkLlxuICAgIC8vIFRoaXMgd2F5IHdlIGNhbiBkZWNvZGUgdHJhbnNhY3Rpb25zIHN1Y2Nlc3NmdWxseSBieSBzdGlsbCBtYWludGFpbmluZyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgIGNvbnN0IGRlY29kZWRUeCA9IGVuY29kaW5nLmRlY29kZShidWZmZXIpO1xuICAgIGlmIChcbiAgICAgIGRlY29kZWRUeC50eG4gJiZcbiAgICAgIGRlY29kZWRUeC50eG4udHlwZSA9PT0gJ2tleXJlZycgJiZcbiAgICAgIGRlY29kZWRUeC50eG4udm90ZWZzdCAmJlxuICAgICAgZGVjb2RlZFR4LnR4bi52b3RlbHN0ICYmXG4gICAgICBkZWNvZGVkVHgudHhuLnZvdGVrZFxuICAgICkge1xuICAgICAgZGVjb2RlZFR4LnR4bi52b3Rla2V5ID0gZGVjb2RlZFR4LnR4bi52b3Rla2V5IHx8IGRlY29kZWRUeC5tc2lnLnN1YnNpZ1swXS5waztcbiAgICAgIGRlY29kZWRUeC50eG4uc2Vsa2V5ID0gZGVjb2RlZFR4LnR4bi5zZWxrZXkgfHwgZGVjb2RlZFR4Lm1zaWcuc3Vic2lnWzBdLnBrO1xuICAgICAgYnVmZmVyID0gZGVjb2RlZFR4Lm1zaWcgfHwgZGVjb2RlZFR4LnNpZyA/IGVuY29kaW5nLmVuY29kZShkZWNvZGVkVHgpIDogZW5jb2RpbmcuZW5jb2RlKGRlY29kZWRUeC50eG4pO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy50cnlUb0RlY29kZVVuc2lnbmVkVHJhbnNhY3Rpb24oYnVmZmVyKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIElnbm9yZSBlcnJvciB0byB0cnkgZGlmZmVyZW50IGZvcm1hdFxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy50cnlUb0RlY29kZVNpZ25lZFRyYW5zYWN0aW9uKGJ1ZmZlcik7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ1RyYW5zYWN0aW9uIGNhbm5vdCBiZSBkZWNvZGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyeSB0byBkZWNvZGUgYSBzaWduZWQgQWxnbyB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gYnVmZmVyIHRoZSBlbmNvZGVkIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHsgRW5jb2RlZFR4IH0gdGhlIGRlY29kZWQgc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAqIEB0aHJvd3MgZXJyb3IgaWYgaXQgaXMgbm90IGEgdmFsaWQgZW5jb2RlZCBzaWduZWQgdHJhbnNhY3Rpb25cbiAgICovXG4gIHRyeVRvRGVjb2RlU2lnbmVkVHJhbnNhY3Rpb24oYnVmZmVyOiBCdWZmZXIpOiBFbmNvZGVkVHgge1xuICAgIC8vIFRPRE86IFJlcGxhY2Ugd2l0aFxuICAgIC8vIHJldHVybiBhbGdvc2RrLlRyYW5zYWN0aW9uLmZyb21fb2JqX2Zvcl9lbmNvZGluZyhhbGdvc2RrLmRlY29kZVNpZ25lZFRyYW5zYWN0aW9uKGJ1ZmZlcikudHhuKTtcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvcmFuZC9qcy1hbGdvcmFuZC1zZGsvaXNzdWVzLzM2NFxuICAgIC8vIFwiLi4uc29tZSBwYXJ0cyBvZiB0aGUgY29kZWJhc2UgdHJlYXQgdGhlIG91dHB1dCBvZiBUcmFuc2FjdGlvbi5mcm9tX29ial9mb3JfZW5jb2RpbmcgYXMgRW5jb2RlZFRyYW5zYWN0aW9uLlxuICAgIC8vIFRoZXkgbmVlZCB0byBiZSBmaXhlZChvciB3ZSBhdCBsZWFzdCBuZWVkIHRvIG1ha2UgaXQgc28gVHJhbnNhY3Rpb24gY29uZm9ybXMgdG8gRW5jb2RlZFRyYW5zYWN0aW9uKS5cIlxuICAgIGNvbnN0IHR4ID0gYWxnb3Nkay5kZWNvZGVTaWduZWRUcmFuc2FjdGlvbihidWZmZXIpO1xuXG4gICAgY29uc3Qgc2lnbmVyczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCBzaWduZWRCeTogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAodHgubXNpZyAmJiB0eC5tc2lnLnN1YnNpZykge1xuICAgICAgZm9yIChjb25zdCBzaWcgb2YgdHgubXNpZy5zdWJzaWcpIHtcbiAgICAgICAgY29uc3QgYWRkciA9IGFsZ29zZGsuZW5jb2RlQWRkcmVzcyhzaWcucGspO1xuICAgICAgICBzaWduZXJzLnB1c2goYWRkcik7XG4gICAgICAgIGlmIChzaWcucykge1xuICAgICAgICAgIHNpZ25lZEJ5LnB1c2goYWRkcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmF3VHJhbnNhY3Rpb246IG5ldyBVaW50OEFycmF5KGJ1ZmZlciksXG4gICAgICB0eG46IHR4LnR4bixcbiAgICAgIHNpZ25lZDogdHJ1ZSxcbiAgICAgIHNpZ25lcnM6IHNpZ25lcnMsXG4gICAgICBzaWduZWRCeTogc2lnbmVkQnksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnkgdG8gZGVjb2RlIGFuIHVuc2lnbmVkIEFsZ28gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIGJ1ZmZlciB0aGUgZW5jb2RlZCB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJucyB7RW5jb2RlZFR4fSB0aGUgZGVjb2RlZCB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgKiBAdGhyb3dzIGVycm9yIGlmIGl0IGlzIG5vdCBhIHZhbGlkIGVuY29kZWQgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICovXG4gIHRyeVRvRGVjb2RlVW5zaWduZWRUcmFuc2FjdGlvbihidWZmZXI6IEJ1ZmZlcik6IEVuY29kZWRUeCB7XG4gICAgY29uc3QgdHhuID0gYWxnb3Nkay5kZWNvZGVVbnNpZ25lZFRyYW5zYWN0aW9uKGJ1ZmZlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhd1RyYW5zYWN0aW9uOiBuZXcgVWludDhBcnJheShidWZmZXIpLFxuICAgICAgdHhuLFxuICAgICAgc2lnbmVkOiBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgLypcbiAgICogZW5jb2RlT2JqIHRha2VzIGEgamF2YXNjcmlwdCBvYmplY3QgYW5kIHJldHVybnMgaXRzIG1zZ3BhY2sgZW5jb2RpbmdcbiAgICogTm90ZSB0aGF0IHRoZSBlbmNvZGluZyBzb3J0cyB0aGUgZmllbGRzIGFscGhhYmV0aWNhbGx5XG4gICAqXG4gICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgYW55Pn0gb2JqIGpzIG9ialxuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0gVWludDhBcnJheSBiaW5hcnkgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIGVuY29kZU9iaihvYmo6IFJlY29yZDxzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wsIGFueT4pOiBVaW50OEFycmF5IHtcbiAgICByZXR1cm4gYWxnb3Nkay5lbmNvZGVPYmoob2JqKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWNvZGVPYmogdGFrZXMgYSBVaW50OEFycmF5IGFuZCByZXR1cm5zIGl0cyBqYXZhc2NyaXB0IG9ialxuICAgKiBAcGFyYW0gbyAtIFVpbnQ4QXJyYXkgdG8gZGVjb2RlXG4gICAqIEByZXR1cm5zIG9iamVjdFxuICAgKi9cbiAgZGVjb2RlT2JqKG86IEFycmF5TGlrZTxudW1iZXI+KTogdW5rbm93biB7XG4gICAgcmV0dXJuIGFsZ29zZGsuZGVjb2RlT2JqKG8pO1xuICB9XG5cbiAgLyoqXG4gICAqIHNlY3JldEtleVRvTW5lbW9uaWMgdGFrZXMgYW4gQWxnb3JhbnQgc2VjcmV0IGtleSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBtbmVtb25pY1xuICAgKlxuICAgKiBAcGFyYW0gc2sgLSBBbGdvcmFudCBzZWNyZXQga2V5XG4gICAqIEByZXR1cm4gU2VjcmV0IGtleSBpcyBhc3NvY2lhdGVkIG1uZW1vbmljXG4gICAqL1xuICBzZWNyZXRLZXlUb01uZW1vbmljKHNrOiBCdWZmZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IHNrVmFsaWQgPSBCdWZmZXIuZnJvbShzay50b1N0cmluZygnaGV4JykpO1xuICAgIGlmICghdGhpcy5pc1ZhbGlkUHJpdmF0ZUtleShza1ZhbGlkLnRvU3RyaW5nKCdoZXgnKSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkS2V5KGBUaGUgc2VjcmV0IGtleTogJHtzay50b1N0cmluZygnaGV4Jyl9IGlzIGludmFsaWRgKTtcbiAgICB9XG4gICAgY29uc3Qgc2tVbml0OEFycmF5ID0gQnVmZmVyLmZyb20oc2spO1xuICAgIHJldHVybiBhbGdvc2RrLnNlY3JldEtleVRvTW5lbW9uaWMoc2tVbml0OEFycmF5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZWVkRnJvbU1uZW1vbmljIGNvbnZlcnRzIGEgbW5lbW9uaWMgZ2VuZXJhdGVkIHVzaW5nIHRoaXMgbGlicmFyeSBpbnRvIHRoZSBzb3VyY2Uga2V5IHVzZWQgdG8gY3JlYXRlIGl0XG4gICAqIEl0IHJldHVybnMgYW4gZXJyb3IgaWYgdGhlIHBhc3NlZCBtbmVtb25pYyBoYXMgYW4gaW5jb3JyZWN0IGNoZWNrc3VtLCBpZiB0aGUgbnVtYmVyIG9mIHdvcmRzIGlzIHVuZXhwZWN0ZWQsIG9yIGlmIG9uZVxuICAgKiBvZiB0aGUgcGFzc2VkIHdvcmRzIGlzIG5vdCBmb3VuZCBpbiB0aGUgd29yZHMgbGlzdFxuICAgKlxuICAgKiBAcGFyYW0gbW5lbW9uaWMgLSAyNSB3b3JkcyBtbmVtb25pY1xuICAgKiBAcmV0dXJucyAzMiBieXRlcyBsb25nIHNlZWRcbiAgICovXG4gIHNlZWRGcm9tTW5lbW9uaWMobW5lbW9uaWM6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiBhbGdvc2RrLm1uZW1vbmljVG9NYXN0ZXJEZXJpdmF0aW9uS2V5KG1uZW1vbmljKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBrZXlQYWlyRnJvbVNlZWQgZ2VuZXJhdGVzIGFuIG9iamVjdCB3aXRoIHNlY3JldEtleSBhbmQgcHVibGljS2V5IHVzaW5nIHRoZSBhbGdvc2RrXG4gICAqIEBwYXJhbSBzZWVkIDMyIGJ5dGVzIGxvbmcgc2VlZFxuICAgKiBAcmV0dXJucyBLZXlQYWlyXG4gICAqL1xuICBrZXlQYWlyRnJvbVNlZWQoc2VlZDogVWludDhBcnJheSk6IEtleVBhaXIge1xuICAgIGNvbnN0IG1uID0gdGhpcy5tbmVtb25pY0Zyb21TZWVkKHNlZWQpO1xuICAgIGNvbnN0IGJhc2U2NFByaXZhdGVLZXkgPSBhbGdvc2RrLm1uZW1vbmljVG9TZWNyZXRLZXkobW4pLnNrO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUtleVBhaXIoYmFzZTY0UHJpdmF0ZUtleSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBuZXcgYEtleVBhaXJgIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBwcml2YXRlIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGJhc2U2NFByaXZhdGVLZXkgNjQgYnl0ZXMgbG9uZyBwcml2YXRlS2V5XG4gICAqIEByZXR1cm5zIEtleVBhaXJcbiAgICovXG4gIHByb3RlY3RlZCBjcmVhdGVLZXlQYWlyKGJhc2U2NFByaXZhdGVLZXk6IFVpbnQ4QXJyYXkpOiBLZXlQYWlyIHtcbiAgICBjb25zdCBzayA9IGJhc2U2NFByaXZhdGVLZXkuc2xpY2UoMCwgMzIpO1xuICAgIHJldHVybiBuZXcgS2V5UGFpcih7IHBydjogQnVmZmVyLmZyb20oc2spLnRvU3RyaW5nKCdoZXgnKSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWNvZGVQcml2YXRlS2V5IGdlbmVyYXRlcyBhIHNlZWQgd2l0aCBhIG1uZW1vbmljIGFuZCB1c2luZyBhbGdvc2RrLlxuICAgKlxuICAgKiBAcGFyYW0gc2VlZCAzMiBieXRlcyBsb25nIHNlZWRcbiAgICogQHJldHVybnMgbW5lbW9uaWMgLSAyNSB3b3JkcyBtbmVtb25pYyAtIDI1IHdvcmRzIG1uZW1vbmljXG4gICAqL1xuICBwcm90ZWN0ZWQgbW5lbW9uaWNGcm9tU2VlZChzZWVkOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgICByZXR1cm4gYWxnb3Nkay5tYXN0ZXJEZXJpdmF0aW9uS2V5VG9NbmVtb25pYyhzZWVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIGtleSB3aXRoIHRoZSBzdGVsbGFyLXNka1xuICAgKlxuICAgKiBAcGFyYW0gcHVibGljS2V5XG4gICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICovXG4gIHByb3RlY3RlZCBpc1ZhbGlkRWQyNTUxOVB1YmxpY0tleVN0ZWxsYXIocHVibGljS2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGVzIHRoZSBrZXkgd2l0aCB0aGUgc3RlbGxhci1zZGtcbiAgICpcbiAgICogQHBhcmFtIHB1YmxpY0tleVxuICAgKiBAcmV0dXJucyBCdWZmZXJcbiAgICovXG4gIHByb3RlY3RlZCBkZWNvZGVFZDI1NTE5UHVibGljS2V5U3RlbGxhcihwdWJsaWNLZXk6IHN0cmluZyk6IEJ1ZmZlciB7XG4gICAgcmV0dXJuIHN0ZWxsYXIuU3RyS2V5LmRlY29kZUVkMjU1MTlQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgc3RlbGxhciBzZWVkIHRvIGFsZ29yYW5kIGVuY29kaW5nXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIHN0cmluZyB0aGUgZW5jb2RlZCBzZWVkXG4gICAqL1xuICBjb252ZXJ0RnJvbVN0ZWxsYXJTZWVkKHNlZWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFNlZWRFbmNvZGluZy5lbmNvZGUoc3RlbGxhci5TdHJLZXkuZGVjb2RlRWQyNTUxOVNlY3JldFNlZWQoc2VlZCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYWRkcmVzcyBlbmNvZGVkIHdpdGggYWxnb3Nka1xuICAgKlxuICAgKiBAcGFyYW0gYWRkclxuICAgKiBAcmV0dXJucyBzdHJpbmdcbiAgICovXG4gIGVuY29kZUFkZHJlc3MoYWRkcjogVWludDhBcnJheSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGFsZ29zZGsuZW5jb2RlQWRkcmVzcyhhZGRyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYWRkcmVzcyBkZWNvZGVkIHdpdGggYWxnb3Nka1xuICAgKlxuICAgKiBAcGFyYW0gYWRkclxuICAgKiBAcmV0dXJucyBBZGRyZXNzXG4gICAqL1xuICBkZWNvZGVBZGRyZXNzKGFkZHI6IHN0cmluZyk6IEFkZHJlc3Mge1xuICAgIHJldHVybiBhbGdvc2RrLmRlY29kZUFkZHJlc3MoYWRkcik7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gYWRkcmVzcyBpbnRvIGFuIEFMR08gb25lXG4gICAqIElmIHRoZSBnaXZlbiBkYXRhIGlzIGEgU3RlbGxhciBhZGRyZXNzIG9yIHB1YmxpYyBrZXksIGl0IGlzIGNvbnZlcnRlZCB0byBBTEdPIGFkZHJlc3MuXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzT3JQdWJLZXkgYW4gQUxHTyBhZGRyZXNzLCBvciBhbiBTdGVsbGFyIGFkZHJlc3Mgb3IgcHVibGljIGtleVxuICAgKiBAcmV0dXJucyBhZGRyZXNzIGFsZ28gYWRkcmVzcyBzdHJpbmdcbiAgICovXG4gIHN0ZWxsYXJBZGRyZXNzVG9BbGdvQWRkcmVzcyhhZGRyZXNzT3JQdWJLZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgLy8gd2UgaGF2ZSBhbiBBbGdvcmFuZCBhZGRyZXNzXG4gICAgaWYgKHRoaXMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzc09yUHViS2V5KSkge1xuICAgICAgcmV0dXJuIGFkZHJlc3NPclB1YktleTtcbiAgICB9XG4gICAgLy8gd2UgaGF2ZSBhIHN0ZWxsYXIga2V5XG4gICAgaWYgKHRoaXMuaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXlTdGVsbGFyKGFkZHJlc3NPclB1YktleSkpIHtcbiAgICAgIGNvbnN0IHN0ZWxsYXJQdWIgPSB0aGlzLmRlY29kZUVkMjU1MTlQdWJsaWNLZXlTdGVsbGFyKGFkZHJlc3NPclB1YktleSk7XG4gICAgICBjb25zdCBhbGdvQWRkcmVzcyA9IHRoaXMuZW5jb2RlQWRkcmVzcyhzdGVsbGFyUHViKTtcbiAgICAgIGlmICh0aGlzLmlzVmFsaWRBZGRyZXNzKGFsZ29BZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gYWxnb0FkZHJlc3M7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IFN0ZWxsYXIgYWRkcmVzcyB0byBhbiBBbGdvcmFuZCBhZGRyZXNzIHZpYSBwdWJrZXkuJyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTmVpdGhlciBhbiBBbGdvcmFuZCBhZGRyZXNzIG5vciBhIHN0ZWxsYXIgcHVia2V5LicpO1xuICB9XG5cbiAgLyoqXG4gICAqIG11bHRpc2lnQWRkcmVzcyB0YWtlcyBtdWx0aXNpZyBtZXRhZGF0YSAocHJlaW1hZ2UpIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGh1bWFuIHJlYWRhYmxlIEFsZ29yYW5kIGFkZHJlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJzaW9uIG11dGxpc2lnIHZlcnNpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZCBtdWx0aXNpZyB0aHJlc2hvbGRcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gYWRkcnMgbGlzdCBvZiBBbGdvcmFuZCBhZGRyZXNzZXNcbiAgICogQHJldHVybnMge3N0cmluZ30gaHVtYW4gcmVhZGFibGUgQWxnb3JhbmQgYWRkcmVzcy5cbiAgICovXG4gIG11bHRpc2lnQWRkcmVzcyh2ZXJzaW9uOiBudW1iZXIsIHRocmVzaG9sZDogbnVtYmVyLCBhZGRyczogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgIHJldHVybiBhbGdvc2RrLm11bHRpc2lnQWRkcmVzcyh7XG4gICAgICB2ZXJzaW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgYWRkcnMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogZ2VuZXJhdGVBY2NvdW50IGdlbmVyYXRlcyB1biBhY2NvdW50IHdpdGggYSBzZWNyZXRLZXkgYW5kIGFuIGFkZHJlc3NcbiAgICpcbiAgICogRnVuY3Rpb24gaGFzIG5vdCBwYXJhbXNcbiAgICogQHJldHVybnMgQWNjb3VudFxuICAgKi9cbiAgZ2VuZXJhdGVBY2NvdW50KCk6IGFsZ29zZGsuQWNjb3VudCB7XG4gICAgcmV0dXJuIGFsZ29zZGsuZ2VuZXJhdGVBY2NvdW50KCk7XG4gIH1cblxuICBnZW5lcmF0ZUFjY291bnRGcm9tU2VlZChzZWVkOiBVaW50OEFycmF5KTogYWxnb3Nkay5BY2NvdW50IHtcbiAgICBjb25zdCBrZXlzID0gbmFjbC5zaWduLmtleVBhaXIuZnJvbVNlZWQoc2VlZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZHI6IGFsZ29zZGsuZW5jb2RlQWRkcmVzcyhrZXlzLnB1YmxpY0tleSksXG4gICAgICBzazoga2V5cy5zZWNyZXRLZXksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgVHggSUQgZnJvbSBhbiBlbmNvZGVkIG11bHRpc2lnIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIFRoaXMgaXMgZG9uZSBiZWNhdXNlIG9mIGEgY2hhbmdlIG1hZGUgb24gdmVyc2lvbiAxLjEwLjEgb24gYWxnb3NkayBzbyBtZXRob2QgdHhJRCgpIG9ubHkgc3VwcG9ydHMgU2lnbmVkVHJhbnNhY3Rpb24gdHlwZS5cbiAgICogKGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvcmFuZC9qcy1hbGdvcmFuZC1zZGsvYmxvYi9kZXZlbG9wL0NIQU5HRUxPRy5tZCMxMTAxKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHhCYXNlNjQgLSBlbmNvZGVkIGJhc2U2NCBtdWx0aXNpZyB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRyYW5zYWN0aW9uIElEXG4gICAqL1xuICBnZXRNdWx0aXNpZ1R4SUQodHhCYXNlNjQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgdHhCeXRlcyA9IEJ1ZmZlci5mcm9tKHR4QmFzZTY0LCAnYmFzZTY0Jyk7XG4gICAgY29uc3QgZGVjb2RlU2lnblR4ID0gYWxnb3Nkay5kZWNvZGVTaWduZWRUcmFuc2FjdGlvbih0eEJ5dGVzKTtcbiAgICBjb25zdCB3ZWxsRm9ybWVkRGVjb2RlZFNpZ25UeCA9IGRlY29kZVNpZ25UeC50eG4uZ2V0X29ial9mb3JfZW5jb2RpbmcoKTtcbiAgICBjb25zdCB0eEZvckVuY29kaW5nID0geyBtc2lnOiBkZWNvZGVTaWduVHgubXNpZywgdHhuOiB3ZWxsRm9ybWVkRGVjb2RlZFNpZ25UeCB9O1xuICAgIGNvbnN0IGVuX21zZyA9IGVuY29kaW5nLmVuY29kZSh0eEZvckVuY29kaW5nKTtcbiAgICBjb25zdCB0YWcgPSBCdWZmZXIuZnJvbShbODQsIDg4XSk7XG4gICAgY29uc3QgZ2ggPSBCdWZmZXIuZnJvbShjb25jYXRBcnJheXModGFnLCBlbl9tc2cpKTtcbiAgICBjb25zdCBoYXNoID0gQnVmZmVyLmZyb20oYWxnb05hY2wuZ2VuZXJpY0hhc2goZ2gpKTtcbiAgICByZXR1cm4gYmFzZTMyLmVuY29kZShoYXNoKS5zbGljZSgwLCBBTEdPUkFORF9UUkFOU0FDVElPTl9MRU5HVEgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgYSBnaXZlbiB0cmFuc2FjdGlvbiBkYXRhIGlzIHRvIGVuYWJsZSBvciBkaXNhYmxlIGEgdG9rZW5cbiAgICogQHBhcmFtIGFtb3VudCB0aGUgYW1vdW50IGluIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBmcm9tIHRoZSBvcmlnaW5hdGVkIGFkZHJlc3NcbiAgICogQHBhcmFtIHRvIHRoZSB0YXJnZXQgYWRkcmVzc1xuICAgKiBAcGFyYW0gY2xvc2VSZW1haW5kZXJUbyAob3B0aW9uYWwpIGFkZHJlc3MgdG8gc2VuZCByZW1haW5pbmcgdW5pdHMgaW4gb3JpZ2luYXRlZCBhZGRyZXNzXG4gICAqIEByZXR1cm5zICdlbmFibGVUb2tlbicgb3IgJ2Rpc2FibGVUb2tlbidcbiAgICovXG4gIGdldFRva2VuVHhUeXBlKGFtb3VudDogc3RyaW5nLCBmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcsIGNsb3NlUmVtYWluZGVyVG8/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGxldCB0eXBlID0gJ3RyYW5zZmVyVG9rZW4nO1xuICAgIGlmIChhbW91bnQgPT09ICcwJyAmJiBmcm9tID09PSB0bykge1xuICAgICAgdHlwZSA9ICFjbG9zZVJlbWFpbmRlclRvID8gJ2VuYWJsZVRva2VuJyA6ICdkaXNhYmxlVG9rZW4nO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBpZiB0aGUga2V5IGlzIGEgdmFsaWQgYmFzZTY0IHN0cmluZ1xuICAgKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdmFsaWRhdGVcbiAgICovXG4gIHZhbGlkYXRlQmFzZTY0KGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFrZXkgfHwgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiYXNlNjQgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IGJhc2U2NFJlZ0V4cCA9XG4gICAgICAvXig/OlthLXpBLVowLTkrXFwvXXs0fSkqKD86fCg/OlthLXpBLVowLTkrXFwvXXszfT0pfCg/OlthLXpBLVowLTkrXFwvXXsyfT09KXwoPzpbYS16QS1aMC05K1xcL117MX09PT0pKSQvO1xuICAgIGlmICghYmFzZTY0UmVnRXhwLnRlc3Qoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJhc2U2NCBzdHJpbmcnKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgdXRpbHMgPSBuZXcgVXRpbHMoKTtcblxuZXhwb3J0IGRlZmF1bHQgdXRpbHM7XG4iXX0=