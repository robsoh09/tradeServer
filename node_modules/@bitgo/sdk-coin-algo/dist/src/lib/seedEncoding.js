"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SeedEncoding = void 0;
const base32 = __importStar(require("hi-base32"));
const js_sha512_1 = __importDefault(require("js-sha512"));
const SEED_BYTES_LENGTH = 32;
const ALGORAND_SEED_BYTE_LENGTH = 36;
const ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
const ALGORAND_SEED_LENGTH = 58;
class SeedEncoding {
    static genericHash(arr) {
        return js_sha512_1.default.sha512_256.array(arr);
    }
    /**
     * Checks if a seed is valid
     * @param {String} seed - encoded Algorand seed
     * @returns {Boolean} true if valid, false otherwise
     */
    static isValidSeed(seed) {
        if (seed.length !== ALGORAND_SEED_LENGTH) {
            return false;
        }
        // Try to decode
        let decoded;
        try {
            decoded = SeedEncoding.decode(seed);
        }
        catch (e) {
            return false;
        }
        // Compute checksum
        const checksum = SeedEncoding.genericHash(decoded.seed).slice(SEED_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, SEED_BYTES_LENGTH);
        // Check if the checksum and the seed are equal
        if (checksum.length !== decoded.checksum.length) {
            return false;
        }
        return checksum.every((val, i) => val === decoded.checksum[i]);
    }
    /**
     * Decode a seed
     *
     * @param seed
     * @return {{checksum: Uint8Array, seed: Uint8Array}}
     */
    static decode(seed) {
        // try to decode
        const decoded = base32.decode.asBytes(seed);
        // Sanity check
        if (decoded.length !== ALGORAND_SEED_BYTE_LENGTH)
            throw new Error('seed seems to be malformed');
        return {
            seed: new Uint8Array(decoded.slice(0, ALGORAND_SEED_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH)),
            checksum: new Uint8Array(decoded.slice(SEED_BYTES_LENGTH, ALGORAND_SEED_BYTE_LENGTH)),
        };
    }
    /**
     * Encode a secret key into a seed
     *
     * @param secretKey
     * @return {String} encoded seed
     */
    static encode(secretKey) {
        // get seed
        const seed = secretKey.slice(0, SEED_BYTES_LENGTH);
        // compute checksum
        const checksum = SeedEncoding.genericHash(seed).slice(SEED_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, SEED_BYTES_LENGTH);
        const arraySeed = new Uint8Array(seed.length + checksum.length);
        arraySeed.set(seed);
        arraySeed.set(checksum, seed.length);
        const encodedSeed = base32.encode(arraySeed);
        return encodedSeed.toString().slice(0, ALGORAND_SEED_LENGTH); // removing the extra '===='
    }
}
exports.SeedEncoding = SeedEncoding;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VlZEVuY29kaW5nLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9zZWVkRW5jb2RpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxrREFBb0M7QUFDcEMsMERBQStCO0FBRy9CLE1BQU0saUJBQWlCLEdBQUcsRUFBRSxDQUFDO0FBQzdCLE1BQU0seUJBQXlCLEdBQUcsRUFBRSxDQUFDO0FBQ3JDLE1BQU0sNkJBQTZCLEdBQUcsQ0FBQyxDQUFDO0FBQ3hDLE1BQU0sb0JBQW9CLEdBQUcsRUFBRSxDQUFDO0FBRWhDLE1BQWEsWUFBWTtJQUNmLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBZTtRQUN4QyxPQUFPLG1CQUFNLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBWTtRQUM3QixJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssb0JBQW9CLEVBQUU7WUFDeEMsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUVELGdCQUFnQjtRQUNoQixJQUFJLE9BQWEsQ0FBQztRQUNsQixJQUFJO1lBQ0YsT0FBTyxHQUFHLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDckM7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFFRCxtQkFBbUI7UUFDbkIsTUFBTSxRQUFRLEdBQUcsWUFBWSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUMzRCxpQkFBaUIsR0FBRyw2QkFBNkIsRUFDakQsaUJBQWlCLENBQ2xCLENBQUM7UUFFRiwrQ0FBK0M7UUFDL0MsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLE9BQU8sQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFO1lBQy9DLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFDRCxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEtBQUssT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBWTtRQUN4QixnQkFBZ0I7UUFDaEIsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFNUMsZUFBZTtRQUNmLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyx5QkFBeUI7WUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7UUFFaEcsT0FBTztZQUNMLElBQUksRUFBRSxJQUFJLFVBQVUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSx5QkFBeUIsR0FBRyw2QkFBNkIsQ0FBQyxDQUFDO1lBQ2pHLFFBQVEsRUFBRSxJQUFJLFVBQVUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLGlCQUFpQixFQUFFLHlCQUF5QixDQUFDLENBQUM7U0FDdEYsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBcUI7UUFDakMsV0FBVztRQUNYLE1BQU0sSUFBSSxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLGlCQUFpQixDQUFDLENBQUM7UUFDbkQsbUJBQW1CO1FBQ25CLE1BQU0sUUFBUSxHQUFHLFlBQVksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUNuRCxpQkFBaUIsR0FBRyw2QkFBNkIsRUFDakQsaUJBQWlCLENBQ2xCLENBQUM7UUFDRixNQUFNLFNBQVMsR0FBRyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNoRSxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BCLFNBQVMsQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNyQyxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRTdDLE9BQU8sV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLDRCQUE0QjtJQUM1RixDQUFDO0NBQ0Y7QUE1RUQsb0NBNEVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYmFzZTMyIGZyb20gJ2hpLWJhc2UzMic7XG5pbXBvcnQgc2hhNTEyIGZyb20gJ2pzLXNoYTUxMic7XG5pbXBvcnQgeyBTZWVkIH0gZnJvbSAnLi9pZmFjZXMnO1xuXG5jb25zdCBTRUVEX0JZVEVTX0xFTkdUSCA9IDMyO1xuY29uc3QgQUxHT1JBTkRfU0VFRF9CWVRFX0xFTkdUSCA9IDM2O1xuY29uc3QgQUxHT1JBTkRfQ0hFQ0tTVU1fQllURV9MRU5HVEggPSA0O1xuY29uc3QgQUxHT1JBTkRfU0VFRF9MRU5HVEggPSA1ODtcblxuZXhwb3J0IGNsYXNzIFNlZWRFbmNvZGluZyB7XG4gIHByaXZhdGUgc3RhdGljIGdlbmVyaWNIYXNoKGFycjogVWludDhBcnJheSk6IG51bWJlcltdIHtcbiAgICByZXR1cm4gc2hhNTEyLnNoYTUxMl8yNTYuYXJyYXkoYXJyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBzZWVkIGlzIHZhbGlkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWVkIC0gZW5jb2RlZCBBbGdvcmFuZCBzZWVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkU2VlZChzZWVkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoc2VlZC5sZW5ndGggIT09IEFMR09SQU5EX1NFRURfTEVOR1RIKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIGRlY29kZVxuICAgIGxldCBkZWNvZGVkOiBTZWVkO1xuICAgIHRyeSB7XG4gICAgICBkZWNvZGVkID0gU2VlZEVuY29kaW5nLmRlY29kZShzZWVkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBjaGVja3N1bVxuICAgIGNvbnN0IGNoZWNrc3VtID0gU2VlZEVuY29kaW5nLmdlbmVyaWNIYXNoKGRlY29kZWQuc2VlZCkuc2xpY2UoXG4gICAgICBTRUVEX0JZVEVTX0xFTkdUSCAtIEFMR09SQU5EX0NIRUNLU1VNX0JZVEVfTEVOR1RILFxuICAgICAgU0VFRF9CWVRFU19MRU5HVEhcbiAgICApO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNoZWNrc3VtIGFuZCB0aGUgc2VlZCBhcmUgZXF1YWxcbiAgICBpZiAoY2hlY2tzdW0ubGVuZ3RoICE9PSBkZWNvZGVkLmNoZWNrc3VtLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW0uZXZlcnkoKHZhbCwgaSkgPT4gdmFsID09PSBkZWNvZGVkLmNoZWNrc3VtW2ldKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzZWVkXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm4ge3tjaGVja3N1bTogVWludDhBcnJheSwgc2VlZDogVWludDhBcnJheX19XG4gICAqL1xuICBzdGF0aWMgZGVjb2RlKHNlZWQ6IHN0cmluZyk6IFNlZWQge1xuICAgIC8vIHRyeSB0byBkZWNvZGVcbiAgICBjb25zdCBkZWNvZGVkID0gYmFzZTMyLmRlY29kZS5hc0J5dGVzKHNlZWQpO1xuXG4gICAgLy8gU2FuaXR5IGNoZWNrXG4gICAgaWYgKGRlY29kZWQubGVuZ3RoICE9PSBBTEdPUkFORF9TRUVEX0JZVEVfTEVOR1RIKSB0aHJvdyBuZXcgRXJyb3IoJ3NlZWQgc2VlbXMgdG8gYmUgbWFsZm9ybWVkJyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2VlZDogbmV3IFVpbnQ4QXJyYXkoZGVjb2RlZC5zbGljZSgwLCBBTEdPUkFORF9TRUVEX0JZVEVfTEVOR1RIIC0gQUxHT1JBTkRfQ0hFQ0tTVU1fQllURV9MRU5HVEgpKSxcbiAgICAgIGNoZWNrc3VtOiBuZXcgVWludDhBcnJheShkZWNvZGVkLnNsaWNlKFNFRURfQllURVNfTEVOR1RILCBBTEdPUkFORF9TRUVEX0JZVEVfTEVOR1RIKSksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgYSBzZWNyZXQga2V5IGludG8gYSBzZWVkXG4gICAqXG4gICAqIEBwYXJhbSBzZWNyZXRLZXlcbiAgICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIHNlZWRcbiAgICovXG4gIHN0YXRpYyBlbmNvZGUoc2VjcmV0S2V5OiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgICAvLyBnZXQgc2VlZFxuICAgIGNvbnN0IHNlZWQgPSBzZWNyZXRLZXkuc2xpY2UoMCwgU0VFRF9CWVRFU19MRU5HVEgpO1xuICAgIC8vIGNvbXB1dGUgY2hlY2tzdW1cbiAgICBjb25zdCBjaGVja3N1bSA9IFNlZWRFbmNvZGluZy5nZW5lcmljSGFzaChzZWVkKS5zbGljZShcbiAgICAgIFNFRURfQllURVNfTEVOR1RIIC0gQUxHT1JBTkRfQ0hFQ0tTVU1fQllURV9MRU5HVEgsXG4gICAgICBTRUVEX0JZVEVTX0xFTkdUSFxuICAgICk7XG4gICAgY29uc3QgYXJyYXlTZWVkID0gbmV3IFVpbnQ4QXJyYXkoc2VlZC5sZW5ndGggKyBjaGVja3N1bS5sZW5ndGgpO1xuICAgIGFycmF5U2VlZC5zZXQoc2VlZCk7XG4gICAgYXJyYXlTZWVkLnNldChjaGVja3N1bSwgc2VlZC5sZW5ndGgpO1xuICAgIGNvbnN0IGVuY29kZWRTZWVkID0gYmFzZTMyLmVuY29kZShhcnJheVNlZWQpO1xuXG4gICAgcmV0dXJuIGVuY29kZWRTZWVkLnRvU3RyaW5nKCkuc2xpY2UoMCwgQUxHT1JBTkRfU0VFRF9MRU5HVEgpOyAvLyByZW1vdmluZyB0aGUgZXh0cmEgJz09PT0nXG4gIH1cbn1cbiJdfQ==