/// <reference types="node" />
import { AddressCoinSpecific, BaseBroadcastTransactionOptions, BaseBroadcastTransactionResult, BaseCoin, BitGoBase, KeyPair, ParsedTransaction, ParseTransactionOptions, SignedTransaction, SignTransactionOptions as BaseSignTransactionOptions, TokenManagementType, TransactionExplanation, VerifyAddressOptions, VerifyTransactionOptions } from '@bitgo/sdk-core';
import * as algosdk from 'algosdk';
import { Buffer } from 'buffer';
export interface AlgoAddressCoinSpecifics extends AddressCoinSpecific {
    rootAddress: string;
    bitgoKey: string;
    bitgoPubKey?: string;
    addressVersion: number;
    threshold: number;
}
export interface VerifyAlgoAddressOptions extends VerifyAddressOptions {
    chain: number;
    index: number;
    coin: string;
    wallet: string;
    coinSpecific: AlgoAddressCoinSpecifics;
}
export interface AlgoTransactionExplanation extends TransactionExplanation {
    memo?: string;
    type?: string | number;
    voteKey?: string;
    selectionKey?: string;
    voteFirst?: number;
    voteLast?: number;
    voteKeyDilution?: number;
    tokenId?: number;
    operations?: TransactionOperation[];
}
export interface TransactionOperation {
    type: string;
    coin: string;
}
export interface SignTransactionOptions extends BaseSignTransactionOptions {
    txPrebuild: TransactionPrebuild;
    prv: string;
}
export interface TransactionPrebuild {
    txHex: string;
    halfSigned?: {
        txHex: string;
    };
    txInfo: {
        from: string;
        to: string;
        amount: string;
        fee: number;
        firstRound: number;
        lastRound: number;
        genesisID: string;
        genesisHash: string;
        note?: string;
    };
    keys: string[];
    addressVersion: number;
}
export interface FullySignedTransaction {
    txHex: string;
}
export interface HalfSignedTransaction {
    halfSigned: {
        txHex: string;
    };
}
export interface TransactionFee {
    fee: string;
}
export interface ExplainTransactionOptions {
    txHex?: string;
    halfSigned?: {
        txHex: string;
    };
    publicKeys?: string[];
    feeInfo: TransactionFee;
}
interface NodeParams {
    token: string;
    baseServer: string;
    port: number;
}
export interface VerifiedTransactionParameters {
    txHex: string;
    addressVersion: number;
    signers: string[];
    prv: string;
    isHalfSigned: boolean;
    numberSigners: number;
}
export interface RecoveryOptions {
    backupKey: string;
    userKey: string;
    rootAddress: string;
    recoveryDestination: string;
    bitgoKey: string;
    walletPassphrase?: string;
    fee: number;
    firstRound?: number;
    note?: string;
    nodeParams: NodeParams;
}
interface RecoveryInfo {
    id: string;
    tx: string;
    coin: string;
    fee: number;
    firstRound: number;
    lastRound: number;
    genesisId: string;
    genesisHash: string;
    note?: string;
}
export interface OfflineVaultTxInfo {
    txHex: string;
    userKey: string;
    backupKey: string;
    bitgoKey: string;
    type?: string;
    address: string;
    coin: string;
    feeInfo: number;
    amount: string;
    firstRound: number;
    lastRound: number;
    genesisId: string;
    genesisHash: string;
    note?: string;
    addressVersion: number;
    keys: string[];
}
export interface BroadcastTransactionOptions extends BaseBroadcastTransactionOptions {
    nodeParams: NodeParams;
}
export declare class Algo extends BaseCoin {
    readonly ENABLE_TOKEN: TokenManagementType;
    readonly DISABLE_TOKEN: TokenManagementType;
    constructor(bitgo: BitGoBase);
    static createInstance(bitgo: BitGoBase): BaseCoin;
    getChain(): string;
    getBaseChain(): string;
    getFamily(): string;
    getFullName(): string;
    getBaseFactor(): number | string;
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed(): boolean;
    /**
     * Algorand supports account consolidations. These are transfers from the receive addresses
     * to the main address.
     */
    allowsAccountConsolidations(): boolean;
    /** inheritdoc */
    deriveKeyWithSeed(): {
        derivationPath: string;
        key: string;
    };
    /** inheritdoc */
    generateKeyPair(seed?: Buffer): KeyPair;
    /** inheritdoc */
    generateRootKeyPair(seed?: Buffer): KeyPair;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub: string): boolean;
    /**
     * Return boolean indicating whether input is valid seed for the coin
     * In Algorand, when the private key is encoded as base32 string only the first 32 bytes are taken,
     * so the encoded value is actually the seed
     *
     * @param {String} prv the prv to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPrv(prv: string): boolean;
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {String} address the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidAddress(address: string): boolean;
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    signMessage(key: KeyPair, message: string | Buffer): Promise<Buffer>;
    /**
     * Specifies what key we will need for signing` - Algorand needs the backup, bitgo pubs.
     */
    keyIdsForSigning(): number[];
    getTokenNameById(tokenId: number | string): string;
    /**
     * Explain/parse transaction
     * @param params
     */
    explainTransaction(params: ExplainTransactionOptions): Promise<AlgoTransactionExplanation | undefined>;
    /**
     * returns if a tx is a token tx
     * @param type {string} - tx type
     * @returns true if it's a token tx
     */
    isTokenTx(type: string): boolean;
    /**
     * Check if a seed is a valid stellar seed
     *
     * @param {String} seed the seed to check
     * @returns {Boolean} true if the input is a Stellar seed
     */
    isStellarSeed(seed: string): boolean;
    /**
     * Convert a stellar seed to an algo seed
     *
     * @param {String} seed the seed to convert
     * @returns {Boolean | null} seed in algo encoding
     */
    convertFromStellarSeed(seed: string): string | null;
    verifySignTransactionParams(params: SignTransactionOptions): VerifiedTransactionParameters;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {TransactionPrebuild} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @returns {Promise<SignedTransaction>}
     */
    signTransaction(params: SignTransactionOptions): Promise<SignedTransaction>;
    parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
    /**
     * Check if address can be used to send funds.
     *
     * @param params.address address to validate
     * @param params.keychains public keys to generate the wallet
     */
    isWalletAddress(params: VerifyAlgoAddressOptions): Promise<boolean>;
    verifyTransaction(params: VerifyTransactionOptions): Promise<boolean>;
    decodeTx(txn: Buffer): unknown;
    getAddressFromPublicKey(pubKey: Uint8Array): string;
    supportsDeriveKeyWithSeed(): boolean;
    /**
     * Gets config for how token enablements work for this coin
     * @returns
     *    requiresTokenEnablement: True if tokens need to be enabled for this coin
     *    supportsMultipleTokenEnablements: True if multiple tokens can be enabled in one transaction
     */
    getTokenEnablementConfig(): {
        requiresTokenEnablement: boolean;
        supportsMultipleTokenEnablements: boolean;
    };
    /**
     * Gets the balance of the root address in base units of algo
     * Eg. If balance is 1 Algo, this returns 1*10^6
     * @param rootAddress
     * @param client
     */
    getAccountBalance(rootAddress: string, client: algosdk.Algodv2): Promise<number>;
    /**
     * Returns the Algo client for the given token, baseServer and port
     * Used to interact with the Algo network
     */
    getClient(token: string, baseServer: string, port: number): algosdk.Algodv2;
    recover(params: RecoveryOptions): Promise<RecoveryInfo | OfflineVaultTxInfo>;
    /**
     * Accepts a fully signed serialized base64 transaction and broadcasts it on the network.
     * Uses the external node provided by the client
     * @param serializedSignedTransaction
     * @param nodeParams
     */
    broadcastTransaction({ serializedSignedTransaction, nodeParams, }: BroadcastTransactionOptions): Promise<BaseBroadcastTransactionResult>;
    /**
     * Stellar and Algorand both use keys on the ed25519 curve, but use different encodings.
     * As the HSM doesn't have explicit support to create Algorand addresses, we use the Stellar
     * keys and re-encode them to the Algorand encoding.
     *
     * This method should only be used when creating Algorand custodial wallets reusing Stellar keys.
     *
     * @param {string} addressOrPubKey a Stellar pubkey or Algorand address
     * @return {*}
     */
    private stellarAddressToAlgoAddress;
    private getBuilder;
}
export {};
//# sourceMappingURL=algo.d.ts.map