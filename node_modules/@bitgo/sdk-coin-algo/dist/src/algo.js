"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Algo = void 0;
/**
 * @prettier
 */
const _ = __importStar(require("lodash"));
const seedValidator_1 = require("./seedValidator");
const statics_1 = require("@bitgo/statics");
const AlgoLib = __importStar(require("./lib"));
const sdk_core_1 = require("@bitgo/sdk-core");
const stellar_sdk_1 = __importDefault(require("stellar-sdk"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const utils_1 = __importDefault(require("./lib/utils"));
const algosdk = __importStar(require("algosdk"));
const transactionBuilder_1 = require("./lib/transactionBuilder");
const buffer_1 = require("buffer");
const SUPPORTED_ADDRESS_VERSION = 1;
const MSIG_THRESHOLD = 2; // m in m-of-n
class Algo extends sdk_core_1.BaseCoin {
    constructor(bitgo) {
        super(bitgo);
        this.ENABLE_TOKEN = 'enabletoken';
        this.DISABLE_TOKEN = 'disabletoken';
    }
    static createInstance(bitgo) {
        return new Algo(bitgo);
    }
    getChain() {
        return 'algo';
    }
    getBaseChain() {
        return 'algo';
    }
    getFamily() {
        return 'algo';
    }
    getFullName() {
        return 'Algorand';
    }
    getBaseFactor() {
        return 1e6;
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return true;
    }
    /**
     * Algorand supports account consolidations. These are transfers from the receive addresses
     * to the main address.
     */
    allowsAccountConsolidations() {
        return true;
    }
    /** inheritdoc */
    deriveKeyWithSeed() {
        throw new sdk_core_1.NotSupported('method deriveKeyWithSeed not supported for eddsa curve');
    }
    /** inheritdoc */
    generateKeyPair(seed) {
        const keyPair = seed ? new AlgoLib.KeyPair({ seed }) : new AlgoLib.KeyPair();
        const keys = keyPair.getKeys();
        if (!keys.prv) {
            throw new Error('Missing prv in key generation.');
        }
        return {
            pub: keyPair.getAddress(),
            prv: AlgoLib.algoUtils.encodeSeed(buffer_1.Buffer.from(keyPair.getSigningKey())),
        };
    }
    /** inheritdoc */
    generateRootKeyPair(seed) {
        const keyPair = seed ? new AlgoLib.KeyPair({ seed }) : new AlgoLib.KeyPair();
        const keys = keyPair.getKeys();
        if (!keys.prv) {
            throw new Error('Missing prv in key generation.');
        }
        return { prv: keys.prv + keys.pub, pub: keys.pub };
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub) {
        return AlgoLib.algoUtils.isValidAddress(pub) || AlgoLib.algoUtils.isValidPublicKey(pub);
    }
    /**
     * Return boolean indicating whether input is valid seed for the coin
     * In Algorand, when the private key is encoded as base32 string only the first 32 bytes are taken,
     * so the encoded value is actually the seed
     *
     * @param {String} prv the prv to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPrv(prv) {
        return AlgoLib.algoUtils.isValidSeed(prv) || AlgoLib.algoUtils.isValidPrivateKey(prv);
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {String} address the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidAddress(address) {
        return AlgoLib.algoUtils.isValidAddress(address);
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        const algoKeypair = new AlgoLib.KeyPair({ prv: key.prv });
        if (buffer_1.Buffer.isBuffer(message)) {
            message = message.toString('base64');
        }
        return buffer_1.Buffer.from(algoKeypair.signMessage(message));
    }
    /**
     * Specifies what key we will need for signing` - Algorand needs the backup, bitgo pubs.
     */
    keyIdsForSigning() {
        return [sdk_core_1.KeyIndices.USER, sdk_core_1.KeyIndices.BACKUP, sdk_core_1.KeyIndices.BITGO];
    }
    getTokenNameById(tokenId) {
        const tokenNames = statics_1.coins.filter((coin) => coin.family === 'algo' && coin.isToken).map(({ name }) => name);
        return tokenNames.find((tokenName) => tokenName.split('-')[1] === `${tokenId}`) || 'AlgoToken unknown';
    }
    /**
     * Explain/parse transaction
     * @param params
     */
    async explainTransaction(params) {
        const txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
        if (!txHex || !params.feeInfo) {
            throw new Error('missing explain tx parameters');
        }
        const factory = this.getBuilder();
        const txBuilder = factory.from(txHex);
        const tx = await txBuilder.build();
        const txJson = tx.toJson();
        if (tx.type === sdk_core_1.TransactionType.Send) {
            const outputs = [
                {
                    address: txJson.to,
                    amount: txJson.amount,
                    memo: txJson.note,
                },
            ];
            const operations = [];
            const isTokenTx = this.isTokenTx(txJson.type);
            if (isTokenTx) {
                const type = AlgoLib.algoUtils.getTokenTxType(txJson.amount, txJson.from, txJson.to, txJson.closeRemainderTo);
                operations.push({
                    type: type,
                    coin: this.getTokenNameById(txJson.tokenId),
                });
            }
            const displayOrder = [
                'id',
                'outputAmount',
                'changeAmount',
                'outputs',
                'changeOutputs',
                'fee',
                'memo',
                'type',
                'operations',
            ];
            const explanationResult = {
                displayOrder,
                id: txJson.id,
                outputAmount: txJson.amount.toString(),
                changeAmount: '0',
                outputs,
                changeOutputs: [],
                fee: txJson.fee,
                memo: txJson.note,
                type: tx.type.toString(),
                operations,
            };
            if (txJson.tokenId) {
                explanationResult.tokenId = txJson.tokenId;
            }
            return explanationResult;
        }
        if (tx.type === sdk_core_1.TransactionType.WalletInitialization) {
            const displayOrder = [
                'id',
                'fee',
                'memo',
                'type',
                'voteKey',
                'selectionKey',
                'voteFirst',
                'voteLast',
                'voteKeyDilution',
            ];
            return {
                displayOrder,
                id: txJson.id,
                outputAmount: '0',
                changeAmount: '0',
                outputs: [],
                changeOutputs: [],
                fee: txJson.fee,
                memo: txJson.note,
                type: tx.type,
                voteKey: txJson.voteKey,
                selectionKey: txJson.selectionKey,
                voteFirst: txJson.voteFirst,
                voteLast: txJson.voteLast,
                voteKeyDilution: txJson.voteKeyDilution,
            };
        }
    }
    /**
     * returns if a tx is a token tx
     * @param type {string} - tx type
     * @returns true if it's a token tx
     */
    isTokenTx(type) {
        return type === 'axfer';
    }
    /**
     * Check if a seed is a valid stellar seed
     *
     * @param {String} seed the seed to check
     * @returns {Boolean} true if the input is a Stellar seed
     */
    isStellarSeed(seed) {
        return seedValidator_1.SeedValidator.isValidEd25519SeedForCoin(seed, statics_1.CoinFamily.XLM);
    }
    /**
     * Convert a stellar seed to an algo seed
     *
     * @param {String} seed the seed to convert
     * @returns {Boolean | null} seed in algo encoding
     */
    convertFromStellarSeed(seed) {
        // assume this is a trust custodial seed if its a valid ed25519 prv
        if (!this.isStellarSeed(seed) || seedValidator_1.SeedValidator.hasCompetingSeedFormats(seed)) {
            return null;
        }
        if (seedValidator_1.SeedValidator.isValidEd25519SeedForCoin(seed, statics_1.CoinFamily.XLM)) {
            return AlgoLib.algoUtils.convertFromStellarSeed(seed);
        }
        return null;
    }
    verifySignTransactionParams(params) {
        const prv = params.prv;
        const addressVersion = params.txPrebuild.addressVersion;
        let isHalfSigned = false;
        // it's possible this tx was already signed - take the halfSigned
        // txHex if it is
        let txHex = params.txPrebuild.txHex;
        if (params.txPrebuild.halfSigned) {
            isHalfSigned = true;
            txHex = params.txPrebuild.halfSigned.txHex;
        }
        if (_.isUndefined(txHex)) {
            throw new Error('missing txPrebuild parameter');
        }
        if (!_.isString(txHex)) {
            throw new Error(`txPrebuild must be an object, got type ${typeof txHex}`);
        }
        if (_.isUndefined(prv)) {
            throw new Error('missing prv parameter to sign transaction');
        }
        if (!_.isString(prv)) {
            throw new Error(`prv must be a string, got type ${typeof prv}`);
        }
        if (!_.has(params.txPrebuild, 'keys')) {
            throw new Error('missing public keys parameter to sign transaction');
        }
        if (!_.isNumber(addressVersion)) {
            throw new Error('missing addressVersion parameter to sign transaction');
        }
        const signers = params.txPrebuild.keys.map((key) => {
            // if we are receiving addresses do not try to convert them
            if (!AlgoLib.algoUtils.isValidAddress(key)) {
                return AlgoLib.algoUtils.publicKeyToAlgoAddress(AlgoLib.algoUtils.toUint8Array(key));
            }
            return key;
        });
        // TODO(https://bitgoinc.atlassian.net/browse/STLX-6067): fix the number of signers using
        // should be similar to other coins implementation
        // If we have a number with digits to eliminate them without taking any rounding criteria.
        const numberSigners = Math.trunc(signers.length / 2) + 1;
        return { txHex, addressVersion, signers, prv, isHalfSigned, numberSigners };
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {TransactionPrebuild} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @returns {Promise<SignedTransaction>}
     */
    async signTransaction(params) {
        const { txHex, signers, prv, isHalfSigned, numberSigners } = this.verifySignTransactionParams(params);
        const factory = this.getBuilder();
        const txBuilder = factory.from(txHex);
        txBuilder.numberOfRequiredSigners(numberSigners);
        txBuilder.sign({ key: prv });
        txBuilder.setSigners(signers);
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new Error('Invalid transaction');
        }
        const signedTxHex = buffer_1.Buffer.from(transaction.toBroadcastFormat()).toString('base64');
        if (numberSigners === 1) {
            return { txHex: signedTxHex };
        }
        else if (isHalfSigned) {
            return { txHex: signedTxHex };
        }
        else {
            return { halfSigned: { txHex: signedTxHex } };
        }
    }
    async parseTransaction(params) {
        return {};
    }
    /**
     * Check if address can be used to send funds.
     *
     * @param params.address address to validate
     * @param params.keychains public keys to generate the wallet
     */
    async isWalletAddress(params) {
        const { address, keychains, coinSpecific: { bitgoPubKey }, } = params;
        if (!this.isValidAddress(address)) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        if (!keychains) {
            throw new Error('missing required param keychains');
        }
        const effectiveKeychain = bitgoPubKey ? keychains.slice(0, -1).concat([{ pub: bitgoPubKey }]) : keychains;
        const pubKeys = effectiveKeychain.map((key) => this.stellarAddressToAlgoAddress(key.pub));
        if (!pubKeys.every((pubKey) => this.isValidPub(pubKey))) {
            throw new sdk_core_1.InvalidKey('invalid public key');
        }
        const rootAddress = AlgoLib.algoUtils.multisigAddress(SUPPORTED_ADDRESS_VERSION, MSIG_THRESHOLD, pubKeys);
        return rootAddress === address;
    }
    async verifyTransaction(params) {
        return true;
    }
    decodeTx(txn) {
        return AlgoLib.algoUtils.decodeAlgoTxn(txn);
    }
    getAddressFromPublicKey(pubKey) {
        return AlgoLib.algoUtils.publicKeyToAlgoAddress(pubKey);
    }
    supportsDeriveKeyWithSeed() {
        return false;
    }
    /**
     * Gets config for how token enablements work for this coin
     * @returns
     *    requiresTokenEnablement: True if tokens need to be enabled for this coin
     *    supportsMultipleTokenEnablements: True if multiple tokens can be enabled in one transaction
     */
    getTokenEnablementConfig() {
        return {
            requiresTokenEnablement: true,
            supportsMultipleTokenEnablements: false,
        };
    }
    /**
     * Gets the balance of the root address in base units of algo
     * Eg. If balance is 1 Algo, this returns 1*10^6
     * @param rootAddress
     * @param client
     */
    async getAccountBalance(rootAddress, client) {
        const accountInformation = await client.accountInformation(rootAddress).do();
        // Extract the balance from the account information
        return accountInformation.amount;
    }
    /**
     * Returns the Algo client for the given token, baseServer and port
     * Used to interact with the Algo network
     */
    getClient(token, baseServer, port) {
        return new algosdk.Algodv2(token, baseServer, port);
    }
    async recover(params) {
        var _a;
        const isUnsignedSweep = this.isValidPub(params.userKey) && this.isValidPub(params.backupKey);
        if (!params.nodeParams) {
            throw new Error('Please provide the details of an ALGO node to use for recovery');
        }
        // Validate the root address
        if (!this.isValidAddress(params.rootAddress)) {
            throw new Error('invalid rootAddress, got: ' + params.rootAddress);
        }
        // Validate the destination address
        if (!this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination, got: ' + params.recoveryDestination);
        }
        if (params.firstRound && new bignumber_js_1.default(params.firstRound).isNegative()) {
            throw new Error('first round needs to be a positive value');
        }
        const genesisId = this.bitgo.getEnv() === 'prod' ? transactionBuilder_1.MAINNET_GENESIS_ID : transactionBuilder_1.TESTNET_GENESIS_ID;
        const genesisHash = this.bitgo.getEnv() === 'prod' ? transactionBuilder_1.MAINNET_GENESIS_HASH : transactionBuilder_1.TESTNET_GENESIS_HASH;
        utils_1.default.validateBase64(genesisHash);
        if (!isUnsignedSweep && !params.walletPassphrase) {
            throw new Error('walletPassphrase is required for non-bitgo recovery');
        }
        const factory = new AlgoLib.TransactionBuilderFactory(statics_1.coins.get('algo'));
        const txBuilder = factory.getTransferBuilder();
        let userPrv;
        let backupPrv;
        if (!isUnsignedSweep) {
            if (!params.bitgoKey) {
                throw new Error('bitgo public key from the keyCard is required for non-bitgo recovery');
            }
            try {
                userPrv = this.bitgo.decrypt({ input: params.userKey, password: params.walletPassphrase });
                backupPrv = this.bitgo.decrypt({ input: params.backupKey, password: params.walletPassphrase });
                const userKeyAddress = utils_1.default.privateKeyToAlgoAddress(userPrv);
                const backupKeyAddress = utils_1.default.privateKeyToAlgoAddress(backupPrv);
                txBuilder.numberOfRequiredSigners(2).setSigners([userKeyAddress, backupKeyAddress, params.bitgoKey]);
            }
            catch (e) {
                throw new Error('unable to decrypt userKey or backupKey with the walletPassphrase provided, got error: ' + e.message);
            }
        }
        const client = this.getClient(params.nodeParams.token, params.nodeParams.baseServer, params.nodeParams.port);
        const nativeBalance = await this.getAccountBalance(params.rootAddress, client);
        // Algorand accounts require a min. balance of 1 ALGO
        const MIN_MICROALGOS_BALANCE = 100000;
        const spendableAmount = new bignumber_js_1.default(nativeBalance).minus(params.fee).minus(MIN_MICROALGOS_BALANCE).toNumber();
        if (new bignumber_js_1.default(spendableAmount).isZero() || new bignumber_js_1.default(spendableAmount).isLessThanOrEqualTo(params.fee)) {
            throw new Error('Insufficient balance to recover, got balance: ' +
                nativeBalance +
                ' fee: ' +
                params.fee +
                ' min account balance: ' +
                MIN_MICROALGOS_BALANCE);
        }
        let latestRound;
        if (!params.firstRound) {
            latestRound = await client
                .status()
                .do()
                .then((status) => status['last-round']);
        }
        const firstRound = !params.firstRound ? latestRound : params.firstRound;
        if (!firstRound) {
            throw new Error('Unable to fetch the latest round from the node. Please provide the firstRound or try again.');
        }
        const LAST_ROUND_BUFFER = 1000;
        const lastRound = firstRound + LAST_ROUND_BUFFER;
        txBuilder
            .fee({ fee: params.fee.toString() })
            .isFlatFee(true)
            .sender({
            address: params.rootAddress,
        })
            .to({
            address: params.recoveryDestination,
        })
            .amount(spendableAmount)
            .genesisId(genesisId)
            .genesisHash(genesisHash)
            .firstRound(new bignumber_js_1.default(firstRound).toNumber())
            .lastRound(new bignumber_js_1.default(lastRound).toNumber());
        if (params.note) {
            const note = new Uint8Array(buffer_1.Buffer.from(params.note, 'utf-8'));
            txBuilder.note(note);
        }
        // Cold wallet, offline vault
        if (isUnsignedSweep) {
            const tx = await txBuilder.build();
            const txJson = tx.toJson();
            return {
                txHex: buffer_1.Buffer.from(tx.toBroadcastFormat()).toString('hex'),
                type: txJson.type,
                userKey: params.userKey,
                backupKey: params.backupKey,
                bitgoKey: params.bitgoKey,
                address: params.rootAddress,
                coin: this.getChain(),
                feeInfo: txJson.fee,
                amount: (_a = txJson.amount) !== null && _a !== void 0 ? _a : nativeBalance.toString(),
                firstRound: txJson.firstRound,
                lastRound: txJson.lastRound,
                genesisId: genesisId,
                genesisHash: genesisHash,
                note: txJson.note ? buffer_1.Buffer.from(txJson.note.buffer).toString('utf-8') : undefined,
                keys: [params.userKey, params.backupKey, params.bitgoKey],
                addressVersion: 1,
            };
        }
        // Non-bitgo Recovery (Hot wallets)
        txBuilder.sign({ key: userPrv });
        txBuilder.sign({ key: backupPrv });
        const tx = await txBuilder.build();
        const txJson = tx.toJson();
        return {
            tx: buffer_1.Buffer.from(tx.toBroadcastFormat()).toString('base64'),
            id: txJson.id,
            coin: this.getChain(),
            fee: txJson.fee,
            firstRound: txJson.firstRound,
            lastRound: txJson.lastRound,
            genesisId: genesisId,
            genesisHash: genesisHash,
            note: txJson.note ? buffer_1.Buffer.from(txJson.note.buffer).toString('utf-8') : undefined,
        };
    }
    /**
     * Accepts a fully signed serialized base64 transaction and broadcasts it on the network.
     * Uses the external node provided by the client
     * @param serializedSignedTransaction
     * @param nodeParams
     */
    async broadcastTransaction({ serializedSignedTransaction, nodeParams, }) {
        if (!nodeParams) {
            throw new Error('Please provide the details of the algorand node');
        }
        try {
            const txHex = buffer_1.Buffer.from(serializedSignedTransaction, 'base64').toString('hex');
            const algoTx = utils_1.default.toUint8Array(txHex);
            const client = this.getClient(nodeParams.token, nodeParams.baseServer, nodeParams.port);
            return await client.sendRawTransaction(algoTx).do();
        }
        catch (e) {
            throw new Error('Failed to broadcast transaction, error: ' + e.message);
        }
    }
    /**
     * Stellar and Algorand both use keys on the ed25519 curve, but use different encodings.
     * As the HSM doesn't have explicit support to create Algorand addresses, we use the Stellar
     * keys and re-encode them to the Algorand encoding.
     *
     * This method should only be used when creating Algorand custodial wallets reusing Stellar keys.
     *
     * @param {string} addressOrPubKey a Stellar pubkey or Algorand address
     * @return {*}
     */
    stellarAddressToAlgoAddress(addressOrPubKey) {
        // we have an Algorand address
        if (this.isValidAddress(addressOrPubKey)) {
            return addressOrPubKey;
        }
        // we have a stellar key
        if (stellar_sdk_1.default.StrKey.isValidEd25519PublicKey(addressOrPubKey)) {
            const stellarPub = stellar_sdk_1.default.StrKey.decodeEd25519PublicKey(addressOrPubKey);
            const algoAddress = AlgoLib.algoUtils.encodeAddress(stellarPub);
            if (this.isValidAddress(algoAddress)) {
                return algoAddress;
            }
            throw new sdk_core_1.UnexpectedAddressError('Cannot convert Stellar address to an Algorand address via stellar pubkey.');
            // we have a root pubkey
        }
        else if (AlgoLib.algoUtils.isValidPublicKey(addressOrPubKey)) {
            const kp = new AlgoLib.KeyPair({ pub: addressOrPubKey });
            const algoAddress = kp.getAddress();
            if (this.isValidAddress(algoAddress)) {
                return algoAddress;
            }
            throw new sdk_core_1.UnexpectedAddressError('Invalid root pubkey.');
        }
        throw new sdk_core_1.UnexpectedAddressError('Neither an Algorand address, a stellar pubkey or a root public key.');
    }
    getBuilder() {
        return new AlgoLib.TransactionBuilderFactory(statics_1.coins.get(this.getBaseChain()));
    }
}
exports.Algo = Algo;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWxnby5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hbGdvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0dBRUc7QUFDSCwwQ0FBNEI7QUFDNUIsbURBQWdEO0FBQ2hELDRDQUFtRDtBQUNuRCwrQ0FBaUM7QUFDakMsOENBc0J5QjtBQUN6Qiw4REFBa0M7QUFDbEMsZ0VBQXFDO0FBQ3JDLHdEQUFnQztBQUVoQyxpREFBbUM7QUFDbkMsaUVBS2tDO0FBQ2xDLG1DQUFnQztBQUVoQyxNQUFNLHlCQUF5QixHQUFHLENBQUMsQ0FBQztBQUNwQyxNQUFNLGNBQWMsR0FBRyxDQUFDLENBQUMsQ0FBQyxjQUFjO0FBaUp4QyxNQUFhLElBQUssU0FBUSxtQkFBUTtJQUloQyxZQUFZLEtBQWdCO1FBQzFCLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUpOLGlCQUFZLEdBQXdCLGFBQWEsQ0FBQztRQUNsRCxrQkFBYSxHQUF3QixjQUFjLENBQUM7SUFJN0QsQ0FBQztJQUVELE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBZ0I7UUFDcEMsT0FBTyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBRUQsUUFBUTtRQUNOLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxZQUFZO1FBQ1YsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVELFNBQVM7UUFDUCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQsV0FBVztRQUNULE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUM7SUFFRCxhQUFhO1FBQ1gsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsd0JBQXdCO1FBQ3RCLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7T0FHRztJQUNILDJCQUEyQjtRQUN6QixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxpQkFBaUI7SUFDakIsaUJBQWlCO1FBQ2YsTUFBTSxJQUFJLHVCQUFZLENBQUMsd0RBQXdELENBQUMsQ0FBQztJQUNuRixDQUFDO0lBRUQsaUJBQWlCO0lBQ2pCLGVBQWUsQ0FBQyxJQUFhO1FBQzNCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDN0UsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQy9CLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ2IsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO1NBQ25EO1FBRUQsT0FBTztZQUNMLEdBQUcsRUFBRSxPQUFPLENBQUMsVUFBVSxFQUFFO1lBQ3pCLEdBQUcsRUFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxlQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO1NBQ3hFLENBQUM7SUFDSixDQUFDO0lBRUQsaUJBQWlCO0lBQ2pCLG1CQUFtQixDQUFDLElBQWE7UUFDL0IsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUM3RSxNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDYixNQUFNLElBQUksS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7U0FDbkQ7UUFDRCxPQUFPLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ3JELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILFVBQVUsQ0FBQyxHQUFXO1FBQ3BCLE9BQU8sT0FBTyxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLElBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMxRixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILFVBQVUsQ0FBQyxHQUFXO1FBQ3BCLE9BQU8sT0FBTyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLElBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN4RixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxjQUFjLENBQUMsT0FBZTtRQUM1QixPQUFPLE9BQU8sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQUMsR0FBWSxFQUFFLE9BQXdCO1FBQ3RELE1BQU0sV0FBVyxHQUFHLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUMxRCxJQUFJLGVBQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDNUIsT0FBTyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDdEM7UUFDRCxPQUFPLGVBQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRDs7T0FFRztJQUNILGdCQUFnQjtRQUNkLE9BQU8sQ0FBQyxxQkFBVSxDQUFDLElBQUksRUFBRSxxQkFBVSxDQUFDLE1BQU0sRUFBRSxxQkFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2hFLENBQUM7SUFFRCxnQkFBZ0IsQ0FBQyxPQUF3QjtRQUN2QyxNQUFNLFVBQVUsR0FBRyxlQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLENBQUMsSUFBSyxDQUFDLENBQUM7UUFDM0csT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsT0FBTyxFQUFFLENBQUMsSUFBSSxtQkFBbUIsQ0FBQztJQUN6RyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLGtCQUFrQixDQUFDLE1BQWlDO1FBQ3hELE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDN0UsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUU7WUFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO1NBQ2xEO1FBRUQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBRWxDLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdEMsTUFBTSxFQUFFLEdBQUcsTUFBTSxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDbkMsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRTNCLElBQUksRUFBRSxDQUFDLElBQUksS0FBSywwQkFBZSxDQUFDLElBQUksRUFBRTtZQUNwQyxNQUFNLE9BQU8sR0FBMkI7Z0JBQ3RDO29CQUNFLE9BQU8sRUFBRSxNQUFNLENBQUMsRUFBRTtvQkFDbEIsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNO29CQUNyQixJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUk7aUJBQ2xCO2FBQ0YsQ0FBQztZQUNGLE1BQU0sVUFBVSxHQUEyQixFQUFFLENBQUM7WUFFOUMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDOUMsSUFBSSxTQUFTLEVBQUU7Z0JBQ2IsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUM7Z0JBQzlHLFVBQVUsQ0FBQyxJQUFJLENBQUM7b0JBQ2QsSUFBSSxFQUFFLElBQUk7b0JBQ1YsSUFBSSxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO2lCQUM1QyxDQUFDLENBQUM7YUFDSjtZQUVELE1BQU0sWUFBWSxHQUFHO2dCQUNuQixJQUFJO2dCQUNKLGNBQWM7Z0JBQ2QsY0FBYztnQkFDZCxTQUFTO2dCQUNULGVBQWU7Z0JBQ2YsS0FBSztnQkFDTCxNQUFNO2dCQUNOLE1BQU07Z0JBQ04sWUFBWTthQUNiLENBQUM7WUFFRixNQUFNLGlCQUFpQixHQUErQjtnQkFDcEQsWUFBWTtnQkFDWixFQUFFLEVBQUUsTUFBTSxDQUFDLEVBQUU7Z0JBQ2IsWUFBWSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFO2dCQUN0QyxZQUFZLEVBQUUsR0FBRztnQkFDakIsT0FBTztnQkFDUCxhQUFhLEVBQUUsRUFBRTtnQkFDakIsR0FBRyxFQUFFLE1BQU0sQ0FBQyxHQUFHO2dCQUNmLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSTtnQkFDakIsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUN4QixVQUFVO2FBQ1gsQ0FBQztZQUVGLElBQUksTUFBTSxDQUFDLE9BQU8sRUFBRTtnQkFDbEIsaUJBQWlCLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUM7YUFDNUM7WUFFRCxPQUFPLGlCQUFpQixDQUFDO1NBQzFCO1FBRUQsSUFBSSxFQUFFLENBQUMsSUFBSSxLQUFLLDBCQUFlLENBQUMsb0JBQW9CLEVBQUU7WUFDcEQsTUFBTSxZQUFZLEdBQUc7Z0JBQ25CLElBQUk7Z0JBQ0osS0FBSztnQkFDTCxNQUFNO2dCQUNOLE1BQU07Z0JBQ04sU0FBUztnQkFDVCxjQUFjO2dCQUNkLFdBQVc7Z0JBQ1gsVUFBVTtnQkFDVixpQkFBaUI7YUFDbEIsQ0FBQztZQUVGLE9BQU87Z0JBQ0wsWUFBWTtnQkFDWixFQUFFLEVBQUUsTUFBTSxDQUFDLEVBQUU7Z0JBQ2IsWUFBWSxFQUFFLEdBQUc7Z0JBQ2pCLFlBQVksRUFBRSxHQUFHO2dCQUNqQixPQUFPLEVBQUUsRUFBRTtnQkFDWCxhQUFhLEVBQUUsRUFBRTtnQkFDakIsR0FBRyxFQUFFLE1BQU0sQ0FBQyxHQUFHO2dCQUNmLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSTtnQkFDakIsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJO2dCQUNiLE9BQU8sRUFBRSxNQUFNLENBQUMsT0FBTztnQkFDdkIsWUFBWSxFQUFFLE1BQU0sQ0FBQyxZQUFZO2dCQUNqQyxTQUFTLEVBQUUsTUFBTSxDQUFDLFNBQVM7Z0JBQzNCLFFBQVEsRUFBRSxNQUFNLENBQUMsUUFBUTtnQkFDekIsZUFBZSxFQUFFLE1BQU0sQ0FBQyxlQUFlO2FBQ3hDLENBQUM7U0FDSDtJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsU0FBUyxDQUFDLElBQVk7UUFDcEIsT0FBTyxJQUFJLEtBQUssT0FBTyxDQUFDO0lBQzFCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGFBQWEsQ0FBQyxJQUFZO1FBQ3hCLE9BQU8sNkJBQWEsQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLEVBQUUsb0JBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN2RSxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxzQkFBc0IsQ0FBQyxJQUFZO1FBQ2pDLG1FQUFtRTtRQUNuRSxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSw2QkFBYSxDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzVFLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFFRCxJQUFJLDZCQUFhLENBQUMseUJBQXlCLENBQUMsSUFBSSxFQUFFLG9CQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDakUsT0FBTyxPQUFPLENBQUMsU0FBUyxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3ZEO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsMkJBQTJCLENBQUMsTUFBOEI7UUFDeEQsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQztRQUN2QixNQUFNLGNBQWMsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQztRQUN4RCxJQUFJLFlBQVksR0FBRyxLQUFLLENBQUM7UUFFekIsaUVBQWlFO1FBQ2pFLGlCQUFpQjtRQUNqQixJQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQztRQUNwQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsVUFBVSxFQUFFO1lBQ2hDLFlBQVksR0FBRyxJQUFJLENBQUM7WUFDcEIsS0FBSyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQztTQUM1QztRQUVELElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN4QixNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixDQUFDLENBQUM7U0FDakQ7UUFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLDBDQUEwQyxPQUFPLEtBQUssRUFBRSxDQUFDLENBQUM7U0FDM0U7UUFFRCxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO1NBQzlEO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDcEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQ0FBa0MsT0FBTyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1NBQ2pFO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxNQUFNLENBQUMsRUFBRTtZQUNyQyxNQUFNLElBQUksS0FBSyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7U0FDdEU7UUFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUMvQixNQUFNLElBQUksS0FBSyxDQUFDLHNEQUFzRCxDQUFDLENBQUM7U0FDekU7UUFFRCxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUNqRCwyREFBMkQ7WUFDM0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUMxQyxPQUFPLE9BQU8sQ0FBQyxTQUFTLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUN0RjtZQUNELE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQyxDQUFDLENBQUM7UUFDSCx5RkFBeUY7UUFDekYsa0RBQWtEO1FBQ2xELDBGQUEwRjtRQUMxRixNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3pELE9BQU8sRUFBRSxLQUFLLEVBQUUsY0FBYyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsWUFBWSxFQUFFLGFBQWEsRUFBRSxDQUFDO0lBQzlFLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsS0FBSyxDQUFDLGVBQWUsQ0FBQyxNQUE4QjtRQUNsRCxNQUFNLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsWUFBWSxFQUFFLGFBQWEsRUFBRSxHQUFHLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN0RyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDbEMsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN0QyxTQUFTLENBQUMsdUJBQXVCLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDakQsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQzdCLFNBQVMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUIsTUFBTSxXQUFXLEdBQUcsTUFBTSxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDNUMsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUM7U0FDeEM7UUFDRCxNQUFNLFdBQVcsR0FBRyxlQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3BGLElBQUksYUFBYSxLQUFLLENBQUMsRUFBRTtZQUN2QixPQUFPLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxDQUFDO1NBQy9CO2FBQU0sSUFBSSxZQUFZLEVBQUU7WUFDdkIsT0FBTyxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsQ0FBQztTQUMvQjthQUFNO1lBQ0wsT0FBTyxFQUFFLFVBQVUsRUFBRSxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsRUFBRSxDQUFDO1NBQy9DO0lBQ0gsQ0FBQztJQUVELEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUErQjtRQUNwRCxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEtBQUssQ0FBQyxlQUFlLENBQUMsTUFBZ0M7UUFDcEQsTUFBTSxFQUNKLE9BQU8sRUFDUCxTQUFTLEVBQ1QsWUFBWSxFQUFFLEVBQUUsV0FBVyxFQUFFLEdBQzlCLEdBQUcsTUFBTSxDQUFDO1FBRVgsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDakMsTUFBTSxJQUFJLDhCQUFtQixDQUFDLG9CQUFvQixPQUFPLEVBQUUsQ0FBQyxDQUFDO1NBQzlEO1FBRUQsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNkLE1BQU0sSUFBSSxLQUFLLENBQUMsa0NBQWtDLENBQUMsQ0FBQztTQUNyRDtRQUVELE1BQU0saUJBQWlCLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1FBQzFHLE1BQU0sT0FBTyxHQUFHLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLDJCQUEyQixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRTFGLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUU7WUFDdkQsTUFBTSxJQUFJLHFCQUFVLENBQUMsb0JBQW9CLENBQUMsQ0FBQztTQUM1QztRQUVELE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLHlCQUF5QixFQUFFLGNBQWMsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUUxRyxPQUFPLFdBQVcsS0FBSyxPQUFPLENBQUM7SUFDakMsQ0FBQztJQUVELEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxNQUFnQztRQUN0RCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxRQUFRLENBQUMsR0FBVztRQUNsQixPQUFPLE9BQU8sQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFFRCx1QkFBdUIsQ0FBQyxNQUFrQjtRQUN4QyxPQUFPLE9BQU8sQ0FBQyxTQUFTLENBQUMsc0JBQXNCLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVELHlCQUF5QjtRQUN2QixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILHdCQUF3QjtRQUN0QixPQUFPO1lBQ0wsdUJBQXVCLEVBQUUsSUFBSTtZQUM3QixnQ0FBZ0MsRUFBRSxLQUFLO1NBQ3hDLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxLQUFLLENBQUMsaUJBQWlCLENBQUMsV0FBbUIsRUFBRSxNQUF1QjtRQUNsRSxNQUFNLGtCQUFrQixHQUFHLE1BQU0sTUFBTSxDQUFDLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQzdFLG1EQUFtRDtRQUNuRCxPQUFPLGtCQUFrQixDQUFDLE1BQU0sQ0FBQztJQUNuQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsU0FBUyxDQUFDLEtBQWEsRUFBRSxVQUFrQixFQUFFLElBQVk7UUFDdkQsT0FBTyxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRU0sS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUF1Qjs7UUFDMUMsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFN0YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUU7WUFDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxnRUFBZ0UsQ0FBQyxDQUFDO1NBQ25GO1FBRUQsNEJBQTRCO1FBQzVCLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRTtZQUM1QyxNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUNwRTtRQUVELG1DQUFtQztRQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsRUFBRTtZQUNwRCxNQUFNLElBQUksS0FBSyxDQUFDLG9DQUFvQyxHQUFHLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQ3BGO1FBRUQsSUFBSSxNQUFNLENBQUMsVUFBVSxJQUFJLElBQUksc0JBQVMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsVUFBVSxFQUFFLEVBQUU7WUFDdEUsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO1NBQzdEO1FBRUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLHVDQUFrQixDQUFDLENBQUMsQ0FBQyx1Q0FBa0IsQ0FBQztRQUMzRixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUMseUNBQW9CLENBQUMsQ0FBQyxDQUFDLHlDQUFvQixDQUFDO1FBRWpHLGVBQUssQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFbEMsSUFBSSxDQUFDLGVBQWUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTtZQUNoRCxNQUFNLElBQUksS0FBSyxDQUFDLHFEQUFxRCxDQUFDLENBQUM7U0FDeEU7UUFFRCxNQUFNLE9BQU8sR0FBRyxJQUFJLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxlQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDekUsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFFL0MsSUFBSSxPQUEyQixDQUFDO1FBQ2hDLElBQUksU0FBNkIsQ0FBQztRQUNsQyxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3BCLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFO2dCQUNwQixNQUFNLElBQUksS0FBSyxDQUFDLHNFQUFzRSxDQUFDLENBQUM7YUFDekY7WUFDRCxJQUFJO2dCQUNGLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDO2dCQUMzRixTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLFNBQVMsRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQztnQkFDL0YsTUFBTSxjQUFjLEdBQUcsZUFBSyxDQUFDLHVCQUF1QixDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUM5RCxNQUFNLGdCQUFnQixHQUFHLGVBQUssQ0FBQyx1QkFBdUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDbEUsU0FBUyxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLGNBQWMsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQzthQUN0RztZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNWLE1BQU0sSUFBSSxLQUFLLENBQ2Isd0ZBQXdGLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FDckcsQ0FBQzthQUNIO1NBQ0Y7UUFFRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxVQUFVLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDN0csTUFBTSxhQUFhLEdBQUcsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUUvRSxxREFBcUQ7UUFDckQsTUFBTSxzQkFBc0IsR0FBRyxNQUFNLENBQUM7UUFDdEMsTUFBTSxlQUFlLEdBQUcsSUFBSSxzQkFBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFaEgsSUFBSSxJQUFJLHNCQUFTLENBQUMsZUFBZSxDQUFDLENBQUMsTUFBTSxFQUFFLElBQUksSUFBSSxzQkFBUyxDQUFDLGVBQWUsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUM3RyxNQUFNLElBQUksS0FBSyxDQUNiLGdEQUFnRDtnQkFDOUMsYUFBYTtnQkFDYixRQUFRO2dCQUNSLE1BQU0sQ0FBQyxHQUFHO2dCQUNWLHdCQUF3QjtnQkFDeEIsc0JBQXNCLENBQ3pCLENBQUM7U0FDSDtRQUVELElBQUksV0FBK0IsQ0FBQztRQUNwQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRTtZQUN0QixXQUFXLEdBQUcsTUFBTSxNQUFNO2lCQUN2QixNQUFNLEVBQUU7aUJBQ1IsRUFBRSxFQUFFO2lCQUNKLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7U0FDM0M7UUFFRCxNQUFNLFVBQVUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQztRQUN4RSxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ2YsTUFBTSxJQUFJLEtBQUssQ0FBQyw2RkFBNkYsQ0FBQyxDQUFDO1NBQ2hIO1FBQ0QsTUFBTSxpQkFBaUIsR0FBRyxJQUFJLENBQUM7UUFDL0IsTUFBTSxTQUFTLEdBQUcsVUFBVSxHQUFHLGlCQUFpQixDQUFDO1FBRWpELFNBQVM7YUFDTixHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDO2FBQ25DLFNBQVMsQ0FBQyxJQUFJLENBQUM7YUFDZixNQUFNLENBQUM7WUFDTixPQUFPLEVBQUUsTUFBTSxDQUFDLFdBQVc7U0FDNUIsQ0FBQzthQUNELEVBQUUsQ0FBQztZQUNGLE9BQU8sRUFBRSxNQUFNLENBQUMsbUJBQW1CO1NBQ3BDLENBQUM7YUFDRCxNQUFNLENBQUMsZUFBZSxDQUFDO2FBQ3ZCLFNBQVMsQ0FBQyxTQUFTLENBQUM7YUFDcEIsV0FBVyxDQUFDLFdBQVcsQ0FBQzthQUN4QixVQUFVLENBQUMsSUFBSSxzQkFBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO2FBQ2hELFNBQVMsQ0FBQyxJQUFJLHNCQUFTLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUVsRCxJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUU7WUFDZixNQUFNLElBQUksR0FBRyxJQUFJLFVBQVUsQ0FBQyxlQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztZQUMvRCxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3RCO1FBRUQsNkJBQTZCO1FBQzdCLElBQUksZUFBZSxFQUFFO1lBQ25CLE1BQU0sRUFBRSxHQUFHLE1BQU0sU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ25DLE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQyxNQUFNLEVBQVksQ0FBQztZQUVyQyxPQUFPO2dCQUNMLEtBQUssRUFBRSxlQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQztnQkFDMUQsSUFBSSxFQUFFLE1BQU0sQ0FBQyxJQUFJO2dCQUNqQixPQUFPLEVBQUUsTUFBTSxDQUFDLE9BQU87Z0JBQ3ZCLFNBQVMsRUFBRSxNQUFNLENBQUMsU0FBUztnQkFDM0IsUUFBUSxFQUFFLE1BQU0sQ0FBQyxRQUFRO2dCQUN6QixPQUFPLEVBQUUsTUFBTSxDQUFDLFdBQVc7Z0JBQzNCLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNyQixPQUFPLEVBQUUsTUFBTSxDQUFDLEdBQUc7Z0JBQ25CLE1BQU0sRUFBRSxNQUFBLE1BQU0sQ0FBQyxNQUFNLG1DQUFJLGFBQWEsQ0FBQyxRQUFRLEVBQUU7Z0JBQ2pELFVBQVUsRUFBRSxNQUFNLENBQUMsVUFBVTtnQkFDN0IsU0FBUyxFQUFFLE1BQU0sQ0FBQyxTQUFTO2dCQUMzQixTQUFTLEVBQUUsU0FBUztnQkFDcEIsV0FBVyxFQUFFLFdBQVc7Z0JBQ3hCLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxlQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTO2dCQUNqRixJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLFFBQVEsQ0FBQztnQkFDekQsY0FBYyxFQUFFLENBQUM7YUFDbEIsQ0FBQztTQUNIO1FBRUQsbUNBQW1DO1FBQ25DLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUNqQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUM7UUFFbkMsTUFBTSxFQUFFLEdBQUcsTUFBTSxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDbkMsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLE1BQU0sRUFBWSxDQUFDO1FBRXJDLE9BQU87WUFDTCxFQUFFLEVBQUUsZUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUM7WUFDMUQsRUFBRSxFQUFFLE1BQU0sQ0FBQyxFQUFFO1lBQ2IsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDckIsR0FBRyxFQUFFLE1BQU0sQ0FBQyxHQUFHO1lBQ2YsVUFBVSxFQUFFLE1BQU0sQ0FBQyxVQUFVO1lBQzdCLFNBQVMsRUFBRSxNQUFNLENBQUMsU0FBUztZQUMzQixTQUFTLEVBQUUsU0FBUztZQUNwQixXQUFXLEVBQUUsV0FBVztZQUN4QixJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsZUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUztTQUNsRixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLG9CQUFvQixDQUFDLEVBQ3pCLDJCQUEyQixFQUMzQixVQUFVLEdBQ2tCO1FBQzVCLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDZixNQUFNLElBQUksS0FBSyxDQUFDLGlEQUFpRCxDQUFDLENBQUM7U0FDcEU7UUFDRCxJQUFJO1lBQ0YsTUFBTSxLQUFLLEdBQUcsZUFBTSxDQUFDLElBQUksQ0FBQywyQkFBMkIsRUFBRSxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDakYsTUFBTSxNQUFNLEdBQUcsZUFBSyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN6QyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsVUFBVSxDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFeEYsT0FBTyxNQUFNLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztTQUNyRDtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDekU7SUFDSCxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0ssMkJBQTJCLENBQUMsZUFBdUI7UUFDekQsOEJBQThCO1FBQzlCLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxlQUFlLENBQUMsRUFBRTtZQUN4QyxPQUFPLGVBQWUsQ0FBQztTQUN4QjtRQUVELHdCQUF3QjtRQUN4QixJQUFJLHFCQUFPLENBQUMsTUFBTSxDQUFDLHVCQUF1QixDQUFDLGVBQWUsQ0FBQyxFQUFFO1lBQzNELE1BQU0sVUFBVSxHQUFHLHFCQUFPLENBQUMsTUFBTSxDQUFDLHNCQUFzQixDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQzFFLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2hFLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsRUFBRTtnQkFDcEMsT0FBTyxXQUFXLENBQUM7YUFDcEI7WUFDRCxNQUFNLElBQUksaUNBQXNCLENBQUMsMkVBQTJFLENBQUMsQ0FBQztZQUM5Ryx3QkFBd0I7U0FDekI7YUFBTSxJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsZUFBZSxDQUFDLEVBQUU7WUFDOUQsTUFBTSxFQUFFLEdBQUcsSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsR0FBRyxFQUFFLGVBQWUsRUFBRSxDQUFDLENBQUM7WUFDekQsTUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ3BDLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsRUFBRTtnQkFDcEMsT0FBTyxXQUFXLENBQUM7YUFDcEI7WUFDRCxNQUFNLElBQUksaUNBQXNCLENBQUMsc0JBQXNCLENBQUMsQ0FBQztTQUMxRDtRQUVELE1BQU0sSUFBSSxpQ0FBc0IsQ0FBQyxxRUFBcUUsQ0FBQyxDQUFDO0lBQzFHLENBQUM7SUFFTyxVQUFVO1FBQ2hCLE9BQU8sSUFBSSxPQUFPLENBQUMseUJBQXlCLENBQUMsZUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQy9FLENBQUM7Q0FDRjtBQTVvQkQsb0JBNG9CQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFNlZWRWYWxpZGF0b3IgfSBmcm9tICcuL3NlZWRWYWxpZGF0b3InO1xuaW1wb3J0IHsgY29pbnMsIENvaW5GYW1pbHkgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgKiBhcyBBbGdvTGliIGZyb20gJy4vbGliJztcbmltcG9ydCB7XG4gIEFkZHJlc3NDb2luU3BlY2lmaWMsXG4gIEJhc2VCcm9hZGNhc3RUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIEJhc2VCcm9hZGNhc3RUcmFuc2FjdGlvblJlc3VsdCxcbiAgQmFzZUNvaW4sXG4gIEJpdEdvQmFzZSxcbiAgSW52YWxpZEFkZHJlc3NFcnJvcixcbiAgSW52YWxpZEtleSxcbiAgS2V5SW5kaWNlcyxcbiAgS2V5UGFpcixcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBTaWduZWRUcmFuc2FjdGlvbixcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVG9rZW5NYW5hZ2VtZW50VHlwZSxcbiAgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbixcbiAgVHJhbnNhY3Rpb25SZWNpcGllbnQsXG4gIFRyYW5zYWN0aW9uVHlwZSxcbiAgVW5leHBlY3RlZEFkZHJlc3NFcnJvcixcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgTm90U3VwcG9ydGVkLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHN0ZWxsYXIgZnJvbSAnc3RlbGxhci1zZGsnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vbGliL3V0aWxzJztcbmltcG9ydCB7IFR4RGF0YSB9IGZyb20gJy4vbGliL2lmYWNlcyc7XG5pbXBvcnQgKiBhcyBhbGdvc2RrIGZyb20gJ2FsZ29zZGsnO1xuaW1wb3J0IHtcbiAgTUFJTk5FVF9HRU5FU0lTX0hBU0gsXG4gIE1BSU5ORVRfR0VORVNJU19JRCxcbiAgVEVTVE5FVF9HRU5FU0lTX0hBU0gsXG4gIFRFU1RORVRfR0VORVNJU19JRCxcbn0gZnJvbSAnLi9saWIvdHJhbnNhY3Rpb25CdWlsZGVyJztcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XG5cbmNvbnN0IFNVUFBPUlRFRF9BRERSRVNTX1ZFUlNJT04gPSAxO1xuY29uc3QgTVNJR19USFJFU0hPTEQgPSAyOyAvLyBtIGluIG0tb2YtblxuXG5leHBvcnQgaW50ZXJmYWNlIEFsZ29BZGRyZXNzQ29pblNwZWNpZmljcyBleHRlbmRzIEFkZHJlc3NDb2luU3BlY2lmaWMge1xuICByb290QWRkcmVzczogc3RyaW5nO1xuICBiaXRnb0tleTogc3RyaW5nO1xuICBiaXRnb1B1YktleT86IHN0cmluZztcbiAgYWRkcmVzc1ZlcnNpb246IG51bWJlcjtcbiAgdGhyZXNob2xkOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZ5QWxnb0FkZHJlc3NPcHRpb25zIGV4dGVuZHMgVmVyaWZ5QWRkcmVzc09wdGlvbnMge1xuICBjaGFpbjogbnVtYmVyO1xuICBpbmRleDogbnVtYmVyO1xuICBjb2luOiBzdHJpbmc7XG4gIHdhbGxldDogc3RyaW5nO1xuICBjb2luU3BlY2lmaWM6IEFsZ29BZGRyZXNzQ29pblNwZWNpZmljcztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBbGdvVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiBleHRlbmRzIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24ge1xuICBtZW1vPzogc3RyaW5nO1xuICB0eXBlPzogc3RyaW5nIHwgbnVtYmVyO1xuICB2b3RlS2V5Pzogc3RyaW5nO1xuICBzZWxlY3Rpb25LZXk/OiBzdHJpbmc7XG4gIHZvdGVGaXJzdD86IG51bWJlcjtcbiAgdm90ZUxhc3Q/OiBudW1iZXI7XG4gIHZvdGVLZXlEaWx1dGlvbj86IG51bWJlcjtcbiAgdG9rZW5JZD86IG51bWJlcjtcbiAgb3BlcmF0aW9ucz86IFRyYW5zYWN0aW9uT3BlcmF0aW9uW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25PcGVyYXRpb24ge1xuICB0eXBlOiBzdHJpbmc7XG4gIGNvaW46IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwcnY6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhIZXg6IHN0cmluZztcbiAgaGFsZlNpZ25lZD86IHtcbiAgICB0eEhleDogc3RyaW5nO1xuICB9O1xuICB0eEluZm86IHtcbiAgICBmcm9tOiBzdHJpbmc7XG4gICAgdG86IHN0cmluZztcbiAgICBhbW91bnQ6IHN0cmluZztcbiAgICBmZWU6IG51bWJlcjtcbiAgICBmaXJzdFJvdW5kOiBudW1iZXI7XG4gICAgbGFzdFJvdW5kOiBudW1iZXI7XG4gICAgZ2VuZXNpc0lEOiBzdHJpbmc7XG4gICAgZ2VuZXNpc0hhc2g6IHN0cmluZztcbiAgICBub3RlPzogc3RyaW5nO1xuICB9O1xuICBrZXlzOiBzdHJpbmdbXTtcbiAgYWRkcmVzc1ZlcnNpb246IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdWxseVNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgdHhIZXg6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYWxmU2lnbmVkVHJhbnNhY3Rpb24ge1xuICBoYWxmU2lnbmVkOiB7XG4gICAgdHhIZXg6IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbkZlZSB7XG4gIGZlZTogc3RyaW5nO1xufVxuZXhwb3J0IGludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhIZXg/OiBzdHJpbmc7XG4gIGhhbGZTaWduZWQ/OiB7XG4gICAgdHhIZXg6IHN0cmluZztcbiAgfTtcbiAgcHVibGljS2V5cz86IHN0cmluZ1tdO1xuICBmZWVJbmZvOiBUcmFuc2FjdGlvbkZlZTtcbn1cblxuaW50ZXJmYWNlIE5vZGVQYXJhbXMge1xuICB0b2tlbjogc3RyaW5nO1xuICBiYXNlU2VydmVyOiBzdHJpbmc7XG4gIHBvcnQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZmllZFRyYW5zYWN0aW9uUGFyYW1ldGVycyB7XG4gIHR4SGV4OiBzdHJpbmc7XG4gIGFkZHJlc3NWZXJzaW9uOiBudW1iZXI7XG4gIHNpZ25lcnM6IHN0cmluZ1tdO1xuICBwcnY6IHN0cmluZztcbiAgaXNIYWxmU2lnbmVkOiBib29sZWFuO1xuICBudW1iZXJTaWduZXJzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjb3ZlcnlPcHRpb25zIHtcbiAgYmFja3VwS2V5OiBzdHJpbmc7XG4gIHVzZXJLZXk6IHN0cmluZztcbiAgcm9vdEFkZHJlc3M6IHN0cmluZztcbiAgcmVjb3ZlcnlEZXN0aW5hdGlvbjogc3RyaW5nO1xuICBiaXRnb0tleTogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICBmZWU6IG51bWJlcjtcbiAgZmlyc3RSb3VuZD86IG51bWJlcjtcbiAgbm90ZT86IHN0cmluZztcbiAgbm9kZVBhcmFtczogTm9kZVBhcmFtcztcbn1cblxuaW50ZXJmYWNlIFJlY292ZXJ5SW5mbyB7XG4gIGlkOiBzdHJpbmc7XG4gIHR4OiBzdHJpbmc7XG4gIGNvaW46IHN0cmluZztcbiAgZmVlOiBudW1iZXI7XG4gIGZpcnN0Um91bmQ6IG51bWJlcjtcbiAgbGFzdFJvdW5kOiBudW1iZXI7XG4gIGdlbmVzaXNJZDogc3RyaW5nO1xuICBnZW5lc2lzSGFzaDogc3RyaW5nO1xuICBub3RlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9mZmxpbmVWYXVsdFR4SW5mbyB7XG4gIHR4SGV4OiBzdHJpbmc7XG4gIHVzZXJLZXk6IHN0cmluZztcbiAgYmFja3VwS2V5OiBzdHJpbmc7XG4gIGJpdGdvS2V5OiBzdHJpbmc7XG4gIHR5cGU/OiBzdHJpbmc7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgY29pbjogc3RyaW5nO1xuICBmZWVJbmZvOiBudW1iZXI7XG4gIGFtb3VudDogc3RyaW5nO1xuICBmaXJzdFJvdW5kOiBudW1iZXI7XG4gIGxhc3RSb3VuZDogbnVtYmVyO1xuICBnZW5lc2lzSWQ6IHN0cmluZztcbiAgZ2VuZXNpc0hhc2g6IHN0cmluZztcbiAgbm90ZT86IHN0cmluZztcbiAgYWRkcmVzc1ZlcnNpb246IG51bWJlcjtcbiAga2V5czogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnJvYWRjYXN0VHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgQmFzZUJyb2FkY2FzdFRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIG5vZGVQYXJhbXM6IE5vZGVQYXJhbXM7XG59XG5cbmV4cG9ydCBjbGFzcyBBbGdvIGV4dGVuZHMgQmFzZUNvaW4ge1xuICByZWFkb25seSBFTkFCTEVfVE9LRU46IFRva2VuTWFuYWdlbWVudFR5cGUgPSAnZW5hYmxldG9rZW4nO1xuICByZWFkb25seSBESVNBQkxFX1RPS0VOOiBUb2tlbk1hbmFnZW1lbnRUeXBlID0gJ2Rpc2FibGV0b2tlbic7XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSkge1xuICAgIHN1cGVyKGJpdGdvKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R29CYXNlKTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgQWxnbyhiaXRnbyk7XG4gIH1cblxuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnYWxnbyc7XG4gIH1cblxuICBnZXRCYXNlQ2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2FsZ28nO1xuICB9XG5cbiAgZ2V0RmFtaWx5KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdhbGdvJztcbiAgfVxuXG4gIGdldEZ1bGxOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdBbGdvcmFuZCc7XG4gIH1cblxuICBnZXRCYXNlRmFjdG9yKCk6IG51bWJlciB8IHN0cmluZyB7XG4gICAgcmV0dXJuIDFlNjtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBzZW5kaW5nIHZhbHVlIG9mIDBcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIDAgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsZ29yYW5kIHN1cHBvcnRzIGFjY291bnQgY29uc29saWRhdGlvbnMuIFRoZXNlIGFyZSB0cmFuc2ZlcnMgZnJvbSB0aGUgcmVjZWl2ZSBhZGRyZXNzZXNcbiAgICogdG8gdGhlIG1haW4gYWRkcmVzcy5cbiAgICovXG4gIGFsbG93c0FjY291bnRDb25zb2xpZGF0aW9ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBpbmhlcml0ZG9jICovXG4gIGRlcml2ZUtleVdpdGhTZWVkKCk6IHsgZGVyaXZhdGlvblBhdGg6IHN0cmluZzsga2V5OiBzdHJpbmcgfSB7XG4gICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCgnbWV0aG9kIGRlcml2ZUtleVdpdGhTZWVkIG5vdCBzdXBwb3J0ZWQgZm9yIGVkZHNhIGN1cnZlJyk7XG4gIH1cblxuICAvKiogaW5oZXJpdGRvYyAqL1xuICBnZW5lcmF0ZUtleVBhaXIoc2VlZD86IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIGNvbnN0IGtleVBhaXIgPSBzZWVkID8gbmV3IEFsZ29MaWIuS2V5UGFpcih7IHNlZWQgfSkgOiBuZXcgQWxnb0xpYi5LZXlQYWlyKCk7XG4gICAgY29uc3Qga2V5cyA9IGtleVBhaXIuZ2V0S2V5cygpO1xuICAgIGlmICgha2V5cy5wcnYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcnYgaW4ga2V5IGdlbmVyYXRpb24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHB1Yjoga2V5UGFpci5nZXRBZGRyZXNzKCksXG4gICAgICBwcnY6IEFsZ29MaWIuYWxnb1V0aWxzLmVuY29kZVNlZWQoQnVmZmVyLmZyb20oa2V5UGFpci5nZXRTaWduaW5nS2V5KCkpKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqIGluaGVyaXRkb2MgKi9cbiAgZ2VuZXJhdGVSb290S2V5UGFpcihzZWVkPzogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgY29uc3Qga2V5UGFpciA9IHNlZWQgPyBuZXcgQWxnb0xpYi5LZXlQYWlyKHsgc2VlZCB9KSA6IG5ldyBBbGdvTGliLktleVBhaXIoKTtcbiAgICBjb25zdCBrZXlzID0ga2V5UGFpci5nZXRLZXlzKCk7XG4gICAgaWYgKCFrZXlzLnBydikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHBydiBpbiBrZXkgZ2VuZXJhdGlvbi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcHJ2OiBrZXlzLnBydiArIGtleXMucHViLCBwdWI6IGtleXMucHViIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHViIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIEFsZ29MaWIuYWxnb1V0aWxzLmlzVmFsaWRBZGRyZXNzKHB1YikgfHwgQWxnb0xpYi5hbGdvVXRpbHMuaXNWYWxpZFB1YmxpY0tleShwdWIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBzZWVkIGZvciB0aGUgY29pblxuICAgKiBJbiBBbGdvcmFuZCwgd2hlbiB0aGUgcHJpdmF0ZSBrZXkgaXMgZW5jb2RlZCBhcyBiYXNlMzIgc3RyaW5nIG9ubHkgdGhlIGZpcnN0IDMyIGJ5dGVzIGFyZSB0YWtlbixcbiAgICogc28gdGhlIGVuY29kZWQgdmFsdWUgaXMgYWN0dWFsbHkgdGhlIHNlZWRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBydiB0aGUgcHJ2IHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBBbGdvTGliLmFsZ29VdGlscy5pc1ZhbGlkU2VlZChwcnYpIHx8IEFsZ29MaWIuYWxnb1V0aWxzLmlzVmFsaWRQcml2YXRlS2V5KHBydik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gQWxnb0xpYi5hbGdvVXRpbHMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBtZXNzYWdlIHdpdGggcHJpdmF0ZSBrZXlcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKi9cbiAgYXN5bmMgc2lnbk1lc3NhZ2Uoa2V5OiBLZXlQYWlyLCBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGNvbnN0IGFsZ29LZXlwYWlyID0gbmV3IEFsZ29MaWIuS2V5UGFpcih7IHBydjoga2V5LnBydiB9KTtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICBtZXNzYWdlID0gbWVzc2FnZS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShhbGdvS2V5cGFpci5zaWduTWVzc2FnZShtZXNzYWdlKSk7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmaWVzIHdoYXQga2V5IHdlIHdpbGwgbmVlZCBmb3Igc2lnbmluZ2AgLSBBbGdvcmFuZCBuZWVkcyB0aGUgYmFja3VwLCBiaXRnbyBwdWJzLlxuICAgKi9cbiAga2V5SWRzRm9yU2lnbmluZygpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIFtLZXlJbmRpY2VzLlVTRVIsIEtleUluZGljZXMuQkFDS1VQLCBLZXlJbmRpY2VzLkJJVEdPXTtcbiAgfVxuXG4gIGdldFRva2VuTmFtZUJ5SWQodG9rZW5JZDogbnVtYmVyIHwgc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCB0b2tlbk5hbWVzID0gY29pbnMuZmlsdGVyKChjb2luKSA9PiBjb2luLmZhbWlseSA9PT0gJ2FsZ28nICYmIGNvaW4uaXNUb2tlbikubWFwKCh7IG5hbWUgfSkgPT4gbmFtZSEpO1xuICAgIHJldHVybiB0b2tlbk5hbWVzLmZpbmQoKHRva2VuTmFtZSkgPT4gdG9rZW5OYW1lLnNwbGl0KCctJylbMV0gPT09IGAke3Rva2VuSWR9YCkgfHwgJ0FsZ29Ub2tlbiB1bmtub3duJztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluL3BhcnNlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIGV4cGxhaW5UcmFuc2FjdGlvbihwYXJhbXM6IEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPEFsZ29UcmFuc2FjdGlvbkV4cGxhbmF0aW9uIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgdHhIZXggPSBwYXJhbXMudHhIZXggfHwgKHBhcmFtcy5oYWxmU2lnbmVkICYmIHBhcmFtcy5oYWxmU2lnbmVkLnR4SGV4KTtcbiAgICBpZiAoIXR4SGV4IHx8ICFwYXJhbXMuZmVlSW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGV4cGxhaW4gdHggcGFyYW1ldGVycycpO1xuICAgIH1cblxuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmdldEJ1aWxkZXIoKTtcblxuICAgIGNvbnN0IHR4QnVpbGRlciA9IGZhY3RvcnkuZnJvbSh0eEhleCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICBjb25zdCB0eEpzb24gPSB0eC50b0pzb24oKTtcblxuICAgIGlmICh0eC50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuU2VuZCkge1xuICAgICAgY29uc3Qgb3V0cHV0czogVHJhbnNhY3Rpb25SZWNpcGllbnRbXSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGFkZHJlc3M6IHR4SnNvbi50byxcbiAgICAgICAgICBhbW91bnQ6IHR4SnNvbi5hbW91bnQsXG4gICAgICAgICAgbWVtbzogdHhKc29uLm5vdGUsXG4gICAgICAgIH0sXG4gICAgICBdO1xuICAgICAgY29uc3Qgb3BlcmF0aW9uczogVHJhbnNhY3Rpb25PcGVyYXRpb25bXSA9IFtdO1xuXG4gICAgICBjb25zdCBpc1Rva2VuVHggPSB0aGlzLmlzVG9rZW5UeCh0eEpzb24udHlwZSk7XG4gICAgICBpZiAoaXNUb2tlblR4KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBBbGdvTGliLmFsZ29VdGlscy5nZXRUb2tlblR4VHlwZSh0eEpzb24uYW1vdW50LCB0eEpzb24uZnJvbSwgdHhKc29uLnRvLCB0eEpzb24uY2xvc2VSZW1haW5kZXJUbyk7XG4gICAgICAgIG9wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBjb2luOiB0aGlzLmdldFRva2VuTmFtZUJ5SWQodHhKc29uLnRva2VuSWQpLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlzcGxheU9yZGVyID0gW1xuICAgICAgICAnaWQnLFxuICAgICAgICAnb3V0cHV0QW1vdW50JyxcbiAgICAgICAgJ2NoYW5nZUFtb3VudCcsXG4gICAgICAgICdvdXRwdXRzJyxcbiAgICAgICAgJ2NoYW5nZU91dHB1dHMnLFxuICAgICAgICAnZmVlJyxcbiAgICAgICAgJ21lbW8nLFxuICAgICAgICAndHlwZScsXG4gICAgICAgICdvcGVyYXRpb25zJyxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGV4cGxhbmF0aW9uUmVzdWx0OiBBbGdvVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiA9IHtcbiAgICAgICAgZGlzcGxheU9yZGVyLFxuICAgICAgICBpZDogdHhKc29uLmlkLFxuICAgICAgICBvdXRwdXRBbW91bnQ6IHR4SnNvbi5hbW91bnQudG9TdHJpbmcoKSxcbiAgICAgICAgY2hhbmdlQW1vdW50OiAnMCcsXG4gICAgICAgIG91dHB1dHMsXG4gICAgICAgIGNoYW5nZU91dHB1dHM6IFtdLFxuICAgICAgICBmZWU6IHR4SnNvbi5mZWUsXG4gICAgICAgIG1lbW86IHR4SnNvbi5ub3RlLFxuICAgICAgICB0eXBlOiB0eC50eXBlLnRvU3RyaW5nKCksXG4gICAgICAgIG9wZXJhdGlvbnMsXG4gICAgICB9O1xuXG4gICAgICBpZiAodHhKc29uLnRva2VuSWQpIHtcbiAgICAgICAgZXhwbGFuYXRpb25SZXN1bHQudG9rZW5JZCA9IHR4SnNvbi50b2tlbklkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwbGFuYXRpb25SZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHR4LnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5XYWxsZXRJbml0aWFsaXphdGlvbikge1xuICAgICAgY29uc3QgZGlzcGxheU9yZGVyID0gW1xuICAgICAgICAnaWQnLFxuICAgICAgICAnZmVlJyxcbiAgICAgICAgJ21lbW8nLFxuICAgICAgICAndHlwZScsXG4gICAgICAgICd2b3RlS2V5JyxcbiAgICAgICAgJ3NlbGVjdGlvbktleScsXG4gICAgICAgICd2b3RlRmlyc3QnLFxuICAgICAgICAndm90ZUxhc3QnLFxuICAgICAgICAndm90ZUtleURpbHV0aW9uJyxcbiAgICAgIF07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXlPcmRlcixcbiAgICAgICAgaWQ6IHR4SnNvbi5pZCxcbiAgICAgICAgb3V0cHV0QW1vdW50OiAnMCcsXG4gICAgICAgIGNoYW5nZUFtb3VudDogJzAnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgY2hhbmdlT3V0cHV0czogW10sXG4gICAgICAgIGZlZTogdHhKc29uLmZlZSxcbiAgICAgICAgbWVtbzogdHhKc29uLm5vdGUsXG4gICAgICAgIHR5cGU6IHR4LnR5cGUsXG4gICAgICAgIHZvdGVLZXk6IHR4SnNvbi52b3RlS2V5LFxuICAgICAgICBzZWxlY3Rpb25LZXk6IHR4SnNvbi5zZWxlY3Rpb25LZXksXG4gICAgICAgIHZvdGVGaXJzdDogdHhKc29uLnZvdGVGaXJzdCxcbiAgICAgICAgdm90ZUxhc3Q6IHR4SnNvbi52b3RlTGFzdCxcbiAgICAgICAgdm90ZUtleURpbHV0aW9uOiB0eEpzb24udm90ZUtleURpbHV0aW9uLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyBpZiBhIHR4IGlzIGEgdG9rZW4gdHhcbiAgICogQHBhcmFtIHR5cGUge3N0cmluZ30gLSB0eCB0eXBlXG4gICAqIEByZXR1cm5zIHRydWUgaWYgaXQncyBhIHRva2VuIHR4XG4gICAqL1xuICBpc1Rva2VuVHgodHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdheGZlcic7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBzZWVkIGlzIGEgdmFsaWQgc3RlbGxhciBzZWVkXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWVkIHRoZSBzZWVkIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBpbnB1dCBpcyBhIFN0ZWxsYXIgc2VlZFxuICAgKi9cbiAgaXNTdGVsbGFyU2VlZChzZWVkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gU2VlZFZhbGlkYXRvci5pc1ZhbGlkRWQyNTUxOVNlZWRGb3JDb2luKHNlZWQsIENvaW5GYW1pbHkuWExNKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgc3RlbGxhciBzZWVkIHRvIGFuIGFsZ28gc2VlZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VlZCB0aGUgc2VlZCB0byBjb252ZXJ0XG4gICAqIEByZXR1cm5zIHtCb29sZWFuIHwgbnVsbH0gc2VlZCBpbiBhbGdvIGVuY29kaW5nXG4gICAqL1xuICBjb252ZXJ0RnJvbVN0ZWxsYXJTZWVkKHNlZWQ6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIC8vIGFzc3VtZSB0aGlzIGlzIGEgdHJ1c3QgY3VzdG9kaWFsIHNlZWQgaWYgaXRzIGEgdmFsaWQgZWQyNTUxOSBwcnZcbiAgICBpZiAoIXRoaXMuaXNTdGVsbGFyU2VlZChzZWVkKSB8fCBTZWVkVmFsaWRhdG9yLmhhc0NvbXBldGluZ1NlZWRGb3JtYXRzKHNlZWQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoU2VlZFZhbGlkYXRvci5pc1ZhbGlkRWQyNTUxOVNlZWRGb3JDb2luKHNlZWQsIENvaW5GYW1pbHkuWExNKSkge1xuICAgICAgcmV0dXJuIEFsZ29MaWIuYWxnb1V0aWxzLmNvbnZlcnRGcm9tU3RlbGxhclNlZWQoc2VlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2ZXJpZnlTaWduVHJhbnNhY3Rpb25QYXJhbXMocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogVmVyaWZpZWRUcmFuc2FjdGlvblBhcmFtZXRlcnMge1xuICAgIGNvbnN0IHBydiA9IHBhcmFtcy5wcnY7XG4gICAgY29uc3QgYWRkcmVzc1ZlcnNpb24gPSBwYXJhbXMudHhQcmVidWlsZC5hZGRyZXNzVmVyc2lvbjtcbiAgICBsZXQgaXNIYWxmU2lnbmVkID0gZmFsc2U7XG5cbiAgICAvLyBpdCdzIHBvc3NpYmxlIHRoaXMgdHggd2FzIGFscmVhZHkgc2lnbmVkIC0gdGFrZSB0aGUgaGFsZlNpZ25lZFxuICAgIC8vIHR4SGV4IGlmIGl0IGlzXG4gICAgbGV0IHR4SGV4ID0gcGFyYW1zLnR4UHJlYnVpbGQudHhIZXg7XG4gICAgaWYgKHBhcmFtcy50eFByZWJ1aWxkLmhhbGZTaWduZWQpIHtcbiAgICAgIGlzSGFsZlNpZ25lZCA9IHRydWU7XG4gICAgICB0eEhleCA9IHBhcmFtcy50eFByZWJ1aWxkLmhhbGZTaWduZWQudHhIZXg7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodHhIZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdHhQcmVidWlsZCBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcodHhIZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHR4UHJlYnVpbGQgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCB0eXBlICR7dHlwZW9mIHR4SGV4fWApO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBydikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwcnYgcGFyYW1ldGVyIHRvIHNpZ24gdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcnYgbXVzdCBiZSBhIHN0cmluZywgZ290IHR5cGUgJHt0eXBlb2YgcHJ2fWApO1xuICAgIH1cblxuICAgIGlmICghXy5oYXMocGFyYW1zLnR4UHJlYnVpbGQsICdrZXlzJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwdWJsaWMga2V5cyBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGlmICghXy5pc051bWJlcihhZGRyZXNzVmVyc2lvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBhZGRyZXNzVmVyc2lvbiBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IHNpZ25lcnMgPSBwYXJhbXMudHhQcmVidWlsZC5rZXlzLm1hcCgoa2V5KSA9PiB7XG4gICAgICAvLyBpZiB3ZSBhcmUgcmVjZWl2aW5nIGFkZHJlc3NlcyBkbyBub3QgdHJ5IHRvIGNvbnZlcnQgdGhlbVxuICAgICAgaWYgKCFBbGdvTGliLmFsZ29VdGlscy5pc1ZhbGlkQWRkcmVzcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBBbGdvTGliLmFsZ29VdGlscy5wdWJsaWNLZXlUb0FsZ29BZGRyZXNzKEFsZ29MaWIuYWxnb1V0aWxzLnRvVWludDhBcnJheShrZXkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXk7XG4gICAgfSk7XG4gICAgLy8gVE9ETyhodHRwczovL2JpdGdvaW5jLmF0bGFzc2lhbi5uZXQvYnJvd3NlL1NUTFgtNjA2Nyk6IGZpeCB0aGUgbnVtYmVyIG9mIHNpZ25lcnMgdXNpbmdcbiAgICAvLyBzaG91bGQgYmUgc2ltaWxhciB0byBvdGhlciBjb2lucyBpbXBsZW1lbnRhdGlvblxuICAgIC8vIElmIHdlIGhhdmUgYSBudW1iZXIgd2l0aCBkaWdpdHMgdG8gZWxpbWluYXRlIHRoZW0gd2l0aG91dCB0YWtpbmcgYW55IHJvdW5kaW5nIGNyaXRlcmlhLlxuICAgIGNvbnN0IG51bWJlclNpZ25lcnMgPSBNYXRoLnRydW5jKHNpZ25lcnMubGVuZ3RoIC8gMikgKyAxO1xuICAgIHJldHVybiB7IHR4SGV4LCBhZGRyZXNzVmVyc2lvbiwgc2lnbmVycywgcHJ2LCBpc0hhbGZTaWduZWQsIG51bWJlclNpZ25lcnMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50eFByZWJ1aWxkIHtUcmFuc2FjdGlvblByZWJ1aWxkfSBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgcGxhdGZvcm1cbiAgICogQHBhcmFtIHBhcmFtcy5wcnYge1N0cmluZ30gdXNlciBwcnZcbiAgICogQHJldHVybnMge1Byb21pc2U8U2lnbmVkVHJhbnNhY3Rpb24+fVxuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8U2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCB7IHR4SGV4LCBzaWduZXJzLCBwcnYsIGlzSGFsZlNpZ25lZCwgbnVtYmVyU2lnbmVycyB9ID0gdGhpcy52ZXJpZnlTaWduVHJhbnNhY3Rpb25QYXJhbXMocGFyYW1zKTtcbiAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5nZXRCdWlsZGVyKCk7XG4gICAgY29uc3QgdHhCdWlsZGVyID0gZmFjdG9yeS5mcm9tKHR4SGV4KTtcbiAgICB0eEJ1aWxkZXIubnVtYmVyT2ZSZXF1aXJlZFNpZ25lcnMobnVtYmVyU2lnbmVycyk7XG4gICAgdHhCdWlsZGVyLnNpZ24oeyBrZXk6IHBydiB9KTtcbiAgICB0eEJ1aWxkZXIuc2V0U2lnbmVycyhzaWduZXJzKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgIGlmICghdHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBzaWduZWRUeEhleCA9IEJ1ZmZlci5mcm9tKHRyYW5zYWN0aW9uLnRvQnJvYWRjYXN0Rm9ybWF0KCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBpZiAobnVtYmVyU2lnbmVycyA9PT0gMSkge1xuICAgICAgcmV0dXJuIHsgdHhIZXg6IHNpZ25lZFR4SGV4IH07XG4gICAgfSBlbHNlIGlmIChpc0hhbGZTaWduZWQpIHtcbiAgICAgIHJldHVybiB7IHR4SGV4OiBzaWduZWRUeEhleCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBoYWxmU2lnbmVkOiB7IHR4SGV4OiBzaWduZWRUeEhleCB9IH07XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhZGRyZXNzIGNhbiBiZSB1c2VkIHRvIHNlbmQgZnVuZHMuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMuYWRkcmVzcyBhZGRyZXNzIHRvIHZhbGlkYXRlXG4gICAqIEBwYXJhbSBwYXJhbXMua2V5Y2hhaW5zIHB1YmxpYyBrZXlzIHRvIGdlbmVyYXRlIHRoZSB3YWxsZXRcbiAgICovXG4gIGFzeW5jIGlzV2FsbGV0QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFsZ29BZGRyZXNzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZHJlc3MsXG4gICAgICBrZXljaGFpbnMsXG4gICAgICBjb2luU3BlY2lmaWM6IHsgYml0Z29QdWJLZXkgfSxcbiAgICB9ID0gcGFyYW1zO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgaWYgKCFrZXljaGFpbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwYXJhbSBrZXljaGFpbnMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBlZmZlY3RpdmVLZXljaGFpbiA9IGJpdGdvUHViS2V5ID8ga2V5Y2hhaW5zLnNsaWNlKDAsIC0xKS5jb25jYXQoW3sgcHViOiBiaXRnb1B1YktleSB9XSkgOiBrZXljaGFpbnM7XG4gICAgY29uc3QgcHViS2V5cyA9IGVmZmVjdGl2ZUtleWNoYWluLm1hcCgoa2V5KSA9PiB0aGlzLnN0ZWxsYXJBZGRyZXNzVG9BbGdvQWRkcmVzcyhrZXkucHViKSk7XG5cbiAgICBpZiAoIXB1YktleXMuZXZlcnkoKHB1YktleSkgPT4gdGhpcy5pc1ZhbGlkUHViKHB1YktleSkpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEtleSgnaW52YWxpZCBwdWJsaWMga2V5Jyk7XG4gICAgfVxuXG4gICAgY29uc3Qgcm9vdEFkZHJlc3MgPSBBbGdvTGliLmFsZ29VdGlscy5tdWx0aXNpZ0FkZHJlc3MoU1VQUE9SVEVEX0FERFJFU1NfVkVSU0lPTiwgTVNJR19USFJFU0hPTEQsIHB1YktleXMpO1xuXG4gICAgcmV0dXJuIHJvb3RBZGRyZXNzID09PSBhZGRyZXNzO1xuICB9XG5cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGRlY29kZVR4KHR4bjogQnVmZmVyKTogdW5rbm93biB7XG4gICAgcmV0dXJuIEFsZ29MaWIuYWxnb1V0aWxzLmRlY29kZUFsZ29UeG4odHhuKTtcbiAgfVxuXG4gIGdldEFkZHJlc3NGcm9tUHVibGljS2V5KHB1YktleTogVWludDhBcnJheSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIEFsZ29MaWIuYWxnb1V0aWxzLnB1YmxpY0tleVRvQWxnb0FkZHJlc3MocHViS2V5KTtcbiAgfVxuXG4gIHN1cHBvcnRzRGVyaXZlS2V5V2l0aFNlZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY29uZmlnIGZvciBob3cgdG9rZW4gZW5hYmxlbWVudHMgd29yayBmb3IgdGhpcyBjb2luXG4gICAqIEByZXR1cm5zXG4gICAqICAgIHJlcXVpcmVzVG9rZW5FbmFibGVtZW50OiBUcnVlIGlmIHRva2VucyBuZWVkIHRvIGJlIGVuYWJsZWQgZm9yIHRoaXMgY29pblxuICAgKiAgICBzdXBwb3J0c011bHRpcGxlVG9rZW5FbmFibGVtZW50czogVHJ1ZSBpZiBtdWx0aXBsZSB0b2tlbnMgY2FuIGJlIGVuYWJsZWQgaW4gb25lIHRyYW5zYWN0aW9uXG4gICAqL1xuICBnZXRUb2tlbkVuYWJsZW1lbnRDb25maWcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcXVpcmVzVG9rZW5FbmFibGVtZW50OiB0cnVlLFxuICAgICAgc3VwcG9ydHNNdWx0aXBsZVRva2VuRW5hYmxlbWVudHM6IGZhbHNlLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgYmFsYW5jZSBvZiB0aGUgcm9vdCBhZGRyZXNzIGluIGJhc2UgdW5pdHMgb2YgYWxnb1xuICAgKiBFZy4gSWYgYmFsYW5jZSBpcyAxIEFsZ28sIHRoaXMgcmV0dXJucyAxKjEwXjZcbiAgICogQHBhcmFtIHJvb3RBZGRyZXNzXG4gICAqIEBwYXJhbSBjbGllbnRcbiAgICovXG4gIGFzeW5jIGdldEFjY291bnRCYWxhbmNlKHJvb3RBZGRyZXNzOiBzdHJpbmcsIGNsaWVudDogYWxnb3Nkay5BbGdvZHYyKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCBhY2NvdW50SW5mb3JtYXRpb24gPSBhd2FpdCBjbGllbnQuYWNjb3VudEluZm9ybWF0aW9uKHJvb3RBZGRyZXNzKS5kbygpO1xuICAgIC8vIEV4dHJhY3QgdGhlIGJhbGFuY2UgZnJvbSB0aGUgYWNjb3VudCBpbmZvcm1hdGlvblxuICAgIHJldHVybiBhY2NvdW50SW5mb3JtYXRpb24uYW1vdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEFsZ28gY2xpZW50IGZvciB0aGUgZ2l2ZW4gdG9rZW4sIGJhc2VTZXJ2ZXIgYW5kIHBvcnRcbiAgICogVXNlZCB0byBpbnRlcmFjdCB3aXRoIHRoZSBBbGdvIG5ldHdvcmtcbiAgICovXG4gIGdldENsaWVudCh0b2tlbjogc3RyaW5nLCBiYXNlU2VydmVyOiBzdHJpbmcsIHBvcnQ6IG51bWJlcik6IGFsZ29zZGsuQWxnb2R2MiB7XG4gICAgcmV0dXJuIG5ldyBhbGdvc2RrLkFsZ29kdjIodG9rZW4sIGJhc2VTZXJ2ZXIsIHBvcnQpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJlY292ZXIocGFyYW1zOiBSZWNvdmVyeU9wdGlvbnMpOiBQcm9taXNlPFJlY292ZXJ5SW5mbyB8IE9mZmxpbmVWYXVsdFR4SW5mbz4ge1xuICAgIGNvbnN0IGlzVW5zaWduZWRTd2VlcCA9IHRoaXMuaXNWYWxpZFB1YihwYXJhbXMudXNlcktleSkgJiYgdGhpcy5pc1ZhbGlkUHViKHBhcmFtcy5iYWNrdXBLZXkpO1xuXG4gICAgaWYgKCFwYXJhbXMubm9kZVBhcmFtcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSB0aGUgZGV0YWlscyBvZiBhbiBBTEdPIG5vZGUgdG8gdXNlIGZvciByZWNvdmVyeScpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHRoZSByb290IGFkZHJlc3NcbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MocGFyYW1zLnJvb3RBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJvb3RBZGRyZXNzLCBnb3Q6ICcgKyBwYXJhbXMucm9vdEFkZHJlc3MpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzXG4gICAgaWYgKCF0aGlzLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlY292ZXJ5RGVzdGluYXRpb24sIGdvdDogJyArIHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmZpcnN0Um91bmQgJiYgbmV3IEJpZ051bWJlcihwYXJhbXMuZmlyc3RSb3VuZCkuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IHJvdW5kIG5lZWRzIHRvIGJlIGEgcG9zaXRpdmUgdmFsdWUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBnZW5lc2lzSWQgPSB0aGlzLmJpdGdvLmdldEVudigpID09PSAncHJvZCcgPyBNQUlOTkVUX0dFTkVTSVNfSUQgOiBURVNUTkVUX0dFTkVTSVNfSUQ7XG4gICAgY29uc3QgZ2VuZXNpc0hhc2ggPSB0aGlzLmJpdGdvLmdldEVudigpID09PSAncHJvZCcgPyBNQUlOTkVUX0dFTkVTSVNfSEFTSCA6IFRFU1RORVRfR0VORVNJU19IQVNIO1xuXG4gICAgVXRpbHMudmFsaWRhdGVCYXNlNjQoZ2VuZXNpc0hhc2gpO1xuXG4gICAgaWYgKCFpc1Vuc2lnbmVkU3dlZXAgJiYgIXBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhbGxldFBhc3NwaHJhc2UgaXMgcmVxdWlyZWQgZm9yIG5vbi1iaXRnbyByZWNvdmVyeScpO1xuICAgIH1cblxuICAgIGNvbnN0IGZhY3RvcnkgPSBuZXcgQWxnb0xpYi5UcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5KGNvaW5zLmdldCgnYWxnbycpKTtcbiAgICBjb25zdCB0eEJ1aWxkZXIgPSBmYWN0b3J5LmdldFRyYW5zZmVyQnVpbGRlcigpO1xuXG4gICAgbGV0IHVzZXJQcnY6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBsZXQgYmFja3VwUHJ2OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgaWYgKCFpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgIGlmICghcGFyYW1zLmJpdGdvS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYml0Z28gcHVibGljIGtleSBmcm9tIHRoZSBrZXlDYXJkIGlzIHJlcXVpcmVkIGZvciBub24tYml0Z28gcmVjb3ZlcnknKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHVzZXJQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoeyBpbnB1dDogcGFyYW1zLnVzZXJLZXksIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSB9KTtcbiAgICAgICAgYmFja3VwUHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHsgaW5wdXQ6IHBhcmFtcy5iYWNrdXBLZXksIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSB9KTtcbiAgICAgICAgY29uc3QgdXNlcktleUFkZHJlc3MgPSBVdGlscy5wcml2YXRlS2V5VG9BbGdvQWRkcmVzcyh1c2VyUHJ2KTtcbiAgICAgICAgY29uc3QgYmFja3VwS2V5QWRkcmVzcyA9IFV0aWxzLnByaXZhdGVLZXlUb0FsZ29BZGRyZXNzKGJhY2t1cFBydik7XG4gICAgICAgIHR4QnVpbGRlci5udW1iZXJPZlJlcXVpcmVkU2lnbmVycygyKS5zZXRTaWduZXJzKFt1c2VyS2V5QWRkcmVzcywgYmFja3VwS2V5QWRkcmVzcywgcGFyYW1zLmJpdGdvS2V5XSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAndW5hYmxlIHRvIGRlY3J5cHQgdXNlcktleSBvciBiYWNrdXBLZXkgd2l0aCB0aGUgd2FsbGV0UGFzc3BocmFzZSBwcm92aWRlZCwgZ290IGVycm9yOiAnICsgZS5tZXNzYWdlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQocGFyYW1zLm5vZGVQYXJhbXMudG9rZW4sIHBhcmFtcy5ub2RlUGFyYW1zLmJhc2VTZXJ2ZXIsIHBhcmFtcy5ub2RlUGFyYW1zLnBvcnQpO1xuICAgIGNvbnN0IG5hdGl2ZUJhbGFuY2UgPSBhd2FpdCB0aGlzLmdldEFjY291bnRCYWxhbmNlKHBhcmFtcy5yb290QWRkcmVzcywgY2xpZW50KTtcblxuICAgIC8vIEFsZ29yYW5kIGFjY291bnRzIHJlcXVpcmUgYSBtaW4uIGJhbGFuY2Ugb2YgMSBBTEdPXG4gICAgY29uc3QgTUlOX01JQ1JPQUxHT1NfQkFMQU5DRSA9IDEwMDAwMDtcbiAgICBjb25zdCBzcGVuZGFibGVBbW91bnQgPSBuZXcgQmlnTnVtYmVyKG5hdGl2ZUJhbGFuY2UpLm1pbnVzKHBhcmFtcy5mZWUpLm1pbnVzKE1JTl9NSUNST0FMR09TX0JBTEFOQ0UpLnRvTnVtYmVyKCk7XG5cbiAgICBpZiAobmV3IEJpZ051bWJlcihzcGVuZGFibGVBbW91bnQpLmlzWmVybygpIHx8IG5ldyBCaWdOdW1iZXIoc3BlbmRhYmxlQW1vdW50KS5pc0xlc3NUaGFuT3JFcXVhbFRvKHBhcmFtcy5mZWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJbnN1ZmZpY2llbnQgYmFsYW5jZSB0byByZWNvdmVyLCBnb3QgYmFsYW5jZTogJyArXG4gICAgICAgICAgbmF0aXZlQmFsYW5jZSArXG4gICAgICAgICAgJyBmZWU6ICcgK1xuICAgICAgICAgIHBhcmFtcy5mZWUgK1xuICAgICAgICAgICcgbWluIGFjY291bnQgYmFsYW5jZTogJyArXG4gICAgICAgICAgTUlOX01JQ1JPQUxHT1NfQkFMQU5DRVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgbGF0ZXN0Um91bmQ6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICBpZiAoIXBhcmFtcy5maXJzdFJvdW5kKSB7XG4gICAgICBsYXRlc3RSb3VuZCA9IGF3YWl0IGNsaWVudFxuICAgICAgICAuc3RhdHVzKClcbiAgICAgICAgLmRvKClcbiAgICAgICAgLnRoZW4oKHN0YXR1cykgPT4gc3RhdHVzWydsYXN0LXJvdW5kJ10pO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0Um91bmQgPSAhcGFyYW1zLmZpcnN0Um91bmQgPyBsYXRlc3RSb3VuZCA6IHBhcmFtcy5maXJzdFJvdW5kO1xuICAgIGlmICghZmlyc3RSb3VuZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmV0Y2ggdGhlIGxhdGVzdCByb3VuZCBmcm9tIHRoZSBub2RlLiBQbGVhc2UgcHJvdmlkZSB0aGUgZmlyc3RSb3VuZCBvciB0cnkgYWdhaW4uJyk7XG4gICAgfVxuICAgIGNvbnN0IExBU1RfUk9VTkRfQlVGRkVSID0gMTAwMDtcbiAgICBjb25zdCBsYXN0Um91bmQgPSBmaXJzdFJvdW5kICsgTEFTVF9ST1VORF9CVUZGRVI7XG5cbiAgICB0eEJ1aWxkZXJcbiAgICAgIC5mZWUoeyBmZWU6IHBhcmFtcy5mZWUudG9TdHJpbmcoKSB9KVxuICAgICAgLmlzRmxhdEZlZSh0cnVlKVxuICAgICAgLnNlbmRlcih7XG4gICAgICAgIGFkZHJlc3M6IHBhcmFtcy5yb290QWRkcmVzcyxcbiAgICAgIH0pXG4gICAgICAudG8oe1xuICAgICAgICBhZGRyZXNzOiBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbixcbiAgICAgIH0pXG4gICAgICAuYW1vdW50KHNwZW5kYWJsZUFtb3VudClcbiAgICAgIC5nZW5lc2lzSWQoZ2VuZXNpc0lkKVxuICAgICAgLmdlbmVzaXNIYXNoKGdlbmVzaXNIYXNoKVxuICAgICAgLmZpcnN0Um91bmQobmV3IEJpZ051bWJlcihmaXJzdFJvdW5kKS50b051bWJlcigpKVxuICAgICAgLmxhc3RSb3VuZChuZXcgQmlnTnVtYmVyKGxhc3RSb3VuZCkudG9OdW1iZXIoKSk7XG5cbiAgICBpZiAocGFyYW1zLm5vdGUpIHtcbiAgICAgIGNvbnN0IG5vdGUgPSBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbShwYXJhbXMubm90ZSwgJ3V0Zi04JykpO1xuICAgICAgdHhCdWlsZGVyLm5vdGUobm90ZSk7XG4gICAgfVxuXG4gICAgLy8gQ29sZCB3YWxsZXQsIG9mZmxpbmUgdmF1bHRcbiAgICBpZiAoaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgICAgY29uc3QgdHhKc29uID0gdHgudG9Kc29uKCkgYXMgVHhEYXRhO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eEhleDogQnVmZmVyLmZyb20odHgudG9Ccm9hZGNhc3RGb3JtYXQoKSkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICB0eXBlOiB0eEpzb24udHlwZSxcbiAgICAgICAgdXNlcktleTogcGFyYW1zLnVzZXJLZXksXG4gICAgICAgIGJhY2t1cEtleTogcGFyYW1zLmJhY2t1cEtleSxcbiAgICAgICAgYml0Z29LZXk6IHBhcmFtcy5iaXRnb0tleSxcbiAgICAgICAgYWRkcmVzczogcGFyYW1zLnJvb3RBZGRyZXNzLFxuICAgICAgICBjb2luOiB0aGlzLmdldENoYWluKCksXG4gICAgICAgIGZlZUluZm86IHR4SnNvbi5mZWUsXG4gICAgICAgIGFtb3VudDogdHhKc29uLmFtb3VudCA/PyBuYXRpdmVCYWxhbmNlLnRvU3RyaW5nKCksXG4gICAgICAgIGZpcnN0Um91bmQ6IHR4SnNvbi5maXJzdFJvdW5kLFxuICAgICAgICBsYXN0Um91bmQ6IHR4SnNvbi5sYXN0Um91bmQsXG4gICAgICAgIGdlbmVzaXNJZDogZ2VuZXNpc0lkLFxuICAgICAgICBnZW5lc2lzSGFzaDogZ2VuZXNpc0hhc2gsXG4gICAgICAgIG5vdGU6IHR4SnNvbi5ub3RlID8gQnVmZmVyLmZyb20odHhKc29uLm5vdGUuYnVmZmVyKS50b1N0cmluZygndXRmLTgnKSA6IHVuZGVmaW5lZCxcbiAgICAgICAga2V5czogW3BhcmFtcy51c2VyS2V5LCBwYXJhbXMuYmFja3VwS2V5LCBwYXJhbXMuYml0Z29LZXldLFxuICAgICAgICBhZGRyZXNzVmVyc2lvbjogMSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTm9uLWJpdGdvIFJlY292ZXJ5IChIb3Qgd2FsbGV0cylcbiAgICB0eEJ1aWxkZXIuc2lnbih7IGtleTogdXNlclBydiB9KTtcbiAgICB0eEJ1aWxkZXIuc2lnbih7IGtleTogYmFja3VwUHJ2IH0pO1xuXG4gICAgY29uc3QgdHggPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICBjb25zdCB0eEpzb24gPSB0eC50b0pzb24oKSBhcyBUeERhdGE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHg6IEJ1ZmZlci5mcm9tKHR4LnRvQnJvYWRjYXN0Rm9ybWF0KCkpLnRvU3RyaW5nKCdiYXNlNjQnKSxcbiAgICAgIGlkOiB0eEpzb24uaWQsXG4gICAgICBjb2luOiB0aGlzLmdldENoYWluKCksXG4gICAgICBmZWU6IHR4SnNvbi5mZWUsXG4gICAgICBmaXJzdFJvdW5kOiB0eEpzb24uZmlyc3RSb3VuZCxcbiAgICAgIGxhc3RSb3VuZDogdHhKc29uLmxhc3RSb3VuZCxcbiAgICAgIGdlbmVzaXNJZDogZ2VuZXNpc0lkLFxuICAgICAgZ2VuZXNpc0hhc2g6IGdlbmVzaXNIYXNoLFxuICAgICAgbm90ZTogdHhKc29uLm5vdGUgPyBCdWZmZXIuZnJvbSh0eEpzb24ubm90ZS5idWZmZXIpLnRvU3RyaW5nKCd1dGYtOCcpIDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyBhIGZ1bGx5IHNpZ25lZCBzZXJpYWxpemVkIGJhc2U2NCB0cmFuc2FjdGlvbiBhbmQgYnJvYWRjYXN0cyBpdCBvbiB0aGUgbmV0d29yay5cbiAgICogVXNlcyB0aGUgZXh0ZXJuYWwgbm9kZSBwcm92aWRlZCBieSB0aGUgY2xpZW50XG4gICAqIEBwYXJhbSBzZXJpYWxpemVkU2lnbmVkVHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIG5vZGVQYXJhbXNcbiAgICovXG4gIGFzeW5jIGJyb2FkY2FzdFRyYW5zYWN0aW9uKHtcbiAgICBzZXJpYWxpemVkU2lnbmVkVHJhbnNhY3Rpb24sXG4gICAgbm9kZVBhcmFtcyxcbiAgfTogQnJvYWRjYXN0VHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxCYXNlQnJvYWRjYXN0VHJhbnNhY3Rpb25SZXN1bHQ+IHtcbiAgICBpZiAoIW5vZGVQYXJhbXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgdGhlIGRldGFpbHMgb2YgdGhlIGFsZ29yYW5kIG5vZGUnKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHR4SGV4ID0gQnVmZmVyLmZyb20oc2VyaWFsaXplZFNpZ25lZFRyYW5zYWN0aW9uLCAnYmFzZTY0JykudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgY29uc3QgYWxnb1R4ID0gVXRpbHMudG9VaW50OEFycmF5KHR4SGV4KTtcbiAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KG5vZGVQYXJhbXMudG9rZW4sIG5vZGVQYXJhbXMuYmFzZVNlcnZlciwgbm9kZVBhcmFtcy5wb3J0KTtcblxuICAgICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zZW5kUmF3VHJhbnNhY3Rpb24oYWxnb1R4KS5kbygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGJyb2FkY2FzdCB0cmFuc2FjdGlvbiwgZXJyb3I6ICcgKyBlLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGVsbGFyIGFuZCBBbGdvcmFuZCBib3RoIHVzZSBrZXlzIG9uIHRoZSBlZDI1NTE5IGN1cnZlLCBidXQgdXNlIGRpZmZlcmVudCBlbmNvZGluZ3MuXG4gICAqIEFzIHRoZSBIU00gZG9lc24ndCBoYXZlIGV4cGxpY2l0IHN1cHBvcnQgdG8gY3JlYXRlIEFsZ29yYW5kIGFkZHJlc3Nlcywgd2UgdXNlIHRoZSBTdGVsbGFyXG4gICAqIGtleXMgYW5kIHJlLWVuY29kZSB0aGVtIHRvIHRoZSBBbGdvcmFuZCBlbmNvZGluZy5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIGNyZWF0aW5nIEFsZ29yYW5kIGN1c3RvZGlhbCB3YWxsZXRzIHJldXNpbmcgU3RlbGxhciBrZXlzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc09yUHViS2V5IGEgU3RlbGxhciBwdWJrZXkgb3IgQWxnb3JhbmQgYWRkcmVzc1xuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgcHJpdmF0ZSBzdGVsbGFyQWRkcmVzc1RvQWxnb0FkZHJlc3MoYWRkcmVzc09yUHViS2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIHdlIGhhdmUgYW4gQWxnb3JhbmQgYWRkcmVzc1xuICAgIGlmICh0aGlzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3NPclB1YktleSkpIHtcbiAgICAgIHJldHVybiBhZGRyZXNzT3JQdWJLZXk7XG4gICAgfVxuXG4gICAgLy8gd2UgaGF2ZSBhIHN0ZWxsYXIga2V5XG4gICAgaWYgKHN0ZWxsYXIuU3RyS2V5LmlzVmFsaWRFZDI1NTE5UHVibGljS2V5KGFkZHJlc3NPclB1YktleSkpIHtcbiAgICAgIGNvbnN0IHN0ZWxsYXJQdWIgPSBzdGVsbGFyLlN0cktleS5kZWNvZGVFZDI1NTE5UHVibGljS2V5KGFkZHJlc3NPclB1YktleSk7XG4gICAgICBjb25zdCBhbGdvQWRkcmVzcyA9IEFsZ29MaWIuYWxnb1V0aWxzLmVuY29kZUFkZHJlc3Moc3RlbGxhclB1Yik7XG4gICAgICBpZiAodGhpcy5pc1ZhbGlkQWRkcmVzcyhhbGdvQWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIGFsZ29BZGRyZXNzO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IFN0ZWxsYXIgYWRkcmVzcyB0byBhbiBBbGdvcmFuZCBhZGRyZXNzIHZpYSBzdGVsbGFyIHB1YmtleS4nKTtcbiAgICAgIC8vIHdlIGhhdmUgYSByb290IHB1YmtleVxuICAgIH0gZWxzZSBpZiAoQWxnb0xpYi5hbGdvVXRpbHMuaXNWYWxpZFB1YmxpY0tleShhZGRyZXNzT3JQdWJLZXkpKSB7XG4gICAgICBjb25zdCBrcCA9IG5ldyBBbGdvTGliLktleVBhaXIoeyBwdWI6IGFkZHJlc3NPclB1YktleSB9KTtcbiAgICAgIGNvbnN0IGFsZ29BZGRyZXNzID0ga3AuZ2V0QWRkcmVzcygpO1xuICAgICAgaWYgKHRoaXMuaXNWYWxpZEFkZHJlc3MoYWxnb0FkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBhbGdvQWRkcmVzcztcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yKCdJbnZhbGlkIHJvb3QgcHVia2V5LicpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yKCdOZWl0aGVyIGFuIEFsZ29yYW5kIGFkZHJlc3MsIGEgc3RlbGxhciBwdWJrZXkgb3IgYSByb290IHB1YmxpYyBrZXkuJyk7XG4gIH1cblxuICBwcml2YXRlIGdldEJ1aWxkZXIoKTogQWxnb0xpYi5UcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5IHtcbiAgICByZXR1cm4gbmV3IEFsZ29MaWIuVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeShjb2lucy5nZXQodGhpcy5nZXRCYXNlQ2hhaW4oKSkpO1xuICB9XG59XG4iXX0=