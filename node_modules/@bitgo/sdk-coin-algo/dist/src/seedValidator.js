"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SeedValidator = void 0;
const stellar = __importStar(require("stellar-sdk"));
const _ = __importStar(require("lodash"));
const statics_1 = require("@bitgo/statics");
const lib_1 = require("./lib");
const cryptography_1 = require("@hashgraph/cryptography");
/**
 * This classes intention is to guess/verify what seeds come from where.
 */
class SeedValidator {
    /**
     * Try to guess what kind of seed this could be
     * @param seed
     * @returns {string} - returns undefined if the coin type is undetectable. returns
     * the coin family otherwise.
     */
    static getCoinFamilyFromSeed(seed) {
        let coin = undefined;
        // if this can be implemented in more than one competing seed format, that could be an issue
        if (!SeedValidator.hasCompetingSeedFormats(seed)) {
            // ordering generally matters here - hbar is the least permissive for seed checking, algo and
            // stellar have checksums. coin is guaranteed to be mutually exclusive by the
            // competing seed format check
            if (lib_1.algoUtils.isValidSeed(seed))
                coin = statics_1.CoinFamily.ALGO;
            if (stellar.StrKey.isValidEd25519SecretSeed(seed))
                coin = statics_1.CoinFamily.XLM;
            if (SeedValidator.isValidHbarSeedFormat(seed))
                coin = statics_1.CoinFamily.HBAR;
        }
        return coin;
    }
    /**
     * Checks whether this is a valid seed for this coin family type.
     * @param seed - seed
     * @param coinFamily - the coinFamily of the coin we're working with
     */
    static isValidEd25519SeedForCoin(seed, coinFamily) {
        const guessedCoin = SeedValidator.getCoinFamilyFromSeed(seed);
        return coinFamily === guessedCoin;
    }
    /**
     * We need to ensure there is no overlap for any two seeds we put into this function. This functions
     * intention is for gating whether this seed could possibly match two formats or is invalid itself.
     * @param seed
     */
    static hasCompetingSeedFormats(seed) {
        const isAlgoSeed = lib_1.algoUtils.isValidSeed(seed);
        const isStellarSeed = stellar.StrKey.isValidEd25519SecretSeed(seed);
        const isHbarSeed = SeedValidator.isValidHbarSeedFormat(seed);
        return _.sum([isAlgoSeed, isStellarSeed, isHbarSeed]) !== 1;
    }
    /**
     * Checks if this is a valid Hbar prv. These can be encoded differently.
     * @param seed
     */
    static isValidHbarSeedFormat(seed) {
        try {
            cryptography_1.PrivateKey.fromString(seed);
        }
        catch {
            return false;
        }
        return true;
    }
}
exports.SeedValidator = SeedValidator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VlZFZhbGlkYXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zZWVkVmFsaWRhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEscURBQXVDO0FBQ3ZDLDBDQUE0QjtBQUM1Qiw0Q0FBNEM7QUFDNUMsK0JBQWtDO0FBQ2xDLDBEQUFxRDtBQUNyRDs7R0FFRztBQUNILE1BQWEsYUFBYTtJQUN4Qjs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxJQUFZO1FBQ3ZDLElBQUksSUFBSSxHQUEyQixTQUFTLENBQUM7UUFFN0MsNEZBQTRGO1FBQzVGLElBQUksQ0FBQyxhQUFhLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDaEQsNkZBQTZGO1lBQzdGLDZFQUE2RTtZQUM3RSw4QkFBOEI7WUFFOUIsSUFBSSxlQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztnQkFBRSxJQUFJLEdBQUcsb0JBQVUsQ0FBQyxJQUFJLENBQUM7WUFDeEQsSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQztnQkFBRSxJQUFJLEdBQUcsb0JBQVUsQ0FBQyxHQUFHLENBQUM7WUFDekUsSUFBSSxhQUFhLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDO2dCQUFFLElBQUksR0FBRyxvQkFBVSxDQUFDLElBQUksQ0FBQztTQUN2RTtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxNQUFNLENBQUMseUJBQXlCLENBQUMsSUFBWSxFQUFFLFVBQXNCO1FBQ25FLE1BQU0sV0FBVyxHQUFHLGFBQWEsQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM5RCxPQUFPLFVBQVUsS0FBSyxXQUFXLENBQUM7SUFDcEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsdUJBQXVCLENBQUMsSUFBWTtRQUN6QyxNQUFNLFVBQVUsR0FBRyxlQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9DLE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDcEUsTUFBTSxVQUFVLEdBQUcsYUFBYSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTdELE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFVBQVUsRUFBRSxhQUFhLEVBQUUsVUFBVSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxJQUFZO1FBQ3ZDLElBQUk7WUFDRix5QkFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM3QjtRQUFDLE1BQU07WUFDTixPQUFPLEtBQUssQ0FBQztTQUNkO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0NBQ0Y7QUEzREQsc0NBMkRDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc3RlbGxhciBmcm9tICdzdGVsbGFyLXNkayc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBDb2luRmFtaWx5IH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHsgYWxnb1V0aWxzIH0gZnJvbSAnLi9saWInO1xuaW1wb3J0IHsgUHJpdmF0ZUtleSB9IGZyb20gJ0BoYXNoZ3JhcGgvY3J5cHRvZ3JhcGh5Jztcbi8qKlxuICogVGhpcyBjbGFzc2VzIGludGVudGlvbiBpcyB0byBndWVzcy92ZXJpZnkgd2hhdCBzZWVkcyBjb21lIGZyb20gd2hlcmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWVkVmFsaWRhdG9yIHtcbiAgLyoqXG4gICAqIFRyeSB0byBndWVzcyB3aGF0IGtpbmQgb2Ygc2VlZCB0aGlzIGNvdWxkIGJlXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gcmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIGNvaW4gdHlwZSBpcyB1bmRldGVjdGFibGUuIHJldHVybnNcbiAgICogdGhlIGNvaW4gZmFtaWx5IG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBnZXRDb2luRmFtaWx5RnJvbVNlZWQoc2VlZDogc3RyaW5nKTogQ29pbkZhbWlseSB8IHVuZGVmaW5lZCB7XG4gICAgbGV0IGNvaW46IENvaW5GYW1pbHkgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBpZiB0aGlzIGNhbiBiZSBpbXBsZW1lbnRlZCBpbiBtb3JlIHRoYW4gb25lIGNvbXBldGluZyBzZWVkIGZvcm1hdCwgdGhhdCBjb3VsZCBiZSBhbiBpc3N1ZVxuICAgIGlmICghU2VlZFZhbGlkYXRvci5oYXNDb21wZXRpbmdTZWVkRm9ybWF0cyhzZWVkKSkge1xuICAgICAgLy8gb3JkZXJpbmcgZ2VuZXJhbGx5IG1hdHRlcnMgaGVyZSAtIGhiYXIgaXMgdGhlIGxlYXN0IHBlcm1pc3NpdmUgZm9yIHNlZWQgY2hlY2tpbmcsIGFsZ28gYW5kXG4gICAgICAvLyBzdGVsbGFyIGhhdmUgY2hlY2tzdW1zLiBjb2luIGlzIGd1YXJhbnRlZWQgdG8gYmUgbXV0dWFsbHkgZXhjbHVzaXZlIGJ5IHRoZVxuICAgICAgLy8gY29tcGV0aW5nIHNlZWQgZm9ybWF0IGNoZWNrXG5cbiAgICAgIGlmIChhbGdvVXRpbHMuaXNWYWxpZFNlZWQoc2VlZCkpIGNvaW4gPSBDb2luRmFtaWx5LkFMR087XG4gICAgICBpZiAoc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlTZWNyZXRTZWVkKHNlZWQpKSBjb2luID0gQ29pbkZhbWlseS5YTE07XG4gICAgICBpZiAoU2VlZFZhbGlkYXRvci5pc1ZhbGlkSGJhclNlZWRGb3JtYXQoc2VlZCkpIGNvaW4gPSBDb2luRmFtaWx5LkhCQVI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvaW47XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBpcyBhIHZhbGlkIHNlZWQgZm9yIHRoaXMgY29pbiBmYW1pbHkgdHlwZS5cbiAgICogQHBhcmFtIHNlZWQgLSBzZWVkXG4gICAqIEBwYXJhbSBjb2luRmFtaWx5IC0gdGhlIGNvaW5GYW1pbHkgb2YgdGhlIGNvaW4gd2UncmUgd29ya2luZyB3aXRoXG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZEVkMjU1MTlTZWVkRm9yQ29pbihzZWVkOiBzdHJpbmcsIGNvaW5GYW1pbHk6IENvaW5GYW1pbHkpOiBib29sZWFuIHtcbiAgICBjb25zdCBndWVzc2VkQ29pbiA9IFNlZWRWYWxpZGF0b3IuZ2V0Q29pbkZhbWlseUZyb21TZWVkKHNlZWQpO1xuICAgIHJldHVybiBjb2luRmFtaWx5ID09PSBndWVzc2VkQ29pbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSBuZWVkIHRvIGVuc3VyZSB0aGVyZSBpcyBubyBvdmVybGFwIGZvciBhbnkgdHdvIHNlZWRzIHdlIHB1dCBpbnRvIHRoaXMgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb25zXG4gICAqIGludGVudGlvbiBpcyBmb3IgZ2F0aW5nIHdoZXRoZXIgdGhpcyBzZWVkIGNvdWxkIHBvc3NpYmx5IG1hdGNoIHR3byBmb3JtYXRzIG9yIGlzIGludmFsaWQgaXRzZWxmLlxuICAgKiBAcGFyYW0gc2VlZFxuICAgKi9cbiAgc3RhdGljIGhhc0NvbXBldGluZ1NlZWRGb3JtYXRzKHNlZWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGlzQWxnb1NlZWQgPSBhbGdvVXRpbHMuaXNWYWxpZFNlZWQoc2VlZCk7XG4gICAgY29uc3QgaXNTdGVsbGFyU2VlZCA9IHN0ZWxsYXIuU3RyS2V5LmlzVmFsaWRFZDI1NTE5U2VjcmV0U2VlZChzZWVkKTtcbiAgICBjb25zdCBpc0hiYXJTZWVkID0gU2VlZFZhbGlkYXRvci5pc1ZhbGlkSGJhclNlZWRGb3JtYXQoc2VlZCk7XG5cbiAgICByZXR1cm4gXy5zdW0oW2lzQWxnb1NlZWQsIGlzU3RlbGxhclNlZWQsIGlzSGJhclNlZWRdKSAhPT0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBpcyBhIHZhbGlkIEhiYXIgcHJ2LiBUaGVzZSBjYW4gYmUgZW5jb2RlZCBkaWZmZXJlbnRseS5cbiAgICogQHBhcmFtIHNlZWRcbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkSGJhclNlZWRGb3JtYXQoc2VlZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIFByaXZhdGVLZXkuZnJvbVN0cmluZyhzZWVkKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiJdfQ==