"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signAndVerifyWalletTransaction = exports.signAndVerifyPsbt = exports.TransactionSigningError = exports.InputSigningError = void 0;
/**
 * @prettier
 */
const utxolib = require("@bitgo/utxo-lib");
const { isWalletUnspent, signInputWithUnspent, toOutput } = utxolib.bitgo;
const debugLib = require("debug");
const replayProtection_1 = require("./replayProtection");
const debug = debugLib('bitgo:v2:utxo');
class InputSigningError extends Error {
    constructor(inputIndex, unspent, reason) {
        super(`signing error at input ${inputIndex}: unspentId=${unspent.id}: ${reason}`);
        this.inputIndex = inputIndex;
        this.unspent = unspent;
        this.reason = reason;
    }
    static expectedWalletUnspent(inputIndex, unspent) {
        return new InputSigningError(inputIndex, unspent, `not a wallet unspent, not a replay protection unspent`);
    }
}
exports.InputSigningError = InputSigningError;
class TransactionSigningError extends Error {
    constructor(signErrors, verifyError) {
        super(`sign errors at inputs: [${signErrors.join(',')}], ` +
            `verify errors at inputs: [${verifyError.join(',')}], see log for details`);
    }
}
exports.TransactionSigningError = TransactionSigningError;
/**
 * Sign all inputs of a psbt and verify signatures after signing.
 * Collects and logs signing errors and verification errors, throws error in the end if any of them
 * failed.
 *
 * If it is the last signature, finalize and extract the transaction from the psbt.
 *
 * This function mirrors signAndVerifyWalletTransaction, but is used for signing PSBTs instead of
 * using TransactionBuilder
 *
 * @param psbt
 * @param signerKeychain
 * @param isLastSignature
 */
function signAndVerifyPsbt(psbt, signerKeychain, { isLastSignature, allowNonSegwitSigningWithoutPrevTx, }) {
    const txInputs = psbt.txInputs;
    const outputIds = [];
    const scriptTypes = [];
    const signErrors = psbt.data.inputs
        .map((input, inputIndex) => {
        const outputId = utxolib.bitgo.formatOutputId(utxolib.bitgo.getOutputIdForInput(txInputs[inputIndex]));
        outputIds.push(outputId);
        const { scriptType } = utxolib.bitgo.parsePsbtInput(input);
        scriptTypes.push(scriptType);
        if (scriptType === 'p2shP2pk') {
            debug('Skipping signature for input %d of %d (RP input?)', inputIndex + 1, psbt.data.inputs.length);
            return;
        }
        try {
            utxolib.bitgo.withUnsafeNonSegwit(psbt, () => psbt.signInputHD(inputIndex, signerKeychain), !!allowNonSegwitSigningWithoutPrevTx);
            debug('Successfully signed input %d of %d', inputIndex + 1, psbt.data.inputs.length);
        }
        catch (e) {
            return new InputSigningError(inputIndex, { id: outputId }, e);
        }
    })
        .filter((e) => e !== undefined);
    const verifyErrors = psbt.data.inputs
        .map((input, inputIndex) => {
        const scriptType = scriptTypes[inputIndex];
        if (scriptType === 'p2shP2pk') {
            debug('Skipping input signature %d of %d (unspent from replay protection address which is platform signed only)', inputIndex + 1, psbt.data.inputs.length);
            return;
        }
        const outputId = outputIds[inputIndex];
        try {
            if (!utxolib.bitgo.withUnsafeNonSegwit(psbt, () => psbt.validateSignaturesOfInputHD(inputIndex, signerKeychain), !!allowNonSegwitSigningWithoutPrevTx)) {
                return new InputSigningError(inputIndex, { id: outputId }, new Error(`invalid signature`));
            }
        }
        catch (e) {
            debug('Invalid signature');
            return new InputSigningError(inputIndex, { id: outputId }, e);
        }
    })
        .filter((e) => e !== undefined);
    if (signErrors.length || verifyErrors.length) {
        throw new TransactionSigningError(signErrors, verifyErrors);
    }
    if (isLastSignature) {
        psbt.finalizeAllInputs();
        return psbt.extractTransaction();
    }
    return psbt;
}
exports.signAndVerifyPsbt = signAndVerifyPsbt;
/**
 * Sign all inputs of a wallet transaction and verify signatures after signing.
 * Collects and logs signing errors and verification errors, throws error in the end if any of them
 * failed.
 *
 * @param transaction - wallet transaction (builder) to be signed
 * @param unspents - transaction unspents
 * @param walletSigner - signing parameters
 * @param isLastSignature - Returns full-signed transaction when true. Builds half-signed when false.
 */
function signAndVerifyWalletTransaction(transaction, unspents, walletSigner, { isLastSignature }) {
    const network = transaction.network;
    const prevOutputs = unspents.map((u) => toOutput(u, network));
    let txBuilder;
    if (transaction instanceof utxolib.bitgo.UtxoTransaction) {
        txBuilder = utxolib.bitgo.createTransactionBuilderFromTransaction(transaction, prevOutputs);
        if (transaction.ins.length !== unspents.length) {
            throw new Error(`transaction inputs must match unspents`);
        }
    }
    else if (transaction instanceof utxolib.bitgo.UtxoTransactionBuilder) {
        txBuilder = transaction;
    }
    else {
        throw new Error(`must pass UtxoTransaction or UtxoTransactionBuilder`);
    }
    const signErrors = unspents
        .map((unspent, inputIndex) => {
        if ((0, replayProtection_1.isReplayProtectionUnspent)(unspent, network)) {
            debug('Skipping signature for input %d of %d (RP input?)', inputIndex + 1, unspents.length);
            return;
        }
        if (!isWalletUnspent(unspent)) {
            return InputSigningError.expectedWalletUnspent(inputIndex, unspent);
        }
        try {
            signInputWithUnspent(txBuilder, inputIndex, unspent, walletSigner);
            debug('Successfully signed input %d of %d', inputIndex + 1, unspents.length);
        }
        catch (e) {
            return new InputSigningError(inputIndex, unspent, e);
        }
    })
        .filter((e) => e !== undefined);
    const signedTransaction = isLastSignature ? txBuilder.build() : txBuilder.buildIncomplete();
    const verifyErrors = signedTransaction.ins
        .map((input, inputIndex) => {
        const unspent = unspents[inputIndex];
        if ((0, replayProtection_1.isReplayProtectionUnspent)(unspent, network)) {
            debug('Skipping input signature %d of %d (unspent from replay protection address which is platform signed only)', inputIndex + 1, unspents.length);
            return;
        }
        if (!isWalletUnspent(unspent)) {
            return InputSigningError.expectedWalletUnspent(inputIndex, unspent);
        }
        try {
            const publicKey = walletSigner.deriveForChainAndIndex(unspent.chain, unspent.index).signer.publicKey;
            if (!utxolib.bitgo.verifySignatureWithPublicKey(signedTransaction, inputIndex, prevOutputs, publicKey)) {
                return new InputSigningError(inputIndex, unspent, new Error(`invalid signature`));
            }
        }
        catch (e) {
            debug('Invalid signature');
            return new InputSigningError(inputIndex, unspent, e);
        }
    })
        .filter((e) => e !== undefined);
    if (signErrors.length || verifyErrors.length) {
        throw new TransactionSigningError(signErrors, verifyErrors);
    }
    return signedTransaction;
}
exports.signAndVerifyWalletTransaction = signAndVerifyWalletTransaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zaWduLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBOztHQUVHO0FBQ0gsMkNBQTJDO0FBQzNDLE1BQU0sRUFBRSxlQUFlLEVBQUUsb0JBQW9CLEVBQUUsUUFBUSxFQUFFLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztBQUkxRSxrQ0FBa0M7QUFFbEMseURBQStEO0FBRS9ELE1BQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQztBQVV4QyxNQUFhLGlCQUE0RCxTQUFRLEtBQUs7SUFRcEYsWUFDUyxVQUFrQixFQUNsQixPQUEwQyxFQUMxQyxNQUFzQjtRQUU3QixLQUFLLENBQUMsMEJBQTBCLFVBQVUsZUFBZSxPQUFPLENBQUMsRUFBRSxLQUFLLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFKM0UsZUFBVSxHQUFWLFVBQVUsQ0FBUTtRQUNsQixZQUFPLEdBQVAsT0FBTyxDQUFtQztRQUMxQyxXQUFNLEdBQU4sTUFBTSxDQUFnQjtJQUcvQixDQUFDO0lBYkQsTUFBTSxDQUFDLHFCQUFxQixDQUMxQixVQUFrQixFQUNsQixPQUEwQztRQUUxQyxPQUFPLElBQUksaUJBQWlCLENBQUMsVUFBVSxFQUFFLE9BQU8sRUFBRSx1REFBdUQsQ0FBQyxDQUFDO0lBQzdHLENBQUM7Q0FTRjtBQWZELDhDQWVDO0FBRUQsTUFBYSx1QkFBa0UsU0FBUSxLQUFLO0lBQzFGLFlBQVksVUFBd0MsRUFBRSxXQUF5QztRQUM3RixLQUFLLENBQ0gsMkJBQTJCLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUs7WUFDbEQsNkJBQTZCLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLHdCQUF3QixDQUM3RSxDQUFDO0lBQ0osQ0FBQztDQUNGO0FBUEQsMERBT0M7QUFFRDs7Ozs7Ozs7Ozs7OztHQWFHO0FBQ0gsU0FBZ0IsaUJBQWlCLENBQy9CLElBQTRCLEVBQzVC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LElBQUksdUJBQXVCLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO0tBQzdEO0lBRUQsT0FBTyxpQkFBaUIsQ0FBQztBQUMzQixDQUFDO0FBMUVELHdFQTBFQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCAqIGFzIHV0eG9saWIgZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmNvbnN0IHsgaXNXYWxsZXRVbnNwZW50LCBzaWduSW5wdXRXaXRoVW5zcGVudCwgdG9PdXRwdXQgfSA9IHV0eG9saWIuYml0Z287XG50eXBlIFVuc3BlbnQ8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludCA9IG51bWJlcj4gPSB1dHhvbGliLmJpdGdvLlVuc3BlbnQ8VE51bWJlcj47XG50eXBlIFJvb3RXYWxsZXRLZXlzID0gdXR4b2xpYi5iaXRnby5Sb290V2FsbGV0S2V5cztcblxuaW1wb3J0ICogYXMgZGVidWdMaWIgZnJvbSAnZGVidWcnO1xuXG5pbXBvcnQgeyBpc1JlcGxheVByb3RlY3Rpb25VbnNwZW50IH0gZnJvbSAnLi9yZXBsYXlQcm90ZWN0aW9uJztcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0xpYignYml0Z286djI6dXR4bycpO1xuXG50eXBlIFBzYnRQYXJzZWRTY3JpcHRUeXBlcyA9XG4gIHwgJ3Ayc2gnXG4gIHwgJ3Ayd3NoJ1xuICB8ICdwMnNoUDJ3c2gnXG4gIHwgJ3Ayc2hQMnBrJ1xuICB8ICd0YXByb290S2V5UGF0aFNwZW5kJ1xuICB8ICd0YXByb290U2NyaXB0UGF0aFNwZW5kJztcblxuZXhwb3J0IGNsYXNzIElucHV0U2lnbmluZ0Vycm9yPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQgPSBudW1iZXI+IGV4dGVuZHMgRXJyb3Ige1xuICBzdGF0aWMgZXhwZWN0ZWRXYWxsZXRVbnNwZW50PFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KFxuICAgIGlucHV0SW5kZXg6IG51bWJlcixcbiAgICB1bnNwZW50OiBVbnNwZW50PFROdW1iZXI+IHwgeyBpZDogc3RyaW5nIH1cbiAgKTogSW5wdXRTaWduaW5nRXJyb3I8VE51bWJlcj4ge1xuICAgIHJldHVybiBuZXcgSW5wdXRTaWduaW5nRXJyb3IoaW5wdXRJbmRleCwgdW5zcGVudCwgYG5vdCBhIHdhbGxldCB1bnNwZW50LCBub3QgYSByZXBsYXkgcHJvdGVjdGlvbiB1bnNwZW50YCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgaW5wdXRJbmRleDogbnVtYmVyLFxuICAgIHB1YmxpYyB1bnNwZW50OiBVbnNwZW50PFROdW1iZXI+IHwgeyBpZDogc3RyaW5nIH0sXG4gICAgcHVibGljIHJlYXNvbjogRXJyb3IgfCBzdHJpbmdcbiAgKSB7XG4gICAgc3VwZXIoYHNpZ25pbmcgZXJyb3IgYXQgaW5wdXQgJHtpbnB1dEluZGV4fTogdW5zcGVudElkPSR7dW5zcGVudC5pZH06ICR7cmVhc29ufWApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvblNpZ25pbmdFcnJvcjxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50ID0gbnVtYmVyPiBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2lnbkVycm9yczogSW5wdXRTaWduaW5nRXJyb3I8VE51bWJlcj5bXSwgdmVyaWZ5RXJyb3I6IElucHV0U2lnbmluZ0Vycm9yPFROdW1iZXI+W10pIHtcbiAgICBzdXBlcihcbiAgICAgIGBzaWduIGVycm9ycyBhdCBpbnB1dHM6IFske3NpZ25FcnJvcnMuam9pbignLCcpfV0sIGAgK1xuICAgICAgICBgdmVyaWZ5IGVycm9ycyBhdCBpbnB1dHM6IFske3ZlcmlmeUVycm9yLmpvaW4oJywnKX1dLCBzZWUgbG9nIGZvciBkZXRhaWxzYFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBTaWduIGFsbCBpbnB1dHMgb2YgYSBwc2J0IGFuZCB2ZXJpZnkgc2lnbmF0dXJlcyBhZnRlciBzaWduaW5nLlxuICogQ29sbGVjdHMgYW5kIGxvZ3Mgc2lnbmluZyBlcnJvcnMgYW5kIHZlcmlmaWNhdGlvbiBlcnJvcnMsIHRocm93cyBlcnJvciBpbiB0aGUgZW5kIGlmIGFueSBvZiB0aGVtXG4gKiBmYWlsZWQuXG4gKlxuICogSWYgaXQgaXMgdGhlIGxhc3Qgc2lnbmF0dXJlLCBmaW5hbGl6ZSBhbmQgZXh0cmFjdCB0aGUgdHJhbnNhY3Rpb24gZnJvbSB0aGUgcHNidC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG1pcnJvcnMgc2lnbkFuZFZlcmlmeVdhbGxldFRyYW5zYWN0aW9uLCBidXQgaXMgdXNlZCBmb3Igc2lnbmluZyBQU0JUcyBpbnN0ZWFkIG9mXG4gKiB1c2luZyBUcmFuc2FjdGlvbkJ1aWxkZXJcbiAqXG4gKiBAcGFyYW0gcHNidFxuICogQHBhcmFtIHNpZ25lcktleWNoYWluXG4gKiBAcGFyYW0gaXNMYXN0U2lnbmF0dXJlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWduQW5kVmVyaWZ5UHNidChcbiAgcHNidDogdXR4b2xpYi5iaXRnby5VdHhvUHNidCxcbiAgc2lnbmVyS2V5Y2hhaW46IHV0eG9saWIuQklQMzJJbnRlcmZhY2UsXG4gIHtcbiAgICBpc0xhc3RTaWduYXR1cmUsXG4gICAgYWxsb3dOb25TZWd3aXRTaWduaW5nV2l0aG91dFByZXZUeCxcbiAgfTogeyBpc0xhc3RTaWduYXR1cmU6IGJvb2xlYW47IGFsbG93Tm9uU2Vnd2l0U2lnbmluZ1dpdGhvdXRQcmV2VHg/OiBib29sZWFuIH1cbik6IHV0eG9saWIuYml0Z28uVXR4b1BzYnQgfCB1dHhvbGliLmJpdGdvLlV0eG9UcmFuc2FjdGlvbjxiaWdpbnQ+IHtcbiAgY29uc3QgdHhJbnB1dHMgPSBwc2J0LnR4SW5wdXRzO1xuICBjb25zdCBvdXRwdXRJZHM6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IHNjcmlwdFR5cGVzOiBQc2J0UGFyc2VkU2NyaXB0VHlwZXNbXSA9IFtdO1xuXG4gIGNvbnN0IHNpZ25FcnJvcnM6IElucHV0U2lnbmluZ0Vycm9yPGJpZ2ludD5bXSA9IHBzYnQuZGF0YS5pbnB1dHNcbiAgICAubWFwKChpbnB1dCwgaW5wdXRJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCBvdXRwdXRJZCA9IHV0eG9saWIuYml0Z28uZm9ybWF0T3V0cHV0SWQodXR4b2xpYi5iaXRnby5nZXRPdXRwdXRJZEZvcklucHV0KHR4SW5wdXRzW2lucHV0SW5kZXhdKSk7XG4gICAgICBvdXRwdXRJZHMucHVzaChvdXRwdXRJZCk7XG5cbiAgICAgIGNvbnN0IHsgc2NyaXB0VHlwZSB9ID0gdXR4b2xpYi5iaXRnby5wYXJzZVBzYnRJbnB1dChpbnB1dCk7XG4gICAgICBzY3JpcHRUeXBlcy5wdXNoKHNjcmlwdFR5cGUpO1xuXG4gICAgICBpZiAoc2NyaXB0VHlwZSA9PT0gJ3Ayc2hQMnBrJykge1xuICAgICAgICBkZWJ1ZygnU2tpcHBpbmcgc2lnbmF0dXJlIGZvciBpbnB1dCAlZCBvZiAlZCAoUlAgaW5wdXQ/KScsIGlucHV0SW5kZXggKyAxLCBwc2J0LmRhdGEuaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdXR4b2xpYi5iaXRnby53aXRoVW5zYWZlTm9uU2Vnd2l0KFxuICAgICAgICAgIHBzYnQsXG4gICAgICAgICAgKCkgPT4gcHNidC5zaWduSW5wdXRIRChpbnB1dEluZGV4LCBzaWduZXJLZXljaGFpbiksXG4gICAgICAgICAgISFhbGxvd05vblNlZ3dpdFNpZ25pbmdXaXRob3V0UHJldlR4XG4gICAgICAgICk7XG4gICAgICAgIGRlYnVnKCdTdWNjZXNzZnVsbHkgc2lnbmVkIGlucHV0ICVkIG9mICVkJywgaW5wdXRJbmRleCArIDEsIHBzYnQuZGF0YS5pbnB1dHMubGVuZ3RoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnB1dFNpZ25pbmdFcnJvcjxiaWdpbnQ+KGlucHV0SW5kZXgsIHsgaWQ6IG91dHB1dElkIH0sIGUpO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmZpbHRlcigoZSk6IGUgaXMgSW5wdXRTaWduaW5nRXJyb3I8YmlnaW50PiA9PiBlICE9PSB1bmRlZmluZWQpO1xuXG4gIGNvbnN0IHZlcmlmeUVycm9yczogSW5wdXRTaWduaW5nRXJyb3I8YmlnaW50PltdID0gcHNidC5kYXRhLmlucHV0c1xuICAgIC5tYXAoKGlucHV0LCBpbnB1dEluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzY3JpcHRUeXBlID0gc2NyaXB0VHlwZXNbaW5wdXRJbmRleF07XG4gICAgICBpZiAoc2NyaXB0VHlwZSA9PT0gJ3Ayc2hQMnBrJykge1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICAnU2tpcHBpbmcgaW5wdXQgc2lnbmF0dXJlICVkIG9mICVkICh1bnNwZW50IGZyb20gcmVwbGF5IHByb3RlY3Rpb24gYWRkcmVzcyB3aGljaCBpcyBwbGF0Zm9ybSBzaWduZWQgb25seSknLFxuICAgICAgICAgIGlucHV0SW5kZXggKyAxLFxuICAgICAgICAgIHBzYnQuZGF0YS5pbnB1dHMubGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0cHV0SWQgPSBvdXRwdXRJZHNbaW5wdXRJbmRleF07XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXV0eG9saWIuYml0Z28ud2l0aFVuc2FmZU5vblNlZ3dpdChcbiAgICAgICAgICAgIHBzYnQsXG4gICAgICAgICAgICAoKSA9PiBwc2J0LnZhbGlkYXRlU2lnbmF0dXJlc09mSW5wdXRIRChpbnB1dEluZGV4LCBzaWduZXJLZXljaGFpbiksXG4gICAgICAgICAgICAhIWFsbG93Tm9uU2Vnd2l0U2lnbmluZ1dpdGhvdXRQcmV2VHhcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBuZXcgSW5wdXRTaWduaW5nRXJyb3IoaW5wdXRJbmRleCwgeyBpZDogb3V0cHV0SWQgfSwgbmV3IEVycm9yKGBpbnZhbGlkIHNpZ25hdHVyZWApKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1ZygnSW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnB1dFNpZ25pbmdFcnJvcjxiaWdpbnQ+KGlucHV0SW5kZXgsIHsgaWQ6IG91dHB1dElkIH0sIGUpO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmZpbHRlcigoZSk6IGUgaXMgSW5wdXRTaWduaW5nRXJyb3I8YmlnaW50PiA9PiBlICE9PSB1bmRlZmluZWQpO1xuXG4gIGlmIChzaWduRXJyb3JzLmxlbmd0aCB8fCB2ZXJpZnlFcnJvcnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uU2lnbmluZ0Vycm9yKHNpZ25FcnJvcnMsIHZlcmlmeUVycm9ycyk7XG4gIH1cblxuICBpZiAoaXNMYXN0U2lnbmF0dXJlKSB7XG4gICAgcHNidC5maW5hbGl6ZUFsbElucHV0cygpO1xuICAgIHJldHVybiBwc2J0LmV4dHJhY3RUcmFuc2FjdGlvbigpO1xuICB9XG5cbiAgcmV0dXJuIHBzYnQ7XG59XG5cbi8qKlxuICogU2lnbiBhbGwgaW5wdXRzIG9mIGEgd2FsbGV0IHRyYW5zYWN0aW9uIGFuZCB2ZXJpZnkgc2lnbmF0dXJlcyBhZnRlciBzaWduaW5nLlxuICogQ29sbGVjdHMgYW5kIGxvZ3Mgc2lnbmluZyBlcnJvcnMgYW5kIHZlcmlmaWNhdGlvbiBlcnJvcnMsIHRocm93cyBlcnJvciBpbiB0aGUgZW5kIGlmIGFueSBvZiB0aGVtXG4gKiBmYWlsZWQuXG4gKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gd2FsbGV0IHRyYW5zYWN0aW9uIChidWlsZGVyKSB0byBiZSBzaWduZWRcbiAqIEBwYXJhbSB1bnNwZW50cyAtIHRyYW5zYWN0aW9uIHVuc3BlbnRzXG4gKiBAcGFyYW0gd2FsbGV0U2lnbmVyIC0gc2lnbmluZyBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gaXNMYXN0U2lnbmF0dXJlIC0gUmV0dXJucyBmdWxsLXNpZ25lZCB0cmFuc2FjdGlvbiB3aGVuIHRydWUuIEJ1aWxkcyBoYWxmLXNpZ25lZCB3aGVuIGZhbHNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnbkFuZFZlcmlmeVdhbGxldFRyYW5zYWN0aW9uPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KFxuICB0cmFuc2FjdGlvbjogdXR4b2xpYi5iaXRnby5VdHhvVHJhbnNhY3Rpb248VE51bWJlcj4gfCB1dHhvbGliLmJpdGdvLlV0eG9UcmFuc2FjdGlvbkJ1aWxkZXI8VE51bWJlcj4sXG4gIHVuc3BlbnRzOiBVbnNwZW50PFROdW1iZXI+W10sXG4gIHdhbGxldFNpZ25lcjogdXR4b2xpYi5iaXRnby5XYWxsZXRVbnNwZW50U2lnbmVyPFJvb3RXYWxsZXRLZXlzPixcbiAgeyBpc0xhc3RTaWduYXR1cmUgfTogeyBpc0xhc3RTaWduYXR1cmU6IGJvb2xlYW4gfVxuKTogdXR4b2xpYi5iaXRnby5VdHhvVHJhbnNhY3Rpb248VE51bWJlcj4ge1xuICBjb25zdCBuZXR3b3JrID0gdHJhbnNhY3Rpb24ubmV0d29yayBhcyB1dHhvbGliLk5ldHdvcms7XG4gIGNvbnN0IHByZXZPdXRwdXRzID0gdW5zcGVudHMubWFwKCh1KSA9PiB0b091dHB1dCh1LCBuZXR3b3JrKSk7XG5cbiAgbGV0IHR4QnVpbGRlcjogdXR4b2xpYi5iaXRnby5VdHhvVHJhbnNhY3Rpb25CdWlsZGVyPFROdW1iZXI+O1xuICBpZiAodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB1dHhvbGliLmJpdGdvLlV0eG9UcmFuc2FjdGlvbikge1xuICAgIHR4QnVpbGRlciA9IHV0eG9saWIuYml0Z28uY3JlYXRlVHJhbnNhY3Rpb25CdWlsZGVyRnJvbVRyYW5zYWN0aW9uPFROdW1iZXI+KHRyYW5zYWN0aW9uLCBwcmV2T3V0cHV0cyk7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmlucy5sZW5ndGggIT09IHVuc3BlbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0cmFuc2FjdGlvbiBpbnB1dHMgbXVzdCBtYXRjaCB1bnNwZW50c2ApO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIHV0eG9saWIuYml0Z28uVXR4b1RyYW5zYWN0aW9uQnVpbGRlcikge1xuICAgIHR4QnVpbGRlciA9IHRyYW5zYWN0aW9uO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgbXVzdCBwYXNzIFV0eG9UcmFuc2FjdGlvbiBvciBVdHhvVHJhbnNhY3Rpb25CdWlsZGVyYCk7XG4gIH1cblxuICBjb25zdCBzaWduRXJyb3JzOiBJbnB1dFNpZ25pbmdFcnJvcjxUTnVtYmVyPltdID0gdW5zcGVudHNcbiAgICAubWFwKCh1bnNwZW50OiBVbnNwZW50PFROdW1iZXI+LCBpbnB1dEluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIGlmIChpc1JlcGxheVByb3RlY3Rpb25VbnNwZW50PFROdW1iZXI+KHVuc3BlbnQsIG5ldHdvcmspKSB7XG4gICAgICAgIGRlYnVnKCdTa2lwcGluZyBzaWduYXR1cmUgZm9yIGlucHV0ICVkIG9mICVkIChSUCBpbnB1dD8pJywgaW5wdXRJbmRleCArIDEsIHVuc3BlbnRzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNXYWxsZXRVbnNwZW50PFROdW1iZXI+KHVuc3BlbnQpKSB7XG4gICAgICAgIHJldHVybiBJbnB1dFNpZ25pbmdFcnJvci5leHBlY3RlZFdhbGxldFVuc3BlbnQ8VE51bWJlcj4oaW5wdXRJbmRleCwgdW5zcGVudCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBzaWduSW5wdXRXaXRoVW5zcGVudDxUTnVtYmVyPih0eEJ1aWxkZXIsIGlucHV0SW5kZXgsIHVuc3BlbnQsIHdhbGxldFNpZ25lcik7XG4gICAgICAgIGRlYnVnKCdTdWNjZXNzZnVsbHkgc2lnbmVkIGlucHV0ICVkIG9mICVkJywgaW5wdXRJbmRleCArIDEsIHVuc3BlbnRzLmxlbmd0aCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5wdXRTaWduaW5nRXJyb3I8VE51bWJlcj4oaW5wdXRJbmRleCwgdW5zcGVudCwgZSk7XG4gICAgICB9XG4gICAgfSlcbiAgICAuZmlsdGVyKChlKTogZSBpcyBJbnB1dFNpZ25pbmdFcnJvcjxUTnVtYmVyPiA9PiBlICE9PSB1bmRlZmluZWQpO1xuXG4gIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0gaXNMYXN0U2lnbmF0dXJlID8gdHhCdWlsZGVyLmJ1aWxkKCkgOiB0eEJ1aWxkZXIuYnVpbGRJbmNvbXBsZXRlKCk7XG5cbiAgY29uc3QgdmVyaWZ5RXJyb3JzOiBJbnB1dFNpZ25pbmdFcnJvcjxUTnVtYmVyPltdID0gc2lnbmVkVHJhbnNhY3Rpb24uaW5zXG4gICAgLm1hcCgoaW5wdXQsIGlucHV0SW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHVuc3BlbnQgPSB1bnNwZW50c1tpbnB1dEluZGV4XSBhcyBVbnNwZW50PFROdW1iZXI+O1xuICAgICAgaWYgKGlzUmVwbGF5UHJvdGVjdGlvblVuc3BlbnQ8VE51bWJlcj4odW5zcGVudCwgbmV0d29yaykpIHtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgJ1NraXBwaW5nIGlucHV0IHNpZ25hdHVyZSAlZCBvZiAlZCAodW5zcGVudCBmcm9tIHJlcGxheSBwcm90ZWN0aW9uIGFkZHJlc3Mgd2hpY2ggaXMgcGxhdGZvcm0gc2lnbmVkIG9ubHkpJyxcbiAgICAgICAgICBpbnB1dEluZGV4ICsgMSxcbiAgICAgICAgICB1bnNwZW50cy5sZW5ndGhcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1dhbGxldFVuc3BlbnQ8VE51bWJlcj4odW5zcGVudCkpIHtcbiAgICAgICAgcmV0dXJuIElucHV0U2lnbmluZ0Vycm9yLmV4cGVjdGVkV2FsbGV0VW5zcGVudDxUTnVtYmVyPihpbnB1dEluZGV4LCB1bnNwZW50KTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHdhbGxldFNpZ25lci5kZXJpdmVGb3JDaGFpbkFuZEluZGV4KHVuc3BlbnQuY2hhaW4sIHVuc3BlbnQuaW5kZXgpLnNpZ25lci5wdWJsaWNLZXk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhdXR4b2xpYi5iaXRnby52ZXJpZnlTaWduYXR1cmVXaXRoUHVibGljS2V5PFROdW1iZXI+KHNpZ25lZFRyYW5zYWN0aW9uLCBpbnB1dEluZGV4LCBwcmV2T3V0cHV0cywgcHVibGljS2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gbmV3IElucHV0U2lnbmluZ0Vycm9yKGlucHV0SW5kZXgsIHVuc3BlbnQsIG5ldyBFcnJvcihgaW52YWxpZCBzaWduYXR1cmVgKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVidWcoJ0ludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgICAgIHJldHVybiBuZXcgSW5wdXRTaWduaW5nRXJyb3I8VE51bWJlcj4oaW5wdXRJbmRleCwgdW5zcGVudCwgZSk7XG4gICAgICB9XG4gICAgfSlcbiAgICAuZmlsdGVyKChlKTogZSBpcyBJbnB1dFNpZ25pbmdFcnJvcjxUTnVtYmVyPiA9PiBlICE9PSB1bmRlZmluZWQpO1xuXG4gIGlmIChzaWduRXJyb3JzLmxlbmd0aCB8fCB2ZXJpZnlFcnJvcnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uU2lnbmluZ0Vycm9yKHNpZ25FcnJvcnMsIHZlcmlmeUVycm9ycyk7XG4gIH1cblxuICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb247XG59XG4iXX0=