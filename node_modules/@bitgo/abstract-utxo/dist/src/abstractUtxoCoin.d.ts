/// <reference types="node" />
/**
 * @prettier
 */
import * as utxolib from '@bitgo/utxo-lib';
import { bitgo } from '@bitgo/utxo-lib';
import { CrossChainRecoverySigned, CrossChainRecoveryUnsigned, RecoveryProvider, backupKeyRecovery, RecoverParams, V1RecoverParams, v1BackupKeyRecovery } from './recovery';
import { AddressCoinSpecific, BaseCoin, BitGoBase, ExtraPrebuildParamsOptions, HalfSignedUtxoTransaction, IBaseCoin, IRequestTracer, ITransactionExplanation as BaseTransactionExplanation, Keychain, KeychainsTriplet, ParsedTransaction as BaseParsedTransaction, ParseTransactionOptions as BaseParseTransactionOptions, PrecreateBitGoOptions, PresignTransactionOptions, RequestTracer, SignedTransaction, SignTransactionOptions as BaseSignTransactionOptions, SupplementGenerateWalletOptions, TransactionParams as BaseTransactionParams, TransactionPrebuild as BaseTransactionPrebuild, Triple, VerificationOptions, VerifyAddressOptions as BaseVerifyAddressOptions, VerifyTransactionOptions as BaseVerifyTransactionOptions, Wallet, WalletData } from '@bitgo/sdk-core';
import { CustomChangeOptions } from './parseOutput';
import ScriptType2Of3 = utxolib.bitgo.outputScripts.ScriptType2Of3;
declare type UtxoCustomSigningFunction<TNumber extends number | bigint> = {
    (params: {
        coin: IBaseCoin;
        txPrebuild: TransactionPrebuild<TNumber>;
        pubs?: string[];
        /**
         * signingStep flag becomes applicable when both of the following conditions are met:
         * 1) When the external express signer is activated
         * 2) When the PSBT includes at least one taprootKeyPathSpend input.
         *
         * The signing process of a taprootKeyPathSpend input is a 4-step sequence:
         * i) user nonce generation - signerNonce - this is the first call to external express signer signTransaction
         * ii) bitgo nonce generation - cosignerNonce - this is the first and only call to local signTransaction
         * iii) user signature - signerSignature - this is the second call to external express signer signTransaction
         * iv) bitgo signature - not in signTransaction methodâ€™s scope
         *
         * In the absence of this flag, the aforementioned first three sequence is executed in a single signTransaction call.
         *
         * NOTE: We make a strong assumption that the external express signer and its caller uses sticky sessions,
         * since PSBTs are cached in step 1 to be used in step 3 for MuSig2 user secure nonce access.
         */
        signingStep?: 'signerNonce' | 'signerSignature' | 'cosignerNonce';
    }): Promise<SignedTransaction>;
};
declare type Unspent<TNumber extends number | bigint = number> = bitgo.Unspent<TNumber>;
export interface VerifyAddressOptions extends BaseVerifyAddressOptions {
    chain: number;
    index: number;
}
export interface Output {
    address: string;
    amount: string | number;
    external?: boolean;
    needsCustomChangeKeySignatureVerification?: boolean;
}
export interface TransactionExplanation extends BaseTransactionExplanation<string, string> {
    locktime: number;
    outputs: Output[];
    changeOutputs: Output[];
    /**
     * Number of input signatures per input.
     */
    inputSignatures: number[];
    /**
     * Highest input signature count for the transaction
     */
    signatures: number;
}
export interface TransactionInfo<TNumber extends number | bigint = number> {
    /** Maps txid to txhex. Required for offline signing. */
    txHexes?: Record<string, string>;
    changeAddresses?: string[];
    /** psbt does not require unspents. */
    unspents?: Unspent<TNumber>[];
}
export interface ExplainTransactionOptions<TNumber extends number | bigint = number> {
    txHex: string;
    txInfo?: TransactionInfo<TNumber>;
    feeInfo?: string;
    pubs?: Triple<string>;
}
export declare type UtxoNetwork = utxolib.Network;
export interface TransactionPrebuild<TNumber extends number | bigint = number> extends BaseTransactionPrebuild {
    txInfo?: TransactionInfo<TNumber>;
    blockHeight?: number;
}
export interface TransactionParams extends BaseTransactionParams {
    walletPassphrase?: string;
    changeAddress?: string;
    rbfTxIds?: string[];
}
export interface AbstractUtxoCoinWalletData extends WalletData {
    customChangeKeySignatures: {
        user: string;
        backup: string;
        bitgo: string;
    };
}
export declare class AbstractUtxoCoinWallet extends Wallet {
    _wallet: AbstractUtxoCoinWalletData;
    constructor(bitgo: BitGoBase, baseCoin: IBaseCoin, walletData: any);
}
export interface ParseTransactionOptions<TNumber extends number | bigint = number> extends BaseParseTransactionOptions {
    txParams: TransactionParams;
    txPrebuild: TransactionPrebuild<TNumber>;
    wallet: AbstractUtxoCoinWallet;
    verification?: VerificationOptions;
    reqId?: IRequestTracer;
}
export interface ParsedTransaction<TNumber extends number | bigint = number> extends BaseParsedTransaction {
    keychains: {
        user?: Keychain;
        backup?: Keychain;
        bitgo?: Keychain;
    };
    keySignatures: {
        backupPub?: string;
        bitgoPub?: string;
    };
    outputs: Output[];
    missingOutputs: Output[];
    explicitExternalOutputs: Output[];
    implicitExternalOutputs: Output[];
    changeOutputs: Output[];
    explicitExternalSpendAmount: TNumber;
    implicitExternalSpendAmount: TNumber;
    needsCustomChangeKeySignatureVerification: boolean;
    customChange?: CustomChangeOptions;
}
export interface GenerateAddressOptions {
    addressType?: ScriptType2Of3;
    keychains: {
        pub: string;
        aspKeyId?: string;
    }[];
    threshold?: number;
    chain?: number;
    index?: number;
    segwit?: boolean;
    bech32?: boolean;
}
export interface AddressDetails {
    address: string;
    chain: number;
    index: number;
    coin: string;
    coinSpecific: AddressCoinSpecific;
    addressType?: string;
}
declare type UtxoBaseSignTransactionOptions<TNumber extends number | bigint = number> = BaseSignTransactionOptions & {
    /** Transaction prebuild from bitgo server */
    txPrebuild: {
        /**
         * walletId is required in following 2 scenarios.
         * 1. External signer express mode is used.
         * 2. bitgo MuSig2 nonce is requested
         */
        walletId?: string;
        txHex: string;
        txInfo?: TransactionInfo<TNumber>;
    };
    /** xpubs triple for wallet (user, backup, bitgo). Required only when txPrebuild.txHex is not a PSBT */
    pubs?: Triple<string>;
    /** xpub for cosigner (defaults to bitgo) */
    cosignerPub?: string;
    /**
     * When true, creates full-signed transaction without placeholder signatures.
     * When false, creates half-signed transaction with placeholder signatures.
     */
    isLastSignature?: boolean;
    /**
     * If true, allows signing a non-segwit input with a witnessUtxo instead requiring a previous
     * transaction (nonWitnessUtxo)
     */
    allowNonSegwitSigningWithoutPrevTx?: boolean;
};
export declare type SignTransactionOptions<TNumber extends number | bigint = number> = UtxoBaseSignTransactionOptions<TNumber> & ({
    prv: string;
    signingStep?: 'signerNonce' | 'signerSignature';
} | {
    signingStep: 'cosignerNonce';
});
export interface MultiSigAddress {
    outputScript: Buffer;
    redeemScript?: Buffer;
    witnessScript?: Buffer;
    address: string;
}
export interface RecoverFromWrongChainOptions {
    txid: string;
    recoveryAddress: string;
    wallet: string;
    walletPassphrase?: string;
    xprv?: string;
    apiKey?: string;
    /** @deprecated */
    coin?: AbstractUtxoCoin;
    recoveryCoin?: AbstractUtxoCoin;
    signed?: boolean;
}
export interface VerifyKeySignaturesOptions {
    userKeychain: {
        pub?: string;
    };
    keychainToVerify: {
        pub?: string;
    };
    keySignature: string;
}
export interface VerifyUserPublicKeyOptions {
    userKeychain?: Keychain;
    disableNetworking: boolean;
    txParams: TransactionParams;
}
export interface VerifyTransactionOptions<TNumber extends number | bigint = number> extends BaseVerifyTransactionOptions {
    txPrebuild: TransactionPrebuild<TNumber>;
    wallet: AbstractUtxoCoinWallet;
}
export interface SignPsbtRequest {
    psbt: string;
}
export interface SignPsbtResponse {
    psbt: string;
}
export declare abstract class AbstractUtxoCoin extends BaseCoin {
    altScriptHash?: number;
    supportAltScriptDestination?: boolean;
    readonly amountType: 'number' | 'bigint';
    private readonly _network;
    protected constructor(bitgo: BitGoBase, network: utxolib.Network, amountType?: 'number' | 'bigint');
    /**
     * Key Value: Unsigned tx id => PSBT
     * It is used to cache PSBTs with taproot key path (MuSig2) inputs during external express signer is activated.
     * Reason: MuSig2 signer secure nonce is cached in the UtxoPsbt object. It will be required during the signing step.
     * For more info, check SignTransactionOptions.signingStep
     *
     * TODO BTC-276: This cache may need to be done with LRU like memory safe caching if memory issues comes up.
     */
    private static readonly PSBT_CACHE;
    get network(): utxolib.Network;
    sweepWithSendMany(): boolean;
    /** @deprecated */
    static get validAddressTypes(): ScriptType2Of3[];
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    getBaseFactor(): number;
    /**
     * @deprecated
     */
    getCoinLibrary(): typeof utxolib;
    /**
     * Check if an address is valid
     * @param address
     * @param param
     */
    isValidAddress(address: string, param?: {
        anyFormat: boolean;
    } | /* legacy parameter */ boolean): boolean;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub: string): boolean;
    /**
     * Get the latest block height
     * @param reqId
     */
    getLatestBlockHeight(reqId?: RequestTracer): Promise<number>;
    /**
     * Run custom coin logic after a transaction prebuild has been received from BitGo
     * @param prebuild
     */
    postProcessPrebuild<TNumber extends number | bigint>(prebuild: TransactionPrebuild<TNumber>): Promise<TransactionPrebuild<TNumber>>;
    /**
     * @param first
     * @param second
     * @returns {Array} All outputs that are in the first array but not in the second
     */
    protected static outputDifference(first: Output[], second: Output[]): Output[];
    /**
     * Determine an address' type based on its witness and redeem script presence
     * @param addressDetails
     */
    static inferAddressType(addressDetails: {
        chain: number;
    }): ScriptType2Of3 | null;
    createTransactionFromHex<TNumber extends number | bigint = number>(hex: string): utxolib.bitgo.UtxoTransaction<TNumber>;
    /**
     * Extract and fill transaction details such as internal/change spend, external spend (explicit vs. implicit), etc.
     * @param params
     * @returns {*}
     */
    parseTransaction<TNumber extends number | bigint = number>(params: ParseTransactionOptions<TNumber>): Promise<ParsedTransaction<TNumber>>;
    /**
     * Decrypt the wallet's user private key and verify that the claimed public key matches
     * @param {VerifyUserPublicKeyOptions} params
     * @return {boolean}
     * @protected
     */
    protected verifyUserPublicKey(params: VerifyUserPublicKeyOptions): boolean;
    /**
     * Verify signatures produced by the user key over the backup and bitgo keys.
     *
     * If set, these signatures ensure that the wallet keys cannot be changed after the wallet has been created.
     * @param {VerifyKeySignaturesOptions} params
     * @return {{backup: boolean, bitgo: boolean}}
     */
    verifyKeySignature(params: VerifyKeySignaturesOptions): boolean;
    /**
     * Verify signatures against the user private key over the change wallet extended keys
     * @param {ParsedTransaction} tx
     * @param {Keychain} userKeychain
     * @return {boolean}
     * @protected
     */
    protected verifyCustomChangeKeySignatures<TNumber extends number | bigint>(tx: ParsedTransaction<TNumber>, userKeychain: Keychain): boolean;
    /**
     * Get the maximum percentage limit for pay-as-you-go outputs
     *
     * @protected
     */
    protected getPayGoLimit(allowPaygoOutput?: boolean): number;
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param params
     * @param params.txParams params object passed to send
     * @param params.txPrebuild prebuild object returned by server
     * @param params.txPrebuild.txHex prebuilt transaction's txHex form
     * @param params.wallet Wallet object to obtain keys to verify against
     * @param params.verification Object specifying some verification parameters
     * @param params.verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param params.verification.keychains Pass keychains manually rather than fetching them by id
     * @param params.verification.addresses Address details to pass in for out-of-band verification
     * @returns {boolean}
     */
    verifyTransaction<TNumber extends number | bigint = number>(params: VerifyTransactionOptions<TNumber>): Promise<boolean>;
    /**
     * Make sure an address is valid and throw an error if it's not.
     * @param params.address The address string on the network
     * @param params.addressType
     * @param params.keychains Keychain objects with xpubs
     * @param params.coinSpecific Coin-specific details for the address such as a witness script
     * @param params.chain Derivation chain
     * @param params.index Derivation index
     * @throws {InvalidAddressError}
     * @throws {InvalidAddressDerivationPropertyError}
     * @throws {UnexpectedAddressError}
     */
    isWalletAddress(params: VerifyAddressOptions): Promise<boolean>;
    /**
     * Indicates whether coin supports a block target
     * @returns {boolean}
     */
    supportsBlockTarget(): boolean;
    /**
     * @param addressType
     * @returns true iff coin supports spending from unspentType
     */
    supportsAddressType(addressType: ScriptType2Of3): boolean;
    /**
     * @param chain
     * @return true iff coin supports spending from chain
     */
    supportsAddressChain(chain: number): boolean;
    keyIdsForSigning(): number[];
    /**
     * TODO(BG-11487): Remove addressType, segwit, and bech32 params in SDKv6
     * Generate an address for a wallet based on a set of configurations
     * @param params.addressType {string}   Deprecated
     * @param params.keychains   {[object]} Array of objects with xpubs
     * @param params.threshold   {number}   Minimum number of signatures
     * @param params.chain       {number}   Derivation chain (see https://github.com/BitGo/unspents/blob/master/src/codes.ts for
     *                                                 the corresponding address type of a given chain code)
     * @param params.index       {number}   Derivation index
     * @param params.segwit      {boolean}  Deprecated
     * @param params.bech32      {boolean}  Deprecated
     * @returns {{chain: number, index: number, coin: number, coinSpecific: {outputScript, redeemScript}}}
     */
    generateAddress(params: GenerateAddressOptions): AddressDetails;
    /**
     * @returns input psbt added with deterministic MuSig2 nonce for bitgo key for each MuSig2 inputs.
     * @param psbtHex all MuSig2 inputs should contain user MuSig2 nonce
     * @param walletId
     */
    signPsbt(psbtHex: string, walletId: string): Promise<SignPsbtResponse>;
    /**
     * @returns input psbt added with deterministic MuSig2 nonce for bitgo key for each MuSig2 inputs from OVC.
     * @param ovcJson JSON object provided by OVC with fields psbtHex and walletId
     */
    signPsbtFromOVC(ovcJson: Record<string, unknown>): Promise<Record<string, unknown>>;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params - {@see SignTransactionOptions}
     * @returns {Promise<SignedTransaction | HalfSignedUtxoTransaction>}
     */
    signTransaction<TNumber extends number | bigint = number>(params: SignTransactionOptions<TNumber>): Promise<SignedTransaction | HalfSignedUtxoTransaction>;
    /**
     * Sign a transaction with a custom signing function. Example use case is express external signer
     * @param customSigningFunction custom signing function that returns a single signed transaction
     * @param signTransactionParams parameters for custom signing function. Includes txPrebuild and pubs (for legacy tx only).
     *
     * @returns signed transaction as hex string
     */
    signWithCustomSigningFunction<TNumber extends number | bigint>(customSigningFunction: UtxoCustomSigningFunction<TNumber>, signTransactionParams: {
        txPrebuild: TransactionPrebuild<TNumber>;
        pubs?: string[];
    }): Promise<SignedTransaction>;
    /**
     * @param unspent
     * @returns {boolean}
     */
    isBitGoTaintedUnspent<TNumber extends number | bigint>(unspent: Unspent<TNumber>): boolean;
    /**
     * @deprecated - use utxolib.bitgo.getDefaultSigHash(network) instead
     * @returns {number}
     */
    get defaultSigHashType(): number;
    /**
     * @deprecated - use utxolib.bitcoin.verifySignature() instead
     */
    verifySignature(transaction: any, inputIndex: number, amount: number, verificationSettings?: {
        signatureIndex?: number;
        publicKey?: string;
    }): boolean;
    /**
     * Decompose a raw psbt/transaction into useful information, such as the total amounts,
     * change amounts, and transaction outputs.
     * @param params
     */
    explainTransaction<TNumber extends number | bigint = number>(params: ExplainTransactionOptions<TNumber>): Promise<TransactionExplanation>;
    /**
     * Create a multisig address of a given type from a list of keychains and a signing threshold
     * @param addressType
     * @param signatureThreshold
     * @param keys
     */
    createMultiSigAddress(addressType: ScriptType2Of3, signatureThreshold: number, keys: Buffer[]): MultiSigAddress;
    /**
     * @deprecated - use {@see backupKeyRecovery}
     * Builds a funds recovery transaction without BitGo
     * @param params - {@see backupKeyRecovery}
     */
    recover(params: RecoverParams): ReturnType<typeof backupKeyRecovery>;
    recoverV1(params: V1RecoverParams): ReturnType<typeof v1BackupKeyRecovery>;
    /**
     * Recover coin that was sent to wrong chain
     * @param params
     * @param params.txid The txid of the faulty transaction
     * @param params.recoveryAddress address to send recovered funds to
     * @param params.wallet the wallet that received the funds
     * @param params.recoveryCoin the coin type of the wallet that received the funds
     * @param params.signed return a half-signed transaction (default=true)
     * @param params.walletPassphrase the wallet passphrase
     * @param params.xprv the unencrypted xprv (used instead of wallet passphrase)
     * @param params.apiKey for utxo coins other than [BTC,TBTC] this is a Block Chair api key
     * @returns {*}
     */
    recoverFromWrongChain<TNumber extends number | bigint = number>(params: RecoverFromWrongChainOptions): Promise<CrossChainRecoverySigned<TNumber> | CrossChainRecoveryUnsigned<TNumber>>;
    /**
     * Generate bip32 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed: Buffer): {
        pub: string;
        prv: string;
    };
    getExtraPrebuildParams(buildParams: ExtraPrebuildParamsOptions & {
        wallet: Wallet;
    }): Promise<{
        txFormat?: 'legacy' | 'psbt';
        changeAddressType?: ScriptType2Of3[] | ScriptType2Of3;
    }>;
    preCreateBitGo(params: PrecreateBitGoOptions): void;
    presignTransaction(params: PresignTransactionOptions): Promise<any>;
    supplementGenerateWallet(walletParams: SupplementGenerateWalletOptions, keychains: KeychainsTriplet): Promise<any>;
    transactionDataAllowed(): boolean;
    valuelessTransferAllowed(): boolean;
    getRecoveryProvider(apiToken?: string): RecoveryProvider;
}
export {};
//# sourceMappingURL=abstractUtxoCoin.d.ts.map