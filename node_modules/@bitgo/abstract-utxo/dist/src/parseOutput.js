"use strict";
/**
 * @prettier
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseOutput = void 0;
const debugLib = require("debug");
const _ = require("lodash");
const sdk_core_1 = require("@bitgo/sdk-core");
const abstractUtxoCoin_1 = require("./abstractUtxoCoin");
const debug = debugLib('bitgo:v2:parseoutput');
/**
 * Check an address which failed initial validation to see if it's the base address of a migrated v1 bch wallet.
 *
 * The wallet in question could be a migrated SafeHD BCH wallet, and the transaction we
 * are currently parsing is trying to spend change back to the v1 wallet base address.
 *
 * It does this since we don't allow new address creation for these wallets,
 * and instead return the base address from the v1 wallet when a new address is requested.
 * If this new address is requested for the purposes of spending change back to the wallet,
 * the change will go to the v1 wallet base address. This address *is* on the wallet,
 * but it will still cause an error to be thrown by verifyAddress, since the derivation path
 * used for this address is non-standard. (I have seen these addresses derived using paths m/0/0 and m/101,
 * whereas the v2 addresses are derived using path  m/0/0/${chain}/${index}).
 *
 * This means we need to check for this case explicitly in this catch block, and classify
 * these types of outputs as internal instead of external. Failing to do so would cause the
 * transaction's implicit external outputs (ie, outputs which go to addresses not specified in
 * the recipients array) to add up to more than the 150 basis point limit which we enforce on
 * pay-as-you-go outputs (which should be the only implicit external outputs on our transactions).
 *
 * The 150 basis point limit for implicit external sends is enforced in verifyTransaction,
 * which calls this function to get information on the total external/internal spend amounts
 * for a transaction. The idea here is to protect from the transaction being maliciously modified
 * to add more implicit external spends (eg, to an attacker-controlled wallet).
 *
 * See verifyTransaction for more information on how transaction prebuilds are verified before signing.
 *
 * @param wallet {Wallet} wallet which is making the transaction
 * @param currentAddress {string} address to check for externality relative to v1 wallet base address
 */
function isMigratedAddress(wallet, currentAddress) {
    if (_.isString(wallet.migratedFrom()) && wallet.migratedFrom() === currentAddress) {
        debug('found address %s which was migrated from v1 wallet, address is not external', currentAddress);
        return true;
    }
    return false;
}
/**
 * Check to see if an address is derived from the given custom change keys
 * @param {VerifyCustomChangeAddressOptions} params
 * @return {boolean}
 */
async function verifyCustomChangeAddress(params) {
    const { coin, customChangeKeys, addressType, addressDetails, currentAddress } = params;
    try {
        return await coin.verifyAddress(_.extend({ addressType }, addressDetails, {
            keychains: customChangeKeys,
            address: currentAddress,
        }));
    }
    catch (e) {
        debug('failed to verify custom change address %s', currentAddress);
        return false;
    }
}
async function handleVerifyAddressError({ e, currentAddress, wallet, txParams, customChangeKeys, coin, addressDetails, addressType, considerMigratedFromAddressInternal, }) {
    // Todo: name server-side errors to avoid message-based checking [BG-5124]
    const walletAddressNotFound = e.message.includes('wallet address not found');
    const unexpectedAddress = e instanceof sdk_core_1.UnexpectedAddressError;
    if (walletAddressNotFound || unexpectedAddress) {
        if (unexpectedAddress && !walletAddressNotFound) {
            // check to see if this is a migrated v1 bch address - it could be internal
            const isMigrated = isMigratedAddress(wallet, currentAddress);
            if (isMigrated) {
                return { external: considerMigratedFromAddressInternal === false };
            }
            debug('Address %s was found on wallet but could not be reconstructed', currentAddress);
            // attempt to verify address using custom change address keys if the wallet has that feature enabled
            if (customChangeKeys &&
                (await verifyCustomChangeAddress({ coin, addressDetails, addressType, currentAddress, customChangeKeys }))) {
                // address is valid against the custom change keys. Mark address as not external
                // and request signature verification for the custom change keys
                debug('Address %s verified as derived from the custom change keys', currentAddress);
                return { external: false, needsCustomChangeKeySignatureVerification: true };
            }
        }
        // the address was found, but not on the wallet, which simply means it's external
        debug('Address %s presumed external', currentAddress);
        return { external: true };
    }
    else if (e instanceof sdk_core_1.InvalidAddressDerivationPropertyError && currentAddress === txParams.changeAddress) {
        // expect to see this error when passing in a custom changeAddress with no chain or index
        return { external: false };
    }
    console.error('Address classification failed for address', currentAddress);
    console.trace(e);
    /**
     * It might be a completely invalid address or a bad validation attempt or something else completely, in
     * which case we do not proceed and rather rethrow the error, which is safer than assuming that the address
     * validation failed simply because it's external to the wallet.
     */
    throw e;
}
async function fetchAddressDetails({ reqId, disableNetworking, addressDetailsPrebuild, addressDetailsVerification, currentAddress, wallet, }) {
    let addressDetails = _.extend({}, addressDetailsPrebuild, addressDetailsVerification);
    debug('Locally available address %s details: %O', currentAddress, addressDetails);
    if (_.isEmpty(addressDetails) && !disableNetworking) {
        addressDetails = await wallet.getAddress({ address: currentAddress, reqId });
        debug('Downloaded address %s details: %O', currentAddress, addressDetails);
    }
    return addressDetails;
}
async function parseOutput({ currentOutput, coin, txPrebuild, verification, keychainArray, wallet, txParams, customChange, reqId, }) {
    var _a, _b;
    const disableNetworking = !!verification.disableNetworking;
    const currentAddress = currentOutput.address;
    // attempt to grab the address details from either the prebuilt tx, or the verification params.
    // If both of these are empty, then we will try to get the address details from bitgo instead
    const addressDetailsPrebuild = _.get(txPrebuild, `txInfo.walletAddressDetails.${currentAddress}`, {});
    const addressDetailsVerification = (_b = (_a = verification === null || verification === void 0 ? void 0 : verification.addresses) === null || _a === void 0 ? void 0 : _a[currentAddress]) !== null && _b !== void 0 ? _b : {};
    debug('Parsing address details for %s', currentAddress);
    let currentAddressDetails = undefined;
    let currentAddressType = undefined;
    const RECIPIENT_THRESHOLD = 1000;
    try {
        /**
         * The only way to determine whether an address is known on the wallet is to initiate a network request and
         * fetch it. Should the request fail and return a 404, it will throw and therefore has to be caught. For that
         * reason, address wallet ownership detection is wrapped in a try/catch. Additionally, once the address
         * details are fetched on the wallet, a local address validation is run, whose errors however are generated
         * client-side and can therefore be analyzed with more granularity and type checking.
         */
        /**
         * In order to minimize API requests, we assume that explicit recipients are always external when the
         * recipient list is > 1000 This is not always a valid assumption and could lead greater apparent spend (but never lower)
         */
        if (txParams.recipients !== undefined && txParams.recipients.length > RECIPIENT_THRESHOLD) {
            const isCurrentAddressInRecipients = txParams.recipients.some((recipient) => recipient.address.includes(currentAddress));
            if (isCurrentAddressInRecipients) {
                return { ...currentOutput, external: true };
            }
        }
        const addressDetails = await fetchAddressDetails({
            reqId,
            addressDetailsVerification,
            addressDetailsPrebuild,
            currentAddress,
            disableNetworking,
            wallet,
        });
        // verify that the address is on the wallet. verifyAddress throws if
        // it fails to correctly rederive the address, meaning it's external
        currentAddressType = abstractUtxoCoin_1.AbstractUtxoCoin.inferAddressType(addressDetails) || undefined;
        currentAddressDetails = addressDetails;
        await coin.verifyAddress(_.extend({ addressType: currentAddressType }, addressDetails, {
            keychains: keychainArray,
            address: currentAddress,
        }));
        debug('Address %s verification passed', currentAddress);
        // verify address succeeded without throwing, so the address was
        // correctly rederived from the wallet keychains, making it not external
        return _.extend({}, currentOutput, addressDetails, { external: false });
    }
    catch (e) {
        debug('Address %s verification threw an error:', currentAddress, e);
        return _.extend({}, currentOutput, await handleVerifyAddressError({
            e,
            coin,
            currentAddress,
            wallet,
            txParams,
            customChangeKeys: customChange && customChange.keys,
            addressDetails: currentAddressDetails,
            addressType: currentAddressType,
            considerMigratedFromAddressInternal: verification.considerMigratedFromAddressInternal,
        }));
    }
}
exports.parseOutput = parseOutput;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2VPdXRwdXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcGFyc2VPdXRwdXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOztHQUVHOzs7QUFFSCxrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCLDhDQVN5QjtBQUN6Qix5REFBaUY7QUFFakYsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFPL0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkJHO0FBQ0gsU0FBUyxpQkFBaUIsQ0FBQyxNQUFlLEVBQUUsY0FBc0I7SUFDaEUsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxZQUFZLEVBQUUsS0FBSyxjQUFjLEVBQUU7UUFDakYsS0FBSyxDQUFDLDZFQUE2RSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ3JHLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFFRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFVRDs7OztHQUlHO0FBQ0gsS0FBSyxVQUFVLHlCQUF5QixDQUFDLE1BQXdDO0lBQy9FLE1BQU0sRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsV0FBVyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsR0FBRyxNQUFNLENBQUM7SUFDdkYsSUFBSTtRQUNGLE9BQU8sTUFBTSxJQUFJLENBQUMsYUFBYSxDQUM3QixDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsV0FBVyxFQUFFLEVBQUUsY0FBYyxFQUFFO1lBQ3hDLFNBQVMsRUFBRSxnQkFBZ0I7WUFDM0IsT0FBTyxFQUFFLGNBQWM7U0FDeEIsQ0FBQyxDQUNILENBQUM7S0FDSDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsS0FBSyxDQUFDLDJDQUEyQyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ25FLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7QUFDSCxDQUFDO0FBY0Qs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O1FBQ3BFLGtCQUFrQixHQUFHLG1DQUFnQixDQUFDLGdCQUFnQixDQUFDLGNBQWMsQ0FBQyxJQUFJLFNBQVMsQ0FBQztRQUNwRixxQkFBcUIsR0FBRyxjQUFjLENBQUM7UUFDdkMsTUFBTSxJQUFJLENBQUMsYUFBYSxDQUN0QixDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsV0FBVyxFQUFFLGtCQUFrQixFQUFFLEVBQUUsY0FBYyxFQUFFO1lBQzVELFNBQVMsRUFBRSxhQUFhO1lBQ3hCLE9BQU8sRUFBRSxjQUFjO1NBQ3hCLENBQUMsQ0FDSCxDQUFDO1FBQ0YsS0FBSyxDQUFDLGdDQUFnQyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBRXhELGdFQUFnRTtRQUNoRSx3RUFBd0U7UUFDeEUsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7S0FDekU7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLEtBQUssQ0FBQyx5Q0FBeUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDcEUsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUNiLEVBQUUsRUFDRixhQUFhLEVBQ2IsTUFBTSx3QkFBd0IsQ0FBQztZQUM3QixDQUFDO1lBQ0QsSUFBSTtZQUNKLGNBQWM7WUFDZCxNQUFNO1lBQ04sUUFBUTtZQUNSLGdCQUFnQixFQUFFLFlBQVksSUFBSSxZQUFZLENBQUMsSUFBSTtZQUNuRCxjQUFjLEVBQUUscUJBQXFCO1lBQ3JDLFdBQVcsRUFBRSxrQkFBa0I7WUFDL0IsbUNBQW1DLEVBQUUsWUFBWSxDQUFDLG1DQUFtQztTQUN0RixDQUFDLENBQ0gsQ0FBQztLQUNIO0FBQ0gsQ0FBQztBQXRGRCxrQ0FzRkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5cbmltcG9ydCAqIGFzIGRlYnVnTGliIGZyb20gJ2RlYnVnJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7XG4gIEFkZHJlc3NWZXJpZmljYXRpb25EYXRhLFxuICBJUmVxdWVzdFRyYWNlcixcbiAgSW52YWxpZEFkZHJlc3NEZXJpdmF0aW9uUHJvcGVydHlFcnJvcixcbiAgSVdhbGxldCxcbiAgS2V5Y2hhaW4sXG4gIFRyYW5zYWN0aW9uUHJlYnVpbGQsXG4gIFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IsXG4gIFZlcmlmaWNhdGlvbk9wdGlvbnMsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBBYnN0cmFjdFV0eG9Db2luLCBPdXRwdXQsIFRyYW5zYWN0aW9uUGFyYW1zIH0gZnJvbSAnLi9hYnN0cmFjdFV0eG9Db2luJztcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0xpYignYml0Z286djI6cGFyc2VvdXRwdXQnKTtcblxuaW50ZXJmYWNlIEhhbmRsZVZlcmlmeUFkZHJlc3NFcnJvclJlc3BvbnNlIHtcbiAgZXh0ZXJuYWw6IGJvb2xlYW47XG4gIG5lZWRzQ3VzdG9tQ2hhbmdlS2V5U2lnbmF0dXJlVmVyaWZpY2F0aW9uPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBDaGVjayBhbiBhZGRyZXNzIHdoaWNoIGZhaWxlZCBpbml0aWFsIHZhbGlkYXRpb24gdG8gc2VlIGlmIGl0J3MgdGhlIGJhc2UgYWRkcmVzcyBvZiBhIG1pZ3JhdGVkIHYxIGJjaCB3YWxsZXQuXG4gKlxuICogVGhlIHdhbGxldCBpbiBxdWVzdGlvbiBjb3VsZCBiZSBhIG1pZ3JhdGVkIFNhZmVIRCBCQ0ggd2FsbGV0LCBhbmQgdGhlIHRyYW5zYWN0aW9uIHdlXG4gKiBhcmUgY3VycmVudGx5IHBhcnNpbmcgaXMgdHJ5aW5nIHRvIHNwZW5kIGNoYW5nZSBiYWNrIHRvIHRoZSB2MSB3YWxsZXQgYmFzZSBhZGRyZXNzLlxuICpcbiAqIEl0IGRvZXMgdGhpcyBzaW5jZSB3ZSBkb24ndCBhbGxvdyBuZXcgYWRkcmVzcyBjcmVhdGlvbiBmb3IgdGhlc2Ugd2FsbGV0cyxcbiAqIGFuZCBpbnN0ZWFkIHJldHVybiB0aGUgYmFzZSBhZGRyZXNzIGZyb20gdGhlIHYxIHdhbGxldCB3aGVuIGEgbmV3IGFkZHJlc3MgaXMgcmVxdWVzdGVkLlxuICogSWYgdGhpcyBuZXcgYWRkcmVzcyBpcyByZXF1ZXN0ZWQgZm9yIHRoZSBwdXJwb3NlcyBvZiBzcGVuZGluZyBjaGFuZ2UgYmFjayB0byB0aGUgd2FsbGV0LFxuICogdGhlIGNoYW5nZSB3aWxsIGdvIHRvIHRoZSB2MSB3YWxsZXQgYmFzZSBhZGRyZXNzLiBUaGlzIGFkZHJlc3MgKmlzKiBvbiB0aGUgd2FsbGV0LFxuICogYnV0IGl0IHdpbGwgc3RpbGwgY2F1c2UgYW4gZXJyb3IgdG8gYmUgdGhyb3duIGJ5IHZlcmlmeUFkZHJlc3MsIHNpbmNlIHRoZSBkZXJpdmF0aW9uIHBhdGhcbiAqIHVzZWQgZm9yIHRoaXMgYWRkcmVzcyBpcyBub24tc3RhbmRhcmQuIChJIGhhdmUgc2VlbiB0aGVzZSBhZGRyZXNzZXMgZGVyaXZlZCB1c2luZyBwYXRocyBtLzAvMCBhbmQgbS8xMDEsXG4gKiB3aGVyZWFzIHRoZSB2MiBhZGRyZXNzZXMgYXJlIGRlcml2ZWQgdXNpbmcgcGF0aCAgbS8wLzAvJHtjaGFpbn0vJHtpbmRleH0pLlxuICpcbiAqIFRoaXMgbWVhbnMgd2UgbmVlZCB0byBjaGVjayBmb3IgdGhpcyBjYXNlIGV4cGxpY2l0bHkgaW4gdGhpcyBjYXRjaCBibG9jaywgYW5kIGNsYXNzaWZ5XG4gKiB0aGVzZSB0eXBlcyBvZiBvdXRwdXRzIGFzIGludGVybmFsIGluc3RlYWQgb2YgZXh0ZXJuYWwuIEZhaWxpbmcgdG8gZG8gc28gd291bGQgY2F1c2UgdGhlXG4gKiB0cmFuc2FjdGlvbidzIGltcGxpY2l0IGV4dGVybmFsIG91dHB1dHMgKGllLCBvdXRwdXRzIHdoaWNoIGdvIHRvIGFkZHJlc3NlcyBub3Qgc3BlY2lmaWVkIGluXG4gKiB0aGUgcmVjaXBpZW50cyBhcnJheSkgdG8gYWRkIHVwIHRvIG1vcmUgdGhhbiB0aGUgMTUwIGJhc2lzIHBvaW50IGxpbWl0IHdoaWNoIHdlIGVuZm9yY2Ugb25cbiAqIHBheS1hcy15b3UtZ28gb3V0cHV0cyAod2hpY2ggc2hvdWxkIGJlIHRoZSBvbmx5IGltcGxpY2l0IGV4dGVybmFsIG91dHB1dHMgb24gb3VyIHRyYW5zYWN0aW9ucykuXG4gKlxuICogVGhlIDE1MCBiYXNpcyBwb2ludCBsaW1pdCBmb3IgaW1wbGljaXQgZXh0ZXJuYWwgc2VuZHMgaXMgZW5mb3JjZWQgaW4gdmVyaWZ5VHJhbnNhY3Rpb24sXG4gKiB3aGljaCBjYWxscyB0aGlzIGZ1bmN0aW9uIHRvIGdldCBpbmZvcm1hdGlvbiBvbiB0aGUgdG90YWwgZXh0ZXJuYWwvaW50ZXJuYWwgc3BlbmQgYW1vdW50c1xuICogZm9yIGEgdHJhbnNhY3Rpb24uIFRoZSBpZGVhIGhlcmUgaXMgdG8gcHJvdGVjdCBmcm9tIHRoZSB0cmFuc2FjdGlvbiBiZWluZyBtYWxpY2lvdXNseSBtb2RpZmllZFxuICogdG8gYWRkIG1vcmUgaW1wbGljaXQgZXh0ZXJuYWwgc3BlbmRzIChlZywgdG8gYW4gYXR0YWNrZXItY29udHJvbGxlZCB3YWxsZXQpLlxuICpcbiAqIFNlZSB2ZXJpZnlUcmFuc2FjdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdHJhbnNhY3Rpb24gcHJlYnVpbGRzIGFyZSB2ZXJpZmllZCBiZWZvcmUgc2lnbmluZy5cbiAqXG4gKiBAcGFyYW0gd2FsbGV0IHtXYWxsZXR9IHdhbGxldCB3aGljaCBpcyBtYWtpbmcgdGhlIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gY3VycmVudEFkZHJlc3Mge3N0cmluZ30gYWRkcmVzcyB0byBjaGVjayBmb3IgZXh0ZXJuYWxpdHkgcmVsYXRpdmUgdG8gdjEgd2FsbGV0IGJhc2UgYWRkcmVzc1xuICovXG5mdW5jdGlvbiBpc01pZ3JhdGVkQWRkcmVzcyh3YWxsZXQ6IElXYWxsZXQsIGN1cnJlbnRBZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKF8uaXNTdHJpbmcod2FsbGV0Lm1pZ3JhdGVkRnJvbSgpKSAmJiB3YWxsZXQubWlncmF0ZWRGcm9tKCkgPT09IGN1cnJlbnRBZGRyZXNzKSB7XG4gICAgZGVidWcoJ2ZvdW5kIGFkZHJlc3MgJXMgd2hpY2ggd2FzIG1pZ3JhdGVkIGZyb20gdjEgd2FsbGV0LCBhZGRyZXNzIGlzIG5vdCBleHRlcm5hbCcsIGN1cnJlbnRBZGRyZXNzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuaW50ZXJmYWNlIFZlcmlmeUN1c3RvbUNoYW5nZUFkZHJlc3NPcHRpb25zIHtcbiAgY29pbjogQWJzdHJhY3RVdHhvQ29pbjtcbiAgY3VzdG9tQ2hhbmdlS2V5czogSGFuZGxlVmVyaWZ5QWRkcmVzc0Vycm9yT3B0aW9uc1snY3VzdG9tQ2hhbmdlS2V5cyddO1xuICBhZGRyZXNzVHlwZTogSGFuZGxlVmVyaWZ5QWRkcmVzc0Vycm9yT3B0aW9uc1snYWRkcmVzc1R5cGUnXTtcbiAgYWRkcmVzc0RldGFpbHM6IEhhbmRsZVZlcmlmeUFkZHJlc3NFcnJvck9wdGlvbnNbJ2FkZHJlc3NEZXRhaWxzJ107XG4gIGN1cnJlbnRBZGRyZXNzOiBIYW5kbGVWZXJpZnlBZGRyZXNzRXJyb3JPcHRpb25zWydjdXJyZW50QWRkcmVzcyddO1xufVxuXG4vKipcbiAqIENoZWNrIHRvIHNlZSBpZiBhbiBhZGRyZXNzIGlzIGRlcml2ZWQgZnJvbSB0aGUgZ2l2ZW4gY3VzdG9tIGNoYW5nZSBrZXlzXG4gKiBAcGFyYW0ge1ZlcmlmeUN1c3RvbUNoYW5nZUFkZHJlc3NPcHRpb25zfSBwYXJhbXNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeUN1c3RvbUNoYW5nZUFkZHJlc3MocGFyYW1zOiBWZXJpZnlDdXN0b21DaGFuZ2VBZGRyZXNzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCB7IGNvaW4sIGN1c3RvbUNoYW5nZUtleXMsIGFkZHJlc3NUeXBlLCBhZGRyZXNzRGV0YWlscywgY3VycmVudEFkZHJlc3MgfSA9IHBhcmFtcztcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgY29pbi52ZXJpZnlBZGRyZXNzKFxuICAgICAgXy5leHRlbmQoeyBhZGRyZXNzVHlwZSB9LCBhZGRyZXNzRGV0YWlscywge1xuICAgICAgICBrZXljaGFpbnM6IGN1c3RvbUNoYW5nZUtleXMsXG4gICAgICAgIGFkZHJlc3M6IGN1cnJlbnRBZGRyZXNzLFxuICAgICAgfSlcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoJ2ZhaWxlZCB0byB2ZXJpZnkgY3VzdG9tIGNoYW5nZSBhZGRyZXNzICVzJywgY3VycmVudEFkZHJlc3MpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgSGFuZGxlVmVyaWZ5QWRkcmVzc0Vycm9yT3B0aW9ucyB7XG4gIGU6IEVycm9yO1xuICBjdXJyZW50QWRkcmVzczogc3RyaW5nO1xuICB3YWxsZXQ6IElXYWxsZXQ7XG4gIHR4UGFyYW1zOiBUcmFuc2FjdGlvblBhcmFtcztcbiAgY3VzdG9tQ2hhbmdlS2V5cz86IEN1c3RvbUNoYW5nZU9wdGlvbnNbJ2tleXMnXTtcbiAgY29pbjogQWJzdHJhY3RVdHhvQ29pbjtcbiAgYWRkcmVzc0RldGFpbHM/OiBhbnk7XG4gIGFkZHJlc3NUeXBlPzogc3RyaW5nO1xuICBjb25zaWRlck1pZ3JhdGVkRnJvbUFkZHJlc3NJbnRlcm5hbD86IGJvb2xlYW47XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVZlcmlmeUFkZHJlc3NFcnJvcih7XG4gIGUsXG4gIGN1cnJlbnRBZGRyZXNzLFxuICB3YWxsZXQsXG4gIHR4UGFyYW1zLFxuICBjdXN0b21DaGFuZ2VLZXlzLFxuICBjb2luLFxuICBhZGRyZXNzRGV0YWlscyxcbiAgYWRkcmVzc1R5cGUsXG4gIGNvbnNpZGVyTWlncmF0ZWRGcm9tQWRkcmVzc0ludGVybmFsLFxufTogSGFuZGxlVmVyaWZ5QWRkcmVzc0Vycm9yT3B0aW9ucyk6IFByb21pc2U8SGFuZGxlVmVyaWZ5QWRkcmVzc0Vycm9yUmVzcG9uc2U+IHtcbiAgLy8gVG9kbzogbmFtZSBzZXJ2ZXItc2lkZSBlcnJvcnMgdG8gYXZvaWQgbWVzc2FnZS1iYXNlZCBjaGVja2luZyBbQkctNTEyNF1cbiAgY29uc3Qgd2FsbGV0QWRkcmVzc05vdEZvdW5kID0gZS5tZXNzYWdlLmluY2x1ZGVzKCd3YWxsZXQgYWRkcmVzcyBub3QgZm91bmQnKTtcbiAgY29uc3QgdW5leHBlY3RlZEFkZHJlc3MgPSBlIGluc3RhbmNlb2YgVW5leHBlY3RlZEFkZHJlc3NFcnJvcjtcbiAgaWYgKHdhbGxldEFkZHJlc3NOb3RGb3VuZCB8fCB1bmV4cGVjdGVkQWRkcmVzcykge1xuICAgIGlmICh1bmV4cGVjdGVkQWRkcmVzcyAmJiAhd2FsbGV0QWRkcmVzc05vdEZvdW5kKSB7XG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhpcyBpcyBhIG1pZ3JhdGVkIHYxIGJjaCBhZGRyZXNzIC0gaXQgY291bGQgYmUgaW50ZXJuYWxcbiAgICAgIGNvbnN0IGlzTWlncmF0ZWQgPSBpc01pZ3JhdGVkQWRkcmVzcyh3YWxsZXQsIGN1cnJlbnRBZGRyZXNzKTtcbiAgICAgIGlmIChpc01pZ3JhdGVkKSB7XG4gICAgICAgIHJldHVybiB7IGV4dGVybmFsOiBjb25zaWRlck1pZ3JhdGVkRnJvbUFkZHJlc3NJbnRlcm5hbCA9PT0gZmFsc2UgfTtcbiAgICAgIH1cblxuICAgICAgZGVidWcoJ0FkZHJlc3MgJXMgd2FzIGZvdW5kIG9uIHdhbGxldCBidXQgY291bGQgbm90IGJlIHJlY29uc3RydWN0ZWQnLCBjdXJyZW50QWRkcmVzcyk7XG5cbiAgICAgIC8vIGF0dGVtcHQgdG8gdmVyaWZ5IGFkZHJlc3MgdXNpbmcgY3VzdG9tIGNoYW5nZSBhZGRyZXNzIGtleXMgaWYgdGhlIHdhbGxldCBoYXMgdGhhdCBmZWF0dXJlIGVuYWJsZWRcbiAgICAgIGlmIChcbiAgICAgICAgY3VzdG9tQ2hhbmdlS2V5cyAmJlxuICAgICAgICAoYXdhaXQgdmVyaWZ5Q3VzdG9tQ2hhbmdlQWRkcmVzcyh7IGNvaW4sIGFkZHJlc3NEZXRhaWxzLCBhZGRyZXNzVHlwZSwgY3VycmVudEFkZHJlc3MsIGN1c3RvbUNoYW5nZUtleXMgfSkpXG4gICAgICApIHtcbiAgICAgICAgLy8gYWRkcmVzcyBpcyB2YWxpZCBhZ2FpbnN0IHRoZSBjdXN0b20gY2hhbmdlIGtleXMuIE1hcmsgYWRkcmVzcyBhcyBub3QgZXh0ZXJuYWxcbiAgICAgICAgLy8gYW5kIHJlcXVlc3Qgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmb3IgdGhlIGN1c3RvbSBjaGFuZ2Uga2V5c1xuICAgICAgICBkZWJ1ZygnQWRkcmVzcyAlcyB2ZXJpZmllZCBhcyBkZXJpdmVkIGZyb20gdGhlIGN1c3RvbSBjaGFuZ2Uga2V5cycsIGN1cnJlbnRBZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHsgZXh0ZXJuYWw6IGZhbHNlLCBuZWVkc0N1c3RvbUNoYW5nZUtleVNpZ25hdHVyZVZlcmlmaWNhdGlvbjogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRoZSBhZGRyZXNzIHdhcyBmb3VuZCwgYnV0IG5vdCBvbiB0aGUgd2FsbGV0LCB3aGljaCBzaW1wbHkgbWVhbnMgaXQncyBleHRlcm5hbFxuICAgIGRlYnVnKCdBZGRyZXNzICVzIHByZXN1bWVkIGV4dGVybmFsJywgY3VycmVudEFkZHJlc3MpO1xuICAgIHJldHVybiB7IGV4dGVybmFsOiB0cnVlIH07XG4gIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIEludmFsaWRBZGRyZXNzRGVyaXZhdGlvblByb3BlcnR5RXJyb3IgJiYgY3VycmVudEFkZHJlc3MgPT09IHR4UGFyYW1zLmNoYW5nZUFkZHJlc3MpIHtcbiAgICAvLyBleHBlY3QgdG8gc2VlIHRoaXMgZXJyb3Igd2hlbiBwYXNzaW5nIGluIGEgY3VzdG9tIGNoYW5nZUFkZHJlc3Mgd2l0aCBubyBjaGFpbiBvciBpbmRleFxuICAgIHJldHVybiB7IGV4dGVybmFsOiBmYWxzZSB9O1xuICB9XG5cbiAgY29uc29sZS5lcnJvcignQWRkcmVzcyBjbGFzc2lmaWNhdGlvbiBmYWlsZWQgZm9yIGFkZHJlc3MnLCBjdXJyZW50QWRkcmVzcyk7XG4gIGNvbnNvbGUudHJhY2UoZSk7XG4gIC8qKlxuICAgKiBJdCBtaWdodCBiZSBhIGNvbXBsZXRlbHkgaW52YWxpZCBhZGRyZXNzIG9yIGEgYmFkIHZhbGlkYXRpb24gYXR0ZW1wdCBvciBzb21ldGhpbmcgZWxzZSBjb21wbGV0ZWx5LCBpblxuICAgKiB3aGljaCBjYXNlIHdlIGRvIG5vdCBwcm9jZWVkIGFuZCByYXRoZXIgcmV0aHJvdyB0aGUgZXJyb3IsIHdoaWNoIGlzIHNhZmVyIHRoYW4gYXNzdW1pbmcgdGhhdCB0aGUgYWRkcmVzc1xuICAgKiB2YWxpZGF0aW9uIGZhaWxlZCBzaW1wbHkgYmVjYXVzZSBpdCdzIGV4dGVybmFsIHRvIHRoZSB3YWxsZXQuXG4gICAqL1xuICB0aHJvdyBlO1xufVxuXG5pbnRlcmZhY2UgRmV0Y2hBZGRyZXNzRGV0YWlsc09wdGlvbnMge1xuICByZXFJZD86IElSZXF1ZXN0VHJhY2VyO1xuICBkaXNhYmxlTmV0d29ya2luZzogYm9vbGVhbjtcbiAgYWRkcmVzc0RldGFpbHNQcmVidWlsZDogYW55O1xuICBhZGRyZXNzRGV0YWlsc1ZlcmlmaWNhdGlvbjogYW55O1xuICBjdXJyZW50QWRkcmVzczogc3RyaW5nO1xuICB3YWxsZXQ6IElXYWxsZXQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQWRkcmVzc0RldGFpbHMoe1xuICByZXFJZCxcbiAgZGlzYWJsZU5ldHdvcmtpbmcsXG4gIGFkZHJlc3NEZXRhaWxzUHJlYnVpbGQsXG4gIGFkZHJlc3NEZXRhaWxzVmVyaWZpY2F0aW9uLFxuICBjdXJyZW50QWRkcmVzcyxcbiAgd2FsbGV0LFxufTogRmV0Y2hBZGRyZXNzRGV0YWlsc09wdGlvbnMpIHtcbiAgbGV0IGFkZHJlc3NEZXRhaWxzID0gXy5leHRlbmQoe30sIGFkZHJlc3NEZXRhaWxzUHJlYnVpbGQsIGFkZHJlc3NEZXRhaWxzVmVyaWZpY2F0aW9uKTtcbiAgZGVidWcoJ0xvY2FsbHkgYXZhaWxhYmxlIGFkZHJlc3MgJXMgZGV0YWlsczogJU8nLCBjdXJyZW50QWRkcmVzcywgYWRkcmVzc0RldGFpbHMpO1xuICBpZiAoXy5pc0VtcHR5KGFkZHJlc3NEZXRhaWxzKSAmJiAhZGlzYWJsZU5ldHdvcmtpbmcpIHtcbiAgICBhZGRyZXNzRGV0YWlscyA9IGF3YWl0IHdhbGxldC5nZXRBZGRyZXNzKHsgYWRkcmVzczogY3VycmVudEFkZHJlc3MsIHJlcUlkIH0pO1xuICAgIGRlYnVnKCdEb3dubG9hZGVkIGFkZHJlc3MgJXMgZGV0YWlsczogJU8nLCBjdXJyZW50QWRkcmVzcywgYWRkcmVzc0RldGFpbHMpO1xuICB9XG4gIHJldHVybiBhZGRyZXNzRGV0YWlscztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDdXN0b21DaGFuZ2VPcHRpb25zIHtcbiAga2V5czogW0tleWNoYWluLCBLZXljaGFpbiwgS2V5Y2hhaW5dO1xuICBzaWduYXR1cmVzOiBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZ107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VPdXRwdXRPcHRpb25zIHtcbiAgY3VycmVudE91dHB1dDogT3V0cHV0O1xuICBjb2luOiBBYnN0cmFjdFV0eG9Db2luO1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICB2ZXJpZmljYXRpb246IFZlcmlmaWNhdGlvbk9wdGlvbnM7XG4gIGtleWNoYWluQXJyYXk6IFtLZXljaGFpbiwgS2V5Y2hhaW4sIEtleWNoYWluXTtcbiAgd2FsbGV0OiBJV2FsbGV0O1xuICB0eFBhcmFtczogVHJhbnNhY3Rpb25QYXJhbXM7XG4gIGN1c3RvbUNoYW5nZT86IEN1c3RvbUNoYW5nZU9wdGlvbnM7XG4gIHJlcUlkPzogSVJlcXVlc3RUcmFjZXI7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZU91dHB1dCh7XG4gIGN1cnJlbnRPdXRwdXQsXG4gIGNvaW4sXG4gIHR4UHJlYnVpbGQsXG4gIHZlcmlmaWNhdGlvbixcbiAga2V5Y2hhaW5BcnJheSxcbiAgd2FsbGV0LFxuICB0eFBhcmFtcyxcbiAgY3VzdG9tQ2hhbmdlLFxuICByZXFJZCxcbn06IFBhcnNlT3V0cHV0T3B0aW9ucyk6IFByb21pc2U8T3V0cHV0PiB7XG4gIGNvbnN0IGRpc2FibGVOZXR3b3JraW5nID0gISF2ZXJpZmljYXRpb24uZGlzYWJsZU5ldHdvcmtpbmc7XG4gIGNvbnN0IGN1cnJlbnRBZGRyZXNzID0gY3VycmVudE91dHB1dC5hZGRyZXNzO1xuXG4gIC8vIGF0dGVtcHQgdG8gZ3JhYiB0aGUgYWRkcmVzcyBkZXRhaWxzIGZyb20gZWl0aGVyIHRoZSBwcmVidWlsdCB0eCwgb3IgdGhlIHZlcmlmaWNhdGlvbiBwYXJhbXMuXG4gIC8vIElmIGJvdGggb2YgdGhlc2UgYXJlIGVtcHR5LCB0aGVuIHdlIHdpbGwgdHJ5IHRvIGdldCB0aGUgYWRkcmVzcyBkZXRhaWxzIGZyb20gYml0Z28gaW5zdGVhZFxuICBjb25zdCBhZGRyZXNzRGV0YWlsc1ByZWJ1aWxkID0gXy5nZXQodHhQcmVidWlsZCwgYHR4SW5mby53YWxsZXRBZGRyZXNzRGV0YWlscy4ke2N1cnJlbnRBZGRyZXNzfWAsIHt9KTtcbiAgY29uc3QgYWRkcmVzc0RldGFpbHNWZXJpZmljYXRpb246IEFkZHJlc3NWZXJpZmljYXRpb25EYXRhID0gdmVyaWZpY2F0aW9uPy5hZGRyZXNzZXM/LltjdXJyZW50QWRkcmVzc10gPz8ge307XG4gIGRlYnVnKCdQYXJzaW5nIGFkZHJlc3MgZGV0YWlscyBmb3IgJXMnLCBjdXJyZW50QWRkcmVzcyk7XG4gIGxldCBjdXJyZW50QWRkcmVzc0RldGFpbHMgPSB1bmRlZmluZWQ7XG4gIGxldCBjdXJyZW50QWRkcmVzc1R5cGU6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgY29uc3QgUkVDSVBJRU5UX1RIUkVTSE9MRCA9IDEwMDA7XG4gIHRyeSB7XG4gICAgLyoqXG4gICAgICogVGhlIG9ubHkgd2F5IHRvIGRldGVybWluZSB3aGV0aGVyIGFuIGFkZHJlc3MgaXMga25vd24gb24gdGhlIHdhbGxldCBpcyB0byBpbml0aWF0ZSBhIG5ldHdvcmsgcmVxdWVzdCBhbmRcbiAgICAgKiBmZXRjaCBpdC4gU2hvdWxkIHRoZSByZXF1ZXN0IGZhaWwgYW5kIHJldHVybiBhIDQwNCwgaXQgd2lsbCB0aHJvdyBhbmQgdGhlcmVmb3JlIGhhcyB0byBiZSBjYXVnaHQuIEZvciB0aGF0XG4gICAgICogcmVhc29uLCBhZGRyZXNzIHdhbGxldCBvd25lcnNoaXAgZGV0ZWN0aW9uIGlzIHdyYXBwZWQgaW4gYSB0cnkvY2F0Y2guIEFkZGl0aW9uYWxseSwgb25jZSB0aGUgYWRkcmVzc1xuICAgICAqIGRldGFpbHMgYXJlIGZldGNoZWQgb24gdGhlIHdhbGxldCwgYSBsb2NhbCBhZGRyZXNzIHZhbGlkYXRpb24gaXMgcnVuLCB3aG9zZSBlcnJvcnMgaG93ZXZlciBhcmUgZ2VuZXJhdGVkXG4gICAgICogY2xpZW50LXNpZGUgYW5kIGNhbiB0aGVyZWZvcmUgYmUgYW5hbHl6ZWQgd2l0aCBtb3JlIGdyYW51bGFyaXR5IGFuZCB0eXBlIGNoZWNraW5nLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogSW4gb3JkZXIgdG8gbWluaW1pemUgQVBJIHJlcXVlc3RzLCB3ZSBhc3N1bWUgdGhhdCBleHBsaWNpdCByZWNpcGllbnRzIGFyZSBhbHdheXMgZXh0ZXJuYWwgd2hlbiB0aGVcbiAgICAgKiByZWNpcGllbnQgbGlzdCBpcyA+IDEwMDAgVGhpcyBpcyBub3QgYWx3YXlzIGEgdmFsaWQgYXNzdW1wdGlvbiBhbmQgY291bGQgbGVhZCBncmVhdGVyIGFwcGFyZW50IHNwZW5kIChidXQgbmV2ZXIgbG93ZXIpXG4gICAgICovXG4gICAgaWYgKHR4UGFyYW1zLnJlY2lwaWVudHMgIT09IHVuZGVmaW5lZCAmJiB0eFBhcmFtcy5yZWNpcGllbnRzLmxlbmd0aCA+IFJFQ0lQSUVOVF9USFJFU0hPTEQpIHtcbiAgICAgIGNvbnN0IGlzQ3VycmVudEFkZHJlc3NJblJlY2lwaWVudHMgPSB0eFBhcmFtcy5yZWNpcGllbnRzLnNvbWUoKHJlY2lwaWVudCkgPT5cbiAgICAgICAgcmVjaXBpZW50LmFkZHJlc3MuaW5jbHVkZXMoY3VycmVudEFkZHJlc3MpXG4gICAgICApO1xuXG4gICAgICBpZiAoaXNDdXJyZW50QWRkcmVzc0luUmVjaXBpZW50cykge1xuICAgICAgICByZXR1cm4geyAuLi5jdXJyZW50T3V0cHV0LCBleHRlcm5hbDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFkZHJlc3NEZXRhaWxzID0gYXdhaXQgZmV0Y2hBZGRyZXNzRGV0YWlscyh7XG4gICAgICByZXFJZCxcbiAgICAgIGFkZHJlc3NEZXRhaWxzVmVyaWZpY2F0aW9uLFxuICAgICAgYWRkcmVzc0RldGFpbHNQcmVidWlsZCxcbiAgICAgIGN1cnJlbnRBZGRyZXNzLFxuICAgICAgZGlzYWJsZU5ldHdvcmtpbmcsXG4gICAgICB3YWxsZXQsXG4gICAgfSk7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhlIGFkZHJlc3MgaXMgb24gdGhlIHdhbGxldC4gdmVyaWZ5QWRkcmVzcyB0aHJvd3MgaWZcbiAgICAvLyBpdCBmYWlscyB0byBjb3JyZWN0bHkgcmVkZXJpdmUgdGhlIGFkZHJlc3MsIG1lYW5pbmcgaXQncyBleHRlcm5hbFxuICAgIGN1cnJlbnRBZGRyZXNzVHlwZSA9IEFic3RyYWN0VXR4b0NvaW4uaW5mZXJBZGRyZXNzVHlwZShhZGRyZXNzRGV0YWlscykgfHwgdW5kZWZpbmVkO1xuICAgIGN1cnJlbnRBZGRyZXNzRGV0YWlscyA9IGFkZHJlc3NEZXRhaWxzO1xuICAgIGF3YWl0IGNvaW4udmVyaWZ5QWRkcmVzcyhcbiAgICAgIF8uZXh0ZW5kKHsgYWRkcmVzc1R5cGU6IGN1cnJlbnRBZGRyZXNzVHlwZSB9LCBhZGRyZXNzRGV0YWlscywge1xuICAgICAgICBrZXljaGFpbnM6IGtleWNoYWluQXJyYXksXG4gICAgICAgIGFkZHJlc3M6IGN1cnJlbnRBZGRyZXNzLFxuICAgICAgfSlcbiAgICApO1xuICAgIGRlYnVnKCdBZGRyZXNzICVzIHZlcmlmaWNhdGlvbiBwYXNzZWQnLCBjdXJyZW50QWRkcmVzcyk7XG5cbiAgICAvLyB2ZXJpZnkgYWRkcmVzcyBzdWNjZWVkZWQgd2l0aG91dCB0aHJvd2luZywgc28gdGhlIGFkZHJlc3Mgd2FzXG4gICAgLy8gY29ycmVjdGx5IHJlZGVyaXZlZCBmcm9tIHRoZSB3YWxsZXQga2V5Y2hhaW5zLCBtYWtpbmcgaXQgbm90IGV4dGVybmFsXG4gICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBjdXJyZW50T3V0cHV0LCBhZGRyZXNzRGV0YWlscywgeyBleHRlcm5hbDogZmFsc2UgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZygnQWRkcmVzcyAlcyB2ZXJpZmljYXRpb24gdGhyZXcgYW4gZXJyb3I6JywgY3VycmVudEFkZHJlc3MsIGUpO1xuICAgIHJldHVybiBfLmV4dGVuZChcbiAgICAgIHt9LFxuICAgICAgY3VycmVudE91dHB1dCxcbiAgICAgIGF3YWl0IGhhbmRsZVZlcmlmeUFkZHJlc3NFcnJvcih7XG4gICAgICAgIGUsXG4gICAgICAgIGNvaW4sXG4gICAgICAgIGN1cnJlbnRBZGRyZXNzLFxuICAgICAgICB3YWxsZXQsXG4gICAgICAgIHR4UGFyYW1zLFxuICAgICAgICBjdXN0b21DaGFuZ2VLZXlzOiBjdXN0b21DaGFuZ2UgJiYgY3VzdG9tQ2hhbmdlLmtleXMsXG4gICAgICAgIGFkZHJlc3NEZXRhaWxzOiBjdXJyZW50QWRkcmVzc0RldGFpbHMsXG4gICAgICAgIGFkZHJlc3NUeXBlOiBjdXJyZW50QWRkcmVzc1R5cGUsXG4gICAgICAgIGNvbnNpZGVyTWlncmF0ZWRGcm9tQWRkcmVzc0ludGVybmFsOiB2ZXJpZmljYXRpb24uY29uc2lkZXJNaWdyYXRlZEZyb21BZGRyZXNzSW50ZXJuYWwsXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiJdfQ==