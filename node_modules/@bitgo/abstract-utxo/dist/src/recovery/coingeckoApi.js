"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoingeckoApi = void 0;
/**
 * @prettier
 */
const baseApi_1 = require("./baseApi");
const familyNamesToCoinGeckoIds = new Map()
    .set('BTC', 'bitcoin')
    .set('LTC', 'litecoin')
    .set('BCH', 'bitcoin-cash')
    .set('ZEC', 'zcash')
    .set('DASH', 'dash')
    // note: we don't have a source for price data of BCHA and BSV, but we will use BCH as a proxy. We will substitute
    // it out for a better source when it becomes available.  TODO BG-26359.
    .set('BCHA', 'bitcoin-cash')
    .set('BSV', 'bitcoin-cash');
class CoingeckoApi extends baseApi_1.BaseApi {
    constructor() {
        super('https://api.coingecko.com/api/v3');
    }
    async getUSDPrice(coinFamily) {
        const coinGeckoId = familyNamesToCoinGeckoIds.get(coinFamily.toUpperCase());
        if (!coinGeckoId) {
            throw new Error(`There is no CoinGecko id for family name ${coinFamily.toUpperCase()}.`);
        }
        const coinGeckoUrl = `/simple/price?ids=${coinGeckoId}&vs_currencies=USD`;
        const res = await this.get(coinGeckoUrl, { retry: 2 });
        return res.map((body) => {
            // An example of response
            // {
            //   "ethereum": {
            //     "usd": 220.64
            //   }
            // }
            if (!body) {
                throw new Error('Unable to reach Coin Gecko API for price data');
            }
            if (!body[coinGeckoId]['usd'] || typeof body[coinGeckoId]['usd'] !== 'number') {
                throw new Error('Unexpected response from Coin Gecko API for price data');
            }
            return body[coinGeckoId]['usd'];
        });
    }
}
exports.CoingeckoApi = CoingeckoApi;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29pbmdlY2tvQXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3JlY292ZXJ5L2NvaW5nZWNrb0FwaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7R0FFRztBQUNILHVDQUFvQztBQUVwQyxNQUFNLHlCQUF5QixHQUFHLElBQUksR0FBRyxFQUFFO0tBQ3hDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDO0tBQ3JCLEdBQUcsQ0FBQyxLQUFLLEVBQUUsVUFBVSxDQUFDO0tBQ3RCLEdBQUcsQ0FBQyxLQUFLLEVBQUUsY0FBYyxDQUFDO0tBQzFCLEdBQUcsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDO0tBQ25CLEdBQUcsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO0lBQ3BCLGtIQUFrSDtJQUNsSCx3RUFBd0U7S0FDdkUsR0FBRyxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUM7S0FDM0IsR0FBRyxDQUFDLEtBQUssRUFBRSxjQUFjLENBQUMsQ0FBQztBQUU5QixNQUFhLFlBQWEsU0FBUSxpQkFBTztJQUN2QztRQUNFLEtBQUssQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFRCxLQUFLLENBQUMsV0FBVyxDQUFDLFVBQWtCO1FBQ2xDLE1BQU0sV0FBVyxHQUFHLHlCQUF5QixDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztRQUM1RSxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsNENBQTRDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUM7U0FDMUY7UUFDRCxNQUFNLFlBQVksR0FBRyxxQkFBcUIsV0FBVyxvQkFBb0IsQ0FBQztRQUMxRSxNQUFNLEdBQUcsR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQU0sWUFBWSxFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDNUQsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDdEIseUJBQXlCO1lBQ3pCLElBQUk7WUFDSixrQkFBa0I7WUFDbEIsb0JBQW9CO1lBQ3BCLE1BQU07WUFDTixJQUFJO1lBQ0osSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDVCxNQUFNLElBQUksS0FBSyxDQUFDLCtDQUErQyxDQUFDLENBQUM7YUFDbEU7WUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLFFBQVEsRUFBRTtnQkFDN0UsTUFBTSxJQUFJLEtBQUssQ0FBQyx3REFBd0QsQ0FBQyxDQUFDO2FBQzNFO1lBRUQsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbEMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0NBQ0Y7QUE3QkQsb0NBNkJDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0IHsgQmFzZUFwaSB9IGZyb20gJy4vYmFzZUFwaSc7XG5cbmNvbnN0IGZhbWlseU5hbWVzVG9Db2luR2Vja29JZHMgPSBuZXcgTWFwKClcbiAgLnNldCgnQlRDJywgJ2JpdGNvaW4nKVxuICAuc2V0KCdMVEMnLCAnbGl0ZWNvaW4nKVxuICAuc2V0KCdCQ0gnLCAnYml0Y29pbi1jYXNoJylcbiAgLnNldCgnWkVDJywgJ3pjYXNoJylcbiAgLnNldCgnREFTSCcsICdkYXNoJylcbiAgLy8gbm90ZTogd2UgZG9uJ3QgaGF2ZSBhIHNvdXJjZSBmb3IgcHJpY2UgZGF0YSBvZiBCQ0hBIGFuZCBCU1YsIGJ1dCB3ZSB3aWxsIHVzZSBCQ0ggYXMgYSBwcm94eS4gV2Ugd2lsbCBzdWJzdGl0dXRlXG4gIC8vIGl0IG91dCBmb3IgYSBiZXR0ZXIgc291cmNlIHdoZW4gaXQgYmVjb21lcyBhdmFpbGFibGUuICBUT0RPIEJHLTI2MzU5LlxuICAuc2V0KCdCQ0hBJywgJ2JpdGNvaW4tY2FzaCcpXG4gIC5zZXQoJ0JTVicsICdiaXRjb2luLWNhc2gnKTtcblxuZXhwb3J0IGNsYXNzIENvaW5nZWNrb0FwaSBleHRlbmRzIEJhc2VBcGkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignaHR0cHM6Ly9hcGkuY29pbmdlY2tvLmNvbS9hcGkvdjMnKTtcbiAgfVxuXG4gIGFzeW5jIGdldFVTRFByaWNlKGNvaW5GYW1pbHk6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgY29pbkdlY2tvSWQgPSBmYW1pbHlOYW1lc1RvQ29pbkdlY2tvSWRzLmdldChjb2luRmFtaWx5LnRvVXBwZXJDYXNlKCkpO1xuICAgIGlmICghY29pbkdlY2tvSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgbm8gQ29pbkdlY2tvIGlkIGZvciBmYW1pbHkgbmFtZSAke2NvaW5GYW1pbHkudG9VcHBlckNhc2UoKX0uYCk7XG4gICAgfVxuICAgIGNvbnN0IGNvaW5HZWNrb1VybCA9IGAvc2ltcGxlL3ByaWNlP2lkcz0ke2NvaW5HZWNrb0lkfSZ2c19jdXJyZW5jaWVzPVVTRGA7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXQ8YW55Pihjb2luR2Vja29VcmwsIHsgcmV0cnk6IDIgfSk7XG4gICAgcmV0dXJuIHJlcy5tYXAoKGJvZHkpID0+IHtcbiAgICAgIC8vIEFuIGV4YW1wbGUgb2YgcmVzcG9uc2VcbiAgICAgIC8vIHtcbiAgICAgIC8vICAgXCJldGhlcmV1bVwiOiB7XG4gICAgICAvLyAgICAgXCJ1c2RcIjogMjIwLjY0XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH1cbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byByZWFjaCBDb2luIEdlY2tvIEFQSSBmb3IgcHJpY2UgZGF0YScpO1xuICAgICAgfVxuICAgICAgaWYgKCFib2R5W2NvaW5HZWNrb0lkXVsndXNkJ10gfHwgdHlwZW9mIGJvZHlbY29pbkdlY2tvSWRdWyd1c2QnXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHJlc3BvbnNlIGZyb20gQ29pbiBHZWNrbyBBUEkgZm9yIHByaWNlIGRhdGEnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJvZHlbY29pbkdlY2tvSWRdWyd1c2QnXTtcbiAgICB9KTtcbiAgfVxufVxuIl19