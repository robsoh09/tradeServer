"use strict";
/**
 * @prettier
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.v1BackupKeyRecovery = exports.backupKeyRecovery = void 0;
const assert = require("assert");
const _ = require("lodash");
const utxolib = require("@bitgo/utxo-lib");
const { getInternalChainCode, scriptTypeForChain, outputScripts, getExternalChainCode } = utxolib.bitgo;
const unspents_1 = require("@bitgo/unspents");
const sdk_core_1 = require("@bitgo/sdk-core");
const RecoveryProvider_1 = require("./RecoveryProvider");
const mempoolApi_1 = require("./mempoolApi");
const coingeckoApi_1 = require("./coingeckoApi");
const sign_1 = require("../sign");
const utxo_lib_1 = require("@bitgo/utxo-lib");
/**
 * This transforms the txInfo from recover into the format that offline-signing-tool expects
 * @param coinName
 * @param txInfo
 * @param txHex
 * @returns {{txHex: *, txInfo: {unspents: *}, feeInfo: {}, coin: void}}
 */
function formatForOfflineVault(coinName, txInfo, txHex) {
    return {
        txHex,
        txInfo: {
            unspents: txInfo.inputs.map((input) => {
                assert(input.valueString);
                return { ...input, valueString: input.valueString };
            }),
        },
        feeInfo: {},
        coin: coinName,
    };
}
/**
 * Get the current market price from a third party to be used for recovery
 * This function is only intended for non-bitgo recovery transactions, when it is necessary
 * to calculate the rough fee needed to pay to Keyternal. We are okay with approximating,
 * because the resulting price of this function only has less than 1 dollar influence on the
 * fee that needs to be paid to Keyternal.
 *
 * See calculateFeeAmount function:  return Math.round(feeAmountUsd / currentPrice * self.getBaseFactor());
 *
 * This end function should not be used as an accurate endpoint, since some coins' prices are missing from the provider
 */
async function getRecoveryMarketPrice(coin) {
    return await new coingeckoApi_1.CoingeckoApi().getUSDPrice(coin.getFamily());
}
/**
 * Calculates the amount (in base units) to pay a KRS provider when building a recovery transaction
 * @param coin
 * @param params
 * @param params.provider {String} the KRS provider that holds the backup key
 * @returns {*}
 */
async function calculateFeeAmount(coin, params) {
    const krsProvider = sdk_core_1.krsProviders[params.provider];
    if (krsProvider === undefined) {
        throw new Error(`no fee structure specified for provider ${params.provider}`);
    }
    if (krsProvider.feeType === 'flatUsd') {
        const feeAmountUsd = krsProvider.feeAmount;
        const currentPrice = await getRecoveryMarketPrice(coin);
        return Math.round((feeAmountUsd / currentPrice) * coin.getBaseFactor());
    }
    else {
        // we can add more fee structures here as needed for different providers, such as percentage of recovery amount
        throw new Error('Fee structure not implemented');
    }
}
function getFormattedAddress(coin, address) {
    // Blockchair uses cashaddr format when querying the API for address information. Convert legacy addresses to cashaddr
    // before querying the API.
    return coin.getChain() === 'bch' || coin.getChain() === 'bcha'
        ? coin.canonicalAddress(address.address, 'cashaddr').split(':')[1]
        : address.address;
}
async function queryBlockchainUnspentsPath(coin, params, walletKeys, chain) {
    var _a;
    const scriptType = scriptTypeForChain(chain);
    const fetchPrevTx = !utxolib.bitgo.outputScripts.hasWitnessData(scriptType) && (0, utxo_lib_1.getMainnet)(coin.network) !== utxo_lib_1.networks.zcash;
    const recoveryProvider = (_a = params.recoveryProvider) !== null && _a !== void 0 ? _a : (0, RecoveryProvider_1.forCoin)(coin.getChain(), params.apiKey);
    const MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS = params.scan || 20;
    let numSequentialAddressesWithoutTxs = 0;
    const prevTxCache = new Map();
    async function getPrevTx(txid) {
        let prevTxHex = prevTxCache.get(txid);
        if (!prevTxHex) {
            prevTxHex = await recoveryProvider.getTransactionHex(txid);
            prevTxCache.set(txid, prevTxHex);
        }
        return prevTxHex;
    }
    async function gatherUnspents(addrIndex) {
        const walletKeysForUnspent = walletKeys.deriveForChainAndIndex(chain, addrIndex);
        const address = coin.createMultiSigAddress(scriptType, 2, walletKeysForUnspent.publicKeys);
        const formattedAddress = getFormattedAddress(coin, address);
        const addrInfo = await recoveryProvider.getAddressInfo(formattedAddress);
        // we use txCount here because it implies usage - having tx'es means the addr was generated and used
        if (addrInfo.txCount === 0) {
            numSequentialAddressesWithoutTxs++;
        }
        else {
            numSequentialAddressesWithoutTxs = 0;
            if (addrInfo.balance > 0) {
                console.log(`Found an address with balance: ${address.address} with balance ${addrInfo.balance}`);
                const addressUnspents = await recoveryProvider.getUnspentsForAddresses([formattedAddress]);
                const processedUnspents = await Promise.all(addressUnspents.map(async (u) => {
                    const { txid, vout } = utxolib.bitgo.parseOutputId(u.id);
                    let val = BigInt(u.value);
                    if (coin.amountType === 'bigint') {
                        // blockchair returns the number with the correct precision, but in number format
                        // json parse won't parse it correctly, so we requery the txid for the tx hex to decode here
                        if (!Number.isSafeInteger(u.value)) {
                            const txHex = await getPrevTx(txid);
                            const tx = coin.createTransactionFromHex(txHex);
                            val = tx.outs[vout].value;
                        }
                    }
                    // the api may return cashaddr's instead of legacy for BCH and BCHA
                    // downstream processes's only expect legacy addresses
                    u = { ...u, address: coin.canonicalAddress(u.address) };
                    return {
                        ...u,
                        value: val,
                        chain: chain,
                        index: addrIndex,
                        prevTx: fetchPrevTx ? Buffer.from(await getPrevTx(txid), 'hex') : undefined,
                    };
                }));
                walletUnspents.push(...processedUnspents);
            }
        }
        if (numSequentialAddressesWithoutTxs >= MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS) {
            // stop searching for addresses with unspents in them, we've found ${MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS} in a row with none
            // we are done
            return;
        }
        return gatherUnspents(addrIndex + 1);
    }
    // get unspents for these addresses
    const walletUnspents = [];
    // This will populate walletAddresses
    await gatherUnspents(0);
    if (walletUnspents.length === 0) {
        // Couldn't find any addresses with funds
        return [];
    }
    return walletUnspents;
}
async function getRecoveryFeePerBytes(coin, { defaultValue }) {
    try {
        return await mempoolApi_1.MempoolApi.forCoin(coin.getChain()).getRecoveryFeePerBytes();
    }
    catch (e) {
        console.dir(e);
        return defaultValue;
    }
}
/**
 * Builds a funds recovery transaction without BitGo.
 *
 * Returns transaction hex in legacy format for unsigned sweep transaction, half signed backup recovery transaction with KRS provider (only keyternal),
 * fully signed backup recovery transaction without a KRS provider.
 *
 * Returns PSBT hex for half signed backup recovery transaction with KRS provider (excluding keyternal)
 * For PSBT hex cases, Unspents are not required in response.
 *
 * @param coin
 * @param bitgo
 * @param params
 * - userKey: [encrypted] xprv, or xpub
 * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
 * - walletPassphrase: necessary if one of the xprvs is encrypted
 * - bitgoKey: xpub
 * - krsProvider: necessary if backup key is held by KRS
 * - recoveryDestination: target address to send recovered funds to
 * - scan: the amount of consecutive addresses without unspents to scan through before stopping
 * - ignoreAddressTypes: (optional) scripts to ignore
 *        for example: ['p2shP2wsh', 'p2wsh'] will prevent code from checking for wrapped-segwit and native-segwit chains on the public block explorers
 */
async function backupKeyRecovery(coin, bitgo, params) {
    if (_.isUndefined(params.userKey)) {
        throw new Error('missing userKey');
    }
    if (_.isUndefined(params.backupKey)) {
        throw new Error('missing backupKey');
    }
    if (_.isUndefined(params.recoveryDestination) ||
        !coin.isValidAddress(params.recoveryDestination, { anyFormat: true })) {
        throw new Error('invalid recoveryDestination');
    }
    if (!_.isUndefined(params.scan) && (!_.isInteger(params.scan) || params.scan < 0)) {
        throw new Error('scan must be a positive integer');
    }
    const isKrsRecovery = (0, sdk_core_1.getIsKrsRecovery)(params);
    const isUnsignedSweep = (0, sdk_core_1.getIsUnsignedSweep)(params);
    const responseTxFormat = isUnsignedSweep || !isKrsRecovery || params.krsProvider === 'keyternal' ? 'legacy' : 'psbt';
    const krsProvider = isKrsRecovery ? (0, sdk_core_1.getKrsProvider)(coin, params.krsProvider) : undefined;
    // check whether key material and password authenticate the users and return parent keys of all three keys of the wallet
    const keys = (0, sdk_core_1.getBip32Keys)(bitgo, params, { requireBitGoXpub: true });
    if (!(0, sdk_core_1.isTriple)(keys)) {
        throw new Error(`expected key triple`);
    }
    const walletKeys = new utxolib.bitgo.RootWalletKeys(keys, [
        params.userKeyPath || utxolib.bitgo.RootWalletKeys.defaultPrefix,
        utxolib.bitgo.RootWalletKeys.defaultPrefix,
        utxolib.bitgo.RootWalletKeys.defaultPrefix,
    ]);
    const unspents = (await Promise.all(outputScripts.scriptTypes2Of3
        .filter((addressType) => { var _a; return coin.supportsAddressType(addressType) && !((_a = params.ignoreAddressTypes) === null || _a === void 0 ? void 0 : _a.includes(addressType)); })
        .reduce((queries, addressType) => [
        ...queries,
        queryBlockchainUnspentsPath(coin, params, walletKeys, getExternalChainCode(addressType)),
        queryBlockchainUnspentsPath(coin, params, walletKeys, getInternalChainCode(addressType)),
    ], []))).flat();
    // Execute the queries and gather the unspents
    const totalInputAmount = utxolib.bitgo.unspentSum(unspents, 'bigint');
    if (totalInputAmount <= BigInt(0)) {
        throw new sdk_core_1.ErrorNoInputToRecover();
    }
    // Build the psbt
    const psbt = utxolib.bitgo.createPsbtForNetwork({ network: coin.network });
    // xpubs can become handy for many things.
    utxolib.bitgo.addXpubsToPsbt(psbt, walletKeys);
    const txInfo = {};
    const feePerByte = await getRecoveryFeePerBytes(coin, { defaultValue: 100 });
    // KRS recovery transactions have a 2nd output to pay the recovery fee, like paygo fees. Use p2wsh outputs because
    // they are the largest outputs and thus the most conservative estimate to use in calculating fees. Also use
    // segwit overhead size and p2sh inputs for the same reason.
    const outputSize = (isKrsRecovery ? 2 : 1) * unspents_1.VirtualSizes.txP2wshOutputSize;
    const approximateSize = unspents_1.VirtualSizes.txSegOverheadVSize + outputSize + unspents_1.VirtualSizes.txP2shInputSize * unspents.length;
    const approximateFee = BigInt(approximateSize * feePerByte);
    txInfo.inputs =
        responseTxFormat === 'legacy'
            ? unspents.map((u) => ({ ...u, value: Number(u.value), valueString: u.value.toString(), prevTx: undefined }))
            : undefined;
    unspents.forEach((unspent) => {
        utxolib.bitgo.addWalletUnspentToPsbt(psbt, unspent, walletKeys, 'user', 'backup');
    });
    let krsFee = BigInt(0);
    if (isKrsRecovery && params.krsProvider) {
        try {
            krsFee = BigInt(await calculateFeeAmount(coin, { provider: params.krsProvider }));
        }
        catch (err) {
            // Don't let this error block the recovery -
            console.dir(err);
        }
    }
    const recoveryAmount = totalInputAmount - approximateFee - krsFee;
    if (recoveryAmount < BigInt(0)) {
        throw new Error(`this wallet\'s balance is too low to pay the fees specified by the KRS provider. 
          Existing balance on wallet: ${totalInputAmount.toString()}. Estimated network fee for the recovery transaction
          : ${approximateFee.toString()}, KRS fee to pay: ${krsFee.toString()}. After deducting fees, your total 
          recoverable balance is ${recoveryAmount.toString()}`);
    }
    const recoveryOutputScript = utxolib.address.toOutputScript(params.recoveryDestination, coin.network);
    psbt.addOutput({ script: recoveryOutputScript, value: recoveryAmount });
    if (krsProvider && krsFee > BigInt(0)) {
        if (!krsProvider.feeAddresses) {
            throw new Error(`keyProvider must define feeAddresses`);
        }
        const krsFeeAddress = krsProvider.feeAddresses[coin.getChain()];
        if (!krsFeeAddress) {
            throw new Error('this KRS provider has not configured their fee structure yet - recovery cannot be completed');
        }
        const krsFeeOutputScript = utxolib.address.toOutputScript(krsFeeAddress, coin.network);
        psbt.addOutput({ script: krsFeeOutputScript, value: krsFee });
    }
    if (isUnsignedSweep) {
        // TODO BTC-317 - When ready to PSBTify OVC, send psbt hex and skip unspents in response.
        const txHex = psbt.getUnsignedTx().toBuffer().toString('hex');
        return formatForOfflineVault(coin.getChain(), txInfo, txHex);
    }
    else {
        (0, sign_1.signAndVerifyPsbt)(psbt, walletKeys.user, { isLastSignature: false });
        if (isKrsRecovery) {
            // The KRS provider keyternal solely supports P2SH, P2WSH, and P2SH-P2WSH input script types.
            // It currently uses an outdated BitGoJS SDK, which relies on a legacy transaction builder for cosigning.
            // Unfortunately, upgrading the keyternal code presents challenges,
            // which hinders the integration of the latest BitGoJS SDK with PSBT signing support.
            txInfo.transactionHex =
                params.krsProvider === 'keyternal'
                    ? utxolib.bitgo.extractP2msOnlyHalfSignedTx(psbt).toBuffer().toString('hex')
                    : psbt.toHex();
        }
        else {
            const tx = (0, sign_1.signAndVerifyPsbt)(psbt, walletKeys.backup, { isLastSignature: true });
            txInfo.transactionHex = tx.toBuffer().toString('hex');
        }
    }
    if (isKrsRecovery) {
        txInfo.coin = coin.getChain();
        txInfo.backupKey = params.backupKey;
        txInfo.recoveryAmount = Number(recoveryAmount);
        txInfo.recoveryAmountString = recoveryAmount.toString();
    }
    return txInfo;
}
exports.backupKeyRecovery = backupKeyRecovery;
async function v1BackupKeyRecovery(coin, bitgo, params) {
    if (_.isUndefined(params.recoveryDestination) ||
        !coin.isValidAddress(params.recoveryDestination, { anyFormat: true })) {
        throw new Error('invalid recoveryDestination');
    }
    const recoveryFeePerByte = await getRecoveryFeePerBytes(coin, { defaultValue: 100 });
    const v1wallet = await bitgo.wallets().get({ id: params.walletId });
    return await v1wallet.recover({
        ...params,
        feeRate: recoveryFeePerByte,
    });
}
exports.v1BackupKeyRecovery = v1BackupKeyRecovery;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja3VwS2V5UmVjb3ZlcnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcmVjb3ZlcnkvYmFja3VwS2V5UmVjb3ZlcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOztHQUVHOzs7QUFFSCxpQ0FBaUM7QUFDakMsNEJBQTRCO0FBQzVCLDJDQUEyQztBQUMzQyxNQUFNLEVBQUUsb0JBQW9CLEVBQUUsa0JBQWtCLEVBQUUsYUFBYSxFQUFFLG9CQUFvQixFQUFFLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztBQVV4Ryw4Q0FBK0M7QUFFL0MsOENBU3lCO0FBR3pCLHlEQUErRDtBQUMvRCw2Q0FBMEM7QUFDMUMsaURBQThDO0FBQzlDLGtDQUE0QztBQUM1Qyw4Q0FBdUQ7QUFldkQ7Ozs7OztHQU1HO0FBQ0gsU0FBUyxxQkFBcUIsQ0FDNUIsUUFBZ0IsRUFDaEIsTUFBMEIsRUFDMUIsS0FBYTtJQUViLE9BQU87UUFDTCxLQUFLO1FBQ0wsTUFBTSxFQUFFO1lBQ04sUUFBUSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7Z0JBQ3BDLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBQzFCLE9BQU8sRUFBRSxHQUFHLEtBQUssRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQ3RELENBQUMsQ0FBQztTQUNIO1FBQ0QsT0FBTyxFQUFFLEVBQUU7UUFDWCxJQUFJLEVBQUUsUUFBUTtLQUNmLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7R0FVRztBQUNILEtBQUssVUFBVSxzQkFBc0IsQ0FBQyxJQUFzQjtJQUMxRCxPQUFPLE1BQU0sSUFBSSwyQkFBWSxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0FBQ2hFLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxLQUFLLFVBQVUsa0JB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QUMsY0FBYyxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUMvQyxNQUFNLENBQUMsb0JBQW9CLEdBQUcsY0FBYyxDQUFDLFFBQVEsRUFBRSxDQUFDO0tBQ3pEO0lBRUQsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQXpKRCw4Q0F5SkM7QUFpQk0sS0FBSyxVQUFVLG1CQUFtQixDQUN2QyxJQUFzQixFQUN0QixLQUFnQixFQUNoQixNQUF1QjtJQUV2QixJQUNFLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDO1FBQ3pDLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsbUJBQW1CLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFDckU7UUFDQSxNQUFNLElBQUksS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7S0FDaEQ7SUFFRCxNQUFNLGtCQUFrQixHQUFHLE1BQU0sc0JBQXNCLENBQUMsSUFBSSxFQUFFLEVBQUUsWUFBWSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDckYsTUFBTSxRQUFRLEdBQUcsTUFBTSxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQ3BFLE9BQU8sTUFBTSxRQUFRLENBQUMsT0FBTyxDQUFDO1FBQzVCLEdBQUcsTUFBTTtRQUNULE9BQU8sRUFBRSxrQkFBa0I7S0FDNUIsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQWxCRCxrREFrQkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5cbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgdXR4b2xpYiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuY29uc3QgeyBnZXRJbnRlcm5hbENoYWluQ29kZSwgc2NyaXB0VHlwZUZvckNoYWluLCBvdXRwdXRTY3JpcHRzLCBnZXRFeHRlcm5hbENoYWluQ29kZSB9ID0gdXR4b2xpYi5iaXRnbztcblxudHlwZSBDaGFpbkNvZGUgPSB1dHhvbGliLmJpdGdvLkNoYWluQ29kZTtcbnR5cGUgUm9vdFdhbGxldEtleXMgPSB1dHhvbGliLmJpdGdvLlJvb3RXYWxsZXRLZXlzO1xudHlwZSBXYWxsZXRVbnNwZW50PFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+ID0gdXR4b2xpYi5iaXRnby5XYWxsZXRVbnNwZW50PFROdW1iZXI+O1xudHlwZSBXYWxsZXRVbnNwZW50SlNPTiA9IHV0eG9saWIuYml0Z28uV2FsbGV0VW5zcGVudCAmIHtcbiAgdmFsdWVTdHJpbmc6IHN0cmluZztcbn07XG50eXBlIFNjcmlwdFR5cGUyT2YzID0gdXR4b2xpYi5iaXRnby5vdXRwdXRTY3JpcHRzLlNjcmlwdFR5cGUyT2YzO1xuXG5pbXBvcnQgeyBWaXJ0dWFsU2l6ZXMgfSBmcm9tICdAYml0Z28vdW5zcGVudHMnO1xuXG5pbXBvcnQge1xuICBCaXRHb0Jhc2UsXG4gIEVycm9yTm9JbnB1dFRvUmVjb3ZlcixcbiAgZ2V0S3JzUHJvdmlkZXIsXG4gIGdldEJpcDMyS2V5cyxcbiAgZ2V0SXNLcnNSZWNvdmVyeSxcbiAgZ2V0SXNVbnNpZ25lZFN3ZWVwLFxuICBpc1RyaXBsZSxcbiAga3JzUHJvdmlkZXJzLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgQWJzdHJhY3RVdHhvQ29pbiwgTXVsdGlTaWdBZGRyZXNzIH0gZnJvbSAnLi4vYWJzdHJhY3RVdHhvQ29pbic7XG5cbmltcG9ydCB7IGZvckNvaW4sIFJlY292ZXJ5UHJvdmlkZXIgfSBmcm9tICcuL1JlY292ZXJ5UHJvdmlkZXInO1xuaW1wb3J0IHsgTWVtcG9vbEFwaSB9IGZyb20gJy4vbWVtcG9vbEFwaSc7XG5pbXBvcnQgeyBDb2luZ2Vja29BcGkgfSBmcm9tICcuL2NvaW5nZWNrb0FwaSc7XG5pbXBvcnQgeyBzaWduQW5kVmVyaWZ5UHNidCB9IGZyb20gJy4uL3NpZ24nO1xuaW1wb3J0IHsgZ2V0TWFpbm5ldCwgbmV0d29ya3MgfSBmcm9tICdAYml0Z28vdXR4by1saWInO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9mZmxpbmVWYXVsdFR4SW5mbyB7XG4gIGlucHV0czogV2FsbGV0VW5zcGVudDxudW1iZXI+W107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9ybWF0dGVkT2ZmbGluZVZhdWx0VHhJbmZvIHtcbiAgdHhJbmZvOiB7XG4gICAgdW5zcGVudHM6IFdhbGxldFVuc3BlbnRKU09OW107XG4gIH07XG4gIHR4SGV4OiBzdHJpbmc7XG4gIGZlZUluZm86IFJlY29yZDxzdHJpbmcsIG5ldmVyPjtcbiAgY29pbjogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRoaXMgdHJhbnNmb3JtcyB0aGUgdHhJbmZvIGZyb20gcmVjb3ZlciBpbnRvIHRoZSBmb3JtYXQgdGhhdCBvZmZsaW5lLXNpZ25pbmctdG9vbCBleHBlY3RzXG4gKiBAcGFyYW0gY29pbk5hbWVcbiAqIEBwYXJhbSB0eEluZm9cbiAqIEBwYXJhbSB0eEhleFxuICogQHJldHVybnMge3t0eEhleDogKiwgdHhJbmZvOiB7dW5zcGVudHM6ICp9LCBmZWVJbmZvOiB7fSwgY29pbjogdm9pZH19XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEZvck9mZmxpbmVWYXVsdChcbiAgY29pbk5hbWU6IHN0cmluZyxcbiAgdHhJbmZvOiBPZmZsaW5lVmF1bHRUeEluZm8sXG4gIHR4SGV4OiBzdHJpbmdcbik6IEZvcm1hdHRlZE9mZmxpbmVWYXVsdFR4SW5mbyB7XG4gIHJldHVybiB7XG4gICAgdHhIZXgsXG4gICAgdHhJbmZvOiB7XG4gICAgICB1bnNwZW50czogdHhJbmZvLmlucHV0cy5tYXAoKGlucHV0KSA9PiB7XG4gICAgICAgIGFzc2VydChpbnB1dC52YWx1ZVN0cmluZyk7XG4gICAgICAgIHJldHVybiB7IC4uLmlucHV0LCB2YWx1ZVN0cmluZzogaW5wdXQudmFsdWVTdHJpbmcgfTtcbiAgICAgIH0pLFxuICAgIH0sXG4gICAgZmVlSW5mbzoge30sXG4gICAgY29pbjogY29pbk5hbWUsXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IG1hcmtldCBwcmljZSBmcm9tIGEgdGhpcmQgcGFydHkgdG8gYmUgdXNlZCBmb3IgcmVjb3ZlcnlcbiAqIFRoaXMgZnVuY3Rpb24gaXMgb25seSBpbnRlbmRlZCBmb3Igbm9uLWJpdGdvIHJlY292ZXJ5IHRyYW5zYWN0aW9ucywgd2hlbiBpdCBpcyBuZWNlc3NhcnlcbiAqIHRvIGNhbGN1bGF0ZSB0aGUgcm91Z2ggZmVlIG5lZWRlZCB0byBwYXkgdG8gS2V5dGVybmFsLiBXZSBhcmUgb2theSB3aXRoIGFwcHJveGltYXRpbmcsXG4gKiBiZWNhdXNlIHRoZSByZXN1bHRpbmcgcHJpY2Ugb2YgdGhpcyBmdW5jdGlvbiBvbmx5IGhhcyBsZXNzIHRoYW4gMSBkb2xsYXIgaW5mbHVlbmNlIG9uIHRoZVxuICogZmVlIHRoYXQgbmVlZHMgdG8gYmUgcGFpZCB0byBLZXl0ZXJuYWwuXG4gKlxuICogU2VlIGNhbGN1bGF0ZUZlZUFtb3VudCBmdW5jdGlvbjogIHJldHVybiBNYXRoLnJvdW5kKGZlZUFtb3VudFVzZCAvIGN1cnJlbnRQcmljZSAqIHNlbGYuZ2V0QmFzZUZhY3RvcigpKTtcbiAqXG4gKiBUaGlzIGVuZCBmdW5jdGlvbiBzaG91bGQgbm90IGJlIHVzZWQgYXMgYW4gYWNjdXJhdGUgZW5kcG9pbnQsIHNpbmNlIHNvbWUgY29pbnMnIHByaWNlcyBhcmUgbWlzc2luZyBmcm9tIHRoZSBwcm92aWRlclxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRSZWNvdmVyeU1hcmtldFByaWNlKGNvaW46IEFic3RyYWN0VXR4b0NvaW4pOiBQcm9taXNlPG51bWJlcj4ge1xuICByZXR1cm4gYXdhaXQgbmV3IENvaW5nZWNrb0FwaSgpLmdldFVTRFByaWNlKGNvaW4uZ2V0RmFtaWx5KCkpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFtb3VudCAoaW4gYmFzZSB1bml0cykgdG8gcGF5IGEgS1JTIHByb3ZpZGVyIHdoZW4gYnVpbGRpbmcgYSByZWNvdmVyeSB0cmFuc2FjdGlvblxuICogQHBhcmFtIGNvaW5cbiAqIEBwYXJhbSBwYXJhbXNcbiAqIEBwYXJhbSBwYXJhbXMucHJvdmlkZXIge1N0cmluZ30gdGhlIEtSUyBwcm92aWRlciB0aGF0IGhvbGRzIHRoZSBiYWNrdXAga2V5XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlRmVlQW1vdW50KGNvaW46IEFic3RyYWN0VXR4b0NvaW4sIHBhcmFtczogeyBwcm92aWRlcjogc3RyaW5nIH0pOiBQcm9taXNlPG51bWJlcj4ge1xuICBjb25zdCBrcnNQcm92aWRlciA9IGtyc1Byb3ZpZGVyc1twYXJhbXMucHJvdmlkZXJdO1xuXG4gIGlmIChrcnNQcm92aWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBubyBmZWUgc3RydWN0dXJlIHNwZWNpZmllZCBmb3IgcHJvdmlkZXIgJHtwYXJhbXMucHJvdmlkZXJ9YCk7XG4gIH1cblxuICBpZiAoa3JzUHJvdmlkZXIuZmVlVHlwZSA9PT0gJ2ZsYXRVc2QnKSB7XG4gICAgY29uc3QgZmVlQW1vdW50VXNkID0ga3JzUHJvdmlkZXIuZmVlQW1vdW50O1xuICAgIGNvbnN0IGN1cnJlbnRQcmljZTogbnVtYmVyID0gYXdhaXQgZ2V0UmVjb3ZlcnlNYXJrZXRQcmljZShjb2luKTtcblxuICAgIHJldHVybiBNYXRoLnJvdW5kKChmZWVBbW91bnRVc2QgLyBjdXJyZW50UHJpY2UpICogY29pbi5nZXRCYXNlRmFjdG9yKCkpO1xuICB9IGVsc2Uge1xuICAgIC8vIHdlIGNhbiBhZGQgbW9yZSBmZWUgc3RydWN0dXJlcyBoZXJlIGFzIG5lZWRlZCBmb3IgZGlmZmVyZW50IHByb3ZpZGVycywgc3VjaCBhcyBwZXJjZW50YWdlIG9mIHJlY292ZXJ5IGFtb3VudFxuICAgIHRocm93IG5ldyBFcnJvcignRmVlIHN0cnVjdHVyZSBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJQYXJhbXMge1xuICBzY2FuPzogbnVtYmVyO1xuICB1c2VyS2V5OiBzdHJpbmc7XG4gIGJhY2t1cEtleTogc3RyaW5nO1xuICBiaXRnb0tleTogc3RyaW5nO1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7XG4gIGtyc1Byb3ZpZGVyPzogc3RyaW5nO1xuICBpZ25vcmVBZGRyZXNzVHlwZXM6IFNjcmlwdFR5cGUyT2YzW107XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIGFwaUtleT86IHN0cmluZztcbiAgdXNlcktleVBhdGg/OiBzdHJpbmc7XG4gIHJlY292ZXJ5UHJvdmlkZXI/OiBSZWNvdmVyeVByb3ZpZGVyO1xufVxuXG5mdW5jdGlvbiBnZXRGb3JtYXR0ZWRBZGRyZXNzKGNvaW46IEFic3RyYWN0VXR4b0NvaW4sIGFkZHJlc3M6IE11bHRpU2lnQWRkcmVzcykge1xuICAvLyBCbG9ja2NoYWlyIHVzZXMgY2FzaGFkZHIgZm9ybWF0IHdoZW4gcXVlcnlpbmcgdGhlIEFQSSBmb3IgYWRkcmVzcyBpbmZvcm1hdGlvbi4gQ29udmVydCBsZWdhY3kgYWRkcmVzc2VzIHRvIGNhc2hhZGRyXG4gIC8vIGJlZm9yZSBxdWVyeWluZyB0aGUgQVBJLlxuICByZXR1cm4gY29pbi5nZXRDaGFpbigpID09PSAnYmNoJyB8fCBjb2luLmdldENoYWluKCkgPT09ICdiY2hhJ1xuICAgID8gY29pbi5jYW5vbmljYWxBZGRyZXNzKGFkZHJlc3MuYWRkcmVzcywgJ2Nhc2hhZGRyJykuc3BsaXQoJzonKVsxXVxuICAgIDogYWRkcmVzcy5hZGRyZXNzO1xufVxuXG5hc3luYyBmdW5jdGlvbiBxdWVyeUJsb2NrY2hhaW5VbnNwZW50c1BhdGgoXG4gIGNvaW46IEFic3RyYWN0VXR4b0NvaW4sXG4gIHBhcmFtczogUmVjb3ZlclBhcmFtcyxcbiAgd2FsbGV0S2V5czogUm9vdFdhbGxldEtleXMsXG4gIGNoYWluOiBDaGFpbkNvZGVcbik6IFByb21pc2U8V2FsbGV0VW5zcGVudDxiaWdpbnQ+W10+IHtcbiAgY29uc3Qgc2NyaXB0VHlwZSA9IHNjcmlwdFR5cGVGb3JDaGFpbihjaGFpbik7XG4gIGNvbnN0IGZldGNoUHJldlR4ID1cbiAgICAhdXR4b2xpYi5iaXRnby5vdXRwdXRTY3JpcHRzLmhhc1dpdG5lc3NEYXRhKHNjcmlwdFR5cGUpICYmIGdldE1haW5uZXQoY29pbi5uZXR3b3JrKSAhPT0gbmV0d29ya3MuemNhc2g7XG4gIGNvbnN0IHJlY292ZXJ5UHJvdmlkZXIgPSBwYXJhbXMucmVjb3ZlcnlQcm92aWRlciA/PyBmb3JDb2luKGNvaW4uZ2V0Q2hhaW4oKSwgcGFyYW1zLmFwaUtleSk7XG4gIGNvbnN0IE1BWF9TRVFVRU5USUFMX0FERFJFU1NFU19XSVRIT1VUX1RYUyA9IHBhcmFtcy5zY2FuIHx8IDIwO1xuICBsZXQgbnVtU2VxdWVudGlhbEFkZHJlc3Nlc1dpdGhvdXRUeHMgPSAwO1xuICBjb25zdCBwcmV2VHhDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG5cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0UHJldlR4KHR4aWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgbGV0IHByZXZUeEhleCA9IHByZXZUeENhY2hlLmdldCh0eGlkKTtcbiAgICBpZiAoIXByZXZUeEhleCkge1xuICAgICAgcHJldlR4SGV4ID0gYXdhaXQgcmVjb3ZlcnlQcm92aWRlci5nZXRUcmFuc2FjdGlvbkhleCh0eGlkKTtcbiAgICAgIHByZXZUeENhY2hlLnNldCh0eGlkLCBwcmV2VHhIZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcHJldlR4SGV4O1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gZ2F0aGVyVW5zcGVudHMoYWRkckluZGV4OiBudW1iZXIpIHtcbiAgICBjb25zdCB3YWxsZXRLZXlzRm9yVW5zcGVudCA9IHdhbGxldEtleXMuZGVyaXZlRm9yQ2hhaW5BbmRJbmRleChjaGFpbiwgYWRkckluZGV4KTtcbiAgICBjb25zdCBhZGRyZXNzID0gY29pbi5jcmVhdGVNdWx0aVNpZ0FkZHJlc3Moc2NyaXB0VHlwZSwgMiwgd2FsbGV0S2V5c0ZvclVuc3BlbnQucHVibGljS2V5cyk7XG5cbiAgICBjb25zdCBmb3JtYXR0ZWRBZGRyZXNzID0gZ2V0Rm9ybWF0dGVkQWRkcmVzcyhjb2luLCBhZGRyZXNzKTtcbiAgICBjb25zdCBhZGRySW5mbyA9IGF3YWl0IHJlY292ZXJ5UHJvdmlkZXIuZ2V0QWRkcmVzc0luZm8oZm9ybWF0dGVkQWRkcmVzcyk7XG4gICAgLy8gd2UgdXNlIHR4Q291bnQgaGVyZSBiZWNhdXNlIGl0IGltcGxpZXMgdXNhZ2UgLSBoYXZpbmcgdHgnZXMgbWVhbnMgdGhlIGFkZHIgd2FzIGdlbmVyYXRlZCBhbmQgdXNlZFxuICAgIGlmIChhZGRySW5mby50eENvdW50ID09PSAwKSB7XG4gICAgICBudW1TZXF1ZW50aWFsQWRkcmVzc2VzV2l0aG91dFR4cysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1TZXF1ZW50aWFsQWRkcmVzc2VzV2l0aG91dFR4cyA9IDA7XG5cbiAgICAgIGlmIChhZGRySW5mby5iYWxhbmNlID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgYW4gYWRkcmVzcyB3aXRoIGJhbGFuY2U6ICR7YWRkcmVzcy5hZGRyZXNzfSB3aXRoIGJhbGFuY2UgJHthZGRySW5mby5iYWxhbmNlfWApO1xuICAgICAgICBjb25zdCBhZGRyZXNzVW5zcGVudHMgPSBhd2FpdCByZWNvdmVyeVByb3ZpZGVyLmdldFVuc3BlbnRzRm9yQWRkcmVzc2VzKFtmb3JtYXR0ZWRBZGRyZXNzXSk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZFVuc3BlbnRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgYWRkcmVzc1Vuc3BlbnRzLm1hcChhc3luYyAodSk6IFByb21pc2U8V2FsbGV0VW5zcGVudDxiaWdpbnQ+PiA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHR4aWQsIHZvdXQgfSA9IHV0eG9saWIuYml0Z28ucGFyc2VPdXRwdXRJZCh1LmlkKTtcbiAgICAgICAgICAgIGxldCB2YWwgPSBCaWdJbnQodS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY29pbi5hbW91bnRUeXBlID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAvLyBibG9ja2NoYWlyIHJldHVybnMgdGhlIG51bWJlciB3aXRoIHRoZSBjb3JyZWN0IHByZWNpc2lvbiwgYnV0IGluIG51bWJlciBmb3JtYXRcbiAgICAgICAgICAgICAgLy8ganNvbiBwYXJzZSB3b24ndCBwYXJzZSBpdCBjb3JyZWN0bHksIHNvIHdlIHJlcXVlcnkgdGhlIHR4aWQgZm9yIHRoZSB0eCBoZXggdG8gZGVjb2RlIGhlcmVcbiAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih1LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4SGV4ID0gYXdhaXQgZ2V0UHJldlR4KHR4aWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gY29pbi5jcmVhdGVUcmFuc2FjdGlvbkZyb21IZXg8YmlnaW50Pih0eEhleCk7XG4gICAgICAgICAgICAgICAgdmFsID0gdHgub3V0c1t2b3V0XS52YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlIGFwaSBtYXkgcmV0dXJuIGNhc2hhZGRyJ3MgaW5zdGVhZCBvZiBsZWdhY3kgZm9yIEJDSCBhbmQgQkNIQVxuICAgICAgICAgICAgLy8gZG93bnN0cmVhbSBwcm9jZXNzZXMncyBvbmx5IGV4cGVjdCBsZWdhY3kgYWRkcmVzc2VzXG4gICAgICAgICAgICB1ID0geyAuLi51LCBhZGRyZXNzOiBjb2luLmNhbm9uaWNhbEFkZHJlc3ModS5hZGRyZXNzKSB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4udSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgICBpbmRleDogYWRkckluZGV4LFxuICAgICAgICAgICAgICBwcmV2VHg6IGZldGNoUHJldlR4ID8gQnVmZmVyLmZyb20oYXdhaXQgZ2V0UHJldlR4KHR4aWQpLCAnaGV4JykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9IGFzIFdhbGxldFVuc3BlbnQ8YmlnaW50PjtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIHdhbGxldFVuc3BlbnRzLnB1c2goLi4ucHJvY2Vzc2VkVW5zcGVudHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChudW1TZXF1ZW50aWFsQWRkcmVzc2VzV2l0aG91dFR4cyA+PSBNQVhfU0VRVUVOVElBTF9BRERSRVNTRVNfV0lUSE9VVF9UWFMpIHtcbiAgICAgIC8vIHN0b3Agc2VhcmNoaW5nIGZvciBhZGRyZXNzZXMgd2l0aCB1bnNwZW50cyBpbiB0aGVtLCB3ZSd2ZSBmb3VuZCAke01BWF9TRVFVRU5USUFMX0FERFJFU1NFU19XSVRIT1VUX1RYU30gaW4gYSByb3cgd2l0aCBub25lXG4gICAgICAvLyB3ZSBhcmUgZG9uZVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBnYXRoZXJVbnNwZW50cyhhZGRySW5kZXggKyAxKTtcbiAgfVxuXG4gIC8vIGdldCB1bnNwZW50cyBmb3IgdGhlc2UgYWRkcmVzc2VzXG5cbiAgY29uc3Qgd2FsbGV0VW5zcGVudHM6IFdhbGxldFVuc3BlbnQ8YmlnaW50PltdID0gW107XG4gIC8vIFRoaXMgd2lsbCBwb3B1bGF0ZSB3YWxsZXRBZGRyZXNzZXNcbiAgYXdhaXQgZ2F0aGVyVW5zcGVudHMoMCk7XG5cbiAgaWYgKHdhbGxldFVuc3BlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIENvdWxkbid0IGZpbmQgYW55IGFkZHJlc3NlcyB3aXRoIGZ1bmRzXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIHdhbGxldFVuc3BlbnRzO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRSZWNvdmVyeUZlZVBlckJ5dGVzKFxuICBjb2luOiBBYnN0cmFjdFV0eG9Db2luLFxuICB7IGRlZmF1bHRWYWx1ZSB9OiB7IGRlZmF1bHRWYWx1ZTogbnVtYmVyIH1cbik6IFByb21pc2U8bnVtYmVyPiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IE1lbXBvb2xBcGkuZm9yQ29pbihjb2luLmdldENoYWluKCkpLmdldFJlY292ZXJ5RmVlUGVyQnl0ZXMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZGlyKGUpO1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQmFja3VwS2V5UmVjb3ZlcnlUcmFuc2Fuc2FjdGlvbiA9IHtcbiAgaW5wdXRzPzogV2FsbGV0VW5zcGVudDxudW1iZXI+W107XG4gIHRyYW5zYWN0aW9uSGV4OiBzdHJpbmc7XG4gIGNvaW46IHN0cmluZztcbiAgYmFja3VwS2V5OiBzdHJpbmc7XG4gIHJlY292ZXJ5QW1vdW50OiBudW1iZXI7XG4gIHJlY292ZXJ5QW1vdW50U3RyaW5nOiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R28uXG4gKlxuICogUmV0dXJucyB0cmFuc2FjdGlvbiBoZXggaW4gbGVnYWN5IGZvcm1hdCBmb3IgdW5zaWduZWQgc3dlZXAgdHJhbnNhY3Rpb24sIGhhbGYgc2lnbmVkIGJhY2t1cCByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRoIEtSUyBwcm92aWRlciAob25seSBrZXl0ZXJuYWwpLFxuICogZnVsbHkgc2lnbmVkIGJhY2t1cCByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRob3V0IGEgS1JTIHByb3ZpZGVyLlxuICpcbiAqIFJldHVybnMgUFNCVCBoZXggZm9yIGhhbGYgc2lnbmVkIGJhY2t1cCByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRoIEtSUyBwcm92aWRlciAoZXhjbHVkaW5nIGtleXRlcm5hbClcbiAqIEZvciBQU0JUIGhleCBjYXNlcywgVW5zcGVudHMgYXJlIG5vdCByZXF1aXJlZCBpbiByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0gY29pblxuICogQHBhcmFtIGJpdGdvXG4gKiBAcGFyYW0gcGFyYW1zXG4gKiAtIHVzZXJLZXk6IFtlbmNyeXB0ZWRdIHhwcnYsIG9yIHhwdWJcbiAqIC0gYmFja3VwS2V5OiBbZW5jcnlwdGVkXSB4cHJ2LCBvciB4cHViIGlmIHRoZSB4cHJ2IGlzIGhlbGQgYnkgYSBLUlMgcHJvdmlkZXJcbiAqIC0gd2FsbGV0UGFzc3BocmFzZTogbmVjZXNzYXJ5IGlmIG9uZSBvZiB0aGUgeHBydnMgaXMgZW5jcnlwdGVkXG4gKiAtIGJpdGdvS2V5OiB4cHViXG4gKiAtIGtyc1Byb3ZpZGVyOiBuZWNlc3NhcnkgaWYgYmFja3VwIGtleSBpcyBoZWxkIGJ5IEtSU1xuICogLSByZWNvdmVyeURlc3RpbmF0aW9uOiB0YXJnZXQgYWRkcmVzcyB0byBzZW5kIHJlY292ZXJlZCBmdW5kcyB0b1xuICogLSBzY2FuOiB0aGUgYW1vdW50IG9mIGNvbnNlY3V0aXZlIGFkZHJlc3NlcyB3aXRob3V0IHVuc3BlbnRzIHRvIHNjYW4gdGhyb3VnaCBiZWZvcmUgc3RvcHBpbmdcbiAqIC0gaWdub3JlQWRkcmVzc1R5cGVzOiAob3B0aW9uYWwpIHNjcmlwdHMgdG8gaWdub3JlXG4gKiAgICAgICAgZm9yIGV4YW1wbGU6IFsncDJzaFAyd3NoJywgJ3Ayd3NoJ10gd2lsbCBwcmV2ZW50IGNvZGUgZnJvbSBjaGVja2luZyBmb3Igd3JhcHBlZC1zZWd3aXQgYW5kIG5hdGl2ZS1zZWd3aXQgY2hhaW5zIG9uIHRoZSBwdWJsaWMgYmxvY2sgZXhwbG9yZXJzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBiYWNrdXBLZXlSZWNvdmVyeShcbiAgY29pbjogQWJzdHJhY3RVdHhvQ29pbixcbiAgYml0Z286IEJpdEdvQmFzZSxcbiAgcGFyYW1zOiBSZWNvdmVyUGFyYW1zXG4pOiBQcm9taXNlPEJhY2t1cEtleVJlY292ZXJ5VHJhbnNhbnNhY3Rpb24gfCBGb3JtYXR0ZWRPZmZsaW5lVmF1bHRUeEluZm8+IHtcbiAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnVzZXJLZXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHVzZXJLZXknKTtcbiAgfVxuXG4gIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5iYWNrdXBLZXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGJhY2t1cEtleScpO1xuICB9XG5cbiAgaWYgKFxuICAgIF8uaXNVbmRlZmluZWQocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pIHx8XG4gICAgIWNvaW4uaXNWYWxpZEFkZHJlc3MocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24sIHsgYW55Rm9ybWF0OiB0cnVlIH0pXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZWNvdmVyeURlc3RpbmF0aW9uJyk7XG4gIH1cblxuICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLnNjYW4pICYmICghXy5pc0ludGVnZXIocGFyYW1zLnNjYW4pIHx8IHBhcmFtcy5zY2FuIDwgMCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjYW4gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgfVxuXG4gIGNvbnN0IGlzS3JzUmVjb3ZlcnkgPSBnZXRJc0tyc1JlY292ZXJ5KHBhcmFtcyk7XG4gIGNvbnN0IGlzVW5zaWduZWRTd2VlcCA9IGdldElzVW5zaWduZWRTd2VlcChwYXJhbXMpO1xuICBjb25zdCByZXNwb25zZVR4Rm9ybWF0ID0gaXNVbnNpZ25lZFN3ZWVwIHx8ICFpc0tyc1JlY292ZXJ5IHx8IHBhcmFtcy5rcnNQcm92aWRlciA9PT0gJ2tleXRlcm5hbCcgPyAnbGVnYWN5JyA6ICdwc2J0JztcblxuICBjb25zdCBrcnNQcm92aWRlciA9IGlzS3JzUmVjb3ZlcnkgPyBnZXRLcnNQcm92aWRlcihjb2luLCBwYXJhbXMua3JzUHJvdmlkZXIpIDogdW5kZWZpbmVkO1xuXG4gIC8vIGNoZWNrIHdoZXRoZXIga2V5IG1hdGVyaWFsIGFuZCBwYXNzd29yZCBhdXRoZW50aWNhdGUgdGhlIHVzZXJzIGFuZCByZXR1cm4gcGFyZW50IGtleXMgb2YgYWxsIHRocmVlIGtleXMgb2YgdGhlIHdhbGxldFxuICBjb25zdCBrZXlzID0gZ2V0QmlwMzJLZXlzKGJpdGdvLCBwYXJhbXMsIHsgcmVxdWlyZUJpdEdvWHB1YjogdHJ1ZSB9KTtcbiAgaWYgKCFpc1RyaXBsZShrZXlzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQga2V5IHRyaXBsZWApO1xuICB9XG4gIGNvbnN0IHdhbGxldEtleXMgPSBuZXcgdXR4b2xpYi5iaXRnby5Sb290V2FsbGV0S2V5cyhrZXlzLCBbXG4gICAgcGFyYW1zLnVzZXJLZXlQYXRoIHx8IHV0eG9saWIuYml0Z28uUm9vdFdhbGxldEtleXMuZGVmYXVsdFByZWZpeCxcbiAgICB1dHhvbGliLmJpdGdvLlJvb3RXYWxsZXRLZXlzLmRlZmF1bHRQcmVmaXgsXG4gICAgdXR4b2xpYi5iaXRnby5Sb290V2FsbGV0S2V5cy5kZWZhdWx0UHJlZml4LFxuICBdKTtcblxuICBjb25zdCB1bnNwZW50czogV2FsbGV0VW5zcGVudDxiaWdpbnQ+W10gPSAoXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBvdXRwdXRTY3JpcHRzLnNjcmlwdFR5cGVzMk9mM1xuICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgIChhZGRyZXNzVHlwZSkgPT4gY29pbi5zdXBwb3J0c0FkZHJlc3NUeXBlKGFkZHJlc3NUeXBlKSAmJiAhcGFyYW1zLmlnbm9yZUFkZHJlc3NUeXBlcz8uaW5jbHVkZXMoYWRkcmVzc1R5cGUpXG4gICAgICAgIClcbiAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAocXVlcmllcywgYWRkcmVzc1R5cGUpID0+IFtcbiAgICAgICAgICAgIC4uLnF1ZXJpZXMsXG4gICAgICAgICAgICBxdWVyeUJsb2NrY2hhaW5VbnNwZW50c1BhdGgoY29pbiwgcGFyYW1zLCB3YWxsZXRLZXlzLCBnZXRFeHRlcm5hbENoYWluQ29kZShhZGRyZXNzVHlwZSkpLFxuICAgICAgICAgICAgcXVlcnlCbG9ja2NoYWluVW5zcGVudHNQYXRoKGNvaW4sIHBhcmFtcywgd2FsbGV0S2V5cywgZ2V0SW50ZXJuYWxDaGFpbkNvZGUoYWRkcmVzc1R5cGUpKSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFtdIGFzIFByb21pc2U8V2FsbGV0VW5zcGVudDxiaWdpbnQ+W10+W11cbiAgICAgICAgKVxuICAgIClcbiAgKS5mbGF0KCk7XG5cbiAgLy8gRXhlY3V0ZSB0aGUgcXVlcmllcyBhbmQgZ2F0aGVyIHRoZSB1bnNwZW50c1xuICBjb25zdCB0b3RhbElucHV0QW1vdW50ID0gdXR4b2xpYi5iaXRnby51bnNwZW50U3VtKHVuc3BlbnRzLCAnYmlnaW50Jyk7XG4gIGlmICh0b3RhbElucHV0QW1vdW50IDw9IEJpZ0ludCgwKSkge1xuICAgIHRocm93IG5ldyBFcnJvck5vSW5wdXRUb1JlY292ZXIoKTtcbiAgfVxuXG4gIC8vIEJ1aWxkIHRoZSBwc2J0XG4gIGNvbnN0IHBzYnQgPSB1dHhvbGliLmJpdGdvLmNyZWF0ZVBzYnRGb3JOZXR3b3JrKHsgbmV0d29yazogY29pbi5uZXR3b3JrIH0pO1xuICAvLyB4cHVicyBjYW4gYmVjb21lIGhhbmR5IGZvciBtYW55IHRoaW5ncy5cbiAgdXR4b2xpYi5iaXRnby5hZGRYcHVic1RvUHNidChwc2J0LCB3YWxsZXRLZXlzKTtcbiAgY29uc3QgdHhJbmZvID0ge30gYXMgQmFja3VwS2V5UmVjb3ZlcnlUcmFuc2Fuc2FjdGlvbjtcbiAgY29uc3QgZmVlUGVyQnl0ZTogbnVtYmVyID0gYXdhaXQgZ2V0UmVjb3ZlcnlGZWVQZXJCeXRlcyhjb2luLCB7IGRlZmF1bHRWYWx1ZTogMTAwIH0pO1xuXG4gIC8vIEtSUyByZWNvdmVyeSB0cmFuc2FjdGlvbnMgaGF2ZSBhIDJuZCBvdXRwdXQgdG8gcGF5IHRoZSByZWNvdmVyeSBmZWUsIGxpa2UgcGF5Z28gZmVlcy4gVXNlIHAyd3NoIG91dHB1dHMgYmVjYXVzZVxuICAvLyB0aGV5IGFyZSB0aGUgbGFyZ2VzdCBvdXRwdXRzIGFuZCB0aHVzIHRoZSBtb3N0IGNvbnNlcnZhdGl2ZSBlc3RpbWF0ZSB0byB1c2UgaW4gY2FsY3VsYXRpbmcgZmVlcy4gQWxzbyB1c2VcbiAgLy8gc2Vnd2l0IG92ZXJoZWFkIHNpemUgYW5kIHAyc2ggaW5wdXRzIGZvciB0aGUgc2FtZSByZWFzb24uXG4gIGNvbnN0IG91dHB1dFNpemUgPSAoaXNLcnNSZWNvdmVyeSA/IDIgOiAxKSAqIFZpcnR1YWxTaXplcy50eFAyd3NoT3V0cHV0U2l6ZTtcbiAgY29uc3QgYXBwcm94aW1hdGVTaXplID0gVmlydHVhbFNpemVzLnR4U2VnT3ZlcmhlYWRWU2l6ZSArIG91dHB1dFNpemUgKyBWaXJ0dWFsU2l6ZXMudHhQMnNoSW5wdXRTaXplICogdW5zcGVudHMubGVuZ3RoO1xuICBjb25zdCBhcHByb3hpbWF0ZUZlZSA9IEJpZ0ludChhcHByb3hpbWF0ZVNpemUgKiBmZWVQZXJCeXRlKTtcblxuICB0eEluZm8uaW5wdXRzID1cbiAgICByZXNwb25zZVR4Rm9ybWF0ID09PSAnbGVnYWN5J1xuICAgICAgPyB1bnNwZW50cy5tYXAoKHUpID0+ICh7IC4uLnUsIHZhbHVlOiBOdW1iZXIodS52YWx1ZSksIHZhbHVlU3RyaW5nOiB1LnZhbHVlLnRvU3RyaW5nKCksIHByZXZUeDogdW5kZWZpbmVkIH0pKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgdW5zcGVudHMuZm9yRWFjaCgodW5zcGVudCkgPT4ge1xuICAgIHV0eG9saWIuYml0Z28uYWRkV2FsbGV0VW5zcGVudFRvUHNidChwc2J0LCB1bnNwZW50LCB3YWxsZXRLZXlzLCAndXNlcicsICdiYWNrdXAnKTtcbiAgfSk7XG5cbiAgbGV0IGtyc0ZlZSA9IEJpZ0ludCgwKTtcbiAgaWYgKGlzS3JzUmVjb3ZlcnkgJiYgcGFyYW1zLmtyc1Byb3ZpZGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGtyc0ZlZSA9IEJpZ0ludChhd2FpdCBjYWxjdWxhdGVGZWVBbW91bnQoY29pbiwgeyBwcm92aWRlcjogcGFyYW1zLmtyc1Byb3ZpZGVyIH0pKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIERvbid0IGxldCB0aGlzIGVycm9yIGJsb2NrIHRoZSByZWNvdmVyeSAtXG4gICAgICBjb25zb2xlLmRpcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlY292ZXJ5QW1vdW50ID0gdG90YWxJbnB1dEFtb3VudCAtIGFwcHJveGltYXRlRmVlIC0ga3JzRmVlO1xuXG4gIGlmIChyZWNvdmVyeUFtb3VudCA8IEJpZ0ludCgwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgdGhpcyB3YWxsZXRcXCdzIGJhbGFuY2UgaXMgdG9vIGxvdyB0byBwYXkgdGhlIGZlZXMgc3BlY2lmaWVkIGJ5IHRoZSBLUlMgcHJvdmlkZXIuIFxuICAgICAgICAgIEV4aXN0aW5nIGJhbGFuY2Ugb24gd2FsbGV0OiAke3RvdGFsSW5wdXRBbW91bnQudG9TdHJpbmcoKX0uIEVzdGltYXRlZCBuZXR3b3JrIGZlZSBmb3IgdGhlIHJlY292ZXJ5IHRyYW5zYWN0aW9uXG4gICAgICAgICAgOiAke2FwcHJveGltYXRlRmVlLnRvU3RyaW5nKCl9LCBLUlMgZmVlIHRvIHBheTogJHtrcnNGZWUudG9TdHJpbmcoKX0uIEFmdGVyIGRlZHVjdGluZyBmZWVzLCB5b3VyIHRvdGFsIFxuICAgICAgICAgIHJlY292ZXJhYmxlIGJhbGFuY2UgaXMgJHtyZWNvdmVyeUFtb3VudC50b1N0cmluZygpfWApO1xuICB9XG5cbiAgY29uc3QgcmVjb3ZlcnlPdXRwdXRTY3JpcHQgPSB1dHhvbGliLmFkZHJlc3MudG9PdXRwdXRTY3JpcHQocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24sIGNvaW4ubmV0d29yayk7XG4gIHBzYnQuYWRkT3V0cHV0KHsgc2NyaXB0OiByZWNvdmVyeU91dHB1dFNjcmlwdCwgdmFsdWU6IHJlY292ZXJ5QW1vdW50IH0pO1xuXG4gIGlmIChrcnNQcm92aWRlciAmJiBrcnNGZWUgPiBCaWdJbnQoMCkpIHtcbiAgICBpZiAoIWtyc1Byb3ZpZGVyLmZlZUFkZHJlc3Nlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBrZXlQcm92aWRlciBtdXN0IGRlZmluZSBmZWVBZGRyZXNzZXNgKTtcbiAgICB9XG5cbiAgICBjb25zdCBrcnNGZWVBZGRyZXNzID0ga3JzUHJvdmlkZXIuZmVlQWRkcmVzc2VzW2NvaW4uZ2V0Q2hhaW4oKV07XG5cbiAgICBpZiAoIWtyc0ZlZUFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhpcyBLUlMgcHJvdmlkZXIgaGFzIG5vdCBjb25maWd1cmVkIHRoZWlyIGZlZSBzdHJ1Y3R1cmUgeWV0IC0gcmVjb3ZlcnkgY2Fubm90IGJlIGNvbXBsZXRlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGtyc0ZlZU91dHB1dFNjcmlwdCA9IHV0eG9saWIuYWRkcmVzcy50b091dHB1dFNjcmlwdChrcnNGZWVBZGRyZXNzLCBjb2luLm5ldHdvcmspO1xuICAgIHBzYnQuYWRkT3V0cHV0KHsgc2NyaXB0OiBrcnNGZWVPdXRwdXRTY3JpcHQsIHZhbHVlOiBrcnNGZWUgfSk7XG4gIH1cblxuICBpZiAoaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgLy8gVE9ETyBCVEMtMzE3IC0gV2hlbiByZWFkeSB0byBQU0JUaWZ5IE9WQywgc2VuZCBwc2J0IGhleCBhbmQgc2tpcCB1bnNwZW50cyBpbiByZXNwb25zZS5cbiAgICBjb25zdCB0eEhleCA9IHBzYnQuZ2V0VW5zaWduZWRUeCgpLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIHJldHVybiBmb3JtYXRGb3JPZmZsaW5lVmF1bHQoY29pbi5nZXRDaGFpbigpLCB0eEluZm8gYXMgT2ZmbGluZVZhdWx0VHhJbmZvLCB0eEhleCk7XG4gIH0gZWxzZSB7XG4gICAgc2lnbkFuZFZlcmlmeVBzYnQocHNidCwgd2FsbGV0S2V5cy51c2VyLCB7IGlzTGFzdFNpZ25hdHVyZTogZmFsc2UgfSk7XG4gICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgIC8vIFRoZSBLUlMgcHJvdmlkZXIga2V5dGVybmFsIHNvbGVseSBzdXBwb3J0cyBQMlNILCBQMldTSCwgYW5kIFAyU0gtUDJXU0ggaW5wdXQgc2NyaXB0IHR5cGVzLlxuICAgICAgLy8gSXQgY3VycmVudGx5IHVzZXMgYW4gb3V0ZGF0ZWQgQml0R29KUyBTREssIHdoaWNoIHJlbGllcyBvbiBhIGxlZ2FjeSB0cmFuc2FjdGlvbiBidWlsZGVyIGZvciBjb3NpZ25pbmcuXG4gICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB1cGdyYWRpbmcgdGhlIGtleXRlcm5hbCBjb2RlIHByZXNlbnRzIGNoYWxsZW5nZXMsXG4gICAgICAvLyB3aGljaCBoaW5kZXJzIHRoZSBpbnRlZ3JhdGlvbiBvZiB0aGUgbGF0ZXN0IEJpdEdvSlMgU0RLIHdpdGggUFNCVCBzaWduaW5nIHN1cHBvcnQuXG4gICAgICB0eEluZm8udHJhbnNhY3Rpb25IZXggPVxuICAgICAgICBwYXJhbXMua3JzUHJvdmlkZXIgPT09ICdrZXl0ZXJuYWwnXG4gICAgICAgICAgPyB1dHhvbGliLmJpdGdvLmV4dHJhY3RQMm1zT25seUhhbGZTaWduZWRUeChwc2J0KS50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgICAgIDogcHNidC50b0hleCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eCA9IHNpZ25BbmRWZXJpZnlQc2J0KHBzYnQsIHdhbGxldEtleXMuYmFja3VwLCB7IGlzTGFzdFNpZ25hdHVyZTogdHJ1ZSB9KTtcbiAgICAgIHR4SW5mby50cmFuc2FjdGlvbkhleCA9IHR4LnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgdHhJbmZvLmNvaW4gPSBjb2luLmdldENoYWluKCk7XG4gICAgdHhJbmZvLmJhY2t1cEtleSA9IHBhcmFtcy5iYWNrdXBLZXk7XG4gICAgdHhJbmZvLnJlY292ZXJ5QW1vdW50ID0gTnVtYmVyKHJlY292ZXJ5QW1vdW50KTtcbiAgICB0eEluZm8ucmVjb3ZlcnlBbW91bnRTdHJpbmcgPSByZWNvdmVyeUFtb3VudC50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHR4SW5mbztcbn1cblxuaW50ZXJmYWNlIEJpdEdvVjFVbnNwZW50IHtcbiAgdmFsdWU6IG51bWJlcjtcbiAgdHhfaGFzaDogc3RyaW5nO1xuICB0eF9vdXRwdXRfbjogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFYxUmVjb3ZlclBhcmFtcyB7XG4gIHdhbGxldElkOiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U6IHN0cmluZztcbiAgdW5zcGVudHM6IEJpdEdvVjFVbnNwZW50W107XG4gIHJlY292ZXJ5RGVzdGluYXRpb246IHN0cmluZztcbiAgdXNlcktleTogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHYxQmFja3VwS2V5UmVjb3ZlcnkoXG4gIGNvaW46IEFic3RyYWN0VXR4b0NvaW4sXG4gIGJpdGdvOiBCaXRHb0Jhc2UsXG4gIHBhcmFtczogVjFSZWNvdmVyUGFyYW1zXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBpZiAoXG4gICAgXy5pc1VuZGVmaW5lZChwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikgfHxcbiAgICAhY29pbi5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbiwgeyBhbnlGb3JtYXQ6IHRydWUgfSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlY292ZXJ5RGVzdGluYXRpb24nKTtcbiAgfVxuXG4gIGNvbnN0IHJlY292ZXJ5RmVlUGVyQnl0ZSA9IGF3YWl0IGdldFJlY292ZXJ5RmVlUGVyQnl0ZXMoY29pbiwgeyBkZWZhdWx0VmFsdWU6IDEwMCB9KTtcbiAgY29uc3QgdjF3YWxsZXQgPSBhd2FpdCBiaXRnby53YWxsZXRzKCkuZ2V0KHsgaWQ6IHBhcmFtcy53YWxsZXRJZCB9KTtcbiAgcmV0dXJuIGF3YWl0IHYxd2FsbGV0LnJlY292ZXIoe1xuICAgIC4uLnBhcmFtcyxcbiAgICBmZWVSYXRlOiByZWNvdmVyeUZlZVBlckJ5dGUsXG4gIH0pO1xufVxuIl19