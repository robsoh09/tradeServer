"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractUtxoCoin = exports.AbstractUtxoCoinWallet = void 0;
/**
 * @prettier
 */
const utxolib = require("@bitgo/utxo-lib");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const assert = require("assert");
const bitcoinMessage = require("bitcoinjs-message");
const crypto_1 = require("crypto");
const debugLib = require("debug");
const _ = require("lodash");
const bignumber_js_1 = require("bignumber.js");
const recovery_1 = require("./recovery");
const sdk_core_1 = require("@bitgo/sdk-core");
const parseOutput_1 = require("./parseOutput");
const debug = debugLib('bitgo:v2:utxo');
const replayProtection_1 = require("./replayProtection");
const sign_1 = require("./sign");
const config_1 = require("./config");
const transaction_1 = require("./transaction");
const { getExternalChainCode, isChainCode, scriptTypeForChain, outputScripts } = utxo_lib_1.bitgo;
class AbstractUtxoCoinWallet extends sdk_core_1.Wallet {
    constructor(bitgo, baseCoin, walletData) {
        super(bitgo, baseCoin, walletData);
    }
}
exports.AbstractUtxoCoinWallet = AbstractUtxoCoinWallet;
class AbstractUtxoCoin extends sdk_core_1.BaseCoin {
    constructor(bitgo, network, amountType = 'number') {
        super(bitgo);
        if (!utxolib.isValidNetwork(network)) {
            throw new Error('invalid network: please make sure to use the same version of ' +
                '@bitgo/utxo-lib as this library when initializing an instance of this class');
        }
        this.amountType = amountType;
        this._network = network;
    }
    get network() {
        return this._network;
    }
    sweepWithSendMany() {
        return true;
    }
    /** @deprecated */
    static get validAddressTypes() {
        return [...outputScripts.scriptTypes2Of3];
    }
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    getBaseFactor() {
        return 1e8;
    }
    /**
     * @deprecated
     */
    getCoinLibrary() {
        return utxolib;
    }
    /**
     * Check if an address is valid
     * @param address
     * @param param
     */
    isValidAddress(address, param) {
        if (typeof param === 'boolean' && param) {
            throw new Error('deprecated');
        }
        const formats = param && param.anyFormat ? undefined : ['default'];
        try {
            const script = utxolib.addressFormat.toOutputScriptTryFormats(address, this.network, formats);
            return address === utxolib.address.fromOutputScript(script, this.network);
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub) {
        try {
            return utxo_lib_1.bip32.fromBase58(pub).isNeutered();
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Get the latest block height
     * @param reqId
     */
    async getLatestBlockHeight(reqId) {
        if (reqId) {
            this.bitgo.setRequestTracer(reqId);
        }
        const chainhead = await this.bitgo.get(this.url('/public/block/latest')).result();
        return chainhead.height;
    }
    /**
     * Run custom coin logic after a transaction prebuild has been received from BitGo
     * @param prebuild
     */
    async postProcessPrebuild(prebuild) {
        if (_.isUndefined(prebuild.txHex)) {
            throw new Error('missing required txPrebuild property txHex');
        }
        const tx = utxo_lib_1.bitgo.isPsbt(prebuild.txHex)
            ? utxo_lib_1.bitgo.createPsbtFromHex(prebuild.txHex, this.network)
            : this.createTransactionFromHex(prebuild.txHex);
        if (_.isUndefined(prebuild.blockHeight)) {
            prebuild.blockHeight = (await this.getLatestBlockHeight());
        }
        return _.extend({}, prebuild, { txHex: tx.toHex() });
    }
    /**
     * @param first
     * @param second
     * @returns {Array} All outputs that are in the first array but not in the second
     */
    static outputDifference(first, second) {
        const keyFunc = ({ address, amount }) => `${address}:${amount}`;
        const groupedOutputs = _.groupBy(first, keyFunc);
        second.forEach((output) => {
            const group = groupedOutputs[keyFunc(output)];
            if (group) {
                group.pop();
            }
        });
        return _.flatten(_.values(groupedOutputs));
    }
    /**
     * Determine an address' type based on its witness and redeem script presence
     * @param addressDetails
     */
    static inferAddressType(addressDetails) {
        return isChainCode(addressDetails.chain) ? scriptTypeForChain(addressDetails.chain) : null;
    }
    createTransactionFromHex(hex) {
        return utxolib.bitgo.createTransactionFromHex(hex, this.network, this.amountType);
    }
    /**
     * Extract and fill transaction details such as internal/change spend, external spend (explicit vs. implicit), etc.
     * @param params
     * @returns {*}
     */
    async parseTransaction(params) {
        const { txParams, txPrebuild, wallet, verification = {}, reqId } = params;
        if (!_.isUndefined(verification.disableNetworking) && !_.isBoolean(verification.disableNetworking)) {
            throw new Error('verification.disableNetworking must be a boolean');
        }
        const disableNetworking = verification.disableNetworking;
        const fetchKeychains = async (wallet) => {
            return (0, sdk_core_1.promiseProps)({
                user: this.keychains().get({ id: wallet.keyIds()[sdk_core_1.KeyIndices.USER], reqId }),
                backup: this.keychains().get({ id: wallet.keyIds()[sdk_core_1.KeyIndices.BACKUP], reqId }),
                bitgo: this.keychains().get({ id: wallet.keyIds()[sdk_core_1.KeyIndices.BITGO], reqId }),
            });
        };
        // obtain the keychains and key signatures
        let keychains = verification.keychains;
        if (!keychains) {
            if (disableNetworking) {
                throw new Error('cannot fetch keychains without networking');
            }
            keychains = await fetchKeychains(wallet);
        }
        if (!keychains || !keychains.user || !keychains.backup || !keychains.bitgo) {
            throw new Error('keychains are required, but could not be fetched');
        }
        const keychainArray = [keychains.user, keychains.backup, keychains.bitgo];
        const keySignatures = _.get(wallet, '_wallet.keySignatures', {});
        if (_.isUndefined(txPrebuild.txHex)) {
            throw new Error('missing required txPrebuild property txHex');
        }
        // obtain all outputs
        const explanation = await this.explainTransaction({
            txHex: txPrebuild.txHex,
            txInfo: txPrebuild.txInfo,
            pubs: keychainArray.map((k) => k.pub),
        });
        const allOutputs = [...explanation.outputs, ...explanation.changeOutputs];
        let expectedOutputs;
        if (txParams.rbfTxIds) {
            assert(txParams.rbfTxIds.length === 1);
            const txToBeReplaced = await wallet.getTransaction({ txHash: txParams.rbfTxIds[0], includeRbf: true });
            expectedOutputs = txToBeReplaced.outputs
                .filter((output) => output.wallet !== wallet.id()) // For self-sends, the walletId will be the same as the wallet's id
                .map((output) => {
                return { amount: BigInt(output.valueString), address: this.canonicalAddress(output.address) };
            });
        }
        else {
            // verify that each recipient from txParams has their own output
            expectedOutputs = _.get(txParams, 'recipients', []).map((output) => {
                return { ...output, address: this.canonicalAddress(output.address) };
            });
        }
        const missingOutputs = AbstractUtxoCoin.outputDifference(expectedOutputs, allOutputs);
        // get the keychains from the custom change wallet if needed
        let customChange;
        const { customChangeWalletId = undefined } = wallet.coinSpecific() || {};
        if (customChangeWalletId) {
            // fetch keychains from custom change wallet for deriving addresses.
            // These keychains should be signed and this should be verified in verifyTransaction
            const customChangeKeySignatures = wallet._wallet.customChangeKeySignatures;
            const customChangeWallet = await this.wallets().get({ id: customChangeWalletId });
            const customChangeKeys = await fetchKeychains(customChangeWallet);
            if (!customChangeKeys) {
                throw new Error('failed to fetch keychains for custom change wallet');
            }
            if (customChangeKeys.user && customChangeKeys.backup && customChangeKeys.bitgo && customChangeWallet) {
                const customChangeKeychains = [
                    customChangeKeys.user,
                    customChangeKeys.backup,
                    customChangeKeys.bitgo,
                ];
                customChange = {
                    keys: customChangeKeychains,
                    signatures: [
                        customChangeKeySignatures.user,
                        customChangeKeySignatures.backup,
                        customChangeKeySignatures.bitgo,
                    ],
                };
            }
        }
        /**
         * Loop through all the outputs and classify each of them as either internal spends
         * or external spends by setting the "external" property to true or false on the output object.
         */
        const allOutputDetails = await Promise.all(allOutputs.map((currentOutput) => {
            return (0, parseOutput_1.parseOutput)({
                currentOutput,
                coin: this,
                txPrebuild,
                verification,
                keychainArray,
                wallet,
                txParams,
                customChange,
                reqId,
            });
        }));
        const needsCustomChangeKeySignatureVerification = allOutputDetails.some((output) => output.needsCustomChangeKeySignatureVerification);
        const changeOutputs = _.filter(allOutputDetails, { external: false });
        // these are all the outputs that were not originally explicitly specified in recipients
        // ideally change outputs or a paygo output that might have been added
        const implicitOutputs = AbstractUtxoCoin.outputDifference(allOutputDetails, expectedOutputs);
        const explicitOutputs = AbstractUtxoCoin.outputDifference(allOutputDetails, implicitOutputs);
        // these are all the non-wallet outputs that had been originally explicitly specified in recipients
        const explicitExternalOutputs = _.filter(explicitOutputs, { external: true });
        // this is the sum of all the originally explicitly specified non-wallet output values
        const explicitExternalSpendAmount = utxolib.bitgo.toTNumber(explicitExternalOutputs.reduce((sum, o) => sum + BigInt(o.amount), BigInt(0)), this.amountType);
        /**
         * The calculation of the implicit external spend amount pertains to verifying the pay-as-you-go-fee BitGo
         * automatically applies to transactions sending money out of the wallet. The logic is fairly straightforward
         * in that we compare the external spend amount that was specified explicitly by the user to the portion
         * that was specified implicitly. To protect customers from people tampering with the transaction outputs, we
         * define a threshold for the maximum percentage of the implicit external spend in relation to the explicit
         * external spend.
         */
        // make sure that all the extra addresses are change addresses
        // get all the additional external outputs the server added and calculate their values
        const implicitExternalOutputs = _.filter(implicitOutputs, { external: true });
        const implicitExternalSpendAmount = utxolib.bitgo.toTNumber(implicitExternalOutputs.reduce((sum, o) => sum + BigInt(o.amount), BigInt(0)), this.amountType);
        return {
            keychains,
            keySignatures,
            outputs: allOutputDetails,
            missingOutputs,
            explicitExternalOutputs,
            implicitExternalOutputs,
            changeOutputs,
            explicitExternalSpendAmount,
            implicitExternalSpendAmount,
            needsCustomChangeKeySignatureVerification,
            customChange,
        };
    }
    /**
     * Decrypt the wallet's user private key and verify that the claimed public key matches
     * @param {VerifyUserPublicKeyOptions} params
     * @return {boolean}
     * @protected
     */
    verifyUserPublicKey(params) {
        const { userKeychain, txParams, disableNetworking } = params;
        if (!userKeychain) {
            throw new Error('user keychain is required');
        }
        const userPub = userKeychain.pub;
        // decrypt the user private key, so we can verify that the claimed public key is a match
        let userPrv = userKeychain.prv;
        if (!userPrv && txParams.walletPassphrase) {
            userPrv = (0, sdk_core_1.decryptKeychainPrivateKey)(this.bitgo, userKeychain, txParams.walletPassphrase);
        }
        if (!userPrv) {
            const errorMessage = 'user private key unavailable for verification';
            if (disableNetworking) {
                console.log(errorMessage);
                return false;
            }
            else {
                throw new Error(errorMessage);
            }
        }
        else {
            const userPrivateKey = utxo_lib_1.bip32.fromBase58(userPrv);
            if (userPrivateKey.toBase58() === userPrivateKey.neutered().toBase58()) {
                throw new Error('user private key is only public');
            }
            if (userPrivateKey.neutered().toBase58() !== userPub) {
                throw new Error('user private key does not match public key');
            }
        }
        return true;
    }
    /**
     * Verify signatures produced by the user key over the backup and bitgo keys.
     *
     * If set, these signatures ensure that the wallet keys cannot be changed after the wallet has been created.
     * @param {VerifyKeySignaturesOptions} params
     * @return {{backup: boolean, bitgo: boolean}}
     */
    verifyKeySignature(params) {
        // first, let's verify the integrity of the user key, whose public key is used for subsequent verifications
        const { userKeychain, keychainToVerify, keySignature } = params;
        if (!userKeychain) {
            throw new Error('user keychain is required');
        }
        if (!keychainToVerify) {
            throw new Error('keychain to verify is required');
        }
        if (!keySignature) {
            throw new Error('key signature is required');
        }
        // verify the signature against the user public key
        assert(userKeychain.pub);
        const publicKey = utxo_lib_1.bip32.fromBase58(userKeychain.pub).publicKey;
        // Due to interface of `bitcoinMessage`, we need to convert the public key to an address.
        // Note that this address has no relationship to on-chain transactions. We are
        // only interested in the address as a representation of the public key.
        const signingAddress = utxolib.address.toBase58Check(utxolib.crypto.hash160(publicKey), utxolib.networks.bitcoin.pubKeyHash, 
        // we do not pass `this.network` here because it would fail for zcash
        // the bitcoinMessage library decodes the address and throws away the first byte
        // because zcash has a two-byte prefix, verify() decodes zcash addresses to an invalid pubkey hash
        utxolib.networks.bitcoin);
        // BG-5703: use BTC mainnet prefix for all key signature operations
        // (this means do not pass a prefix parameter, and let it use the default prefix instead)
        assert(keychainToVerify.pub);
        try {
            return bitcoinMessage.verify(keychainToVerify.pub, signingAddress, Buffer.from(keySignature, 'hex'));
        }
        catch (e) {
            debug('error thrown from bitcoinmessage while verifying key signature', e);
            return false;
        }
    }
    /**
     * Verify signatures against the user private key over the change wallet extended keys
     * @param {ParsedTransaction} tx
     * @param {Keychain} userKeychain
     * @return {boolean}
     * @protected
     */
    verifyCustomChangeKeySignatures(tx, userKeychain) {
        if (!tx.customChange) {
            throw new Error('parsed transaction is missing required custom change verification data');
        }
        if (!Array.isArray(tx.customChange.keys) || !Array.isArray(tx.customChange.signatures)) {
            throw new Error('customChange property is missing keys or signatures');
        }
        for (const keyIndex of [sdk_core_1.KeyIndices.USER, sdk_core_1.KeyIndices.BACKUP, sdk_core_1.KeyIndices.BITGO]) {
            const keychainToVerify = tx.customChange.keys[keyIndex];
            const keySignature = tx.customChange.signatures[keyIndex];
            if (!keychainToVerify) {
                throw new Error(`missing required custom change ${sdk_core_1.KeyIndices[keyIndex].toLowerCase()} keychain public key`);
            }
            if (!keySignature) {
                throw new Error(`missing required custom change ${sdk_core_1.KeyIndices[keyIndex].toLowerCase()} keychain signature`);
            }
            if (!this.verifyKeySignature({
                userKeychain: userKeychain,
                keychainToVerify: keychainToVerify,
                keySignature,
            })) {
                debug('failed to verify custom change %s key signature!', sdk_core_1.KeyIndices[keyIndex].toLowerCase());
                return false;
            }
        }
        return true;
    }
    /**
     * Get the maximum percentage limit for pay-as-you-go outputs
     *
     * @protected
     */
    getPayGoLimit(allowPaygoOutput) {
        // allowing paygo outputs needs to be the default behavior, so only disallow paygo outputs if the
        // relevant verification option is both set and false
        if (!_.isNil(allowPaygoOutput) && !allowPaygoOutput) {
            return 0;
        }
        // 150 basis points is the absolute permitted maximum if paygo outputs are allowed
        return 0.015;
    }
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param params
     * @param params.txParams params object passed to send
     * @param params.txPrebuild prebuild object returned by server
     * @param params.txPrebuild.txHex prebuilt transaction's txHex form
     * @param params.wallet Wallet object to obtain keys to verify against
     * @param params.verification Object specifying some verification parameters
     * @param params.verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param params.verification.keychains Pass keychains manually rather than fetching them by id
     * @param params.verification.addresses Address details to pass in for out-of-band verification
     * @returns {boolean}
     */
    async verifyTransaction(params) {
        var _a;
        const { txParams, txPrebuild, wallet, verification = { allowPaygoOutput: true }, reqId } = params;
        const isPsbt = txPrebuild.txHex && utxo_lib_1.bitgo.isPsbt(txPrebuild.txHex);
        if (isPsbt && ((_a = txPrebuild.txInfo) === null || _a === void 0 ? void 0 : _a.unspents)) {
            throw new Error('should not have unspents in txInfo for psbt');
        }
        const disableNetworking = !!verification.disableNetworking;
        const parsedTransaction = await this.parseTransaction({
            txParams,
            txPrebuild,
            wallet,
            verification,
            reqId,
        });
        const keychains = parsedTransaction.keychains;
        // verify that the claimed user public key corresponds to the wallet's user private key
        let userPublicKeyVerified = false;
        try {
            // verify the user public key matches the private key - this will throw if there is no match
            userPublicKeyVerified = this.verifyUserPublicKey({ userKeychain: keychains.user, disableNetworking, txParams });
        }
        catch (e) {
            debug('failed to verify user public key!', e);
        }
        // let's verify these keychains
        const keySignatures = parsedTransaction.keySignatures;
        if (!_.isEmpty(keySignatures)) {
            const verify = (key, pub) => {
                if (!keychains.user || !keychains.user.pub) {
                    throw new Error('missing user keychain');
                }
                return this.verifyKeySignature({
                    userKeychain: keychains.user,
                    keychainToVerify: key,
                    keySignature: pub,
                });
            };
            const isBackupKeySignatureValid = verify(keychains.backup, keySignatures.backupPub);
            const isBitgoKeySignatureValid = verify(keychains.bitgo, keySignatures.bitgoPub);
            if (!isBackupKeySignatureValid || !isBitgoKeySignatureValid) {
                throw new Error('secondary public key signatures invalid');
            }
            debug('successfully verified backup and bitgo key signatures');
        }
        else if (!disableNetworking) {
            // these keys were obtained online and their signatures were not verified
            // this could be dangerous
            console.log('unsigned keys obtained online are being used for address verification');
        }
        if (parsedTransaction.needsCustomChangeKeySignatureVerification) {
            if (!keychains.user || !userPublicKeyVerified) {
                throw new Error('transaction requires verification of user public key, but it was unable to be verified');
            }
            const customChangeKeySignaturesVerified = this.verifyCustomChangeKeySignatures(parsedTransaction, keychains.user);
            if (!customChangeKeySignaturesVerified) {
                throw new Error('transaction requires verification of custom change key signatures, but they were unable to be verified');
            }
            debug('successfully verified user public key and custom change key signatures');
        }
        const missingOutputs = parsedTransaction.missingOutputs;
        if (missingOutputs.length !== 0) {
            // there are some outputs in the recipients list that have not made it into the actual transaction
            throw new Error('expected outputs missing in transaction prebuild');
        }
        const intendedExternalSpend = parsedTransaction.explicitExternalSpendAmount;
        // this is a limit we impose for the total value that is amended to the transaction beyond what was originally intended
        const payAsYouGoLimit = new bignumber_js_1.default(this.getPayGoLimit(verification.allowPaygoOutput)).multipliedBy(intendedExternalSpend.toString());
        /*
        Some explanation for why we're doing what we're doing:
        Some customers will have an output to BitGo's PAYGo wallet added to their transaction, and we need to account for
        it here. To protect someone tampering with the output to make it send more than it should to BitGo, we define a
        threshold for the output's value above which we'll throw an error, because the paygo output should never be that
        high.
         */
        // make sure that all the extra addresses are change addresses
        // get all the additional external outputs the server added and calculate their values
        const nonChangeAmount = new bignumber_js_1.default(parsedTransaction.implicitExternalSpendAmount.toString());
        debug('Intended spend is %s, Non-change amount is %s, paygo limit is %s', intendedExternalSpend.toString(), nonChangeAmount.toString(), payAsYouGoLimit.toString());
        // the additional external outputs can only be BitGo's pay-as-you-go fee, but we cannot verify the wallet address
        if (nonChangeAmount.gt(payAsYouGoLimit)) {
            // there are some addresses that are outside the scope of intended recipients that are not change addresses
            throw new Error('prebuild attempts to spend to unintended external recipients');
        }
        const allOutputs = parsedTransaction.outputs;
        if (!txPrebuild.txHex) {
            throw new Error(`txPrebuild.txHex not set`);
        }
        const inputs = isPsbt
            ? (0, transaction_1.getPsbtTxInputs)(txPrebuild.txHex, this.network).map((v) => ({
                ...v,
                value: utxo_lib_1.bitgo.toTNumber(v.value, this.amountType),
            }))
            : await (0, transaction_1.getTxInputs)({ txPrebuild, bitgo: this.bitgo, coin: this, disableNetworking, reqId });
        // coins (doge) that can exceed number limits (and thus will use bigint) will have the `valueString` field
        const inputAmount = inputs.reduce((sum, i) => sum + BigInt(this.amountType === 'bigint' ? i.valueString : i.value), BigInt(0));
        const outputAmount = allOutputs.reduce((sum, o) => sum + BigInt(o.amount), BigInt(0));
        const fee = inputAmount - outputAmount;
        if (fee < 0) {
            throw new Error(`attempting to spend ${outputAmount} satoshis, which exceeds the input amount (${inputAmount} satoshis) by ${-fee}`);
        }
        return true;
    }
    /**
     * Make sure an address is valid and throw an error if it's not.
     * @param params.address The address string on the network
     * @param params.addressType
     * @param params.keychains Keychain objects with xpubs
     * @param params.coinSpecific Coin-specific details for the address such as a witness script
     * @param params.chain Derivation chain
     * @param params.index Derivation index
     * @throws {InvalidAddressError}
     * @throws {InvalidAddressDerivationPropertyError}
     * @throws {UnexpectedAddressError}
     */
    async isWalletAddress(params) {
        const { address, addressType, keychains, coinSpecific, chain, index } = params;
        if (!this.isValidAddress(address)) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        if ((_.isUndefined(chain) && _.isUndefined(index)) || !(_.isFinite(chain) && _.isFinite(index))) {
            throw new sdk_core_1.InvalidAddressDerivationPropertyError(`address validation failure: invalid chain (${chain}) or index (${index})`);
        }
        if (!_.isObject(coinSpecific)) {
            throw new sdk_core_1.InvalidAddressVerificationObjectPropertyError('address validation failure: coinSpecific field must be an object');
        }
        if (!keychains) {
            throw new Error('missing required param keychains');
        }
        const expectedAddress = this.generateAddress({
            addressType: addressType,
            keychains,
            threshold: 2,
            chain,
            index,
        });
        if (expectedAddress.address !== address) {
            throw new sdk_core_1.UnexpectedAddressError(`address validation failure: expected ${expectedAddress.address} but got ${address}`);
        }
        return true;
    }
    /**
     * Indicates whether coin supports a block target
     * @returns {boolean}
     */
    supportsBlockTarget() {
        return true;
    }
    /**
     * @param addressType
     * @returns true iff coin supports spending from unspentType
     */
    supportsAddressType(addressType) {
        return utxolib.bitgo.outputScripts.isSupportedScriptType(this.network, addressType);
    }
    /**
     * @param chain
     * @return true iff coin supports spending from chain
     */
    supportsAddressChain(chain) {
        return isChainCode(chain) && this.supportsAddressType(utxolib.bitgo.scriptTypeForChain(chain));
    }
    keyIdsForSigning() {
        return [sdk_core_1.KeyIndices.USER, sdk_core_1.KeyIndices.BACKUP, sdk_core_1.KeyIndices.BITGO];
    }
    /**
     * TODO(BG-11487): Remove addressType, segwit, and bech32 params in SDKv6
     * Generate an address for a wallet based on a set of configurations
     * @param params.addressType {string}   Deprecated
     * @param params.keychains   {[object]} Array of objects with xpubs
     * @param params.threshold   {number}   Minimum number of signatures
     * @param params.chain       {number}   Derivation chain (see https://github.com/BitGo/unspents/blob/master/src/codes.ts for
     *                                                 the corresponding address type of a given chain code)
     * @param params.index       {number}   Derivation index
     * @param params.segwit      {boolean}  Deprecated
     * @param params.bech32      {boolean}  Deprecated
     * @returns {{chain: number, index: number, coin: number, coinSpecific: {outputScript, redeemScript}}}
     */
    generateAddress(params) {
        const { keychains, threshold, chain, index, segwit = false, bech32 = false } = params;
        let derivationChain = getExternalChainCode('p2sh');
        if (_.isNumber(chain) && _.isInteger(chain) && isChainCode(chain)) {
            derivationChain = chain;
        }
        function convertFlagsToAddressType() {
            if (isChainCode(chain)) {
                return utxolib.bitgo.scriptTypeForChain(chain);
            }
            if (_.isBoolean(segwit) && segwit) {
                return 'p2shP2wsh';
            }
            else if (_.isBoolean(bech32) && bech32) {
                return 'p2wsh';
            }
            else {
                return 'p2sh';
            }
        }
        const addressType = params.addressType || convertFlagsToAddressType();
        if (addressType !== utxolib.bitgo.scriptTypeForChain(derivationChain)) {
            throw new sdk_core_1.AddressTypeChainMismatchError(addressType, derivationChain);
        }
        if (!this.supportsAddressType(addressType)) {
            switch (addressType) {
                case 'p2sh':
                    throw new Error(`internal error: p2sh should always be supported`);
                case 'p2shP2wsh':
                    throw new sdk_core_1.P2shP2wshUnsupportedError();
                case 'p2wsh':
                    throw new sdk_core_1.P2wshUnsupportedError();
                case 'p2tr':
                    throw new sdk_core_1.P2trUnsupportedError();
                case 'p2trMusig2':
                    throw new sdk_core_1.P2trMusig2UnsupportedError();
                default:
                    throw new sdk_core_1.UnsupportedAddressTypeError();
            }
        }
        let signatureThreshold = 2;
        if (_.isInteger(threshold)) {
            signatureThreshold = threshold;
            if (signatureThreshold <= 0) {
                throw new Error('threshold has to be positive');
            }
            if (signatureThreshold > keychains.length) {
                throw new Error('threshold cannot exceed number of keys');
            }
        }
        let derivationIndex = 0;
        if (_.isInteger(index) && index > 0) {
            derivationIndex = index;
        }
        const path = '0/0/' + derivationChain + '/' + derivationIndex;
        const hdNodes = keychains.map(({ pub }) => utxo_lib_1.bip32.fromBase58(pub));
        const derivedKeys = hdNodes.map((hdNode) => hdNode.derivePath((0, sdk_core_1.sanitizeLegacyPath)(path)).publicKey);
        const { outputScript, redeemScript, witnessScript, address } = this.createMultiSigAddress(addressType, signatureThreshold, derivedKeys);
        return {
            address,
            chain: derivationChain,
            index: derivationIndex,
            coin: this.getChain(),
            coinSpecific: {
                outputScript: outputScript.toString('hex'),
                redeemScript: redeemScript && redeemScript.toString('hex'),
                witnessScript: witnessScript && witnessScript.toString('hex'),
            },
            addressType,
        };
    }
    /**
     * @returns input psbt added with deterministic MuSig2 nonce for bitgo key for each MuSig2 inputs.
     * @param psbtHex all MuSig2 inputs should contain user MuSig2 nonce
     * @param walletId
     */
    async signPsbt(psbtHex, walletId) {
        const params = { psbt: psbtHex };
        return await this.bitgo
            .post(this.url('/wallet/' + walletId + '/tx/signpsbt'))
            .send(params)
            .result();
    }
    /**
     * @returns input psbt added with deterministic MuSig2 nonce for bitgo key for each MuSig2 inputs from OVC.
     * @param ovcJson JSON object provided by OVC with fields psbtHex and walletId
     */
    async signPsbtFromOVC(ovcJson) {
        assert(ovcJson['psbtHex'], 'ovcJson must contain psbtHex');
        assert(ovcJson['walletId'], 'ovcJson must contain walletId');
        const psbt = (await this.signPsbt(ovcJson['psbtHex'], ovcJson['walletId'])).psbt;
        assert(psbt, 'psbt not found');
        return _.extend(ovcJson, { txHex: psbt });
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params - {@see SignTransactionOptions}
     * @returns {Promise<SignedTransaction | HalfSignedUtxoTransaction>}
     */
    async signTransaction(params) {
        var _a, _b, _c;
        const txPrebuild = params.txPrebuild;
        if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
            if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                throw new Error(`txPrebuild must be an object, got type ${typeof txPrebuild}`);
            }
            throw new Error('missing txPrebuild parameter');
        }
        let tx = utxo_lib_1.bitgo.isPsbt(txPrebuild.txHex)
            ? utxo_lib_1.bitgo.createPsbtFromHex(txPrebuild.txHex, this.network)
            : this.createTransactionFromHex(txPrebuild.txHex);
        const isTxWithKeyPathSpendInput = tx instanceof utxo_lib_1.bitgo.UtxoPsbt && utxo_lib_1.bitgo.isTransactionWithKeyPathSpendInput(tx);
        let isLastSignature = false;
        if (_.isBoolean(params.isLastSignature)) {
            // We can only be the first signature on a transaction with taproot key path spend inputs because
            // we require the secret nonce in the cache of the first signer, which is impossible to retrieve if
            // deserialized from a hex.
            if (params.isLastSignature && isTxWithKeyPathSpendInput) {
                throw new Error('Cannot be last signature on a transaction with key path spend inputs');
            }
            // if build is called instead of buildIncomplete, no signature placeholders are left in the sig script
            isLastSignature = params.isLastSignature;
        }
        const getSignerKeychain = () => {
            const userPrv = params.prv;
            if (_.isUndefined(userPrv) || !_.isString(userPrv)) {
                if (!_.isUndefined(userPrv)) {
                    throw new Error(`prv must be a string, got type ${typeof userPrv}`);
                }
                throw new Error('missing prv parameter to sign transaction');
            }
            const signerKeychain = utxo_lib_1.bip32.fromBase58(userPrv, utxolib.networks.bitcoin);
            if (signerKeychain.isNeutered()) {
                throw new Error('expected user private key but received public key');
            }
            debug(`Here is the public key of the xprv you used to sign: ${signerKeychain.neutered().toBase58()}`);
            return signerKeychain;
        };
        const setSignerMusigNonceWithOverride = (psbt, signerKeychain, nonSegwitOverride) => {
            utxolib.bitgo.withUnsafeNonSegwit(psbt, () => psbt.setAllInputsMusig2NonceHD(signerKeychain), nonSegwitOverride);
        };
        let signerKeychain;
        if (tx instanceof utxo_lib_1.bitgo.UtxoPsbt && isTxWithKeyPathSpendInput) {
            switch (params.signingStep) {
                case 'signerNonce':
                    signerKeychain = getSignerKeychain();
                    setSignerMusigNonceWithOverride(tx, signerKeychain, !!params.allowNonSegwitSigningWithoutPrevTx);
                    AbstractUtxoCoin.PSBT_CACHE.set(tx.getUnsignedTx().getId(), tx);
                    return { txHex: tx.toHex() };
                case 'cosignerNonce':
                    assert(txPrebuild.walletId, 'walletId is required for MuSig2 bitgo nonce');
                    return { txHex: (await this.signPsbt(tx.toHex(), txPrebuild.walletId)).psbt };
                case 'signerSignature':
                    const txId = tx.getUnsignedTx().getId();
                    const psbt = AbstractUtxoCoin.PSBT_CACHE.get(txId);
                    assert(psbt, `Psbt is missing from txCache (cache size ${AbstractUtxoCoin.PSBT_CACHE.size}).
            This may be due to the request being routed to a different BitGo-Express instance that for signing step 'signerNonce'.`);
                    AbstractUtxoCoin.PSBT_CACHE.delete(txId);
                    tx = psbt.combine(tx);
                    break;
                default:
                    // this instance is not an external signer
                    assert(txPrebuild.walletId, 'walletId is required for MuSig2 bitgo nonce');
                    signerKeychain = getSignerKeychain();
                    setSignerMusigNonceWithOverride(tx, signerKeychain, !!params.allowNonSegwitSigningWithoutPrevTx);
                    const response = await this.signPsbt(tx.toHex(), txPrebuild.walletId);
                    tx.combine(utxo_lib_1.bitgo.createPsbtFromHex(response.psbt, this.network));
                    break;
            }
        }
        else {
            switch (params.signingStep) {
                case 'signerNonce':
                case 'cosignerNonce':
                    /**
                     * In certain cases, the caller of this method may not know whether the txHex contains a psbt with taproot key path spend input(s).
                     * Instead of throwing error, no-op and return the txHex. So that the caller can call this method in the same sequence.
                     */
                    return { txHex: tx.toHex() };
            }
        }
        if (signerKeychain === undefined) {
            signerKeychain = getSignerKeychain();
        }
        let signedTransaction;
        if (tx instanceof utxo_lib_1.bitgo.UtxoPsbt) {
            signedTransaction = (0, sign_1.signAndVerifyPsbt)(tx, signerKeychain, {
                isLastSignature,
                allowNonSegwitSigningWithoutPrevTx: params.allowNonSegwitSigningWithoutPrevTx,
            });
        }
        else {
            if (tx.ins.length !== ((_b = (_a = txPrebuild.txInfo) === null || _a === void 0 ? void 0 : _a.unspents) === null || _b === void 0 ? void 0 : _b.length)) {
                throw new Error('length of unspents array should equal to the number of transaction inputs');
            }
            if (!params.pubs || !(0, sdk_core_1.isTriple)(params.pubs)) {
                throw new Error(`must provide xpub array`);
            }
            const keychains = params.pubs.map((pub) => utxo_lib_1.bip32.fromBase58(pub));
            const cosignerPub = (_c = params.cosignerPub) !== null && _c !== void 0 ? _c : params.pubs[2];
            const cosignerKeychain = utxo_lib_1.bip32.fromBase58(cosignerPub);
            const walletSigner = new utxo_lib_1.bitgo.WalletUnspentSigner(keychains, signerKeychain, cosignerKeychain);
            signedTransaction = (0, sign_1.signAndVerifyWalletTransaction)(tx, txPrebuild.txInfo.unspents, walletSigner, {
                isLastSignature,
            });
        }
        return {
            txHex: signedTransaction.toBuffer().toString('hex'),
        };
    }
    /**
     * Sign a transaction with a custom signing function. Example use case is express external signer
     * @param customSigningFunction custom signing function that returns a single signed transaction
     * @param signTransactionParams parameters for custom signing function. Includes txPrebuild and pubs (for legacy tx only).
     *
     * @returns signed transaction as hex string
     */
    async signWithCustomSigningFunction(customSigningFunction, signTransactionParams) {
        const txHex = signTransactionParams.txPrebuild.txHex;
        assert(txHex, 'missing txHex parameter');
        const tx = utxo_lib_1.bitgo.isPsbt(txHex)
            ? utxo_lib_1.bitgo.createPsbtFromHex(txHex, this.network)
            : this.createTransactionFromHex(txHex);
        const isTxWithKeyPathSpendInput = tx instanceof utxo_lib_1.bitgo.UtxoPsbt && utxo_lib_1.bitgo.isTransactionWithKeyPathSpendInput(tx);
        if (!isTxWithKeyPathSpendInput) {
            return await customSigningFunction({ ...signTransactionParams, coin: this });
        }
        const getTxHex = (v) => {
            if ('txHex' in v) {
                return v.txHex;
            }
            throw new Error('txHex not found in signTransaction result');
        };
        const signerNonceTx = await customSigningFunction({
            ...signTransactionParams,
            signingStep: 'signerNonce',
            coin: this,
        });
        const { pubs } = signTransactionParams;
        assert(pubs === undefined || (0, sdk_core_1.isTriple)(pubs));
        const cosignerNonceTx = await this.signTransaction({
            ...signTransactionParams,
            pubs,
            txPrebuild: { ...signTransactionParams.txPrebuild, txHex: getTxHex(signerNonceTx) },
            signingStep: 'cosignerNonce',
        });
        return await customSigningFunction({
            ...signTransactionParams,
            txPrebuild: { ...signTransactionParams.txPrebuild, txHex: getTxHex(cosignerNonceTx) },
            signingStep: 'signerSignature',
            coin: this,
        });
    }
    /**
     * @param unspent
     * @returns {boolean}
     */
    isBitGoTaintedUnspent(unspent) {
        return (0, replayProtection_1.isReplayProtectionUnspent)(unspent, this.network);
    }
    /**
     * @deprecated - use utxolib.bitgo.getDefaultSigHash(network) instead
     * @returns {number}
     */
    get defaultSigHashType() {
        return utxolib.bitgo.getDefaultSigHash(this.network);
    }
    /**
     * @deprecated - use utxolib.bitcoin.verifySignature() instead
     */
    verifySignature(transaction, inputIndex, amount, verificationSettings = {}) {
        if (transaction.network !== this.network) {
            throw new Error(`network mismatch`);
        }
        return utxolib.bitgo.verifySignature(transaction, inputIndex, amount, {
            signatureIndex: verificationSettings.signatureIndex,
            publicKey: verificationSettings.publicKey ? Buffer.from(verificationSettings.publicKey, 'hex') : undefined,
        });
    }
    /**
     * Decompose a raw psbt/transaction into useful information, such as the total amounts,
     * change amounts, and transaction outputs.
     * @param params
     */
    async explainTransaction(params) {
        const { txHex } = params;
        if (typeof txHex !== 'string' || !txHex.match(/^([a-f0-9]{2})+$/i)) {
            throw new Error('invalid transaction hex, must be a valid hex string');
        }
        return utxolib.bitgo.isPsbt(txHex) ? (0, transaction_1.explainPsbt)(params, this.network) : (0, transaction_1.explainTx)(params, this);
    }
    /**
     * Create a multisig address of a given type from a list of keychains and a signing threshold
     * @param addressType
     * @param signatureThreshold
     * @param keys
     */
    createMultiSigAddress(addressType, signatureThreshold, keys) {
        const { scriptPubKey: outputScript, redeemScript, witnessScript, } = utxolib.bitgo.outputScripts.createOutputScript2of3(keys, addressType);
        return {
            outputScript,
            redeemScript,
            witnessScript,
            address: utxolib.address.fromOutputScript(outputScript, this.network),
        };
    }
    /**
     * @deprecated - use {@see backupKeyRecovery}
     * Builds a funds recovery transaction without BitGo
     * @param params - {@see backupKeyRecovery}
     */
    async recover(params) {
        return (0, recovery_1.backupKeyRecovery)(this, this.bitgo, params);
    }
    async recoverV1(params) {
        return (0, recovery_1.v1BackupKeyRecovery)(this, this.bitgo, params);
    }
    /**
     * Recover coin that was sent to wrong chain
     * @param params
     * @param params.txid The txid of the faulty transaction
     * @param params.recoveryAddress address to send recovered funds to
     * @param params.wallet the wallet that received the funds
     * @param params.recoveryCoin the coin type of the wallet that received the funds
     * @param params.signed return a half-signed transaction (default=true)
     * @param params.walletPassphrase the wallet passphrase
     * @param params.xprv the unencrypted xprv (used instead of wallet passphrase)
     * @param params.apiKey for utxo coins other than [BTC,TBTC] this is a Block Chair api key
     * @returns {*}
     */
    async recoverFromWrongChain(params) {
        const { txid, recoveryAddress, wallet, walletPassphrase, xprv, apiKey } = params;
        // params.recoveryCoin used to be params.coin, backwards compatibility
        const recoveryCoin = params.coin || params.recoveryCoin;
        if (!recoveryCoin) {
            throw new Error('missing required object recoveryCoin');
        }
        // signed should default to true, and only be disabled if explicitly set to false (not undefined)
        const signed = params.signed !== false;
        const sourceCoinFamily = this.getFamily();
        const recoveryCoinFamily = recoveryCoin.getFamily();
        const supportedRecoveryCoins = config_1.supportedCrossChainRecoveries[sourceCoinFamily];
        if (_.isUndefined(supportedRecoveryCoins) || !supportedRecoveryCoins.includes(recoveryCoinFamily)) {
            throw new Error(`Recovery of ${sourceCoinFamily} balances from ${recoveryCoinFamily} wallets is not supported.`);
        }
        return await (0, recovery_1.recoverCrossChain)(this.bitgo, {
            sourceCoin: this,
            recoveryCoin,
            walletId: wallet,
            txid,
            recoveryAddress,
            walletPassphrase: signed ? walletPassphrase : undefined,
            xprv: signed ? xprv : undefined,
            apiKey,
        });
    }
    /**
     * Generate bip32 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = (0, crypto_1.randomBytes)(512 / 8);
        }
        const extendedKey = utxo_lib_1.bip32.fromSeed(seed);
        return {
            pub: extendedKey.neutered().toBase58(),
            prv: extendedKey.toBase58(),
        };
    }
    async getExtraPrebuildParams(buildParams) {
        let txFormat = buildParams.txFormat;
        let changeAddressType = buildParams.changeAddressType;
        const walletFlagMusigKp = buildParams.wallet.flag('musigKp') === 'true';
        // if the txFormat is not specified, we need to default to psbt for distributed custody wallets or testnet hot wallets
        if (buildParams.txFormat === undefined &&
            (buildParams.wallet.subType() === 'distributedCustody' ||
                ((0, utxo_lib_1.isTestnet)(this.network) && buildParams.wallet.type() === 'hot') ||
                // FIXME(BTC-776): default to psbt for all mainnet wallets in the future
                walletFlagMusigKp)) {
            txFormat = 'psbt';
        }
        // if the addressType is not specified, we need to default to p2trMusig2 for testnet hot wallets for staged rollout of p2trMusig2
        if (buildParams.addressType === undefined && // addressType is deprecated and replaced by `changeAddress`
            buildParams.changeAddressType === undefined &&
            buildParams.changeAddress === undefined &&
            buildParams.wallet.type() === 'hot') {
            changeAddressType = ['p2trMusig2', 'p2wsh', 'p2shP2wsh', 'p2sh', 'p2tr'];
        }
        return {
            txFormat,
            changeAddressType,
        };
    }
    preCreateBitGo(params) {
        return;
    }
    async presignTransaction(params) {
        return params;
    }
    async supplementGenerateWallet(walletParams, keychains) {
        return walletParams;
    }
    transactionDataAllowed() {
        return false;
    }
    valuelessTransferAllowed() {
        return false;
    }
    getRecoveryProvider(apiToken) {
        return (0, recovery_1.forCoin)(this.getChain(), apiToken);
    }
}
exports.AbstractUtxoCoin = AbstractUtxoCoin;
/**
 * Key Value: Unsigned tx id => PSBT
 * It is used to cache PSBTs with taproot key path (MuSig2) inputs during external express signer is activated.
 * Reason: MuSig2 signer secure nonce is cached in the UtxoPsbt object. It will be required during the signing step.
 * For more info, check SignTransactionOptions.signingStep
 *
 * TODO BTC-276: This cache may need to be done with LRU like memory safe caching if memory issues comes up.
 */
AbstractUtxoCoin.PSBT_CACHE = new Map();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJzdHJhY3RVdHhvQ29pbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hYnN0cmFjdFV0eG9Db2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBOztHQUVHO0FBQ0gsMkNBQTJDO0FBQzNDLDhDQUEwRTtBQUMxRSxpQ0FBaUM7QUFDakMsb0RBQW9EO0FBQ3BELG1DQUFxQztBQUNyQyxrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCLCtDQUFxQztBQUVyQyx5Q0FVb0I7QUFFcEIsOENBNEN5QjtBQUN6QiwrQ0FBaUU7QUFFakUsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBR3hDLHlEQUErRDtBQUMvRCxpQ0FBMkU7QUFDM0UscUNBQXlEO0FBQ3pELCtDQUFxRjtBQTJCckYsTUFBTSxFQUFFLG9CQUFvQixFQUFFLFdBQVcsRUFBRSxrQkFBa0IsRUFBRSxhQUFhLEVBQUUsR0FBRyxnQkFBSyxDQUFDO0FBc0V2RixNQUFhLHNCQUF1QixTQUFRLGlCQUFNO0lBR2hELFlBQVksS0FBZ0IsRUFBRSxRQUFtQixFQUFFLFVBQWU7UUFDaEUsS0FBSyxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDckMsQ0FBQztDQUNGO0FBTkQsd0RBTUM7QUEwSUQsTUFBc0IsZ0JBQWlCLFNBQVEsbUJBQVE7SUFNckQsWUFBc0IsS0FBZ0IsRUFBRSxPQUF3QixFQUFFLGFBQWtDLFFBQVE7UUFDMUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDcEMsTUFBTSxJQUFJLEtBQUssQ0FDYiwrREFBK0Q7Z0JBQzdELDZFQUE2RSxDQUNoRixDQUFDO1NBQ0g7UUFDRCxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QixJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztJQUMxQixD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IGFzIHV0eG9saWIgZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCB7IGJpcDMyLCBCSVAzMkludGVyZmFjZSwgYml0Z28sIGlzVGVzdG5ldCB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCAqIGFzIGJpdGNvaW5NZXNzYWdlIGZyb20gJ2JpdGNvaW5qcy1tZXNzYWdlJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCAqIGFzIGRlYnVnTGliIGZyb20gJ2RlYnVnJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcblxuaW1wb3J0IHtcbiAgQ3Jvc3NDaGFpblJlY292ZXJ5U2lnbmVkLFxuICBDcm9zc0NoYWluUmVjb3ZlcnlVbnNpZ25lZCxcbiAgZm9yQ29pbixcbiAgcmVjb3ZlckNyb3NzQ2hhaW4sXG4gIFJlY292ZXJ5UHJvdmlkZXIsXG4gIGJhY2t1cEtleVJlY292ZXJ5LFxuICBSZWNvdmVyUGFyYW1zLFxuICBWMVJlY292ZXJQYXJhbXMsXG4gIHYxQmFja3VwS2V5UmVjb3ZlcnksXG59IGZyb20gJy4vcmVjb3ZlcnknO1xuXG5pbXBvcnQge1xuICBBZGRyZXNzQ29pblNwZWNpZmljLFxuICBBZGRyZXNzVHlwZUNoYWluTWlzbWF0Y2hFcnJvcixcbiAgQmFzZUNvaW4sXG4gIEJpdEdvQmFzZSxcbiAgZGVjcnlwdEtleWNoYWluUHJpdmF0ZUtleSxcbiAgRXh0cmFQcmVidWlsZFBhcmFtc09wdGlvbnMsXG4gIEhhbGZTaWduZWRVdHhvVHJhbnNhY3Rpb24sXG4gIElCYXNlQ29pbixcbiAgSW52YWxpZEFkZHJlc3NEZXJpdmF0aW9uUHJvcGVydHlFcnJvcixcbiAgSW52YWxpZEFkZHJlc3NFcnJvcixcbiAgSW52YWxpZEFkZHJlc3NWZXJpZmljYXRpb25PYmplY3RQcm9wZXJ0eUVycm9yLFxuICBJUmVxdWVzdFRyYWNlcixcbiAgaXNUcmlwbGUsXG4gIElUcmFuc2FjdGlvbkV4cGxhbmF0aW9uIGFzIEJhc2VUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBJV2FsbGV0LFxuICBLZXljaGFpbixcbiAgS2V5Y2hhaW5zVHJpcGxldCxcbiAgS2V5SW5kaWNlcyxcbiAgUDJzaFAyd3NoVW5zdXBwb3J0ZWRFcnJvcixcbiAgUDJ0ck11c2lnMlVuc3VwcG9ydGVkRXJyb3IsXG4gIFAydHJVbnN1cHBvcnRlZEVycm9yLFxuICBQMndzaFVuc3VwcG9ydGVkRXJyb3IsXG4gIFBhcnNlZFRyYW5zYWN0aW9uIGFzIEJhc2VQYXJzZWRUcmFuc2FjdGlvbixcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMgYXMgQmFzZVBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBQcmVjcmVhdGVCaXRHb09wdGlvbnMsXG4gIFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gIHByb21pc2VQcm9wcyxcbiAgUmVxdWVzdFRyYWNlcixcbiAgc2FuaXRpemVMZWdhY3lQYXRoLFxuICBTaWduZWRUcmFuc2FjdGlvbixcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25QYXJhbXMgYXMgQmFzZVRyYW5zYWN0aW9uUGFyYW1zLFxuICBUcmFuc2FjdGlvblByZWJ1aWxkIGFzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBUcmFuc2FjdGlvblJlY2lwaWVudCxcbiAgVHJpcGxlLFxuICBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yLFxuICBVbnN1cHBvcnRlZEFkZHJlc3NUeXBlRXJyb3IsXG4gIFZlcmlmaWNhdGlvbk9wdGlvbnMsXG4gIFZlcmlmeUFkZHJlc3NPcHRpb25zIGFzIEJhc2VWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFdhbGxldCxcbiAgV2FsbGV0RGF0YSxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IEN1c3RvbUNoYW5nZU9wdGlvbnMsIHBhcnNlT3V0cHV0IH0gZnJvbSAnLi9wYXJzZU91dHB1dCc7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdMaWIoJ2JpdGdvOnYyOnV0eG8nKTtcblxuaW1wb3J0IFNjcmlwdFR5cGUyT2YzID0gdXR4b2xpYi5iaXRnby5vdXRwdXRTY3JpcHRzLlNjcmlwdFR5cGUyT2YzO1xuaW1wb3J0IHsgaXNSZXBsYXlQcm90ZWN0aW9uVW5zcGVudCB9IGZyb20gJy4vcmVwbGF5UHJvdGVjdGlvbic7XG5pbXBvcnQgeyBzaWduQW5kVmVyaWZ5UHNidCwgc2lnbkFuZFZlcmlmeVdhbGxldFRyYW5zYWN0aW9uIH0gZnJvbSAnLi9zaWduJztcbmltcG9ydCB7IHN1cHBvcnRlZENyb3NzQ2hhaW5SZWNvdmVyaWVzIH0gZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHsgZXhwbGFpblBzYnQsIGV4cGxhaW5UeCwgZ2V0UHNidFR4SW5wdXRzLCBnZXRUeElucHV0cyB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuXG50eXBlIFV0eG9DdXN0b21TaWduaW5nRnVuY3Rpb248VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludD4gPSB7XG4gIChwYXJhbXM6IHtcbiAgICBjb2luOiBJQmFzZUNvaW47XG4gICAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDxUTnVtYmVyPjtcbiAgICBwdWJzPzogc3RyaW5nW107XG4gICAgLyoqXG4gICAgICogc2lnbmluZ1N0ZXAgZmxhZyBiZWNvbWVzIGFwcGxpY2FibGUgd2hlbiBib3RoIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICAgICAqIDEpIFdoZW4gdGhlIGV4dGVybmFsIGV4cHJlc3Mgc2lnbmVyIGlzIGFjdGl2YXRlZFxuICAgICAqIDIpIFdoZW4gdGhlIFBTQlQgaW5jbHVkZXMgYXQgbGVhc3Qgb25lIHRhcHJvb3RLZXlQYXRoU3BlbmQgaW5wdXQuXG4gICAgICpcbiAgICAgKiBUaGUgc2lnbmluZyBwcm9jZXNzIG9mIGEgdGFwcm9vdEtleVBhdGhTcGVuZCBpbnB1dCBpcyBhIDQtc3RlcCBzZXF1ZW5jZTpcbiAgICAgKiBpKSB1c2VyIG5vbmNlIGdlbmVyYXRpb24gLSBzaWduZXJOb25jZSAtIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwgdG8gZXh0ZXJuYWwgZXhwcmVzcyBzaWduZXIgc2lnblRyYW5zYWN0aW9uXG4gICAgICogaWkpIGJpdGdvIG5vbmNlIGdlbmVyYXRpb24gLSBjb3NpZ25lck5vbmNlIC0gdGhpcyBpcyB0aGUgZmlyc3QgYW5kIG9ubHkgY2FsbCB0byBsb2NhbCBzaWduVHJhbnNhY3Rpb25cbiAgICAgKiBpaWkpIHVzZXIgc2lnbmF0dXJlIC0gc2lnbmVyU2lnbmF0dXJlIC0gdGhpcyBpcyB0aGUgc2Vjb25kIGNhbGwgdG8gZXh0ZXJuYWwgZXhwcmVzcyBzaWduZXIgc2lnblRyYW5zYWN0aW9uXG4gICAgICogaXYpIGJpdGdvIHNpZ25hdHVyZSAtIG5vdCBpbiBzaWduVHJhbnNhY3Rpb24gbWV0aG9k4oCZcyBzY29wZVxuICAgICAqXG4gICAgICogSW4gdGhlIGFic2VuY2Ugb2YgdGhpcyBmbGFnLCB0aGUgYWZvcmVtZW50aW9uZWQgZmlyc3QgdGhyZWUgc2VxdWVuY2UgaXMgZXhlY3V0ZWQgaW4gYSBzaW5nbGUgc2lnblRyYW5zYWN0aW9uIGNhbGwuXG4gICAgICpcbiAgICAgKiBOT1RFOiBXZSBtYWtlIGEgc3Ryb25nIGFzc3VtcHRpb24gdGhhdCB0aGUgZXh0ZXJuYWwgZXhwcmVzcyBzaWduZXIgYW5kIGl0cyBjYWxsZXIgdXNlcyBzdGlja3kgc2Vzc2lvbnMsXG4gICAgICogc2luY2UgUFNCVHMgYXJlIGNhY2hlZCBpbiBzdGVwIDEgdG8gYmUgdXNlZCBpbiBzdGVwIDMgZm9yIE11U2lnMiB1c2VyIHNlY3VyZSBub25jZSBhY2Nlc3MuXG4gICAgICovXG4gICAgc2lnbmluZ1N0ZXA/OiAnc2lnbmVyTm9uY2UnIHwgJ3NpZ25lclNpZ25hdHVyZScgfCAnY29zaWduZXJOb25jZSc7XG4gIH0pOiBQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPjtcbn07XG5cbmNvbnN0IHsgZ2V0RXh0ZXJuYWxDaGFpbkNvZGUsIGlzQ2hhaW5Db2RlLCBzY3JpcHRUeXBlRm9yQ2hhaW4sIG91dHB1dFNjcmlwdHMgfSA9IGJpdGdvO1xudHlwZSBVbnNwZW50PFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQgPSBudW1iZXI+ID0gYml0Z28uVW5zcGVudDxUTnVtYmVyPjtcblxudHlwZSBSb290V2FsbGV0S2V5cyA9IGJpdGdvLlJvb3RXYWxsZXRLZXlzO1xuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeUFkZHJlc3NPcHRpb25zIGV4dGVuZHMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zIHtcbiAgY2hhaW46IG51bWJlcjtcbiAgaW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPdXRwdXQge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGFtb3VudDogc3RyaW5nIHwgbnVtYmVyO1xuICBleHRlcm5hbD86IGJvb2xlYW47XG4gIG5lZWRzQ3VzdG9tQ2hhbmdlS2V5U2lnbmF0dXJlVmVyaWZpY2F0aW9uPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uRXhwbGFuYXRpb248c3RyaW5nLCBzdHJpbmc+IHtcbiAgbG9ja3RpbWU6IG51bWJlcjtcbiAgb3V0cHV0czogT3V0cHV0W107XG4gIGNoYW5nZU91dHB1dHM6IE91dHB1dFtdO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgaW5wdXQgc2lnbmF0dXJlcyBwZXIgaW5wdXQuXG4gICAqL1xuICBpbnB1dFNpZ25hdHVyZXM6IG51bWJlcltdO1xuXG4gIC8qKlxuICAgKiBIaWdoZXN0IGlucHV0IHNpZ25hdHVyZSBjb3VudCBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzaWduYXR1cmVzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25JbmZvPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQgPSBudW1iZXI+IHtcbiAgLyoqIE1hcHMgdHhpZCB0byB0eGhleC4gUmVxdWlyZWQgZm9yIG9mZmxpbmUgc2lnbmluZy4gKi9cbiAgdHhIZXhlcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIGNoYW5nZUFkZHJlc3Nlcz86IHN0cmluZ1tdO1xuICAvKiogcHNidCBkb2VzIG5vdCByZXF1aXJlIHVuc3BlbnRzLiAqL1xuICB1bnNwZW50cz86IFVuc3BlbnQ8VE51bWJlcj5bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQgPSBudW1iZXI+IHtcbiAgdHhIZXg6IHN0cmluZztcbiAgdHhJbmZvPzogVHJhbnNhY3Rpb25JbmZvPFROdW1iZXI+O1xuICBmZWVJbmZvPzogc3RyaW5nO1xuICBwdWJzPzogVHJpcGxlPHN0cmluZz47XG59XG5cbmV4cG9ydCB0eXBlIFV0eG9OZXR3b3JrID0gdXR4b2xpYi5OZXR3b3JrO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQ8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludCA9IG51bWJlcj4gZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHR4SW5mbz86IFRyYW5zYWN0aW9uSW5mbzxUTnVtYmVyPjtcbiAgYmxvY2tIZWlnaHQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QYXJhbXMgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QYXJhbXMge1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICBjaGFuZ2VBZGRyZXNzPzogc3RyaW5nO1xuICByYmZUeElkcz86IHN0cmluZ1tdO1xufVxuXG4vLyBwYXJzZVRyYW5zYWN0aW9ucycgcmV0dXJuIHR5cGUgbWFrZXMgdXNlIG9mIFdhbGxldERhdGEncyB0eXBlIGJ1dCB3aXRoIGN1c3RvbUNoYW5nZUtleVNpZ25hdHVyZXMgYXMgcmVxdWlyZWQuXG5leHBvcnQgaW50ZXJmYWNlIEFic3RyYWN0VXR4b0NvaW5XYWxsZXREYXRhIGV4dGVuZHMgV2FsbGV0RGF0YSB7XG4gIGN1c3RvbUNoYW5nZUtleVNpZ25hdHVyZXM6IHtcbiAgICB1c2VyOiBzdHJpbmc7XG4gICAgYmFja3VwOiBzdHJpbmc7XG4gICAgYml0Z286IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIEFic3RyYWN0VXR4b0NvaW5XYWxsZXQgZXh0ZW5kcyBXYWxsZXQge1xuICBwdWJsaWMgX3dhbGxldDogQWJzdHJhY3RVdHhvQ29pbldhbGxldERhdGE7XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSwgYmFzZUNvaW46IElCYXNlQ29pbiwgd2FsbGV0RGF0YTogYW55KSB7XG4gICAgc3VwZXIoYml0Z28sIGJhc2VDb2luLCB3YWxsZXREYXRhKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQgPSBudW1iZXI+IGV4dGVuZHMgQmFzZVBhcnNlVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQYXJhbXM6IFRyYW5zYWN0aW9uUGFyYW1zO1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkPFROdW1iZXI+O1xuICB3YWxsZXQ6IEFic3RyYWN0VXR4b0NvaW5XYWxsZXQ7XG4gIHZlcmlmaWNhdGlvbj86IFZlcmlmaWNhdGlvbk9wdGlvbnM7XG4gIHJlcUlkPzogSVJlcXVlc3RUcmFjZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkVHJhbnNhY3Rpb248VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludCA9IG51bWJlcj4gZXh0ZW5kcyBCYXNlUGFyc2VkVHJhbnNhY3Rpb24ge1xuICBrZXljaGFpbnM6IHtcbiAgICB1c2VyPzogS2V5Y2hhaW47XG4gICAgYmFja3VwPzogS2V5Y2hhaW47XG4gICAgYml0Z28/OiBLZXljaGFpbjtcbiAgfTtcbiAga2V5U2lnbmF0dXJlczoge1xuICAgIGJhY2t1cFB1Yj86IHN0cmluZztcbiAgICBiaXRnb1B1Yj86IHN0cmluZztcbiAgfTtcbiAgb3V0cHV0czogT3V0cHV0W107XG4gIG1pc3NpbmdPdXRwdXRzOiBPdXRwdXRbXTtcbiAgZXhwbGljaXRFeHRlcm5hbE91dHB1dHM6IE91dHB1dFtdO1xuICBpbXBsaWNpdEV4dGVybmFsT3V0cHV0czogT3V0cHV0W107XG4gIGNoYW5nZU91dHB1dHM6IE91dHB1dFtdO1xuICBleHBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQ6IFROdW1iZXI7XG4gIGltcGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudDogVE51bWJlcjtcbiAgbmVlZHNDdXN0b21DaGFuZ2VLZXlTaWduYXR1cmVWZXJpZmljYXRpb246IGJvb2xlYW47XG4gIGN1c3RvbUNoYW5nZT86IEN1c3RvbUNoYW5nZU9wdGlvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2VuZXJhdGVBZGRyZXNzT3B0aW9ucyB7XG4gIGFkZHJlc3NUeXBlPzogU2NyaXB0VHlwZTJPZjM7XG4gIGtleWNoYWluczoge1xuICAgIHB1Yjogc3RyaW5nO1xuICAgIGFzcEtleUlkPzogc3RyaW5nO1xuICB9W107XG4gIHRocmVzaG9sZD86IG51bWJlcjtcbiAgY2hhaW4/OiBudW1iZXI7XG4gIGluZGV4PzogbnVtYmVyO1xuICBzZWd3aXQ/OiBib29sZWFuO1xuICBiZWNoMzI/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkZHJlc3NEZXRhaWxzIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBjaGFpbjogbnVtYmVyO1xuICBpbmRleDogbnVtYmVyO1xuICBjb2luOiBzdHJpbmc7XG4gIGNvaW5TcGVjaWZpYzogQWRkcmVzc0NvaW5TcGVjaWZpYztcbiAgYWRkcmVzc1R5cGU/OiBzdHJpbmc7XG59XG5cbnR5cGUgVXR4b0Jhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQgPSBudW1iZXI+ID0gQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgJiB7XG4gIC8qKiBUcmFuc2FjdGlvbiBwcmVidWlsZCBmcm9tIGJpdGdvIHNlcnZlciAqL1xuICB0eFByZWJ1aWxkOiB7XG4gICAgLyoqXG4gICAgICogd2FsbGV0SWQgaXMgcmVxdWlyZWQgaW4gZm9sbG93aW5nIDIgc2NlbmFyaW9zLlxuICAgICAqIDEuIEV4dGVybmFsIHNpZ25lciBleHByZXNzIG1vZGUgaXMgdXNlZC5cbiAgICAgKiAyLiBiaXRnbyBNdVNpZzIgbm9uY2UgaXMgcmVxdWVzdGVkXG4gICAgICovXG4gICAgd2FsbGV0SWQ/OiBzdHJpbmc7XG4gICAgdHhIZXg6IHN0cmluZztcbiAgICB0eEluZm8/OiBUcmFuc2FjdGlvbkluZm88VE51bWJlcj47XG4gIH07XG4gIC8qKiB4cHVicyB0cmlwbGUgZm9yIHdhbGxldCAodXNlciwgYmFja3VwLCBiaXRnbykuIFJlcXVpcmVkIG9ubHkgd2hlbiB0eFByZWJ1aWxkLnR4SGV4IGlzIG5vdCBhIFBTQlQgKi9cbiAgcHVicz86IFRyaXBsZTxzdHJpbmc+O1xuICAvKiogeHB1YiBmb3IgY29zaWduZXIgKGRlZmF1bHRzIHRvIGJpdGdvKSAqL1xuICBjb3NpZ25lclB1Yj86IHN0cmluZztcbiAgLyoqXG4gICAqIFdoZW4gdHJ1ZSwgY3JlYXRlcyBmdWxsLXNpZ25lZCB0cmFuc2FjdGlvbiB3aXRob3V0IHBsYWNlaG9sZGVyIHNpZ25hdHVyZXMuXG4gICAqIFdoZW4gZmFsc2UsIGNyZWF0ZXMgaGFsZi1zaWduZWQgdHJhbnNhY3Rpb24gd2l0aCBwbGFjZWhvbGRlciBzaWduYXR1cmVzLlxuICAgKi9cbiAgaXNMYXN0U2lnbmF0dXJlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIElmIHRydWUsIGFsbG93cyBzaWduaW5nIGEgbm9uLXNlZ3dpdCBpbnB1dCB3aXRoIGEgd2l0bmVzc1V0eG8gaW5zdGVhZCByZXF1aXJpbmcgYSBwcmV2aW91c1xuICAgKiB0cmFuc2FjdGlvbiAobm9uV2l0bmVzc1V0eG8pXG4gICAqL1xuICBhbGxvd05vblNlZ3dpdFNpZ25pbmdXaXRob3V0UHJldlR4PzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnM8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludCA9IG51bWJlcj4gPSBVdHhvQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnM8VE51bWJlcj4gJlxuICAoXG4gICAgfCB7XG4gICAgICAgIHBydjogc3RyaW5nO1xuICAgICAgICBzaWduaW5nU3RlcD86ICdzaWduZXJOb25jZScgfCAnc2lnbmVyU2lnbmF0dXJlJztcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgc2lnbmluZ1N0ZXA6ICdjb3NpZ25lck5vbmNlJztcbiAgICAgIH1cbiAgKTtcblxuZXhwb3J0IGludGVyZmFjZSBNdWx0aVNpZ0FkZHJlc3Mge1xuICBvdXRwdXRTY3JpcHQ6IEJ1ZmZlcjtcbiAgcmVkZWVtU2NyaXB0PzogQnVmZmVyO1xuICB3aXRuZXNzU2NyaXB0PzogQnVmZmVyO1xuICBhZGRyZXNzOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjb3ZlckZyb21Xcm9uZ0NoYWluT3B0aW9ucyB7XG4gIHR4aWQ6IHN0cmluZztcbiAgcmVjb3ZlcnlBZGRyZXNzOiBzdHJpbmc7XG4gIHdhbGxldDogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICB4cHJ2Pzogc3RyaW5nO1xuICBhcGlLZXk/OiBzdHJpbmc7XG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBjb2luPzogQWJzdHJhY3RVdHhvQ29pbjtcbiAgcmVjb3ZlcnlDb2luPzogQWJzdHJhY3RVdHhvQ29pbjtcbiAgc2lnbmVkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZnlLZXlTaWduYXR1cmVzT3B0aW9ucyB7XG4gIHVzZXJLZXljaGFpbjogeyBwdWI/OiBzdHJpbmcgfTtcbiAga2V5Y2hhaW5Ub1ZlcmlmeTogeyBwdWI/OiBzdHJpbmcgfTtcbiAga2V5U2lnbmF0dXJlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZ5VXNlclB1YmxpY0tleU9wdGlvbnMge1xuICB1c2VyS2V5Y2hhaW4/OiBLZXljaGFpbjtcbiAgZGlzYWJsZU5ldHdvcmtpbmc6IGJvb2xlYW47XG4gIHR4UGFyYW1zOiBUcmFuc2FjdGlvblBhcmFtcztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnM8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludCA9IG51bWJlcj5cbiAgZXh0ZW5kcyBCYXNlVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDxUTnVtYmVyPjtcbiAgd2FsbGV0OiBBYnN0cmFjdFV0eG9Db2luV2FsbGV0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25Qc2J0UmVxdWVzdCB7XG4gIHBzYnQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaWduUHNidFJlc3BvbnNlIHtcbiAgcHNidDogc3RyaW5nO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RVdHhvQ29pbiBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHVibGljIGFsdFNjcmlwdEhhc2g/OiBudW1iZXI7XG4gIHB1YmxpYyBzdXBwb3J0QWx0U2NyaXB0RGVzdGluYXRpb24/OiBib29sZWFuO1xuICBwdWJsaWMgcmVhZG9ubHkgYW1vdW50VHlwZTogJ251bWJlcicgfCAnYmlnaW50JztcbiAgcHJpdmF0ZSByZWFkb25seSBfbmV0d29yazogdXR4b2xpYi5OZXR3b3JrO1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlLCBuZXR3b3JrOiB1dHhvbGliLk5ldHdvcmssIGFtb3VudFR5cGU6ICdudW1iZXInIHwgJ2JpZ2ludCcgPSAnbnVtYmVyJykge1xuICAgIHN1cGVyKGJpdGdvKTtcbiAgICBpZiAoIXV0eG9saWIuaXNWYWxpZE5ldHdvcmsobmV0d29yaykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2ludmFsaWQgbmV0d29yazogcGxlYXNlIG1ha2Ugc3VyZSB0byB1c2UgdGhlIHNhbWUgdmVyc2lvbiBvZiAnICtcbiAgICAgICAgICAnQGJpdGdvL3V0eG8tbGliIGFzIHRoaXMgbGlicmFyeSB3aGVuIGluaXRpYWxpemluZyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzJ1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5hbW91bnRUeXBlID0gYW1vdW50VHlwZTtcbiAgICB0aGlzLl9uZXR3b3JrID0gbmV0d29yaztcbiAgfVxuXG4gIC8qKlxuICAgKiBLZXkgVmFsdWU6IFVuc2lnbmVkIHR4IGlkID0+IFBTQlRcbiAgICogSXQgaXMgdXNlZCB0byBjYWNoZSBQU0JUcyB3aXRoIHRhcHJvb3Qga2V5IHBhdGggKE11U2lnMikgaW5wdXRzIGR1cmluZyBleHRlcm5hbCBleHByZXNzIHNpZ25lciBpcyBhY3RpdmF0ZWQuXG4gICAqIFJlYXNvbjogTXVTaWcyIHNpZ25lciBzZWN1cmUgbm9uY2UgaXMgY2FjaGVkIGluIHRoZSBVdHhvUHNidCBvYmplY3QuIEl0IHdpbGwgYmUgcmVxdWlyZWQgZHVyaW5nIHRoZSBzaWduaW5nIHN0ZXAuXG4gICAqIEZvciBtb3JlIGluZm8sIGNoZWNrIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMuc2lnbmluZ1N0ZXBcbiAgICpcbiAgICogVE9ETyBCVEMtMjc2OiBUaGlzIGNhY2hlIG1heSBuZWVkIHRvIGJlIGRvbmUgd2l0aCBMUlUgbGlrZSBtZW1vcnkgc2FmZSBjYWNoaW5nIGlmIG1lbW9yeSBpc3N1ZXMgY29tZXMgdXAuXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBQU0JUX0NBQ0hFID0gbmV3IE1hcDxzdHJpbmcsIHV0eG9saWIuYml0Z28uVXR4b1BzYnQ+KCk7XG5cbiAgZ2V0IG5ldHdvcmsoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25ldHdvcms7XG4gIH1cblxuICBzd2VlcFdpdGhTZW5kTWFueSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBzdGF0aWMgZ2V0IHZhbGlkQWRkcmVzc1R5cGVzKCk6IFNjcmlwdFR5cGUyT2YzW10ge1xuICAgIHJldHVybiBbLi4ub3V0cHV0U2NyaXB0cy5zY3JpcHRUeXBlczJPZjNdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZhY3RvciBiZXR3ZWVuIHRoZSBiYXNlIHVuaXQgYW5kIGl0cyBzbWFsbGVzdCBzdWJkaXZpc29uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldEJhc2VGYWN0b3IoKSB7XG4gICAgcmV0dXJuIDFlODtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0Q29pbkxpYnJhcnkoKSB7XG4gICAgcmV0dXJuIHV0eG9saWI7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYWRkcmVzcyBpcyB2YWxpZFxuICAgKiBAcGFyYW0gYWRkcmVzc1xuICAgKiBAcGFyYW0gcGFyYW1cbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZywgcGFyYW0/OiB7IGFueUZvcm1hdDogYm9vbGVhbiB9IHwgLyogbGVnYWN5IHBhcmFtZXRlciAqLyBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ2Jvb2xlYW4nICYmIHBhcmFtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlcHJlY2F0ZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtYXRzID0gcGFyYW0gJiYgcGFyYW0uYW55Rm9ybWF0ID8gdW5kZWZpbmVkIDogWydkZWZhdWx0JyBhcyBjb25zdF07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNjcmlwdCA9IHV0eG9saWIuYWRkcmVzc0Zvcm1hdC50b091dHB1dFNjcmlwdFRyeUZvcm1hdHMoYWRkcmVzcywgdGhpcy5uZXR3b3JrLCBmb3JtYXRzKTtcbiAgICAgIHJldHVybiBhZGRyZXNzID09PSB1dHhvbGliLmFkZHJlc3MuZnJvbU91dHB1dFNjcmlwdChzY3JpcHQsIHRoaXMubmV0d29yayk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwdWIgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJpcDMyLmZyb21CYXNlNTgocHViKS5pc05ldXRlcmVkKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhdGVzdCBibG9jayBoZWlnaHRcbiAgICogQHBhcmFtIHJlcUlkXG4gICAqL1xuICBhc3luYyBnZXRMYXRlc3RCbG9ja0hlaWdodChyZXFJZD86IFJlcXVlc3RUcmFjZXIpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGlmIChyZXFJZCkge1xuICAgICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHJlcUlkKTtcbiAgICB9XG4gICAgY29uc3QgY2hhaW5oZWFkID0gYXdhaXQgdGhpcy5iaXRnby5nZXQodGhpcy51cmwoJy9wdWJsaWMvYmxvY2svbGF0ZXN0JykpLnJlc3VsdCgpO1xuICAgIHJldHVybiAoY2hhaW5oZWFkIGFzIGFueSkuaGVpZ2h0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBjdXN0b20gY29pbiBsb2dpYyBhZnRlciBhIHRyYW5zYWN0aW9uIHByZWJ1aWxkIGhhcyBiZWVuIHJlY2VpdmVkIGZyb20gQml0R29cbiAgICogQHBhcmFtIHByZWJ1aWxkXG4gICAqL1xuICBhc3luYyBwb3N0UHJvY2Vzc1ByZWJ1aWxkPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KFxuICAgIHByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkPFROdW1iZXI+XG4gICk6IFByb21pc2U8VHJhbnNhY3Rpb25QcmVidWlsZDxUTnVtYmVyPj4ge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKHByZWJ1aWxkLnR4SGV4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR4UHJlYnVpbGQgcHJvcGVydHkgdHhIZXgnKTtcbiAgICB9XG4gICAgY29uc3QgdHggPSBiaXRnby5pc1BzYnQocHJlYnVpbGQudHhIZXgpXG4gICAgICA/IGJpdGdvLmNyZWF0ZVBzYnRGcm9tSGV4KHByZWJ1aWxkLnR4SGV4LCB0aGlzLm5ldHdvcmspXG4gICAgICA6IHRoaXMuY3JlYXRlVHJhbnNhY3Rpb25Gcm9tSGV4PFROdW1iZXI+KHByZWJ1aWxkLnR4SGV4KTtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwcmVidWlsZC5ibG9ja0hlaWdodCkpIHtcbiAgICAgIHByZWJ1aWxkLmJsb2NrSGVpZ2h0ID0gKGF3YWl0IHRoaXMuZ2V0TGF0ZXN0QmxvY2tIZWlnaHQoKSkgYXMgbnVtYmVyO1xuICAgIH1cbiAgICByZXR1cm4gXy5leHRlbmQoe30sIHByZWJ1aWxkLCB7IHR4SGV4OiB0eC50b0hleCgpIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBmaXJzdFxuICAgKiBAcGFyYW0gc2Vjb25kXG4gICAqIEByZXR1cm5zIHtBcnJheX0gQWxsIG91dHB1dHMgdGhhdCBhcmUgaW4gdGhlIGZpcnN0IGFycmF5IGJ1dCBub3QgaW4gdGhlIHNlY29uZFxuICAgKi9cbiAgcHJvdGVjdGVkIHN0YXRpYyBvdXRwdXREaWZmZXJlbmNlKGZpcnN0OiBPdXRwdXRbXSwgc2Vjb25kOiBPdXRwdXRbXSk6IE91dHB1dFtdIHtcbiAgICBjb25zdCBrZXlGdW5jID0gKHsgYWRkcmVzcywgYW1vdW50IH06IE91dHB1dCk6IHN0cmluZyA9PiBgJHthZGRyZXNzfToke2Ftb3VudH1gO1xuICAgIGNvbnN0IGdyb3VwZWRPdXRwdXRzID0gXy5ncm91cEJ5KGZpcnN0LCBrZXlGdW5jKTtcblxuICAgIHNlY29uZC5mb3JFYWNoKChvdXRwdXQpID0+IHtcbiAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBlZE91dHB1dHNba2V5RnVuYyhvdXRwdXQpXTtcbiAgICAgIGlmIChncm91cCkge1xuICAgICAgICBncm91cC5wb3AoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBfLmZsYXR0ZW4oXy52YWx1ZXMoZ3JvdXBlZE91dHB1dHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgYW4gYWRkcmVzcycgdHlwZSBiYXNlZCBvbiBpdHMgd2l0bmVzcyBhbmQgcmVkZWVtIHNjcmlwdCBwcmVzZW5jZVxuICAgKiBAcGFyYW0gYWRkcmVzc0RldGFpbHNcbiAgICovXG4gIHN0YXRpYyBpbmZlckFkZHJlc3NUeXBlKGFkZHJlc3NEZXRhaWxzOiB7IGNoYWluOiBudW1iZXIgfSk6IFNjcmlwdFR5cGUyT2YzIHwgbnVsbCB7XG4gICAgcmV0dXJuIGlzQ2hhaW5Db2RlKGFkZHJlc3NEZXRhaWxzLmNoYWluKSA/IHNjcmlwdFR5cGVGb3JDaGFpbihhZGRyZXNzRGV0YWlscy5jaGFpbikgOiBudWxsO1xuICB9XG5cbiAgY3JlYXRlVHJhbnNhY3Rpb25Gcm9tSGV4PFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQgPSBudW1iZXI+KFxuICAgIGhleDogc3RyaW5nXG4gICk6IHV0eG9saWIuYml0Z28uVXR4b1RyYW5zYWN0aW9uPFROdW1iZXI+IHtcbiAgICByZXR1cm4gdXR4b2xpYi5iaXRnby5jcmVhdGVUcmFuc2FjdGlvbkZyb21IZXg8VE51bWJlcj4oaGV4LCB0aGlzLm5ldHdvcmssIHRoaXMuYW1vdW50VHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBhbmQgZmlsbCB0cmFuc2FjdGlvbiBkZXRhaWxzIHN1Y2ggYXMgaW50ZXJuYWwvY2hhbmdlIHNwZW5kLCBleHRlcm5hbCBzcGVuZCAoZXhwbGljaXQgdnMuIGltcGxpY2l0KSwgZXRjLlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgcGFyc2VUcmFuc2FjdGlvbjxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50ID0gbnVtYmVyPihcbiAgICBwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zPFROdW1iZXI+XG4gICk6IFByb21pc2U8UGFyc2VkVHJhbnNhY3Rpb248VE51bWJlcj4+IHtcbiAgICBjb25zdCB7IHR4UGFyYW1zLCB0eFByZWJ1aWxkLCB3YWxsZXQsIHZlcmlmaWNhdGlvbiA9IHt9LCByZXFJZCB9ID0gcGFyYW1zO1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHZlcmlmaWNhdGlvbi5kaXNhYmxlTmV0d29ya2luZykgJiYgIV8uaXNCb29sZWFuKHZlcmlmaWNhdGlvbi5kaXNhYmxlTmV0d29ya2luZykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndmVyaWZpY2F0aW9uLmRpc2FibGVOZXR3b3JraW5nIG11c3QgYmUgYSBib29sZWFuJyk7XG4gICAgfVxuICAgIGNvbnN0IGRpc2FibGVOZXR3b3JraW5nID0gdmVyaWZpY2F0aW9uLmRpc2FibGVOZXR3b3JraW5nO1xuXG4gICAgY29uc3QgZmV0Y2hLZXljaGFpbnMgPSBhc3luYyAod2FsbGV0OiBJV2FsbGV0KTogUHJvbWlzZTxWZXJpZmljYXRpb25PcHRpb25zWydrZXljaGFpbnMnXT4gPT4ge1xuICAgICAgcmV0dXJuIHByb21pc2VQcm9wcyh7XG4gICAgICAgIHVzZXI6IHRoaXMua2V5Y2hhaW5zKCkuZ2V0KHsgaWQ6IHdhbGxldC5rZXlJZHMoKVtLZXlJbmRpY2VzLlVTRVJdLCByZXFJZCB9KSxcbiAgICAgICAgYmFja3VwOiB0aGlzLmtleWNoYWlucygpLmdldCh7IGlkOiB3YWxsZXQua2V5SWRzKClbS2V5SW5kaWNlcy5CQUNLVVBdLCByZXFJZCB9KSxcbiAgICAgICAgYml0Z286IHRoaXMua2V5Y2hhaW5zKCkuZ2V0KHsgaWQ6IHdhbGxldC5rZXlJZHMoKVtLZXlJbmRpY2VzLkJJVEdPXSwgcmVxSWQgfSksXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gb2J0YWluIHRoZSBrZXljaGFpbnMgYW5kIGtleSBzaWduYXR1cmVzXG4gICAgbGV0IGtleWNoYWluczogVmVyaWZpY2F0aW9uT3B0aW9uc1sna2V5Y2hhaW5zJ10gfCB1bmRlZmluZWQgPSB2ZXJpZmljYXRpb24ua2V5Y2hhaW5zO1xuICAgIGlmICgha2V5Y2hhaW5zKSB7XG4gICAgICBpZiAoZGlzYWJsZU5ldHdvcmtpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZmV0Y2gga2V5Y2hhaW5zIHdpdGhvdXQgbmV0d29ya2luZycpO1xuICAgICAgfVxuICAgICAga2V5Y2hhaW5zID0gYXdhaXQgZmV0Y2hLZXljaGFpbnMod2FsbGV0KTtcbiAgICB9XG5cbiAgICBpZiAoIWtleWNoYWlucyB8fCAha2V5Y2hhaW5zLnVzZXIgfHwgIWtleWNoYWlucy5iYWNrdXAgfHwgIWtleWNoYWlucy5iaXRnbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXljaGFpbnMgYXJlIHJlcXVpcmVkLCBidXQgY291bGQgbm90IGJlIGZldGNoZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXljaGFpbkFycmF5OiBUcmlwbGU8S2V5Y2hhaW4+ID0gW2tleWNoYWlucy51c2VyLCBrZXljaGFpbnMuYmFja3VwLCBrZXljaGFpbnMuYml0Z29dO1xuXG4gICAgY29uc3Qga2V5U2lnbmF0dXJlcyA9IF8uZ2V0KHdhbGxldCwgJ193YWxsZXQua2V5U2lnbmF0dXJlcycsIHt9KTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHR4UHJlYnVpbGQudHhIZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgdHhQcmVidWlsZCBwcm9wZXJ0eSB0eEhleCcpO1xuICAgIH1cbiAgICAvLyBvYnRhaW4gYWxsIG91dHB1dHNcbiAgICBjb25zdCBleHBsYW5hdGlvbjogVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiA9IGF3YWl0IHRoaXMuZXhwbGFpblRyYW5zYWN0aW9uPFROdW1iZXI+KHtcbiAgICAgIHR4SGV4OiB0eFByZWJ1aWxkLnR4SGV4LFxuICAgICAgdHhJbmZvOiB0eFByZWJ1aWxkLnR4SW5mbyxcbiAgICAgIHB1YnM6IGtleWNoYWluQXJyYXkubWFwKChrKSA9PiBrLnB1YikgYXMgVHJpcGxlPHN0cmluZz4sXG4gICAgfSk7XG4gICAgY29uc3QgYWxsT3V0cHV0cyA9IFsuLi5leHBsYW5hdGlvbi5vdXRwdXRzLCAuLi5leHBsYW5hdGlvbi5jaGFuZ2VPdXRwdXRzXTtcblxuICAgIGxldCBleHBlY3RlZE91dHB1dHM7XG4gICAgaWYgKHR4UGFyYW1zLnJiZlR4SWRzKSB7XG4gICAgICBhc3NlcnQodHhQYXJhbXMucmJmVHhJZHMubGVuZ3RoID09PSAxKTtcblxuICAgICAgY29uc3QgdHhUb0JlUmVwbGFjZWQgPSBhd2FpdCB3YWxsZXQuZ2V0VHJhbnNhY3Rpb24oeyB0eEhhc2g6IHR4UGFyYW1zLnJiZlR4SWRzWzBdLCBpbmNsdWRlUmJmOiB0cnVlIH0pO1xuICAgICAgZXhwZWN0ZWRPdXRwdXRzID0gdHhUb0JlUmVwbGFjZWQub3V0cHV0c1xuICAgICAgICAuZmlsdGVyKChvdXRwdXQpID0+IG91dHB1dC53YWxsZXQgIT09IHdhbGxldC5pZCgpKSAvLyBGb3Igc2VsZi1zZW5kcywgdGhlIHdhbGxldElkIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHdhbGxldCdzIGlkXG4gICAgICAgIC5tYXAoKG91dHB1dCkgPT4ge1xuICAgICAgICAgIHJldHVybiB7IGFtb3VudDogQmlnSW50KG91dHB1dC52YWx1ZVN0cmluZyksIGFkZHJlc3M6IHRoaXMuY2Fub25pY2FsQWRkcmVzcyhvdXRwdXQuYWRkcmVzcykgfTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHZlcmlmeSB0aGF0IGVhY2ggcmVjaXBpZW50IGZyb20gdHhQYXJhbXMgaGFzIHRoZWlyIG93biBvdXRwdXRcbiAgICAgIGV4cGVjdGVkT3V0cHV0cyA9IF8uZ2V0KHR4UGFyYW1zLCAncmVjaXBpZW50cycsIFtdIGFzIFRyYW5zYWN0aW9uUmVjaXBpZW50W10pLm1hcCgob3V0cHV0KSA9PiB7XG4gICAgICAgIHJldHVybiB7IC4uLm91dHB1dCwgYWRkcmVzczogdGhpcy5jYW5vbmljYWxBZGRyZXNzKG91dHB1dC5hZGRyZXNzKSB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWlzc2luZ091dHB1dHMgPSBBYnN0cmFjdFV0eG9Db2luLm91dHB1dERpZmZlcmVuY2UoZXhwZWN0ZWRPdXRwdXRzLCBhbGxPdXRwdXRzKTtcblxuICAgIC8vIGdldCB0aGUga2V5Y2hhaW5zIGZyb20gdGhlIGN1c3RvbSBjaGFuZ2Ugd2FsbGV0IGlmIG5lZWRlZFxuICAgIGxldCBjdXN0b21DaGFuZ2U6IEN1c3RvbUNoYW5nZU9wdGlvbnMgfCB1bmRlZmluZWQ7XG4gICAgY29uc3QgeyBjdXN0b21DaGFuZ2VXYWxsZXRJZCA9IHVuZGVmaW5lZCB9ID0gd2FsbGV0LmNvaW5TcGVjaWZpYygpIHx8IHt9O1xuICAgIGlmIChjdXN0b21DaGFuZ2VXYWxsZXRJZCkge1xuICAgICAgLy8gZmV0Y2gga2V5Y2hhaW5zIGZyb20gY3VzdG9tIGNoYW5nZSB3YWxsZXQgZm9yIGRlcml2aW5nIGFkZHJlc3Nlcy5cbiAgICAgIC8vIFRoZXNlIGtleWNoYWlucyBzaG91bGQgYmUgc2lnbmVkIGFuZCB0aGlzIHNob3VsZCBiZSB2ZXJpZmllZCBpbiB2ZXJpZnlUcmFuc2FjdGlvblxuICAgICAgY29uc3QgY3VzdG9tQ2hhbmdlS2V5U2lnbmF0dXJlcyA9IHdhbGxldC5fd2FsbGV0LmN1c3RvbUNoYW5nZUtleVNpZ25hdHVyZXM7XG4gICAgICBjb25zdCBjdXN0b21DaGFuZ2VXYWxsZXQ6IFdhbGxldCA9IGF3YWl0IHRoaXMud2FsbGV0cygpLmdldCh7IGlkOiBjdXN0b21DaGFuZ2VXYWxsZXRJZCB9KTtcbiAgICAgIGNvbnN0IGN1c3RvbUNoYW5nZUtleXMgPSBhd2FpdCBmZXRjaEtleWNoYWlucyhjdXN0b21DaGFuZ2VXYWxsZXQpO1xuXG4gICAgICBpZiAoIWN1c3RvbUNoYW5nZUtleXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZmV0Y2gga2V5Y2hhaW5zIGZvciBjdXN0b20gY2hhbmdlIHdhbGxldCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VzdG9tQ2hhbmdlS2V5cy51c2VyICYmIGN1c3RvbUNoYW5nZUtleXMuYmFja3VwICYmIGN1c3RvbUNoYW5nZUtleXMuYml0Z28gJiYgY3VzdG9tQ2hhbmdlV2FsbGV0KSB7XG4gICAgICAgIGNvbnN0IGN1c3RvbUNoYW5nZUtleWNoYWluczogW0tleWNoYWluLCBLZXljaGFpbiwgS2V5Y2hhaW5dID0gW1xuICAgICAgICAgIGN1c3RvbUNoYW5nZUtleXMudXNlcixcbiAgICAgICAgICBjdXN0b21DaGFuZ2VLZXlzLmJhY2t1cCxcbiAgICAgICAgICBjdXN0b21DaGFuZ2VLZXlzLmJpdGdvLFxuICAgICAgICBdO1xuXG4gICAgICAgIGN1c3RvbUNoYW5nZSA9IHtcbiAgICAgICAgICBrZXlzOiBjdXN0b21DaGFuZ2VLZXljaGFpbnMsXG4gICAgICAgICAgc2lnbmF0dXJlczogW1xuICAgICAgICAgICAgY3VzdG9tQ2hhbmdlS2V5U2lnbmF0dXJlcy51c2VyLFxuICAgICAgICAgICAgY3VzdG9tQ2hhbmdlS2V5U2lnbmF0dXJlcy5iYWNrdXAsXG4gICAgICAgICAgICBjdXN0b21DaGFuZ2VLZXlTaWduYXR1cmVzLmJpdGdvLFxuICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9vcCB0aHJvdWdoIGFsbCB0aGUgb3V0cHV0cyBhbmQgY2xhc3NpZnkgZWFjaCBvZiB0aGVtIGFzIGVpdGhlciBpbnRlcm5hbCBzcGVuZHNcbiAgICAgKiBvciBleHRlcm5hbCBzcGVuZHMgYnkgc2V0dGluZyB0aGUgXCJleHRlcm5hbFwiIHByb3BlcnR5IHRvIHRydWUgb3IgZmFsc2Ugb24gdGhlIG91dHB1dCBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3QgYWxsT3V0cHV0RGV0YWlsczogT3V0cHV0W10gPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGFsbE91dHB1dHMubWFwKChjdXJyZW50T3V0cHV0KSA9PiB7XG4gICAgICAgIHJldHVybiBwYXJzZU91dHB1dCh7XG4gICAgICAgICAgY3VycmVudE91dHB1dCxcbiAgICAgICAgICBjb2luOiB0aGlzLFxuICAgICAgICAgIHR4UHJlYnVpbGQsXG4gICAgICAgICAgdmVyaWZpY2F0aW9uLFxuICAgICAgICAgIGtleWNoYWluQXJyYXksXG4gICAgICAgICAgd2FsbGV0LFxuICAgICAgICAgIHR4UGFyYW1zLFxuICAgICAgICAgIGN1c3RvbUNoYW5nZSxcbiAgICAgICAgICByZXFJZCxcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICBjb25zdCBuZWVkc0N1c3RvbUNoYW5nZUtleVNpZ25hdHVyZVZlcmlmaWNhdGlvbiA9IGFsbE91dHB1dERldGFpbHMuc29tZShcbiAgICAgIChvdXRwdXQpID0+IG91dHB1dC5uZWVkc0N1c3RvbUNoYW5nZUtleVNpZ25hdHVyZVZlcmlmaWNhdGlvblxuICAgICk7XG5cbiAgICBjb25zdCBjaGFuZ2VPdXRwdXRzID0gXy5maWx0ZXIoYWxsT3V0cHV0RGV0YWlscywgeyBleHRlcm5hbDogZmFsc2UgfSk7XG5cbiAgICAvLyB0aGVzZSBhcmUgYWxsIHRoZSBvdXRwdXRzIHRoYXQgd2VyZSBub3Qgb3JpZ2luYWxseSBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiByZWNpcGllbnRzXG4gICAgLy8gaWRlYWxseSBjaGFuZ2Ugb3V0cHV0cyBvciBhIHBheWdvIG91dHB1dCB0aGF0IG1pZ2h0IGhhdmUgYmVlbiBhZGRlZFxuICAgIGNvbnN0IGltcGxpY2l0T3V0cHV0cyA9IEFic3RyYWN0VXR4b0NvaW4ub3V0cHV0RGlmZmVyZW5jZShhbGxPdXRwdXREZXRhaWxzLCBleHBlY3RlZE91dHB1dHMpO1xuXG4gICAgY29uc3QgZXhwbGljaXRPdXRwdXRzID0gQWJzdHJhY3RVdHhvQ29pbi5vdXRwdXREaWZmZXJlbmNlKGFsbE91dHB1dERldGFpbHMsIGltcGxpY2l0T3V0cHV0cyk7XG5cbiAgICAvLyB0aGVzZSBhcmUgYWxsIHRoZSBub24td2FsbGV0IG91dHB1dHMgdGhhdCBoYWQgYmVlbiBvcmlnaW5hbGx5IGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHJlY2lwaWVudHNcbiAgICBjb25zdCBleHBsaWNpdEV4dGVybmFsT3V0cHV0cyA9IF8uZmlsdGVyKGV4cGxpY2l0T3V0cHV0cywgeyBleHRlcm5hbDogdHJ1ZSB9KTtcblxuICAgIC8vIHRoaXMgaXMgdGhlIHN1bSBvZiBhbGwgdGhlIG9yaWdpbmFsbHkgZXhwbGljaXRseSBzcGVjaWZpZWQgbm9uLXdhbGxldCBvdXRwdXQgdmFsdWVzXG4gICAgY29uc3QgZXhwbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50ID0gdXR4b2xpYi5iaXRnby50b1ROdW1iZXI8VE51bWJlcj4oXG4gICAgICBleHBsaWNpdEV4dGVybmFsT3V0cHV0cy5yZWR1Y2UoKHN1bTogYmlnaW50LCBvOiBPdXRwdXQpID0+IHN1bSArIEJpZ0ludChvLmFtb3VudCksIEJpZ0ludCgwKSkgYXMgYmlnaW50LFxuICAgICAgdGhpcy5hbW91bnRUeXBlXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYWxjdWxhdGlvbiBvZiB0aGUgaW1wbGljaXQgZXh0ZXJuYWwgc3BlbmQgYW1vdW50IHBlcnRhaW5zIHRvIHZlcmlmeWluZyB0aGUgcGF5LWFzLXlvdS1nby1mZWUgQml0R29cbiAgICAgKiBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdG8gdHJhbnNhY3Rpb25zIHNlbmRpbmcgbW9uZXkgb3V0IG9mIHRoZSB3YWxsZXQuIFRoZSBsb2dpYyBpcyBmYWlybHkgc3RyYWlnaHRmb3J3YXJkXG4gICAgICogaW4gdGhhdCB3ZSBjb21wYXJlIHRoZSBleHRlcm5hbCBzcGVuZCBhbW91bnQgdGhhdCB3YXMgc3BlY2lmaWVkIGV4cGxpY2l0bHkgYnkgdGhlIHVzZXIgdG8gdGhlIHBvcnRpb25cbiAgICAgKiB0aGF0IHdhcyBzcGVjaWZpZWQgaW1wbGljaXRseS4gVG8gcHJvdGVjdCBjdXN0b21lcnMgZnJvbSBwZW9wbGUgdGFtcGVyaW5nIHdpdGggdGhlIHRyYW5zYWN0aW9uIG91dHB1dHMsIHdlXG4gICAgICogZGVmaW5lIGEgdGhyZXNob2xkIGZvciB0aGUgbWF4aW11bSBwZXJjZW50YWdlIG9mIHRoZSBpbXBsaWNpdCBleHRlcm5hbCBzcGVuZCBpbiByZWxhdGlvbiB0byB0aGUgZXhwbGljaXRcbiAgICAgKiBleHRlcm5hbCBzcGVuZC5cbiAgICAgKi9cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGFsbCB0aGUgZXh0cmEgYWRkcmVzc2VzIGFyZSBjaGFuZ2UgYWRkcmVzc2VzXG4gICAgLy8gZ2V0IGFsbCB0aGUgYWRkaXRpb25hbCBleHRlcm5hbCBvdXRwdXRzIHRoZSBzZXJ2ZXIgYWRkZWQgYW5kIGNhbGN1bGF0ZSB0aGVpciB2YWx1ZXNcbiAgICBjb25zdCBpbXBsaWNpdEV4dGVybmFsT3V0cHV0cyA9IF8uZmlsdGVyKGltcGxpY2l0T3V0cHV0cywgeyBleHRlcm5hbDogdHJ1ZSB9KTtcbiAgICBjb25zdCBpbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQgPSB1dHhvbGliLmJpdGdvLnRvVE51bWJlcjxUTnVtYmVyPihcbiAgICAgIGltcGxpY2l0RXh0ZXJuYWxPdXRwdXRzLnJlZHVjZSgoc3VtOiBiaWdpbnQsIG86IE91dHB1dCkgPT4gc3VtICsgQmlnSW50KG8uYW1vdW50KSwgQmlnSW50KDApKSBhcyBiaWdpbnQsXG4gICAgICB0aGlzLmFtb3VudFR5cGVcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtleWNoYWlucyxcbiAgICAgIGtleVNpZ25hdHVyZXMsXG4gICAgICBvdXRwdXRzOiBhbGxPdXRwdXREZXRhaWxzLFxuICAgICAgbWlzc2luZ091dHB1dHMsXG4gICAgICBleHBsaWNpdEV4dGVybmFsT3V0cHV0cyxcbiAgICAgIGltcGxpY2l0RXh0ZXJuYWxPdXRwdXRzLFxuICAgICAgY2hhbmdlT3V0cHV0cyxcbiAgICAgIGV4cGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudCxcbiAgICAgIGltcGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudCxcbiAgICAgIG5lZWRzQ3VzdG9tQ2hhbmdlS2V5U2lnbmF0dXJlVmVyaWZpY2F0aW9uLFxuICAgICAgY3VzdG9tQ2hhbmdlLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjcnlwdCB0aGUgd2FsbGV0J3MgdXNlciBwcml2YXRlIGtleSBhbmQgdmVyaWZ5IHRoYXQgdGhlIGNsYWltZWQgcHVibGljIGtleSBtYXRjaGVzXG4gICAqIEBwYXJhbSB7VmVyaWZ5VXNlclB1YmxpY0tleU9wdGlvbnN9IHBhcmFtc1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90ZWN0ZWQgdmVyaWZ5VXNlclB1YmxpY0tleShwYXJhbXM6IFZlcmlmeVVzZXJQdWJsaWNLZXlPcHRpb25zKTogYm9vbGVhbiB7XG4gICAgY29uc3QgeyB1c2VyS2V5Y2hhaW4sIHR4UGFyYW1zLCBkaXNhYmxlTmV0d29ya2luZyB9ID0gcGFyYW1zO1xuICAgIGlmICghdXNlcktleWNoYWluKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZXIga2V5Y2hhaW4gaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyUHViID0gdXNlcktleWNoYWluLnB1YjtcblxuICAgIC8vIGRlY3J5cHQgdGhlIHVzZXIgcHJpdmF0ZSBrZXksIHNvIHdlIGNhbiB2ZXJpZnkgdGhhdCB0aGUgY2xhaW1lZCBwdWJsaWMga2V5IGlzIGEgbWF0Y2hcbiAgICBsZXQgdXNlclBydiA9IHVzZXJLZXljaGFpbi5wcnY7XG4gICAgaWYgKCF1c2VyUHJ2ICYmIHR4UGFyYW1zLndhbGxldFBhc3NwaHJhc2UpIHtcbiAgICAgIHVzZXJQcnYgPSBkZWNyeXB0S2V5Y2hhaW5Qcml2YXRlS2V5KHRoaXMuYml0Z28sIHVzZXJLZXljaGFpbiwgdHhQYXJhbXMud2FsbGV0UGFzc3BocmFzZSk7XG4gICAgfVxuXG4gICAgaWYgKCF1c2VyUHJ2KSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAndXNlciBwcml2YXRlIGtleSB1bmF2YWlsYWJsZSBmb3IgdmVyaWZpY2F0aW9uJztcbiAgICAgIGlmIChkaXNhYmxlTmV0d29ya2luZykge1xuICAgICAgICBjb25zb2xlLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdXNlclByaXZhdGVLZXkgPSBiaXAzMi5mcm9tQmFzZTU4KHVzZXJQcnYpO1xuICAgICAgaWYgKHVzZXJQcml2YXRlS2V5LnRvQmFzZTU4KCkgPT09IHVzZXJQcml2YXRlS2V5Lm5ldXRlcmVkKCkudG9CYXNlNTgoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZXIgcHJpdmF0ZSBrZXkgaXMgb25seSBwdWJsaWMnKTtcbiAgICAgIH1cbiAgICAgIGlmICh1c2VyUHJpdmF0ZUtleS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCkgIT09IHVzZXJQdWIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VyIHByaXZhdGUga2V5IGRvZXMgbm90IG1hdGNoIHB1YmxpYyBrZXknKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgc2lnbmF0dXJlcyBwcm9kdWNlZCBieSB0aGUgdXNlciBrZXkgb3ZlciB0aGUgYmFja3VwIGFuZCBiaXRnbyBrZXlzLlxuICAgKlxuICAgKiBJZiBzZXQsIHRoZXNlIHNpZ25hdHVyZXMgZW5zdXJlIHRoYXQgdGhlIHdhbGxldCBrZXlzIGNhbm5vdCBiZSBjaGFuZ2VkIGFmdGVyIHRoZSB3YWxsZXQgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICogQHBhcmFtIHtWZXJpZnlLZXlTaWduYXR1cmVzT3B0aW9uc30gcGFyYW1zXG4gICAqIEByZXR1cm4ge3tiYWNrdXA6IGJvb2xlYW4sIGJpdGdvOiBib29sZWFufX1cbiAgICovXG4gIHB1YmxpYyB2ZXJpZnlLZXlTaWduYXR1cmUocGFyYW1zOiBWZXJpZnlLZXlTaWduYXR1cmVzT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIC8vIGZpcnN0LCBsZXQncyB2ZXJpZnkgdGhlIGludGVncml0eSBvZiB0aGUgdXNlciBrZXksIHdob3NlIHB1YmxpYyBrZXkgaXMgdXNlZCBmb3Igc3Vic2VxdWVudCB2ZXJpZmljYXRpb25zXG4gICAgY29uc3QgeyB1c2VyS2V5Y2hhaW4sIGtleWNoYWluVG9WZXJpZnksIGtleVNpZ25hdHVyZSB9ID0gcGFyYW1zO1xuICAgIGlmICghdXNlcktleWNoYWluKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZXIga2V5Y2hhaW4gaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoIWtleWNoYWluVG9WZXJpZnkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigna2V5Y2hhaW4gdG8gdmVyaWZ5IGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgaWYgKCFrZXlTaWduYXR1cmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigna2V5IHNpZ25hdHVyZSBpcyByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIC8vIHZlcmlmeSB0aGUgc2lnbmF0dXJlIGFnYWluc3QgdGhlIHVzZXIgcHVibGljIGtleVxuICAgIGFzc2VydCh1c2VyS2V5Y2hhaW4ucHViKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBiaXAzMi5mcm9tQmFzZTU4KHVzZXJLZXljaGFpbi5wdWIpLnB1YmxpY0tleTtcbiAgICAvLyBEdWUgdG8gaW50ZXJmYWNlIG9mIGBiaXRjb2luTWVzc2FnZWAsIHdlIG5lZWQgdG8gY29udmVydCB0aGUgcHVibGljIGtleSB0byBhbiBhZGRyZXNzLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGFkZHJlc3MgaGFzIG5vIHJlbGF0aW9uc2hpcCB0byBvbi1jaGFpbiB0cmFuc2FjdGlvbnMuIFdlIGFyZVxuICAgIC8vIG9ubHkgaW50ZXJlc3RlZCBpbiB0aGUgYWRkcmVzcyBhcyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5LlxuICAgIGNvbnN0IHNpZ25pbmdBZGRyZXNzID0gdXR4b2xpYi5hZGRyZXNzLnRvQmFzZTU4Q2hlY2soXG4gICAgICB1dHhvbGliLmNyeXB0by5oYXNoMTYwKHB1YmxpY0tleSksXG4gICAgICB1dHhvbGliLm5ldHdvcmtzLmJpdGNvaW4ucHViS2V5SGFzaCxcbiAgICAgIC8vIHdlIGRvIG5vdCBwYXNzIGB0aGlzLm5ldHdvcmtgIGhlcmUgYmVjYXVzZSBpdCB3b3VsZCBmYWlsIGZvciB6Y2FzaFxuICAgICAgLy8gdGhlIGJpdGNvaW5NZXNzYWdlIGxpYnJhcnkgZGVjb2RlcyB0aGUgYWRkcmVzcyBhbmQgdGhyb3dzIGF3YXkgdGhlIGZpcnN0IGJ5dGVcbiAgICAgIC8vIGJlY2F1c2UgemNhc2ggaGFzIGEgdHdvLWJ5dGUgcHJlZml4LCB2ZXJpZnkoKSBkZWNvZGVzIHpjYXNoIGFkZHJlc3NlcyB0byBhbiBpbnZhbGlkIHB1YmtleSBoYXNoXG4gICAgICB1dHhvbGliLm5ldHdvcmtzLmJpdGNvaW5cbiAgICApO1xuXG4gICAgLy8gQkctNTcwMzogdXNlIEJUQyBtYWlubmV0IHByZWZpeCBmb3IgYWxsIGtleSBzaWduYXR1cmUgb3BlcmF0aW9uc1xuICAgIC8vICh0aGlzIG1lYW5zIGRvIG5vdCBwYXNzIGEgcHJlZml4IHBhcmFtZXRlciwgYW5kIGxldCBpdCB1c2UgdGhlIGRlZmF1bHQgcHJlZml4IGluc3RlYWQpXG4gICAgYXNzZXJ0KGtleWNoYWluVG9WZXJpZnkucHViKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJpdGNvaW5NZXNzYWdlLnZlcmlmeShrZXljaGFpblRvVmVyaWZ5LnB1Yiwgc2lnbmluZ0FkZHJlc3MsIEJ1ZmZlci5mcm9tKGtleVNpZ25hdHVyZSwgJ2hleCcpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygnZXJyb3IgdGhyb3duIGZyb20gYml0Y29pbm1lc3NhZ2Ugd2hpbGUgdmVyaWZ5aW5nIGtleSBzaWduYXR1cmUnLCBlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHNpZ25hdHVyZXMgYWdhaW5zdCB0aGUgdXNlciBwcml2YXRlIGtleSBvdmVyIHRoZSBjaGFuZ2Ugd2FsbGV0IGV4dGVuZGVkIGtleXNcbiAgICogQHBhcmFtIHtQYXJzZWRUcmFuc2FjdGlvbn0gdHhcbiAgICogQHBhcmFtIHtLZXljaGFpbn0gdXNlcktleWNoYWluXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RlY3RlZCB2ZXJpZnlDdXN0b21DaGFuZ2VLZXlTaWduYXR1cmVzPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KFxuICAgIHR4OiBQYXJzZWRUcmFuc2FjdGlvbjxUTnVtYmVyPixcbiAgICB1c2VyS2V5Y2hhaW46IEtleWNoYWluXG4gICk6IGJvb2xlYW4ge1xuICAgIGlmICghdHguY3VzdG9tQ2hhbmdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnNlZCB0cmFuc2FjdGlvbiBpcyBtaXNzaW5nIHJlcXVpcmVkIGN1c3RvbSBjaGFuZ2UgdmVyaWZpY2F0aW9uIGRhdGEnKTtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHguY3VzdG9tQ2hhbmdlLmtleXMpIHx8ICFBcnJheS5pc0FycmF5KHR4LmN1c3RvbUNoYW5nZS5zaWduYXR1cmVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXN0b21DaGFuZ2UgcHJvcGVydHkgaXMgbWlzc2luZyBrZXlzIG9yIHNpZ25hdHVyZXMnKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleUluZGV4IG9mIFtLZXlJbmRpY2VzLlVTRVIsIEtleUluZGljZXMuQkFDS1VQLCBLZXlJbmRpY2VzLkJJVEdPXSkge1xuICAgICAgY29uc3Qga2V5Y2hhaW5Ub1ZlcmlmeSA9IHR4LmN1c3RvbUNoYW5nZS5rZXlzW2tleUluZGV4XTtcbiAgICAgIGNvbnN0IGtleVNpZ25hdHVyZSA9IHR4LmN1c3RvbUNoYW5nZS5zaWduYXR1cmVzW2tleUluZGV4XTtcbiAgICAgIGlmICgha2V5Y2hhaW5Ub1ZlcmlmeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgcmVxdWlyZWQgY3VzdG9tIGNoYW5nZSAke0tleUluZGljZXNba2V5SW5kZXhdLnRvTG93ZXJDYXNlKCl9IGtleWNoYWluIHB1YmxpYyBrZXlgKTtcbiAgICAgIH1cbiAgICAgIGlmICgha2V5U2lnbmF0dXJlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyByZXF1aXJlZCBjdXN0b20gY2hhbmdlICR7S2V5SW5kaWNlc1trZXlJbmRleF0udG9Mb3dlckNhc2UoKX0ga2V5Y2hhaW4gc2lnbmF0dXJlYCk7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgICF0aGlzLnZlcmlmeUtleVNpZ25hdHVyZSh7XG4gICAgICAgICAgdXNlcktleWNoYWluOiB1c2VyS2V5Y2hhaW4gYXMgeyBwdWI6IHN0cmluZyB9LFxuICAgICAgICAgIGtleWNoYWluVG9WZXJpZnk6IGtleWNoYWluVG9WZXJpZnkgYXMgeyBwdWI6IHN0cmluZyB9LFxuICAgICAgICAgIGtleVNpZ25hdHVyZSxcbiAgICAgICAgfSlcbiAgICAgICkge1xuICAgICAgICBkZWJ1ZygnZmFpbGVkIHRvIHZlcmlmeSBjdXN0b20gY2hhbmdlICVzIGtleSBzaWduYXR1cmUhJywgS2V5SW5kaWNlc1trZXlJbmRleF0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1heGltdW0gcGVyY2VudGFnZSBsaW1pdCBmb3IgcGF5LWFzLXlvdS1nbyBvdXRwdXRzXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYXlHb0xpbWl0KGFsbG93UGF5Z29PdXRwdXQ/OiBib29sZWFuKTogbnVtYmVyIHtcbiAgICAvLyBhbGxvd2luZyBwYXlnbyBvdXRwdXRzIG5lZWRzIHRvIGJlIHRoZSBkZWZhdWx0IGJlaGF2aW9yLCBzbyBvbmx5IGRpc2FsbG93IHBheWdvIG91dHB1dHMgaWYgdGhlXG4gICAgLy8gcmVsZXZhbnQgdmVyaWZpY2F0aW9uIG9wdGlvbiBpcyBib3RoIHNldCBhbmQgZmFsc2VcbiAgICBpZiAoIV8uaXNOaWwoYWxsb3dQYXlnb091dHB1dCkgJiYgIWFsbG93UGF5Z29PdXRwdXQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyAxNTAgYmFzaXMgcG9pbnRzIGlzIHRoZSBhYnNvbHV0ZSBwZXJtaXR0ZWQgbWF4aW11bSBpZiBwYXlnbyBvdXRwdXRzIGFyZSBhbGxvd2VkXG4gICAgcmV0dXJuIDAuMDE1O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGF0IGEgdHJhbnNhY3Rpb24gcHJlYnVpbGQgY29tcGxpZXMgd2l0aCB0aGUgb3JpZ2luYWwgaW50ZW50aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50eFBhcmFtcyBwYXJhbXMgb2JqZWN0IHBhc3NlZCB0byBzZW5kXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZCBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgc2VydmVyXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZC50eEhleCBwcmVidWlsdCB0cmFuc2FjdGlvbidzIHR4SGV4IGZvcm1cbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXQgV2FsbGV0IG9iamVjdCB0byBvYnRhaW4ga2V5cyB0byB2ZXJpZnkgYWdhaW5zdFxuICAgKiBAcGFyYW0gcGFyYW1zLnZlcmlmaWNhdGlvbiBPYmplY3Qgc3BlY2lmeWluZyBzb21lIHZlcmlmaWNhdGlvbiBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBwYXJhbXMudmVyaWZpY2F0aW9uLmRpc2FibGVOZXR3b3JraW5nIERpc2FsbG93IGZldGNoaW5nIGFueSBkYXRhIGZyb20gdGhlIGludGVybmV0IGZvciB2ZXJpZmljYXRpb24gcHVycG9zZXNcbiAgICogQHBhcmFtIHBhcmFtcy52ZXJpZmljYXRpb24ua2V5Y2hhaW5zIFBhc3Mga2V5Y2hhaW5zIG1hbnVhbGx5IHJhdGhlciB0aGFuIGZldGNoaW5nIHRoZW0gYnkgaWRcbiAgICogQHBhcmFtIHBhcmFtcy52ZXJpZmljYXRpb24uYWRkcmVzc2VzIEFkZHJlc3MgZGV0YWlscyB0byBwYXNzIGluIGZvciBvdXQtb2YtYmFuZCB2ZXJpZmljYXRpb25cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBhc3luYyB2ZXJpZnlUcmFuc2FjdGlvbjxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50ID0gbnVtYmVyPihcbiAgICBwYXJhbXM6IFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9uczxUTnVtYmVyPlxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCB7IHR4UGFyYW1zLCB0eFByZWJ1aWxkLCB3YWxsZXQsIHZlcmlmaWNhdGlvbiA9IHsgYWxsb3dQYXlnb091dHB1dDogdHJ1ZSB9LCByZXFJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGlzUHNidCA9IHR4UHJlYnVpbGQudHhIZXggJiYgYml0Z28uaXNQc2J0KHR4UHJlYnVpbGQudHhIZXgpO1xuICAgIGlmIChpc1BzYnQgJiYgdHhQcmVidWlsZC50eEluZm8/LnVuc3BlbnRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nob3VsZCBub3QgaGF2ZSB1bnNwZW50cyBpbiB0eEluZm8gZm9yIHBzYnQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBkaXNhYmxlTmV0d29ya2luZyA9ICEhdmVyaWZpY2F0aW9uLmRpc2FibGVOZXR3b3JraW5nO1xuICAgIGNvbnN0IHBhcnNlZFRyYW5zYWN0aW9uOiBQYXJzZWRUcmFuc2FjdGlvbjxUTnVtYmVyPiA9IGF3YWl0IHRoaXMucGFyc2VUcmFuc2FjdGlvbjxUTnVtYmVyPih7XG4gICAgICB0eFBhcmFtcyxcbiAgICAgIHR4UHJlYnVpbGQsXG4gICAgICB3YWxsZXQsXG4gICAgICB2ZXJpZmljYXRpb24sXG4gICAgICByZXFJZCxcbiAgICB9KTtcblxuICAgIGNvbnN0IGtleWNoYWlucyA9IHBhcnNlZFRyYW5zYWN0aW9uLmtleWNoYWlucztcblxuICAgIC8vIHZlcmlmeSB0aGF0IHRoZSBjbGFpbWVkIHVzZXIgcHVibGljIGtleSBjb3JyZXNwb25kcyB0byB0aGUgd2FsbGV0J3MgdXNlciBwcml2YXRlIGtleVxuICAgIGxldCB1c2VyUHVibGljS2V5VmVyaWZpZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgLy8gdmVyaWZ5IHRoZSB1c2VyIHB1YmxpYyBrZXkgbWF0Y2hlcyB0aGUgcHJpdmF0ZSBrZXkgLSB0aGlzIHdpbGwgdGhyb3cgaWYgdGhlcmUgaXMgbm8gbWF0Y2hcbiAgICAgIHVzZXJQdWJsaWNLZXlWZXJpZmllZCA9IHRoaXMudmVyaWZ5VXNlclB1YmxpY0tleSh7IHVzZXJLZXljaGFpbjoga2V5Y2hhaW5zLnVzZXIsIGRpc2FibGVOZXR3b3JraW5nLCB0eFBhcmFtcyB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygnZmFpbGVkIHRvIHZlcmlmeSB1c2VyIHB1YmxpYyBrZXkhJywgZSk7XG4gICAgfVxuXG4gICAgLy8gbGV0J3MgdmVyaWZ5IHRoZXNlIGtleWNoYWluc1xuICAgIGNvbnN0IGtleVNpZ25hdHVyZXMgPSBwYXJzZWRUcmFuc2FjdGlvbi5rZXlTaWduYXR1cmVzO1xuICAgIGlmICghXy5pc0VtcHR5KGtleVNpZ25hdHVyZXMpKSB7XG4gICAgICBjb25zdCB2ZXJpZnkgPSAoa2V5LCBwdWIpID0+IHtcbiAgICAgICAgaWYgKCFrZXljaGFpbnMudXNlciB8fCAha2V5Y2hhaW5zLnVzZXIucHViKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHVzZXIga2V5Y2hhaW4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlLZXlTaWduYXR1cmUoe1xuICAgICAgICAgIHVzZXJLZXljaGFpbjoga2V5Y2hhaW5zLnVzZXIgYXMgeyBwdWI6IHN0cmluZyB9LFxuICAgICAgICAgIGtleWNoYWluVG9WZXJpZnk6IGtleSxcbiAgICAgICAgICBrZXlTaWduYXR1cmU6IHB1YixcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNCYWNrdXBLZXlTaWduYXR1cmVWYWxpZCA9IHZlcmlmeShrZXljaGFpbnMuYmFja3VwLCBrZXlTaWduYXR1cmVzLmJhY2t1cFB1Yik7XG4gICAgICBjb25zdCBpc0JpdGdvS2V5U2lnbmF0dXJlVmFsaWQgPSB2ZXJpZnkoa2V5Y2hhaW5zLmJpdGdvLCBrZXlTaWduYXR1cmVzLmJpdGdvUHViKTtcbiAgICAgIGlmICghaXNCYWNrdXBLZXlTaWduYXR1cmVWYWxpZCB8fCAhaXNCaXRnb0tleVNpZ25hdHVyZVZhbGlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kYXJ5IHB1YmxpYyBrZXkgc2lnbmF0dXJlcyBpbnZhbGlkJyk7XG4gICAgICB9XG4gICAgICBkZWJ1Zygnc3VjY2Vzc2Z1bGx5IHZlcmlmaWVkIGJhY2t1cCBhbmQgYml0Z28ga2V5IHNpZ25hdHVyZXMnKTtcbiAgICB9IGVsc2UgaWYgKCFkaXNhYmxlTmV0d29ya2luZykge1xuICAgICAgLy8gdGhlc2Uga2V5cyB3ZXJlIG9idGFpbmVkIG9ubGluZSBhbmQgdGhlaXIgc2lnbmF0dXJlcyB3ZXJlIG5vdCB2ZXJpZmllZFxuICAgICAgLy8gdGhpcyBjb3VsZCBiZSBkYW5nZXJvdXNcbiAgICAgIGNvbnNvbGUubG9nKCd1bnNpZ25lZCBrZXlzIG9idGFpbmVkIG9ubGluZSBhcmUgYmVpbmcgdXNlZCBmb3IgYWRkcmVzcyB2ZXJpZmljYXRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAocGFyc2VkVHJhbnNhY3Rpb24ubmVlZHNDdXN0b21DaGFuZ2VLZXlTaWduYXR1cmVWZXJpZmljYXRpb24pIHtcbiAgICAgIGlmICgha2V5Y2hhaW5zLnVzZXIgfHwgIXVzZXJQdWJsaWNLZXlWZXJpZmllZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHJlcXVpcmVzIHZlcmlmaWNhdGlvbiBvZiB1c2VyIHB1YmxpYyBrZXksIGJ1dCBpdCB3YXMgdW5hYmxlIHRvIGJlIHZlcmlmaWVkJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXN0b21DaGFuZ2VLZXlTaWduYXR1cmVzVmVyaWZpZWQgPSB0aGlzLnZlcmlmeUN1c3RvbUNoYW5nZUtleVNpZ25hdHVyZXMocGFyc2VkVHJhbnNhY3Rpb24sIGtleWNoYWlucy51c2VyKTtcbiAgICAgIGlmICghY3VzdG9tQ2hhbmdlS2V5U2lnbmF0dXJlc1ZlcmlmaWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAndHJhbnNhY3Rpb24gcmVxdWlyZXMgdmVyaWZpY2F0aW9uIG9mIGN1c3RvbSBjaGFuZ2Uga2V5IHNpZ25hdHVyZXMsIGJ1dCB0aGV5IHdlcmUgdW5hYmxlIHRvIGJlIHZlcmlmaWVkJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVidWcoJ3N1Y2Nlc3NmdWxseSB2ZXJpZmllZCB1c2VyIHB1YmxpYyBrZXkgYW5kIGN1c3RvbSBjaGFuZ2Uga2V5IHNpZ25hdHVyZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBtaXNzaW5nT3V0cHV0cyA9IHBhcnNlZFRyYW5zYWN0aW9uLm1pc3NpbmdPdXRwdXRzO1xuICAgIGlmIChtaXNzaW5nT3V0cHV0cy5sZW5ndGggIT09IDApIHtcbiAgICAgIC8vIHRoZXJlIGFyZSBzb21lIG91dHB1dHMgaW4gdGhlIHJlY2lwaWVudHMgbGlzdCB0aGF0IGhhdmUgbm90IG1hZGUgaXQgaW50byB0aGUgYWN0dWFsIHRyYW5zYWN0aW9uXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIG91dHB1dHMgbWlzc2luZyBpbiB0cmFuc2FjdGlvbiBwcmVidWlsZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGludGVuZGVkRXh0ZXJuYWxTcGVuZCA9IHBhcnNlZFRyYW5zYWN0aW9uLmV4cGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudDtcblxuICAgIC8vIHRoaXMgaXMgYSBsaW1pdCB3ZSBpbXBvc2UgZm9yIHRoZSB0b3RhbCB2YWx1ZSB0aGF0IGlzIGFtZW5kZWQgdG8gdGhlIHRyYW5zYWN0aW9uIGJleW9uZCB3aGF0IHdhcyBvcmlnaW5hbGx5IGludGVuZGVkXG4gICAgY29uc3QgcGF5QXNZb3VHb0xpbWl0ID0gbmV3IEJpZ051bWJlcih0aGlzLmdldFBheUdvTGltaXQodmVyaWZpY2F0aW9uLmFsbG93UGF5Z29PdXRwdXQpKS5tdWx0aXBsaWVkQnkoXG4gICAgICBpbnRlbmRlZEV4dGVybmFsU3BlbmQudG9TdHJpbmcoKVxuICAgICk7XG5cbiAgICAvKlxuICAgIFNvbWUgZXhwbGFuYXRpb24gZm9yIHdoeSB3ZSdyZSBkb2luZyB3aGF0IHdlJ3JlIGRvaW5nOlxuICAgIFNvbWUgY3VzdG9tZXJzIHdpbGwgaGF2ZSBhbiBvdXRwdXQgdG8gQml0R28ncyBQQVlHbyB3YWxsZXQgYWRkZWQgdG8gdGhlaXIgdHJhbnNhY3Rpb24sIGFuZCB3ZSBuZWVkIHRvIGFjY291bnQgZm9yXG4gICAgaXQgaGVyZS4gVG8gcHJvdGVjdCBzb21lb25lIHRhbXBlcmluZyB3aXRoIHRoZSBvdXRwdXQgdG8gbWFrZSBpdCBzZW5kIG1vcmUgdGhhbiBpdCBzaG91bGQgdG8gQml0R28sIHdlIGRlZmluZSBhXG4gICAgdGhyZXNob2xkIGZvciB0aGUgb3V0cHV0J3MgdmFsdWUgYWJvdmUgd2hpY2ggd2UnbGwgdGhyb3cgYW4gZXJyb3IsIGJlY2F1c2UgdGhlIHBheWdvIG91dHB1dCBzaG91bGQgbmV2ZXIgYmUgdGhhdFxuICAgIGhpZ2guXG4gICAgICovXG5cbiAgICAvLyBtYWtlIHN1cmUgdGhhdCBhbGwgdGhlIGV4dHJhIGFkZHJlc3NlcyBhcmUgY2hhbmdlIGFkZHJlc3Nlc1xuICAgIC8vIGdldCBhbGwgdGhlIGFkZGl0aW9uYWwgZXh0ZXJuYWwgb3V0cHV0cyB0aGUgc2VydmVyIGFkZGVkIGFuZCBjYWxjdWxhdGUgdGhlaXIgdmFsdWVzXG4gICAgY29uc3Qgbm9uQ2hhbmdlQW1vdW50ID0gbmV3IEJpZ051bWJlcihwYXJzZWRUcmFuc2FjdGlvbi5pbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQudG9TdHJpbmcoKSk7XG5cbiAgICBkZWJ1ZyhcbiAgICAgICdJbnRlbmRlZCBzcGVuZCBpcyAlcywgTm9uLWNoYW5nZSBhbW91bnQgaXMgJXMsIHBheWdvIGxpbWl0IGlzICVzJyxcbiAgICAgIGludGVuZGVkRXh0ZXJuYWxTcGVuZC50b1N0cmluZygpLFxuICAgICAgbm9uQ2hhbmdlQW1vdW50LnRvU3RyaW5nKCksXG4gICAgICBwYXlBc1lvdUdvTGltaXQudG9TdHJpbmcoKVxuICAgICk7XG4gICAgLy8gdGhlIGFkZGl0aW9uYWwgZXh0ZXJuYWwgb3V0cHV0cyBjYW4gb25seSBiZSBCaXRHbydzIHBheS1hcy15b3UtZ28gZmVlLCBidXQgd2UgY2Fubm90IHZlcmlmeSB0aGUgd2FsbGV0IGFkZHJlc3NcbiAgICBpZiAobm9uQ2hhbmdlQW1vdW50Lmd0KHBheUFzWW91R29MaW1pdCkpIHtcbiAgICAgIC8vIHRoZXJlIGFyZSBzb21lIGFkZHJlc3NlcyB0aGF0IGFyZSBvdXRzaWRlIHRoZSBzY29wZSBvZiBpbnRlbmRlZCByZWNpcGllbnRzIHRoYXQgYXJlIG5vdCBjaGFuZ2UgYWRkcmVzc2VzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZWJ1aWxkIGF0dGVtcHRzIHRvIHNwZW5kIHRvIHVuaW50ZW5kZWQgZXh0ZXJuYWwgcmVjaXBpZW50cycpO1xuICAgIH1cblxuICAgIGNvbnN0IGFsbE91dHB1dHMgPSBwYXJzZWRUcmFuc2FjdGlvbi5vdXRwdXRzO1xuICAgIGlmICghdHhQcmVidWlsZC50eEhleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eFByZWJ1aWxkLnR4SGV4IG5vdCBzZXRgKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRzID0gaXNQc2J0XG4gICAgICA/IGdldFBzYnRUeElucHV0cyh0eFByZWJ1aWxkLnR4SGV4LCB0aGlzLm5ldHdvcmspLm1hcCgodikgPT4gKHtcbiAgICAgICAgICAuLi52LFxuICAgICAgICAgIHZhbHVlOiBiaXRnby50b1ROdW1iZXIodi52YWx1ZSwgdGhpcy5hbW91bnRUeXBlKSxcbiAgICAgICAgfSkpXG4gICAgICA6IGF3YWl0IGdldFR4SW5wdXRzKHsgdHhQcmVidWlsZCwgYml0Z286IHRoaXMuYml0Z28sIGNvaW46IHRoaXMsIGRpc2FibGVOZXR3b3JraW5nLCByZXFJZCB9KTtcbiAgICAvLyBjb2lucyAoZG9nZSkgdGhhdCBjYW4gZXhjZWVkIG51bWJlciBsaW1pdHMgKGFuZCB0aHVzIHdpbGwgdXNlIGJpZ2ludCkgd2lsbCBoYXZlIHRoZSBgdmFsdWVTdHJpbmdgIGZpZWxkXG4gICAgY29uc3QgaW5wdXRBbW91bnQgPSBpbnB1dHMucmVkdWNlKFxuICAgICAgKHN1bTogYmlnaW50LCBpKSA9PiBzdW0gKyBCaWdJbnQodGhpcy5hbW91bnRUeXBlID09PSAnYmlnaW50JyA/IGkudmFsdWVTdHJpbmcgOiBpLnZhbHVlKSxcbiAgICAgIEJpZ0ludCgwKVxuICAgICk7XG4gICAgY29uc3Qgb3V0cHV0QW1vdW50ID0gYWxsT3V0cHV0cy5yZWR1Y2UoKHN1bTogYmlnaW50LCBvOiBPdXRwdXQpID0+IHN1bSArIEJpZ0ludChvLmFtb3VudCksIEJpZ0ludCgwKSk7XG4gICAgY29uc3QgZmVlID0gaW5wdXRBbW91bnQgLSBvdXRwdXRBbW91bnQ7XG5cbiAgICBpZiAoZmVlIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgYXR0ZW1wdGluZyB0byBzcGVuZCAke291dHB1dEFtb3VudH0gc2F0b3NoaXMsIHdoaWNoIGV4Y2VlZHMgdGhlIGlucHV0IGFtb3VudCAoJHtpbnB1dEFtb3VudH0gc2F0b3NoaXMpIGJ5ICR7LWZlZX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2Ugc3VyZSBhbiBhZGRyZXNzIGlzIHZhbGlkIGFuZCB0aHJvdyBhbiBlcnJvciBpZiBpdCdzIG5vdC5cbiAgICogQHBhcmFtIHBhcmFtcy5hZGRyZXNzIFRoZSBhZGRyZXNzIHN0cmluZyBvbiB0aGUgbmV0d29ya1xuICAgKiBAcGFyYW0gcGFyYW1zLmFkZHJlc3NUeXBlXG4gICAqIEBwYXJhbSBwYXJhbXMua2V5Y2hhaW5zIEtleWNoYWluIG9iamVjdHMgd2l0aCB4cHVic1xuICAgKiBAcGFyYW0gcGFyYW1zLmNvaW5TcGVjaWZpYyBDb2luLXNwZWNpZmljIGRldGFpbHMgZm9yIHRoZSBhZGRyZXNzIHN1Y2ggYXMgYSB3aXRuZXNzIHNjcmlwdFxuICAgKiBAcGFyYW0gcGFyYW1zLmNoYWluIERlcml2YXRpb24gY2hhaW5cbiAgICogQHBhcmFtIHBhcmFtcy5pbmRleCBEZXJpdmF0aW9uIGluZGV4XG4gICAqIEB0aHJvd3Mge0ludmFsaWRBZGRyZXNzRXJyb3J9XG4gICAqIEB0aHJvd3Mge0ludmFsaWRBZGRyZXNzRGVyaXZhdGlvblByb3BlcnR5RXJyb3J9XG4gICAqIEB0aHJvd3Mge1VuZXhwZWN0ZWRBZGRyZXNzRXJyb3J9XG4gICAqL1xuICBhc3luYyBpc1dhbGxldEFkZHJlc3MocGFyYW1zOiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHsgYWRkcmVzcywgYWRkcmVzc1R5cGUsIGtleWNoYWlucywgY29pblNwZWNpZmljLCBjaGFpbiwgaW5kZXggfSA9IHBhcmFtcztcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGlmICgoXy5pc1VuZGVmaW5lZChjaGFpbikgJiYgXy5pc1VuZGVmaW5lZChpbmRleCkpIHx8ICEoXy5pc0Zpbml0ZShjaGFpbikgJiYgXy5pc0Zpbml0ZShpbmRleCkpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NEZXJpdmF0aW9uUHJvcGVydHlFcnJvcihcbiAgICAgICAgYGFkZHJlc3MgdmFsaWRhdGlvbiBmYWlsdXJlOiBpbnZhbGlkIGNoYWluICgke2NoYWlufSkgb3IgaW5kZXggKCR7aW5kZXh9KWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzT2JqZWN0KGNvaW5TcGVjaWZpYykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc1ZlcmlmaWNhdGlvbk9iamVjdFByb3BlcnR5RXJyb3IoXG4gICAgICAgICdhZGRyZXNzIHZhbGlkYXRpb24gZmFpbHVyZTogY29pblNwZWNpZmljIGZpZWxkIG11c3QgYmUgYW4gb2JqZWN0J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWtleWNoYWlucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHBhcmFtIGtleWNoYWlucycpO1xuICAgIH1cblxuICAgIGNvbnN0IGV4cGVjdGVkQWRkcmVzcyA9IHRoaXMuZ2VuZXJhdGVBZGRyZXNzKHtcbiAgICAgIGFkZHJlc3NUeXBlOiBhZGRyZXNzVHlwZSBhcyBTY3JpcHRUeXBlMk9mMyxcbiAgICAgIGtleWNoYWlucyxcbiAgICAgIHRocmVzaG9sZDogMixcbiAgICAgIGNoYWluLFxuICAgICAgaW5kZXgsXG4gICAgfSk7XG5cbiAgICBpZiAoZXhwZWN0ZWRBZGRyZXNzLmFkZHJlc3MgIT09IGFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yKFxuICAgICAgICBgYWRkcmVzcyB2YWxpZGF0aW9uIGZhaWx1cmU6IGV4cGVjdGVkICR7ZXhwZWN0ZWRBZGRyZXNzLmFkZHJlc3N9IGJ1dCBnb3QgJHthZGRyZXNzfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgY29pbiBzdXBwb3J0cyBhIGJsb2NrIHRhcmdldFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN1cHBvcnRzQmxvY2tUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGFkZHJlc3NUeXBlXG4gICAqIEByZXR1cm5zIHRydWUgaWZmIGNvaW4gc3VwcG9ydHMgc3BlbmRpbmcgZnJvbSB1bnNwZW50VHlwZVxuICAgKi9cbiAgc3VwcG9ydHNBZGRyZXNzVHlwZShhZGRyZXNzVHlwZTogU2NyaXB0VHlwZTJPZjMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdXR4b2xpYi5iaXRnby5vdXRwdXRTY3JpcHRzLmlzU3VwcG9ydGVkU2NyaXB0VHlwZSh0aGlzLm5ldHdvcmssIGFkZHJlc3NUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gY2hhaW5cbiAgICogQHJldHVybiB0cnVlIGlmZiBjb2luIHN1cHBvcnRzIHNwZW5kaW5nIGZyb20gY2hhaW5cbiAgICovXG4gIHN1cHBvcnRzQWRkcmVzc0NoYWluKGNoYWluOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNDaGFpbkNvZGUoY2hhaW4pICYmIHRoaXMuc3VwcG9ydHNBZGRyZXNzVHlwZSh1dHhvbGliLmJpdGdvLnNjcmlwdFR5cGVGb3JDaGFpbihjaGFpbikpO1xuICB9XG5cbiAga2V5SWRzRm9yU2lnbmluZygpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIFtLZXlJbmRpY2VzLlVTRVIsIEtleUluZGljZXMuQkFDS1VQLCBLZXlJbmRpY2VzLkJJVEdPXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPKEJHLTExNDg3KTogUmVtb3ZlIGFkZHJlc3NUeXBlLCBzZWd3aXQsIGFuZCBiZWNoMzIgcGFyYW1zIGluIFNES3Y2XG4gICAqIEdlbmVyYXRlIGFuIGFkZHJlc3MgZm9yIGEgd2FsbGV0IGJhc2VkIG9uIGEgc2V0IG9mIGNvbmZpZ3VyYXRpb25zXG4gICAqIEBwYXJhbSBwYXJhbXMuYWRkcmVzc1R5cGUge3N0cmluZ30gICBEZXByZWNhdGVkXG4gICAqIEBwYXJhbSBwYXJhbXMua2V5Y2hhaW5zICAge1tvYmplY3RdfSBBcnJheSBvZiBvYmplY3RzIHdpdGggeHB1YnNcbiAgICogQHBhcmFtIHBhcmFtcy50aHJlc2hvbGQgICB7bnVtYmVyfSAgIE1pbmltdW0gbnVtYmVyIG9mIHNpZ25hdHVyZXNcbiAgICogQHBhcmFtIHBhcmFtcy5jaGFpbiAgICAgICB7bnVtYmVyfSAgIERlcml2YXRpb24gY2hhaW4gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vQml0R28vdW5zcGVudHMvYmxvYi9tYXN0ZXIvc3JjL2NvZGVzLnRzIGZvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY29ycmVzcG9uZGluZyBhZGRyZXNzIHR5cGUgb2YgYSBnaXZlbiBjaGFpbiBjb2RlKVxuICAgKiBAcGFyYW0gcGFyYW1zLmluZGV4ICAgICAgIHtudW1iZXJ9ICAgRGVyaXZhdGlvbiBpbmRleFxuICAgKiBAcGFyYW0gcGFyYW1zLnNlZ3dpdCAgICAgIHtib29sZWFufSAgRGVwcmVjYXRlZFxuICAgKiBAcGFyYW0gcGFyYW1zLmJlY2gzMiAgICAgIHtib29sZWFufSAgRGVwcmVjYXRlZFxuICAgKiBAcmV0dXJucyB7e2NoYWluOiBudW1iZXIsIGluZGV4OiBudW1iZXIsIGNvaW46IG51bWJlciwgY29pblNwZWNpZmljOiB7b3V0cHV0U2NyaXB0LCByZWRlZW1TY3JpcHR9fX1cbiAgICovXG4gIGdlbmVyYXRlQWRkcmVzcyhwYXJhbXM6IEdlbmVyYXRlQWRkcmVzc09wdGlvbnMpOiBBZGRyZXNzRGV0YWlscyB7XG4gICAgY29uc3QgeyBrZXljaGFpbnMsIHRocmVzaG9sZCwgY2hhaW4sIGluZGV4LCBzZWd3aXQgPSBmYWxzZSwgYmVjaDMyID0gZmFsc2UgfSA9IHBhcmFtcztcbiAgICBsZXQgZGVyaXZhdGlvbkNoYWluID0gZ2V0RXh0ZXJuYWxDaGFpbkNvZGUoJ3Ayc2gnKTtcbiAgICBpZiAoXy5pc051bWJlcihjaGFpbikgJiYgXy5pc0ludGVnZXIoY2hhaW4pICYmIGlzQ2hhaW5Db2RlKGNoYWluKSkge1xuICAgICAgZGVyaXZhdGlvbkNoYWluID0gY2hhaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydEZsYWdzVG9BZGRyZXNzVHlwZSgpOiBTY3JpcHRUeXBlMk9mMyB7XG4gICAgICBpZiAoaXNDaGFpbkNvZGUoY2hhaW4pKSB7XG4gICAgICAgIHJldHVybiB1dHhvbGliLmJpdGdvLnNjcmlwdFR5cGVGb3JDaGFpbihjaGFpbik7XG4gICAgICB9XG4gICAgICBpZiAoXy5pc0Jvb2xlYW4oc2Vnd2l0KSAmJiBzZWd3aXQpIHtcbiAgICAgICAgcmV0dXJuICdwMnNoUDJ3c2gnO1xuICAgICAgfSBlbHNlIGlmIChfLmlzQm9vbGVhbihiZWNoMzIpICYmIGJlY2gzMikge1xuICAgICAgICByZXR1cm4gJ3Ayd3NoJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAncDJzaCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYWRkcmVzc1R5cGUgPSBwYXJhbXMuYWRkcmVzc1R5cGUgfHwgY29udmVydEZsYWdzVG9BZGRyZXNzVHlwZSgpO1xuXG4gICAgaWYgKGFkZHJlc3NUeXBlICE9PSB1dHhvbGliLmJpdGdvLnNjcmlwdFR5cGVGb3JDaGFpbihkZXJpdmF0aW9uQ2hhaW4pKSB7XG4gICAgICB0aHJvdyBuZXcgQWRkcmVzc1R5cGVDaGFpbk1pc21hdGNoRXJyb3IoYWRkcmVzc1R5cGUsIGRlcml2YXRpb25DaGFpbik7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzQWRkcmVzc1R5cGUoYWRkcmVzc1R5cGUpKSB7XG4gICAgICBzd2l0Y2ggKGFkZHJlc3NUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3Ayc2gnOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW50ZXJuYWwgZXJyb3I6IHAyc2ggc2hvdWxkIGFsd2F5cyBiZSBzdXBwb3J0ZWRgKTtcbiAgICAgICAgY2FzZSAncDJzaFAyd3NoJzpcbiAgICAgICAgICB0aHJvdyBuZXcgUDJzaFAyd3NoVW5zdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICBjYXNlICdwMndzaCc6XG4gICAgICAgICAgdGhyb3cgbmV3IFAyd3NoVW5zdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICBjYXNlICdwMnRyJzpcbiAgICAgICAgICB0aHJvdyBuZXcgUDJ0clVuc3VwcG9ydGVkRXJyb3IoKTtcbiAgICAgICAgY2FzZSAncDJ0ck11c2lnMic6XG4gICAgICAgICAgdGhyb3cgbmV3IFAydHJNdXNpZzJVbnN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkQWRkcmVzc1R5cGVFcnJvcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzaWduYXR1cmVUaHJlc2hvbGQgPSAyO1xuICAgIGlmIChfLmlzSW50ZWdlcih0aHJlc2hvbGQpKSB7XG4gICAgICBzaWduYXR1cmVUaHJlc2hvbGQgPSB0aHJlc2hvbGQgYXMgbnVtYmVyO1xuICAgICAgaWYgKHNpZ25hdHVyZVRocmVzaG9sZCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndGhyZXNob2xkIGhhcyB0byBiZSBwb3NpdGl2ZScpO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25hdHVyZVRocmVzaG9sZCA+IGtleWNoYWlucy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aHJlc2hvbGQgY2Fubm90IGV4Y2VlZCBudW1iZXIgb2Yga2V5cycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBkZXJpdmF0aW9uSW5kZXggPSAwO1xuICAgIGlmIChfLmlzSW50ZWdlcihpbmRleCkgJiYgKGluZGV4IGFzIG51bWJlcikgPiAwKSB7XG4gICAgICBkZXJpdmF0aW9uSW5kZXggPSBpbmRleCBhcyBudW1iZXI7XG4gICAgfVxuXG4gICAgY29uc3QgcGF0aCA9ICcwLzAvJyArIGRlcml2YXRpb25DaGFpbiArICcvJyArIGRlcml2YXRpb25JbmRleDtcbiAgICBjb25zdCBoZE5vZGVzID0ga2V5Y2hhaW5zLm1hcCgoeyBwdWIgfSkgPT4gYmlwMzIuZnJvbUJhc2U1OChwdWIpKTtcbiAgICBjb25zdCBkZXJpdmVkS2V5cyA9IGhkTm9kZXMubWFwKChoZE5vZGUpID0+IGhkTm9kZS5kZXJpdmVQYXRoKHNhbml0aXplTGVnYWN5UGF0aChwYXRoKSkucHVibGljS2V5KTtcblxuICAgIGNvbnN0IHsgb3V0cHV0U2NyaXB0LCByZWRlZW1TY3JpcHQsIHdpdG5lc3NTY3JpcHQsIGFkZHJlc3MgfSA9IHRoaXMuY3JlYXRlTXVsdGlTaWdBZGRyZXNzKFxuICAgICAgYWRkcmVzc1R5cGUsXG4gICAgICBzaWduYXR1cmVUaHJlc2hvbGQsXG4gICAgICBkZXJpdmVkS2V5c1xuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzcyxcbiAgICAgIGNoYWluOiBkZXJpdmF0aW9uQ2hhaW4sXG4gICAgICBpbmRleDogZGVyaXZhdGlvbkluZGV4LFxuICAgICAgY29pbjogdGhpcy5nZXRDaGFpbigpLFxuICAgICAgY29pblNwZWNpZmljOiB7XG4gICAgICAgIG91dHB1dFNjcmlwdDogb3V0cHV0U2NyaXB0LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgcmVkZWVtU2NyaXB0OiByZWRlZW1TY3JpcHQgJiYgcmVkZWVtU2NyaXB0LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgd2l0bmVzc1NjcmlwdDogd2l0bmVzc1NjcmlwdCAmJiB3aXRuZXNzU2NyaXB0LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIH0sXG4gICAgICBhZGRyZXNzVHlwZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIGlucHV0IHBzYnQgYWRkZWQgd2l0aCBkZXRlcm1pbmlzdGljIE11U2lnMiBub25jZSBmb3IgYml0Z28ga2V5IGZvciBlYWNoIE11U2lnMiBpbnB1dHMuXG4gICAqIEBwYXJhbSBwc2J0SGV4IGFsbCBNdVNpZzIgaW5wdXRzIHNob3VsZCBjb250YWluIHVzZXIgTXVTaWcyIG5vbmNlXG4gICAqIEBwYXJhbSB3YWxsZXRJZFxuICAgKi9cbiAgYXN5bmMgc2lnblBzYnQocHNidEhleDogc3RyaW5nLCB3YWxsZXRJZDogc3RyaW5nKTogUHJvbWlzZTxTaWduUHNidFJlc3BvbnNlPiB7XG4gICAgY29uc3QgcGFyYW1zOiBTaWduUHNidFJlcXVlc3QgPSB7IHBzYnQ6IHBzYnRIZXggfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgLnBvc3QodGhpcy51cmwoJy93YWxsZXQvJyArIHdhbGxldElkICsgJy90eC9zaWducHNidCcpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIGlucHV0IHBzYnQgYWRkZWQgd2l0aCBkZXRlcm1pbmlzdGljIE11U2lnMiBub25jZSBmb3IgYml0Z28ga2V5IGZvciBlYWNoIE11U2lnMiBpbnB1dHMgZnJvbSBPVkMuXG4gICAqIEBwYXJhbSBvdmNKc29uIEpTT04gb2JqZWN0IHByb3ZpZGVkIGJ5IE9WQyB3aXRoIGZpZWxkcyBwc2J0SGV4IGFuZCB3YWxsZXRJZFxuICAgKi9cbiAgYXN5bmMgc2lnblBzYnRGcm9tT1ZDKG92Y0pzb246IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4ge1xuICAgIGFzc2VydChvdmNKc29uWydwc2J0SGV4J10sICdvdmNKc29uIG11c3QgY29udGFpbiBwc2J0SGV4Jyk7XG4gICAgYXNzZXJ0KG92Y0pzb25bJ3dhbGxldElkJ10sICdvdmNKc29uIG11c3QgY29udGFpbiB3YWxsZXRJZCcpO1xuICAgIGNvbnN0IHBzYnQgPSAoYXdhaXQgdGhpcy5zaWduUHNidChvdmNKc29uWydwc2J0SGV4J10gYXMgc3RyaW5nLCBvdmNKc29uWyd3YWxsZXRJZCddIGFzIHN0cmluZykpLnBzYnQ7XG4gICAgYXNzZXJ0KHBzYnQsICdwc2J0IG5vdCBmb3VuZCcpO1xuICAgIHJldHVybiBfLmV4dGVuZChvdmNKc29uLCB7IHR4SGV4OiBwc2J0IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VtYmxlIGtleWNoYWluIGFuZCBoYWxmLXNpZ24gcHJlYnVpbHQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtcyAtIHtAc2VlIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnN9XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uIHwgSGFsZlNpZ25lZFV0eG9UcmFuc2FjdGlvbj59XG4gICAqL1xuICBhc3luYyBzaWduVHJhbnNhY3Rpb248VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludCA9IG51bWJlcj4oXG4gICAgcGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zPFROdW1iZXI+XG4gICk6IFByb21pc2U8U2lnbmVkVHJhbnNhY3Rpb24gfCBIYWxmU2lnbmVkVXR4b1RyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgdHhQcmVidWlsZCA9IHBhcmFtcy50eFByZWJ1aWxkO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodHhQcmVidWlsZCkgfHwgIV8uaXNPYmplY3QodHhQcmVidWlsZCkpIHtcbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh0eFByZWJ1aWxkKSAmJiAhXy5pc09iamVjdCh0eFByZWJ1aWxkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHR4UHJlYnVpbGQgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCB0eXBlICR7dHlwZW9mIHR4UHJlYnVpbGR9YCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdHhQcmVidWlsZCBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICBsZXQgdHggPSBiaXRnby5pc1BzYnQodHhQcmVidWlsZC50eEhleClcbiAgICAgID8gYml0Z28uY3JlYXRlUHNidEZyb21IZXgodHhQcmVidWlsZC50eEhleCwgdGhpcy5uZXR3b3JrKVxuICAgICAgOiB0aGlzLmNyZWF0ZVRyYW5zYWN0aW9uRnJvbUhleDxUTnVtYmVyPih0eFByZWJ1aWxkLnR4SGV4KTtcblxuICAgIGNvbnN0IGlzVHhXaXRoS2V5UGF0aFNwZW5kSW5wdXQgPSB0eCBpbnN0YW5jZW9mIGJpdGdvLlV0eG9Qc2J0ICYmIGJpdGdvLmlzVHJhbnNhY3Rpb25XaXRoS2V5UGF0aFNwZW5kSW5wdXQodHgpO1xuXG4gICAgbGV0IGlzTGFzdFNpZ25hdHVyZSA9IGZhbHNlO1xuICAgIGlmIChfLmlzQm9vbGVhbihwYXJhbXMuaXNMYXN0U2lnbmF0dXJlKSkge1xuICAgICAgLy8gV2UgY2FuIG9ubHkgYmUgdGhlIGZpcnN0IHNpZ25hdHVyZSBvbiBhIHRyYW5zYWN0aW9uIHdpdGggdGFwcm9vdCBrZXkgcGF0aCBzcGVuZCBpbnB1dHMgYmVjYXVzZVxuICAgICAgLy8gd2UgcmVxdWlyZSB0aGUgc2VjcmV0IG5vbmNlIGluIHRoZSBjYWNoZSBvZiB0aGUgZmlyc3Qgc2lnbmVyLCB3aGljaCBpcyBpbXBvc3NpYmxlIHRvIHJldHJpZXZlIGlmXG4gICAgICAvLyBkZXNlcmlhbGl6ZWQgZnJvbSBhIGhleC5cbiAgICAgIGlmIChwYXJhbXMuaXNMYXN0U2lnbmF0dXJlICYmIGlzVHhXaXRoS2V5UGF0aFNwZW5kSW5wdXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYmUgbGFzdCBzaWduYXR1cmUgb24gYSB0cmFuc2FjdGlvbiB3aXRoIGtleSBwYXRoIHNwZW5kIGlucHV0cycpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBidWlsZCBpcyBjYWxsZWQgaW5zdGVhZCBvZiBidWlsZEluY29tcGxldGUsIG5vIHNpZ25hdHVyZSBwbGFjZWhvbGRlcnMgYXJlIGxlZnQgaW4gdGhlIHNpZyBzY3JpcHRcbiAgICAgIGlzTGFzdFNpZ25hdHVyZSA9IHBhcmFtcy5pc0xhc3RTaWduYXR1cmU7XG4gICAgfVxuXG4gICAgY29uc3QgZ2V0U2lnbmVyS2V5Y2hhaW4gPSAoKTogdXR4b2xpYi5CSVAzMkludGVyZmFjZSA9PiB7XG4gICAgICBjb25zdCB1c2VyUHJ2ID0gcGFyYW1zLnBydjtcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHVzZXJQcnYpIHx8ICFfLmlzU3RyaW5nKHVzZXJQcnYpKSB7XG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh1c2VyUHJ2KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJ2IG11c3QgYmUgYSBzdHJpbmcsIGdvdCB0eXBlICR7dHlwZW9mIHVzZXJQcnZ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBydiBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmVyS2V5Y2hhaW4gPSBiaXAzMi5mcm9tQmFzZTU4KHVzZXJQcnYsIHV0eG9saWIubmV0d29ya3MuYml0Y29pbik7XG4gICAgICBpZiAoc2lnbmVyS2V5Y2hhaW4uaXNOZXV0ZXJlZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgdXNlciBwcml2YXRlIGtleSBidXQgcmVjZWl2ZWQgcHVibGljIGtleScpO1xuICAgICAgfVxuICAgICAgZGVidWcoYEhlcmUgaXMgdGhlIHB1YmxpYyBrZXkgb2YgdGhlIHhwcnYgeW91IHVzZWQgdG8gc2lnbjogJHtzaWduZXJLZXljaGFpbi5uZXV0ZXJlZCgpLnRvQmFzZTU4KCl9YCk7XG4gICAgICByZXR1cm4gc2lnbmVyS2V5Y2hhaW47XG4gICAgfTtcblxuICAgIGNvbnN0IHNldFNpZ25lck11c2lnTm9uY2VXaXRoT3ZlcnJpZGUgPSAoXG4gICAgICBwc2J0OiB1dHhvbGliLmJpdGdvLlV0eG9Qc2J0LFxuICAgICAgc2lnbmVyS2V5Y2hhaW46IHV0eG9saWIuQklQMzJJbnRlcmZhY2UsXG4gICAgICBub25TZWd3aXRPdmVycmlkZTogYm9vbGVhblxuICAgICkgPT4ge1xuICAgICAgdXR4b2xpYi5iaXRnby53aXRoVW5zYWZlTm9uU2Vnd2l0KHBzYnQsICgpID0+IHBzYnQuc2V0QWxsSW5wdXRzTXVzaWcyTm9uY2VIRChzaWduZXJLZXljaGFpbiksIG5vblNlZ3dpdE92ZXJyaWRlKTtcbiAgICB9O1xuXG4gICAgbGV0IHNpZ25lcktleWNoYWluOiB1dHhvbGliLkJJUDMySW50ZXJmYWNlIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKHR4IGluc3RhbmNlb2YgYml0Z28uVXR4b1BzYnQgJiYgaXNUeFdpdGhLZXlQYXRoU3BlbmRJbnB1dCkge1xuICAgICAgc3dpdGNoIChwYXJhbXMuc2lnbmluZ1N0ZXApIHtcbiAgICAgICAgY2FzZSAnc2lnbmVyTm9uY2UnOlxuICAgICAgICAgIHNpZ25lcktleWNoYWluID0gZ2V0U2lnbmVyS2V5Y2hhaW4oKTtcbiAgICAgICAgICBzZXRTaWduZXJNdXNpZ05vbmNlV2l0aE92ZXJyaWRlKHR4LCBzaWduZXJLZXljaGFpbiwgISFwYXJhbXMuYWxsb3dOb25TZWd3aXRTaWduaW5nV2l0aG91dFByZXZUeCk7XG4gICAgICAgICAgQWJzdHJhY3RVdHhvQ29pbi5QU0JUX0NBQ0hFLnNldCh0eC5nZXRVbnNpZ25lZFR4KCkuZ2V0SWQoKSwgdHgpO1xuICAgICAgICAgIHJldHVybiB7IHR4SGV4OiB0eC50b0hleCgpIH07XG4gICAgICAgIGNhc2UgJ2Nvc2lnbmVyTm9uY2UnOlxuICAgICAgICAgIGFzc2VydCh0eFByZWJ1aWxkLndhbGxldElkLCAnd2FsbGV0SWQgaXMgcmVxdWlyZWQgZm9yIE11U2lnMiBiaXRnbyBub25jZScpO1xuICAgICAgICAgIHJldHVybiB7IHR4SGV4OiAoYXdhaXQgdGhpcy5zaWduUHNidCh0eC50b0hleCgpLCB0eFByZWJ1aWxkLndhbGxldElkKSkucHNidCB9O1xuICAgICAgICBjYXNlICdzaWduZXJTaWduYXR1cmUnOlxuICAgICAgICAgIGNvbnN0IHR4SWQgPSB0eC5nZXRVbnNpZ25lZFR4KCkuZ2V0SWQoKTtcbiAgICAgICAgICBjb25zdCBwc2J0ID0gQWJzdHJhY3RVdHhvQ29pbi5QU0JUX0NBQ0hFLmdldCh0eElkKTtcbiAgICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgICBwc2J0LFxuICAgICAgICAgICAgYFBzYnQgaXMgbWlzc2luZyBmcm9tIHR4Q2FjaGUgKGNhY2hlIHNpemUgJHtBYnN0cmFjdFV0eG9Db2luLlBTQlRfQ0FDSEUuc2l6ZX0pLlxuICAgICAgICAgICAgVGhpcyBtYXkgYmUgZHVlIHRvIHRoZSByZXF1ZXN0IGJlaW5nIHJvdXRlZCB0byBhIGRpZmZlcmVudCBCaXRHby1FeHByZXNzIGluc3RhbmNlIHRoYXQgZm9yIHNpZ25pbmcgc3RlcCAnc2lnbmVyTm9uY2UnLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIEFic3RyYWN0VXR4b0NvaW4uUFNCVF9DQUNIRS5kZWxldGUodHhJZCk7XG4gICAgICAgICAgdHggPSBwc2J0LmNvbWJpbmUodHgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIHRoaXMgaW5zdGFuY2UgaXMgbm90IGFuIGV4dGVybmFsIHNpZ25lclxuICAgICAgICAgIGFzc2VydCh0eFByZWJ1aWxkLndhbGxldElkLCAnd2FsbGV0SWQgaXMgcmVxdWlyZWQgZm9yIE11U2lnMiBiaXRnbyBub25jZScpO1xuICAgICAgICAgIHNpZ25lcktleWNoYWluID0gZ2V0U2lnbmVyS2V5Y2hhaW4oKTtcbiAgICAgICAgICBzZXRTaWduZXJNdXNpZ05vbmNlV2l0aE92ZXJyaWRlKHR4LCBzaWduZXJLZXljaGFpbiwgISFwYXJhbXMuYWxsb3dOb25TZWd3aXRTaWduaW5nV2l0aG91dFByZXZUeCk7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNpZ25Qc2J0KHR4LnRvSGV4KCksIHR4UHJlYnVpbGQud2FsbGV0SWQpO1xuICAgICAgICAgIHR4LmNvbWJpbmUoYml0Z28uY3JlYXRlUHNidEZyb21IZXgocmVzcG9uc2UucHNidCwgdGhpcy5uZXR3b3JrKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAocGFyYW1zLnNpZ25pbmdTdGVwKSB7XG4gICAgICAgIGNhc2UgJ3NpZ25lck5vbmNlJzpcbiAgICAgICAgY2FzZSAnY29zaWduZXJOb25jZSc6XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSW4gY2VydGFpbiBjYXNlcywgdGhlIGNhbGxlciBvZiB0aGlzIG1ldGhvZCBtYXkgbm90IGtub3cgd2hldGhlciB0aGUgdHhIZXggY29udGFpbnMgYSBwc2J0IHdpdGggdGFwcm9vdCBrZXkgcGF0aCBzcGVuZCBpbnB1dChzKS5cbiAgICAgICAgICAgKiBJbnN0ZWFkIG9mIHRocm93aW5nIGVycm9yLCBuby1vcCBhbmQgcmV0dXJuIHRoZSB0eEhleC4gU28gdGhhdCB0aGUgY2FsbGVyIGNhbiBjYWxsIHRoaXMgbWV0aG9kIGluIHRoZSBzYW1lIHNlcXVlbmNlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHJldHVybiB7IHR4SGV4OiB0eC50b0hleCgpIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNpZ25lcktleWNoYWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNpZ25lcktleWNoYWluID0gZ2V0U2lnbmVyS2V5Y2hhaW4oKTtcbiAgICB9XG5cbiAgICBsZXQgc2lnbmVkVHJhbnNhY3Rpb246IGJpdGdvLlV0eG9UcmFuc2FjdGlvbjxiaWdpbnQ+IHwgYml0Z28uVXR4b1BzYnQ7XG4gICAgaWYgKHR4IGluc3RhbmNlb2YgYml0Z28uVXR4b1BzYnQpIHtcbiAgICAgIHNpZ25lZFRyYW5zYWN0aW9uID0gc2lnbkFuZFZlcmlmeVBzYnQodHgsIHNpZ25lcktleWNoYWluLCB7XG4gICAgICAgIGlzTGFzdFNpZ25hdHVyZSxcbiAgICAgICAgYWxsb3dOb25TZWd3aXRTaWduaW5nV2l0aG91dFByZXZUeDogcGFyYW1zLmFsbG93Tm9uU2Vnd2l0U2lnbmluZ1dpdGhvdXRQcmV2VHgsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR4Lmlucy5sZW5ndGggIT09IHR4UHJlYnVpbGQudHhJbmZvPy51bnNwZW50cz8ubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHVuc3BlbnRzIGFycmF5IHNob3VsZCBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9uIGlucHV0cycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhcmFtcy5wdWJzIHx8ICFpc1RyaXBsZShwYXJhbXMucHVicykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtdXN0IHByb3ZpZGUgeHB1YiBhcnJheWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXljaGFpbnMgPSBwYXJhbXMucHVicy5tYXAoKHB1YikgPT4gYmlwMzIuZnJvbUJhc2U1OChwdWIpKSBhcyBUcmlwbGU8QklQMzJJbnRlcmZhY2U+O1xuICAgICAgY29uc3QgY29zaWduZXJQdWIgPSBwYXJhbXMuY29zaWduZXJQdWIgPz8gcGFyYW1zLnB1YnNbMl07XG4gICAgICBjb25zdCBjb3NpZ25lcktleWNoYWluID0gYmlwMzIuZnJvbUJhc2U1OChjb3NpZ25lclB1Yik7XG5cbiAgICAgIGNvbnN0IHdhbGxldFNpZ25lciA9IG5ldyBiaXRnby5XYWxsZXRVbnNwZW50U2lnbmVyPFJvb3RXYWxsZXRLZXlzPihrZXljaGFpbnMsIHNpZ25lcktleWNoYWluLCBjb3NpZ25lcktleWNoYWluKTtcbiAgICAgIHNpZ25lZFRyYW5zYWN0aW9uID0gc2lnbkFuZFZlcmlmeVdhbGxldFRyYW5zYWN0aW9uKHR4LCB0eFByZWJ1aWxkLnR4SW5mby51bnNwZW50cywgd2FsbGV0U2lnbmVyLCB7XG4gICAgICAgIGlzTGFzdFNpZ25hdHVyZSxcbiAgICAgIH0pIGFzIGJpdGdvLlV0eG9UcmFuc2FjdGlvbjxiaWdpbnQ+O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eEhleDogc2lnbmVkVHJhbnNhY3Rpb24udG9CdWZmZXIoKS50b1N0cmluZygnaGV4JyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIGEgdHJhbnNhY3Rpb24gd2l0aCBhIGN1c3RvbSBzaWduaW5nIGZ1bmN0aW9uLiBFeGFtcGxlIHVzZSBjYXNlIGlzIGV4cHJlc3MgZXh0ZXJuYWwgc2lnbmVyXG4gICAqIEBwYXJhbSBjdXN0b21TaWduaW5nRnVuY3Rpb24gY3VzdG9tIHNpZ25pbmcgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2luZ2xlIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gc2lnblRyYW5zYWN0aW9uUGFyYW1zIHBhcmFtZXRlcnMgZm9yIGN1c3RvbSBzaWduaW5nIGZ1bmN0aW9uLiBJbmNsdWRlcyB0eFByZWJ1aWxkIGFuZCBwdWJzIChmb3IgbGVnYWN5IHR4IG9ubHkpLlxuICAgKlxuICAgKiBAcmV0dXJucyBzaWduZWQgdHJhbnNhY3Rpb24gYXMgaGV4IHN0cmluZ1xuICAgKi9cbiAgYXN5bmMgc2lnbldpdGhDdXN0b21TaWduaW5nRnVuY3Rpb248VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludD4oXG4gICAgY3VzdG9tU2lnbmluZ0Z1bmN0aW9uOiBVdHhvQ3VzdG9tU2lnbmluZ0Z1bmN0aW9uPFROdW1iZXI+LFxuICAgIHNpZ25UcmFuc2FjdGlvblBhcmFtczogeyB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkPFROdW1iZXI+OyBwdWJzPzogc3RyaW5nW10gfVxuICApOiBQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgdHhIZXggPSBzaWduVHJhbnNhY3Rpb25QYXJhbXMudHhQcmVidWlsZC50eEhleDtcbiAgICBhc3NlcnQodHhIZXgsICdtaXNzaW5nIHR4SGV4IHBhcmFtZXRlcicpO1xuXG4gICAgY29uc3QgdHggPSBiaXRnby5pc1BzYnQodHhIZXgpXG4gICAgICA/IGJpdGdvLmNyZWF0ZVBzYnRGcm9tSGV4KHR4SGV4LCB0aGlzLm5ldHdvcmspXG4gICAgICA6IHRoaXMuY3JlYXRlVHJhbnNhY3Rpb25Gcm9tSGV4PFROdW1iZXI+KHR4SGV4KTtcblxuICAgIGNvbnN0IGlzVHhXaXRoS2V5UGF0aFNwZW5kSW5wdXQgPSB0eCBpbnN0YW5jZW9mIGJpdGdvLlV0eG9Qc2J0ICYmIGJpdGdvLmlzVHJhbnNhY3Rpb25XaXRoS2V5UGF0aFNwZW5kSW5wdXQodHgpO1xuXG4gICAgaWYgKCFpc1R4V2l0aEtleVBhdGhTcGVuZElucHV0KSB7XG4gICAgICByZXR1cm4gYXdhaXQgY3VzdG9tU2lnbmluZ0Z1bmN0aW9uKHsgLi4uc2lnblRyYW5zYWN0aW9uUGFyYW1zLCBjb2luOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGdldFR4SGV4ID0gKHY6IFNpZ25lZFRyYW5zYWN0aW9uKTogc3RyaW5nID0+IHtcbiAgICAgIGlmICgndHhIZXgnIGluIHYpIHtcbiAgICAgICAgcmV0dXJuIHYudHhIZXg7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4SGV4IG5vdCBmb3VuZCBpbiBzaWduVHJhbnNhY3Rpb24gcmVzdWx0Jyk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNpZ25lck5vbmNlVHggPSBhd2FpdCBjdXN0b21TaWduaW5nRnVuY3Rpb24oe1xuICAgICAgLi4uc2lnblRyYW5zYWN0aW9uUGFyYW1zLFxuICAgICAgc2lnbmluZ1N0ZXA6ICdzaWduZXJOb25jZScsXG4gICAgICBjb2luOiB0aGlzLFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBwdWJzIH0gPSBzaWduVHJhbnNhY3Rpb25QYXJhbXM7XG4gICAgYXNzZXJ0KHB1YnMgPT09IHVuZGVmaW5lZCB8fCBpc1RyaXBsZShwdWJzKSk7XG5cbiAgICBjb25zdCBjb3NpZ25lck5vbmNlVHggPSBhd2FpdCB0aGlzLnNpZ25UcmFuc2FjdGlvbjxUTnVtYmVyPih7XG4gICAgICAuLi5zaWduVHJhbnNhY3Rpb25QYXJhbXMsXG4gICAgICBwdWJzLFxuICAgICAgdHhQcmVidWlsZDogeyAuLi5zaWduVHJhbnNhY3Rpb25QYXJhbXMudHhQcmVidWlsZCwgdHhIZXg6IGdldFR4SGV4KHNpZ25lck5vbmNlVHgpIH0sXG4gICAgICBzaWduaW5nU3RlcDogJ2Nvc2lnbmVyTm9uY2UnLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF3YWl0IGN1c3RvbVNpZ25pbmdGdW5jdGlvbih7XG4gICAgICAuLi5zaWduVHJhbnNhY3Rpb25QYXJhbXMsXG4gICAgICB0eFByZWJ1aWxkOiB7IC4uLnNpZ25UcmFuc2FjdGlvblBhcmFtcy50eFByZWJ1aWxkLCB0eEhleDogZ2V0VHhIZXgoY29zaWduZXJOb25jZVR4KSB9LFxuICAgICAgc2lnbmluZ1N0ZXA6ICdzaWduZXJTaWduYXR1cmUnLFxuICAgICAgY29pbjogdGhpcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gdW5zcGVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQml0R29UYWludGVkVW5zcGVudDxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50Pih1bnNwZW50OiBVbnNwZW50PFROdW1iZXI+KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzUmVwbGF5UHJvdGVjdGlvblVuc3BlbnQ8VE51bWJlcj4odW5zcGVudCwgdGhpcy5uZXR3b3JrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCAtIHVzZSB1dHhvbGliLmJpdGdvLmdldERlZmF1bHRTaWdIYXNoKG5ldHdvcmspIGluc3RlYWRcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldCBkZWZhdWx0U2lnSGFzaFR5cGUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdXR4b2xpYi5iaXRnby5nZXREZWZhdWx0U2lnSGFzaCh0aGlzLm5ldHdvcmspO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIC0gdXNlIHV0eG9saWIuYml0Y29pbi52ZXJpZnlTaWduYXR1cmUoKSBpbnN0ZWFkXG4gICAqL1xuICB2ZXJpZnlTaWduYXR1cmUoXG4gICAgdHJhbnNhY3Rpb246IGFueSxcbiAgICBpbnB1dEluZGV4OiBudW1iZXIsXG4gICAgYW1vdW50OiBudW1iZXIsXG4gICAgdmVyaWZpY2F0aW9uU2V0dGluZ3M6IHtcbiAgICAgIHNpZ25hdHVyZUluZGV4PzogbnVtYmVyO1xuICAgICAgcHVibGljS2V5Pzogc3RyaW5nO1xuICAgIH0gPSB7fVxuICApOiBib29sZWFuIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ubmV0d29yayAhPT0gdGhpcy5uZXR3b3JrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG5ldHdvcmsgbWlzbWF0Y2hgKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0eG9saWIuYml0Z28udmVyaWZ5U2lnbmF0dXJlKHRyYW5zYWN0aW9uLCBpbnB1dEluZGV4LCBhbW91bnQsIHtcbiAgICAgIHNpZ25hdHVyZUluZGV4OiB2ZXJpZmljYXRpb25TZXR0aW5ncy5zaWduYXR1cmVJbmRleCxcbiAgICAgIHB1YmxpY0tleTogdmVyaWZpY2F0aW9uU2V0dGluZ3MucHVibGljS2V5ID8gQnVmZmVyLmZyb20odmVyaWZpY2F0aW9uU2V0dGluZ3MucHVibGljS2V5LCAnaGV4JykgOiB1bmRlZmluZWQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wb3NlIGEgcmF3IHBzYnQvdHJhbnNhY3Rpb24gaW50byB1c2VmdWwgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIHRvdGFsIGFtb3VudHMsXG4gICAqIGNoYW5nZSBhbW91bnRzLCBhbmQgdHJhbnNhY3Rpb24gb3V0cHV0cy5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgZXhwbGFpblRyYW5zYWN0aW9uPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQgPSBudW1iZXI+KFxuICAgIHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9uczxUTnVtYmVyPlxuICApOiBQcm9taXNlPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+IHtcbiAgICBjb25zdCB7IHR4SGV4IH0gPSBwYXJhbXM7XG4gICAgaWYgKHR5cGVvZiB0eEhleCAhPT0gJ3N0cmluZycgfHwgIXR4SGV4Lm1hdGNoKC9eKFthLWYwLTldezJ9KSskL2kpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHJhbnNhY3Rpb24gaGV4LCBtdXN0IGJlIGEgdmFsaWQgaGV4IHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gdXR4b2xpYi5iaXRnby5pc1BzYnQodHhIZXgpID8gZXhwbGFpblBzYnQocGFyYW1zLCB0aGlzLm5ldHdvcmspIDogZXhwbGFpblR4KHBhcmFtcywgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbXVsdGlzaWcgYWRkcmVzcyBvZiBhIGdpdmVuIHR5cGUgZnJvbSBhIGxpc3Qgb2Yga2V5Y2hhaW5zIGFuZCBhIHNpZ25pbmcgdGhyZXNob2xkXG4gICAqIEBwYXJhbSBhZGRyZXNzVHlwZVxuICAgKiBAcGFyYW0gc2lnbmF0dXJlVGhyZXNob2xkXG4gICAqIEBwYXJhbSBrZXlzXG4gICAqL1xuICBjcmVhdGVNdWx0aVNpZ0FkZHJlc3MoYWRkcmVzc1R5cGU6IFNjcmlwdFR5cGUyT2YzLCBzaWduYXR1cmVUaHJlc2hvbGQ6IG51bWJlciwga2V5czogQnVmZmVyW10pOiBNdWx0aVNpZ0FkZHJlc3Mge1xuICAgIGNvbnN0IHtcbiAgICAgIHNjcmlwdFB1YktleTogb3V0cHV0U2NyaXB0LFxuICAgICAgcmVkZWVtU2NyaXB0LFxuICAgICAgd2l0bmVzc1NjcmlwdCxcbiAgICB9ID0gdXR4b2xpYi5iaXRnby5vdXRwdXRTY3JpcHRzLmNyZWF0ZU91dHB1dFNjcmlwdDJvZjMoa2V5cywgYWRkcmVzc1R5cGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dFNjcmlwdCxcbiAgICAgIHJlZGVlbVNjcmlwdCxcbiAgICAgIHdpdG5lc3NTY3JpcHQsXG4gICAgICBhZGRyZXNzOiB1dHhvbGliLmFkZHJlc3MuZnJvbU91dHB1dFNjcmlwdChvdXRwdXRTY3JpcHQsIHRoaXMubmV0d29yayksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCAtIHVzZSB7QHNlZSBiYWNrdXBLZXlSZWNvdmVyeX1cbiAgICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHb1xuICAgKiBAcGFyYW0gcGFyYW1zIC0ge0BzZWUgYmFja3VwS2V5UmVjb3Zlcnl9XG4gICAqL1xuICBhc3luYyByZWNvdmVyKHBhcmFtczogUmVjb3ZlclBhcmFtcyk6IFJldHVyblR5cGU8dHlwZW9mIGJhY2t1cEtleVJlY292ZXJ5PiB7XG4gICAgcmV0dXJuIGJhY2t1cEtleVJlY292ZXJ5KHRoaXMsIHRoaXMuYml0Z28sIHBhcmFtcyk7XG4gIH1cblxuICBhc3luYyByZWNvdmVyVjEocGFyYW1zOiBWMVJlY292ZXJQYXJhbXMpOiBSZXR1cm5UeXBlPHR5cGVvZiB2MUJhY2t1cEtleVJlY292ZXJ5PiB7XG4gICAgcmV0dXJuIHYxQmFja3VwS2V5UmVjb3ZlcnkodGhpcywgdGhpcy5iaXRnbywgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvdmVyIGNvaW4gdGhhdCB3YXMgc2VudCB0byB3cm9uZyBjaGFpblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudHhpZCBUaGUgdHhpZCBvZiB0aGUgZmF1bHR5IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXMucmVjb3ZlcnlBZGRyZXNzIGFkZHJlc3MgdG8gc2VuZCByZWNvdmVyZWQgZnVuZHMgdG9cbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXQgdGhlIHdhbGxldCB0aGF0IHJlY2VpdmVkIHRoZSBmdW5kc1xuICAgKiBAcGFyYW0gcGFyYW1zLnJlY292ZXJ5Q29pbiB0aGUgY29pbiB0eXBlIG9mIHRoZSB3YWxsZXQgdGhhdCByZWNlaXZlZCB0aGUgZnVuZHNcbiAgICogQHBhcmFtIHBhcmFtcy5zaWduZWQgcmV0dXJuIGEgaGFsZi1zaWduZWQgdHJhbnNhY3Rpb24gKGRlZmF1bHQ9dHJ1ZSlcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIHRoZSB3YWxsZXQgcGFzc3BocmFzZVxuICAgKiBAcGFyYW0gcGFyYW1zLnhwcnYgdGhlIHVuZW5jcnlwdGVkIHhwcnYgKHVzZWQgaW5zdGVhZCBvZiB3YWxsZXQgcGFzc3BocmFzZSlcbiAgICogQHBhcmFtIHBhcmFtcy5hcGlLZXkgZm9yIHV0eG8gY29pbnMgb3RoZXIgdGhhbiBbQlRDLFRCVENdIHRoaXMgaXMgYSBCbG9jayBDaGFpciBhcGkga2V5XG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgcmVjb3ZlckZyb21Xcm9uZ0NoYWluPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQgPSBudW1iZXI+KFxuICAgIHBhcmFtczogUmVjb3ZlckZyb21Xcm9uZ0NoYWluT3B0aW9uc1xuICApOiBQcm9taXNlPENyb3NzQ2hhaW5SZWNvdmVyeVNpZ25lZDxUTnVtYmVyPiB8IENyb3NzQ2hhaW5SZWNvdmVyeVVuc2lnbmVkPFROdW1iZXI+PiB7XG4gICAgY29uc3QgeyB0eGlkLCByZWNvdmVyeUFkZHJlc3MsIHdhbGxldCwgd2FsbGV0UGFzc3BocmFzZSwgeHBydiwgYXBpS2V5IH0gPSBwYXJhbXM7XG5cbiAgICAvLyBwYXJhbXMucmVjb3ZlcnlDb2luIHVzZWQgdG8gYmUgcGFyYW1zLmNvaW4sIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgY29uc3QgcmVjb3ZlcnlDb2luID0gcGFyYW1zLmNvaW4gfHwgcGFyYW1zLnJlY292ZXJ5Q29pbjtcbiAgICBpZiAoIXJlY292ZXJ5Q29pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIG9iamVjdCByZWNvdmVyeUNvaW4nKTtcbiAgICB9XG4gICAgLy8gc2lnbmVkIHNob3VsZCBkZWZhdWx0IHRvIHRydWUsIGFuZCBvbmx5IGJlIGRpc2FibGVkIGlmIGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlIChub3QgdW5kZWZpbmVkKVxuICAgIGNvbnN0IHNpZ25lZCA9IHBhcmFtcy5zaWduZWQgIT09IGZhbHNlO1xuXG4gICAgY29uc3Qgc291cmNlQ29pbkZhbWlseSA9IHRoaXMuZ2V0RmFtaWx5KCk7XG4gICAgY29uc3QgcmVjb3ZlcnlDb2luRmFtaWx5ID0gcmVjb3ZlcnlDb2luLmdldEZhbWlseSgpO1xuICAgIGNvbnN0IHN1cHBvcnRlZFJlY292ZXJ5Q29pbnMgPSBzdXBwb3J0ZWRDcm9zc0NoYWluUmVjb3Zlcmllc1tzb3VyY2VDb2luRmFtaWx5XTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHN1cHBvcnRlZFJlY292ZXJ5Q29pbnMpIHx8ICFzdXBwb3J0ZWRSZWNvdmVyeUNvaW5zLmluY2x1ZGVzKHJlY292ZXJ5Q29pbkZhbWlseSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjb3Zlcnkgb2YgJHtzb3VyY2VDb2luRmFtaWx5fSBiYWxhbmNlcyBmcm9tICR7cmVjb3ZlcnlDb2luRmFtaWx5fSB3YWxsZXRzIGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHJlY292ZXJDcm9zc0NoYWluPFROdW1iZXI+KHRoaXMuYml0Z28sIHtcbiAgICAgIHNvdXJjZUNvaW46IHRoaXMsXG4gICAgICByZWNvdmVyeUNvaW4sXG4gICAgICB3YWxsZXRJZDogd2FsbGV0LFxuICAgICAgdHhpZCxcbiAgICAgIHJlY292ZXJ5QWRkcmVzcyxcbiAgICAgIHdhbGxldFBhc3NwaHJhc2U6IHNpZ25lZCA/IHdhbGxldFBhc3NwaHJhc2UgOiB1bmRlZmluZWQsXG4gICAgICB4cHJ2OiBzaWduZWQgPyB4cHJ2IDogdW5kZWZpbmVkLFxuICAgICAgYXBpS2V5LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGJpcDMyIGtleSBwYWlyXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGdlbmVyYXRlZCBwdWIgYW5kIHBydlxuICAgKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ6IEJ1ZmZlcik6IHsgcHViOiBzdHJpbmc7IHBydjogc3RyaW5nIH0ge1xuICAgIGlmICghc2VlZCkge1xuICAgICAgLy8gQW4gZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgaGFzIGJvdGggYSBub3JtYWwgMjU2IGJpdCBwcml2YXRlIGtleSBhbmQgYSAyNTZcbiAgICAgIC8vIGJpdCBjaGFpbiBjb2RlLCBib3RoIG9mIHdoaWNoIG11c3QgYmUgcmFuZG9tLiA1MTIgYml0cyBpcyB0aGVyZWZvcmUgdGhlXG4gICAgICAvLyBtYXhpbXVtIGVudHJvcHkgYW5kIGdpdmVzIHVzIG1heGltdW0gc2VjdXJpdHkgYWdhaW5zdCBjcmFja2luZy5cbiAgICAgIHNlZWQgPSByYW5kb21CeXRlcyg1MTIgLyA4KTtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5kZWRLZXkgPSBiaXAzMi5mcm9tU2VlZChzZWVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiBleHRlbmRlZEtleS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCksXG4gICAgICBwcnY6IGV4dGVuZGVkS2V5LnRvQmFzZTU4KCksXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGdldEV4dHJhUHJlYnVpbGRQYXJhbXMoYnVpbGRQYXJhbXM6IEV4dHJhUHJlYnVpbGRQYXJhbXNPcHRpb25zICYgeyB3YWxsZXQ6IFdhbGxldCB9KTogUHJvbWlzZTx7XG4gICAgdHhGb3JtYXQ/OiAnbGVnYWN5JyB8ICdwc2J0JztcbiAgICBjaGFuZ2VBZGRyZXNzVHlwZT86IFNjcmlwdFR5cGUyT2YzW10gfCBTY3JpcHRUeXBlMk9mMztcbiAgfT4ge1xuICAgIGxldCB0eEZvcm1hdCA9IGJ1aWxkUGFyYW1zLnR4Rm9ybWF0IGFzICdsZWdhY3knIHwgJ3BzYnQnIHwgdW5kZWZpbmVkO1xuICAgIGxldCBjaGFuZ2VBZGRyZXNzVHlwZSA9IGJ1aWxkUGFyYW1zLmNoYW5nZUFkZHJlc3NUeXBlIGFzIFNjcmlwdFR5cGUyT2YzW10gfCBTY3JpcHRUeXBlMk9mMyB8IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IHdhbGxldEZsYWdNdXNpZ0twID0gYnVpbGRQYXJhbXMud2FsbGV0LmZsYWcoJ211c2lnS3AnKSA9PT0gJ3RydWUnO1xuXG4gICAgLy8gaWYgdGhlIHR4Rm9ybWF0IGlzIG5vdCBzcGVjaWZpZWQsIHdlIG5lZWQgdG8gZGVmYXVsdCB0byBwc2J0IGZvciBkaXN0cmlidXRlZCBjdXN0b2R5IHdhbGxldHMgb3IgdGVzdG5ldCBob3Qgd2FsbGV0c1xuICAgIGlmIChcbiAgICAgIGJ1aWxkUGFyYW1zLnR4Rm9ybWF0ID09PSB1bmRlZmluZWQgJiZcbiAgICAgIChidWlsZFBhcmFtcy53YWxsZXQuc3ViVHlwZSgpID09PSAnZGlzdHJpYnV0ZWRDdXN0b2R5JyB8fFxuICAgICAgICAoaXNUZXN0bmV0KHRoaXMubmV0d29yaykgJiYgYnVpbGRQYXJhbXMud2FsbGV0LnR5cGUoKSA9PT0gJ2hvdCcpIHx8XG4gICAgICAgIC8vIEZJWE1FKEJUQy03NzYpOiBkZWZhdWx0IHRvIHBzYnQgZm9yIGFsbCBtYWlubmV0IHdhbGxldHMgaW4gdGhlIGZ1dHVyZVxuICAgICAgICB3YWxsZXRGbGFnTXVzaWdLcClcbiAgICApIHtcbiAgICAgIHR4Rm9ybWF0ID0gJ3BzYnQnO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBhZGRyZXNzVHlwZSBpcyBub3Qgc3BlY2lmaWVkLCB3ZSBuZWVkIHRvIGRlZmF1bHQgdG8gcDJ0ck11c2lnMiBmb3IgdGVzdG5ldCBob3Qgd2FsbGV0cyBmb3Igc3RhZ2VkIHJvbGxvdXQgb2YgcDJ0ck11c2lnMlxuICAgIGlmIChcbiAgICAgIGJ1aWxkUGFyYW1zLmFkZHJlc3NUeXBlID09PSB1bmRlZmluZWQgJiYgLy8gYWRkcmVzc1R5cGUgaXMgZGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgYnkgYGNoYW5nZUFkZHJlc3NgXG4gICAgICBidWlsZFBhcmFtcy5jaGFuZ2VBZGRyZXNzVHlwZSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICBidWlsZFBhcmFtcy5jaGFuZ2VBZGRyZXNzID09PSB1bmRlZmluZWQgJiZcbiAgICAgIGJ1aWxkUGFyYW1zLndhbGxldC50eXBlKCkgPT09ICdob3QnXG4gICAgKSB7XG4gICAgICBjaGFuZ2VBZGRyZXNzVHlwZSA9IFsncDJ0ck11c2lnMicsICdwMndzaCcsICdwMnNoUDJ3c2gnLCAncDJzaCcsICdwMnRyJ107XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR4Rm9ybWF0LFxuICAgICAgY2hhbmdlQWRkcmVzc1R5cGUsXG4gICAgfTtcbiAgfVxuXG4gIHByZUNyZWF0ZUJpdEdvKHBhcmFtczogUHJlY3JlYXRlQml0R29PcHRpb25zKTogdm9pZCB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXN5bmMgcHJlc2lnblRyYW5zYWN0aW9uKHBhcmFtczogUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIGFzeW5jIHN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldChcbiAgICB3YWxsZXRQYXJhbXM6IFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMsXG4gICAga2V5Y2hhaW5zOiBLZXljaGFpbnNUcmlwbGV0XG4gICk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHdhbGxldFBhcmFtcztcbiAgfVxuXG4gIHRyYW5zYWN0aW9uRGF0YUFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGdldFJlY292ZXJ5UHJvdmlkZXIoYXBpVG9rZW4/OiBzdHJpbmcpOiBSZWNvdmVyeVByb3ZpZGVyIHtcbiAgICByZXR1cm4gZm9yQ29pbih0aGlzLmdldENoYWluKCksIGFwaVRva2VuKTtcbiAgfVxufVxuIl19