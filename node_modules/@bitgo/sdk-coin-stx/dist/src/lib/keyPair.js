"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyPair = void 0;
const crypto_1 = require("crypto");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const transactions_1 = require("@stacks/transactions");
const sdk_core_1 = require("@bitgo/sdk-core");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
class KeyPair extends sdk_core_1.Secp256k1ExtendedKeyPair {
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param { KeyPairOptions } source Either a master seed, a private key, or a public key
     */
    constructor(source) {
        super(source);
        if (!source) {
            const seed = (0, crypto_1.randomBytes)(constants_1.DEFAULT_SEED_SIZE_BYTES);
            this.hdNode = utxo_lib_1.bip32.fromSeed(seed);
        }
        else if ((0, sdk_core_1.isSeed)(source)) {
            this.hdNode = utxo_lib_1.bip32.fromSeed(source.seed);
        }
        else if ((0, sdk_core_1.isPrivateKey)(source)) {
            this.recordKeysFromPrivateKey(source.prv);
        }
        else if ((0, sdk_core_1.isPublicKey)(source)) {
            this.recordKeysFromPublicKey(source.pub);
        }
        else {
            throw new Error('Invalid key pair options');
        }
        if (this.hdNode) {
            this.keyPair = sdk_core_1.Secp256k1ExtendedKeyPair.toKeyPair(this.hdNode);
        }
    }
    /**
     * Build a keypair from a protocol private key or extended private key.
     *
     * The protocol private key is either 32 or 33 bytes long (64 or 66
     * characters hex).  If it is 32 bytes long, set the keypair's "compressed"
     * field to false to later generate uncompressed public keys (the default).
     * A 33 byte key has 0x01 as the last byte.
     *
     * @param {string} prv A raw private key
     */
    recordKeysFromPrivateKey(prv) {
        if (!(0, utils_1.isValidPrivateKey)(prv)) {
            throw new Error('Unsupported private key');
        }
        if ((0, sdk_core_1.isValidXprv)(prv)) {
            this.hdNode = utxo_lib_1.bip32.fromBase58(prv);
        }
        else {
            this.keyPair = utxo_lib_1.ECPair.fromPrivateKey(Buffer.from(prv.slice(0, 64), 'hex'));
        }
    }
    /**
     * Build an ECPair from a protocol public key or extended public key.
     *
     * The protocol public key is either 32 bytes or 64 bytes long, with a
     * one-byte prefix (a total of 66 or 130 characters in hex).  If the
     * prefix is 0x02 or 0x03, it is a compressed public key.  A prefix of 0x04
     * denotes an uncompressed public key.
     *
     * @param {string} pub A raw public key
     */
    recordKeysFromPublicKey(pub) {
        if (!(0, utils_1.isValidPublicKey)(pub)) {
            throw new Error('Unsupported public key');
        }
        if ((0, sdk_core_1.isValidXpub)(pub)) {
            this.hdNode = utxo_lib_1.bip32.fromBase58(pub);
        }
        else {
            this.keyPair = utxo_lib_1.ECPair.fromPublicKey(Buffer.from(pub, 'hex'));
        }
    }
    /**
     * Stacks default keys format is raw private and uncompressed public key
     *
     * @param {boolean} compressed - Compress public key (defaults to false)
     * @returns {DefaultKeys} The keys in the protocol default key format
     */
    getKeys(compressed = false) {
        var _a;
        let prv = (_a = this.getPrivateKey()) === null || _a === void 0 ? void 0 : _a.toString('hex');
        if (prv && compressed) {
            prv += '01';
        }
        return {
            pub: this.getPublicKey({ compressed }).toString('hex'),
            prv,
        };
    }
    getCompressed() {
        return this.keyPair.compressed;
    }
    /**
     * Get a public address of an uncompressed public key.
     *
     * @returns {string} The public address
     */
    getAddress() {
        return this.getSTXAddress(false, transactions_1.TransactionVersion.Mainnet);
    }
    /**
     * Get a public address of an uncompressed public key.
     *
     * @param {boolean} compressed - Compress public key (defaults to false)
     * @param {TransactionVersion} network - select Mainnet or Testnet for the address
     * @returns {string} The public address
     */
    getSTXAddress(compressed = false, network = transactions_1.TransactionVersion.Mainnet) {
        return (0, transactions_1.getAddressFromPublicKey)(this.getKeys(compressed).pub, network);
    }
}
exports.KeyPair = KeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIva2V5UGFpci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxtQ0FBcUM7QUFDckMsOENBQWdEO0FBQ2hELHVEQUFtRjtBQUNuRiw4Q0FTeUI7QUFDekIsbUNBQThEO0FBQzlELDJDQUFzRDtBQUV0RCxNQUFhLE9BQVEsU0FBUSxtQ0FBd0I7SUFDbkQ7Ozs7T0FJRztJQUNILFlBQVksTUFBdUI7UUFDakMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2QsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLE1BQU0sSUFBSSxHQUFHLElBQUEsb0JBQVcsRUFBQyxtQ0FBdUIsQ0FBQyxDQUFDO1lBQ2xELElBQUksQ0FBQyxNQUFNLEdBQUcsZ0JBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDcEM7YUFBTSxJQUFJLElBQUEsaUJBQU0sRUFBQyxNQUFNLENBQUMsRUFBRTtZQUN6QixJQUFJLENBQUMsTUFBTSxHQUFHLGdCQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUMzQzthQUFNLElBQUksSUFBQSx1QkFBWSxFQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQy9CLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDM0M7YUFBTSxJQUFJLElBQUEsc0JBQVcsRUFBQyxNQUFNLENBQUMsRUFBRTtZQUM5QixJQUFJLENBQUMsdUJBQXVCLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzFDO2FBQU07WUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUM7U0FDN0M7UUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDZixJQUFJLENBQUMsT0FBTyxHQUFHLG1DQUF3QixDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDaEU7SUFDSCxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0gsd0JBQXdCLENBQUMsR0FBVztRQUNsQyxJQUFJLENBQUMsSUFBQSx5QkFBaUIsRUFBQyxHQUFHLENBQUMsRUFBRTtZQUMzQixNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7U0FDNUM7UUFFRCxJQUFJLElBQUEsc0JBQVcsRUFBQyxHQUFHLENBQUMsRUFBRTtZQUNwQixJQUFJLENBQUMsTUFBTSxHQUFHLGdCQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3JDO2FBQU07WUFDTCxJQUFJLENBQUMsT0FBTyxHQUFHLGlCQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUM1RTtJQUNILENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSCx1QkFBdUIsQ0FBQyxHQUFXO1FBQ2pDLElBQUksQ0FBQyxJQUFBLHdCQUFnQixFQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzFCLE1BQU0sSUFBSSxLQUFLLENBQUMsd0JBQXdCLENBQUMsQ0FBQztTQUMzQztRQUVELElBQUksSUFBQSxzQkFBVyxFQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3BCLElBQUksQ0FBQyxNQUFNLEdBQUcsZ0JBQUssQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDckM7YUFBTTtZQUNMLElBQUksQ0FBQyxPQUFPLEdBQUcsaUJBQU0sQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUM5RDtJQUNILENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE9BQU8sQ0FBQyxVQUFVLEdBQUcsS0FBSzs7UUFDeEIsSUFBSSxHQUFHLEdBQUcsTUFBQSxJQUFJLENBQUMsYUFBYSxFQUFFLDBDQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNoRCxJQUFJLEdBQUcsSUFBSSxVQUFVLEVBQUU7WUFDckIsR0FBRyxJQUFJLElBQUksQ0FBQztTQUNiO1FBRUQsT0FBTztZQUNMLEdBQUcsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO1lBQ3RELEdBQUc7U0FDSixDQUFDO0lBQ0osQ0FBQztJQUVELGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsVUFBVTtRQUNSLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsaUNBQWtCLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDL0QsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILGFBQWEsQ0FBQyxVQUFVLEdBQUcsS0FBSyxFQUFFLFVBQThCLGlDQUFrQixDQUFDLE9BQU87UUFDeEYsT0FBTyxJQUFBLHNDQUF1QixFQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3hFLENBQUM7Q0FDRjtBQS9HRCwwQkErR0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBiaXAzMiwgRUNQYWlyIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCB7IGdldEFkZHJlc3NGcm9tUHVibGljS2V5LCBUcmFuc2FjdGlvblZlcnNpb24gfSBmcm9tICdAc3RhY2tzL3RyYW5zYWN0aW9ucyc7XG5pbXBvcnQge1xuICBEZWZhdWx0S2V5cyxcbiAgaXNQcml2YXRlS2V5LFxuICBpc1B1YmxpY0tleSxcbiAgaXNTZWVkLFxuICBpc1ZhbGlkWHBydixcbiAgaXNWYWxpZFhwdWIsXG4gIEtleVBhaXJPcHRpb25zLFxuICBTZWNwMjU2azFFeHRlbmRlZEtleVBhaXIsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBpc1ZhbGlkUHJpdmF0ZUtleSwgaXNWYWxpZFB1YmxpY0tleSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgREVGQVVMVF9TRUVEX1NJWkVfQllURVMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBjbGFzcyBLZXlQYWlyIGV4dGVuZHMgU2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyIHtcbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci4gQnkgZGVmYXVsdCwgY3JlYXRlcyBhIGtleSBwYWlyIHdpdGggYSByYW5kb20gbWFzdGVyIHNlZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7IEtleVBhaXJPcHRpb25zIH0gc291cmNlIEVpdGhlciBhIG1hc3RlciBzZWVkLCBhIHByaXZhdGUga2V5LCBvciBhIHB1YmxpYyBrZXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZT86IEtleVBhaXJPcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlKTtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgY29uc3Qgc2VlZCA9IHJhbmRvbUJ5dGVzKERFRkFVTFRfU0VFRF9TSVpFX0JZVEVTKTtcbiAgICAgIHRoaXMuaGROb2RlID0gYmlwMzIuZnJvbVNlZWQoc2VlZCk7XG4gICAgfSBlbHNlIGlmIChpc1NlZWQoc291cmNlKSkge1xuICAgICAgdGhpcy5oZE5vZGUgPSBiaXAzMi5mcm9tU2VlZChzb3VyY2Uuc2VlZCk7XG4gICAgfSBlbHNlIGlmIChpc1ByaXZhdGVLZXkoc291cmNlKSkge1xuICAgICAgdGhpcy5yZWNvcmRLZXlzRnJvbVByaXZhdGVLZXkoc291cmNlLnBydik7XG4gICAgfSBlbHNlIGlmIChpc1B1YmxpY0tleShzb3VyY2UpKSB7XG4gICAgICB0aGlzLnJlY29yZEtleXNGcm9tUHVibGljS2V5KHNvdXJjZS5wdWIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IHBhaXIgb3B0aW9ucycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhkTm9kZSkge1xuICAgICAgdGhpcy5rZXlQYWlyID0gU2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyLnRvS2V5UGFpcih0aGlzLmhkTm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEga2V5cGFpciBmcm9tIGEgcHJvdG9jb2wgcHJpdmF0ZSBrZXkgb3IgZXh0ZW5kZWQgcHJpdmF0ZSBrZXkuXG4gICAqXG4gICAqIFRoZSBwcm90b2NvbCBwcml2YXRlIGtleSBpcyBlaXRoZXIgMzIgb3IgMzMgYnl0ZXMgbG9uZyAoNjQgb3IgNjZcbiAgICogY2hhcmFjdGVycyBoZXgpLiAgSWYgaXQgaXMgMzIgYnl0ZXMgbG9uZywgc2V0IHRoZSBrZXlwYWlyJ3MgXCJjb21wcmVzc2VkXCJcbiAgICogZmllbGQgdG8gZmFsc2UgdG8gbGF0ZXIgZ2VuZXJhdGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXlzICh0aGUgZGVmYXVsdCkuXG4gICAqIEEgMzMgYnl0ZSBrZXkgaGFzIDB4MDEgYXMgdGhlIGxhc3QgYnl0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBydiBBIHJhdyBwcml2YXRlIGtleVxuICAgKi9cbiAgcmVjb3JkS2V5c0Zyb21Qcml2YXRlS2V5KHBydjogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFpc1ZhbGlkUHJpdmF0ZUtleShwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHByaXZhdGUga2V5Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzVmFsaWRYcHJ2KHBydikpIHtcbiAgICAgIHRoaXMuaGROb2RlID0gYmlwMzIuZnJvbUJhc2U1OChwcnYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleVBhaXIgPSBFQ1BhaXIuZnJvbVByaXZhdGVLZXkoQnVmZmVyLmZyb20ocHJ2LnNsaWNlKDAsIDY0KSwgJ2hleCcpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYW4gRUNQYWlyIGZyb20gYSBwcm90b2NvbCBwdWJsaWMga2V5IG9yIGV4dGVuZGVkIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIFRoZSBwcm90b2NvbCBwdWJsaWMga2V5IGlzIGVpdGhlciAzMiBieXRlcyBvciA2NCBieXRlcyBsb25nLCB3aXRoIGFcbiAgICogb25lLWJ5dGUgcHJlZml4IChhIHRvdGFsIG9mIDY2IG9yIDEzMCBjaGFyYWN0ZXJzIGluIGhleCkuICBJZiB0aGVcbiAgICogcHJlZml4IGlzIDB4MDIgb3IgMHgwMywgaXQgaXMgYSBjb21wcmVzc2VkIHB1YmxpYyBrZXkuICBBIHByZWZpeCBvZiAweDA0XG4gICAqIGRlbm90ZXMgYW4gdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwdWIgQSByYXcgcHVibGljIGtleVxuICAgKi9cbiAgcmVjb3JkS2V5c0Zyb21QdWJsaWNLZXkocHViOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIWlzVmFsaWRQdWJsaWNLZXkocHViKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwdWJsaWMga2V5Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzVmFsaWRYcHViKHB1YikpIHtcbiAgICAgIHRoaXMuaGROb2RlID0gYmlwMzIuZnJvbUJhc2U1OChwdWIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleVBhaXIgPSBFQ1BhaXIuZnJvbVB1YmxpY0tleShCdWZmZXIuZnJvbShwdWIsICdoZXgnKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YWNrcyBkZWZhdWx0IGtleXMgZm9ybWF0IGlzIHJhdyBwcml2YXRlIGFuZCB1bmNvbXByZXNzZWQgcHVibGljIGtleVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWQgLSBDb21wcmVzcyBwdWJsaWMga2V5IChkZWZhdWx0cyB0byBmYWxzZSlcbiAgICogQHJldHVybnMge0RlZmF1bHRLZXlzfSBUaGUga2V5cyBpbiB0aGUgcHJvdG9jb2wgZGVmYXVsdCBrZXkgZm9ybWF0XG4gICAqL1xuICBnZXRLZXlzKGNvbXByZXNzZWQgPSBmYWxzZSk6IERlZmF1bHRLZXlzIHtcbiAgICBsZXQgcHJ2ID0gdGhpcy5nZXRQcml2YXRlS2V5KCk/LnRvU3RyaW5nKCdoZXgnKTtcbiAgICBpZiAocHJ2ICYmIGNvbXByZXNzZWQpIHtcbiAgICAgIHBydiArPSAnMDEnO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwdWI6IHRoaXMuZ2V0UHVibGljS2V5KHsgY29tcHJlc3NlZCB9KS50b1N0cmluZygnaGV4JyksXG4gICAgICBwcnYsXG4gICAgfTtcbiAgfVxuXG4gIGdldENvbXByZXNzZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMua2V5UGFpci5jb21wcmVzc2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHB1YmxpYyBhZGRyZXNzIG9mIGFuIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcHVibGljIGFkZHJlc3NcbiAgICovXG4gIGdldEFkZHJlc3MoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTVFhBZGRyZXNzKGZhbHNlLCBUcmFuc2FjdGlvblZlcnNpb24uTWFpbm5ldCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcHVibGljIGFkZHJlc3Mgb2YgYW4gdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZCAtIENvbXByZXNzIHB1YmxpYyBrZXkgKGRlZmF1bHRzIHRvIGZhbHNlKVxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uVmVyc2lvbn0gbmV0d29yayAtIHNlbGVjdCBNYWlubmV0IG9yIFRlc3RuZXQgZm9yIHRoZSBhZGRyZXNzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBwdWJsaWMgYWRkcmVzc1xuICAgKi9cbiAgZ2V0U1RYQWRkcmVzcyhjb21wcmVzc2VkID0gZmFsc2UsIG5ldHdvcms6IFRyYW5zYWN0aW9uVmVyc2lvbiA9IFRyYW5zYWN0aW9uVmVyc2lvbi5NYWlubmV0KTogc3RyaW5nIHtcbiAgICByZXR1cm4gZ2V0QWRkcmVzc0Zyb21QdWJsaWNLZXkodGhpcy5nZXRLZXlzKGNvbXByZXNzZWQpLnB1YiwgbmV0d29yayk7XG4gIH1cbn1cbiJdfQ==