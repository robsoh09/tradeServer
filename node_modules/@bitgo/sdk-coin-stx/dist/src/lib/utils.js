"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSameBaseAddress = exports.getBaseAddress = exports.xpubToSTXPubkey = exports.getAddressVersion = exports.functionArgsToSendParams = exports.stringifyCv = exports.isValidAddressWithPaymentId = exports.normalizeAddress = exports.getAddressDetails = exports.verifySignature = exports.signMessage = exports.getSTXAddressFromPubKeys = exports.unpadMemo = exports.isValidContractFunctionName = exports.isValidContractAddress = exports.isValidMemo = exports.isValidRawTransaction = exports.isValidPrivateKey = exports.isValidPublicKey = exports.isValidTransactionId = exports.isValidAddress = exports.isValidAmount = exports.getTxSenderAddress = exports.removeHexPrefix = exports.bufferToHexPrefixString = void 0;
const url = __importStar(require("url"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ethereumjs_util_1 = require("ethereumjs-util");
const transactions_1 = require("@stacks/transactions");
const elliptic_1 = require("elliptic");
const _ = __importStar(require("lodash"));
const sdk_core_1 = require("@bitgo/sdk-core");
const _1 = require(".");
const constants_1 = require("./constants");
/**
 * Encodes a buffer as a "0x" prefixed lower-case hex string.
 *
 * @param {Buffer} buff - a buffer with a hexadecimal string
 * @returns {string} - the hexadecimal string prefixed with "0x"
 */
function bufferToHexPrefixString(buff) {
    return (0, ethereumjs_util_1.bufferToHex)(buff);
}
exports.bufferToHexPrefixString = bufferToHexPrefixString;
/**
 * Remove the "0x" prefix from the given string, if present.
 *
 * @param {string} hex - a hexadecimal string
 * @returns {string} - the hexadecimal string without a leading "0x"
 */
function removeHexPrefix(hex) {
    return (0, ethereumjs_util_1.stripHexPrefix)(hex);
}
exports.removeHexPrefix = removeHexPrefix;
/**
 * Get stacks address from public key hash
 *
 * @param {Buffer} publicKeyHash - hash of public key
 * @param {AddressHashMode} hashMode - hash mode
 * @param {TransactionVersion} transactionVersion - tx version
 * @returns {string} stacks address
 */
function getAddressFromPublicKeyHash(publicKeyHash, hashMode, transactionVersion) {
    if (publicKeyHash.length !== 20) {
        throw new Error('expected 20-byte pubkeyhash');
    }
    const addrVer = (0, transactions_1.addressHashModeToVersion)(hashMode, transactionVersion);
    const addr = (0, transactions_1.addressFromVersionHash)(addrVer, publicKeyHash.toString('hex'));
    const addrString = (0, transactions_1.addressToString)(addr);
    return addrString;
}
/**
 * @param tx
 */
function getTxSenderAddress(tx) {
    if (tx.auth.spendingCondition !== null && tx.auth.spendingCondition !== undefined) {
        const spendingCondition = tx.auth.spendingCondition;
        const txSender = getAddressFromPublicKeyHash(Buffer.from(spendingCondition.signer, 'hex'), spendingCondition.hashMode, tx.version);
        return txSender;
    }
    else
        throw new Error('spendingCondition should not be null');
}
exports.getTxSenderAddress = getTxSenderAddress;
/**
 * Returns whether or not the string is a valid amount number
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
function isValidAmount(amount) {
    const bigNumberAmount = new bignumber_js_1.default(amount);
    return bigNumberAmount.isInteger() && bigNumberAmount.isGreaterThanOrEqualTo(0);
}
exports.isValidAmount = isValidAmount;
/**
 * Returns whether or not the string is a valid protocol address
 *
 * @param {string} address - the address to be validated
 * @returns {boolean} - the validation result
 */
function isValidAddress(address) {
    return (0, transactions_1.validateStacksAddress)(address);
}
exports.isValidAddress = isValidAddress;
/**
 * Returns whether or not the string is a valid protocol transaction id or not.
 *
 * A valid transaction id is a SHA-512/256 hash of a serialized transaction; see
 * the txidFromData function in @stacks/transaction:
 * https://github.com/blockstack/stacks.js/blob/master/packages/transactions/src/utils.ts#L97
 *
 * @param {string} txId - the transaction id to be validated
 * @returns {boolean} - the validation result
 */
function isValidTransactionId(txId) {
    if (txId.length !== 64 && txId.length !== 66)
        return false;
    const noPrefix = removeHexPrefix(txId);
    if (noPrefix.length !== 64)
        return false;
    return allHexChars(noPrefix);
}
exports.isValidTransactionId = isValidTransactionId;
/**
 * Returns whether or not the string is a valid protocol public key or
 * extended public key.
 *
 * The key format is documented at
 * https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md#transaction-authorization
 *
 * @param {string} pub - the  public key to be validated
 * @returns {boolean} - the validation result
 */
function isValidPublicKey(pub) {
    if ((0, sdk_core_1.isValidXpub)(pub))
        return true;
    if (pub.length !== 66 && pub.length !== 130)
        return false;
    const firstByte = pub.slice(0, 2);
    // uncompressed public key
    if (pub.length === 130 && firstByte !== '04')
        return false;
    // compressed public key
    if (pub.length === 66 && firstByte !== '02' && firstByte !== '03')
        return false;
    if (!allHexChars(pub))
        return false;
    // validate the public key
    const secp256k1 = new elliptic_1.ec('secp256k1');
    try {
        const keyPair = secp256k1.keyFromPublic(Buffer.from(pub, 'hex'));
        const { result } = keyPair.validate();
        return result;
    }
    catch (e) {
        return false;
    }
}
exports.isValidPublicKey = isValidPublicKey;
/**
 * Returns whether or not the string is a valid protocol private key, or extended
 * private key.
 *
 * The protocol key format is described in the @stacks/transactions npm package, in the
 * createStacksPrivateKey function:
 * https://github.com/blockstack/stacks.js/blob/master/packages/transactions/src/keys.ts#L125
 *
 * @param {string} prv - the private key (or extended private key) to be validated
 * @returns {boolean} - the validation result
 */
function isValidPrivateKey(prv) {
    if ((0, sdk_core_1.isValidXprv)(prv))
        return true;
    if (prv.length !== 64 && prv.length !== 66)
        return false;
    if (prv.length === 66 && prv.slice(64) !== '01')
        return false;
    return allHexChars(prv);
}
exports.isValidPrivateKey = isValidPrivateKey;
/**
 * Returns whether or not the string is a composed of hex chars only
 *
 * @param {string} maybe - the  string to be validated
 * @returns {boolean} - the validation result
 */
function allHexChars(maybe) {
    return /^([0-9a-f])+$/i.test(maybe);
}
/**
 * Checks if raw transaction can be deserialized
 *
 * @param {unknown} rawTransaction - transaction in raw hex format
 * @returns {boolean} - the validation result
 */
function isValidRawTransaction(rawTransaction) {
    try {
        if (typeof rawTransaction === 'string') {
            (0, transactions_1.deserializeTransaction)(transactions_1.BufferReader.fromBuffer(Buffer.from(removeHexPrefix(rawTransaction), 'hex')));
        }
        else {
            return false;
        }
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.isValidRawTransaction = isValidRawTransaction;
/**
 * Returns whether or not the memo string is valid
 *
 * @param {string} memo - the string to be validated
 * @returns {boolean} - the validation result
 */
function isValidMemo(memo) {
    try {
        (0, transactions_1.createMemoString)(memo);
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.isValidMemo = isValidMemo;
/**
 * Checks for valid contract address
 *
 * @param {string} addr - contract deployer address
 * @param {BitgoStacksNetwork} network - network object
 * @returns {boolean} - the validation result
 */
function isValidContractAddress(addr, network) {
    return addr === network.stakingContractAddress || addr === network.sendmanymemoContractAddress;
}
exports.isValidContractAddress = isValidContractAddress;
/**
 * Check if the name is one of valid contract names
 *
 * @param {string} name - function name
 * @returns {boolean} - validation result
 */
function isValidContractFunctionName(name) {
    return constants_1.VALID_CONTRACT_FUNCTION_NAMES.includes(name);
}
exports.isValidContractFunctionName = isValidContractFunctionName;
/**
 * Unpads a memo string, so it removes nulls.
 *
 * Useful when memo is fill up the length. Result is becomes readable.
 *
 * @param {string} memo - the string to be validated
 * @returns {boolean} - the validation result
 */
function unpadMemo(memo) {
    const end = memo.indexOf('\u0000');
    if (end < 0)
        return memo;
    return memo.slice(0, end);
}
exports.unpadMemo = unpadMemo;
/**
 * Generate a multisig address from multiple STX public keys
 *
 * @param {string[]} pubKeys - list of public keys as strings
 * @param {AddressVersion} addressVersion - MainnetMultiSig, TestnetMultiSig
 * @param {AddressHashMode} addressHashMode - SerializeP2SH
 * @param {number} [signaturesRequired] - number of signatures required, default value its 2
 * @returns {address: string, hash160: string} - a multisig address
 */
function getSTXAddressFromPubKeys(pubKeys, addressVersion = transactions_1.AddressVersion.MainnetMultiSig, addressHashMode = transactions_1.AddressHashMode.SerializeP2SH, signaturesRequired = 2) {
    if (pubKeys.length === 0) {
        throw new Error('Invalid number of public keys');
    }
    if (!pubKeys.every(isValidPublicKey)) {
        throw new Error('Invalid public keys');
    }
    if (signaturesRequired > pubKeys.length) {
        throw new Error('Number of signatures required must be lower or equal to the number of Public Keys');
    }
    const stxPubKeys = pubKeys.map(transactions_1.createStacksPublicKey);
    const address = (0, transactions_1.addressFromPublicKeys)(addressVersion, addressHashMode, signaturesRequired, stxPubKeys);
    return { address: (0, transactions_1.addressToString)(address), hash160: address.hash160 };
}
exports.getSTXAddressFromPubKeys = getSTXAddressFromPubKeys;
/**
 * signs a string message
 *
 * @param keyPair
 * @param data  - message to be signed
 * @returns signed message string
 */
function signMessage(keyPair, data) {
    const prv = keyPair.getKeys().prv;
    if (prv) {
        return (0, transactions_1.signWithKey)((0, transactions_1.createStacksPrivateKey)(prv), data).data;
    }
    else {
        throw new sdk_core_1.SigningError('Missing private key');
    }
}
exports.signMessage = signMessage;
/**
 * Verifies a signed message
 *
 * The signature must be 130 bytes long -- see RECOVERABLE_ECDSA_SIG_LENGTH_BYTES
 * in @stacks/transactions/src/constants.ts
 *
 * @param {string} message - message to verify the signature
 * @param {string} signature - signature to verify
 * @param {string} publicKey - public key as hex string used to verify the signature
 * @returns {boolean} - verification result
 */
function verifySignature(message, signature, publicKey) {
    if (!isValidPublicKey(publicKey))
        return false;
    if (signature.length !== 130)
        return false;
    if (!allHexChars(signature))
        throw new sdk_core_1.UtilsError('Invalid signature input to verifySignature');
    if (_.isEmpty(message))
        throw new sdk_core_1.UtilsError('Cannot verify empty messages');
    // provided publicKey can be compressed or uncompressed
    const keyEncoding = publicKey.length === 66 ? transactions_1.PubKeyEncoding.Compressed : transactions_1.PubKeyEncoding.Uncompressed;
    const messageSig = (0, transactions_1.createMessageSignature)(signature);
    const foundKey = (0, transactions_1.publicKeyFromSignature)(message, messageSig, keyEncoding);
    return foundKey === publicKey;
}
exports.verifySignature = verifySignature;
/**
 * Process address into address and memo id
 *
 * @param {string} address the address to process
 * @returns {Object} object containing address and memo id
 */
function getAddressDetails(address) {
    const addressDetails = url.parse(address);
    const queryDetails = addressDetails.query ? new URLSearchParams(addressDetails.query) : undefined;
    const baseAddress = addressDetails.pathname;
    if (!isValidAddress(baseAddress)) {
        throw new sdk_core_1.UtilsError(`invalid address: ${address}`);
    }
    // address doesn't have a memo id
    if (baseAddress === address) {
        return {
            address: address,
            memoId: undefined,
        };
    }
    if (!queryDetails || _.isNil(queryDetails.get('memoId'))) {
        // if there are more properties, the query details need to contain the memo id property
        throw new sdk_core_1.UtilsError(`invalid address with memo id: ${address}`);
    }
    const memoId = queryDetails.get('memoId');
    const intMemoId = parseInt(memoId, 10);
    if (isNaN(intMemoId) || intMemoId < 0) {
        throw new Error(`invalid memo id: ${memoId}`);
    }
    return {
        address: baseAddress,
        memoId,
    };
}
exports.getAddressDetails = getAddressDetails;
/**
 * Validate and return address with appended memo id
 *
 * @param {AddressDetails} addressDetails
 * @returns {string} address with memo id
 */
function normalizeAddress({ address, memoId }) {
    if (!isValidAddress(address)) {
        throw new sdk_core_1.UtilsError(`invalid address: ${address}`);
    }
    if (!_.isUndefined(memoId)) {
        const intMemoId = parseInt(memoId, 10);
        if (isNaN(intMemoId) || intMemoId < 0) {
            throw new Error(`invalid memo id: ${memoId}`);
        }
        return `${address}?memoId=${memoId}`;
    }
    return address;
}
exports.normalizeAddress = normalizeAddress;
/**
 * Return boolean indicating whether input is a valid address with memo id
 *
 * @param {string} address address in the form <address>?memoId=<memoId>
 * @returns {boolean} true is input is a valid address
 */
function isValidAddressWithPaymentId(address) {
    try {
        const addressDetails = getAddressDetails(address);
        return address === normalizeAddress(addressDetails);
    }
    catch (e) {
        return false;
    }
}
exports.isValidAddressWithPaymentId = isValidAddressWithPaymentId;
/**
 * Return string representation of clarity value input
 *
 * @param {ClarityValue} cv clarity value function argument
 * @returns {String} stringified clarity value
 */
function stringifyCv(cv) {
    switch (cv.type) {
        case transactions_1.ClarityType.Int:
        case transactions_1.ClarityType.UInt:
            return { type: cv.type, value: cv.value.toString() };
        case transactions_1.ClarityType.OptionalSome:
            return { type: cv.type, value: stringifyCv(cv.value) };
        case transactions_1.ClarityType.Tuple:
            return {
                type: cv.type,
                data: _.mapValues(cv.data, (value) => stringifyCv(value)),
            };
        case transactions_1.ClarityType.List:
            return {
                type: cv.type,
                list: cv.list.map(stringifyCv),
            };
        default:
            return cv;
    }
}
exports.stringifyCv = stringifyCv;
/**
 * Parse functionArgs into send params for send-many-memo contract calls
 *
 * @param {ClarityValue[]} args functionArgs from a contract call payload
 * @returns {SendParams[]} An array of sendParams
 */
function functionArgsToSendParams(args) {
    if (args.length !== 1 || args[0].type !== transactions_1.ClarityType.List) {
        throw new sdk_core_1.InvalidTransactionError("function args don't match send-many-memo type declaration");
    }
    return args[0].list.map((tuple) => {
        var _a, _b, _c;
        if (tuple.type !== transactions_1.ClarityType.Tuple ||
            ((_a = tuple.data.to) === null || _a === void 0 ? void 0 : _a.type) !== transactions_1.ClarityType.PrincipalStandard ||
            ((_b = tuple.data.ustx) === null || _b === void 0 ? void 0 : _b.type) !== transactions_1.ClarityType.UInt ||
            ((_c = tuple.data.memo) === null || _c === void 0 ? void 0 : _c.type) !== transactions_1.ClarityType.Buffer) {
            throw new sdk_core_1.InvalidTransactionError("function args don't match send-many-memo type declaration");
        }
        return {
            address: (0, transactions_1.cvToString)(tuple.data.to),
            amount: (0, transactions_1.cvToValue)(tuple.data.ustx, true),
            memo: tuple.data.memo.buffer.toString('ascii'),
        };
    });
}
exports.functionArgsToSendParams = functionArgsToSendParams;
/**
 * Gets the version of an address
 *
 * @param {String} address the address with or without the memoId
 * @returns {AddressVersion} A number that represent the Address Version
 */
function getAddressVersion(address) {
    const baseAddress = getAddressDetails(address).address;
    return (0, transactions_1.createAddress)(baseAddress).version;
}
exports.getAddressVersion = getAddressVersion;
/**
 * Returns a STX pub key from an xpub
 *
 * @param {String} xpub an xpub
 * @returns {String} a compressed STX pub key
 */
function xpubToSTXPubkey(xpub, compressed = true) {
    return new _1.KeyPair({ pub: xpub }).getKeys(compressed).pub;
}
exports.xpubToSTXPubkey = xpubToSTXPubkey;
/**
 * Returns the base address portion of an address
 *
 * @param {String} address - an address
 * @returns {String} - the base address
 */
function getBaseAddress(address) {
    const addressDetails = getAddressDetails(address);
    return addressDetails.address;
}
exports.getBaseAddress = getBaseAddress;
/**
 * Compares an address to the base address to check if matchs.
 *
 * @param {String} address - an address
 * @param {String} baseAddress - a base address
 * @returns {boolean}
 */
function isSameBaseAddress(address, baseAddress) {
    if (!isValidAddressWithPaymentId(address)) {
        throw new sdk_core_1.UtilsError(`invalid address: ${address}`);
    }
    return getBaseAddress(address) === getBaseAddress(baseAddress);
}
exports.isSameBaseAddress = isSameBaseAddress;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEseUNBQTJCO0FBQzNCLGdFQUFxQztBQUNyQyxxREFBOEQ7QUFDOUQsdURBd0I4QjtBQUM5Qix1Q0FBOEI7QUFDOUIsMENBQTRCO0FBQzVCLDhDQUE4RztBQUU5Ryx3QkFBNEI7QUFFNUIsMkNBQTREO0FBRTVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsdUJBQXVCLENBQUMsSUFBWTtJQUNsRCxPQUFPLElBQUEsNkJBQVcsRUFBQyxJQUFJLENBQUMsQ0FBQztBQUMzQixDQUFDO0FBRkQsMERBRUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLGVBQWUsQ0FBQyxHQUFXO0lBQ3pDLE9BQU8sSUFBQSxnQ0FBYyxFQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzdCLENBQUM7QUFGRCwwQ0FFQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxTQUFTLDJCQUEyQixDQUNsQyxhQUFxQixFQUNyQixRQUF5QixFQUN6QixrQkFBc0M7SUFFdEMsSUFBSSxhQUFhLENBQUMsTUFBTSxLQUFLLEVBQUUsRUFBRTtRQUMvQixNQUFNLElBQUksS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7S0FDaEQ7SUFFRCxNQUFNLE9BQU8sR0FBRyxJQUFBLHVDQUF3QixFQUFDLFFBQVEsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3ZFLE1BQU0sSUFBSSxHQUFHLElBQUEscUNBQXNCLEVBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUM1RSxNQUFNLFVBQVUsR0FBRyxJQUFBLDhCQUFlLEVBQUMsSUFBSSxDQUFDLENBQUM7SUFDekMsT0FBTyxVQUFVLENBQUM7QUFDcEIsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0Isa0JBQWtCLENBQUMsRUFB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QUFXLEdBQUcsaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDO0lBQ3ZELE9BQU8sSUFBQSw0QkFBYSxFQUFDLFdBQVcsQ0FBQyxDQUFDLE9BQU8sQ0FBQztBQUM1QyxDQUFDO0FBSEQsOENBR0M7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLGVBQWUsQ0FBQyxJQUFZLEVBQUUsVUFBVSxHQUFHLElBQUk7SUFDN0QsT0FBTyxJQUFJLFVBQU8sQ0FBQyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDNUQsQ0FBQztBQUZELDBDQUVDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixjQUFjLENBQUMsT0FBZTtJQUM1QyxNQUFNLGNBQWMsR0FBRyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNsRCxPQUFPLGNBQWMsQ0FBQyxPQUFPLENBQUM7QUFDaEMsQ0FBQztBQUhELHdDQUdDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsaUJBQWlCLENBQUMsT0FBZSxFQUFFLFdBQW1CO0lBQ3BFLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxPQUFPLENBQUMsRUFBRTtRQUN6QyxNQUFNLElBQUkscUJBQVUsQ0FBQyxvQkFBb0IsT0FBTyxFQUFFLENBQUMsQ0FBQztLQUNyRDtJQUNELE9BQU8sY0FBYyxDQUFDLE9BQU8sQ0FBQyxLQUFLLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUNqRSxDQUFDO0FBTEQsOENBS0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1cmwgZnJvbSAndXJsJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IGJ1ZmZlclRvSGV4LCBzdHJpcEhleFByZWZpeCB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5pbXBvcnQge1xuICBhZGRyZXNzRnJvbVB1YmxpY0tleXMsXG4gIGFkZHJlc3NGcm9tVmVyc2lvbkhhc2gsXG4gIEFkZHJlc3NIYXNoTW9kZSxcbiAgYWRkcmVzc0hhc2hNb2RlVG9WZXJzaW9uLFxuICBhZGRyZXNzVG9TdHJpbmcsXG4gIEFkZHJlc3NWZXJzaW9uLFxuICBCdWZmZXJSZWFkZXIsXG4gIENsYXJpdHlUeXBlLFxuICBDbGFyaXR5VmFsdWUsXG4gIGNyZWF0ZUFkZHJlc3MsXG4gIGNyZWF0ZU1lbW9TdHJpbmcsXG4gIGNyZWF0ZU1lc3NhZ2VTaWduYXR1cmUsXG4gIGNyZWF0ZVN0YWNrc1ByaXZhdGVLZXksXG4gIGNyZWF0ZVN0YWNrc1B1YmxpY0tleSxcbiAgY3ZUb1N0cmluZyxcbiAgY3ZUb1ZhbHVlLFxuICBkZXNlcmlhbGl6ZVRyYW5zYWN0aW9uLFxuICBQdWJLZXlFbmNvZGluZyxcbiAgcHVibGljS2V5RnJvbVNpZ25hdHVyZSxcbiAgc2lnbldpdGhLZXksXG4gIFN0YWNrc1RyYW5zYWN0aW9uLFxuICBUcmFuc2FjdGlvblZlcnNpb24sXG4gIHZhbGlkYXRlU3RhY2tzQWRkcmVzcyxcbn0gZnJvbSAnQHN0YWNrcy90cmFuc2FjdGlvbnMnO1xuaW1wb3J0IHsgZWMgfSBmcm9tICdlbGxpcHRpYyc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvciwgaXNWYWxpZFhwcnYsIGlzVmFsaWRYcHViLCBTaWduaW5nRXJyb3IsIFV0aWxzRXJyb3IgfSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgQWRkcmVzc0RldGFpbHMsIFNlbmRQYXJhbXMgfSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IEtleVBhaXIgfSBmcm9tICcuJztcbmltcG9ydCB7IFN0YWNrc05ldHdvcmsgYXMgQml0Z29TdGFja3NOZXR3b3JrIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHsgVkFMSURfQ09OVFJBQ1RfRlVOQ1RJT05fTkFNRVMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogRW5jb2RlcyBhIGJ1ZmZlciBhcyBhIFwiMHhcIiBwcmVmaXhlZCBsb3dlci1jYXNlIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmYgLSBhIGJ1ZmZlciB3aXRoIGEgaGV4YWRlY2ltYWwgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgcHJlZml4ZWQgd2l0aCBcIjB4XCJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlclRvSGV4UHJlZml4U3RyaW5nKGJ1ZmY6IEJ1ZmZlcik6IHN0cmluZyB7XG4gIHJldHVybiBidWZmZXJUb0hleChidWZmKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIFwiMHhcIiBwcmVmaXggZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLCBpZiBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZXggLSBhIGhleGFkZWNpbWFsIHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgaGV4YWRlY2ltYWwgc3RyaW5nIHdpdGhvdXQgYSBsZWFkaW5nIFwiMHhcIlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlSGV4UHJlZml4KGhleDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHN0cmlwSGV4UHJlZml4KGhleCk7XG59XG5cbi8qKlxuICogR2V0IHN0YWNrcyBhZGRyZXNzIGZyb20gcHVibGljIGtleSBoYXNoXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleUhhc2ggLSBoYXNoIG9mIHB1YmxpYyBrZXlcbiAqIEBwYXJhbSB7QWRkcmVzc0hhc2hNb2RlfSBoYXNoTW9kZSAtIGhhc2ggbW9kZVxuICogQHBhcmFtIHtUcmFuc2FjdGlvblZlcnNpb259IHRyYW5zYWN0aW9uVmVyc2lvbiAtIHR4IHZlcnNpb25cbiAqIEByZXR1cm5zIHtzdHJpbmd9IHN0YWNrcyBhZGRyZXNzXG4gKi9cbmZ1bmN0aW9uIGdldEFkZHJlc3NGcm9tUHVibGljS2V5SGFzaChcbiAgcHVibGljS2V5SGFzaDogQnVmZmVyLFxuICBoYXNoTW9kZTogQWRkcmVzc0hhc2hNb2RlLFxuICB0cmFuc2FjdGlvblZlcnNpb246IFRyYW5zYWN0aW9uVmVyc2lvblxuKTogc3RyaW5nIHtcbiAgaWYgKHB1YmxpY0tleUhhc2gubGVuZ3RoICE9PSAyMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgMjAtYnl0ZSBwdWJrZXloYXNoJyk7XG4gIH1cblxuICBjb25zdCBhZGRyVmVyID0gYWRkcmVzc0hhc2hNb2RlVG9WZXJzaW9uKGhhc2hNb2RlLCB0cmFuc2FjdGlvblZlcnNpb24pO1xuICBjb25zdCBhZGRyID0gYWRkcmVzc0Zyb21WZXJzaW9uSGFzaChhZGRyVmVyLCBwdWJsaWNLZXlIYXNoLnRvU3RyaW5nKCdoZXgnKSk7XG4gIGNvbnN0IGFkZHJTdHJpbmcgPSBhZGRyZXNzVG9TdHJpbmcoYWRkcik7XG4gIHJldHVybiBhZGRyU3RyaW5nO1xufVxuXG4vKipcbiAqIEBwYXJhbSB0eFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHhTZW5kZXJBZGRyZXNzKHR4OiBTdGFja3NUcmFuc2FjdGlvbik6IHN0cmluZyB7XG4gIGlmICh0eC5hdXRoLnNwZW5kaW5nQ29uZGl0aW9uICE9PSBudWxsICYmIHR4LmF1dGguc3BlbmRpbmdDb25kaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHNwZW5kaW5nQ29uZGl0aW9uID0gdHguYXV0aC5zcGVuZGluZ0NvbmRpdGlvbjtcbiAgICBjb25zdCB0eFNlbmRlciA9IGdldEFkZHJlc3NGcm9tUHVibGljS2V5SGFzaChcbiAgICAgIEJ1ZmZlci5mcm9tKHNwZW5kaW5nQ29uZGl0aW9uLnNpZ25lciwgJ2hleCcpLFxuICAgICAgc3BlbmRpbmdDb25kaXRpb24uaGFzaE1vZGUgYXMgbnVtYmVyLFxuICAgICAgdHgudmVyc2lvblxuICAgICk7XG4gICAgcmV0dXJuIHR4U2VuZGVyO1xuICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKCdzcGVuZGluZ0NvbmRpdGlvbiBzaG91bGQgbm90IGJlIG51bGwnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBhbW91bnQgbnVtYmVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFtb3VudCAtIHRoZSBzdHJpbmcgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEFtb3VudChhbW91bnQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBiaWdOdW1iZXJBbW91bnQgPSBuZXcgQmlnTnVtYmVyKGFtb3VudCk7XG4gIHJldHVybiBiaWdOdW1iZXJBbW91bnQuaXNJbnRlZ2VyKCkgJiYgYmlnTnVtYmVyQW1vdW50LmlzR3JlYXRlclRoYW5PckVxdWFsVG8oMCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgcHJvdG9jb2wgYWRkcmVzc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gdGhlIGFkZHJlc3MgdG8gYmUgdmFsaWRhdGVkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gdmFsaWRhdGVTdGFja3NBZGRyZXNzKGFkZHJlc3MpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIHByb3RvY29sIHRyYW5zYWN0aW9uIGlkIG9yIG5vdC5cbiAqXG4gKiBBIHZhbGlkIHRyYW5zYWN0aW9uIGlkIGlzIGEgU0hBLTUxMi8yNTYgaGFzaCBvZiBhIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb247IHNlZVxuICogdGhlIHR4aWRGcm9tRGF0YSBmdW5jdGlvbiBpbiBAc3RhY2tzL3RyYW5zYWN0aW9uOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2Jsb2Nrc3RhY2svc3RhY2tzLmpzL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3RyYW5zYWN0aW9ucy9zcmMvdXRpbHMudHMjTDk3XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR4SWQgLSB0aGUgdHJhbnNhY3Rpb24gaWQgdG8gYmUgdmFsaWRhdGVkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRUcmFuc2FjdGlvbklkKHR4SWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAodHhJZC5sZW5ndGggIT09IDY0ICYmIHR4SWQubGVuZ3RoICE9PSA2NikgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub1ByZWZpeCA9IHJlbW92ZUhleFByZWZpeCh0eElkKTtcbiAgaWYgKG5vUHJlZml4Lmxlbmd0aCAhPT0gNjQpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gYWxsSGV4Q2hhcnMobm9QcmVmaXgpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIHByb3RvY29sIHB1YmxpYyBrZXkgb3JcbiAqIGV4dGVuZGVkIHB1YmxpYyBrZXkuXG4gKlxuICogVGhlIGtleSBmb3JtYXQgaXMgZG9jdW1lbnRlZCBhdFxuICogaHR0cHM6Ly9naXRodWIuY29tL3N0YWNrc2dvdi9zaXBzL2Jsb2IvbWFpbi9zaXBzL3NpcC0wMDUvc2lwLTAwNS1ibG9ja3MtYW5kLXRyYW5zYWN0aW9ucy5tZCN0cmFuc2FjdGlvbi1hdXRob3JpemF0aW9uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHB1YiAtIHRoZSAgcHVibGljIGtleSB0byBiZSB2YWxpZGF0ZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFB1YmxpY0tleShwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAoaXNWYWxpZFhwdWIocHViKSkgcmV0dXJuIHRydWU7XG5cbiAgaWYgKHB1Yi5sZW5ndGggIT09IDY2ICYmIHB1Yi5sZW5ndGggIT09IDEzMCkgcmV0dXJuIGZhbHNlO1xuXG4gIGNvbnN0IGZpcnN0Qnl0ZSA9IHB1Yi5zbGljZSgwLCAyKTtcblxuICAvLyB1bmNvbXByZXNzZWQgcHVibGljIGtleVxuICBpZiAocHViLmxlbmd0aCA9PT0gMTMwICYmIGZpcnN0Qnl0ZSAhPT0gJzA0JykgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIGNvbXByZXNzZWQgcHVibGljIGtleVxuICBpZiAocHViLmxlbmd0aCA9PT0gNjYgJiYgZmlyc3RCeXRlICE9PSAnMDInICYmIGZpcnN0Qnl0ZSAhPT0gJzAzJykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghYWxsSGV4Q2hhcnMocHViKSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIHZhbGlkYXRlIHRoZSBwdWJsaWMga2V5XG4gIGNvbnN0IHNlY3AyNTZrMSA9IG5ldyBlYygnc2VjcDI1NmsxJyk7XG4gIHRyeSB7XG4gICAgY29uc3Qga2V5UGFpciA9IHNlY3AyNTZrMS5rZXlGcm9tUHVibGljKEJ1ZmZlci5mcm9tKHB1YiwgJ2hleCcpKTtcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0ga2V5UGFpci52YWxpZGF0ZSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBwcm90b2NvbCBwcml2YXRlIGtleSwgb3IgZXh0ZW5kZWRcbiAqIHByaXZhdGUga2V5LlxuICpcbiAqIFRoZSBwcm90b2NvbCBrZXkgZm9ybWF0IGlzIGRlc2NyaWJlZCBpbiB0aGUgQHN0YWNrcy90cmFuc2FjdGlvbnMgbnBtIHBhY2thZ2UsIGluIHRoZVxuICogY3JlYXRlU3RhY2tzUHJpdmF0ZUtleSBmdW5jdGlvbjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibG9ja3N0YWNrL3N0YWNrcy5qcy9ibG9iL21hc3Rlci9wYWNrYWdlcy90cmFuc2FjdGlvbnMvc3JjL2tleXMudHMjTDEyNVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcnYgLSB0aGUgcHJpdmF0ZSBrZXkgKG9yIGV4dGVuZGVkIHByaXZhdGUga2V5KSB0byBiZSB2YWxpZGF0ZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFByaXZhdGVLZXkocHJ2OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKGlzVmFsaWRYcHJ2KHBydikpIHJldHVybiB0cnVlO1xuXG4gIGlmIChwcnYubGVuZ3RoICE9PSA2NCAmJiBwcnYubGVuZ3RoICE9PSA2NikgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChwcnYubGVuZ3RoID09PSA2NiAmJiBwcnYuc2xpY2UoNjQpICE9PSAnMDEnKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIGFsbEhleENoYXJzKHBydik7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGEgY29tcG9zZWQgb2YgaGV4IGNoYXJzIG9ubHlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWF5YmUgLSB0aGUgIHN0cmluZyB0byBiZSB2YWxpZGF0ZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhbGxIZXhDaGFycyhtYXliZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiAvXihbMC05YS1mXSkrJC9pLnRlc3QobWF5YmUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiByYXcgdHJhbnNhY3Rpb24gY2FuIGJlIGRlc2VyaWFsaXplZFxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gcmF3VHJhbnNhY3Rpb24gLSB0cmFuc2FjdGlvbiBpbiByYXcgaGV4IGZvcm1hdFxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb246IHVua25vd24pOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHJhd1RyYW5zYWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgZGVzZXJpYWxpemVUcmFuc2FjdGlvbihCdWZmZXJSZWFkZXIuZnJvbUJ1ZmZlcihCdWZmZXIuZnJvbShyZW1vdmVIZXhQcmVmaXgocmF3VHJhbnNhY3Rpb24pLCAnaGV4JykpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1lbW8gc3RyaW5nIGlzIHZhbGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lbW8gLSB0aGUgc3RyaW5nIHRvIGJlIHZhbGlkYXRlZFxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTWVtbyhtZW1vOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjcmVhdGVNZW1vU3RyaW5nKG1lbW8pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGZvciB2YWxpZCBjb250cmFjdCBhZGRyZXNzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHIgLSBjb250cmFjdCBkZXBsb3llciBhZGRyZXNzXG4gKiBAcGFyYW0ge0JpdGdvU3RhY2tzTmV0d29ya30gbmV0d29yayAtIG5ldHdvcmsgb2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRDb250cmFjdEFkZHJlc3MoYWRkcjogc3RyaW5nLCBuZXR3b3JrOiBCaXRnb1N0YWNrc05ldHdvcmspOiBib29sZWFuIHtcbiAgcmV0dXJuIGFkZHIgPT09IG5ldHdvcmsuc3Rha2luZ0NvbnRyYWN0QWRkcmVzcyB8fCBhZGRyID09PSBuZXR3b3JrLnNlbmRtYW55bWVtb0NvbnRyYWN0QWRkcmVzcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgbmFtZSBpcyBvbmUgb2YgdmFsaWQgY29udHJhY3QgbmFtZXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIGZ1bmN0aW9uIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQ29udHJhY3RGdW5jdGlvbk5hbWUobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBWQUxJRF9DT05UUkFDVF9GVU5DVElPTl9OQU1FUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuLyoqXG4gKiBVbnBhZHMgYSBtZW1vIHN0cmluZywgc28gaXQgcmVtb3ZlcyBudWxscy5cbiAqXG4gKiBVc2VmdWwgd2hlbiBtZW1vIGlzIGZpbGwgdXAgdGhlIGxlbmd0aC4gUmVzdWx0IGlzIGJlY29tZXMgcmVhZGFibGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lbW8gLSB0aGUgc3RyaW5nIHRvIGJlIHZhbGlkYXRlZFxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnBhZE1lbW8obWVtbzogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgZW5kID0gbWVtby5pbmRleE9mKCdcXHUwMDAwJyk7XG4gIGlmIChlbmQgPCAwKSByZXR1cm4gbWVtbztcbiAgcmV0dXJuIG1lbW8uc2xpY2UoMCwgZW5kKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG11bHRpc2lnIGFkZHJlc3MgZnJvbSBtdWx0aXBsZSBTVFggcHVibGljIGtleXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwdWJLZXlzIC0gbGlzdCBvZiBwdWJsaWMga2V5cyBhcyBzdHJpbmdzXG4gKiBAcGFyYW0ge0FkZHJlc3NWZXJzaW9ufSBhZGRyZXNzVmVyc2lvbiAtIE1haW5uZXRNdWx0aVNpZywgVGVzdG5ldE11bHRpU2lnXG4gKiBAcGFyYW0ge0FkZHJlc3NIYXNoTW9kZX0gYWRkcmVzc0hhc2hNb2RlIC0gU2VyaWFsaXplUDJTSFxuICogQHBhcmFtIHtudW1iZXJ9IFtzaWduYXR1cmVzUmVxdWlyZWRdIC0gbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQsIGRlZmF1bHQgdmFsdWUgaXRzIDJcbiAqIEByZXR1cm5zIHthZGRyZXNzOiBzdHJpbmcsIGhhc2gxNjA6IHN0cmluZ30gLSBhIG11bHRpc2lnIGFkZHJlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNUWEFkZHJlc3NGcm9tUHViS2V5cyhcbiAgcHViS2V5czogc3RyaW5nW10sXG4gIGFkZHJlc3NWZXJzaW9uOiBBZGRyZXNzVmVyc2lvbiA9IEFkZHJlc3NWZXJzaW9uLk1haW5uZXRNdWx0aVNpZyxcbiAgYWRkcmVzc0hhc2hNb2RlOiBBZGRyZXNzSGFzaE1vZGUgPSBBZGRyZXNzSGFzaE1vZGUuU2VyaWFsaXplUDJTSCxcbiAgc2lnbmF0dXJlc1JlcXVpcmVkID0gMlxuKTogeyBhZGRyZXNzOiBzdHJpbmc7IGhhc2gxNjA6IHN0cmluZyB9IHtcbiAgaWYgKHB1YktleXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciBvZiBwdWJsaWMga2V5cycpO1xuICB9XG4gIGlmICghcHViS2V5cy5ldmVyeShpc1ZhbGlkUHVibGljS2V5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwdWJsaWMga2V5cycpO1xuICB9XG4gIGlmIChzaWduYXR1cmVzUmVxdWlyZWQgPiBwdWJLZXlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgbXVzdCBiZSBsb3dlciBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIFB1YmxpYyBLZXlzJyk7XG4gIH1cblxuICBjb25zdCBzdHhQdWJLZXlzID0gcHViS2V5cy5tYXAoY3JlYXRlU3RhY2tzUHVibGljS2V5KTtcbiAgY29uc3QgYWRkcmVzcyA9IGFkZHJlc3NGcm9tUHVibGljS2V5cyhhZGRyZXNzVmVyc2lvbiwgYWRkcmVzc0hhc2hNb2RlLCBzaWduYXR1cmVzUmVxdWlyZWQsIHN0eFB1YktleXMpO1xuXG4gIHJldHVybiB7IGFkZHJlc3M6IGFkZHJlc3NUb1N0cmluZyhhZGRyZXNzKSwgaGFzaDE2MDogYWRkcmVzcy5oYXNoMTYwIH07XG59XG5cbi8qKlxuICogc2lnbnMgYSBzdHJpbmcgbWVzc2FnZVxuICpcbiAqIEBwYXJhbSBrZXlQYWlyXG4gKiBAcGFyYW0gZGF0YSAgLSBtZXNzYWdlIHRvIGJlIHNpZ25lZFxuICogQHJldHVybnMgc2lnbmVkIG1lc3NhZ2Ugc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWduTWVzc2FnZShrZXlQYWlyOiBLZXlQYWlyLCBkYXRhOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBwcnYgPSBrZXlQYWlyLmdldEtleXMoKS5wcnY7XG4gIGlmIChwcnYpIHtcbiAgICByZXR1cm4gc2lnbldpdGhLZXkoY3JlYXRlU3RhY2tzUHJpdmF0ZUtleShwcnYpLCBkYXRhKS5kYXRhO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZSBrZXknKTtcbiAgfVxufVxuXG4vKipcbiAqIFZlcmlmaWVzIGEgc2lnbmVkIG1lc3NhZ2VcbiAqXG4gKiBUaGUgc2lnbmF0dXJlIG11c3QgYmUgMTMwIGJ5dGVzIGxvbmcgLS0gc2VlIFJFQ09WRVJBQkxFX0VDRFNBX1NJR19MRU5HVEhfQllURVNcbiAqIGluIEBzdGFja3MvdHJhbnNhY3Rpb25zL3NyYy9jb25zdGFudHMudHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIG1lc3NhZ2UgdG8gdmVyaWZ5IHRoZSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaWduYXR1cmUgLSBzaWduYXR1cmUgdG8gdmVyaWZ5XG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljS2V5IC0gcHVibGljIGtleSBhcyBoZXggc3RyaW5nIHVzZWQgdG8gdmVyaWZ5IHRoZSBzaWduYXR1cmVcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHZlcmlmaWNhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZShtZXNzYWdlOiBzdHJpbmcsIHNpZ25hdHVyZTogc3RyaW5nLCBwdWJsaWNLZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAoIWlzVmFsaWRQdWJsaWNLZXkocHVibGljS2V5KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoc2lnbmF0dXJlLmxlbmd0aCAhPT0gMTMwKSByZXR1cm4gZmFsc2U7XG4gIGlmICghYWxsSGV4Q2hhcnMoc2lnbmF0dXJlKSkgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGlucHV0IHRvIHZlcmlmeVNpZ25hdHVyZScpO1xuICBpZiAoXy5pc0VtcHR5KG1lc3NhZ2UpKSB0aHJvdyBuZXcgVXRpbHNFcnJvcignQ2Fubm90IHZlcmlmeSBlbXB0eSBtZXNzYWdlcycpO1xuXG4gIC8vIHByb3ZpZGVkIHB1YmxpY0tleSBjYW4gYmUgY29tcHJlc3NlZCBvciB1bmNvbXByZXNzZWRcbiAgY29uc3Qga2V5RW5jb2RpbmcgPSBwdWJsaWNLZXkubGVuZ3RoID09PSA2NiA/IFB1YktleUVuY29kaW5nLkNvbXByZXNzZWQgOiBQdWJLZXlFbmNvZGluZy5VbmNvbXByZXNzZWQ7XG5cbiAgY29uc3QgbWVzc2FnZVNpZyA9IGNyZWF0ZU1lc3NhZ2VTaWduYXR1cmUoc2lnbmF0dXJlKTtcblxuICBjb25zdCBmb3VuZEtleSA9IHB1YmxpY0tleUZyb21TaWduYXR1cmUobWVzc2FnZSwgbWVzc2FnZVNpZywga2V5RW5jb2RpbmcpO1xuXG4gIHJldHVybiBmb3VuZEtleSA9PT0gcHVibGljS2V5O1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYWRkcmVzcyBpbnRvIGFkZHJlc3MgYW5kIG1lbW8gaWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyB0aGUgYWRkcmVzcyB0byBwcm9jZXNzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBhZGRyZXNzIGFuZCBtZW1vIGlkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzOiBzdHJpbmcpOiBBZGRyZXNzRGV0YWlscyB7XG4gIGNvbnN0IGFkZHJlc3NEZXRhaWxzID0gdXJsLnBhcnNlKGFkZHJlc3MpO1xuICBjb25zdCBxdWVyeURldGFpbHMgPSBhZGRyZXNzRGV0YWlscy5xdWVyeSA/IG5ldyBVUkxTZWFyY2hQYXJhbXMoYWRkcmVzc0RldGFpbHMucXVlcnkpIDogdW5kZWZpbmVkO1xuICBjb25zdCBiYXNlQWRkcmVzcyA9IGFkZHJlc3NEZXRhaWxzLnBhdGhuYW1lIGFzIHN0cmluZztcbiAgaWYgKCFpc1ZhbGlkQWRkcmVzcyhiYXNlQWRkcmVzcykpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gIH1cbiAgLy8gYWRkcmVzcyBkb2Vzbid0IGhhdmUgYSBtZW1vIGlkXG4gIGlmIChiYXNlQWRkcmVzcyA9PT0gYWRkcmVzcykge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgbWVtb0lkOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxuXG4gIGlmICghcXVlcnlEZXRhaWxzIHx8IF8uaXNOaWwocXVlcnlEZXRhaWxzLmdldCgnbWVtb0lkJykpKSB7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG1vcmUgcHJvcGVydGllcywgdGhlIHF1ZXJ5IGRldGFpbHMgbmVlZCB0byBjb250YWluIHRoZSBtZW1vIGlkIHByb3BlcnR5XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoYGludmFsaWQgYWRkcmVzcyB3aXRoIG1lbW8gaWQ6ICR7YWRkcmVzc31gKTtcbiAgfVxuICBjb25zdCBtZW1vSWQgPSBxdWVyeURldGFpbHMuZ2V0KCdtZW1vSWQnKSBhcyBzdHJpbmc7XG4gIGNvbnN0IGludE1lbW9JZCA9IHBhcnNlSW50KG1lbW9JZCwgMTApO1xuICBpZiAoaXNOYU4oaW50TWVtb0lkKSB8fCBpbnRNZW1vSWQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG1lbW8gaWQ6ICR7bWVtb0lkfWApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZGRyZXNzOiBiYXNlQWRkcmVzcyxcbiAgICBtZW1vSWQsXG4gIH07XG59XG5cbi8qKlxuICogVmFsaWRhdGUgYW5kIHJldHVybiBhZGRyZXNzIHdpdGggYXBwZW5kZWQgbWVtbyBpZFxuICpcbiAqIEBwYXJhbSB7QWRkcmVzc0RldGFpbHN9IGFkZHJlc3NEZXRhaWxzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBhZGRyZXNzIHdpdGggbWVtbyBpZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQWRkcmVzcyh7IGFkZHJlc3MsIG1lbW9JZCB9OiBBZGRyZXNzRGV0YWlscyk6IHN0cmluZyB7XG4gIGlmICghaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gIH1cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKG1lbW9JZCkpIHtcbiAgICBjb25zdCBpbnRNZW1vSWQgPSBwYXJzZUludChtZW1vSWQsIDEwKTtcbiAgICBpZiAoaXNOYU4oaW50TWVtb0lkKSB8fCBpbnRNZW1vSWQgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgbWVtbyBpZDogJHttZW1vSWR9YCk7XG4gICAgfVxuICAgIHJldHVybiBgJHthZGRyZXNzfT9tZW1vSWQ9JHttZW1vSWR9YDtcbiAgfVxuICByZXR1cm4gYWRkcmVzcztcbn1cblxuLyoqXG4gKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgYSB2YWxpZCBhZGRyZXNzIHdpdGggbWVtbyBpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIGFkZHJlc3MgaW4gdGhlIGZvcm0gPGFkZHJlc3M+P21lbW9JZD08bWVtb0lkPlxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaXMgaW5wdXQgaXMgYSB2YWxpZCBhZGRyZXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQWRkcmVzc1dpdGhQYXltZW50SWQoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSBnZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKTtcbiAgICByZXR1cm4gYWRkcmVzcyA9PT0gbm9ybWFsaXplQWRkcmVzcyhhZGRyZXNzRGV0YWlscyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGNsYXJpdHkgdmFsdWUgaW5wdXRcbiAqXG4gKiBAcGFyYW0ge0NsYXJpdHlWYWx1ZX0gY3YgY2xhcml0eSB2YWx1ZSBmdW5jdGlvbiBhcmd1bWVudFxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5naWZpZWQgY2xhcml0eSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5Q3YoY3Y6IENsYXJpdHlWYWx1ZSk6IGFueSB7XG4gIHN3aXRjaCAoY3YudHlwZSkge1xuICAgIGNhc2UgQ2xhcml0eVR5cGUuSW50OlxuICAgIGNhc2UgQ2xhcml0eVR5cGUuVUludDpcbiAgICAgIHJldHVybiB7IHR5cGU6IGN2LnR5cGUsIHZhbHVlOiBjdi52YWx1ZS50b1N0cmluZygpIH07XG4gICAgY2FzZSBDbGFyaXR5VHlwZS5PcHRpb25hbFNvbWU6XG4gICAgICByZXR1cm4geyB0eXBlOiBjdi50eXBlLCB2YWx1ZTogc3RyaW5naWZ5Q3YoY3YudmFsdWUpIH07XG4gICAgY2FzZSBDbGFyaXR5VHlwZS5UdXBsZTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGN2LnR5cGUsXG4gICAgICAgIGRhdGE6IF8ubWFwVmFsdWVzKGN2LmRhdGEsICh2YWx1ZSkgPT4gc3RyaW5naWZ5Q3YodmFsdWUpKSxcbiAgICAgIH07XG4gICAgY2FzZSBDbGFyaXR5VHlwZS5MaXN0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogY3YudHlwZSxcbiAgICAgICAgbGlzdDogY3YubGlzdC5tYXAoc3RyaW5naWZ5Q3YpLFxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGN2O1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgZnVuY3Rpb25BcmdzIGludG8gc2VuZCBwYXJhbXMgZm9yIHNlbmQtbWFueS1tZW1vIGNvbnRyYWN0IGNhbGxzXG4gKlxuICogQHBhcmFtIHtDbGFyaXR5VmFsdWVbXX0gYXJncyBmdW5jdGlvbkFyZ3MgZnJvbSBhIGNvbnRyYWN0IGNhbGwgcGF5bG9hZFxuICogQHJldHVybnMge1NlbmRQYXJhbXNbXX0gQW4gYXJyYXkgb2Ygc2VuZFBhcmFtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZnVuY3Rpb25BcmdzVG9TZW5kUGFyYW1zKGFyZ3M6IENsYXJpdHlWYWx1ZVtdKTogU2VuZFBhcmFtc1tdIHtcbiAgaWYgKGFyZ3MubGVuZ3RoICE9PSAxIHx8IGFyZ3NbMF0udHlwZSAhPT0gQ2xhcml0eVR5cGUuTGlzdCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihcImZ1bmN0aW9uIGFyZ3MgZG9uJ3QgbWF0Y2ggc2VuZC1tYW55LW1lbW8gdHlwZSBkZWNsYXJhdGlvblwiKTtcbiAgfVxuICByZXR1cm4gYXJnc1swXS5saXN0Lm1hcCgodHVwbGUpID0+IHtcbiAgICBpZiAoXG4gICAgICB0dXBsZS50eXBlICE9PSBDbGFyaXR5VHlwZS5UdXBsZSB8fFxuICAgICAgdHVwbGUuZGF0YS50bz8udHlwZSAhPT0gQ2xhcml0eVR5cGUuUHJpbmNpcGFsU3RhbmRhcmQgfHxcbiAgICAgIHR1cGxlLmRhdGEudXN0eD8udHlwZSAhPT0gQ2xhcml0eVR5cGUuVUludCB8fFxuICAgICAgdHVwbGUuZGF0YS5tZW1vPy50eXBlICE9PSBDbGFyaXR5VHlwZS5CdWZmZXJcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihcImZ1bmN0aW9uIGFyZ3MgZG9uJ3QgbWF0Y2ggc2VuZC1tYW55LW1lbW8gdHlwZSBkZWNsYXJhdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZHJlc3M6IGN2VG9TdHJpbmcodHVwbGUuZGF0YS50byksXG4gICAgICBhbW91bnQ6IGN2VG9WYWx1ZSh0dXBsZS5kYXRhLnVzdHgsIHRydWUpLFxuICAgICAgbWVtbzogdHVwbGUuZGF0YS5tZW1vLmJ1ZmZlci50b1N0cmluZygnYXNjaWknKSxcbiAgICB9O1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2ZXJzaW9uIG9mIGFuIGFkZHJlc3NcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB0aGUgYWRkcmVzcyB3aXRoIG9yIHdpdGhvdXQgdGhlIG1lbW9JZFxuICogQHJldHVybnMge0FkZHJlc3NWZXJzaW9ufSBBIG51bWJlciB0aGF0IHJlcHJlc2VudCB0aGUgQWRkcmVzcyBWZXJzaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRyZXNzVmVyc2lvbihhZGRyZXNzOiBzdHJpbmcpOiBBZGRyZXNzVmVyc2lvbiB7XG4gIGNvbnN0IGJhc2VBZGRyZXNzID0gZ2V0QWRkcmVzc0RldGFpbHMoYWRkcmVzcykuYWRkcmVzcztcbiAgcmV0dXJuIGNyZWF0ZUFkZHJlc3MoYmFzZUFkZHJlc3MpLnZlcnNpb247XG59XG5cbi8qKlxuICogUmV0dXJucyBhIFNUWCBwdWIga2V5IGZyb20gYW4geHB1YlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB4cHViIGFuIHhwdWJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGEgY29tcHJlc3NlZCBTVFggcHViIGtleVxuICovXG5leHBvcnQgZnVuY3Rpb24geHB1YlRvU1RYUHVia2V5KHhwdWI6IHN0cmluZywgY29tcHJlc3NlZCA9IHRydWUpOiBzdHJpbmcge1xuICByZXR1cm4gbmV3IEtleVBhaXIoeyBwdWI6IHhwdWIgfSkuZ2V0S2V5cyhjb21wcmVzc2VkKS5wdWI7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSBhZGRyZXNzIHBvcnRpb24gb2YgYW4gYWRkcmVzc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIC0gYW4gYWRkcmVzc1xuICogQHJldHVybnMge1N0cmluZ30gLSB0aGUgYmFzZSBhZGRyZXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCYXNlQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBhZGRyZXNzRGV0YWlscyA9IGdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3MpO1xuICByZXR1cm4gYWRkcmVzc0RldGFpbHMuYWRkcmVzcztcbn1cblxuLyoqXG4gKiBDb21wYXJlcyBhbiBhZGRyZXNzIHRvIHRoZSBiYXNlIGFkZHJlc3MgdG8gY2hlY2sgaWYgbWF0Y2hzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIC0gYW4gYWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGJhc2VBZGRyZXNzIC0gYSBiYXNlIGFkZHJlc3NcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTYW1lQmFzZUFkZHJlc3MoYWRkcmVzczogc3RyaW5nLCBiYXNlQWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmICghaXNWYWxpZEFkZHJlc3NXaXRoUGF5bWVudElkKGFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICB9XG4gIHJldHVybiBnZXRCYXNlQWRkcmVzcyhhZGRyZXNzKSA9PT0gZ2V0QmFzZUFkZHJlc3MoYmFzZUFkZHJlc3MpO1xufVxuIl19