"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InscriptionBuilder = void 0;
const abstract_utxo_1 = require("@bitgo/abstract-utxo");
const sdk_core_1 = require("@bitgo/sdk-core");
const utxolib = __importStar(require("@bitgo/utxo-lib"));
const utxo_ord_1 = require("@bitgo/utxo-ord");
const assert_1 = __importDefault(require("assert"));
const SUPPLEMENTARY_UNSPENTS_MIN_VALUE_SATS = [0, 20000, 200000];
class InscriptionBuilder {
    constructor(wallet, coin) {
        this.wallet = wallet;
        this.coin = coin;
    }
    async prepareReveal(inscriptionData, contentType) {
        const user = await this.wallet.baseCoin.keychains().get({ id: this.wallet.keyIds()[sdk_core_1.KeyIndices.USER] });
        (0, assert_1.default)(user.pub);
        const derived = this.coin.deriveKeyWithSeed({ key: user.pub, seed: inscriptionData.toString() });
        const compressedPublicKey = (0, sdk_core_1.xpubToCompressedPub)(derived.key);
        const xOnlyPublicKey = utxolib.bitgo.outputScripts.toXOnlyPublicKey(Buffer.from(compressedPublicKey, 'hex'));
        return utxo_ord_1.inscriptions.createInscriptionRevealData(xOnlyPublicKey, contentType, inscriptionData, this.coin.network);
    }
    async prepareTransferWithExtraInputs(satPoint, feeRateSatKB, { signer, cosigner, inscriptionConstraints, }, rootWalletKeys, outputs, inscriptionUnspents, supplementaryUnspentsMinValue) {
        let supplementaryUnspents = [];
        if (supplementaryUnspentsMinValue > 0) {
            const response = await this.wallet.unspents({
                minValue: supplementaryUnspentsMinValue,
            });
            // Filter out the inscription unspent from the supplementary unspents
            supplementaryUnspents = response.unspents
                .filter((unspent) => unspent.id !== inscriptionUnspents[0].id)
                .slice(0, utxo_ord_1.MAX_UNSPENTS_FOR_OUTPUT_LAYOUT - 1)
                .map((unspent) => {
                unspent.value = BigInt(unspent.value);
                return unspent;
            });
        }
        const psbt = (0, utxo_ord_1.createPsbtForSingleInscriptionPassingTransaction)(this.coin.network, {
            walletKeys: rootWalletKeys,
            signer,
            cosigner,
        }, inscriptionUnspents, satPoint, outputs, { feeRateSatKB, ...inscriptionConstraints }, { supplementaryUnspents });
        if (!psbt) {
            throw new Error('Fee too high for the selected unspent with this fee rate');
        }
        const allUnspents = [...inscriptionUnspents, ...supplementaryUnspents];
        // TODO: Remove the call to this function because it's already called inside the createPsbt function above.
        // Create & use a getFee function inside the created PSBT instead, lack of which necessitates a duplicate call here.
        const outputLayout = (0, utxo_ord_1.findOutputLayoutForWalletUnspents)(allUnspents, satPoint, outputs, {
            feeRateSatKB,
            ...inscriptionConstraints,
        });
        if (!outputLayout) {
            throw new Error('Fee too high for the selected unspent with this fee rate');
        }
        return {
            walletId: this.wallet.id(),
            txHex: psbt.getUnsignedTx().toHex(),
            txInfo: { unspents: allUnspents },
            feeInfo: { fee: Number(outputLayout.layout.feeOutput), feeString: outputLayout.layout.feeOutput.toString() },
        };
    }
    /**
     * Build a transaction to send an inscription
     * @param satPoint Satpoint you want to send
     * @param recipient Address you want to send to
     * @param feeRateSatKB Fee rate for transaction
     * @param signer first signer of the transaction
     * @param cosigner second signer of the transaction
     * @param inscriptionConstraints.minChangeOutput (optional) the minimum size of the change output
     * @param inscriptionConstraints.minInscriptionOutput (optional) the minimum number of sats of the output containing the inscription
     * @param inscriptionConstraints.maxInscriptionOutput (optional) the maximum number of sats of the output containing the inscription
     * @param changeAddressType Address type of the change address
     */
    async prepareTransfer(satPoint, recipient, feeRateSatKB, { signer = 'user', cosigner = 'bitgo', inscriptionConstraints = utxo_ord_1.DefaultInscriptionConstraints, changeAddressType = 'p2wsh', }) {
        (0, assert_1.default)((0, utxo_ord_1.isSatPoint)(satPoint));
        const rootWalletKeys = await (0, abstract_utxo_1.getWalletKeys)(this.coin, this.wallet);
        const parsedSatPoint = (0, utxo_ord_1.parseSatPoint)(satPoint);
        const transaction = await this.wallet.getTransaction({ txHash: parsedSatPoint.txid });
        const unspents = [transaction.outputs[parsedSatPoint.vout]];
        unspents[0].value = BigInt(unspents[0].value);
        const changeAddress = await this.wallet.createAddress({
            chain: utxolib.bitgo.getInternalChainCode(changeAddressType),
        });
        const outputs = {
            inscriptionRecipient: recipient,
            changeOutputs: [
                { chain: changeAddress.chain, index: changeAddress.index },
                { chain: changeAddress.chain, index: changeAddress.index },
            ],
        };
        for (const supplementaryUnspentsMinValue of SUPPLEMENTARY_UNSPENTS_MIN_VALUE_SATS) {
            try {
                return await this.prepareTransferWithExtraInputs(satPoint, feeRateSatKB, { signer, cosigner, inscriptionConstraints }, rootWalletKeys, outputs, unspents, supplementaryUnspentsMinValue);
            }
            catch (error) {
                if (!(error instanceof utxo_ord_1.ErrorNoLayout)) {
                    throw error; // Propagate error if it's not an ErrorNoLayout
                } // Otherwise continue trying with higher minValue for supplementary unspents
            }
        }
        throw new Error('Fee too high for the selected unspent with this fee rate'); // Exhausted all tries to supplement
    }
    /**
     *
     * @param walletPassphrase
     * @param tapLeafScript
     * @param commitAddress
     * @param unsignedCommitTx
     * @param commitTransactionUnspents
     * @param recipientAddress
     * @param inscriptionData
     */
    async signAndSendReveal(walletPassphrase, tapLeafScript, commitAddress, unsignedCommitTx, commitTransactionUnspents, recipientAddress, inscriptionData) {
        const userKeychain = await this.wallet.baseCoin.keychains().get({ id: this.wallet.keyIds()[sdk_core_1.KeyIndices.USER] });
        const xprv = await this.wallet.getUserPrv({ keychain: userKeychain, walletPassphrase });
        const halfSignedCommitTransaction = (await this.wallet.signTransaction({
            prv: xprv,
            txPrebuild: {
                txHex: unsignedCommitTx.toString('hex'),
                txInfo: { unspents: commitTransactionUnspents },
            },
        }));
        const derived = this.coin.deriveKeyWithSeed({ key: xprv, seed: inscriptionData.toString() });
        const prv = (0, sdk_core_1.xprvToRawPrv)(derived.key);
        const fullySignedRevealTransaction = await utxo_ord_1.inscriptions.signRevealTransaction(Buffer.from(prv, 'hex'), tapLeafScript, commitAddress, recipientAddress, Buffer.from(halfSignedCommitTransaction.txHex, 'hex'), this.coin.network);
        return this.wallet.submitTransaction({
            halfSigned: {
                txHex: halfSignedCommitTransaction.txHex,
                signedChildPsbt: fullySignedRevealTransaction.toHex(),
            },
        });
    }
    /**
     * Sign and send a transaction that transfers an inscription
     * @param walletPassphrase passphrase to unlock your keys
     * @param txPrebuild this is the output of `inscription.prepareTransfer`
     */
    async signAndSendTransfer(walletPassphrase, txPrebuild) {
        const userKeychain = await this.wallet.baseCoin.keychains().get({ id: this.wallet.keyIds()[sdk_core_1.KeyIndices.USER] });
        const prv = this.wallet.getUserPrv({ keychain: userKeychain, walletPassphrase });
        const halfSigned = (await this.wallet.signTransaction({ prv, txPrebuild }));
        return this.wallet.submitTransaction({ halfSigned });
    }
}
exports.InscriptionBuilder = InscriptionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5zY3JpcHRpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2luc2NyaXB0aW9uQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHdEQUF1RjtBQUN2Riw4Q0FVeUI7QUFDekIseURBQTJDO0FBQzNDLDhDQVd5QjtBQUN6QixvREFBNEI7QUFFNUIsTUFBTSxxQ0FBcUMsR0FBRyxDQUFDLENBQUMsRUFBRSxLQUFNLEVBQUUsTUFBTyxDQUFDLENBQUM7QUFFbkUsTUFBYSxrQkFBa0I7SUFJN0IsWUFBWSxNQUFlLEVBQUUsSUFBc0I7UUFDakQsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7SUFDbkIsQ0FBQztJQUVELEtBQUssQ0FBQyxhQUFhLENBQUMsZUFBdUIsRUFBRSxXQUFtQjtRQUM5RCxNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLHFCQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZHLElBQUEsZ0JBQU0sRUFBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFakIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxlQUFlLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ2pHLE1BQU0sbUJBQW1CLEdBQUcsSUFBQSw4QkFBbUIsRUFBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDN0QsTUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLEtB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QyxDQUFDO1FBQy9HLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUUsUUFBUSxFQUFFLFlBQVksRUFBRSxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7UUFFakYsTUFBTSxVQUFVLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQThCLENBQUM7UUFDekcsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQztJQUN2RCxDQUFDO0NBQ0Y7QUFwT0QsZ0RBb09DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWJzdHJhY3RVdHhvQ29pbiwgZ2V0V2FsbGV0S2V5cywgUm9vdFdhbGxldEtleXMgfSBmcm9tICdAYml0Z28vYWJzdHJhY3QtdXR4byc7XG5pbXBvcnQge1xuICBIYWxmU2lnbmVkVXR4b1RyYW5zYWN0aW9uLFxuICBJSW5zY3JpcHRpb25CdWlsZGVyLFxuICBJV2FsbGV0LFxuICBLZXlJbmRpY2VzLFxuICBQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0LFxuICBQcmVwYXJlZEluc2NyaXB0aW9uUmV2ZWFsRGF0YSxcbiAgU3VibWl0VHJhbnNhY3Rpb25SZXNwb25zZSxcbiAgeHBydlRvUmF3UHJ2LFxuICB4cHViVG9Db21wcmVzc2VkUHViLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0ICogYXMgdXR4b2xpYiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0IHtcbiAgY3JlYXRlUHNidEZvclNpbmdsZUluc2NyaXB0aW9uUGFzc2luZ1RyYW5zYWN0aW9uLFxuICBEZWZhdWx0SW5zY3JpcHRpb25Db25zdHJhaW50cyxcbiAgSW5zY3JpcHRpb25PdXRwdXRzLFxuICBpbnNjcmlwdGlvbnMsXG4gIHBhcnNlU2F0UG9pbnQsXG4gIGlzU2F0UG9pbnQsXG4gIEVycm9yTm9MYXlvdXQsXG4gIGZpbmRPdXRwdXRMYXlvdXRGb3JXYWxsZXRVbnNwZW50cyxcbiAgTUFYX1VOU1BFTlRTX0ZPUl9PVVRQVVRfTEFZT1VULFxuICBTYXRQb2ludCxcbn0gZnJvbSAnQGJpdGdvL3V0eG8tb3JkJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgU1VQUExFTUVOVEFSWV9VTlNQRU5UU19NSU5fVkFMVUVfU0FUUyA9IFswLCAyMF8wMDAsIDIwMF8wMDBdO1xuXG5leHBvcnQgY2xhc3MgSW5zY3JpcHRpb25CdWlsZGVyIGltcGxlbWVudHMgSUluc2NyaXB0aW9uQnVpbGRlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgd2FsbGV0OiBJV2FsbGV0O1xuICBwcml2YXRlIHJlYWRvbmx5IGNvaW46IEFic3RyYWN0VXR4b0NvaW47XG5cbiAgY29uc3RydWN0b3Iod2FsbGV0OiBJV2FsbGV0LCBjb2luOiBBYnN0cmFjdFV0eG9Db2luKSB7XG4gICAgdGhpcy53YWxsZXQgPSB3YWxsZXQ7XG4gICAgdGhpcy5jb2luID0gY29pbjtcbiAgfVxuXG4gIGFzeW5jIHByZXBhcmVSZXZlYWwoaW5zY3JpcHRpb25EYXRhOiBCdWZmZXIsIGNvbnRlbnRUeXBlOiBzdHJpbmcpOiBQcm9taXNlPFByZXBhcmVkSW5zY3JpcHRpb25SZXZlYWxEYXRhPiB7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMud2FsbGV0LmJhc2VDb2luLmtleWNoYWlucygpLmdldCh7IGlkOiB0aGlzLndhbGxldC5rZXlJZHMoKVtLZXlJbmRpY2VzLlVTRVJdIH0pO1xuICAgIGFzc2VydCh1c2VyLnB1Yik7XG5cbiAgICBjb25zdCBkZXJpdmVkID0gdGhpcy5jb2luLmRlcml2ZUtleVdpdGhTZWVkKHsga2V5OiB1c2VyLnB1Yiwgc2VlZDogaW5zY3JpcHRpb25EYXRhLnRvU3RyaW5nKCkgfSk7XG4gICAgY29uc3QgY29tcHJlc3NlZFB1YmxpY0tleSA9IHhwdWJUb0NvbXByZXNzZWRQdWIoZGVyaXZlZC5rZXkpO1xuICAgIGNvbnN0IHhPbmx5UHVibGljS2V5ID0gdXR4b2xpYi5iaXRnby5vdXRwdXRTY3JpcHRzLnRvWE9ubHlQdWJsaWNLZXkoQnVmZmVyLmZyb20oY29tcHJlc3NlZFB1YmxpY0tleSwgJ2hleCcpKTtcblxuICAgIHJldHVybiBpbnNjcmlwdGlvbnMuY3JlYXRlSW5zY3JpcHRpb25SZXZlYWxEYXRhKHhPbmx5UHVibGljS2V5LCBjb250ZW50VHlwZSwgaW5zY3JpcHRpb25EYXRhLCB0aGlzLmNvaW4ubmV0d29yayk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHByZXBhcmVUcmFuc2ZlcldpdGhFeHRyYUlucHV0cyhcbiAgICBzYXRQb2ludDogU2F0UG9pbnQsXG4gICAgZmVlUmF0ZVNhdEtCOiBudW1iZXIsXG4gICAge1xuICAgICAgc2lnbmVyLFxuICAgICAgY29zaWduZXIsXG4gICAgICBpbnNjcmlwdGlvbkNvbnN0cmFpbnRzLFxuICAgIH06IHtcbiAgICAgIHNpZ25lcjogdXR4b2xpYi5iaXRnby5LZXlOYW1lO1xuICAgICAgY29zaWduZXI6IHV0eG9saWIuYml0Z28uS2V5TmFtZTtcbiAgICAgIGluc2NyaXB0aW9uQ29uc3RyYWludHM6IHtcbiAgICAgICAgbWluQ2hhbmdlT3V0cHV0PzogYmlnaW50O1xuICAgICAgICBtaW5JbnNjcmlwdGlvbk91dHB1dD86IGJpZ2ludDtcbiAgICAgICAgbWF4SW5zY3JpcHRpb25PdXRwdXQ/OiBiaWdpbnQ7XG4gICAgICB9O1xuICAgIH0sXG4gICAgcm9vdFdhbGxldEtleXM6IFJvb3RXYWxsZXRLZXlzLFxuICAgIG91dHB1dHM6IEluc2NyaXB0aW9uT3V0cHV0cyxcbiAgICBpbnNjcmlwdGlvblVuc3BlbnRzOiB1dHhvbGliLmJpdGdvLldhbGxldFVuc3BlbnQ8YmlnaW50PltdLFxuICAgIHN1cHBsZW1lbnRhcnlVbnNwZW50c01pblZhbHVlOiBudW1iZXJcbiAgKTogUHJvbWlzZTxQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0PiB7XG4gICAgbGV0IHN1cHBsZW1lbnRhcnlVbnNwZW50czogdXR4b2xpYi5iaXRnby5XYWxsZXRVbnNwZW50PGJpZ2ludD5bXSA9IFtdO1xuICAgIGlmIChzdXBwbGVtZW50YXJ5VW5zcGVudHNNaW5WYWx1ZSA+IDApIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53YWxsZXQudW5zcGVudHMoe1xuICAgICAgICBtaW5WYWx1ZTogc3VwcGxlbWVudGFyeVVuc3BlbnRzTWluVmFsdWUsXG4gICAgICB9KTtcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIGluc2NyaXB0aW9uIHVuc3BlbnQgZnJvbSB0aGUgc3VwcGxlbWVudGFyeSB1bnNwZW50c1xuICAgICAgc3VwcGxlbWVudGFyeVVuc3BlbnRzID0gcmVzcG9uc2UudW5zcGVudHNcbiAgICAgICAgLmZpbHRlcigodW5zcGVudCkgPT4gdW5zcGVudC5pZCAhPT0gaW5zY3JpcHRpb25VbnNwZW50c1swXS5pZClcbiAgICAgICAgLnNsaWNlKDAsIE1BWF9VTlNQRU5UU19GT1JfT1VUUFVUX0xBWU9VVCAtIDEpXG4gICAgICAgIC5tYXAoKHVuc3BlbnQpID0+IHtcbiAgICAgICAgICB1bnNwZW50LnZhbHVlID0gQmlnSW50KHVuc3BlbnQudmFsdWUpO1xuICAgICAgICAgIHJldHVybiB1bnNwZW50O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcHNidCA9IGNyZWF0ZVBzYnRGb3JTaW5nbGVJbnNjcmlwdGlvblBhc3NpbmdUcmFuc2FjdGlvbihcbiAgICAgIHRoaXMuY29pbi5uZXR3b3JrLFxuICAgICAge1xuICAgICAgICB3YWxsZXRLZXlzOiByb290V2FsbGV0S2V5cyxcbiAgICAgICAgc2lnbmVyLFxuICAgICAgICBjb3NpZ25lcixcbiAgICAgIH0sXG4gICAgICBpbnNjcmlwdGlvblVuc3BlbnRzLFxuICAgICAgc2F0UG9pbnQsXG4gICAgICBvdXRwdXRzLFxuICAgICAgeyBmZWVSYXRlU2F0S0IsIC4uLmluc2NyaXB0aW9uQ29uc3RyYWludHMgfSxcbiAgICAgIHsgc3VwcGxlbWVudGFyeVVuc3BlbnRzIH1cbiAgICApO1xuICAgIGlmICghcHNidCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGZWUgdG9vIGhpZ2ggZm9yIHRoZSBzZWxlY3RlZCB1bnNwZW50IHdpdGggdGhpcyBmZWUgcmF0ZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGFsbFVuc3BlbnRzID0gWy4uLmluc2NyaXB0aW9uVW5zcGVudHMsIC4uLnN1cHBsZW1lbnRhcnlVbnNwZW50c107XG5cbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhlIGNhbGwgdG8gdGhpcyBmdW5jdGlvbiBiZWNhdXNlIGl0J3MgYWxyZWFkeSBjYWxsZWQgaW5zaWRlIHRoZSBjcmVhdGVQc2J0IGZ1bmN0aW9uIGFib3ZlLlxuICAgIC8vIENyZWF0ZSAmIHVzZSBhIGdldEZlZSBmdW5jdGlvbiBpbnNpZGUgdGhlIGNyZWF0ZWQgUFNCVCBpbnN0ZWFkLCBsYWNrIG9mIHdoaWNoIG5lY2Vzc2l0YXRlcyBhIGR1cGxpY2F0ZSBjYWxsIGhlcmUuXG4gICAgY29uc3Qgb3V0cHV0TGF5b3V0ID0gZmluZE91dHB1dExheW91dEZvcldhbGxldFVuc3BlbnRzKGFsbFVuc3BlbnRzLCBzYXRQb2ludCwgb3V0cHV0cywge1xuICAgICAgZmVlUmF0ZVNhdEtCLFxuICAgICAgLi4uaW5zY3JpcHRpb25Db25zdHJhaW50cyxcbiAgICB9KTtcbiAgICBpZiAoIW91dHB1dExheW91dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGZWUgdG9vIGhpZ2ggZm9yIHRoZSBzZWxlY3RlZCB1bnNwZW50IHdpdGggdGhpcyBmZWUgcmF0ZScpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0LmlkKCksXG4gICAgICB0eEhleDogcHNidC5nZXRVbnNpZ25lZFR4KCkudG9IZXgoKSxcbiAgICAgIHR4SW5mbzogeyB1bnNwZW50czogYWxsVW5zcGVudHMgfSxcbiAgICAgIGZlZUluZm86IHsgZmVlOiBOdW1iZXIob3V0cHV0TGF5b3V0LmxheW91dC5mZWVPdXRwdXQpLCBmZWVTdHJpbmc6IG91dHB1dExheW91dC5sYXlvdXQuZmVlT3V0cHV0LnRvU3RyaW5nKCkgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEgdHJhbnNhY3Rpb24gdG8gc2VuZCBhbiBpbnNjcmlwdGlvblxuICAgKiBAcGFyYW0gc2F0UG9pbnQgU2F0cG9pbnQgeW91IHdhbnQgdG8gc2VuZFxuICAgKiBAcGFyYW0gcmVjaXBpZW50IEFkZHJlc3MgeW91IHdhbnQgdG8gc2VuZCB0b1xuICAgKiBAcGFyYW0gZmVlUmF0ZVNhdEtCIEZlZSByYXRlIGZvciB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gc2lnbmVyIGZpcnN0IHNpZ25lciBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIGNvc2lnbmVyIHNlY29uZCBzaWduZXIgb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBpbnNjcmlwdGlvbkNvbnN0cmFpbnRzLm1pbkNoYW5nZU91dHB1dCAob3B0aW9uYWwpIHRoZSBtaW5pbXVtIHNpemUgb2YgdGhlIGNoYW5nZSBvdXRwdXRcbiAgICogQHBhcmFtIGluc2NyaXB0aW9uQ29uc3RyYWludHMubWluSW5zY3JpcHRpb25PdXRwdXQgKG9wdGlvbmFsKSB0aGUgbWluaW11bSBudW1iZXIgb2Ygc2F0cyBvZiB0aGUgb3V0cHV0IGNvbnRhaW5pbmcgdGhlIGluc2NyaXB0aW9uXG4gICAqIEBwYXJhbSBpbnNjcmlwdGlvbkNvbnN0cmFpbnRzLm1heEluc2NyaXB0aW9uT3V0cHV0IChvcHRpb25hbCkgdGhlIG1heGltdW0gbnVtYmVyIG9mIHNhdHMgb2YgdGhlIG91dHB1dCBjb250YWluaW5nIHRoZSBpbnNjcmlwdGlvblxuICAgKiBAcGFyYW0gY2hhbmdlQWRkcmVzc1R5cGUgQWRkcmVzcyB0eXBlIG9mIHRoZSBjaGFuZ2UgYWRkcmVzc1xuICAgKi9cbiAgYXN5bmMgcHJlcGFyZVRyYW5zZmVyKFxuICAgIHNhdFBvaW50OiBzdHJpbmcsXG4gICAgcmVjaXBpZW50OiBzdHJpbmcsXG4gICAgZmVlUmF0ZVNhdEtCOiBudW1iZXIsXG4gICAge1xuICAgICAgc2lnbmVyID0gJ3VzZXInLFxuICAgICAgY29zaWduZXIgPSAnYml0Z28nLFxuICAgICAgaW5zY3JpcHRpb25Db25zdHJhaW50cyA9IERlZmF1bHRJbnNjcmlwdGlvbkNvbnN0cmFpbnRzLFxuICAgICAgY2hhbmdlQWRkcmVzc1R5cGUgPSAncDJ3c2gnLFxuICAgIH06IHtcbiAgICAgIHNpZ25lcj86IHV0eG9saWIuYml0Z28uS2V5TmFtZTtcbiAgICAgIGNvc2lnbmVyPzogdXR4b2xpYi5iaXRnby5LZXlOYW1lO1xuICAgICAgaW5zY3JpcHRpb25Db25zdHJhaW50cz86IHtcbiAgICAgICAgbWluQ2hhbmdlT3V0cHV0PzogYmlnaW50O1xuICAgICAgICBtaW5JbnNjcmlwdGlvbk91dHB1dD86IGJpZ2ludDtcbiAgICAgICAgbWF4SW5zY3JpcHRpb25PdXRwdXQ/OiBiaWdpbnQ7XG4gICAgICB9O1xuICAgICAgY2hhbmdlQWRkcmVzc1R5cGU/OiB1dHhvbGliLmJpdGdvLm91dHB1dFNjcmlwdHMuU2NyaXB0VHlwZTJPZjM7XG4gICAgfVxuICApOiBQcm9taXNlPFByZWJ1aWxkVHJhbnNhY3Rpb25SZXN1bHQ+IHtcbiAgICBhc3NlcnQoaXNTYXRQb2ludChzYXRQb2ludCkpO1xuXG4gICAgY29uc3Qgcm9vdFdhbGxldEtleXMgPSBhd2FpdCBnZXRXYWxsZXRLZXlzKHRoaXMuY29pbiwgdGhpcy53YWxsZXQpO1xuICAgIGNvbnN0IHBhcnNlZFNhdFBvaW50ID0gcGFyc2VTYXRQb2ludChzYXRQb2ludCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLndhbGxldC5nZXRUcmFuc2FjdGlvbih7IHR4SGFzaDogcGFyc2VkU2F0UG9pbnQudHhpZCB9KTtcbiAgICBjb25zdCB1bnNwZW50czogdXR4b2xpYi5iaXRnby5XYWxsZXRVbnNwZW50PGJpZ2ludD5bXSA9IFt0cmFuc2FjdGlvbi5vdXRwdXRzW3BhcnNlZFNhdFBvaW50LnZvdXRdXTtcbiAgICB1bnNwZW50c1swXS52YWx1ZSA9IEJpZ0ludCh1bnNwZW50c1swXS52YWx1ZSk7XG5cbiAgICBjb25zdCBjaGFuZ2VBZGRyZXNzID0gYXdhaXQgdGhpcy53YWxsZXQuY3JlYXRlQWRkcmVzcyh7XG4gICAgICBjaGFpbjogdXR4b2xpYi5iaXRnby5nZXRJbnRlcm5hbENoYWluQ29kZShjaGFuZ2VBZGRyZXNzVHlwZSksXG4gICAgfSk7XG4gICAgY29uc3Qgb3V0cHV0czogSW5zY3JpcHRpb25PdXRwdXRzID0ge1xuICAgICAgaW5zY3JpcHRpb25SZWNpcGllbnQ6IHJlY2lwaWVudCxcbiAgICAgIGNoYW5nZU91dHB1dHM6IFtcbiAgICAgICAgeyBjaGFpbjogY2hhbmdlQWRkcmVzcy5jaGFpbiwgaW5kZXg6IGNoYW5nZUFkZHJlc3MuaW5kZXggfSxcbiAgICAgICAgeyBjaGFpbjogY2hhbmdlQWRkcmVzcy5jaGFpbiwgaW5kZXg6IGNoYW5nZUFkZHJlc3MuaW5kZXggfSxcbiAgICAgIF0sXG4gICAgfTtcblxuICAgIGZvciAoY29uc3Qgc3VwcGxlbWVudGFyeVVuc3BlbnRzTWluVmFsdWUgb2YgU1VQUExFTUVOVEFSWV9VTlNQRU5UU19NSU5fVkFMVUVfU0FUUykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJlcGFyZVRyYW5zZmVyV2l0aEV4dHJhSW5wdXRzKFxuICAgICAgICAgIHNhdFBvaW50LFxuICAgICAgICAgIGZlZVJhdGVTYXRLQixcbiAgICAgICAgICB7IHNpZ25lciwgY29zaWduZXIsIGluc2NyaXB0aW9uQ29uc3RyYWludHMgfSxcbiAgICAgICAgICByb290V2FsbGV0S2V5cyxcbiAgICAgICAgICBvdXRwdXRzLFxuICAgICAgICAgIHVuc3BlbnRzLFxuICAgICAgICAgIHN1cHBsZW1lbnRhcnlVbnNwZW50c01pblZhbHVlXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yTm9MYXlvdXQpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7IC8vIFByb3BhZ2F0ZSBlcnJvciBpZiBpdCdzIG5vdCBhbiBFcnJvck5vTGF5b3V0XG4gICAgICAgIH0gLy8gT3RoZXJ3aXNlIGNvbnRpbnVlIHRyeWluZyB3aXRoIGhpZ2hlciBtaW5WYWx1ZSBmb3Igc3VwcGxlbWVudGFyeSB1bnNwZW50c1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignRmVlIHRvbyBoaWdoIGZvciB0aGUgc2VsZWN0ZWQgdW5zcGVudCB3aXRoIHRoaXMgZmVlIHJhdGUnKTsgLy8gRXhoYXVzdGVkIGFsbCB0cmllcyB0byBzdXBwbGVtZW50XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHdhbGxldFBhc3NwaHJhc2VcbiAgICogQHBhcmFtIHRhcExlYWZTY3JpcHRcbiAgICogQHBhcmFtIGNvbW1pdEFkZHJlc3NcbiAgICogQHBhcmFtIHVuc2lnbmVkQ29tbWl0VHhcbiAgICogQHBhcmFtIGNvbW1pdFRyYW5zYWN0aW9uVW5zcGVudHNcbiAgICogQHBhcmFtIHJlY2lwaWVudEFkZHJlc3NcbiAgICogQHBhcmFtIGluc2NyaXB0aW9uRGF0YVxuICAgKi9cbiAgYXN5bmMgc2lnbkFuZFNlbmRSZXZlYWwoXG4gICAgd2FsbGV0UGFzc3BocmFzZTogc3RyaW5nLFxuICAgIHRhcExlYWZTY3JpcHQ6IHV0eG9saWIuYml0Z28uVGFwTGVhZlNjcmlwdCxcbiAgICBjb21taXRBZGRyZXNzOiBzdHJpbmcsXG4gICAgdW5zaWduZWRDb21taXRUeDogQnVmZmVyLFxuICAgIGNvbW1pdFRyYW5zYWN0aW9uVW5zcGVudHM6IHV0eG9saWIuYml0Z28uV2FsbGV0VW5zcGVudFtdLFxuICAgIHJlY2lwaWVudEFkZHJlc3M6IHN0cmluZyxcbiAgICBpbnNjcmlwdGlvbkRhdGE6IEJ1ZmZlclxuICApOiBQcm9taXNlPFN1Ym1pdFRyYW5zYWN0aW9uUmVzcG9uc2U+IHtcbiAgICBjb25zdCB1c2VyS2V5Y2hhaW4gPSBhd2FpdCB0aGlzLndhbGxldC5iYXNlQ29pbi5rZXljaGFpbnMoKS5nZXQoeyBpZDogdGhpcy53YWxsZXQua2V5SWRzKClbS2V5SW5kaWNlcy5VU0VSXSB9KTtcbiAgICBjb25zdCB4cHJ2ID0gYXdhaXQgdGhpcy53YWxsZXQuZ2V0VXNlclBydih7IGtleWNoYWluOiB1c2VyS2V5Y2hhaW4sIHdhbGxldFBhc3NwaHJhc2UgfSk7XG5cbiAgICBjb25zdCBoYWxmU2lnbmVkQ29tbWl0VHJhbnNhY3Rpb24gPSAoYXdhaXQgdGhpcy53YWxsZXQuc2lnblRyYW5zYWN0aW9uKHtcbiAgICAgIHBydjogeHBydixcbiAgICAgIHR4UHJlYnVpbGQ6IHtcbiAgICAgICAgdHhIZXg6IHVuc2lnbmVkQ29tbWl0VHgudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICB0eEluZm86IHsgdW5zcGVudHM6IGNvbW1pdFRyYW5zYWN0aW9uVW5zcGVudHMgfSxcbiAgICAgIH0sXG4gICAgfSkpIGFzIEhhbGZTaWduZWRVdHhvVHJhbnNhY3Rpb247XG5cbiAgICBjb25zdCBkZXJpdmVkID0gdGhpcy5jb2luLmRlcml2ZUtleVdpdGhTZWVkKHsga2V5OiB4cHJ2LCBzZWVkOiBpbnNjcmlwdGlvbkRhdGEudG9TdHJpbmcoKSB9KTtcbiAgICBjb25zdCBwcnYgPSB4cHJ2VG9SYXdQcnYoZGVyaXZlZC5rZXkpO1xuXG4gICAgY29uc3QgZnVsbHlTaWduZWRSZXZlYWxUcmFuc2FjdGlvbiA9IGF3YWl0IGluc2NyaXB0aW9ucy5zaWduUmV2ZWFsVHJhbnNhY3Rpb24oXG4gICAgICBCdWZmZXIuZnJvbShwcnYsICdoZXgnKSxcbiAgICAgIHRhcExlYWZTY3JpcHQsXG4gICAgICBjb21taXRBZGRyZXNzLFxuICAgICAgcmVjaXBpZW50QWRkcmVzcyxcbiAgICAgIEJ1ZmZlci5mcm9tKGhhbGZTaWduZWRDb21taXRUcmFuc2FjdGlvbi50eEhleCwgJ2hleCcpLFxuICAgICAgdGhpcy5jb2luLm5ldHdvcmtcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMud2FsbGV0LnN1Ym1pdFRyYW5zYWN0aW9uKHtcbiAgICAgIGhhbGZTaWduZWQ6IHtcbiAgICAgICAgdHhIZXg6IGhhbGZTaWduZWRDb21taXRUcmFuc2FjdGlvbi50eEhleCxcbiAgICAgICAgc2lnbmVkQ2hpbGRQc2J0OiBmdWxseVNpZ25lZFJldmVhbFRyYW5zYWN0aW9uLnRvSGV4KCksXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gYW5kIHNlbmQgYSB0cmFuc2FjdGlvbiB0aGF0IHRyYW5zZmVycyBhbiBpbnNjcmlwdGlvblxuICAgKiBAcGFyYW0gd2FsbGV0UGFzc3BocmFzZSBwYXNzcGhyYXNlIHRvIHVubG9jayB5b3VyIGtleXNcbiAgICogQHBhcmFtIHR4UHJlYnVpbGQgdGhpcyBpcyB0aGUgb3V0cHV0IG9mIGBpbnNjcmlwdGlvbi5wcmVwYXJlVHJhbnNmZXJgXG4gICAqL1xuICBhc3luYyBzaWduQW5kU2VuZFRyYW5zZmVyKFxuICAgIHdhbGxldFBhc3NwaHJhc2U6IHN0cmluZyxcbiAgICB0eFByZWJ1aWxkOiBQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0XG4gICk6IFByb21pc2U8U3VibWl0VHJhbnNhY3Rpb25SZXNwb25zZT4ge1xuICAgIGNvbnN0IHVzZXJLZXljaGFpbiA9IGF3YWl0IHRoaXMud2FsbGV0LmJhc2VDb2luLmtleWNoYWlucygpLmdldCh7IGlkOiB0aGlzLndhbGxldC5rZXlJZHMoKVtLZXlJbmRpY2VzLlVTRVJdIH0pO1xuICAgIGNvbnN0IHBydiA9IHRoaXMud2FsbGV0LmdldFVzZXJQcnYoeyBrZXljaGFpbjogdXNlcktleWNoYWluLCB3YWxsZXRQYXNzcGhyYXNlIH0pO1xuXG4gICAgY29uc3QgaGFsZlNpZ25lZCA9IChhd2FpdCB0aGlzLndhbGxldC5zaWduVHJhbnNhY3Rpb24oeyBwcnYsIHR4UHJlYnVpbGQgfSkpIGFzIEhhbGZTaWduZWRVdHhvVHJhbnNhY3Rpb247XG4gICAgcmV0dXJuIHRoaXMud2FsbGV0LnN1Ym1pdFRyYW5zYWN0aW9uKHsgaGFsZlNpZ25lZCB9KTtcbiAgfVxufVxuIl19