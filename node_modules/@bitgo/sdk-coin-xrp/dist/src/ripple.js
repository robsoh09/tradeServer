"use strict";
/**
 * @hidden
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
/**
 */
const rippleKeypairs = __importStar(require("ripple-keypairs"));
const ripple = __importStar(require("ripple-lib"));
const utxo_lib_1 = require("@bitgo/utxo-lib");
const binary = __importStar(require("ripple-binary-codec"));
const hashes_1 = require("ripple-lib/dist/npm/common/hashes");
function computeSignature(tx, privateKey, signAs) {
    const signingData = signAs ? binary.encodeForMultisigning(tx, signAs) : binary.encodeForSigning(tx);
    return rippleKeypairs.sign(signingData, privateKey);
}
/**
 * Sign Ripple transaction with a secp256k1 private key
 * @param txHex
 * @param privateKey
 * @param options
 * @returns {{signedTransaction: *, id}}
 */
const signWithPrivateKey = function (txHex, privateKey, options) {
    let privateKeyBuffer = Buffer.from(privateKey, 'hex');
    if (privateKeyBuffer.length === 33 && privateKeyBuffer[0] === 0) {
        privateKeyBuffer = privateKeyBuffer.slice(1, 33);
    }
    const publicKey = utxo_lib_1.ECPair.fromPrivateKey(privateKeyBuffer).publicKey.toString('hex').toUpperCase();
    let tx;
    try {
        tx = binary.decode(txHex);
    }
    catch (e) {
        try {
            tx = JSON.parse(txHex);
        }
        catch (e) {
            throw new Error('txHex needs to be either hex or JSON string for XRP');
        }
    }
    tx.SigningPubKey = options && options.signAs ? '' : publicKey;
    if (options && options.signAs) {
        const expectedSigner = rippleKeypairs.deriveAddress(publicKey);
        if (options.signAs !== expectedSigner) {
            throw new Error('signAs does not match private key');
        }
        const signer = {
            Account: options.signAs,
            SigningPubKey: publicKey,
            TxnSignature: computeSignature(tx, privateKey, options.signAs),
        };
        // Ordering of private key signing matters, or the Ripple fullnode will throw an 'Unsorted Signers array' error.
        // Additional signers must be added to the front of the signers array list.
        if (tx.TxnSignature || tx.Signers) {
            tx.Signers.unshift({ Signer: signer });
        }
        else {
            tx.Signers = [{ Signer: signer }];
        }
    }
    else {
        tx.TxnSignature = computeSignature(tx, privateKey, undefined);
    }
    const serialized = binary.encode(tx);
    return {
        signedTransaction: serialized,
        id: (0, hashes_1.computeBinaryTransactionHash)(serialized),
    };
};
module.exports = (params) => {
    const rippleLib = new ripple.RippleAPI(params);
    rippleLib.signWithPrivateKey = signWithPrivateKey;
    return rippleLib;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmlwcGxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3JpcHBsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVIO0dBQ0c7QUFDSCxnRUFBa0Q7QUFDbEQsbURBQXFDO0FBQ3JDLDhDQUF5QztBQUV6Qyw0REFBOEM7QUFDOUMsOERBQWlGO0FBRWpGLFNBQVMsZ0JBQWdCLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNO0lBQzlDLE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLHFCQUFxQixDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3BHLE9BQU8sY0FBYyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsVUFBVSxDQUFDLENBQUM7QUFDdEQsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILE1BQU0sa0JBQWtCLEdBQUcsVUFBVSxLQUFLLEVBQUUsVUFBVSxFQUFFLE9BQU87SUFDN0QsSUFBSSxnQkFBZ0IsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN0RCxJQUFJLGdCQUFnQixDQUFDLE1BQU0sS0FBSyxFQUFFLElBQUksZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQy9ELGdCQUFnQixHQUFHLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7S0FDbEQ7SUFDRCxNQUFNLFNBQVMsR0FBRyxpQkFBTSxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7SUFFbEcsSUFBSSxFQUFFLENBQUM7SUFDUCxJQUFJO1FBQ0YsRUFBRSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDM0I7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLElBQUk7WUFDRixFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN4QjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO1NBQ3hFO0tBQ0Y7SUFFRCxFQUFFLENBQUMsYUFBYSxHQUFHLE9BQU8sSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztJQUU5RCxJQUFJLE9BQU8sSUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO1FBQzdCLE1BQU0sY0FBYyxHQUFHLGNBQWMsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDL0QsSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLGNBQWMsRUFBRTtZQUNyQyxNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7U0FDdEQ7UUFDRCxNQUFNLE1BQU0sR0FBRztZQUNiLE9BQU8sRUFBRSxPQUFPLENBQUMsTUFBTTtZQUN2QixhQUFhLEVBQUUsU0FBUztZQUN4QixZQUFZLEVBQUUsZ0JBQWdCLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDO1NBQy9ELENBQUM7UUFDRixnSEFBZ0g7UUFDaEgsMkVBQTJFO1FBQzNFLElBQUksRUFBRSxDQUFDLFlBQVksSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFO1lBQ2pDLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7U0FDeEM7YUFBTTtZQUNMLEVBQUUsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO1NBQ25DO0tBQ0Y7U0FBTTtRQUNMLEVBQUUsQ0FBQyxZQUFZLEdBQUcsZ0JBQWdCLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQztLQUMvRDtJQUVELE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDckMsT0FBTztRQUNMLGlCQUFpQixFQUFFLFVBQVU7UUFDN0IsRUFBRSxFQUFFLElBQUEscUNBQTRCLEVBQUMsVUFBVSxDQUFDO0tBQzdDLENBQUM7QUFDSixDQUFDLENBQUM7QUFFRixpQkFBUyxDQUFDLE1BQU0sRUFBb0IsRUFBRTtJQUNwQyxNQUFNLFNBQVMsR0FBRyxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDOUMsU0FBaUIsQ0FBQyxrQkFBa0IsR0FBRyxrQkFBa0IsQ0FBQztJQUMzRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBoaWRkZW5cbiAqL1xuXG4vKipcbiAqL1xuaW1wb3J0ICogYXMgcmlwcGxlS2V5cGFpcnMgZnJvbSAncmlwcGxlLWtleXBhaXJzJztcbmltcG9ydCAqIGFzIHJpcHBsZSBmcm9tICdyaXBwbGUtbGliJztcbmltcG9ydCB7IEVDUGFpciB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5cbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICdyaXBwbGUtYmluYXJ5LWNvZGVjJztcbmltcG9ydCB7IGNvbXB1dGVCaW5hcnlUcmFuc2FjdGlvbkhhc2ggfSBmcm9tICdyaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9oYXNoZXMnO1xuXG5mdW5jdGlvbiBjb21wdXRlU2lnbmF0dXJlKHR4LCBwcml2YXRlS2V5LCBzaWduQXMpIHtcbiAgY29uc3Qgc2lnbmluZ0RhdGEgPSBzaWduQXMgPyBiaW5hcnkuZW5jb2RlRm9yTXVsdGlzaWduaW5nKHR4LCBzaWduQXMpIDogYmluYXJ5LmVuY29kZUZvclNpZ25pbmcodHgpO1xuICByZXR1cm4gcmlwcGxlS2V5cGFpcnMuc2lnbihzaWduaW5nRGF0YSwgcHJpdmF0ZUtleSk7XG59XG5cbi8qKlxuICogU2lnbiBSaXBwbGUgdHJhbnNhY3Rpb24gd2l0aCBhIHNlY3AyNTZrMSBwcml2YXRlIGtleVxuICogQHBhcmFtIHR4SGV4XG4gKiBAcGFyYW0gcHJpdmF0ZUtleVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHt7c2lnbmVkVHJhbnNhY3Rpb246ICosIGlkfX1cbiAqL1xuY29uc3Qgc2lnbldpdGhQcml2YXRlS2V5ID0gZnVuY3Rpb24gKHR4SGV4LCBwcml2YXRlS2V5LCBvcHRpb25zKSB7XG4gIGxldCBwcml2YXRlS2V5QnVmZmVyID0gQnVmZmVyLmZyb20ocHJpdmF0ZUtleSwgJ2hleCcpO1xuICBpZiAocHJpdmF0ZUtleUJ1ZmZlci5sZW5ndGggPT09IDMzICYmIHByaXZhdGVLZXlCdWZmZXJbMF0gPT09IDApIHtcbiAgICBwcml2YXRlS2V5QnVmZmVyID0gcHJpdmF0ZUtleUJ1ZmZlci5zbGljZSgxLCAzMyk7XG4gIH1cbiAgY29uc3QgcHVibGljS2V5ID0gRUNQYWlyLmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXlCdWZmZXIpLnB1YmxpY0tleS50b1N0cmluZygnaGV4JykudG9VcHBlckNhc2UoKTtcblxuICBsZXQgdHg7XG4gIHRyeSB7XG4gICAgdHggPSBiaW5hcnkuZGVjb2RlKHR4SGV4KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICB0eCA9IEpTT04ucGFyc2UodHhIZXgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHhIZXggbmVlZHMgdG8gYmUgZWl0aGVyIGhleCBvciBKU09OIHN0cmluZyBmb3IgWFJQJyk7XG4gICAgfVxuICB9XG5cbiAgdHguU2lnbmluZ1B1YktleSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zaWduQXMgPyAnJyA6IHB1YmxpY0tleTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNpZ25Bcykge1xuICAgIGNvbnN0IGV4cGVjdGVkU2lnbmVyID0gcmlwcGxlS2V5cGFpcnMuZGVyaXZlQWRkcmVzcyhwdWJsaWNLZXkpO1xuICAgIGlmIChvcHRpb25zLnNpZ25BcyAhPT0gZXhwZWN0ZWRTaWduZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbkFzIGRvZXMgbm90IG1hdGNoIHByaXZhdGUga2V5Jyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lciA9IHtcbiAgICAgIEFjY291bnQ6IG9wdGlvbnMuc2lnbkFzLFxuICAgICAgU2lnbmluZ1B1YktleTogcHVibGljS2V5LFxuICAgICAgVHhuU2lnbmF0dXJlOiBjb21wdXRlU2lnbmF0dXJlKHR4LCBwcml2YXRlS2V5LCBvcHRpb25zLnNpZ25BcyksXG4gICAgfTtcbiAgICAvLyBPcmRlcmluZyBvZiBwcml2YXRlIGtleSBzaWduaW5nIG1hdHRlcnMsIG9yIHRoZSBSaXBwbGUgZnVsbG5vZGUgd2lsbCB0aHJvdyBhbiAnVW5zb3J0ZWQgU2lnbmVycyBhcnJheScgZXJyb3IuXG4gICAgLy8gQWRkaXRpb25hbCBzaWduZXJzIG11c3QgYmUgYWRkZWQgdG8gdGhlIGZyb250IG9mIHRoZSBzaWduZXJzIGFycmF5IGxpc3QuXG4gICAgaWYgKHR4LlR4blNpZ25hdHVyZSB8fCB0eC5TaWduZXJzKSB7XG4gICAgICB0eC5TaWduZXJzLnVuc2hpZnQoeyBTaWduZXI6IHNpZ25lciB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHguU2lnbmVycyA9IFt7IFNpZ25lcjogc2lnbmVyIH1dO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0eC5UeG5TaWduYXR1cmUgPSBjb21wdXRlU2lnbmF0dXJlKHR4LCBwcml2YXRlS2V5LCB1bmRlZmluZWQpO1xuICB9XG5cbiAgY29uc3Qgc2VyaWFsaXplZCA9IGJpbmFyeS5lbmNvZGUodHgpO1xuICByZXR1cm4ge1xuICAgIHNpZ25lZFRyYW5zYWN0aW9uOiBzZXJpYWxpemVkLFxuICAgIGlkOiBjb21wdXRlQmluYXJ5VHJhbnNhY3Rpb25IYXNoKHNlcmlhbGl6ZWQpLFxuICB9O1xufTtcblxuZXhwb3J0ID0gKHBhcmFtcyk6IHJpcHBsZS5SaXBwbGVBUEkgPT4ge1xuICBjb25zdCByaXBwbGVMaWIgPSBuZXcgcmlwcGxlLlJpcHBsZUFQSShwYXJhbXMpO1xuICAocmlwcGxlTGliIGFzIGFueSkuc2lnbldpdGhQcml2YXRlS2V5ID0gc2lnbldpdGhQcml2YXRlS2V5O1xuICByZXR1cm4gcmlwcGxlTGliO1xufTtcbiJdfQ==