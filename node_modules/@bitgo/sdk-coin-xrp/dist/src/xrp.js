"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Xrp = void 0;
/**
 * @prettier
 */
const bignumber_js_1 = require("bignumber.js");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const crypto_1 = require("crypto");
const _ = __importStar(require("lodash"));
const url = __importStar(require("url"));
const querystring = __importStar(require("querystring"));
const rippleAddressCodec = __importStar(require("ripple-address-codec"));
const rippleBinaryCodec = __importStar(require("ripple-binary-codec"));
const hashes_1 = require("ripple-lib/dist/npm/common/hashes");
const rippleKeypairs = __importStar(require("ripple-keypairs"));
const sdk_core_1 = require("@bitgo/sdk-core");
const ripple = require('./ripple');
class Xrp extends sdk_core_1.BaseCoin {
    constructor(bitgo) {
        super(bitgo);
    }
    static createInstance(bitgo) {
        return new Xrp(bitgo);
    }
    /**
     * Factor between the coin's base unit and its smallest subdivison
     */
    getBaseFactor() {
        return 1e6;
    }
    /**
     * Identifier for the blockchain which supports this coin
     */
    getChain() {
        return 'xrp';
    }
    /**
     * Identifier for the coin family
     */
    getFamily() {
        return 'xrp';
    }
    /**
     * Complete human-readable name of this coin
     */
    getFullName() {
        return 'Ripple';
    }
    /**
     * Parse an address string into address and destination tag
     */
    getAddressDetails(address) {
        const destinationDetails = url.parse(address);
        const destinationAddress = destinationDetails.pathname;
        if (!destinationAddress || !rippleAddressCodec.isValidClassicAddress(destinationAddress)) {
            throw new sdk_core_1.InvalidAddressError(`destination address "${destinationAddress}" is not valid`);
        }
        // there are no other properties like destination tags
        if (destinationDetails.pathname === address) {
            return {
                address: address,
                destinationTag: undefined,
            };
        }
        if (!destinationDetails.query) {
            throw new sdk_core_1.InvalidAddressError('no query params present');
        }
        const queryDetails = querystring.parse(destinationDetails.query);
        if (!queryDetails.dt) {
            // if there are more properties, the query details need to contain the destination tag property.
            throw new sdk_core_1.InvalidAddressError('destination tag missing');
        }
        if (Array.isArray(queryDetails.dt)) {
            // if queryDetails.dt is an array, that means dt was given multiple times, which is not valid
            throw new sdk_core_1.InvalidAddressError(`destination tag can appear at most once, but ${queryDetails.dt.length} destination tags were found`);
        }
        const parsedTag = parseInt(queryDetails.dt, 10);
        if (!Number.isSafeInteger(parsedTag)) {
            throw new sdk_core_1.InvalidAddressError('invalid destination tag');
        }
        if (parsedTag > 0xffffffff || parsedTag < 0) {
            throw new sdk_core_1.InvalidAddressError('destination tag out of range');
        }
        return {
            address: destinationAddress,
            destinationTag: parsedTag,
        };
    }
    /**
     * Construct a full, normalized address from an address and destination tag
     */
    normalizeAddress({ address, destinationTag }) {
        if (!_.isString(address)) {
            throw new sdk_core_1.InvalidAddressError('invalid address details');
        }
        if (_.isInteger(destinationTag)) {
            return `${address}?dt=${destinationTag}`;
        }
        return address;
    }
    /**
     * Evaluates whether an address string is valid for this coin
     * @param address
     */
    isValidAddress(address) {
        try {
            const addressDetails = this.getAddressDetails(address);
            return address === this.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub) {
        try {
            return utxo_lib_1.bip32.fromBase58(pub).isNeutered();
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Get fee info from server
     */
    async getFeeInfo() {
        return this.bitgo.get(this.url('/public/feeinfo')).result();
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns Bluebird<HalfSignedTransaction>
     */
    async signTransaction({ txPrebuild, prv, isLastSignature, }) {
        if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
            if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                throw new Error(`txPrebuild must be an object, got type ${typeof txPrebuild}`);
            }
            throw new Error('missing txPrebuild parameter');
        }
        if (_.isUndefined(prv) || !_.isString(prv)) {
            if (!_.isUndefined(prv) && !_.isString(prv)) {
                throw new Error(`prv must be a string, got type ${typeof prv}`);
            }
            throw new Error('missing prv parameter to sign transaction');
        }
        const userKey = utxo_lib_1.bip32.fromBase58(prv);
        const userPrivateKey = userKey.privateKey;
        if (!userPrivateKey) {
            throw new Error(`no privateKey`);
        }
        const userAddress = rippleKeypairs.deriveAddress(userKey.publicKey.toString('hex'));
        const rippleLib = ripple();
        const tx = rippleLib.signWithPrivateKey(txPrebuild.txHex, userPrivateKey.toString('hex'), {
            signAs: userAddress,
        });
        // Normally the SDK provides the first signature for an XRP tx, but occasionally it provides the final one as well
        // (recoveries)
        if (isLastSignature) {
            return { txHex: tx.signedTransaction };
        }
        return { halfSigned: { txHex: tx.signedTransaction } };
    }
    /**
     * Ripple requires additional parameters for wallet generation to be sent to the server. The additional parameters are
     * the root public key, which is the basis of the root address, two signed, and one half-signed initialization txs
     * @param walletParams
     * - rootPrivateKey: optional hex-encoded Ripple private key
     */
    async supplementGenerateWallet(walletParams) {
        if (walletParams.rootPrivateKey) {
            if (walletParams.rootPrivateKey.length !== 64) {
                throw new Error('rootPrivateKey needs to be a hexadecimal private key string');
            }
        }
        else {
            const keyPair = utxo_lib_1.ECPair.makeRandom();
            if (!keyPair.privateKey) {
                throw new Error('no privateKey');
            }
            walletParams.rootPrivateKey = keyPair.privateKey.toString('hex');
        }
        return walletParams;
    }
    /**
     * Explain/parse transaction
     * @param params
     */
    async explainTransaction(params = {}) {
        let transaction;
        let txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
        if (!txHex) {
            throw new Error('missing required param txHex');
        }
        try {
            transaction = rippleBinaryCodec.decode(txHex);
        }
        catch (e) {
            try {
                transaction = JSON.parse(txHex);
                txHex = rippleBinaryCodec.encode(transaction);
            }
            catch (e) {
                throw new Error('txHex needs to be either hex or JSON string for XRP');
            }
        }
        const id = (0, hashes_1.computeBinaryTransactionHash)(txHex);
        if (transaction.TransactionType == 'AccountSet') {
            return {
                displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee', 'accountSet'],
                id: id,
                changeOutputs: [],
                outputAmount: 0,
                changeAmount: 0,
                outputs: [],
                fee: {
                    fee: transaction.Fee,
                    feeRate: null,
                    size: txHex.length / 2,
                },
                accountSet: {
                    messageKey: transaction.MessageKey,
                },
            };
        }
        const address = transaction.Destination + (transaction.DestinationTag >= 0 ? '?dt=' + transaction.DestinationTag : '');
        return {
            displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee'],
            id: id,
            changeOutputs: [],
            outputAmount: transaction.Amount,
            changeAmount: 0,
            outputs: [
                {
                    address,
                    amount: transaction.Amount,
                },
            ],
            fee: {
                fee: transaction.Fee,
                feeRate: null,
                size: txHex.length / 2,
            },
        };
    }
    /**
     * Verify that a transaction prebuild complies with the original intention
     * @param txParams params object passed to send
     * @param txPrebuild prebuild object returned by server
     * @param wallet
     * @returns {boolean}
     */
    async verifyTransaction({ txParams, txPrebuild }) {
        const explanation = await this.explainTransaction({
            txHex: txPrebuild.txHex,
        });
        const output = [...explanation.outputs, ...explanation.changeOutputs][0];
        const expectedOutput = txParams.recipients && txParams.recipients[0];
        const comparator = (recipient1, recipient2) => {
            if (recipient1.address !== recipient2.address) {
                return false;
            }
            const amount1 = new bignumber_js_1.BigNumber(recipient1.amount);
            const amount2 = new bignumber_js_1.BigNumber(recipient2.amount);
            return amount1.toFixed() === amount2.toFixed();
        };
        if (!comparator(output, expectedOutput)) {
            throw new Error('transaction prebuild does not match expected output');
        }
        return true;
    }
    /**
     * Check if address is a valid XRP address, and then make sure the root addresses match.
     * This prevents attacks where an attack may switch out the new address for one of their own
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     * @return true iff address is a wallet address (based on rootAddress)
     */
    async isWalletAddress({ address, rootAddress }) {
        if (!this.isValidAddress(address)) {
            throw new sdk_core_1.InvalidAddressError(`address verification failure: address "${address}" is not valid`);
        }
        const addressDetails = this.getAddressDetails(address);
        const rootAddressDetails = this.getAddressDetails(rootAddress);
        if (addressDetails.address !== rootAddressDetails.address) {
            throw new sdk_core_1.UnexpectedAddressError(`address validation failure: ${addressDetails.address} vs. ${rootAddressDetails.address}`);
        }
        return true;
    }
    /**
     * URL of a well-known, public facing (non-bitgo) rippled instance which can be used for recovery
     */
    getRippledUrl() {
        return 'https://s1.ripple.com:51234';
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - rootAddress: root XRP wallet address to recover funds from
     * - userKey: [encrypted] xprv
     * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
     * - walletPassphrase: necessary if one of the xprvs is encrypted
     * - bitgoKey: xpub
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     */
    async recover(params) {
        const rippledUrl = this.getRippledUrl();
        const isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
        const isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
        const accountInfoParams = {
            method: 'account_info',
            params: [
                {
                    account: params.rootAddress,
                    strict: true,
                    ledger_index: 'current',
                    queue: true,
                    signer_lists: true,
                },
            ],
        };
        if (isKrsRecovery) {
            (0, sdk_core_1.checkKrsProvider)(this, params.krsProvider);
        }
        // Validate the destination address
        if (!this.isValidAddress(params.recoveryDestination)) {
            throw new Error('Invalid destination address!');
        }
        const keys = (0, sdk_core_1.getBip32Keys)(this.bitgo, params, { requireBitGoXpub: false });
        const { addressDetails, feeDetails, serverDetails } = await (0, sdk_core_1.promiseProps)({
            addressDetails: this.bitgo.post(rippledUrl).send(accountInfoParams),
            feeDetails: this.bitgo.post(rippledUrl).send({ method: 'fee' }),
            serverDetails: this.bitgo.post(rippledUrl).send({ method: 'server_info' }),
        });
        const openLedgerFee = new bignumber_js_1.BigNumber(feeDetails.body.result.drops.open_ledger_fee);
        const baseReserve = new bignumber_js_1.BigNumber(serverDetails.body.result.info.validated_ledger.reserve_base_xrp).times(this.getBaseFactor());
        const reserveDelta = new bignumber_js_1.BigNumber(serverDetails.body.result.info.validated_ledger.reserve_inc_xrp).times(this.getBaseFactor());
        const currentLedger = serverDetails.body.result.info.validated_ledger.seq;
        const sequenceId = addressDetails.body.result.account_data.Sequence;
        const balance = new bignumber_js_1.BigNumber(addressDetails.body.result.account_data.Balance);
        const signerLists = addressDetails.body.result.account_data.signer_lists;
        const accountFlags = addressDetails.body.result.account_data.Flags;
        // make sure there is only one signer list set
        if (signerLists.length !== 1) {
            throw new Error('unexpected set of signer lists');
        }
        // make sure the signers are user, backup, bitgo
        const userAddress = rippleKeypairs.deriveAddress(keys[0].publicKey.toString('hex'));
        const backupAddress = rippleKeypairs.deriveAddress(keys[1].publicKey.toString('hex'));
        const signerList = signerLists[0];
        if (signerList.SignerQuorum !== 2) {
            throw new Error('invalid minimum signature count');
        }
        const foundAddresses = {};
        const signerEntries = signerList.SignerEntries;
        if (signerEntries.length !== 3) {
            throw new Error('invalid signer list length');
        }
        for (const { SignerEntry } of signerEntries) {
            const weight = SignerEntry.SignerWeight;
            const address = SignerEntry.Account;
            if (weight !== 1) {
                throw new Error('invalid signer weight');
            }
            // if it's a dupe of an address we already know, block
            if (foundAddresses[address] >= 1) {
                throw new Error('duplicate signer address');
            }
            foundAddresses[address] = (foundAddresses[address] || 0) + 1;
        }
        if (foundAddresses[userAddress] !== 1) {
            throw new Error('unexpected incidence frequency of user signer address');
        }
        if (foundAddresses[backupAddress] !== 1) {
            throw new Error('unexpected incidence frequency of user signer address');
        }
        // make sure the flags disable the master key and enforce destination tags
        const USER_KEY_SETTING_FLAG = 65536;
        const MASTER_KEY_DEACTIVATION_FLAG = 1048576;
        const REQUIRE_DESTINATION_TAG_FLAG = 131072;
        if ((accountFlags & USER_KEY_SETTING_FLAG) !== 0) {
            throw new Error('a custom user key has been set');
        }
        if ((accountFlags & MASTER_KEY_DEACTIVATION_FLAG) !== MASTER_KEY_DEACTIVATION_FLAG) {
            throw new Error('the master key has not been deactivated');
        }
        if ((accountFlags & REQUIRE_DESTINATION_TAG_FLAG) !== REQUIRE_DESTINATION_TAG_FLAG) {
            throw new Error('the destination flag requirement has not been activated');
        }
        // recover the funds
        const reserve = baseReserve.plus(reserveDelta);
        const recoverableBalance = balance.minus(reserve);
        const rawDestination = params.recoveryDestination;
        const destinationDetails = url.parse(rawDestination);
        const destinationAddress = destinationDetails.pathname;
        // parse destination tag from query
        let destinationTag;
        if (destinationDetails.query) {
            const queryDetails = querystring.parse(destinationDetails.query);
            if (Array.isArray(queryDetails.dt)) {
                // if queryDetails.dt is an array, that means dt was given multiple times, which is not valid
                throw new sdk_core_1.InvalidAddressError(`destination tag can appear at most once, but ${queryDetails.dt.length} destination tags were found`);
            }
            const parsedTag = parseInt(queryDetails.dt, 10);
            if (Number.isInteger(parsedTag)) {
                destinationTag = parsedTag;
            }
        }
        if (recoverableBalance.toNumber() <= 0) {
            throw new Error(`Quantity of XRP to recover must be greater than 0. Current balance: ${balance.toNumber()}, blockchain reserve: ${reserve.toNumber()}, spendable balance: ${recoverableBalance.toNumber()}`);
        }
        const transaction = {
            TransactionType: 'Payment',
            Account: params.rootAddress,
            Destination: destinationAddress,
            DestinationTag: destinationTag,
            Amount: recoverableBalance.toFixed(0),
            Flags: 2147483648,
            LastLedgerSequence: currentLedger + 1000000,
            Fee: openLedgerFee.times(3).toFixed(0),
            Sequence: sequenceId,
        };
        const txJSON = JSON.stringify(transaction);
        if (isUnsignedSweep) {
            return {
                txHex: txJSON,
                coin: this.getChain(),
            };
        }
        const rippleLib = ripple();
        if (!keys[0].privateKey) {
            throw new Error(`userKey is not a private key`);
        }
        const userKey = keys[0].privateKey.toString('hex');
        const userSignature = rippleLib.signWithPrivateKey(txJSON, userKey, { signAs: userAddress });
        let signedTransaction;
        if (isKrsRecovery) {
            signedTransaction = userSignature;
        }
        else {
            if (!keys[1].privateKey) {
                throw new Error(`backupKey is not a private key`);
            }
            const backupKey = keys[1].privateKey.toString('hex');
            const backupSignature = rippleLib.signWithPrivateKey(txJSON, backupKey, { signAs: backupAddress });
            signedTransaction = rippleLib.combine([userSignature.signedTransaction, backupSignature.signedTransaction]);
        }
        const transactionExplanation = (await this.explainTransaction({
            txHex: signedTransaction.signedTransaction,
        }));
        transactionExplanation.txHex = signedTransaction.signedTransaction;
        if (isKrsRecovery) {
            transactionExplanation.backupKey = params.backupKey;
            transactionExplanation.coin = this.getChain();
        }
        return transactionExplanation;
    }
    initiateRecovery(params) {
        throw new Error('deprecated method');
    }
    /**
     * Generate a new keypair for this coin.
     * @param seed Seed from which the new keypair should be generated, otherwise a random seed is used
     */
    generateKeyPair(seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = (0, crypto_1.randomBytes)(512 / 8);
        }
        const extendedKey = utxo_lib_1.bip32.fromSeed(seed);
        const xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58(),
        };
    }
    async parseTransaction(params) {
        return {};
    }
}
exports.Xrp = Xrp;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieHJwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3hycC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0gsK0NBQXlDO0FBQ3pDLDhDQUFnRDtBQUNoRCxtQ0FBcUM7QUFDckMsMENBQTRCO0FBQzVCLHlDQUEyQjtBQUMzQix5REFBMkM7QUFFM0MseUVBQTJEO0FBQzNELHVFQUF5RDtBQUN6RCw4REFBaUY7QUFDakYsZ0VBQWtEO0FBQ2xELDhDQWlCeUI7QUFFekIsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBaUVuQyxNQUFhLEdBQUksU0FBUSxtQkFBUTtJQUMvQixZQUFzQixLQUFnQjtRQUNwQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDZixDQUFDO0lBRUQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFnQjtRQUNwQyxPQUFPLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7T0FFRztJQUNJLGFBQWE7UUFDbEIsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7O09BRUc7SUFDSSxRQUFRO1FBQ2IsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSSxTQUFTO1FBQ2QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSSxXQUFXO1FBQ2hCLE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7T0FFRztJQUNJLGlCQUFpQixDQUFDLE9BQWU7UUFDdEMsTUFBTSxrQkFBa0IsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzlDLE1BQU0sa0JBQWtCLEdBQUcsa0JBQWtCLENBQUMsUUFBUSxDQUFDO1FBQ3ZELElBQUksQ0FBQyxrQkFBa0IsSUFBSSxDQUFDLGtCQUFrQixDQUFDLHFCQUFxQixDQUFDLGtCQUFr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R0FBRyxJQUFBLG9CQUFXLEVBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQzdCO1FBQ0QsTUFBTSxXQUFXLEdBQUcsZ0JBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekMsTUFBTSxJQUFJLEdBQUcsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQy9DLE9BQU87WUFDTCxHQUFHLEVBQUUsSUFBSTtZQUNULEdBQUcsRUFBRSxXQUFXLENBQUMsUUFBUSxFQUFFO1NBQzVCLENBQUM7SUFDSixDQUFDO0lBRUQsS0FBSyxDQUFDLGdCQUFnQixDQUFDLE1BQStCO1FBQ3BELE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztDQUNGO0FBcmlCRCxrQkFxaUJDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IGJpcDMyLCBFQ1BhaXIgfSBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgdXJsIGZyb20gJ3VybCc7XG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICdxdWVyeXN0cmluZyc7XG5cbmltcG9ydCAqIGFzIHJpcHBsZUFkZHJlc3NDb2RlYyBmcm9tICdyaXBwbGUtYWRkcmVzcy1jb2RlYyc7XG5pbXBvcnQgKiBhcyByaXBwbGVCaW5hcnlDb2RlYyBmcm9tICdyaXBwbGUtYmluYXJ5LWNvZGVjJztcbmltcG9ydCB7IGNvbXB1dGVCaW5hcnlUcmFuc2FjdGlvbkhhc2ggfSBmcm9tICdyaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9oYXNoZXMnO1xuaW1wb3J0ICogYXMgcmlwcGxlS2V5cGFpcnMgZnJvbSAncmlwcGxlLWtleXBhaXJzJztcbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBCaXRHb0Jhc2UsXG4gIGNoZWNrS3JzUHJvdmlkZXIsXG4gIGdldEJpcDMyS2V5cyxcbiAgSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMgYXMgQmFzZUluaXRpYXRlUmVjb3ZlcnlPcHRpb25zLFxuICBJbnZhbGlkQWRkcmVzc0Vycm9yLFxuICBLZXlQYWlyLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIHByb21pc2VQcm9wcyxcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbixcbiAgVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgVW5leHBlY3RlZEFkZHJlc3NFcnJvcixcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMgYXMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zLFxuICBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5cbmNvbnN0IHJpcHBsZSA9IHJlcXVpcmUoJy4vcmlwcGxlJyk7XG5cbmludGVyZmFjZSBBZGRyZXNzIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBkZXN0aW5hdGlvblRhZz86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEZlZUluZm8ge1xuICBkYXRlOiBzdHJpbmc7XG4gIGhlaWdodDogbnVtYmVyO1xuICBiYXNlUmVzZXJ2ZTogc3RyaW5nO1xuICBiYXNlRmVlOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwcnY6IHN0cmluZztcbiAgaXNMYXN0U2lnbmF0dXJlPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEhleD86IHN0cmluZztcbiAgaGFsZlNpZ25lZD86IHtcbiAgICB0eEhleDogc3RyaW5nOyAvLyB0eEhleCBpcyBwb29ybHkgbmFtZWQgaGVyZTsgaXQgaXMganVzdCBhIHdyYXBwZWQgSlNPTiBvYmplY3RcbiAgfTtcbn1cblxuaW50ZXJmYWNlIFZlcmlmeUFkZHJlc3NPcHRpb25zIGV4dGVuZHMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zIHtcbiAgcm9vdEFkZHJlc3M6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlY292ZXJ5SW5mbyBleHRlbmRzIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24ge1xuICB0eEhleDogc3RyaW5nO1xuICBiYWNrdXBLZXk/OiBzdHJpbmc7XG4gIGNvaW4/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjb3ZlcnlUcmFuc2FjdGlvbiB7XG4gIHR4SGV4OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMgZXh0ZW5kcyBCYXNlSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMge1xuICBrcnNQcm92aWRlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyeU9wdGlvbnMge1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgdXNlcktleTogc3RyaW5nO1xuICByb290QWRkcmVzczogc3RyaW5nO1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7XG4gIGJpdGdvS2V5Pzogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlOiBzdHJpbmc7XG4gIGtyc1Byb3ZpZGVyPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgSGFsZlNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgaGFsZlNpZ25lZDoge1xuICAgIHR4SGV4OiBzdHJpbmc7XG4gIH07XG59XG5cbmludGVyZmFjZSBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zIHtcbiAgcm9vdFByaXZhdGVLZXk/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBYcnAgZXh0ZW5kcyBCYXNlQ29pbiB7XG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlKSB7XG4gICAgc3VwZXIoYml0Z28pO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHb0Jhc2UpOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBYcnAoYml0Z28pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhY3RvciBiZXR3ZWVuIHRoZSBjb2luJ3MgYmFzZSB1bml0IGFuZCBpdHMgc21hbGxlc3Qgc3ViZGl2aXNvblxuICAgKi9cbiAgcHVibGljIGdldEJhc2VGYWN0b3IoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gMWU2O1xuICB9XG5cbiAgLyoqXG4gICAqIElkZW50aWZpZXIgZm9yIHRoZSBibG9ja2NoYWluIHdoaWNoIHN1cHBvcnRzIHRoaXMgY29pblxuICAgKi9cbiAgcHVibGljIGdldENoYWluKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICd4cnAnO1xuICB9XG5cbiAgLyoqXG4gICAqIElkZW50aWZpZXIgZm9yIHRoZSBjb2luIGZhbWlseVxuICAgKi9cbiAgcHVibGljIGdldEZhbWlseSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAneHJwJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoaXMgY29pblxuICAgKi9cbiAgcHVibGljIGdldEZ1bGxOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdSaXBwbGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuIGFkZHJlc3Mgc3RyaW5nIGludG8gYWRkcmVzcyBhbmQgZGVzdGluYXRpb24gdGFnXG4gICAqL1xuICBwdWJsaWMgZ2V0QWRkcmVzc0RldGFpbHMoYWRkcmVzczogc3RyaW5nKTogQWRkcmVzcyB7XG4gICAgY29uc3QgZGVzdGluYXRpb25EZXRhaWxzID0gdXJsLnBhcnNlKGFkZHJlc3MpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uQWRkcmVzcyA9IGRlc3RpbmF0aW9uRGV0YWlscy5wYXRobmFtZTtcbiAgICBpZiAoIWRlc3RpbmF0aW9uQWRkcmVzcyB8fCAhcmlwcGxlQWRkcmVzc0NvZGVjLmlzVmFsaWRDbGFzc2ljQWRkcmVzcyhkZXN0aW5hdGlvbkFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgZGVzdGluYXRpb24gYWRkcmVzcyBcIiR7ZGVzdGluYXRpb25BZGRyZXNzfVwiIGlzIG5vdCB2YWxpZGApO1xuICAgIH1cbiAgICAvLyB0aGVyZSBhcmUgbm8gb3RoZXIgcHJvcGVydGllcyBsaWtlIGRlc3RpbmF0aW9uIHRhZ3NcbiAgICBpZiAoZGVzdGluYXRpb25EZXRhaWxzLnBhdGhuYW1lID09PSBhZGRyZXNzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICBkZXN0aW5hdGlvblRhZzogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWRlc3RpbmF0aW9uRGV0YWlscy5xdWVyeSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoJ25vIHF1ZXJ5IHBhcmFtcyBwcmVzZW50Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgcXVlcnlEZXRhaWxzID0gcXVlcnlzdHJpbmcucGFyc2UoZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KTtcbiAgICBpZiAoIXF1ZXJ5RGV0YWlscy5kdCkge1xuICAgICAgLy8gaWYgdGhlcmUgYXJlIG1vcmUgcHJvcGVydGllcywgdGhlIHF1ZXJ5IGRldGFpbHMgbmVlZCB0byBjb250YWluIHRoZSBkZXN0aW5hdGlvbiB0YWcgcHJvcGVydHkuXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcignZGVzdGluYXRpb24gdGFnIG1pc3NpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShxdWVyeURldGFpbHMuZHQpKSB7XG4gICAgICAvLyBpZiBxdWVyeURldGFpbHMuZHQgaXMgYW4gYXJyYXksIHRoYXQgbWVhbnMgZHQgd2FzIGdpdmVuIG11bHRpcGxlIHRpbWVzLCB3aGljaCBpcyBub3QgdmFsaWRcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKFxuICAgICAgICBgZGVzdGluYXRpb24gdGFnIGNhbiBhcHBlYXIgYXQgbW9zdCBvbmNlLCBidXQgJHtxdWVyeURldGFpbHMuZHQubGVuZ3RofSBkZXN0aW5hdGlvbiB0YWdzIHdlcmUgZm91bmRgXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnNlZFRhZyA9IHBhcnNlSW50KHF1ZXJ5RGV0YWlscy5kdCwgMTApO1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIocGFyc2VkVGFnKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoJ2ludmFsaWQgZGVzdGluYXRpb24gdGFnJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlZFRhZyA+IDB4ZmZmZmZmZmYgfHwgcGFyc2VkVGFnIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoJ2Rlc3RpbmF0aW9uIHRhZyBvdXQgb2YgcmFuZ2UnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogZGVzdGluYXRpb25BZGRyZXNzLFxuICAgICAgZGVzdGluYXRpb25UYWc6IHBhcnNlZFRhZyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIGZ1bGwsIG5vcm1hbGl6ZWQgYWRkcmVzcyBmcm9tIGFuIGFkZHJlc3MgYW5kIGRlc3RpbmF0aW9uIHRhZ1xuICAgKi9cbiAgcHVibGljIG5vcm1hbGl6ZUFkZHJlc3MoeyBhZGRyZXNzLCBkZXN0aW5hdGlvblRhZyB9OiBBZGRyZXNzKTogc3RyaW5nIHtcbiAgICBpZiAoIV8uaXNTdHJpbmcoYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKCdpbnZhbGlkIGFkZHJlc3MgZGV0YWlscycpO1xuICAgIH1cbiAgICBpZiAoXy5pc0ludGVnZXIoZGVzdGluYXRpb25UYWcpKSB7XG4gICAgICByZXR1cm4gYCR7YWRkcmVzc30/ZHQ9JHtkZXN0aW5hdGlvblRhZ31gO1xuICAgIH1cbiAgICByZXR1cm4gYWRkcmVzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZXMgd2hldGhlciBhbiBhZGRyZXNzIHN0cmluZyBpcyB2YWxpZCBmb3IgdGhpcyBjb2luXG4gICAqIEBwYXJhbSBhZGRyZXNzXG4gICAqL1xuICBwdWJsaWMgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFkZHJlc3NEZXRhaWxzID0gdGhpcy5nZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKTtcbiAgICAgIHJldHVybiBhZGRyZXNzID09PSB0aGlzLm5vcm1hbGl6ZUFkZHJlc3MoYWRkcmVzc0RldGFpbHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHViIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBwdWJsaWMgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYmlwMzIuZnJvbUJhc2U1OChwdWIpLmlzTmV1dGVyZWQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBmZWUgaW5mbyBmcm9tIHNlcnZlclxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldEZlZUluZm8oKTogUHJvbWlzZTxGZWVJbmZvPiB7XG4gICAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMudXJsKCcvcHVibGljL2ZlZWluZm8nKSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gdHhQcmVidWlsZFxuICAgKiAtIHBydlxuICAgKiBAcmV0dXJucyBCbHVlYmlyZDxIYWxmU2lnbmVkVHJhbnNhY3Rpb24+XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHtcbiAgICB0eFByZWJ1aWxkLFxuICAgIHBydixcbiAgICBpc0xhc3RTaWduYXR1cmUsXG4gIH06IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPEhhbGZTaWduZWRUcmFuc2FjdGlvbiB8IFJlY292ZXJ5VHJhbnNhY3Rpb24+IHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh0eFByZWJ1aWxkKSB8fCAhXy5pc09iamVjdCh0eFByZWJ1aWxkKSkge1xuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHR4UHJlYnVpbGQpICYmICFfLmlzT2JqZWN0KHR4UHJlYnVpbGQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdHhQcmVidWlsZCBtdXN0IGJlIGFuIG9iamVjdCwgZ290IHR5cGUgJHt0eXBlb2YgdHhQcmVidWlsZH1gKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB0eFByZWJ1aWxkIHBhcmFtZXRlcicpO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBydikgfHwgIV8uaXNTdHJpbmcocHJ2KSkge1xuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBydikgJiYgIV8uaXNTdHJpbmcocHJ2KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBydiBtdXN0IGJlIGEgc3RyaW5nLCBnb3QgdHlwZSAke3R5cGVvZiBwcnZ9YCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHJ2IHBhcmFtZXRlciB0byBzaWduIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlcktleSA9IGJpcDMyLmZyb21CYXNlNTgocHJ2KTtcbiAgICBjb25zdCB1c2VyUHJpdmF0ZUtleSA9IHVzZXJLZXkucHJpdmF0ZUtleTtcbiAgICBpZiAoIXVzZXJQcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIHByaXZhdGVLZXlgKTtcbiAgICB9XG4gICAgY29uc3QgdXNlckFkZHJlc3MgPSByaXBwbGVLZXlwYWlycy5kZXJpdmVBZGRyZXNzKHVzZXJLZXkucHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKSk7XG5cbiAgICBjb25zdCByaXBwbGVMaWIgPSByaXBwbGUoKTtcblxuICAgIGNvbnN0IHR4ID0gcmlwcGxlTGliLnNpZ25XaXRoUHJpdmF0ZUtleSh0eFByZWJ1aWxkLnR4SGV4LCB1c2VyUHJpdmF0ZUtleS50b1N0cmluZygnaGV4JyksIHtcbiAgICAgIHNpZ25BczogdXNlckFkZHJlc3MsXG4gICAgfSk7XG5cbiAgICAvLyBOb3JtYWxseSB0aGUgU0RLIHByb3ZpZGVzIHRoZSBmaXJzdCBzaWduYXR1cmUgZm9yIGFuIFhSUCB0eCwgYnV0IG9jY2FzaW9uYWxseSBpdCBwcm92aWRlcyB0aGUgZmluYWwgb25lIGFzIHdlbGxcbiAgICAvLyAocmVjb3ZlcmllcylcbiAgICBpZiAoaXNMYXN0U2lnbmF0dXJlKSB7XG4gICAgICByZXR1cm4geyB0eEhleDogdHguc2lnbmVkVHJhbnNhY3Rpb24gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaGFsZlNpZ25lZDogeyB0eEhleDogdHguc2lnbmVkVHJhbnNhY3Rpb24gfSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJpcHBsZSByZXF1aXJlcyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHdhbGxldCBnZW5lcmF0aW9uIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci4gVGhlIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBhcmVcbiAgICogdGhlIHJvb3QgcHVibGljIGtleSwgd2hpY2ggaXMgdGhlIGJhc2lzIG9mIHRoZSByb290IGFkZHJlc3MsIHR3byBzaWduZWQsIGFuZCBvbmUgaGFsZi1zaWduZWQgaW5pdGlhbGl6YXRpb24gdHhzXG4gICAqIEBwYXJhbSB3YWxsZXRQYXJhbXNcbiAgICogLSByb290UHJpdmF0ZUtleTogb3B0aW9uYWwgaGV4LWVuY29kZWQgUmlwcGxlIHByaXZhdGUga2V5XG4gICAqL1xuICBhc3luYyBzdXBwbGVtZW50R2VuZXJhdGVXYWxsZXQoXG4gICAgd2FsbGV0UGFyYW1zOiBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zXG4gICk6IFByb21pc2U8U3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucz4ge1xuICAgIGlmICh3YWxsZXRQYXJhbXMucm9vdFByaXZhdGVLZXkpIHtcbiAgICAgIGlmICh3YWxsZXRQYXJhbXMucm9vdFByaXZhdGVLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jvb3RQcml2YXRlS2V5IG5lZWRzIHRvIGJlIGEgaGV4YWRlY2ltYWwgcHJpdmF0ZSBrZXkgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleVBhaXIgPSBFQ1BhaXIubWFrZVJhbmRvbSgpO1xuICAgICAgaWYgKCFrZXlQYWlyLnByaXZhdGVLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBwcml2YXRlS2V5Jyk7XG4gICAgICB9XG4gICAgICB3YWxsZXRQYXJhbXMucm9vdFByaXZhdGVLZXkgPSBrZXlQYWlyLnByaXZhdGVLZXkudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbiAgICByZXR1cm4gd2FsbGV0UGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGxhaW4vcGFyc2UgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgZXhwbGFpblRyYW5zYWN0aW9uKHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPiB7XG4gICAgbGV0IHRyYW5zYWN0aW9uO1xuICAgIGxldCB0eEhleDogc3RyaW5nID0gcGFyYW1zLnR4SGV4IHx8ICgocGFyYW1zLmhhbGZTaWduZWQgJiYgcGFyYW1zLmhhbGZTaWduZWQudHhIZXgpIGFzIHN0cmluZyk7XG4gICAgaWYgKCF0eEhleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHBhcmFtIHR4SGV4Jyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0cmFuc2FjdGlvbiA9IHJpcHBsZUJpbmFyeUNvZGVjLmRlY29kZSh0eEhleCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHJhbnNhY3Rpb24gPSBKU09OLnBhcnNlKHR4SGV4KTtcbiAgICAgICAgdHhIZXggPSByaXBwbGVCaW5hcnlDb2RlYy5lbmNvZGUodHJhbnNhY3Rpb24pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4SGV4IG5lZWRzIHRvIGJlIGVpdGhlciBoZXggb3IgSlNPTiBzdHJpbmcgZm9yIFhSUCcpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpZCA9IGNvbXB1dGVCaW5hcnlUcmFuc2FjdGlvbkhhc2godHhIZXggYXMgc3RyaW5nKTtcblxuICAgIGlmICh0cmFuc2FjdGlvbi5UcmFuc2FjdGlvblR5cGUgPT0gJ0FjY291bnRTZXQnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXNwbGF5T3JkZXI6IFsnaWQnLCAnb3V0cHV0QW1vdW50JywgJ2NoYW5nZUFtb3VudCcsICdvdXRwdXRzJywgJ2NoYW5nZU91dHB1dHMnLCAnZmVlJywgJ2FjY291bnRTZXQnXSxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBjaGFuZ2VPdXRwdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0QW1vdW50OiAwLFxuICAgICAgICBjaGFuZ2VBbW91bnQ6IDAsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBmZWU6IHtcbiAgICAgICAgICBmZWU6IHRyYW5zYWN0aW9uLkZlZSxcbiAgICAgICAgICBmZWVSYXRlOiBudWxsLFxuICAgICAgICAgIHNpemU6IHR4SGV4IS5sZW5ndGggLyAyLFxuICAgICAgICB9LFxuICAgICAgICBhY2NvdW50U2V0OiB7XG4gICAgICAgICAgbWVzc2FnZUtleTogdHJhbnNhY3Rpb24uTWVzc2FnZUtleSxcbiAgICAgICAgfSxcbiAgICAgIH0gYXMgYW55O1xuICAgIH1cblxuICAgIGNvbnN0IGFkZHJlc3MgPVxuICAgICAgdHJhbnNhY3Rpb24uRGVzdGluYXRpb24gKyAodHJhbnNhY3Rpb24uRGVzdGluYXRpb25UYWcgPj0gMCA/ICc/ZHQ9JyArIHRyYW5zYWN0aW9uLkRlc3RpbmF0aW9uVGFnIDogJycpO1xuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5T3JkZXI6IFsnaWQnLCAnb3V0cHV0QW1vdW50JywgJ2NoYW5nZUFtb3VudCcsICdvdXRwdXRzJywgJ2NoYW5nZU91dHB1dHMnLCAnZmVlJ10sXG4gICAgICBpZDogaWQsXG4gICAgICBjaGFuZ2VPdXRwdXRzOiBbXSxcbiAgICAgIG91dHB1dEFtb3VudDogdHJhbnNhY3Rpb24uQW1vdW50LFxuICAgICAgY2hhbmdlQW1vdW50OiAwLFxuICAgICAgb3V0cHV0czogW1xuICAgICAgICB7XG4gICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICBhbW91bnQ6IHRyYW5zYWN0aW9uLkFtb3VudCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBmZWU6IHtcbiAgICAgICAgZmVlOiB0cmFuc2FjdGlvbi5GZWUsXG4gICAgICAgIGZlZVJhdGU6IG51bGwsXG4gICAgICAgIHNpemU6IHR4SGV4Lmxlbmd0aCAvIDIsXG4gICAgICB9LFxuICAgIH0gYXMgYW55O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGF0IGEgdHJhbnNhY3Rpb24gcHJlYnVpbGQgY29tcGxpZXMgd2l0aCB0aGUgb3JpZ2luYWwgaW50ZW50aW9uXG4gICAqIEBwYXJhbSB0eFBhcmFtcyBwYXJhbXMgb2JqZWN0IHBhc3NlZCB0byBzZW5kXG4gICAqIEBwYXJhbSB0eFByZWJ1aWxkIHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBzZXJ2ZXJcbiAgICogQHBhcmFtIHdhbGxldFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHB1YmxpYyBhc3luYyB2ZXJpZnlUcmFuc2FjdGlvbih7IHR4UGFyYW1zLCB0eFByZWJ1aWxkIH06IFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGV4cGxhbmF0aW9uID0gYXdhaXQgdGhpcy5leHBsYWluVHJhbnNhY3Rpb24oe1xuICAgICAgdHhIZXg6IHR4UHJlYnVpbGQudHhIZXgsXG4gICAgfSk7XG5cbiAgICBjb25zdCBvdXRwdXQgPSBbLi4uZXhwbGFuYXRpb24ub3V0cHV0cywgLi4uZXhwbGFuYXRpb24uY2hhbmdlT3V0cHV0c11bMF07XG4gICAgY29uc3QgZXhwZWN0ZWRPdXRwdXQgPSB0eFBhcmFtcy5yZWNpcGllbnRzICYmIHR4UGFyYW1zLnJlY2lwaWVudHNbMF07XG5cbiAgICBjb25zdCBjb21wYXJhdG9yID0gKHJlY2lwaWVudDEsIHJlY2lwaWVudDIpID0+IHtcbiAgICAgIGlmIChyZWNpcGllbnQxLmFkZHJlc3MgIT09IHJlY2lwaWVudDIuYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBhbW91bnQxID0gbmV3IEJpZ051bWJlcihyZWNpcGllbnQxLmFtb3VudCk7XG4gICAgICBjb25zdCBhbW91bnQyID0gbmV3IEJpZ051bWJlcihyZWNpcGllbnQyLmFtb3VudCk7XG4gICAgICByZXR1cm4gYW1vdW50MS50b0ZpeGVkKCkgPT09IGFtb3VudDIudG9GaXhlZCgpO1xuICAgIH07XG5cbiAgICBpZiAoIWNvbXBhcmF0b3Iob3V0cHV0LCBleHBlY3RlZE91dHB1dCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgb3V0cHV0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYWRkcmVzcyBpcyBhIHZhbGlkIFhSUCBhZGRyZXNzLCBhbmQgdGhlbiBtYWtlIHN1cmUgdGhlIHJvb3QgYWRkcmVzc2VzIG1hdGNoLlxuICAgKiBUaGlzIHByZXZlbnRzIGF0dGFja3Mgd2hlcmUgYW4gYXR0YWNrIG1heSBzd2l0Y2ggb3V0IHRoZSBuZXcgYWRkcmVzcyBmb3Igb25lIG9mIHRoZWlyIG93blxuICAgKiBAcGFyYW0gYWRkcmVzcyB7U3RyaW5nfSB0aGUgYWRkcmVzcyB0byB2ZXJpZnlcbiAgICogQHBhcmFtIHJvb3RBZGRyZXNzIHtTdHJpbmd9IHRoZSB3YWxsZXQncyByb290IGFkZHJlc3NcbiAgICogQHJldHVybiB0cnVlIGlmZiBhZGRyZXNzIGlzIGEgd2FsbGV0IGFkZHJlc3MgKGJhc2VkIG9uIHJvb3RBZGRyZXNzKVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGlzV2FsbGV0QWRkcmVzcyh7IGFkZHJlc3MsIHJvb3RBZGRyZXNzIH06IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgYWRkcmVzcyB2ZXJpZmljYXRpb24gZmFpbHVyZTogYWRkcmVzcyBcIiR7YWRkcmVzc31cIiBpcyBub3QgdmFsaWRgKTtcbiAgICB9XG5cbiAgICBjb25zdCBhZGRyZXNzRGV0YWlscyA9IHRoaXMuZ2V0QWRkcmVzc0RldGFpbHMoYWRkcmVzcyk7XG4gICAgY29uc3Qgcm9vdEFkZHJlc3NEZXRhaWxzID0gdGhpcy5nZXRBZGRyZXNzRGV0YWlscyhyb290QWRkcmVzcyk7XG5cbiAgICBpZiAoYWRkcmVzc0RldGFpbHMuYWRkcmVzcyAhPT0gcm9vdEFkZHJlc3NEZXRhaWxzLmFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yKFxuICAgICAgICBgYWRkcmVzcyB2YWxpZGF0aW9uIGZhaWx1cmU6ICR7YWRkcmVzc0RldGFpbHMuYWRkcmVzc30gdnMuICR7cm9vdEFkZHJlc3NEZXRhaWxzLmFkZHJlc3N9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVUkwgb2YgYSB3ZWxsLWtub3duLCBwdWJsaWMgZmFjaW5nIChub24tYml0Z28pIHJpcHBsZWQgaW5zdGFuY2Ugd2hpY2ggY2FuIGJlIHVzZWQgZm9yIHJlY292ZXJ5XG4gICAqL1xuICBwdWJsaWMgZ2V0UmlwcGxlZFVybCgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnaHR0cHM6Ly9zMS5yaXBwbGUuY29tOjUxMjM0JztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBmdW5kcyByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRob3V0IEJpdEdvXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSByb290QWRkcmVzczogcm9vdCBYUlAgd2FsbGV0IGFkZHJlc3MgdG8gcmVjb3ZlciBmdW5kcyBmcm9tXG4gICAqIC0gdXNlcktleTogW2VuY3J5cHRlZF0geHBydlxuICAgKiAtIGJhY2t1cEtleTogW2VuY3J5cHRlZF0geHBydiwgb3IgeHB1YiBpZiB0aGUgeHBydiBpcyBoZWxkIGJ5IGEgS1JTIHByb3ZpZGVyXG4gICAqIC0gd2FsbGV0UGFzc3BocmFzZTogbmVjZXNzYXJ5IGlmIG9uZSBvZiB0aGUgeHBydnMgaXMgZW5jcnlwdGVkXG4gICAqIC0gYml0Z29LZXk6IHhwdWJcbiAgICogLSBrcnNQcm92aWRlcjogbmVjZXNzYXJ5IGlmIGJhY2t1cCBrZXkgaXMgaGVsZCBieSBLUlNcbiAgICogLSByZWNvdmVyeURlc3RpbmF0aW9uOiB0YXJnZXQgYWRkcmVzcyB0byBzZW5kIHJlY292ZXJlZCBmdW5kcyB0b1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlY292ZXIocGFyYW1zOiBSZWNvdmVyeU9wdGlvbnMpOiBQcm9taXNlPFJlY292ZXJ5SW5mbyB8IFJlY292ZXJ5VHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCByaXBwbGVkVXJsID0gdGhpcy5nZXRSaXBwbGVkVXJsKCk7XG4gICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IHBhcmFtcy5iYWNrdXBLZXkuc3RhcnRzV2l0aCgneHB1YicpICYmICFwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCd4cHViJyk7XG4gICAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gcGFyYW1zLmJhY2t1cEtleS5zdGFydHNXaXRoKCd4cHViJykgJiYgcGFyYW1zLnVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpO1xuXG4gICAgY29uc3QgYWNjb3VudEluZm9QYXJhbXMgPSB7XG4gICAgICBtZXRob2Q6ICdhY2NvdW50X2luZm8nLFxuICAgICAgcGFyYW1zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBhY2NvdW50OiBwYXJhbXMucm9vdEFkZHJlc3MsXG4gICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgIGxlZGdlcl9pbmRleDogJ2N1cnJlbnQnLFxuICAgICAgICAgIHF1ZXVlOiB0cnVlLFxuICAgICAgICAgIHNpZ25lcl9saXN0czogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcblxuICAgIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgICBjaGVja0tyc1Byb3ZpZGVyKHRoaXMsIHBhcmFtcy5rcnNQcm92aWRlcik7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgdGhlIGRlc3RpbmF0aW9uIGFkZHJlc3NcbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGVzdGluYXRpb24gYWRkcmVzcyEnKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gZ2V0QmlwMzJLZXlzKHRoaXMuYml0Z28sIHBhcmFtcywgeyByZXF1aXJlQml0R29YcHViOiBmYWxzZSB9KTtcblxuICAgIGNvbnN0IHsgYWRkcmVzc0RldGFpbHMsIGZlZURldGFpbHMsIHNlcnZlckRldGFpbHMgfSA9IGF3YWl0IHByb21pc2VQcm9wcyh7XG4gICAgICBhZGRyZXNzRGV0YWlsczogdGhpcy5iaXRnby5wb3N0KHJpcHBsZWRVcmwpLnNlbmQoYWNjb3VudEluZm9QYXJhbXMpLFxuICAgICAgZmVlRGV0YWlsczogdGhpcy5iaXRnby5wb3N0KHJpcHBsZWRVcmwpLnNlbmQoeyBtZXRob2Q6ICdmZWUnIH0pLFxuICAgICAgc2VydmVyRGV0YWlsczogdGhpcy5iaXRnby5wb3N0KHJpcHBsZWRVcmwpLnNlbmQoeyBtZXRob2Q6ICdzZXJ2ZXJfaW5mbycgfSksXG4gICAgfSk7XG5cbiAgICBjb25zdCBvcGVuTGVkZ2VyRmVlID0gbmV3IEJpZ051bWJlcihmZWVEZXRhaWxzLmJvZHkucmVzdWx0LmRyb3BzLm9wZW5fbGVkZ2VyX2ZlZSk7XG4gICAgY29uc3QgYmFzZVJlc2VydmUgPSBuZXcgQmlnTnVtYmVyKHNlcnZlckRldGFpbHMuYm9keS5yZXN1bHQuaW5mby52YWxpZGF0ZWRfbGVkZ2VyLnJlc2VydmVfYmFzZV94cnApLnRpbWVzKFxuICAgICAgdGhpcy5nZXRCYXNlRmFjdG9yKClcbiAgICApO1xuICAgIGNvbnN0IHJlc2VydmVEZWx0YSA9IG5ldyBCaWdOdW1iZXIoc2VydmVyRGV0YWlscy5ib2R5LnJlc3VsdC5pbmZvLnZhbGlkYXRlZF9sZWRnZXIucmVzZXJ2ZV9pbmNfeHJwKS50aW1lcyhcbiAgICAgIHRoaXMuZ2V0QmFzZUZhY3RvcigpXG4gICAgKTtcbiAgICBjb25zdCBjdXJyZW50TGVkZ2VyID0gc2VydmVyRGV0YWlscy5ib2R5LnJlc3VsdC5pbmZvLnZhbGlkYXRlZF9sZWRnZXIuc2VxO1xuICAgIGNvbnN0IHNlcXVlbmNlSWQgPSBhZGRyZXNzRGV0YWlscy5ib2R5LnJlc3VsdC5hY2NvdW50X2RhdGEuU2VxdWVuY2U7XG4gICAgY29uc3QgYmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoYWRkcmVzc0RldGFpbHMuYm9keS5yZXN1bHQuYWNjb3VudF9kYXRhLkJhbGFuY2UpO1xuICAgIGNvbnN0IHNpZ25lckxpc3RzID0gYWRkcmVzc0RldGFpbHMuYm9keS5yZXN1bHQuYWNjb3VudF9kYXRhLnNpZ25lcl9saXN0cztcbiAgICBjb25zdCBhY2NvdW50RmxhZ3MgPSBhZGRyZXNzRGV0YWlscy5ib2R5LnJlc3VsdC5hY2NvdW50X2RhdGEuRmxhZ3M7XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlcmUgaXMgb25seSBvbmUgc2lnbmVyIGxpc3Qgc2V0XG4gICAgaWYgKHNpZ25lckxpc3RzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHNldCBvZiBzaWduZXIgbGlzdHMnKTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIHNpZ25lcnMgYXJlIHVzZXIsIGJhY2t1cCwgYml0Z29cbiAgICBjb25zdCB1c2VyQWRkcmVzcyA9IHJpcHBsZUtleXBhaXJzLmRlcml2ZUFkZHJlc3Moa2V5c1swXS5wdWJsaWNLZXkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICBjb25zdCBiYWNrdXBBZGRyZXNzID0gcmlwcGxlS2V5cGFpcnMuZGVyaXZlQWRkcmVzcyhrZXlzWzFdLnB1YmxpY0tleS50b1N0cmluZygnaGV4JykpO1xuXG4gICAgY29uc3Qgc2lnbmVyTGlzdCA9IHNpZ25lckxpc3RzWzBdO1xuICAgIGlmIChzaWduZXJMaXN0LlNpZ25lclF1b3J1bSAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1pbmltdW0gc2lnbmF0dXJlIGNvdW50Jyk7XG4gICAgfVxuICAgIGNvbnN0IGZvdW5kQWRkcmVzc2VzID0ge307XG5cbiAgICBjb25zdCBzaWduZXJFbnRyaWVzID0gc2lnbmVyTGlzdC5TaWduZXJFbnRyaWVzO1xuICAgIGlmIChzaWduZXJFbnRyaWVzLmxlbmd0aCAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZ25lciBsaXN0IGxlbmd0aCcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHsgU2lnbmVyRW50cnkgfSBvZiBzaWduZXJFbnRyaWVzKSB7XG4gICAgICBjb25zdCB3ZWlnaHQgPSBTaWduZXJFbnRyeS5TaWduZXJXZWlnaHQ7XG4gICAgICBjb25zdCBhZGRyZXNzID0gU2lnbmVyRW50cnkuQWNjb3VudDtcbiAgICAgIGlmICh3ZWlnaHQgIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZ25lciB3ZWlnaHQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgaXQncyBhIGR1cGUgb2YgYW4gYWRkcmVzcyB3ZSBhbHJlYWR5IGtub3csIGJsb2NrXG4gICAgICBpZiAoZm91bmRBZGRyZXNzZXNbYWRkcmVzc10gPj0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2R1cGxpY2F0ZSBzaWduZXIgYWRkcmVzcycpO1xuICAgICAgfVxuICAgICAgZm91bmRBZGRyZXNzZXNbYWRkcmVzc10gPSAoZm91bmRBZGRyZXNzZXNbYWRkcmVzc10gfHwgMCkgKyAxO1xuICAgIH1cblxuICAgIGlmIChmb3VuZEFkZHJlc3Nlc1t1c2VyQWRkcmVzc10gIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBpbmNpZGVuY2UgZnJlcXVlbmN5IG9mIHVzZXIgc2lnbmVyIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgaWYgKGZvdW5kQWRkcmVzc2VzW2JhY2t1cEFkZHJlc3NdICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgaW5jaWRlbmNlIGZyZXF1ZW5jeSBvZiB1c2VyIHNpZ25lciBhZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBmbGFncyBkaXNhYmxlIHRoZSBtYXN0ZXIga2V5IGFuZCBlbmZvcmNlIGRlc3RpbmF0aW9uIHRhZ3NcbiAgICBjb25zdCBVU0VSX0tFWV9TRVRUSU5HX0ZMQUcgPSA2NTUzNjtcbiAgICBjb25zdCBNQVNURVJfS0VZX0RFQUNUSVZBVElPTl9GTEFHID0gMTA0ODU3NjtcbiAgICBjb25zdCBSRVFVSVJFX0RFU1RJTkFUSU9OX1RBR19GTEFHID0gMTMxMDcyO1xuICAgIGlmICgoYWNjb3VudEZsYWdzICYgVVNFUl9LRVlfU0VUVElOR19GTEFHKSAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhIGN1c3RvbSB1c2VyIGtleSBoYXMgYmVlbiBzZXQnKTtcbiAgICB9XG4gICAgaWYgKChhY2NvdW50RmxhZ3MgJiBNQVNURVJfS0VZX0RFQUNUSVZBVElPTl9GTEFHKSAhPT0gTUFTVEVSX0tFWV9ERUFDVElWQVRJT05fRkxBRykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgbWFzdGVyIGtleSBoYXMgbm90IGJlZW4gZGVhY3RpdmF0ZWQnKTtcbiAgICB9XG4gICAgaWYgKChhY2NvdW50RmxhZ3MgJiBSRVFVSVJFX0RFU1RJTkFUSU9OX1RBR19GTEFHKSAhPT0gUkVRVUlSRV9ERVNUSU5BVElPTl9UQUdfRkxBRykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgZGVzdGluYXRpb24gZmxhZyByZXF1aXJlbWVudCBoYXMgbm90IGJlZW4gYWN0aXZhdGVkJyk7XG4gICAgfVxuXG4gICAgLy8gcmVjb3ZlciB0aGUgZnVuZHNcbiAgICBjb25zdCByZXNlcnZlID0gYmFzZVJlc2VydmUucGx1cyhyZXNlcnZlRGVsdGEpO1xuICAgIGNvbnN0IHJlY292ZXJhYmxlQmFsYW5jZSA9IGJhbGFuY2UubWludXMocmVzZXJ2ZSk7XG5cbiAgICBjb25zdCByYXdEZXN0aW5hdGlvbiA9IHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uRGV0YWlscyA9IHVybC5wYXJzZShyYXdEZXN0aW5hdGlvbik7XG4gICAgY29uc3QgZGVzdGluYXRpb25BZGRyZXNzID0gZGVzdGluYXRpb25EZXRhaWxzLnBhdGhuYW1lO1xuXG4gICAgLy8gcGFyc2UgZGVzdGluYXRpb24gdGFnIGZyb20gcXVlcnlcbiAgICBsZXQgZGVzdGluYXRpb25UYWc6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICBpZiAoZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KSB7XG4gICAgICBjb25zdCBxdWVyeURldGFpbHMgPSBxdWVyeXN0cmluZy5wYXJzZShkZXN0aW5hdGlvbkRldGFpbHMucXVlcnkpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlEZXRhaWxzLmR0KSkge1xuICAgICAgICAvLyBpZiBxdWVyeURldGFpbHMuZHQgaXMgYW4gYXJyYXksIHRoYXQgbWVhbnMgZHQgd2FzIGdpdmVuIG11bHRpcGxlIHRpbWVzLCB3aGljaCBpcyBub3QgdmFsaWRcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoXG4gICAgICAgICAgYGRlc3RpbmF0aW9uIHRhZyBjYW4gYXBwZWFyIGF0IG1vc3Qgb25jZSwgYnV0ICR7cXVlcnlEZXRhaWxzLmR0Lmxlbmd0aH0gZGVzdGluYXRpb24gdGFncyB3ZXJlIGZvdW5kYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZWRUYWcgPSBwYXJzZUludChxdWVyeURldGFpbHMuZHQgYXMgc3RyaW5nLCAxMCk7XG4gICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihwYXJzZWRUYWcpKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uVGFnID0gcGFyc2VkVGFnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZWNvdmVyYWJsZUJhbGFuY2UudG9OdW1iZXIoKSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBRdWFudGl0eSBvZiBYUlAgdG8gcmVjb3ZlciBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLiBDdXJyZW50IGJhbGFuY2U6ICR7YmFsYW5jZS50b051bWJlcigpfSwgYmxvY2tjaGFpbiByZXNlcnZlOiAke3Jlc2VydmUudG9OdW1iZXIoKX0sIHNwZW5kYWJsZSBiYWxhbmNlOiAke3JlY292ZXJhYmxlQmFsYW5jZS50b051bWJlcigpfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgICBUcmFuc2FjdGlvblR5cGU6ICdQYXltZW50JyxcbiAgICAgIEFjY291bnQ6IHBhcmFtcy5yb290QWRkcmVzcywgLy8gc291cmNlIGFkZHJlc3NcbiAgICAgIERlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbkFkZHJlc3MsXG4gICAgICBEZXN0aW5hdGlvblRhZzogZGVzdGluYXRpb25UYWcsXG4gICAgICBBbW91bnQ6IHJlY292ZXJhYmxlQmFsYW5jZS50b0ZpeGVkKDApLFxuICAgICAgRmxhZ3M6IDIxNDc0ODM2NDgsXG4gICAgICBMYXN0TGVkZ2VyU2VxdWVuY2U6IGN1cnJlbnRMZWRnZXIgKyAxMDAwMDAwLCAvLyBnaXZlIGl0IDEgbWlsbGlvbiBsZWRnZXJzJyB0aW1lICh+MSBtb250aCwgc3VpdGFibGUgZm9yIEtSUylcbiAgICAgIEZlZTogb3BlbkxlZGdlckZlZS50aW1lcygzKS50b0ZpeGVkKDApLCAvLyB0aGUgZmFjdG9yIHRocmVlIGlzIGZvciB0aGUgbXVsdGlzaWduaW5nXG4gICAgICBTZXF1ZW5jZTogc2VxdWVuY2VJZCxcbiAgICB9O1xuICAgIGNvbnN0IHR4SlNPTjogc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkodHJhbnNhY3Rpb24pO1xuXG4gICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHhIZXg6IHR4SlNPTixcbiAgICAgICAgY29pbjogdGhpcy5nZXRDaGFpbigpLFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmlwcGxlTGliID0gcmlwcGxlKCk7XG4gICAgaWYgKCFrZXlzWzBdLnByaXZhdGVLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdXNlcktleSBpcyBub3QgYSBwcml2YXRlIGtleWApO1xuICAgIH1cbiAgICBjb25zdCB1c2VyS2V5ID0ga2V5c1swXS5wcml2YXRlS2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCB1c2VyU2lnbmF0dXJlID0gcmlwcGxlTGliLnNpZ25XaXRoUHJpdmF0ZUtleSh0eEpTT04sIHVzZXJLZXksIHsgc2lnbkFzOiB1c2VyQWRkcmVzcyB9KTtcblxuICAgIGxldCBzaWduZWRUcmFuc2FjdGlvbjtcblxuICAgIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgICBzaWduZWRUcmFuc2FjdGlvbiA9IHVzZXJTaWduYXR1cmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgha2V5c1sxXS5wcml2YXRlS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFja3VwS2V5IGlzIG5vdCBhIHByaXZhdGUga2V5YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBiYWNrdXBLZXkgPSBrZXlzWzFdLnByaXZhdGVLZXkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgY29uc3QgYmFja3VwU2lnbmF0dXJlID0gcmlwcGxlTGliLnNpZ25XaXRoUHJpdmF0ZUtleSh0eEpTT04sIGJhY2t1cEtleSwgeyBzaWduQXM6IGJhY2t1cEFkZHJlc3MgfSk7XG4gICAgICBzaWduZWRUcmFuc2FjdGlvbiA9IHJpcHBsZUxpYi5jb21iaW5lKFt1c2VyU2lnbmF0dXJlLnNpZ25lZFRyYW5zYWN0aW9uLCBiYWNrdXBTaWduYXR1cmUuc2lnbmVkVHJhbnNhY3Rpb25dKTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2FjdGlvbkV4cGxhbmF0aW9uOiBSZWNvdmVyeUluZm8gPSAoYXdhaXQgdGhpcy5leHBsYWluVHJhbnNhY3Rpb24oe1xuICAgICAgdHhIZXg6IHNpZ25lZFRyYW5zYWN0aW9uLnNpZ25lZFRyYW5zYWN0aW9uLFxuICAgIH0pKSBhcyBhbnk7XG4gICAgdHJhbnNhY3Rpb25FeHBsYW5hdGlvbi50eEhleCA9IHNpZ25lZFRyYW5zYWN0aW9uLnNpZ25lZFRyYW5zYWN0aW9uO1xuXG4gICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgIHRyYW5zYWN0aW9uRXhwbGFuYXRpb24uYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleTtcbiAgICAgIHRyYW5zYWN0aW9uRXhwbGFuYXRpb24uY29pbiA9IHRoaXMuZ2V0Q2hhaW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uRXhwbGFuYXRpb247XG4gIH1cblxuICBpbml0aWF0ZVJlY292ZXJ5KHBhcmFtczogSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMpOiBuZXZlciB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZXByZWNhdGVkIG1ldGhvZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IGtleXBhaXIgZm9yIHRoaXMgY29pbi5cbiAgICogQHBhcmFtIHNlZWQgU2VlZCBmcm9tIHdoaWNoIHRoZSBuZXcga2V5cGFpciBzaG91bGQgYmUgZ2VuZXJhdGVkLCBvdGhlcndpc2UgYSByYW5kb20gc2VlZCBpcyB1c2VkXG4gICAqL1xuICBwdWJsaWMgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBpZiAoIXNlZWQpIHtcbiAgICAgIC8vIEFuIGV4dGVuZGVkIHByaXZhdGUga2V5IGhhcyBib3RoIGEgbm9ybWFsIDI1NiBiaXQgcHJpdmF0ZSBrZXkgYW5kIGEgMjU2XG4gICAgICAvLyBiaXQgY2hhaW4gY29kZSwgYm90aCBvZiB3aGljaCBtdXN0IGJlIHJhbmRvbS4gNTEyIGJpdHMgaXMgdGhlcmVmb3JlIHRoZVxuICAgICAgLy8gbWF4aW11bSBlbnRyb3B5IGFuZCBnaXZlcyB1cyBtYXhpbXVtIHNlY3VyaXR5IGFnYWluc3QgY3JhY2tpbmcuXG4gICAgICBzZWVkID0gcmFuZG9tQnl0ZXMoNTEyIC8gOCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuZGVkS2V5ID0gYmlwMzIuZnJvbVNlZWQoc2VlZCk7XG4gICAgY29uc3QgeHB1YiA9IGV4dGVuZGVkS2V5Lm5ldXRlcmVkKCkudG9CYXNlNTgoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiB4cHViLFxuICAgICAgcHJ2OiBleHRlbmRlZEtleS50b0Jhc2U1OCgpLFxuICAgIH07XG4gIH1cblxuICBhc3luYyBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG4iXX0=