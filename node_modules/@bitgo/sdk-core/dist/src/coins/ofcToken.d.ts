/**
 * @prettier
 */
import { OfcTokenConfig } from '@bitgo/statics';
import { BitGoBase, CoinConstructor, SignTransactionOptions as BaseSignTransactionOptions, SignedTransaction } from '../';
import { Ofc } from './ofc';
export interface SignTransactionOptions extends BaseSignTransactionOptions {
    txPrebuild: {
        payload: string;
    };
    prv: string;
}
export { OfcTokenConfig };
export declare class OfcToken extends Ofc {
    readonly tokenConfig: OfcTokenConfig;
    constructor(bitgo: BitGoBase, tokenConfig: OfcTokenConfig);
    get coin(): string;
    get decimalPlaces(): number;
    get name(): string;
    get backingCoin(): string;
    get isFiat(): boolean;
    getChain(): string;
    getFullName(): string;
    getBaseFactor(): string;
    get type(): string;
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed(): boolean;
    static createTokenConstructor(config: OfcTokenConfig): CoinConstructor;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * @returns {Promise<SignedTransaction>}
     */
    signTransaction(params: SignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Check if an address is valid for this ofc token.
     *
     * These addresses are either bg-<publicid>, where public id is the internal address to send to,
     * or are an address which is valid on the backing coin of this ofc token.
     * @param address address to check for validity
     */
    isValidAddress(address?: string): boolean;
}
//# sourceMappingURL=ofcToken.d.ts.map