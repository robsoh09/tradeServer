"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const paillierBigint = __importStar(require("paillier-bigint"));
const bigintCryptoUtils = __importStar(require("bigint-crypto-utils"));
const secp = __importStar(require("@noble/secp256k1"));
const crypto_1 = require("crypto");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const util_1 = require("../../util");
const curves_1 = require("../../curves");
const sdk_lib_mpc_1 = require("@bitgo/sdk-lib-mpc");
const _5n = BigInt(5);
// Size of alpha and mu shares in bytes expected by the implementation of the protocol
const ALPHAMUSIZE = 768;
/**
 * ECDSA TSS implementation supporting 2:n Threshold
 */
class Ecdsa {
    /**
     * Generate shares for participant at index and split keys `(threshold,numShares)` ways.
     * @param {number} index participant index
     * @param {number} threshold Signing threshold
     * @param {number} numShares  Number of shares
     * @param {Buffer} seed optional 64 byte seed to use for key generation
     * @param sync optional sync flag, if true then a synchronous version of Paillier key generation is used that does not spawn Worker threads.
     * @returns {Promise<KeyShare>} Returns the private p-share
     * and n-shares to be distributed to participants at their corresponding index.
     */
    async keyShare(index, threshold, numShares, seed, sync = false) {
        var _a, _b;
        if (!(index > 0 && index <= numShares && threshold <= numShares && threshold === 2)) {
            throw 'Invalid KeyShare Config';
        }
        if (seed && seed.length < 64) {
            throw new Error('Seed must have a length of at least 64 bytes');
        }
        let seedWithValidLength = seed;
        if (seed && seed.length > 64) {
            // if seed length is greater than 64 bytes, hash seed to 64 bytes.
            seedWithValidLength = (0, crypto_1.createHash)('sha512').update(seed).digest();
        }
        // Generate additively homomorphic encryption key.
        let paillierKeyPair;
        if (!sync) {
            paillierKeyPair = await paillierBigint.generateRandomKeys(sdk_lib_mpc_1.minModulusBitLength, true);
        }
        else {
            // eslint-disable-next-line no-sync
            paillierKeyPair = paillierBigint.generateRandomKeysSync(sdk_lib_mpc_1.minModulusBitLength, true);
        }
        const { publicKey, privateKey } = paillierKeyPair;
        // Accept a 64 byte seed and create an extended private key from that seed
        const secretKey = seedWithValidLength && utxo_lib_1.bip32.fromSeed(seedWithValidLength);
        const u = (_a = (secretKey && secretKey.privateKey && (0, util_1.bigIntFromU8ABE)(new Uint8Array(secretKey.privateKey)))) !== null && _a !== void 0 ? _a : Ecdsa.curve.scalarRandom();
        const y = Ecdsa.curve.basePointMult(u);
        const chaincode = (_b = (secretKey && secretKey.chainCode)) !== null && _b !== void 0 ? _b : (0, crypto_1.randomBytes)(32);
        // Compute secret shares of the private key
        const { shares: uShares, v } = Ecdsa.shamir.split(u, threshold, numShares);
        const currentParticipant = {
            i: index,
            t: threshold,
            c: numShares,
            l: (0, util_1.bigIntToBufferBE)(privateKey.lambda, 192).toString('hex'),
            m: (0, util_1.bigIntToBufferBE)(privateKey.mu, 192).toString('hex'),
            n: (0, util_1.bigIntToBufferBE)(publicKey.n, 384).toString('hex'),
            y: (0, util_1.bigIntToBufferBE)(y, 33).toString('hex'),
            u: (0, util_1.bigIntToBufferBE)(uShares[index], 32).toString('hex'),
            uu: u.toString(),
            chaincode: chaincode.toString('hex'),
        };
        const keyShare = {
            pShare: currentParticipant,
            nShares: {},
        };
        for (const share in uShares) {
            const participantIndex = parseInt(share, 10);
            if (participantIndex !== index) {
                keyShare.nShares[participantIndex] = {
                    i: participantIndex,
                    j: currentParticipant['i'],
                    n: publicKey.n.toString(16),
                    y: (0, util_1.bigIntToBufferBE)(y, 33).toString('hex'),
                    v: (0, util_1.bigIntToBufferBE)(v[0], 33).toString('hex'),
                    u: (0, util_1.bigIntToBufferBE)(uShares[participantIndex], 32).toString('hex'),
                    chaincode: chaincode.toString('hex'),
                };
            }
        }
        return keyShare;
    }
    /**
     * Combine data shared during the key generation protocol.
     * @param {KeyShare} participantShares private p-share and
     * n-shares received from all other participants.
     * @returns {KeyCombined} Returns the participant private x-share
     * and y-shares to be used when generating signing shares.
     */
    keyCombine(pShare, nShares) {
        const allShares = [pShare, ...nShares];
        // Compute the public key.
        const y = allShares.map((participant) => (0, sdk_lib_mpc_1.hexToBigInt)(participant['y'])).reduce(Ecdsa.curve.pointAdd);
        // Add secret shares
        const x = allShares.map((participant) => (0, sdk_lib_mpc_1.hexToBigInt)(participant['u'])).reduce(Ecdsa.curve.scalarAdd);
        // Verify shares.
        for (const share of nShares) {
            if (share.v) {
                try {
                    Ecdsa.shamir.verify((0, sdk_lib_mpc_1.hexToBigInt)(share.u), [(0, sdk_lib_mpc_1.hexToBigInt)(share.y), (0, sdk_lib_mpc_1.hexToBigInt)(share.v)], pShare.i);
                }
                catch (err) {
                    throw new Error(`Could not verify share from participant ${share.j}. Verification error: ${err}`);
                }
            }
        }
        // Generate Schnorr proof of knowledge of the discrete log of X = xG.
        const X = Ecdsa.curve.basePointMult(x);
        const proofContext = (0, crypto_1.createHash)('sha256').update((0, util_1.bigIntToBufferBE)(y, Ecdsa.curve.pointBytes)).digest();
        const schnorrProofX = sdk_lib_mpc_1.Schnorr.createSchnorrProof(X, x, Ecdsa.curve, proofContext);
        // Chaincode will be used in future when we add support for key derivation for ecdsa
        const chaincodes = [pShare, ...nShares].map(({ chaincode }) => (0, util_1.bigIntFromBufferBE)(Buffer.from(chaincode, 'hex')));
        const chaincode = chaincodes.reduce((acc, chaincode) => (acc + chaincode) % BigInt('0x010000000000000000000000000000000000000000000000000000000000000000') // 2^256
        );
        const participants = {
            xShare: {
                i: pShare.i,
                l: pShare.l,
                m: pShare.m,
                n: pShare.n,
                y: (0, util_1.bigIntToBufferBE)(y, 33).toString('hex'),
                x: (0, util_1.bigIntToBufferBE)(x, 32).toString('hex'),
                schnorrProofX: schnorrProofX,
                chaincode: (0, util_1.bigIntToBufferBE)(chaincode, 32).toString('hex'),
            },
            yShares: {},
        };
        for (const share in nShares) {
            const participantIndex = nShares[share]['j'];
            participants.yShares[participantIndex] = {
                i: pShare.i,
                j: nShares[share]['j'],
                n: nShares[share]['n'],
            };
        }
        return participants;
    }
    /**
     * Derive shares for a BIP-32 subkey.
     * @param {PShare} The user's p-share.
     * @param {NShare[]} The n-shares received from the other participants.
     * @param {string} The BIP-32 path to derive.
     * @returns {SubkeyShare} Returns the private x-share and n-shares to
     * be distributed to participants at their corresponding index.
     */
    keyDerive(pShare, nShares, path) {
        const yValues = [pShare, ...nShares].map((share) => (0, sdk_lib_mpc_1.hexToBigInt)(share.y));
        const y = yValues.reduce((partial, share) => Ecdsa.curve.pointAdd(partial, share));
        const u = BigInt(pShare.uu);
        let contribChaincode = (0, sdk_lib_mpc_1.hexToBigInt)(pShare.chaincode);
        const chaincodes = [contribChaincode, ...nShares.map(({ chaincode }) => (0, sdk_lib_mpc_1.hexToBigInt)(chaincode))];
        const chaincode = chaincodes.reduce((acc, chaincode) => (acc + chaincode) % sdk_lib_mpc_1.chaincodeBase);
        // Verify shares.
        for (const share of nShares) {
            if (share.v) {
                try {
                    Ecdsa.shamir.verify((0, sdk_lib_mpc_1.hexToBigInt)(share.u), [(0, sdk_lib_mpc_1.hexToBigInt)(share.y), (0, sdk_lib_mpc_1.hexToBigInt)(share.v)], pShare.i);
                }
                catch (err) {
                    throw new Error(`Could not verify share from participant ${share.j}. Verification error: ${err}`);
                }
            }
        }
        // Derive subkey.
        const subkey = Ecdsa.hdTree.privateDerive({ pk: y, sk: u, chaincode }, path);
        // Calculate new public key contribution.
        const contribY = Ecdsa.curve.basePointMult(subkey.sk);
        // Calculate new chaincode contribution.
        const chaincodeDelta = (sdk_lib_mpc_1.chaincodeBase + subkey.chaincode - chaincode) % sdk_lib_mpc_1.chaincodeBase;
        contribChaincode = (contribChaincode + chaincodeDelta) % sdk_lib_mpc_1.chaincodeBase;
        // Calculate new u values.
        const { shares: split_u, v } = Ecdsa.shamir.split(subkey.sk, pShare.t || 2, pShare.c || 3);
        // Calculate new signing key.
        const x = [split_u[pShare.i], ...nShares.map(({ u }) => (0, sdk_lib_mpc_1.hexToBigInt)(u))].reduce(Ecdsa.curve.scalarAdd);
        // Generate Schnorr proof of knowledge of the discrete log of X = xG.
        const X = Ecdsa.curve.basePointMult(x);
        const proofContext = (0, crypto_1.createHash)('sha256').update((0, util_1.bigIntToBufferBE)(subkey.pk, Ecdsa.curve.pointBytes)).digest();
        const schnorrProofX = sdk_lib_mpc_1.Schnorr.createSchnorrProof(X, x, Ecdsa.curve, proofContext);
        const P_i = {
            i: pShare.i,
            l: pShare.l,
            m: pShare.m,
            n: pShare.n,
            y: (0, util_1.bigIntToBufferBE)(subkey.pk, 33).toString('hex'),
            x: (0, util_1.bigIntToBufferBE)(x, 32).toString('hex'),
            schnorrProofX: schnorrProofX,
            chaincode: (0, util_1.bigIntToBufferBE)(subkey.chaincode, 32).toString('hex'),
        };
        const shares = {
            xShare: P_i,
            nShares: {},
        };
        for (let ind = 0; ind < nShares.length; ind++) {
            const P_j = nShares[ind];
            shares.nShares[P_j.j] = {
                i: P_j.j,
                j: P_i.i,
                n: P_i.n,
                u: (0, util_1.bigIntToBufferBE)(split_u[P_j.j], 32).toString('hex'),
                y: (0, util_1.bigIntToBufferBE)(contribY, 32).toString('hex'),
                v: (0, util_1.bigIntToBufferBE)(v[0], 32).toString('hex'),
                chaincode: (0, util_1.bigIntToBufferBE)(contribChaincode, 32).toString('hex'),
            };
        }
        return shares;
    }
    /**
     * Verify Schnorr proof of knowledge of the discrete log of X_i = x_i * G.
     * @param Y The combined public key.
     * @param VSSs The VSS shares received from all participants.
     * @param index The i of X_i.
     * @param proof The schnorr proof.
     * @returns True if it's a valid proof with regards to Y and VSSs.
     */
    verifySchnorrProofX(Y, VSSs, index, proof) {
        if (index < 1 || index > VSSs.length) {
            throw new Error('Invalid value supplied for index');
        }
        // Calculate X_i from public information.
        let X_i = Y;
        VSSs.forEach((VSS) => {
            VSS.forEach((v) => {
                X_i = Ecdsa.curve.pointAdd(X_i, Ecdsa.curve.pointMultiply(v, BigInt(index)));
            });
        });
        const proofContext = (0, crypto_1.createHash)('sha256').update((0, util_1.bigIntToBufferBE)(Y, Ecdsa.curve.pointBytes)).digest();
        return sdk_lib_mpc_1.Schnorr.verifySchnorrProof(X_i, proof, Ecdsa.curve, proofContext);
    }
    /**
     * Derives a child common keychain from common keychain
     *
     * @param {commonKeychain} The common keychain as a hex string.
     * @param {path} The BIP-32 path to derive.
     * @return {string} The derived common keychain as a hex string.
     */
    deriveUnhardened(commonKeychain, path) {
        if (Ecdsa.hdTree === undefined) {
            throw new Error("Can't derive key without HDTree implementation");
        }
        const keychain = Buffer.from(commonKeychain, 'hex');
        const derivedPublicKeychain = Ecdsa.hdTree.publicDerive({
            pk: (0, util_1.bigIntFromBufferBE)(keychain.slice(0, 33)),
            chaincode: (0, util_1.bigIntFromBufferBE)(keychain.slice(33)),
        }, path);
        const derivedPk = (0, util_1.bigIntToBufferBE)(derivedPublicKeychain.pk, 33).toString('hex');
        const derivedChaincode = (0, util_1.bigIntToBufferBE)(derivedPublicKeychain.chaincode, 32).toString('hex');
        return derivedPk + derivedChaincode;
    }
    /**
     * Appends a given range proof challenge to the shares previously created
     * by #keyCombine. Generates a new challenge if not provided.
     * @param {XShare | YShare} share Private xShare or yShare of the signing operation
     * @param rangeProofChallenge - challenge generated via generateNtilde
     * @param paillierProofChallenge
     * @returns {KeyCombined} The share with amended challenge values
     */
    appendChallenge(share, rangeProofChallenge, paillierProofChallenge) {
        const { ntilde, h1, h2 } = rangeProofChallenge;
        return {
            ...share,
            ntilde,
            h1,
            h2,
            p: paillierProofChallenge.p,
        };
    }
    /**
     * Create signing shares.
     * @param {xShare} xShare Private xShare of current participant signer
     * @param {YShare} yShare yShare corresponding to the other participant signer
     * @returns {SignShareRT} Returns the participant private w-share
     * and k-share to be distributed to other participant signer
     */
    async signShare(xShare, yShare) {
        const pk = (0, util_1.getPaillierPublicKey)((0, sdk_lib_mpc_1.hexToBigInt)(xShare.n));
        const k = Ecdsa.curve.scalarRandom();
        const rk = await (0, sdk_lib_mpc_1.randomPositiveCoPrimeTo)(pk.n);
        const ck = pk.encrypt(k, rk);
        const gamma = Ecdsa.curve.scalarRandom();
        const d = Ecdsa.curve.scalarMult(Ecdsa.curve.scalarSub(BigInt(yShare.j), BigInt(xShare.i)), BigInt(xShare.i));
        const w = [
            Ecdsa.curve.scalarMult(BigInt(yShare.j), BigInt(xShare.i)),
            (0, sdk_lib_mpc_1.hexToBigInt)(xShare['x']),
            Ecdsa.curve.scalarInvert(d),
        ].reduce(Ecdsa.curve.scalarMult);
        const { ntilde: ntildea, h1: h1a, h2: h2a } = xShare;
        const wShare = {
            i: xShare.i,
            l: xShare.l,
            m: xShare.m,
            n: xShare.n,
            y: xShare.y,
            ntilde: ntildea,
            h1: h1a,
            h2: h2a,
            p: xShare.p,
            k: (0, util_1.bigIntToBufferBE)(k, 32).toString('hex'),
            ck: (0, util_1.bigIntToBufferBE)(ck, 768).toString('hex'),
            w: (0, util_1.bigIntToBufferBE)(w, 32).toString('hex'),
            gamma: (0, util_1.bigIntToBufferBE)(gamma, 32).toString('hex'),
        };
        const { ntilde: ntildeb, h1: h1b, h2: h2b } = yShare;
        const proof = await sdk_lib_mpc_1.EcdsaRangeProof.prove(Ecdsa.curve, sdk_lib_mpc_1.minModulusBitLength, pk, {
            ntilde: (0, sdk_lib_mpc_1.hexToBigInt)(ntildeb),
            h1: (0, sdk_lib_mpc_1.hexToBigInt)(h1b),
            h2: (0, sdk_lib_mpc_1.hexToBigInt)(h2b),
        }, ck, k, rk);
        // create paillier challenge proof based on the other signers challenge
        // only send sigma if we also send challenge p
        const sigma = sdk_lib_mpc_1.EcdsaPaillierProof.prove((0, sdk_lib_mpc_1.hexToBigInt)(xShare.n), (0, sdk_lib_mpc_1.hexToBigInt)(xShare.l), sdk_lib_mpc_1.EcdsaTypes.deserializePaillierChallenge({ p: yShare.p }).p);
        const proofShare = {
            z: (0, util_1.bigIntToBufferBE)(proof.z, 384).toString('hex'),
            u: (0, util_1.bigIntToBufferBE)(proof.u, 768).toString('hex'),
            w: (0, util_1.bigIntToBufferBE)(proof.w, 384).toString('hex'),
            s: (0, util_1.bigIntToBufferBE)(proof.s, 384).toString('hex'),
            s1: (0, util_1.bigIntToBufferBE)(proof.s1, 96).toString('hex'),
            s2: (0, util_1.bigIntToBufferBE)(proof.s2, 480).toString('hex'),
        };
        const kShare = {
            // this share will be sent to the other participant,
            // so we need to swap the i and j values here
            // so that they know it's their kShare, produced by us
            i: yShare.j,
            j: xShare.i,
            n: pk.n.toString(16),
            ntilde: ntildea,
            h1: h1a,
            h2: h2a,
            p: xShare.p,
            k: (0, util_1.bigIntToBufferBE)(ck, 768).toString('hex'),
            sigma: sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallengeProofs({ sigma: sigma }).sigma,
            proof: proofShare,
        };
        return {
            wShare,
            kShare,
        };
    }
    /**
     * Perform multiplicitive-to-additive (MtA) share conversion with another signer.
     * Connection 1.2 in https://lucid.app/lucidchart/7061785b-bc5c-4002-b546-3f4a3612fc62/edit?page=IAVmvYO4FvKc#
     * If signer A completed signShare initially (input to this fn), then this step is completed by signer B.
     * @param {SignConvert} shares
     * @returns {SignConvertRT}
     */
    async signConvertStep1(shares) {
        const receivedKShare = shares.kShare;
        const xShare = shares.xShare; // currentParticipant secret xShare
        const yShare = {
            ...shares.yShare,
            ntilde: receivedKShare.ntilde,
            h1: receivedKShare.h1,
            h2: receivedKShare.h2,
            p: receivedKShare.p,
        };
        const signShare = await this.signShare(xShare, yShare);
        const shareParticipant = signShare.wShare;
        if (shareParticipant.i !== receivedKShare.i) {
            throw new Error('Shares from same participant');
        }
        if (!receivedKShare.proof) {
            throw new Error('Unexpected missing proof on aShareToBeSent');
        }
        // the other participants paillier public key
        const n = (0, sdk_lib_mpc_1.hexToBigInt)(receivedKShare.n);
        const pka = (0, util_1.getPaillierPublicKey)(n);
        // the other participant's range proof challenge
        const ntildea = (0, sdk_lib_mpc_1.hexToBigInt)(receivedKShare.ntilde);
        const h1a = (0, sdk_lib_mpc_1.hexToBigInt)(receivedKShare.h1);
        const h2a = (0, sdk_lib_mpc_1.hexToBigInt)(receivedKShare.h2);
        // the current participant's range proof challenge
        const ntildeb = (0, sdk_lib_mpc_1.hexToBigInt)(shareParticipant.ntilde);
        const h1b = (0, sdk_lib_mpc_1.hexToBigInt)(shareParticipant.h1);
        const h2b = (0, sdk_lib_mpc_1.hexToBigInt)(shareParticipant.h2);
        const k = (0, sdk_lib_mpc_1.hexToBigInt)(receivedKShare.k);
        // the current participants paillier proof challenge
        const shareParticipantPaillierChallenge = sdk_lib_mpc_1.EcdsaTypes.deserializePaillierChallenge({ p: shareParticipant.p });
        // the other signing parties proof to the current participants paillier proof challenge
        const receivedPaillierChallengeProof = sdk_lib_mpc_1.EcdsaTypes.deserializePaillierChallengeProofs({
            sigma: receivedKShare.sigma,
        });
        if (!(await sdk_lib_mpc_1.EcdsaPaillierProof.verify(n, shareParticipantPaillierChallenge.p, receivedPaillierChallengeProof.sigma))) {
            throw new Error('Could not verify signing A share paillier proof');
        }
        if (!sdk_lib_mpc_1.EcdsaRangeProof.verify(Ecdsa.curve, sdk_lib_mpc_1.minModulusBitLength, pka, {
            ntilde: ntildeb,
            h1: h1b,
            h2: h2b,
        }, {
            z: (0, sdk_lib_mpc_1.hexToBigInt)(receivedKShare.proof.z),
            u: (0, sdk_lib_mpc_1.hexToBigInt)(receivedKShare.proof.u),
            w: (0, sdk_lib_mpc_1.hexToBigInt)(receivedKShare.proof.w),
            s: (0, sdk_lib_mpc_1.hexToBigInt)(receivedKShare.proof.s),
            s1: (0, sdk_lib_mpc_1.hexToBigInt)(receivedKShare.proof.s1),
            s2: (0, sdk_lib_mpc_1.hexToBigInt)(receivedKShare.proof.s2),
        }, k)) {
            throw new Error('Could not verify signing A share proof');
        }
        // MtA $k_j, \gamma_i$.
        const beta0 = bigintCryptoUtils.randBetween(Ecdsa.curve.order() ** _5n);
        const beta = (0, util_1.bigIntToBufferBE)(Ecdsa.curve.scalarNegate(Ecdsa.curve.scalarReduce(beta0)), 32).toString('hex');
        const g = (0, sdk_lib_mpc_1.hexToBigInt)(shareParticipant.gamma);
        const rb = await (0, sdk_lib_mpc_1.randomPositiveCoPrimeTo)(pka.n);
        const cb = pka.encrypt(beta0, rb);
        const alpha = pka.addition(pka.multiply(k, g), cb);
        const alphaToBeSent = (0, util_1.bigIntToBufferBE)(alpha, ALPHAMUSIZE).toString('hex');
        // Prove $\gamma_i \in Z_{N^2}$.
        const gx = Ecdsa.curve.basePointMult(g);
        let proof = await sdk_lib_mpc_1.EcdsaRangeProof.proveWithCheck(Ecdsa.curve, sdk_lib_mpc_1.minModulusBitLength, pka, {
            ntilde: ntildea,
            h1: h1a,
            h2: h2a,
        }, k, alpha, g, beta0, rb, gx);
        const gammaProofToBeSent = {
            z: (0, util_1.bigIntToBufferBE)(proof.z, 384).toString('hex'),
            zprm: (0, util_1.bigIntToBufferBE)(proof.zprm, 384).toString('hex'),
            t: (0, util_1.bigIntToBufferBE)(proof.t, 384).toString('hex'),
            v: (0, util_1.bigIntToBufferBE)(proof.v, 768).toString('hex'),
            w: (0, util_1.bigIntToBufferBE)(proof.w, 384).toString('hex'),
            s: (0, util_1.bigIntToBufferBE)(proof.s, 384).toString('hex'),
            s1: (0, util_1.bigIntToBufferBE)(proof.s1, 96).toString('hex'),
            s2: (0, util_1.bigIntToBufferBE)(proof.s2, 480).toString('hex'),
            t1: (0, util_1.bigIntToBufferBE)(proof.t1, 224).toString('hex'),
            t2: (0, util_1.bigIntToBufferBE)(proof.t2, 480).toString('hex'),
            u: (0, util_1.bigIntToBufferBE)(proof.u, 33).toString('hex'),
            x: (0, util_1.bigIntToBufferBE)(gx, 33).toString('hex'),
        };
        // MtA $k_j, w_i$.
        const nu0 = bigintCryptoUtils.randBetween(Ecdsa.curve.order() ** _5n);
        const nu = (0, util_1.bigIntToBufferBE)(Ecdsa.curve.scalarNegate(Ecdsa.curve.scalarReduce(nu0)), 32).toString('hex');
        const w = (0, sdk_lib_mpc_1.hexToBigInt)(shareParticipant.w);
        const rn = await (0, sdk_lib_mpc_1.randomPositiveCoPrimeTo)(pka.n);
        const cn = pka.encrypt(nu0, rn);
        const mu = pka.addition(pka.multiply(k, w), cn);
        const muToBeSent = (0, util_1.bigIntToBufferBE)(mu, ALPHAMUSIZE).toString('hex');
        // Prove $\w_i \in Z_{N^2}$.
        const wx = Ecdsa.curve.basePointMult(w);
        proof = await sdk_lib_mpc_1.EcdsaRangeProof.proveWithCheck(Ecdsa.curve, sdk_lib_mpc_1.minModulusBitLength, pka, {
            ntilde: ntildea,
            h1: h1a,
            h2: h2a,
        }, k, (0, sdk_lib_mpc_1.hexToBigInt)(muToBeSent), w, nu0, rn, wx);
        const wProofToBeSent = {
            z: (0, util_1.bigIntToBufferBE)(proof.z, 384).toString('hex'),
            zprm: (0, util_1.bigIntToBufferBE)(proof.zprm, 384).toString('hex'),
            t: (0, util_1.bigIntToBufferBE)(proof.t, 384).toString('hex'),
            v: (0, util_1.bigIntToBufferBE)(proof.v, 768).toString('hex'),
            w: (0, util_1.bigIntToBufferBE)(proof.w, 384).toString('hex'),
            s: (0, util_1.bigIntToBufferBE)(proof.s, 384).toString('hex'),
            s1: (0, util_1.bigIntToBufferBE)(proof.s1, 96).toString('hex'),
            s2: (0, util_1.bigIntToBufferBE)(proof.s2, 480).toString('hex'),
            t1: (0, util_1.bigIntToBufferBE)(proof.t1, 224).toString('hex'),
            t2: (0, util_1.bigIntToBufferBE)(proof.t2, 480).toString('hex'),
            u: (0, util_1.bigIntToBufferBE)(proof.u, 33).toString('hex'),
            x: (0, util_1.bigIntToBufferBE)(wx, 33).toString('hex'),
        };
        const nToBeSent = signShare.kShare.n;
        const ntildeToBeSent = (0, util_1.bigIntToBufferBE)(ntildeb, 384).toString('hex');
        const h1ToBeSent = (0, util_1.bigIntToBufferBE)(h1b, 384).toString('hex');
        const h2ToBeSent = (0, util_1.bigIntToBufferBE)(h2b, 384).toString('hex');
        const kToBeSent = signShare.kShare.k;
        const proofToBeSent = signShare.kShare.proof;
        const [iToBeSent, jToBeSent] = [receivedKShare.j, receivedKShare.i];
        return {
            aShare: {
                i: iToBeSent,
                j: jToBeSent,
                ntilde: ntildeToBeSent,
                h1: h1ToBeSent,
                h2: h2ToBeSent,
                n: nToBeSent,
                k: kToBeSent,
                alpha: alphaToBeSent,
                mu: muToBeSent,
                proof: proofToBeSent,
                gammaProof: gammaProofToBeSent,
                wProof: wProofToBeSent,
                // provide the share participants proof
                // to the paillier challenge in the receivedKShare from the other signer
                sigma: signShare.kShare.sigma,
            },
            bShare: {
                ...shareParticipant,
                beta,
                nu,
            },
        };
    }
    /**
     * Perform multiplicitive-to-additive (MtA) share conversion with another
     * signer.
     * Connection 2.1 in https://lucid.app/lucidchart/7061785b-bc5c-4002-b546-3f4a3612fc62/edit?page=IAVmvYO4FvKc#
     * If signer B completed signConvertStep1, then this step is completed by signer A.
     * @param {SignConvert} shares
     * @returns {SignConvertRT}
     */
    async signConvertStep2(shares) {
        const receivedAShare = shares.aShare;
        if (!receivedAShare.gammaProof) {
            throw new Error('Unexpected missing gammaProof on aShareToBeSent');
        }
        if (!receivedAShare.wProof) {
            throw new Error('Unexpected missing wProof on aShareToBeSent');
        }
        const n = (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.n); // Paillier pub from other signer
        // current participant public key
        const pka = (0, util_1.getPaillierPublicKey)((0, sdk_lib_mpc_1.hexToBigInt)(shares.wShare.n));
        const ntildea = (0, sdk_lib_mpc_1.hexToBigInt)(shares.wShare.ntilde);
        const h1a = (0, sdk_lib_mpc_1.hexToBigInt)(shares.wShare.h1);
        const h2a = (0, sdk_lib_mpc_1.hexToBigInt)(shares.wShare.h2);
        const ck = (0, sdk_lib_mpc_1.hexToBigInt)(shares.wShare.ck);
        const shareParticipantPaillierChallenge = sdk_lib_mpc_1.EcdsaTypes.deserializePaillierChallenge({ p: shares.wShare.p });
        const receivedPaillierChallengeProof = sdk_lib_mpc_1.EcdsaTypes.deserializePaillierChallengeProofs({
            sigma: shares.aShare.sigma,
        });
        if (!sdk_lib_mpc_1.EcdsaPaillierProof.verify(n, shareParticipantPaillierChallenge.p, receivedPaillierChallengeProof.sigma)) {
            throw new Error('could not verify signing share for paillier proof');
        }
        // Verify $\gamma_i \in Z_{N^2}$.
        if (!sdk_lib_mpc_1.EcdsaRangeProof.verifyWithCheck(Ecdsa.curve, sdk_lib_mpc_1.minModulusBitLength, pka, {
            ntilde: ntildea,
            h1: h1a,
            h2: h2a,
        }, {
            z: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.gammaProof.z),
            zprm: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.gammaProof.zprm),
            t: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.gammaProof.t),
            v: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.gammaProof.v),
            w: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.gammaProof.w),
            s: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.gammaProof.s),
            s1: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.gammaProof.s1),
            s2: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.gammaProof.s2),
            t1: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.gammaProof.t1),
            t2: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.gammaProof.t2),
            u: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.gammaProof.u),
        }, ck, (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.alpha), (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.gammaProof.x))) {
            throw new Error('could not verify signing share for gamma proof');
        }
        // Verify $\w_i \in Z_{N^2}$.
        if (!sdk_lib_mpc_1.EcdsaRangeProof.verifyWithCheck(Ecdsa.curve, sdk_lib_mpc_1.minModulusBitLength, pka, {
            ntilde: ntildea,
            h1: h1a,
            h2: h2a,
        }, {
            z: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.wProof.z),
            zprm: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.wProof.zprm),
            t: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.wProof.t),
            v: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.wProof.v),
            w: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.wProof.w),
            s: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.wProof.s),
            s1: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.wProof.s1),
            s2: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.wProof.s2),
            t1: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.wProof.t1),
            t2: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.wProof.t2),
            u: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.wProof.u),
        }, ck, (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.mu), (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.wProof.x))) {
            throw new Error('could not verify share for wProof');
        }
        const sk = new paillierBigint.PrivateKey((0, sdk_lib_mpc_1.hexToBigInt)(shares.wShare.l), (0, sdk_lib_mpc_1.hexToBigInt)(shares.wShare.m), pka);
        const gShareAlpha = (0, util_1.bigIntToBufferBE)(Ecdsa.curve.scalarReduce(sk.decrypt((0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.alpha))), 32).toString('hex');
        const gShareMu = (0, util_1.bigIntToBufferBE)(Ecdsa.curve.scalarReduce(sk.decrypt((0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.mu))), // recheck encrypted number
        32).toString('hex');
        if (!receivedAShare.proof) {
            throw new Error('Unexpected missing proof on aShareToBeSent');
        }
        const pkb = (0, util_1.getPaillierPublicKey)(n);
        const ntildeb = (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.ntilde);
        const h1b = (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.h1);
        const h2b = (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.h2);
        const k = (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.k);
        if (!sdk_lib_mpc_1.EcdsaRangeProof.verify(Ecdsa.curve, sdk_lib_mpc_1.minModulusBitLength, pkb, {
            ntilde: ntildea,
            h1: h1a,
            h2: h2a,
        }, {
            z: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.proof.z),
            u: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.proof.u),
            w: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.proof.w),
            s: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.proof.s),
            s1: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.proof.s1),
            s2: (0, sdk_lib_mpc_1.hexToBigInt)(receivedAShare.proof.s2),
        }, k)) {
            throw new Error('Could not verify signing A share proof');
        }
        // MtA $k_j, \gamma_i$.
        const beta0 = bigintCryptoUtils.randBetween(Ecdsa.curve.order() ** _5n);
        const gShareBeta = (0, util_1.bigIntToBufferBE)(Ecdsa.curve.scalarNegate(Ecdsa.curve.scalarReduce(beta0)), 32).toString('hex');
        const g = (0, sdk_lib_mpc_1.hexToBigInt)(shares.wShare.gamma);
        const rb = await (0, sdk_lib_mpc_1.randomPositiveCoPrimeTo)(pkb.n);
        const cb = pkb.encrypt(beta0, rb);
        const alpha = pkb.addition(pkb.multiply(k, g), cb);
        const alphaToBeSent = (0, util_1.bigIntToBufferBE)(alpha, ALPHAMUSIZE).toString('hex');
        // Prove $\gamma_i \in Z_{N^2}$.
        const gx = Ecdsa.curve.basePointMult(g);
        let proof = await sdk_lib_mpc_1.EcdsaRangeProof.proveWithCheck(Ecdsa.curve, sdk_lib_mpc_1.minModulusBitLength, pkb, {
            ntilde: ntildeb,
            h1: h1b,
            h2: h2b,
        }, k, alpha, g, beta0, rb, gx);
        const gammaProofToBeSent = {
            z: (0, util_1.bigIntToBufferBE)(proof.z, 384).toString('hex'),
            zprm: (0, util_1.bigIntToBufferBE)(proof.zprm, 384).toString('hex'),
            t: (0, util_1.bigIntToBufferBE)(proof.t, 384).toString('hex'),
            v: (0, util_1.bigIntToBufferBE)(proof.v, 768).toString('hex'),
            w: (0, util_1.bigIntToBufferBE)(proof.w, 384).toString('hex'),
            s: (0, util_1.bigIntToBufferBE)(proof.s, 384).toString('hex'),
            s1: (0, util_1.bigIntToBufferBE)(proof.s1, 96).toString('hex'),
            s2: (0, util_1.bigIntToBufferBE)(proof.s2, 480).toString('hex'),
            t1: (0, util_1.bigIntToBufferBE)(proof.t1, 224).toString('hex'),
            t2: (0, util_1.bigIntToBufferBE)(proof.t2, 480).toString('hex'),
            u: (0, util_1.bigIntToBufferBE)(proof.u, 33).toString('hex'),
            x: (0, util_1.bigIntToBufferBE)(gx, 33).toString('hex'),
        };
        // MtA $k_j, w_i$.
        const nu0 = bigintCryptoUtils.randBetween(Ecdsa.curve.order() ** _5n);
        const gShareNu = (0, util_1.bigIntToBufferBE)(Ecdsa.curve.scalarNegate(Ecdsa.curve.scalarReduce(nu0)), 32).toString('hex');
        const w = (0, sdk_lib_mpc_1.hexToBigInt)(shares.wShare.w);
        const rn = await (0, sdk_lib_mpc_1.randomPositiveCoPrimeTo)(pkb.n);
        const cn = pkb.encrypt(nu0, rn);
        const mu = pkb.addition(pkb.multiply(k, w), cn);
        const muToBeSent = (0, util_1.bigIntToBufferBE)(mu, ALPHAMUSIZE).toString('hex');
        // Prove $\w_i \in Z_{N^2}$.
        const wx = Ecdsa.curve.basePointMult(w);
        proof = await sdk_lib_mpc_1.EcdsaRangeProof.proveWithCheck(Ecdsa.curve, sdk_lib_mpc_1.minModulusBitLength, pkb, {
            ntilde: ntildeb,
            h1: h1b,
            h2: h2b,
        }, k, (0, sdk_lib_mpc_1.hexToBigInt)(muToBeSent), w, nu0, rn, wx);
        const wProofToBeSent = {
            z: (0, util_1.bigIntToBufferBE)(proof.z, 384).toString('hex'),
            zprm: (0, util_1.bigIntToBufferBE)(proof.zprm, 384).toString('hex'),
            t: (0, util_1.bigIntToBufferBE)(proof.t, 384).toString('hex'),
            v: (0, util_1.bigIntToBufferBE)(proof.v, 768).toString('hex'),
            w: (0, util_1.bigIntToBufferBE)(proof.w, 384).toString('hex'),
            s: (0, util_1.bigIntToBufferBE)(proof.s, 384).toString('hex'),
            s1: (0, util_1.bigIntToBufferBE)(proof.s1, 96).toString('hex'),
            s2: (0, util_1.bigIntToBufferBE)(proof.s2, 480).toString('hex'),
            t1: (0, util_1.bigIntToBufferBE)(proof.t1, 224).toString('hex'),
            t2: (0, util_1.bigIntToBufferBE)(proof.t2, 480).toString('hex'),
            u: (0, util_1.bigIntToBufferBE)(proof.u, 33).toString('hex'),
            x: (0, util_1.bigIntToBufferBE)(wx, 33).toString('hex'),
        };
        const [iToBeSent, jToBeSent] = [receivedAShare.j, receivedAShare.i];
        return {
            muShare: {
                i: iToBeSent,
                j: jToBeSent,
                alpha: alphaToBeSent,
                mu: muToBeSent,
                gammaProof: gammaProofToBeSent,
                wProof: wProofToBeSent,
            },
            gShare: {
                i: shares.wShare.i,
                n: shares.wShare.n,
                y: shares.wShare.y,
                k: shares.wShare.k,
                w: shares.wShare.w,
                gamma: shares.wShare.gamma,
                alpha: gShareAlpha,
                mu: gShareMu,
                beta: gShareBeta,
                nu: gShareNu,
            },
        };
    }
    /**
     * Perform multiplicitive-to-additive (MtA) share conversion with another signer.
     * Connection 2.2 in https://lucid.app/lucidchart/7061785b-bc5c-4002-b546-3f4a3612fc62/edit?page=IAVmvYO4FvKc#
     * If signer A completed signConvertStep2, then this step is completed by signer B.
     * @param {SignConvert} shares
     * @returns {SignConvertRT}
     */
    async signConvertStep3(shares) {
        const receivedMuShare = shares.muShare;
        if (!receivedMuShare.gammaProof) {
            throw new Error('Unexpected missing gammaProof on aShareToBeSent');
        }
        if (!receivedMuShare.wProof) {
            throw new Error('Unexpected missing wProof on aShareToBeSent');
        }
        const pka = (0, util_1.getPaillierPublicKey)((0, sdk_lib_mpc_1.hexToBigInt)(shares.bShare.n));
        const ntildea = (0, sdk_lib_mpc_1.hexToBigInt)(shares.bShare.ntilde);
        const h1a = (0, sdk_lib_mpc_1.hexToBigInt)(shares.bShare.h1);
        const h2a = (0, sdk_lib_mpc_1.hexToBigInt)(shares.bShare.h2);
        const ck = (0, sdk_lib_mpc_1.hexToBigInt)(shares.bShare.ck);
        // Verify $\gamma_i \in Z_{N^2}$.
        if (!sdk_lib_mpc_1.EcdsaRangeProof.verifyWithCheck(Ecdsa.curve, sdk_lib_mpc_1.minModulusBitLength, pka, {
            ntilde: ntildea,
            h1: h1a,
            h2: h2a,
        }, {
            z: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.gammaProof.z),
            zprm: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.gammaProof.zprm),
            t: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.gammaProof.t),
            v: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.gammaProof.v),
            w: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.gammaProof.w),
            s: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.gammaProof.s),
            s1: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.gammaProof.s1),
            s2: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.gammaProof.s2),
            t1: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.gammaProof.t1),
            t2: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.gammaProof.t2),
            u: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.gammaProof.u),
        }, ck, (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.alpha), (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.gammaProof.x))) {
            throw new Error('could not verify signing share for gamma proof');
        }
        // Verify $\w_i \in Z_{N^2}$.
        if (!sdk_lib_mpc_1.EcdsaRangeProof.verifyWithCheck(Ecdsa.curve, sdk_lib_mpc_1.minModulusBitLength, pka, {
            ntilde: ntildea,
            h1: h1a,
            h2: h2a,
        }, {
            z: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.wProof.z),
            zprm: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.wProof.zprm),
            t: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.wProof.t),
            v: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.wProof.v),
            w: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.wProof.w),
            s: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.wProof.s),
            s1: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.wProof.s1),
            s2: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.wProof.s2),
            t1: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.wProof.t1),
            t2: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.wProof.t2),
            u: (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.wProof.u),
        }, ck, (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.mu), (0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.wProof.x))) {
            throw new Error('could not verify share for wProof');
        }
        const sk = new paillierBigint.PrivateKey((0, sdk_lib_mpc_1.hexToBigInt)(shares.bShare.l), (0, sdk_lib_mpc_1.hexToBigInt)(shares.bShare.m), pka);
        const alpha = sk.decrypt((0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.alpha));
        const gShareAlpha = (0, util_1.bigIntToBufferBE)(Ecdsa.curve.scalarReduce(alpha), 32).toString('hex');
        const mu = sk.decrypt((0, sdk_lib_mpc_1.hexToBigInt)(receivedMuShare.mu)); // recheck encrypted number
        const gShareMu = (0, util_1.bigIntToBufferBE)(Ecdsa.curve.scalarReduce(mu), 32).toString('hex');
        const [iToBeSent, jToBeSent] = [receivedMuShare.j, receivedMuShare.i];
        return {
            gShare: {
                i: shares.bShare.i,
                n: shares.bShare.n,
                y: shares.bShare.y,
                k: shares.bShare.k,
                w: shares.bShare.w,
                gamma: shares.bShare.gamma,
                alpha: gShareAlpha,
                mu: gShareMu,
                beta: shares.bShare.beta,
                nu: shares.bShare.nu,
            },
            signIndex: {
                i: iToBeSent,
                j: jToBeSent,
            },
        };
    }
    /**
     * Perform multiplicitive-to-additive (MtA) share conversion with another signer.
     * @deprecated - use one of [signConvertStep1, signConvertStep2, signConvertStep3] instead
     * @param {SignConvert} shares
     * @returns {SignConvertRT}
     */
    async signConvert(shares) {
        let shareParticipant, shareToBeSent;
        let isGammaShare = false;
        let kShare = {};
        if (shares.xShare && shares.yShare && shares.kShare) {
            const xShare = shares.xShare; // currentParticipant secret xShare
            const yShare = {
                ...shares.yShare,
                ntilde: shares.kShare.ntilde,
                h1: shares.kShare.h1,
                h2: shares.kShare.h2,
                p: shares.kShare.p,
            };
            const signShare = await this.signShare(xShare, yShare);
            kShare = signShare.kShare;
            shareToBeSent = { ...shares.kShare };
            shareParticipant = { ...signShare.wShare };
        }
        else if ((shares.bShare && shares.muShare) || (shares.aShare && shares.wShare)) {
            isGammaShare = true;
            shareToBeSent = shares.aShare ? { ...shares.aShare } : { ...shares.muShare };
            shareParticipant = shares.wShare ? { ...shares.wShare } : { ...shares.bShare };
        }
        else {
            throw new Error('Invalid config for Sign Convert');
        }
        if (shareParticipant.i !== shareToBeSent.i) {
            throw new Error('Shares from same participant');
        }
        if (shareToBeSent.alpha) {
            const bShareParticipant = shareParticipant;
            const aShareToBeSent = shareToBeSent;
            if (!aShareToBeSent.gammaProof) {
                throw new Error('Unexpected missing gammaProof on aShareToBeSent');
            }
            if (!aShareToBeSent.wProof) {
                throw new Error('Unexpected missing wProof on aShareToBeSent');
            }
            const pka = (0, util_1.getPaillierPublicKey)((0, sdk_lib_mpc_1.hexToBigInt)(bShareParticipant.n));
            let ntildea, h1a, h2a, ck;
            if (bShareParticipant.ntilde) {
                ntildea = (0, sdk_lib_mpc_1.hexToBigInt)(bShareParticipant.ntilde);
                h1a = (0, sdk_lib_mpc_1.hexToBigInt)(bShareParticipant.h1);
                h2a = (0, sdk_lib_mpc_1.hexToBigInt)(bShareParticipant.h2);
                ck = (0, sdk_lib_mpc_1.hexToBigInt)(bShareParticipant.ck);
            }
            // Verify $\gamma_i \in Z_{N^2}$.
            if (!sdk_lib_mpc_1.EcdsaRangeProof.verifyWithCheck(Ecdsa.curve, sdk_lib_mpc_1.minModulusBitLength, pka, {
                ntilde: ntildea,
                h1: h1a,
                h2: h2a,
            }, {
                z: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.gammaProof.z),
                zprm: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.gammaProof.zprm),
                t: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.gammaProof.t),
                v: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.gammaProof.v),
                w: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.gammaProof.w),
                s: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.gammaProof.s),
                s1: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.gammaProof.s1),
                s2: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.gammaProof.s2),
                t1: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.gammaProof.t1),
                t2: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.gammaProof.t2),
                u: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.gammaProof.u),
            }, ck, (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.alpha), (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.gammaProof.x))) {
                throw new Error('could not verify signing share for gamma proof');
            }
            // Verify $\w_i \in Z_{N^2}$.
            if (!sdk_lib_mpc_1.EcdsaRangeProof.verifyWithCheck(Ecdsa.curve, sdk_lib_mpc_1.minModulusBitLength, pka, {
                ntilde: ntildea,
                h1: h1a,
                h2: h2a,
            }, {
                z: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.wProof.z),
                zprm: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.wProof.zprm),
                t: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.wProof.t),
                v: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.wProof.v),
                w: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.wProof.w),
                s: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.wProof.s),
                s1: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.wProof.s1),
                s2: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.wProof.s2),
                t1: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.wProof.t1),
                t2: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.wProof.t2),
                u: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.wProof.u),
            }, ck, (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.mu), (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.wProof.x))) {
                throw new Error('could not verify share for wProof');
            }
            const sk = new paillierBigint.PrivateKey((0, sdk_lib_mpc_1.hexToBigInt)(bShareParticipant.l), (0, sdk_lib_mpc_1.hexToBigInt)(bShareParticipant.m), pka);
            const gShareParticipant = shareParticipant;
            const muShareToBeSent = shareToBeSent;
            const alpha = sk.decrypt((0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.alpha));
            gShareParticipant.alpha = (0, util_1.bigIntToBufferBE)(Ecdsa.curve.scalarReduce(alpha), 32).toString('hex');
            const mu = sk.decrypt((0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.mu)); // recheck encrypted number
            gShareParticipant.mu = (0, util_1.bigIntToBufferBE)(Ecdsa.curve.scalarReduce(mu), 32).toString('hex');
            const partialShareParticipant = shareParticipant;
            const partialShareToBeSent = muShareToBeSent;
            delete partialShareParticipant.l;
            delete partialShareParticipant.m;
            delete partialShareToBeSent.alpha;
            delete partialShareToBeSent.mu;
        }
        if (shareToBeSent.k) {
            const bShareParticipant = shareParticipant;
            const aShareToBeSent = shareToBeSent;
            if (!aShareToBeSent.proof) {
                throw new Error('Unexpected missing proof on aShareToBeSent');
            }
            const n = (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.n); // Paillier pub from other signer
            const pka = (0, util_1.getPaillierPublicKey)(n);
            const ntildea = (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.ntilde);
            const h1a = (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.h1);
            const h2a = (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.h2);
            const ntildeb = (0, sdk_lib_mpc_1.hexToBigInt)(bShareParticipant.ntilde);
            const h1b = (0, sdk_lib_mpc_1.hexToBigInt)(bShareParticipant.h1);
            const h2b = (0, sdk_lib_mpc_1.hexToBigInt)(bShareParticipant.h2);
            const k = (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.k);
            if (!sdk_lib_mpc_1.EcdsaRangeProof.verify(Ecdsa.curve, sdk_lib_mpc_1.minModulusBitLength, pka, {
                ntilde: ntildeb,
                h1: h1b,
                h2: h2b,
            }, {
                z: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.proof.z),
                u: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.proof.u),
                w: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.proof.w),
                s: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.proof.s),
                s1: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.proof.s1),
                s2: (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.proof.s2),
            }, k)) {
                throw new Error('Could not verify signing A share proof');
            }
            // MtA $k_j, \gamma_i$.
            const beta0 = bigintCryptoUtils.randBetween(Ecdsa.curve.order() ** _5n);
            bShareParticipant.beta = (0, util_1.bigIntToBufferBE)(Ecdsa.curve.scalarNegate(Ecdsa.curve.scalarReduce(beta0)), 32).toString('hex');
            const g = (0, sdk_lib_mpc_1.hexToBigInt)(bShareParticipant.gamma);
            const rb = await (0, sdk_lib_mpc_1.randomPositiveCoPrimeTo)(pka.n);
            const cb = pka.encrypt(beta0, rb);
            const alpha = pka.addition(pka.multiply(k, g), cb);
            aShareToBeSent.alpha = (0, util_1.bigIntToBufferBE)(alpha, 32).toString('hex');
            // Prove $\gamma_i \in Z_{N^2}$.
            const gx = Ecdsa.curve.basePointMult(g);
            let proof = await sdk_lib_mpc_1.EcdsaRangeProof.proveWithCheck(Ecdsa.curve, sdk_lib_mpc_1.minModulusBitLength, pka, {
                ntilde: ntildea,
                h1: h1a,
                h2: h2a,
            }, k, alpha, g, beta0, rb, gx);
            Object.assign(aShareToBeSent, {
                gammaProof: {
                    z: (0, util_1.bigIntToBufferBE)(proof.z, 384).toString('hex'),
                    zprm: (0, util_1.bigIntToBufferBE)(proof.zprm, 384).toString('hex'),
                    t: (0, util_1.bigIntToBufferBE)(proof.t, 384).toString('hex'),
                    v: (0, util_1.bigIntToBufferBE)(proof.v, 768).toString('hex'),
                    w: (0, util_1.bigIntToBufferBE)(proof.w, 384).toString('hex'),
                    s: (0, util_1.bigIntToBufferBE)(proof.s, 384).toString('hex'),
                    s1: (0, util_1.bigIntToBufferBE)(proof.s1, 96).toString('hex'),
                    s2: (0, util_1.bigIntToBufferBE)(proof.s2, 480).toString('hex'),
                    t1: (0, util_1.bigIntToBufferBE)(proof.t1, 224).toString('hex'),
                    t2: (0, util_1.bigIntToBufferBE)(proof.t2, 480).toString('hex'),
                    u: (0, util_1.bigIntToBufferBE)(proof.u, 33).toString('hex'),
                    x: (0, util_1.bigIntToBufferBE)(gx, 33).toString('hex'),
                },
            });
            // MtA $k_j, w_i$.
            const nu0 = bigintCryptoUtils.randBetween(Ecdsa.curve.order() ** _5n);
            shareParticipant.nu = (0, util_1.bigIntToBufferBE)(Ecdsa.curve.scalarNegate(Ecdsa.curve.scalarReduce(nu0)), 32).toString('hex');
            const w = (0, sdk_lib_mpc_1.hexToBigInt)(bShareParticipant.w);
            const rn = await (0, sdk_lib_mpc_1.randomPositiveCoPrimeTo)(pka.n);
            const cn = pka.encrypt(nu0, rn);
            const mu = pka.addition(pka.multiply(k, w), cn);
            shareToBeSent.mu = (0, util_1.bigIntToBufferBE)(mu, 32).toString('hex');
            // Prove $\w_i \in Z_{N^2}$.
            const wx = Ecdsa.curve.basePointMult(w);
            proof = await sdk_lib_mpc_1.EcdsaRangeProof.proveWithCheck(Ecdsa.curve, sdk_lib_mpc_1.minModulusBitLength, pka, {
                ntilde: ntildea,
                h1: h1a,
                h2: h2a,
            }, k, (0, sdk_lib_mpc_1.hexToBigInt)(aShareToBeSent.mu), w, nu0, rn, wx);
            Object.assign(shareToBeSent, {
                wProof: {
                    z: (0, util_1.bigIntToBufferBE)(proof.z, 384).toString('hex'),
                    zprm: (0, util_1.bigIntToBufferBE)(proof.zprm, 384).toString('hex'),
                    t: (0, util_1.bigIntToBufferBE)(proof.t, 384).toString('hex'),
                    v: (0, util_1.bigIntToBufferBE)(proof.v, 768).toString('hex'),
                    w: (0, util_1.bigIntToBufferBE)(proof.w, 384).toString('hex'),
                    s: (0, util_1.bigIntToBufferBE)(proof.s, 384).toString('hex'),
                    s1: (0, util_1.bigIntToBufferBE)(proof.s1, 96).toString('hex'),
                    s2: (0, util_1.bigIntToBufferBE)(proof.s2, 480).toString('hex'),
                    t1: (0, util_1.bigIntToBufferBE)(proof.t1, 224).toString('hex'),
                    t2: (0, util_1.bigIntToBufferBE)(proof.t2, 480).toString('hex'),
                    u: (0, util_1.bigIntToBufferBE)(proof.u, 33).toString('hex'),
                    x: (0, util_1.bigIntToBufferBE)(wx, 33).toString('hex'),
                },
            });
            if (shareParticipant.alpha) {
                const partialShareParticipant = shareParticipant;
                const partialShareToBeSent = shareToBeSent;
                delete partialShareParticipant.ntilde;
                delete partialShareParticipant.h1;
                delete partialShareParticipant.h2;
                delete partialShareParticipant.ck;
                delete partialShareToBeSent.n;
                delete partialShareToBeSent.ntilde;
                delete partialShareToBeSent.h1;
                delete partialShareToBeSent.h2;
                delete partialShareToBeSent.k;
                delete partialShareToBeSent.proof;
            }
            else {
                Object.assign(shareToBeSent, {
                    n: kShare.n,
                    ntilde: (0, util_1.bigIntToBufferBE)(ntildeb, 384).toString('hex'),
                    h1: (0, util_1.bigIntToBufferBE)(h1b, 384).toString('hex'),
                    h2: (0, util_1.bigIntToBufferBE)(h2b, 384).toString('hex'),
                    k: kShare.k,
                    proof: kShare.proof,
                });
            }
        }
        if (!('alpha' in shareToBeSent) && !('k' in shareToBeSent)) {
            const partialShareParticipant = shareParticipant;
            delete partialShareParticipant.ntilde;
            delete partialShareParticipant.h1;
            delete partialShareParticipant.h2;
            delete partialShareParticipant.ck;
            const muShareToBeSent = shareToBeSent;
            shareToBeSent = {
                i: muShareToBeSent.i,
                j: muShareToBeSent.j,
            };
        }
        [shareToBeSent.i, shareToBeSent.j] = [shareToBeSent.j, shareToBeSent.i];
        if (isGammaShare) {
            return {
                muShare: shareToBeSent,
                gShare: shareParticipant,
            };
        }
        return {
            aShare: shareToBeSent,
            bShare: shareParticipant,
        };
    }
    /**
     * Combine gamma shares to get the private omicron / delta shares
     * @param {SignCombine} shares
     * @returns {SignCombineRT}
     */
    signCombine(shares) {
        const gShare = shares.gShare;
        const S = shares.signIndex;
        const gamma = (0, sdk_lib_mpc_1.hexToBigInt)(gShare.gamma);
        const alpha = (0, sdk_lib_mpc_1.hexToBigInt)(gShare.alpha);
        const beta = (0, sdk_lib_mpc_1.hexToBigInt)(gShare.beta);
        const mu = (0, sdk_lib_mpc_1.hexToBigInt)(gShare.mu);
        const nu = (0, sdk_lib_mpc_1.hexToBigInt)(gShare.nu);
        const k = (0, sdk_lib_mpc_1.hexToBigInt)(gShare.k);
        const w = (0, sdk_lib_mpc_1.hexToBigInt)(gShare.w);
        const delta = Ecdsa.curve.scalarAdd(Ecdsa.curve.scalarMult(k, gamma), Ecdsa.curve.scalarAdd(alpha, beta));
        const omicron = Ecdsa.curve.scalarAdd(Ecdsa.curve.scalarMult(k, w), Ecdsa.curve.scalarAdd(mu, nu));
        const Gamma = Ecdsa.curve.basePointMult(gamma);
        return {
            oShare: {
                i: gShare.i,
                y: gShare.y,
                k: (0, util_1.bigIntToBufferBE)(k, 32).toString('hex'),
                omicron: (0, util_1.bigIntToBufferBE)(omicron, 32).toString('hex'),
                delta: (0, util_1.bigIntToBufferBE)(delta, 32).toString('hex'),
                Gamma: (0, util_1.bigIntToBufferBE)(Gamma, 33).toString('hex'),
            },
            dShare: {
                i: S.i,
                j: gShare.i,
                delta: (0, util_1.bigIntToBufferBE)(delta, 32).toString('hex'),
                Gamma: (0, util_1.bigIntToBufferBE)(Gamma, 33).toString('hex'),
            },
        };
    }
    /**
     * Sign a message.
     * @param {Buffer} M Message to be signed
     * @param {OShare} oShare private omicron share of current participant
     * @param {DShare} dShare delta share received from the other participant
     * @param {Hash} hash hashing algorithm implementing Node`s standard crypto hash interface
     * @param shouldHash if true, we hash the provided buffer before signing
     * @returns {VAShare}
     */
    sign(M, oShare, dShare, hash, shouldHash = true) {
        const m = shouldHash ? (hash || (0, crypto_1.createHash)('sha256')).update(M).digest() : M;
        const delta = Ecdsa.curve.scalarAdd((0, sdk_lib_mpc_1.hexToBigInt)(oShare.delta), (0, sdk_lib_mpc_1.hexToBigInt)(dShare.delta));
        const R = Ecdsa.curve.pointMultiply(Ecdsa.curve.pointAdd((0, sdk_lib_mpc_1.hexToBigInt)(oShare.Gamma), (0, sdk_lib_mpc_1.hexToBigInt)(dShare.Gamma)), Ecdsa.curve.scalarInvert(delta));
        const pointR = secp.Point.fromHex((0, util_1.bigIntToBufferBE)(R, 32));
        const r = pointR.x;
        const s = Ecdsa.curve.scalarAdd(Ecdsa.curve.scalarMult((0, util_1.bigIntFromU8ABE)(m), (0, sdk_lib_mpc_1.hexToBigInt)(oShare.k)), Ecdsa.curve.scalarMult(r, (0, sdk_lib_mpc_1.hexToBigInt)(oShare.omicron)));
        const l = Ecdsa.curve.scalarRandom();
        const rho = Ecdsa.curve.scalarRandom();
        const V = Ecdsa.curve.pointAdd(Ecdsa.curve.pointMultiply(R, s), Ecdsa.curve.basePointMult(l));
        const A = Ecdsa.curve.basePointMult(rho);
        const comDecom_V_A = sdk_lib_mpc_1.HashCommitment.createCommitment(Buffer.concat([(0, util_1.bigIntToBufferBE)(V, Ecdsa.curve.pointBytes), (0, util_1.bigIntToBufferBE)(A, Ecdsa.curve.pointBytes)]));
        return {
            i: oShare.i,
            y: oShare.y,
            R: pointR.toHex(true),
            s: (0, util_1.bigIntToBufferBE)(s, 32).toString('hex'),
            m: m,
            l: l,
            rho: rho,
            V: V,
            A: A,
            comDecomVA: comDecom_V_A,
        };
    }
    /**
     * Generate proofs of V_i and A_i values.
     * @param {Buffer} M Message to commit to as part of the context of the proof.
     *    This doesn't need to be the same message that was signed in the sign function above.
     *    But it should be the same for all participants for the purpose of providing proof context.
     * @param {VAShare} vaShare The VAShare to prove.
     * @returns {VAShareWithProofs}
     */
    generateVAProofs(M, vaShare) {
        const s = (0, sdk_lib_mpc_1.hexToBigInt)(vaShare.s);
        const R = (0, util_1.bigIntFromU8ABE)(secp.Point.fromHex(vaShare.R).toRawBytes(true));
        const proofContext = (0, crypto_1.createHash)('sha256').update(M).update((0, util_1.bigIntToBufferBE)(R, Ecdsa.curve.pointBytes)).digest();
        const zkVProof = sdk_lib_mpc_1.EcdsaZkVProof.createZkVProof(vaShare.V, s, vaShare.l, R, Ecdsa.curve, proofContext);
        const schnorrProof = sdk_lib_mpc_1.Schnorr.createSchnorrProof(vaShare.A, vaShare.rho, Ecdsa.curve, proofContext);
        return {
            ...vaShare,
            proofContext: proofContext,
            zkVProofV: zkVProof,
            schnorrProofA: schnorrProof,
        };
    }
    /**
     * Verify V_i and A_i values of all other participants during signing phase 5 steps 5A and 5B.
     * @param {VAShareWithProofs} vaShare V_i, A_i info including SShare values of the currenct participant
     * @param {PublicVAShareWithProofs[]} publicVAShares public V_i, A_i info of all other participants
     * @returns {UTShare} U_i, T_i info of the current participant if all verifications pass
     */
    verifyVAShares(vaShare, publicVAShares) {
        publicVAShares.forEach((publicVAShare) => {
            if (!sdk_lib_mpc_1.HashCommitment.verifyCommitment(publicVAShare.comDecomVA.commitment, {
                secret: Buffer.concat([
                    (0, util_1.bigIntToBufferBE)(publicVAShare.V, Ecdsa.curve.pointBytes),
                    (0, util_1.bigIntToBufferBE)(publicVAShare.A, Ecdsa.curve.pointBytes),
                ]),
                blindingFactor: publicVAShare.comDecomVA.decommitment.blindingFactor,
            })) {
                throw new Error('Could not verify commitment of V_i and A_i');
            }
            if (!sdk_lib_mpc_1.Schnorr.verifySchnorrProof(publicVAShare.A, publicVAShare.schnorrProofA, Ecdsa.curve, vaShare.proofContext)) {
                throw new Error('Could not verify Schnorr proof of A_i');
            }
            if (!sdk_lib_mpc_1.EcdsaZkVProof.verifyZkVProof(publicVAShare.V, publicVAShare.zkVProofV, (0, sdk_lib_mpc_1.hexToBigInt)(vaShare.R), Ecdsa.curve, vaShare.proofContext)) {
                throw new Error('Could not verify ZK proof of V_i');
            }
        });
        const y = (0, sdk_lib_mpc_1.hexToBigInt)(vaShare.y);
        // r is R's x coordinate.  R is in compressed form, so we need to slice off the first byte.
        const r = (0, sdk_lib_mpc_1.hexToBigInt)(vaShare.R.slice(2));
        // Calculate aggregation of all V_i and A_i.
        let V = Ecdsa.curve.pointAdd(Ecdsa.curve.pointAdd(Ecdsa.curve.basePointMult(Ecdsa.curve.scalarNegate((0, util_1.bigIntFromU8ABE)(vaShare.m))), Ecdsa.curve.pointMultiply(y, Ecdsa.curve.scalarNegate(r))), vaShare.V);
        let A = vaShare.A;
        publicVAShares.forEach((publicVAShare) => {
            V = Ecdsa.curve.pointAdd(V, publicVAShare.V);
            A = Ecdsa.curve.pointAdd(A, publicVAShare.A);
        });
        // Calculate U_i = rho_i * V and T_i = l_i * A.
        const U = Ecdsa.curve.pointMultiply(V, vaShare.rho);
        const T = Ecdsa.curve.pointMultiply(A, vaShare.l);
        const comDecom_U_T = sdk_lib_mpc_1.HashCommitment.createCommitment(Buffer.concat([(0, util_1.bigIntToBufferBE)(U, Ecdsa.curve.pointBytes), (0, util_1.bigIntToBufferBE)(T, Ecdsa.curve.pointBytes)]));
        return {
            ...vaShare,
            U,
            T,
            comDecomUT: comDecom_U_T,
        };
    }
    /**
     * Verify U_i and V_i values of all other participants during signing phase 5 steps 5C and 5D.
     * @param {UTShare} utShare U_i, T_i info including SShare values of the currenct participant
     * @param {PublicUTShare[]} publicUTShares public U_i, T_i info of all other participants
     * @returns {SShare} SShare of the current participant if all verifications pass
     */
    verifyUTShares(utShare, publicUTShares) {
        let sigmaU = utShare.U;
        let sigmaT = utShare.T;
        publicUTShares.forEach((publicUTShare) => {
            if (!sdk_lib_mpc_1.HashCommitment.verifyCommitment(publicUTShare.comDecomUT.commitment, {
                secret: Buffer.concat([
                    (0, util_1.bigIntToBufferBE)(publicUTShare.U, Ecdsa.curve.pointBytes),
                    (0, util_1.bigIntToBufferBE)(publicUTShare.T, Ecdsa.curve.pointBytes),
                ]),
                blindingFactor: publicUTShare.comDecomUT.decommitment.blindingFactor,
            })) {
                throw new Error('Could not verify commitment of U_i and T_i');
            }
            sigmaU = Ecdsa.curve.pointAdd(sigmaU, publicUTShare.U);
            sigmaT = Ecdsa.curve.pointAdd(sigmaT, publicUTShare.T);
        });
        if (sigmaU !== sigmaT) {
            throw new Error('Sum of all U_i does not match sum of all T_i');
        }
        return { ...utShare };
    }
    /**
     * Construct full signature by combining Sign Shares
     * @param {SShare[]} shares
     * @returns {Signature}
     */
    constructSignature(shares) {
        // Every R must match.
        const R = shares[0]['R'];
        const isRMatching = shares.map((share) => share['R'] === R).reduce((a, b) => a && b);
        if (!isRMatching) {
            throw new Error('R value should be consistent across all shares');
        }
        let s = shares.map((share) => (0, sdk_lib_mpc_1.hexToBigInt)(share['s'])).reduce(Ecdsa.curve.scalarAdd);
        const recid = (R.slice(0, 2) === '03' ? 1 : 0) ^ (s > Ecdsa.curve.order() / BigInt(2) ? 1 : 0);
        // Normalize s.
        s = s > Ecdsa.curve.order() / BigInt(2) ? Ecdsa.curve.order() - s : s;
        return {
            y: shares[0]['y'],
            r: R.slice(2),
            s: (0, util_1.bigIntToBufferBE)(s, 32).toString('hex'),
            recid: recid,
        };
    }
    /**
     * Verify ecdsa signatures
     * @param {Buffer} message
     * @param {Signature } signature
     * @param {Hash} hash hashing algorithm implementing Node`s standard crypto hash interface
     * @param {boolean} shouldHash if true, we hash the provided buffer before verifying
     * @returns {boolean} True if signature is valid; False otherwise
     */
    verify(message, signature, hash, shouldHash = true) {
        const messageToVerify = shouldHash ? (hash || (0, crypto_1.createHash)('sha256')).update(message).digest() : message;
        return Ecdsa.curve.verify(messageToVerify, Buffer.concat([
            Buffer.from([signature['recid']]),
            (0, util_1.bigIntToBufferBE)((0, sdk_lib_mpc_1.hexToBigInt)(signature['r']), 32),
            (0, util_1.bigIntToBufferBE)((0, sdk_lib_mpc_1.hexToBigInt)(signature['s']), 32),
        ]), (0, sdk_lib_mpc_1.hexToBigInt)(signature['y']));
    }
    /**
     * Deserializes a challenge and it's proofs from hex strings to bigint
     * @deprecated use sdk-lib-mpc EcdsaTypes.deserializeNtilde instead
     */
    static deserializeNtilde(challenge) {
        return sdk_lib_mpc_1.EcdsaTypes.deserializeNtilde(challenge);
    }
    /**
     * Serializes a challenge and it's proofs from big int to hex strings.
     * @deprecated use sdk-lib-mpc EcdsaTypes.deserializeNtilde instead
     * @param challenge
     */
    static serializeNtilde(challenge) {
        return sdk_lib_mpc_1.EcdsaTypes.serializeNtilde(challenge);
    }
}
exports.default = Ecdsa;
Ecdsa.curve = new curves_1.Secp256k1Curve();
Ecdsa.hdTree = new sdk_lib_mpc_1.Secp256k1Bip32HdTree();
Ecdsa.shamir = new sdk_lib_mpc_1.Shamir(Ecdsa.curve);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNkc2EuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvYWNjb3VudC1saWIvbXBjL3Rzcy9lY2RzYS9lY2RzYS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsZ0VBQWtEO0FBQ2xELHVFQUF5RDtBQUN6RCx1REFBeUM7QUFDekMsbUNBQXVEO0FBQ3ZELDhDQUF3QztBQUN4QyxxQ0FBeUc7QUFDekcseUNBQThDO0FBQzlDLG9EQWU0QjtBQXVDNUIsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3RCLHNGQUFzRjtBQUN0RixNQUFNLFdBQVcsR0FBRyxHQUFHLENBQUM7QUFFeEI7O0dBRUc7QUFDSCxNQUFxQixLQUFLO0lBSXhCOzs7Ozs7Ozs7T0FTRztJQUNILEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBYSxFQUFFLFNBQWlCLEVBQUUsU0FBaUIsRUFBRSxJQUFhLEVBQUUsSUFBSSxHQUFHLEtBQUs7O1FBQzdGLElBQUksQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLElBQUksS0FBSyxJQUFJLFNBQVMsSUFBSSxTQUFTLElBQUksU0FBUyxJQUFJLFNBQVMsS0FBSyxDQUFDLENBQUMsRUFBRTtZQUNuRixNQUFNLHlCQUF5QixDQUFDO1NBQ2pDO1FBRUQsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLEVBQUU7WUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyw4Q0FBOEMsQ0FBQyxDQUFDO1NBQ2pFO1FBRUQsSUFBSSxtQkFBbUIsR0FBRyxJQUFJLENBQUM7UUFDL0IsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLEVBQUU7WUFDNUIsa0VBQWtFO1lBQ2xFLG1CQUFtQixHQUFHLElBQUEsbUJBQVUsRUFBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxF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UyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQzVCLENBQUM7SUFDSixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTSxDQUFDLGlCQUFpQixDQUFDLFNBQXNDO1FBQzdELE9BQU8sd0JBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxlQUFlLENBQUMsU0FBd0M7UUFDN0QsT0FBTyx3QkFBVSxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUMvQyxDQUFDOztBQXIvQ0gsd0JBcy9DQztBQXIvQ1EsV0FBSyxHQUFtQixJQUFJLHVCQUFjLEVBQUUsQ0FBQztBQUM3QyxZQUFNLEdBQVcsSUFBSSxrQ0FBb0IsRUFBRSxDQUFDO0FBQzVDLFlBQU0sR0FBVyxJQUFJLG9CQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcGFpbGxpZXJCaWdpbnQgZnJvbSAncGFpbGxpZXItYmlnaW50JztcbmltcG9ydCAqIGFzIGJpZ2ludENyeXB0b1V0aWxzIGZyb20gJ2JpZ2ludC1jcnlwdG8tdXRpbHMnO1xuaW1wb3J0ICogYXMgc2VjcCBmcm9tICdAbm9ibGUvc2VjcDI1NmsxJztcbmltcG9ydCB7IGNyZWF0ZUhhc2gsIEhhc2gsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IGJpcDMyIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCB7IGJpZ0ludEZyb21CdWZmZXJCRSwgYmlnSW50RnJvbVU4QUJFLCBiaWdJbnRUb0J1ZmZlckJFLCBnZXRQYWlsbGllclB1YmxpY0tleSB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgU2VjcDI1NmsxQ3VydmUgfSBmcm9tICcuLi8uLi9jdXJ2ZXMnO1xuaW1wb3J0IHtcbiAgRWNkc2FQYWlsbGllclByb29mLFxuICBFY2RzYVJhbmdlUHJvb2YsXG4gIEVjZHNhVHlwZXMsXG4gIEVjZHNhWmtWUHJvb2YsXG4gIEhhc2hDb21taXRtZW50LFxuICBTY2hub3JyLFxuICByYW5kb21Qb3NpdGl2ZUNvUHJpbWVUbyxcbiAgaGV4VG9CaWdJbnQsXG4gIG1pbk1vZHVsdXNCaXRMZW5ndGgsXG4gIEhEVHJlZSxcbiAgU2VjcDI1NmsxQmlwMzJIZFRyZWUsXG4gIGNoYWluY29kZUJhc2UsXG4gIFNoYW1pcixcbiAgU2Nobm9yclByb29mLFxufSBmcm9tICdAYml0Z28vc2RrLWxpYi1tcGMnO1xuaW1wb3J0IHtcbiAgQVNoYXJlLFxuICBCU2hhcmUsXG4gIERTaGFyZSxcbiAgR1NoYXJlLFxuICBLZXlDb21iaW5lZCxcbiAgS2V5U2hhcmUsXG4gIEtTaGFyZSxcbiAgTVVTaGFyZSxcbiAgTlNoYXJlLFxuICBPU2hhcmUsXG4gIFBTaGFyZSxcbiAgUHVibGljVVRTaGFyZSxcbiAgUmFuZ2VQcm9vZldpdGhDaGVja1NoYXJlLFxuICBTaWduYXR1cmUsXG4gIFNpZ25Db21iaW5lLFxuICBTaWduQ29tYmluZVJULFxuICBTaWduQ29udmVydCxcbiAgU2lnbkNvbnZlcnRSVCxcbiAgU2lnbkNvbnZlcnRTdGVwMSxcbiAgU2lnbkNvbnZlcnRTdGVwMVJlc3BvbnNlLFxuICBTaWduQ29udmVydFN0ZXAyLFxuICBTaWduQ29udmVydFN0ZXAyUmVzcG9uc2UsXG4gIFNpZ25Db252ZXJ0U3RlcDMsXG4gIFNpZ25Db252ZXJ0U3RlcDNSZXNwb25zZSxcbiAgU2lnblNoYXJlUlQsXG4gIFNTaGFyZSxcbiAgU3Via2V5U2hhcmUsXG4gIFVUU2hhcmUsXG4gIFZBU2hhcmVXaXRoUHJvb2ZzLFxuICBWQVNoYXJlLFxuICBXU2hhcmUsXG4gIFhTaGFyZSxcbiAgWFNoYXJlV2l0aENoYWxsZW5nZXMsXG4gIFlTaGFyZVdpdGhDaGFsbGVuZ2VzLFxuICBQdWJsaWNWQVNoYXJlV2l0aFByb29mcyxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IF81biA9IEJpZ0ludCg1KTtcbi8vIFNpemUgb2YgYWxwaGEgYW5kIG11IHNoYXJlcyBpbiBieXRlcyBleHBlY3RlZCBieSB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIHByb3RvY29sXG5jb25zdCBBTFBIQU1VU0laRSA9IDc2ODtcblxuLyoqXG4gKiBFQ0RTQSBUU1MgaW1wbGVtZW50YXRpb24gc3VwcG9ydGluZyAyOm4gVGhyZXNob2xkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVjZHNhIHtcbiAgc3RhdGljIGN1cnZlOiBTZWNwMjU2azFDdXJ2ZSA9IG5ldyBTZWNwMjU2azFDdXJ2ZSgpO1xuICBzdGF0aWMgaGRUcmVlOiBIRFRyZWUgPSBuZXcgU2VjcDI1NmsxQmlwMzJIZFRyZWUoKTtcbiAgc3RhdGljIHNoYW1pcjogU2hhbWlyID0gbmV3IFNoYW1pcihFY2RzYS5jdXJ2ZSk7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBzaGFyZXMgZm9yIHBhcnRpY2lwYW50IGF0IGluZGV4IGFuZCBzcGxpdCBrZXlzIGAodGhyZXNob2xkLG51bVNoYXJlcylgIHdheXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBwYXJ0aWNpcGFudCBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkIFNpZ25pbmcgdGhyZXNob2xkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1TaGFyZXMgIE51bWJlciBvZiBzaGFyZXNcbiAgICogQHBhcmFtIHtCdWZmZXJ9IHNlZWQgb3B0aW9uYWwgNjQgYnl0ZSBzZWVkIHRvIHVzZSBmb3Iga2V5IGdlbmVyYXRpb25cbiAgICogQHBhcmFtIHN5bmMgb3B0aW9uYWwgc3luYyBmbGFnLCBpZiB0cnVlIHRoZW4gYSBzeW5jaHJvbm91cyB2ZXJzaW9uIG9mIFBhaWxsaWVyIGtleSBnZW5lcmF0aW9uIGlzIHVzZWQgdGhhdCBkb2VzIG5vdCBzcGF3biBXb3JrZXIgdGhyZWFkcy5cbiAgICogQHJldHVybnMge1Byb21pc2U8S2V5U2hhcmU+fSBSZXR1cm5zIHRoZSBwcml2YXRlIHAtc2hhcmVcbiAgICogYW5kIG4tc2hhcmVzIHRvIGJlIGRpc3RyaWJ1dGVkIHRvIHBhcnRpY2lwYW50cyBhdCB0aGVpciBjb3JyZXNwb25kaW5nIGluZGV4LlxuICAgKi9cbiAgYXN5bmMga2V5U2hhcmUoaW5kZXg6IG51bWJlciwgdGhyZXNob2xkOiBudW1iZXIsIG51bVNoYXJlczogbnVtYmVyLCBzZWVkPzogQnVmZmVyLCBzeW5jID0gZmFsc2UpOiBQcm9taXNlPEtleVNoYXJlPiB7XG4gICAgaWYgKCEoaW5kZXggPiAwICYmIGluZGV4IDw9IG51bVNoYXJlcyAmJiB0aHJlc2hvbGQgPD0gbnVtU2hhcmVzICYmIHRocmVzaG9sZCA9PT0gMikpIHtcbiAgICAgIHRocm93ICdJbnZhbGlkIEtleVNoYXJlIENvbmZpZyc7XG4gICAgfVxuXG4gICAgaWYgKHNlZWQgJiYgc2VlZC5sZW5ndGggPCA2NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWVkIG11c3QgaGF2ZSBhIGxlbmd0aCBvZiBhdCBsZWFzdCA2NCBieXRlcycpO1xuICAgIH1cblxuICAgIGxldCBzZWVkV2l0aFZhbGlkTGVuZ3RoID0gc2VlZDtcbiAgICBpZiAoc2VlZCAmJiBzZWVkLmxlbmd0aCA+IDY0KSB7XG4gICAgICAvLyBpZiBzZWVkIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gNjQgYnl0ZXMsIGhhc2ggc2VlZCB0byA2NCBieXRlcy5cbiAgICAgIHNlZWRXaXRoVmFsaWRMZW5ndGggPSBjcmVhdGVIYXNoKCdzaGE1MTInKS51cGRhdGUoc2VlZCkuZGlnZXN0KCk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgYWRkaXRpdmVseSBob21vbW9ycGhpYyBlbmNyeXB0aW9uIGtleS5cbiAgICBsZXQgcGFpbGxpZXJLZXlQYWlyOiBwYWlsbGllckJpZ2ludC5LZXlQYWlyO1xuICAgIGlmICghc3luYykge1xuICAgICAgcGFpbGxpZXJLZXlQYWlyID0gYXdhaXQgcGFpbGxpZXJCaWdpbnQuZ2VuZXJhdGVSYW5kb21LZXlzKG1pbk1vZHVsdXNCaXRMZW5ndGgsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc3luY1xuICAgICAgcGFpbGxpZXJLZXlQYWlyID0gcGFpbGxpZXJCaWdpbnQuZ2VuZXJhdGVSYW5kb21LZXlzU3luYyhtaW5Nb2R1bHVzQml0TGVuZ3RoLCB0cnVlKTtcbiAgICB9XG4gICAgY29uc3QgeyBwdWJsaWNLZXksIHByaXZhdGVLZXkgfSA9IHBhaWxsaWVyS2V5UGFpcjtcbiAgICAvLyBBY2NlcHQgYSA2NCBieXRlIHNlZWQgYW5kIGNyZWF0ZSBhbiBleHRlbmRlZCBwcml2YXRlIGtleSBmcm9tIHRoYXQgc2VlZFxuICAgIGNvbnN0IHNlY3JldEtleSA9IHNlZWRXaXRoVmFsaWRMZW5ndGggJiYgYmlwMzIuZnJvbVNlZWQoc2VlZFdpdGhWYWxpZExlbmd0aCk7XG4gICAgY29uc3QgdSA9XG4gICAgICAoc2VjcmV0S2V5ICYmIHNlY3JldEtleS5wcml2YXRlS2V5ICYmIGJpZ0ludEZyb21VOEFCRShuZXcgVWludDhBcnJheShzZWNyZXRLZXkucHJpdmF0ZUtleSkpKSA/P1xuICAgICAgRWNkc2EuY3VydmUuc2NhbGFyUmFuZG9tKCk7XG4gICAgY29uc3QgeSA9IEVjZHNhLmN1cnZlLmJhc2VQb2ludE11bHQodSk7XG4gICAgY29uc3QgY2hhaW5jb2RlID0gKHNlY3JldEtleSAmJiBzZWNyZXRLZXkuY2hhaW5Db2RlKSA/PyByYW5kb21CeXRlcygzMik7XG4gICAgLy8gQ29tcHV0ZSBzZWNyZXQgc2hhcmVzIG9mIHRoZSBwcml2YXRlIGtleVxuICAgIGNvbnN0IHsgc2hhcmVzOiB1U2hhcmVzLCB2IH0gPSBFY2RzYS5zaGFtaXIuc3BsaXQodSwgdGhyZXNob2xkLCBudW1TaGFyZXMpO1xuICAgIGNvbnN0IGN1cnJlbnRQYXJ0aWNpcGFudDogUFNoYXJlID0ge1xuICAgICAgaTogaW5kZXgsXG4gICAgICB0OiB0aHJlc2hvbGQsXG4gICAgICBjOiBudW1TaGFyZXMsXG4gICAgICBsOiBiaWdJbnRUb0J1ZmZlckJFKHByaXZhdGVLZXkubGFtYmRhLCAxOTIpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIG06IGJpZ0ludFRvQnVmZmVyQkUocHJpdmF0ZUtleS5tdSwgMTkyKS50b1N0cmluZygnaGV4JyksXG4gICAgICBuOiBiaWdJbnRUb0J1ZmZlckJFKHB1YmxpY0tleS5uLCAzODQpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHk6IGJpZ0ludFRvQnVmZmVyQkUoeSwgMzMpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHU6IGJpZ0ludFRvQnVmZmVyQkUodVNoYXJlc1tpbmRleF0sIDMyKS50b1N0cmluZygnaGV4JyksXG4gICAgICB1dTogdS50b1N0cmluZygpLFxuICAgICAgY2hhaW5jb2RlOiBjaGFpbmNvZGUudG9TdHJpbmcoJ2hleCcpLFxuICAgIH07XG4gICAgY29uc3Qga2V5U2hhcmU6IEtleVNoYXJlID0ge1xuICAgICAgcFNoYXJlOiBjdXJyZW50UGFydGljaXBhbnQsXG4gICAgICBuU2hhcmVzOiB7fSxcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBzaGFyZSBpbiB1U2hhcmVzKSB7XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudEluZGV4ID0gcGFyc2VJbnQoc2hhcmUsIDEwKTtcbiAgICAgIGlmIChwYXJ0aWNpcGFudEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICBrZXlTaGFyZS5uU2hhcmVzW3BhcnRpY2lwYW50SW5kZXhdID0ge1xuICAgICAgICAgIGk6IHBhcnRpY2lwYW50SW5kZXgsXG4gICAgICAgICAgajogY3VycmVudFBhcnRpY2lwYW50WydpJ10sXG4gICAgICAgICAgbjogcHVibGljS2V5Lm4udG9TdHJpbmcoMTYpLFxuICAgICAgICAgIHk6IGJpZ0ludFRvQnVmZmVyQkUoeSwgMzMpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICB2OiBiaWdJbnRUb0J1ZmZlckJFKHZbMF0sIDMzKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgdTogYmlnSW50VG9CdWZmZXJCRSh1U2hhcmVzW3BhcnRpY2lwYW50SW5kZXhdLCAzMikudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgIGNoYWluY29kZTogY2hhaW5jb2RlLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgfSBhcyBOU2hhcmU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlTaGFyZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lIGRhdGEgc2hhcmVkIGR1cmluZyB0aGUga2V5IGdlbmVyYXRpb24gcHJvdG9jb2wuXG4gICAqIEBwYXJhbSB7S2V5U2hhcmV9IHBhcnRpY2lwYW50U2hhcmVzIHByaXZhdGUgcC1zaGFyZSBhbmRcbiAgICogbi1zaGFyZXMgcmVjZWl2ZWQgZnJvbSBhbGwgb3RoZXIgcGFydGljaXBhbnRzLlxuICAgKiBAcmV0dXJucyB7S2V5Q29tYmluZWR9IFJldHVybnMgdGhlIHBhcnRpY2lwYW50IHByaXZhdGUgeC1zaGFyZVxuICAgKiBhbmQgeS1zaGFyZXMgdG8gYmUgdXNlZCB3aGVuIGdlbmVyYXRpbmcgc2lnbmluZyBzaGFyZXMuXG4gICAqL1xuICBrZXlDb21iaW5lKHBTaGFyZTogUFNoYXJlLCBuU2hhcmVzOiBOU2hhcmVbXSk6IEtleUNvbWJpbmVkIHtcbiAgICBjb25zdCBhbGxTaGFyZXMgPSBbcFNoYXJlLCAuLi5uU2hhcmVzXTtcbiAgICAvLyBDb21wdXRlIHRoZSBwdWJsaWMga2V5LlxuICAgIGNvbnN0IHkgPSBhbGxTaGFyZXMubWFwKChwYXJ0aWNpcGFudCkgPT4gaGV4VG9CaWdJbnQocGFydGljaXBhbnRbJ3knXSkpLnJlZHVjZShFY2RzYS5jdXJ2ZS5wb2ludEFkZCk7XG4gICAgLy8gQWRkIHNlY3JldCBzaGFyZXNcbiAgICBjb25zdCB4ID0gYWxsU2hhcmVzLm1hcCgocGFydGljaXBhbnQpID0+IGhleFRvQmlnSW50KHBhcnRpY2lwYW50Wyd1J10pKS5yZWR1Y2UoRWNkc2EuY3VydmUuc2NhbGFyQWRkKTtcblxuICAgIC8vIFZlcmlmeSBzaGFyZXMuXG4gICAgZm9yIChjb25zdCBzaGFyZSBvZiBuU2hhcmVzKSB7XG4gICAgICBpZiAoc2hhcmUudikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEVjZHNhLnNoYW1pci52ZXJpZnkoaGV4VG9CaWdJbnQoc2hhcmUudSksIFtoZXhUb0JpZ0ludChzaGFyZS55KSwgaGV4VG9CaWdJbnQoc2hhcmUudildLCBwU2hhcmUuaSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHZlcmlmeSBzaGFyZSBmcm9tIHBhcnRpY2lwYW50ICR7c2hhcmUuan0uIFZlcmlmaWNhdGlvbiBlcnJvcjogJHtlcnJ9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBTY2hub3JyIHByb29mIG9mIGtub3dsZWRnZSBvZiB0aGUgZGlzY3JldGUgbG9nIG9mIFggPSB4Ry5cbiAgICBjb25zdCBYID0gRWNkc2EuY3VydmUuYmFzZVBvaW50TXVsdCh4KTtcblxuICAgIGNvbnN0IHByb29mQ29udGV4dCA9IGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHksIEVjZHNhLmN1cnZlLnBvaW50Qnl0ZXMpKS5kaWdlc3QoKTtcblxuICAgIGNvbnN0IHNjaG5vcnJQcm9vZlggPSBTY2hub3JyLmNyZWF0ZVNjaG5vcnJQcm9vZihYLCB4LCBFY2RzYS5jdXJ2ZSwgcHJvb2ZDb250ZXh0KTtcblxuICAgIC8vIENoYWluY29kZSB3aWxsIGJlIHVzZWQgaW4gZnV0dXJlIHdoZW4gd2UgYWRkIHN1cHBvcnQgZm9yIGtleSBkZXJpdmF0aW9uIGZvciBlY2RzYVxuICAgIGNvbnN0IGNoYWluY29kZXMgPSBbcFNoYXJlLCAuLi5uU2hhcmVzXS5tYXAoKHsgY2hhaW5jb2RlIH0pID0+IGJpZ0ludEZyb21CdWZmZXJCRShCdWZmZXIuZnJvbShjaGFpbmNvZGUsICdoZXgnKSkpO1xuICAgIGNvbnN0IGNoYWluY29kZSA9IGNoYWluY29kZXMucmVkdWNlKFxuICAgICAgKGFjYywgY2hhaW5jb2RlKSA9PlxuICAgICAgICAoYWNjICsgY2hhaW5jb2RlKSAlIEJpZ0ludCgnMHgwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKSAvLyAyXjI1NlxuICAgICk7XG5cbiAgICBjb25zdCBwYXJ0aWNpcGFudHM6IEtleUNvbWJpbmVkID0ge1xuICAgICAgeFNoYXJlOiB7XG4gICAgICAgIGk6IHBTaGFyZS5pLFxuICAgICAgICBsOiBwU2hhcmUubCxcbiAgICAgICAgbTogcFNoYXJlLm0sXG4gICAgICAgIG46IHBTaGFyZS5uLFxuICAgICAgICB5OiBiaWdJbnRUb0J1ZmZlckJFKHksIDMzKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgIHg6IGJpZ0ludFRvQnVmZmVyQkUoeCwgMzIpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgc2Nobm9yclByb29mWDogc2Nobm9yclByb29mWCxcbiAgICAgICAgY2hhaW5jb2RlOiBiaWdJbnRUb0J1ZmZlckJFKGNoYWluY29kZSwgMzIpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIH0sXG4gICAgICB5U2hhcmVzOiB7fSxcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBzaGFyZSBpbiBuU2hhcmVzKSB7XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudEluZGV4ID0gblNoYXJlc1tzaGFyZV1bJ2onXTtcbiAgICAgIHBhcnRpY2lwYW50cy55U2hhcmVzW3BhcnRpY2lwYW50SW5kZXhdID0ge1xuICAgICAgICBpOiBwU2hhcmUuaSxcbiAgICAgICAgajogblNoYXJlc1tzaGFyZV1bJ2onXSxcbiAgICAgICAgbjogblNoYXJlc1tzaGFyZV1bJ24nXSxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWNpcGFudHM7XG4gIH1cblxuICAvKipcbiAgICogRGVyaXZlIHNoYXJlcyBmb3IgYSBCSVAtMzIgc3Via2V5LlxuICAgKiBAcGFyYW0ge1BTaGFyZX0gVGhlIHVzZXIncyBwLXNoYXJlLlxuICAgKiBAcGFyYW0ge05TaGFyZVtdfSBUaGUgbi1zaGFyZXMgcmVjZWl2ZWQgZnJvbSB0aGUgb3RoZXIgcGFydGljaXBhbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIEJJUC0zMiBwYXRoIHRvIGRlcml2ZS5cbiAgICogQHJldHVybnMge1N1YmtleVNoYXJlfSBSZXR1cm5zIHRoZSBwcml2YXRlIHgtc2hhcmUgYW5kIG4tc2hhcmVzIHRvXG4gICAqIGJlIGRpc3RyaWJ1dGVkIHRvIHBhcnRpY2lwYW50cyBhdCB0aGVpciBjb3JyZXNwb25kaW5nIGluZGV4LlxuICAgKi9cbiAga2V5RGVyaXZlKHBTaGFyZTogUFNoYXJlLCBuU2hhcmVzOiBOU2hhcmVbXSwgcGF0aDogc3RyaW5nKTogU3Via2V5U2hhcmUge1xuICAgIGNvbnN0IHlWYWx1ZXMgPSBbcFNoYXJlLCAuLi5uU2hhcmVzXS5tYXAoKHNoYXJlKSA9PiBoZXhUb0JpZ0ludChzaGFyZS55KSk7XG4gICAgY29uc3QgeSA9IHlWYWx1ZXMucmVkdWNlKChwYXJ0aWFsLCBzaGFyZSkgPT4gRWNkc2EuY3VydmUucG9pbnRBZGQocGFydGlhbCwgc2hhcmUpKTtcbiAgICBjb25zdCB1ID0gQmlnSW50KHBTaGFyZS51dSk7XG4gICAgbGV0IGNvbnRyaWJDaGFpbmNvZGUgPSBoZXhUb0JpZ0ludChwU2hhcmUuY2hhaW5jb2RlKTtcbiAgICBjb25zdCBjaGFpbmNvZGVzID0gW2NvbnRyaWJDaGFpbmNvZGUsIC4uLm5TaGFyZXMubWFwKCh7IGNoYWluY29kZSB9KSA9PiBoZXhUb0JpZ0ludChjaGFpbmNvZGUpKV07XG4gICAgY29uc3QgY2hhaW5jb2RlID0gY2hhaW5jb2Rlcy5yZWR1Y2UoKGFjYywgY2hhaW5jb2RlKSA9PiAoYWNjICsgY2hhaW5jb2RlKSAlIGNoYWluY29kZUJhc2UpO1xuXG4gICAgLy8gVmVyaWZ5IHNoYXJlcy5cbiAgICBmb3IgKGNvbnN0IHNoYXJlIG9mIG5TaGFyZXMpIHtcbiAgICAgIGlmIChzaGFyZS52KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRWNkc2Euc2hhbWlyLnZlcmlmeShoZXhUb0JpZ0ludChzaGFyZS51KSwgW2hleFRvQmlnSW50KHNoYXJlLnkpLCBoZXhUb0JpZ0ludChzaGFyZS52KV0sIHBTaGFyZS5pKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgdmVyaWZ5IHNoYXJlIGZyb20gcGFydGljaXBhbnQgJHtzaGFyZS5qfS4gVmVyaWZpY2F0aW9uIGVycm9yOiAke2Vycn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlcml2ZSBzdWJrZXkuXG4gICAgY29uc3Qgc3Via2V5ID0gRWNkc2EuaGRUcmVlLnByaXZhdGVEZXJpdmUoeyBwazogeSwgc2s6IHUsIGNoYWluY29kZSB9LCBwYXRoKTtcblxuICAgIC8vIENhbGN1bGF0ZSBuZXcgcHVibGljIGtleSBjb250cmlidXRpb24uXG4gICAgY29uc3QgY29udHJpYlkgPSBFY2RzYS5jdXJ2ZS5iYXNlUG9pbnRNdWx0KHN1YmtleS5zayk7XG5cbiAgICAvLyBDYWxjdWxhdGUgbmV3IGNoYWluY29kZSBjb250cmlidXRpb24uXG4gICAgY29uc3QgY2hhaW5jb2RlRGVsdGEgPSAoY2hhaW5jb2RlQmFzZSArIHN1YmtleS5jaGFpbmNvZGUgLSBjaGFpbmNvZGUpICUgY2hhaW5jb2RlQmFzZTtcbiAgICBjb250cmliQ2hhaW5jb2RlID0gKGNvbnRyaWJDaGFpbmNvZGUgKyBjaGFpbmNvZGVEZWx0YSkgJSBjaGFpbmNvZGVCYXNlO1xuXG4gICAgLy8gQ2FsY3VsYXRlIG5ldyB1IHZhbHVlcy5cbiAgICBjb25zdCB7IHNoYXJlczogc3BsaXRfdSwgdiB9ID0gRWNkc2Euc2hhbWlyLnNwbGl0KHN1YmtleS5zaywgcFNoYXJlLnQgfHwgMiwgcFNoYXJlLmMgfHwgMyk7XG5cbiAgICAvLyBDYWxjdWxhdGUgbmV3IHNpZ25pbmcga2V5LlxuICAgIGNvbnN0IHggPSBbc3BsaXRfdVtwU2hhcmUuaV0sIC4uLm5TaGFyZXMubWFwKCh7IHUgfSkgPT4gaGV4VG9CaWdJbnQodSkpXS5yZWR1Y2UoRWNkc2EuY3VydmUuc2NhbGFyQWRkKTtcblxuICAgIC8vIEdlbmVyYXRlIFNjaG5vcnIgcHJvb2Ygb2Yga25vd2xlZGdlIG9mIHRoZSBkaXNjcmV0ZSBsb2cgb2YgWCA9IHhHLlxuICAgIGNvbnN0IFggPSBFY2RzYS5jdXJ2ZS5iYXNlUG9pbnRNdWx0KHgpO1xuXG4gICAgY29uc3QgcHJvb2ZDb250ZXh0ID0gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUoc3Via2V5LnBrLCBFY2RzYS5jdXJ2ZS5wb2ludEJ5dGVzKSkuZGlnZXN0KCk7XG5cbiAgICBjb25zdCBzY2hub3JyUHJvb2ZYID0gU2Nobm9yci5jcmVhdGVTY2hub3JyUHJvb2YoWCwgeCwgRWNkc2EuY3VydmUsIHByb29mQ29udGV4dCk7XG5cbiAgICBjb25zdCBQX2k6IFhTaGFyZSA9IHtcbiAgICAgIGk6IHBTaGFyZS5pLFxuICAgICAgbDogcFNoYXJlLmwsXG4gICAgICBtOiBwU2hhcmUubSxcbiAgICAgIG46IHBTaGFyZS5uLFxuICAgICAgeTogYmlnSW50VG9CdWZmZXJCRShzdWJrZXkucGssIDMzKS50b1N0cmluZygnaGV4JyksXG4gICAgICB4OiBiaWdJbnRUb0J1ZmZlckJFKHgsIDMyKS50b1N0cmluZygnaGV4JyksXG4gICAgICBzY2hub3JyUHJvb2ZYOiBzY2hub3JyUHJvb2ZYLFxuICAgICAgY2hhaW5jb2RlOiBiaWdJbnRUb0J1ZmZlckJFKHN1YmtleS5jaGFpbmNvZGUsIDMyKS50b1N0cmluZygnaGV4JyksXG4gICAgfTtcblxuICAgIGNvbnN0IHNoYXJlczogU3Via2V5U2hhcmUgPSB7XG4gICAgICB4U2hhcmU6IFBfaSxcbiAgICAgIG5TaGFyZXM6IHt9LFxuICAgIH07XG5cbiAgICBmb3IgKGxldCBpbmQgPSAwOyBpbmQgPCBuU2hhcmVzLmxlbmd0aDsgaW5kKyspIHtcbiAgICAgIGNvbnN0IFBfaiA9IG5TaGFyZXNbaW5kXTtcbiAgICAgIHNoYXJlcy5uU2hhcmVzW1Bfai5qXSA9IHtcbiAgICAgICAgaTogUF9qLmosXG4gICAgICAgIGo6IFBfaS5pLFxuICAgICAgICBuOiBQX2kubixcbiAgICAgICAgdTogYmlnSW50VG9CdWZmZXJCRShzcGxpdF91W1Bfai5qXSwgMzIpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgeTogYmlnSW50VG9CdWZmZXJCRShjb250cmliWSwgMzIpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgdjogYmlnSW50VG9CdWZmZXJCRSh2WzBdLCAzMikudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICBjaGFpbmNvZGU6IGJpZ0ludFRvQnVmZmVyQkUoY29udHJpYkNoYWluY29kZSwgMzIpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYXJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgU2Nobm9yciBwcm9vZiBvZiBrbm93bGVkZ2Ugb2YgdGhlIGRpc2NyZXRlIGxvZyBvZiBYX2kgPSB4X2kgKiBHLlxuICAgKiBAcGFyYW0gWSBUaGUgY29tYmluZWQgcHVibGljIGtleS5cbiAgICogQHBhcmFtIFZTU3MgVGhlIFZTUyBzaGFyZXMgcmVjZWl2ZWQgZnJvbSBhbGwgcGFydGljaXBhbnRzLlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGkgb2YgWF9pLlxuICAgKiBAcGFyYW0gcHJvb2YgVGhlIHNjaG5vcnIgcHJvb2YuXG4gICAqIEByZXR1cm5zIFRydWUgaWYgaXQncyBhIHZhbGlkIHByb29mIHdpdGggcmVnYXJkcyB0byBZIGFuZCBWU1NzLlxuICAgKi9cbiAgdmVyaWZ5U2Nobm9yclByb29mWChZOiBiaWdpbnQsIFZTU3M6IGJpZ2ludFtdW10sIGluZGV4OiBudW1iZXIsIHByb29mOiBTY2hub3JyUHJvb2YpOiBib29sZWFuIHtcbiAgICBpZiAoaW5kZXggPCAxIHx8IGluZGV4ID4gVlNTcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBzdXBwbGllZCBmb3IgaW5kZXgnKTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgWF9pIGZyb20gcHVibGljIGluZm9ybWF0aW9uLlxuICAgIGxldCBYX2kgPSBZO1xuICAgIFZTU3MuZm9yRWFjaCgoVlNTKSA9PiB7XG4gICAgICBWU1MuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICBYX2kgPSBFY2RzYS5jdXJ2ZS5wb2ludEFkZChYX2ksIEVjZHNhLmN1cnZlLnBvaW50TXVsdGlwbHkodiwgQmlnSW50KGluZGV4KSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBwcm9vZkNvbnRleHQgPSBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShZLCBFY2RzYS5jdXJ2ZS5wb2ludEJ5dGVzKSkuZGlnZXN0KCk7XG4gICAgcmV0dXJuIFNjaG5vcnIudmVyaWZ5U2Nobm9yclByb29mKFhfaSwgcHJvb2YsIEVjZHNhLmN1cnZlLCBwcm9vZkNvbnRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcml2ZXMgYSBjaGlsZCBjb21tb24ga2V5Y2hhaW4gZnJvbSBjb21tb24ga2V5Y2hhaW5cbiAgICpcbiAgICogQHBhcmFtIHtjb21tb25LZXljaGFpbn0gVGhlIGNvbW1vbiBrZXljaGFpbiBhcyBhIGhleCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7cGF0aH0gVGhlIEJJUC0zMiBwYXRoIHRvIGRlcml2ZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgZGVyaXZlZCBjb21tb24ga2V5Y2hhaW4gYXMgYSBoZXggc3RyaW5nLlxuICAgKi9cbiAgZGVyaXZlVW5oYXJkZW5lZChjb21tb25LZXljaGFpbjogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChFY2RzYS5oZFRyZWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZGVyaXZlIGtleSB3aXRob3V0IEhEVHJlZSBpbXBsZW1lbnRhdGlvblwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXljaGFpbiA9IEJ1ZmZlci5mcm9tKGNvbW1vbktleWNoYWluLCAnaGV4Jyk7XG5cbiAgICBjb25zdCBkZXJpdmVkUHVibGljS2V5Y2hhaW4gPSBFY2RzYS5oZFRyZWUucHVibGljRGVyaXZlKFxuICAgICAge1xuICAgICAgICBwazogYmlnSW50RnJvbUJ1ZmZlckJFKGtleWNoYWluLnNsaWNlKDAsIDMzKSksXG4gICAgICAgIGNoYWluY29kZTogYmlnSW50RnJvbUJ1ZmZlckJFKGtleWNoYWluLnNsaWNlKDMzKSksXG4gICAgICB9LFxuICAgICAgcGF0aFxuICAgICk7XG5cbiAgICBjb25zdCBkZXJpdmVkUGsgPSBiaWdJbnRUb0J1ZmZlckJFKGRlcml2ZWRQdWJsaWNLZXljaGFpbi5waywgMzMpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCBkZXJpdmVkQ2hhaW5jb2RlID0gYmlnSW50VG9CdWZmZXJCRShkZXJpdmVkUHVibGljS2V5Y2hhaW4uY2hhaW5jb2RlLCAzMikudG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgcmV0dXJuIGRlcml2ZWRQayArIGRlcml2ZWRDaGFpbmNvZGU7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyBhIGdpdmVuIHJhbmdlIHByb29mIGNoYWxsZW5nZSB0byB0aGUgc2hhcmVzIHByZXZpb3VzbHkgY3JlYXRlZFxuICAgKiBieSAja2V5Q29tYmluZS4gR2VuZXJhdGVzIGEgbmV3IGNoYWxsZW5nZSBpZiBub3QgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSB7WFNoYXJlIHwgWVNoYXJlfSBzaGFyZSBQcml2YXRlIHhTaGFyZSBvciB5U2hhcmUgb2YgdGhlIHNpZ25pbmcgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSByYW5nZVByb29mQ2hhbGxlbmdlIC0gY2hhbGxlbmdlIGdlbmVyYXRlZCB2aWEgZ2VuZXJhdGVOdGlsZGVcbiAgICogQHBhcmFtIHBhaWxsaWVyUHJvb2ZDaGFsbGVuZ2VcbiAgICogQHJldHVybnMge0tleUNvbWJpbmVkfSBUaGUgc2hhcmUgd2l0aCBhbWVuZGVkIGNoYWxsZW5nZSB2YWx1ZXNcbiAgICovXG4gIGFwcGVuZENoYWxsZW5nZTxUPihcbiAgICBzaGFyZTogVCxcbiAgICByYW5nZVByb29mQ2hhbGxlbmdlOiBFY2RzYVR5cGVzLlNlcmlhbGl6ZWROdGlsZGUsXG4gICAgcGFpbGxpZXJQcm9vZkNoYWxsZW5nZTogRWNkc2FUeXBlcy5TZXJpYWxpemVkUGFpbGxpZXJDaGFsbGVuZ2VcbiAgKTogVCAmIEVjZHNhVHlwZXMuU2VyaWFsaXplZEVjZHNhQ2hhbGxlbmdlcyB7XG4gICAgY29uc3QgeyBudGlsZGUsIGgxLCBoMiB9ID0gcmFuZ2VQcm9vZkNoYWxsZW5nZTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2hhcmUsXG4gICAgICBudGlsZGUsXG4gICAgICBoMSxcbiAgICAgIGgyLFxuICAgICAgcDogcGFpbGxpZXJQcm9vZkNoYWxsZW5nZS5wLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHNpZ25pbmcgc2hhcmVzLlxuICAgKiBAcGFyYW0ge3hTaGFyZX0geFNoYXJlIFByaXZhdGUgeFNoYXJlIG9mIGN1cnJlbnQgcGFydGljaXBhbnQgc2lnbmVyXG4gICAqIEBwYXJhbSB7WVNoYXJlfSB5U2hhcmUgeVNoYXJlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG90aGVyIHBhcnRpY2lwYW50IHNpZ25lclxuICAgKiBAcmV0dXJucyB7U2lnblNoYXJlUlR9IFJldHVybnMgdGhlIHBhcnRpY2lwYW50IHByaXZhdGUgdy1zaGFyZVxuICAgKiBhbmQgay1zaGFyZSB0byBiZSBkaXN0cmlidXRlZCB0byBvdGhlciBwYXJ0aWNpcGFudCBzaWduZXJcbiAgICovXG4gIGFzeW5jIHNpZ25TaGFyZSh4U2hhcmU6IFhTaGFyZVdpdGhDaGFsbGVuZ2VzLCB5U2hhcmU6IFlTaGFyZVdpdGhDaGFsbGVuZ2VzKTogUHJvbWlzZTxTaWduU2hhcmVSVD4ge1xuICAgIGNvbnN0IHBrID0gZ2V0UGFpbGxpZXJQdWJsaWNLZXkoaGV4VG9CaWdJbnQoeFNoYXJlLm4pKTtcblxuICAgIGNvbnN0IGsgPSBFY2RzYS5jdXJ2ZS5zY2FsYXJSYW5kb20oKTtcbiAgICBjb25zdCByayA9IGF3YWl0IHJhbmRvbVBvc2l0aXZlQ29QcmltZVRvKHBrLm4pO1xuICAgIGNvbnN0IGNrID0gcGsuZW5jcnlwdChrLCByayk7XG4gICAgY29uc3QgZ2FtbWEgPSBFY2RzYS5jdXJ2ZS5zY2FsYXJSYW5kb20oKTtcblxuICAgIGNvbnN0IGQgPSBFY2RzYS5jdXJ2ZS5zY2FsYXJNdWx0KEVjZHNhLmN1cnZlLnNjYWxhclN1YihCaWdJbnQoeVNoYXJlLmopLCBCaWdJbnQoeFNoYXJlLmkpKSwgQmlnSW50KHhTaGFyZS5pKSk7XG5cbiAgICBjb25zdCB3ID0gW1xuICAgICAgRWNkc2EuY3VydmUuc2NhbGFyTXVsdChCaWdJbnQoeVNoYXJlLmopLCBCaWdJbnQoeFNoYXJlLmkpKSxcbiAgICAgIGhleFRvQmlnSW50KHhTaGFyZVsneCddKSxcbiAgICAgIEVjZHNhLmN1cnZlLnNjYWxhckludmVydChkKSxcbiAgICBdLnJlZHVjZShFY2RzYS5jdXJ2ZS5zY2FsYXJNdWx0KTtcblxuICAgIGNvbnN0IHsgbnRpbGRlOiBudGlsZGVhLCBoMTogaDFhLCBoMjogaDJhIH0gPSB4U2hhcmU7XG5cbiAgICBjb25zdCB3U2hhcmU6IFdTaGFyZSA9IHtcbiAgICAgIGk6IHhTaGFyZS5pLFxuICAgICAgbDogeFNoYXJlLmwsXG4gICAgICBtOiB4U2hhcmUubSxcbiAgICAgIG46IHhTaGFyZS5uLFxuICAgICAgeTogeFNoYXJlLnksXG4gICAgICBudGlsZGU6IG50aWxkZWEsXG4gICAgICBoMTogaDFhLFxuICAgICAgaDI6IGgyYSxcbiAgICAgIHA6IHhTaGFyZS5wLFxuICAgICAgazogYmlnSW50VG9CdWZmZXJCRShrLCAzMikudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgY2s6IGJpZ0ludFRvQnVmZmVyQkUoY2ssIDc2OCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgdzogYmlnSW50VG9CdWZmZXJCRSh3LCAzMikudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgZ2FtbWE6IGJpZ0ludFRvQnVmZmVyQkUoZ2FtbWEsIDMyKS50b1N0cmluZygnaGV4JyksXG4gICAgfTtcblxuICAgIGNvbnN0IHsgbnRpbGRlOiBudGlsZGViLCBoMTogaDFiLCBoMjogaDJiIH0gPSB5U2hhcmU7XG4gICAgY29uc3QgcHJvb2YgPSBhd2FpdCBFY2RzYVJhbmdlUHJvb2YucHJvdmUoXG4gICAgICBFY2RzYS5jdXJ2ZSxcbiAgICAgIG1pbk1vZHVsdXNCaXRMZW5ndGgsXG4gICAgICBwayxcbiAgICAgIHtcbiAgICAgICAgbnRpbGRlOiBoZXhUb0JpZ0ludChudGlsZGViKSxcbiAgICAgICAgaDE6IGhleFRvQmlnSW50KGgxYiksXG4gICAgICAgIGgyOiBoZXhUb0JpZ0ludChoMmIpLFxuICAgICAgfSxcbiAgICAgIGNrLFxuICAgICAgayxcbiAgICAgIHJrXG4gICAgKTtcblxuICAgIC8vIGNyZWF0ZSBwYWlsbGllciBjaGFsbGVuZ2UgcHJvb2YgYmFzZWQgb24gdGhlIG90aGVyIHNpZ25lcnMgY2hhbGxlbmdlXG4gICAgLy8gb25seSBzZW5kIHNpZ21hIGlmIHdlIGFsc28gc2VuZCBjaGFsbGVuZ2UgcFxuICAgIGNvbnN0IHNpZ21hID0gRWNkc2FQYWlsbGllclByb29mLnByb3ZlKFxuICAgICAgaGV4VG9CaWdJbnQoeFNoYXJlLm4pLFxuICAgICAgaGV4VG9CaWdJbnQoeFNoYXJlLmwpLFxuICAgICAgRWNkc2FUeXBlcy5kZXNlcmlhbGl6ZVBhaWxsaWVyQ2hhbGxlbmdlKHsgcDogeVNoYXJlLnAgfSkucFxuICAgICk7XG5cbiAgICBjb25zdCBwcm9vZlNoYXJlID0ge1xuICAgICAgejogYmlnSW50VG9CdWZmZXJCRShwcm9vZi56LCAzODQpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHU6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudSwgNzY4KS50b1N0cmluZygnaGV4JyksXG4gICAgICB3OiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLncsIDM4NCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgczogYmlnSW50VG9CdWZmZXJCRShwcm9vZi5zLCAzODQpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHMxOiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnMxLCA5NikudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgczI6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YuczIsIDQ4MCkudG9TdHJpbmcoJ2hleCcpLFxuICAgIH07XG5cbiAgICBjb25zdCBrU2hhcmU6IEtTaGFyZSA9IHtcbiAgICAgIC8vIHRoaXMgc2hhcmUgd2lsbCBiZSBzZW50IHRvIHRoZSBvdGhlciBwYXJ0aWNpcGFudCxcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gc3dhcCB0aGUgaSBhbmQgaiB2YWx1ZXMgaGVyZVxuICAgICAgLy8gc28gdGhhdCB0aGV5IGtub3cgaXQncyB0aGVpciBrU2hhcmUsIHByb2R1Y2VkIGJ5IHVzXG4gICAgICBpOiB5U2hhcmUuaixcbiAgICAgIGo6IHhTaGFyZS5pLFxuICAgICAgbjogcGsubi50b1N0cmluZygxNiksXG4gICAgICBudGlsZGU6IG50aWxkZWEsXG4gICAgICBoMTogaDFhLFxuICAgICAgaDI6IGgyYSxcbiAgICAgIHA6IHhTaGFyZS5wLFxuICAgICAgazogYmlnSW50VG9CdWZmZXJCRShjaywgNzY4KS50b1N0cmluZygnaGV4JyksXG4gICAgICBzaWdtYTogRWNkc2FUeXBlcy5zZXJpYWxpemVQYWlsbGllckNoYWxsZW5nZVByb29mcyh7IHNpZ21hOiBzaWdtYSB9KS5zaWdtYSxcbiAgICAgIHByb29mOiBwcm9vZlNoYXJlLFxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgd1NoYXJlLFxuICAgICAga1NoYXJlLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBtdWx0aXBsaWNpdGl2ZS10by1hZGRpdGl2ZSAoTXRBKSBzaGFyZSBjb252ZXJzaW9uIHdpdGggYW5vdGhlciBzaWduZXIuXG4gICAqIENvbm5lY3Rpb24gMS4yIGluIGh0dHBzOi8vbHVjaWQuYXBwL2x1Y2lkY2hhcnQvNzA2MTc4NWItYmM1Yy00MDAyLWI1NDYtM2Y0YTM2MTJmYzYyL2VkaXQ/cGFnZT1JQVZtdllPNEZ2S2MjXG4gICAqIElmIHNpZ25lciBBIGNvbXBsZXRlZCBzaWduU2hhcmUgaW5pdGlhbGx5IChpbnB1dCB0byB0aGlzIGZuKSwgdGhlbiB0aGlzIHN0ZXAgaXMgY29tcGxldGVkIGJ5IHNpZ25lciBCLlxuICAgKiBAcGFyYW0ge1NpZ25Db252ZXJ0fSBzaGFyZXNcbiAgICogQHJldHVybnMge1NpZ25Db252ZXJ0UlR9XG4gICAqL1xuICBhc3luYyBzaWduQ29udmVydFN0ZXAxKHNoYXJlczogU2lnbkNvbnZlcnRTdGVwMSk6IFByb21pc2U8U2lnbkNvbnZlcnRTdGVwMVJlc3BvbnNlPiB7XG4gICAgY29uc3QgcmVjZWl2ZWRLU2hhcmUgPSBzaGFyZXMua1NoYXJlO1xuICAgIGNvbnN0IHhTaGFyZSA9IHNoYXJlcy54U2hhcmU7IC8vIGN1cnJlbnRQYXJ0aWNpcGFudCBzZWNyZXQgeFNoYXJlXG4gICAgY29uc3QgeVNoYXJlOiBZU2hhcmVXaXRoQ2hhbGxlbmdlcyA9IHtcbiAgICAgIC4uLnNoYXJlcy55U2hhcmUsXG4gICAgICBudGlsZGU6IHJlY2VpdmVkS1NoYXJlLm50aWxkZSxcbiAgICAgIGgxOiByZWNlaXZlZEtTaGFyZS5oMSxcbiAgICAgIGgyOiByZWNlaXZlZEtTaGFyZS5oMixcbiAgICAgIHA6IHJlY2VpdmVkS1NoYXJlLnAsXG4gICAgfTtcbiAgICBjb25zdCBzaWduU2hhcmUgPSBhd2FpdCB0aGlzLnNpZ25TaGFyZSh4U2hhcmUsIHlTaGFyZSk7XG4gICAgY29uc3Qgc2hhcmVQYXJ0aWNpcGFudCA9IHNpZ25TaGFyZS53U2hhcmU7XG5cbiAgICBpZiAoc2hhcmVQYXJ0aWNpcGFudC5pICE9PSByZWNlaXZlZEtTaGFyZS5pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXJlcyBmcm9tIHNhbWUgcGFydGljaXBhbnQnKTtcbiAgICB9XG4gICAgaWYgKCFyZWNlaXZlZEtTaGFyZS5wcm9vZikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIG1pc3NpbmcgcHJvb2Ygb24gYVNoYXJlVG9CZVNlbnQnKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgb3RoZXIgcGFydGljaXBhbnRzIHBhaWxsaWVyIHB1YmxpYyBrZXlcbiAgICBjb25zdCBuID0gaGV4VG9CaWdJbnQocmVjZWl2ZWRLU2hhcmUubik7XG4gICAgY29uc3QgcGthID0gZ2V0UGFpbGxpZXJQdWJsaWNLZXkobik7XG4gICAgLy8gdGhlIG90aGVyIHBhcnRpY2lwYW50J3MgcmFuZ2UgcHJvb2YgY2hhbGxlbmdlXG4gICAgY29uc3QgbnRpbGRlYSA9IGhleFRvQmlnSW50KHJlY2VpdmVkS1NoYXJlLm50aWxkZSk7XG4gICAgY29uc3QgaDFhID0gaGV4VG9CaWdJbnQocmVjZWl2ZWRLU2hhcmUuaDEpO1xuICAgIGNvbnN0IGgyYSA9IGhleFRvQmlnSW50KHJlY2VpdmVkS1NoYXJlLmgyKTtcblxuICAgIC8vIHRoZSBjdXJyZW50IHBhcnRpY2lwYW50J3MgcmFuZ2UgcHJvb2YgY2hhbGxlbmdlXG4gICAgY29uc3QgbnRpbGRlYiA9IGhleFRvQmlnSW50KHNoYXJlUGFydGljaXBhbnQubnRpbGRlKTtcbiAgICBjb25zdCBoMWIgPSBoZXhUb0JpZ0ludChzaGFyZVBhcnRpY2lwYW50LmgxKTtcbiAgICBjb25zdCBoMmIgPSBoZXhUb0JpZ0ludChzaGFyZVBhcnRpY2lwYW50LmgyKTtcblxuICAgIGNvbnN0IGsgPSBoZXhUb0JpZ0ludChyZWNlaXZlZEtTaGFyZS5rKTtcblxuICAgIC8vIHRoZSBjdXJyZW50IHBhcnRpY2lwYW50cyBwYWlsbGllciBwcm9vZiBjaGFsbGVuZ2VcbiAgICBjb25zdCBzaGFyZVBhcnRpY2lwYW50UGFpbGxpZXJDaGFsbGVuZ2UgPSBFY2RzYVR5cGVzLmRlc2VyaWFsaXplUGFpbGxpZXJDaGFsbGVuZ2UoeyBwOiBzaGFyZVBhcnRpY2lwYW50LnAgfSk7XG4gICAgLy8gdGhlIG90aGVyIHNpZ25pbmcgcGFydGllcyBwcm9vZiB0byB0aGUgY3VycmVudCBwYXJ0aWNpcGFudHMgcGFpbGxpZXIgcHJvb2YgY2hhbGxlbmdlXG4gICAgY29uc3QgcmVjZWl2ZWRQYWlsbGllckNoYWxsZW5nZVByb29mID0gRWNkc2FUeXBlcy5kZXNlcmlhbGl6ZVBhaWxsaWVyQ2hhbGxlbmdlUHJvb2ZzKHtcbiAgICAgIHNpZ21hOiByZWNlaXZlZEtTaGFyZS5zaWdtYSxcbiAgICB9KTtcbiAgICBpZiAoXG4gICAgICAhKGF3YWl0IEVjZHNhUGFpbGxpZXJQcm9vZi52ZXJpZnkobiwgc2hhcmVQYXJ0aWNpcGFudFBhaWxsaWVyQ2hhbGxlbmdlLnAsIHJlY2VpdmVkUGFpbGxpZXJDaGFsbGVuZ2VQcm9vZi5zaWdtYSkpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCB2ZXJpZnkgc2lnbmluZyBBIHNoYXJlIHBhaWxsaWVyIHByb29mJyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIUVjZHNhUmFuZ2VQcm9vZi52ZXJpZnkoXG4gICAgICAgIEVjZHNhLmN1cnZlLFxuICAgICAgICBtaW5Nb2R1bHVzQml0TGVuZ3RoLFxuICAgICAgICBwa2EsXG4gICAgICAgIHtcbiAgICAgICAgICBudGlsZGU6IG50aWxkZWIsXG4gICAgICAgICAgaDE6IGgxYixcbiAgICAgICAgICBoMjogaDJiLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgejogaGV4VG9CaWdJbnQocmVjZWl2ZWRLU2hhcmUucHJvb2YueiksXG4gICAgICAgICAgdTogaGV4VG9CaWdJbnQocmVjZWl2ZWRLU2hhcmUucHJvb2YudSksXG4gICAgICAgICAgdzogaGV4VG9CaWdJbnQocmVjZWl2ZWRLU2hhcmUucHJvb2YudyksXG4gICAgICAgICAgczogaGV4VG9CaWdJbnQocmVjZWl2ZWRLU2hhcmUucHJvb2YucyksXG4gICAgICAgICAgczE6IGhleFRvQmlnSW50KHJlY2VpdmVkS1NoYXJlLnByb29mLnMxKSxcbiAgICAgICAgICBzMjogaGV4VG9CaWdJbnQocmVjZWl2ZWRLU2hhcmUucHJvb2YuczIpLFxuICAgICAgICB9LFxuICAgICAgICBrXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCB2ZXJpZnkgc2lnbmluZyBBIHNoYXJlIHByb29mJyk7XG4gICAgfVxuICAgIC8vIE10QSAka19qLCBcXGdhbW1hX2kkLlxuICAgIGNvbnN0IGJldGEwID0gYmlnaW50Q3J5cHRvVXRpbHMucmFuZEJldHdlZW4oRWNkc2EuY3VydmUub3JkZXIoKSAqKiBfNW4pO1xuICAgIGNvbnN0IGJldGEgPSBiaWdJbnRUb0J1ZmZlckJFKEVjZHNhLmN1cnZlLnNjYWxhck5lZ2F0ZShFY2RzYS5jdXJ2ZS5zY2FsYXJSZWR1Y2UoYmV0YTApKSwgMzIpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCBnID0gaGV4VG9CaWdJbnQoc2hhcmVQYXJ0aWNpcGFudC5nYW1tYSk7XG4gICAgY29uc3QgcmIgPSBhd2FpdCByYW5kb21Qb3NpdGl2ZUNvUHJpbWVUbyhwa2Eubik7XG4gICAgY29uc3QgY2IgPSBwa2EuZW5jcnlwdChiZXRhMCwgcmIpO1xuICAgIGNvbnN0IGFscGhhID0gcGthLmFkZGl0aW9uKHBrYS5tdWx0aXBseShrLCBnKSwgY2IpO1xuICAgIGNvbnN0IGFscGhhVG9CZVNlbnQgPSBiaWdJbnRUb0J1ZmZlckJFKGFscGhhLCBBTFBIQU1VU0laRSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIC8vIFByb3ZlICRcXGdhbW1hX2kgXFxpbiBaX3tOXjJ9JC5cbiAgICBjb25zdCBneCA9IEVjZHNhLmN1cnZlLmJhc2VQb2ludE11bHQoZyk7XG4gICAgbGV0IHByb29mID0gYXdhaXQgRWNkc2FSYW5nZVByb29mLnByb3ZlV2l0aENoZWNrKFxuICAgICAgRWNkc2EuY3VydmUsXG4gICAgICBtaW5Nb2R1bHVzQml0TGVuZ3RoLFxuICAgICAgcGthLFxuICAgICAge1xuICAgICAgICBudGlsZGU6IG50aWxkZWEsXG4gICAgICAgIGgxOiBoMWEsXG4gICAgICAgIGgyOiBoMmEsXG4gICAgICB9LFxuICAgICAgayxcbiAgICAgIGFscGhhLFxuICAgICAgZyxcbiAgICAgIGJldGEwLFxuICAgICAgcmIsXG4gICAgICBneFxuICAgICk7XG4gICAgY29uc3QgZ2FtbWFQcm9vZlRvQmVTZW50OiBSYW5nZVByb29mV2l0aENoZWNrU2hhcmUgPSB7XG4gICAgICB6OiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnosIDM4NCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgenBybTogYmlnSW50VG9CdWZmZXJCRShwcm9vZi56cHJtLCAzODQpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHQ6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudCwgMzg0KS50b1N0cmluZygnaGV4JyksXG4gICAgICB2OiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnYsIDc2OCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgdzogYmlnSW50VG9CdWZmZXJCRShwcm9vZi53LCAzODQpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHM6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YucywgMzg0KS50b1N0cmluZygnaGV4JyksXG4gICAgICBzMTogYmlnSW50VG9CdWZmZXJCRShwcm9vZi5zMSwgOTYpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHMyOiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnMyLCA0ODApLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHQxOiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnQxLCAyMjQpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHQyOiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnQyLCA0ODApLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHU6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudSwgMzMpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHg6IGJpZ0ludFRvQnVmZmVyQkUoZ3gsIDMzKS50b1N0cmluZygnaGV4JyksXG4gICAgfTtcbiAgICAvLyBNdEEgJGtfaiwgd19pJC5cbiAgICBjb25zdCBudTAgPSBiaWdpbnRDcnlwdG9VdGlscy5yYW5kQmV0d2VlbihFY2RzYS5jdXJ2ZS5vcmRlcigpICoqIF81bik7XG4gICAgY29uc3QgbnUgPSBiaWdJbnRUb0J1ZmZlckJFKEVjZHNhLmN1cnZlLnNjYWxhck5lZ2F0ZShFY2RzYS5jdXJ2ZS5zY2FsYXJSZWR1Y2UobnUwKSksIDMyKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgdyA9IGhleFRvQmlnSW50KHNoYXJlUGFydGljaXBhbnQudyk7XG4gICAgY29uc3Qgcm4gPSBhd2FpdCByYW5kb21Qb3NpdGl2ZUNvUHJpbWVUbyhwa2Eubik7XG4gICAgY29uc3QgY24gPSBwa2EuZW5jcnlwdChudTAsIHJuKTtcbiAgICBjb25zdCBtdSA9IHBrYS5hZGRpdGlvbihwa2EubXVsdGlwbHkoaywgdyksIGNuKTtcbiAgICBjb25zdCBtdVRvQmVTZW50ID0gYmlnSW50VG9CdWZmZXJCRShtdSwgQUxQSEFNVVNJWkUpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAvLyBQcm92ZSAkXFx3X2kgXFxpbiBaX3tOXjJ9JC5cbiAgICBjb25zdCB3eCA9IEVjZHNhLmN1cnZlLmJhc2VQb2ludE11bHQodyk7XG4gICAgcHJvb2YgPSBhd2FpdCBFY2RzYVJhbmdlUHJvb2YucHJvdmVXaXRoQ2hlY2soXG4gICAgICBFY2RzYS5jdXJ2ZSxcbiAgICAgIG1pbk1vZHVsdXNCaXRMZW5ndGgsXG4gICAgICBwa2EsXG4gICAgICB7XG4gICAgICAgIG50aWxkZTogbnRpbGRlYSxcbiAgICAgICAgaDE6IGgxYSxcbiAgICAgICAgaDI6IGgyYSxcbiAgICAgIH0sXG4gICAgICBrLFxuICAgICAgaGV4VG9CaWdJbnQobXVUb0JlU2VudCksXG4gICAgICB3LFxuICAgICAgbnUwLFxuICAgICAgcm4sXG4gICAgICB3eFxuICAgICk7XG4gICAgY29uc3Qgd1Byb29mVG9CZVNlbnQ6IFJhbmdlUHJvb2ZXaXRoQ2hlY2tTaGFyZSA9IHtcbiAgICAgIHo6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YueiwgMzg0KS50b1N0cmluZygnaGV4JyksXG4gICAgICB6cHJtOiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnpwcm0sIDM4NCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgdDogYmlnSW50VG9CdWZmZXJCRShwcm9vZi50LCAzODQpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHY6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudiwgNzY4KS50b1N0cmluZygnaGV4JyksXG4gICAgICB3OiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLncsIDM4NCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgczogYmlnSW50VG9CdWZmZXJCRShwcm9vZi5zLCAzODQpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHMxOiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnMxLCA5NikudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgczI6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YuczIsIDQ4MCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgdDE6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudDEsIDIyNCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgdDI6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudDIsIDQ4MCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgdTogYmlnSW50VG9CdWZmZXJCRShwcm9vZi51LCAzMykudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgeDogYmlnSW50VG9CdWZmZXJCRSh3eCwgMzMpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICB9O1xuXG4gICAgY29uc3QgblRvQmVTZW50ID0gc2lnblNoYXJlLmtTaGFyZS5uO1xuICAgIGNvbnN0IG50aWxkZVRvQmVTZW50ID0gYmlnSW50VG9CdWZmZXJCRShudGlsZGViLCAzODQpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCBoMVRvQmVTZW50ID0gYmlnSW50VG9CdWZmZXJCRShoMWIsIDM4NCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IGgyVG9CZVNlbnQgPSBiaWdJbnRUb0J1ZmZlckJFKGgyYiwgMzg0KS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3Qga1RvQmVTZW50ID0gc2lnblNoYXJlLmtTaGFyZS5rO1xuICAgIGNvbnN0IHByb29mVG9CZVNlbnQgPSBzaWduU2hhcmUua1NoYXJlLnByb29mO1xuICAgIGNvbnN0IFtpVG9CZVNlbnQsIGpUb0JlU2VudF0gPSBbcmVjZWl2ZWRLU2hhcmUuaiwgcmVjZWl2ZWRLU2hhcmUuaV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGFTaGFyZToge1xuICAgICAgICBpOiBpVG9CZVNlbnQsXG4gICAgICAgIGo6IGpUb0JlU2VudCxcbiAgICAgICAgbnRpbGRlOiBudGlsZGVUb0JlU2VudCxcbiAgICAgICAgaDE6IGgxVG9CZVNlbnQsXG4gICAgICAgIGgyOiBoMlRvQmVTZW50LFxuICAgICAgICBuOiBuVG9CZVNlbnQsXG4gICAgICAgIGs6IGtUb0JlU2VudCxcbiAgICAgICAgYWxwaGE6IGFscGhhVG9CZVNlbnQsXG4gICAgICAgIG11OiBtdVRvQmVTZW50LFxuICAgICAgICBwcm9vZjogcHJvb2ZUb0JlU2VudCxcbiAgICAgICAgZ2FtbWFQcm9vZjogZ2FtbWFQcm9vZlRvQmVTZW50LFxuICAgICAgICB3UHJvb2Y6IHdQcm9vZlRvQmVTZW50LFxuICAgICAgICAvLyBwcm92aWRlIHRoZSBzaGFyZSBwYXJ0aWNpcGFudHMgcHJvb2ZcbiAgICAgICAgLy8gdG8gdGhlIHBhaWxsaWVyIGNoYWxsZW5nZSBpbiB0aGUgcmVjZWl2ZWRLU2hhcmUgZnJvbSB0aGUgb3RoZXIgc2lnbmVyXG4gICAgICAgIHNpZ21hOiBzaWduU2hhcmUua1NoYXJlLnNpZ21hLFxuICAgICAgfSxcbiAgICAgIGJTaGFyZToge1xuICAgICAgICAuLi5zaGFyZVBhcnRpY2lwYW50LFxuICAgICAgICBiZXRhLFxuICAgICAgICBudSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIG11bHRpcGxpY2l0aXZlLXRvLWFkZGl0aXZlIChNdEEpIHNoYXJlIGNvbnZlcnNpb24gd2l0aCBhbm90aGVyXG4gICAqIHNpZ25lci5cbiAgICogQ29ubmVjdGlvbiAyLjEgaW4gaHR0cHM6Ly9sdWNpZC5hcHAvbHVjaWRjaGFydC83MDYxNzg1Yi1iYzVjLTQwMDItYjU0Ni0zZjRhMzYxMmZjNjIvZWRpdD9wYWdlPUlBVm12WU80RnZLYyNcbiAgICogSWYgc2lnbmVyIEIgY29tcGxldGVkIHNpZ25Db252ZXJ0U3RlcDEsIHRoZW4gdGhpcyBzdGVwIGlzIGNvbXBsZXRlZCBieSBzaWduZXIgQS5cbiAgICogQHBhcmFtIHtTaWduQ29udmVydH0gc2hhcmVzXG4gICAqIEByZXR1cm5zIHtTaWduQ29udmVydFJUfVxuICAgKi9cbiAgYXN5bmMgc2lnbkNvbnZlcnRTdGVwMihzaGFyZXM6IFNpZ25Db252ZXJ0U3RlcDIpOiBQcm9taXNlPFNpZ25Db252ZXJ0U3RlcDJSZXNwb25zZT4ge1xuICAgIGNvbnN0IHJlY2VpdmVkQVNoYXJlID0gc2hhcmVzLmFTaGFyZTtcbiAgICBpZiAoIXJlY2VpdmVkQVNoYXJlLmdhbW1hUHJvb2YpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBtaXNzaW5nIGdhbW1hUHJvb2Ygb24gYVNoYXJlVG9CZVNlbnQnKTtcbiAgICB9XG4gICAgaWYgKCFyZWNlaXZlZEFTaGFyZS53UHJvb2YpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBtaXNzaW5nIHdQcm9vZiBvbiBhU2hhcmVUb0JlU2VudCcpO1xuICAgIH1cbiAgICBjb25zdCBuID0gaGV4VG9CaWdJbnQocmVjZWl2ZWRBU2hhcmUubik7IC8vIFBhaWxsaWVyIHB1YiBmcm9tIG90aGVyIHNpZ25lclxuICAgIC8vIGN1cnJlbnQgcGFydGljaXBhbnQgcHVibGljIGtleVxuICAgIGNvbnN0IHBrYSA9IGdldFBhaWxsaWVyUHVibGljS2V5KGhleFRvQmlnSW50KHNoYXJlcy53U2hhcmUubikpO1xuICAgIGNvbnN0IG50aWxkZWEgPSBoZXhUb0JpZ0ludChzaGFyZXMud1NoYXJlLm50aWxkZSk7XG4gICAgY29uc3QgaDFhID0gaGV4VG9CaWdJbnQoc2hhcmVzLndTaGFyZS5oMSk7XG4gICAgY29uc3QgaDJhID0gaGV4VG9CaWdJbnQoc2hhcmVzLndTaGFyZS5oMik7XG4gICAgY29uc3QgY2sgPSBoZXhUb0JpZ0ludChzaGFyZXMud1NoYXJlLmNrKTtcblxuICAgIGNvbnN0IHNoYXJlUGFydGljaXBhbnRQYWlsbGllckNoYWxsZW5nZSA9IEVjZHNhVHlwZXMuZGVzZXJpYWxpemVQYWlsbGllckNoYWxsZW5nZSh7IHA6IHNoYXJlcy53U2hhcmUucCB9KTtcbiAgICBjb25zdCByZWNlaXZlZFBhaWxsaWVyQ2hhbGxlbmdlUHJvb2YgPSBFY2RzYVR5cGVzLmRlc2VyaWFsaXplUGFpbGxpZXJDaGFsbGVuZ2VQcm9vZnMoe1xuICAgICAgc2lnbWE6IHNoYXJlcy5hU2hhcmUuc2lnbWEsXG4gICAgfSk7XG4gICAgaWYgKCFFY2RzYVBhaWxsaWVyUHJvb2YudmVyaWZ5KG4sIHNoYXJlUGFydGljaXBhbnRQYWlsbGllckNoYWxsZW5nZS5wLCByZWNlaXZlZFBhaWxsaWVyQ2hhbGxlbmdlUHJvb2Yuc2lnbWEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCB2ZXJpZnkgc2lnbmluZyBzaGFyZSBmb3IgcGFpbGxpZXIgcHJvb2YnKTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgJFxcZ2FtbWFfaSBcXGluIFpfe05eMn0kLlxuICAgIGlmIChcbiAgICAgICFFY2RzYVJhbmdlUHJvb2YudmVyaWZ5V2l0aENoZWNrKFxuICAgICAgICBFY2RzYS5jdXJ2ZSxcbiAgICAgICAgbWluTW9kdWx1c0JpdExlbmd0aCxcbiAgICAgICAgcGthLFxuICAgICAgICB7XG4gICAgICAgICAgbnRpbGRlOiBudGlsZGVhLFxuICAgICAgICAgIGgxOiBoMWEsXG4gICAgICAgICAgaDI6IGgyYSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHo6IGhleFRvQmlnSW50KHJlY2VpdmVkQVNoYXJlLmdhbW1hUHJvb2YueiksXG4gICAgICAgICAgenBybTogaGV4VG9CaWdJbnQocmVjZWl2ZWRBU2hhcmUuZ2FtbWFQcm9vZi56cHJtKSxcbiAgICAgICAgICB0OiBoZXhUb0JpZ0ludChyZWNlaXZlZEFTaGFyZS5nYW1tYVByb29mLnQpLFxuICAgICAgICAgIHY6IGhleFRvQmlnSW50KHJlY2VpdmVkQVNoYXJlLmdhbW1hUHJvb2YudiksXG4gICAgICAgICAgdzogaGV4VG9CaWdJbnQocmVjZWl2ZWRBU2hhcmUuZ2FtbWFQcm9vZi53KSxcbiAgICAgICAgICBzOiBoZXhUb0JpZ0ludChyZWNlaXZlZEFTaGFyZS5nYW1tYVByb29mLnMpLFxuICAgICAgICAgIHMxOiBoZXhUb0JpZ0ludChyZWNlaXZlZEFTaGFyZS5nYW1tYVByb29mLnMxKSxcbiAgICAgICAgICBzMjogaGV4VG9CaWdJbnQocmVjZWl2ZWRBU2hhcmUuZ2FtbWFQcm9vZi5zMiksXG4gICAgICAgICAgdDE6IGhleFRvQmlnSW50KHJlY2VpdmVkQVNoYXJlLmdhbW1hUHJvb2YudDEpLFxuICAgICAgICAgIHQyOiBoZXhUb0JpZ0ludChyZWNlaXZlZEFTaGFyZS5nYW1tYVByb29mLnQyKSxcbiAgICAgICAgICB1OiBoZXhUb0JpZ0ludChyZWNlaXZlZEFTaGFyZS5nYW1tYVByb29mLnUpLFxuICAgICAgICB9LFxuICAgICAgICBjayxcbiAgICAgICAgaGV4VG9CaWdJbnQocmVjZWl2ZWRBU2hhcmUuYWxwaGEpLFxuICAgICAgICBoZXhUb0JpZ0ludChyZWNlaXZlZEFTaGFyZS5nYW1tYVByb29mLngpXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCB2ZXJpZnkgc2lnbmluZyBzaGFyZSBmb3IgZ2FtbWEgcHJvb2YnKTtcbiAgICB9XG4gICAgLy8gVmVyaWZ5ICRcXHdfaSBcXGluIFpfe05eMn0kLlxuICAgIGlmIChcbiAgICAgICFFY2RzYVJhbmdlUHJvb2YudmVyaWZ5V2l0aENoZWNrKFxuICAgICAgICBFY2RzYS5jdXJ2ZSxcbiAgICAgICAgbWluTW9kdWx1c0JpdExlbmd0aCxcbiAgICAgICAgcGthLFxuICAgICAgICB7XG4gICAgICAgICAgbnRpbGRlOiBudGlsZGVhLFxuICAgICAgICAgIGgxOiBoMWEsXG4gICAgICAgICAgaDI6IGgyYSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHo6IGhleFRvQmlnSW50KHJlY2VpdmVkQVNoYXJlLndQcm9vZi56KSxcbiAgICAgICAgICB6cHJtOiBoZXhUb0JpZ0ludChyZWNlaXZlZEFTaGFyZS53UHJvb2YuenBybSksXG4gICAgICAgICAgdDogaGV4VG9CaWdJbnQocmVjZWl2ZWRBU2hhcmUud1Byb29mLnQpLFxuICAgICAgICAgIHY6IGhleFRvQmlnSW50KHJlY2VpdmVkQVNoYXJlLndQcm9vZi52KSxcbiAgICAgICAgICB3OiBoZXhUb0JpZ0ludChyZWNlaXZlZEFTaGFyZS53UHJvb2YudyksXG4gICAgICAgICAgczogaGV4VG9CaWdJbnQocmVjZWl2ZWRBU2hhcmUud1Byb29mLnMpLFxuICAgICAgICAgIHMxOiBoZXhUb0JpZ0ludChyZWNlaXZlZEFTaGFyZS53UHJvb2YuczEpLFxuICAgICAgICAgIHMyOiBoZXhUb0JpZ0ludChyZWNlaXZlZEFTaGFyZS53UHJvb2YuczIpLFxuICAgICAgICAgIHQxOiBoZXhUb0JpZ0ludChyZWNlaXZlZEFTaGFyZS53UHJvb2YudDEpLFxuICAgICAgICAgIHQyOiBoZXhUb0JpZ0ludChyZWNlaXZlZEFTaGFyZS53UHJvb2YudDIpLFxuICAgICAgICAgIHU6IGhleFRvQmlnSW50KHJlY2VpdmVkQVNoYXJlLndQcm9vZi51KSxcbiAgICAgICAgfSxcbiAgICAgICAgY2ssXG4gICAgICAgIGhleFRvQmlnSW50KHJlY2VpdmVkQVNoYXJlLm11KSxcbiAgICAgICAgaGV4VG9CaWdJbnQocmVjZWl2ZWRBU2hhcmUud1Byb29mLngpXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCB2ZXJpZnkgc2hhcmUgZm9yIHdQcm9vZicpO1xuICAgIH1cbiAgICBjb25zdCBzayA9IG5ldyBwYWlsbGllckJpZ2ludC5Qcml2YXRlS2V5KGhleFRvQmlnSW50KHNoYXJlcy53U2hhcmUubCksIGhleFRvQmlnSW50KHNoYXJlcy53U2hhcmUubSksIHBrYSk7XG5cbiAgICBjb25zdCBnU2hhcmVBbHBoYSA9IGJpZ0ludFRvQnVmZmVyQkUoXG4gICAgICBFY2RzYS5jdXJ2ZS5zY2FsYXJSZWR1Y2Uoc2suZGVjcnlwdChoZXhUb0JpZ0ludChyZWNlaXZlZEFTaGFyZS5hbHBoYSkpKSxcbiAgICAgIDMyXG4gICAgKS50b1N0cmluZygnaGV4Jyk7XG5cbiAgICBjb25zdCBnU2hhcmVNdSA9IGJpZ0ludFRvQnVmZmVyQkUoXG4gICAgICBFY2RzYS5jdXJ2ZS5zY2FsYXJSZWR1Y2Uoc2suZGVjcnlwdChoZXhUb0JpZ0ludChyZWNlaXZlZEFTaGFyZS5tdSkpKSwgLy8gcmVjaGVjayBlbmNyeXB0ZWQgbnVtYmVyXG4gICAgICAzMlxuICAgICkudG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgaWYgKCFyZWNlaXZlZEFTaGFyZS5wcm9vZikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIG1pc3NpbmcgcHJvb2Ygb24gYVNoYXJlVG9CZVNlbnQnKTtcbiAgICB9XG4gICAgY29uc3QgcGtiID0gZ2V0UGFpbGxpZXJQdWJsaWNLZXkobik7XG4gICAgY29uc3QgbnRpbGRlYiA9IGhleFRvQmlnSW50KHJlY2VpdmVkQVNoYXJlLm50aWxkZSk7XG4gICAgY29uc3QgaDFiID0gaGV4VG9CaWdJbnQocmVjZWl2ZWRBU2hhcmUuaDEpO1xuICAgIGNvbnN0IGgyYiA9IGhleFRvQmlnSW50KHJlY2VpdmVkQVNoYXJlLmgyKTtcbiAgICBjb25zdCBrID0gaGV4VG9CaWdJbnQocmVjZWl2ZWRBU2hhcmUuayk7XG4gICAgaWYgKFxuICAgICAgIUVjZHNhUmFuZ2VQcm9vZi52ZXJpZnkoXG4gICAgICAgIEVjZHNhLmN1cnZlLFxuICAgICAgICBtaW5Nb2R1bHVzQml0TGVuZ3RoLFxuICAgICAgICBwa2IsXG4gICAgICAgIHtcbiAgICAgICAgICBudGlsZGU6IG50aWxkZWEsXG4gICAgICAgICAgaDE6IGgxYSxcbiAgICAgICAgICBoMjogaDJhLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgejogaGV4VG9CaWdJbnQocmVjZWl2ZWRBU2hhcmUucHJvb2YueiksXG4gICAgICAgICAgdTogaGV4VG9CaWdJbnQocmVjZWl2ZWRBU2hhcmUucHJvb2YudSksXG4gICAgICAgICAgdzogaGV4VG9CaWdJbnQocmVjZWl2ZWRBU2hhcmUucHJvb2YudyksXG4gICAgICAgICAgczogaGV4VG9CaWdJbnQocmVjZWl2ZWRBU2hhcmUucHJvb2YucyksXG4gICAgICAgICAgczE6IGhleFRvQmlnSW50KHJlY2VpdmVkQVNoYXJlLnByb29mLnMxKSxcbiAgICAgICAgICBzMjogaGV4VG9CaWdJbnQocmVjZWl2ZWRBU2hhcmUucHJvb2YuczIpLFxuICAgICAgICB9LFxuICAgICAgICBrXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCB2ZXJpZnkgc2lnbmluZyBBIHNoYXJlIHByb29mJyk7XG4gICAgfVxuICAgIC8vIE10QSAka19qLCBcXGdhbW1hX2kkLlxuICAgIGNvbnN0IGJldGEwID0gYmlnaW50Q3J5cHRvVXRpbHMucmFuZEJldHdlZW4oRWNkc2EuY3VydmUub3JkZXIoKSAqKiBfNW4pO1xuICAgIGNvbnN0IGdTaGFyZUJldGEgPSBiaWdJbnRUb0J1ZmZlckJFKEVjZHNhLmN1cnZlLnNjYWxhck5lZ2F0ZShFY2RzYS5jdXJ2ZS5zY2FsYXJSZWR1Y2UoYmV0YTApKSwgMzIpLnRvU3RyaW5nKCdoZXgnKTtcblxuICAgIGNvbnN0IGcgPSBoZXhUb0JpZ0ludChzaGFyZXMud1NoYXJlLmdhbW1hKTtcbiAgICBjb25zdCByYiA9IGF3YWl0IHJhbmRvbVBvc2l0aXZlQ29QcmltZVRvKHBrYi5uKTtcbiAgICBjb25zdCBjYiA9IHBrYi5lbmNyeXB0KGJldGEwLCByYik7XG4gICAgY29uc3QgYWxwaGEgPSBwa2IuYWRkaXRpb24ocGtiLm11bHRpcGx5KGssIGcpLCBjYik7XG4gICAgY29uc3QgYWxwaGFUb0JlU2VudCA9IGJpZ0ludFRvQnVmZmVyQkUoYWxwaGEsIEFMUEhBTVVTSVpFKS50b1N0cmluZygnaGV4Jyk7XG4gICAgLy8gUHJvdmUgJFxcZ2FtbWFfaSBcXGluIFpfe05eMn0kLlxuICAgIGNvbnN0IGd4ID0gRWNkc2EuY3VydmUuYmFzZVBvaW50TXVsdChnKTtcbiAgICBsZXQgcHJvb2YgPSBhd2FpdCBFY2RzYVJhbmdlUHJvb2YucHJvdmVXaXRoQ2hlY2soXG4gICAgICBFY2RzYS5jdXJ2ZSxcbiAgICAgIG1pbk1vZHVsdXNCaXRMZW5ndGgsXG4gICAgICBwa2IsXG4gICAgICB7XG4gICAgICAgIG50aWxkZTogbnRpbGRlYixcbiAgICAgICAgaDE6IGgxYixcbiAgICAgICAgaDI6IGgyYixcbiAgICAgIH0sXG4gICAgICBrLFxuICAgICAgYWxwaGEsXG4gICAgICBnLFxuICAgICAgYmV0YTAsXG4gICAgICByYixcbiAgICAgIGd4XG4gICAgKTtcbiAgICBjb25zdCBnYW1tYVByb29mVG9CZVNlbnQ6IFJhbmdlUHJvb2ZXaXRoQ2hlY2tTaGFyZSA9IHtcbiAgICAgIHo6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YueiwgMzg0KS50b1N0cmluZygnaGV4JyksXG4gICAgICB6cHJtOiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnpwcm0sIDM4NCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgdDogYmlnSW50VG9CdWZmZXJCRShwcm9vZi50LCAzODQpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHY6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudiwgNzY4KS50b1N0cmluZygnaGV4JyksXG4gICAgICB3OiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLncsIDM4NCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgczogYmlnSW50VG9CdWZmZXJCRShwcm9vZi5zLCAzODQpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHMxOiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnMxLCA5NikudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgczI6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YuczIsIDQ4MCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgdDE6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudDEsIDIyNCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgdDI6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudDIsIDQ4MCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgdTogYmlnSW50VG9CdWZmZXJCRShwcm9vZi51LCAzMykudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgeDogYmlnSW50VG9CdWZmZXJCRShneCwgMzMpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICB9O1xuICAgIC8vIE10QSAka19qLCB3X2kkLlxuICAgIGNvbnN0IG51MCA9IGJpZ2ludENyeXB0b1V0aWxzLnJhbmRCZXR3ZWVuKEVjZHNhLmN1cnZlLm9yZGVyKCkgKiogXzVuKTtcbiAgICBjb25zdCBnU2hhcmVOdSA9IGJpZ0ludFRvQnVmZmVyQkUoRWNkc2EuY3VydmUuc2NhbGFyTmVnYXRlKEVjZHNhLmN1cnZlLnNjYWxhclJlZHVjZShudTApKSwgMzIpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCB3ID0gaGV4VG9CaWdJbnQoc2hhcmVzLndTaGFyZS53KTtcbiAgICBjb25zdCBybiA9IGF3YWl0IHJhbmRvbVBvc2l0aXZlQ29QcmltZVRvKHBrYi5uKTtcbiAgICBjb25zdCBjbiA9IHBrYi5lbmNyeXB0KG51MCwgcm4pO1xuICAgIGNvbnN0IG11ID0gcGtiLmFkZGl0aW9uKHBrYi5tdWx0aXBseShrLCB3KSwgY24pO1xuICAgIGNvbnN0IG11VG9CZVNlbnQgPSBiaWdJbnRUb0J1ZmZlckJFKG11LCBBTFBIQU1VU0laRSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIC8vIFByb3ZlICRcXHdfaSBcXGluIFpfe05eMn0kLlxuICAgIGNvbnN0IHd4ID0gRWNkc2EuY3VydmUuYmFzZVBvaW50TXVsdCh3KTtcbiAgICBwcm9vZiA9IGF3YWl0IEVjZHNhUmFuZ2VQcm9vZi5wcm92ZVdpdGhDaGVjayhcbiAgICAgIEVjZHNhLmN1cnZlLFxuICAgICAgbWluTW9kdWx1c0JpdExlbmd0aCxcbiAgICAgIHBrYixcbiAgICAgIHtcbiAgICAgICAgbnRpbGRlOiBudGlsZGViLFxuICAgICAgICBoMTogaDFiLFxuICAgICAgICBoMjogaDJiLFxuICAgICAgfSxcbiAgICAgIGssXG4gICAgICBoZXhUb0JpZ0ludChtdVRvQmVTZW50KSxcbiAgICAgIHcsXG4gICAgICBudTAsXG4gICAgICBybixcbiAgICAgIHd4XG4gICAgKTtcbiAgICBjb25zdCB3UHJvb2ZUb0JlU2VudDogUmFuZ2VQcm9vZldpdGhDaGVja1NoYXJlID0ge1xuICAgICAgejogYmlnSW50VG9CdWZmZXJCRShwcm9vZi56LCAzODQpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHpwcm06IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YuenBybSwgMzg0KS50b1N0cmluZygnaGV4JyksXG4gICAgICB0OiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnQsIDM4NCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgdjogYmlnSW50VG9CdWZmZXJCRShwcm9vZi52LCA3NjgpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHc6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudywgMzg0KS50b1N0cmluZygnaGV4JyksXG4gICAgICBzOiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnMsIDM4NCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgczE6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YuczEsIDk2KS50b1N0cmluZygnaGV4JyksXG4gICAgICBzMjogYmlnSW50VG9CdWZmZXJCRShwcm9vZi5zMiwgNDgwKS50b1N0cmluZygnaGV4JyksXG4gICAgICB0MTogYmlnSW50VG9CdWZmZXJCRShwcm9vZi50MSwgMjI0KS50b1N0cmluZygnaGV4JyksXG4gICAgICB0MjogYmlnSW50VG9CdWZmZXJCRShwcm9vZi50MiwgNDgwKS50b1N0cmluZygnaGV4JyksXG4gICAgICB1OiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnUsIDMzKS50b1N0cmluZygnaGV4JyksXG4gICAgICB4OiBiaWdJbnRUb0J1ZmZlckJFKHd4LCAzMykudG9TdHJpbmcoJ2hleCcpLFxuICAgIH07XG5cbiAgICBjb25zdCBbaVRvQmVTZW50LCBqVG9CZVNlbnRdID0gW3JlY2VpdmVkQVNoYXJlLmosIHJlY2VpdmVkQVNoYXJlLmldO1xuICAgIHJldHVybiB7XG4gICAgICBtdVNoYXJlOiB7XG4gICAgICAgIGk6IGlUb0JlU2VudCxcbiAgICAgICAgajogalRvQmVTZW50LFxuICAgICAgICBhbHBoYTogYWxwaGFUb0JlU2VudCxcbiAgICAgICAgbXU6IG11VG9CZVNlbnQsXG4gICAgICAgIGdhbW1hUHJvb2Y6IGdhbW1hUHJvb2ZUb0JlU2VudCxcbiAgICAgICAgd1Byb29mOiB3UHJvb2ZUb0JlU2VudCxcbiAgICAgIH0sXG4gICAgICBnU2hhcmU6IHtcbiAgICAgICAgaTogc2hhcmVzLndTaGFyZS5pLFxuICAgICAgICBuOiBzaGFyZXMud1NoYXJlLm4sXG4gICAgICAgIHk6IHNoYXJlcy53U2hhcmUueSxcbiAgICAgICAgazogc2hhcmVzLndTaGFyZS5rLFxuICAgICAgICB3OiBzaGFyZXMud1NoYXJlLncsXG4gICAgICAgIGdhbW1hOiBzaGFyZXMud1NoYXJlLmdhbW1hLFxuICAgICAgICBhbHBoYTogZ1NoYXJlQWxwaGEsXG4gICAgICAgIG11OiBnU2hhcmVNdSxcbiAgICAgICAgYmV0YTogZ1NoYXJlQmV0YSxcbiAgICAgICAgbnU6IGdTaGFyZU51LFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gbXVsdGlwbGljaXRpdmUtdG8tYWRkaXRpdmUgKE10QSkgc2hhcmUgY29udmVyc2lvbiB3aXRoIGFub3RoZXIgc2lnbmVyLlxuICAgKiBDb25uZWN0aW9uIDIuMiBpbiBodHRwczovL2x1Y2lkLmFwcC9sdWNpZGNoYXJ0LzcwNjE3ODViLWJjNWMtNDAwMi1iNTQ2LTNmNGEzNjEyZmM2Mi9lZGl0P3BhZ2U9SUFWbXZZTzRGdktjI1xuICAgKiBJZiBzaWduZXIgQSBjb21wbGV0ZWQgc2lnbkNvbnZlcnRTdGVwMiwgdGhlbiB0aGlzIHN0ZXAgaXMgY29tcGxldGVkIGJ5IHNpZ25lciBCLlxuICAgKiBAcGFyYW0ge1NpZ25Db252ZXJ0fSBzaGFyZXNcbiAgICogQHJldHVybnMge1NpZ25Db252ZXJ0UlR9XG4gICAqL1xuICBhc3luYyBzaWduQ29udmVydFN0ZXAzKHNoYXJlczogU2lnbkNvbnZlcnRTdGVwMyk6IFByb21pc2U8U2lnbkNvbnZlcnRTdGVwM1Jlc3BvbnNlPiB7XG4gICAgY29uc3QgcmVjZWl2ZWRNdVNoYXJlID0gc2hhcmVzLm11U2hhcmU7XG4gICAgaWYgKCFyZWNlaXZlZE11U2hhcmUuZ2FtbWFQcm9vZikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIG1pc3NpbmcgZ2FtbWFQcm9vZiBvbiBhU2hhcmVUb0JlU2VudCcpO1xuICAgIH1cbiAgICBpZiAoIXJlY2VpdmVkTXVTaGFyZS53UHJvb2YpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBtaXNzaW5nIHdQcm9vZiBvbiBhU2hhcmVUb0JlU2VudCcpO1xuICAgIH1cbiAgICBjb25zdCBwa2EgPSBnZXRQYWlsbGllclB1YmxpY0tleShoZXhUb0JpZ0ludChzaGFyZXMuYlNoYXJlLm4pKTtcbiAgICBjb25zdCBudGlsZGVhID0gaGV4VG9CaWdJbnQoc2hhcmVzLmJTaGFyZS5udGlsZGUpO1xuICAgIGNvbnN0IGgxYSA9IGhleFRvQmlnSW50KHNoYXJlcy5iU2hhcmUuaDEpO1xuICAgIGNvbnN0IGgyYSA9IGhleFRvQmlnSW50KHNoYXJlcy5iU2hhcmUuaDIpO1xuICAgIGNvbnN0IGNrID0gaGV4VG9CaWdJbnQoc2hhcmVzLmJTaGFyZS5jayk7XG4gICAgLy8gVmVyaWZ5ICRcXGdhbW1hX2kgXFxpbiBaX3tOXjJ9JC5cbiAgICBpZiAoXG4gICAgICAhRWNkc2FSYW5nZVByb29mLnZlcmlmeVdpdGhDaGVjayhcbiAgICAgICAgRWNkc2EuY3VydmUsXG4gICAgICAgIG1pbk1vZHVsdXNCaXRMZW5ndGgsXG4gICAgICAgIHBrYSxcbiAgICAgICAge1xuICAgICAgICAgIG50aWxkZTogbnRpbGRlYSxcbiAgICAgICAgICBoMTogaDFhLFxuICAgICAgICAgIGgyOiBoMmEsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB6OiBoZXhUb0JpZ0ludChyZWNlaXZlZE11U2hhcmUuZ2FtbWFQcm9vZi56KSxcbiAgICAgICAgICB6cHJtOiBoZXhUb0JpZ0ludChyZWNlaXZlZE11U2hhcmUuZ2FtbWFQcm9vZi56cHJtKSxcbiAgICAgICAgICB0OiBoZXhUb0JpZ0ludChyZWNlaXZlZE11U2hhcmUuZ2FtbWFQcm9vZi50KSxcbiAgICAgICAgICB2OiBoZXhUb0JpZ0ludChyZWNlaXZlZE11U2hhcmUuZ2FtbWFQcm9vZi52KSxcbiAgICAgICAgICB3OiBoZXhUb0JpZ0ludChyZWNlaXZlZE11U2hhcmUuZ2FtbWFQcm9vZi53KSxcbiAgICAgICAgICBzOiBoZXhUb0JpZ0ludChyZWNlaXZlZE11U2hhcmUuZ2FtbWFQcm9vZi5zKSxcbiAgICAgICAgICBzMTogaGV4VG9CaWdJbnQocmVjZWl2ZWRNdVNoYXJlLmdhbW1hUHJvb2YuczEpLFxuICAgICAgICAgIHMyOiBoZXhUb0JpZ0ludChyZWNlaXZlZE11U2hhcmUuZ2FtbWFQcm9vZi5zMiksXG4gICAgICAgICAgdDE6IGhleFRvQmlnSW50KHJlY2VpdmVkTXVTaGFyZS5nYW1tYVByb29mLnQxKSxcbiAgICAgICAgICB0MjogaGV4VG9CaWdJbnQocmVjZWl2ZWRNdVNoYXJlLmdhbW1hUHJvb2YudDIpLFxuICAgICAgICAgIHU6IGhleFRvQmlnSW50KHJlY2VpdmVkTXVTaGFyZS5nYW1tYVByb29mLnUpLFxuICAgICAgICB9LFxuICAgICAgICBjayxcbiAgICAgICAgaGV4VG9CaWdJbnQocmVjZWl2ZWRNdVNoYXJlLmFscGhhKSxcbiAgICAgICAgaGV4VG9CaWdJbnQocmVjZWl2ZWRNdVNoYXJlLmdhbW1hUHJvb2YueClcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHZlcmlmeSBzaWduaW5nIHNoYXJlIGZvciBnYW1tYSBwcm9vZicpO1xuICAgIH1cbiAgICAvLyBWZXJpZnkgJFxcd19pIFxcaW4gWl97Tl4yfSQuXG4gICAgaWYgKFxuICAgICAgIUVjZHNhUmFuZ2VQcm9vZi52ZXJpZnlXaXRoQ2hlY2soXG4gICAgICAgIEVjZHNhLmN1cnZlLFxuICAgICAgICBtaW5Nb2R1bHVzQml0TGVuZ3RoLFxuICAgICAgICBwa2EsXG4gICAgICAgIHtcbiAgICAgICAgICBudGlsZGU6IG50aWxkZWEsXG4gICAgICAgICAgaDE6IGgxYSxcbiAgICAgICAgICBoMjogaDJhLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgejogaGV4VG9CaWdJbnQocmVjZWl2ZWRNdVNoYXJlLndQcm9vZi56KSxcbiAgICAgICAgICB6cHJtOiBoZXhUb0JpZ0ludChyZWNlaXZlZE11U2hhcmUud1Byb29mLnpwcm0pLFxuICAgICAgICAgIHQ6IGhleFRvQmlnSW50KHJlY2VpdmVkTXVTaGFyZS53UHJvb2YudCksXG4gICAgICAgICAgdjogaGV4VG9CaWdJbnQocmVjZWl2ZWRNdVNoYXJlLndQcm9vZi52KSxcbiAgICAgICAgICB3OiBoZXhUb0JpZ0ludChyZWNlaXZlZE11U2hhcmUud1Byb29mLncpLFxuICAgICAgICAgIHM6IGhleFRvQmlnSW50KHJlY2VpdmVkTXVTaGFyZS53UHJvb2YucyksXG4gICAgICAgICAgczE6IGhleFRvQmlnSW50KHJlY2VpdmVkTXVTaGFyZS53UHJvb2YuczEpLFxuICAgICAgICAgIHMyOiBoZXhUb0JpZ0ludChyZWNlaXZlZE11U2hhcmUud1Byb29mLnMyKSxcbiAgICAgICAgICB0MTogaGV4VG9CaWdJbnQocmVjZWl2ZWRNdVNoYXJlLndQcm9vZi50MSksXG4gICAgICAgICAgdDI6IGhleFRvQmlnSW50KHJlY2VpdmVkTXVTaGFyZS53UHJvb2YudDIpLFxuICAgICAgICAgIHU6IGhleFRvQmlnSW50KHJlY2VpdmVkTXVTaGFyZS53UHJvb2YudSksXG4gICAgICAgIH0sXG4gICAgICAgIGNrLFxuICAgICAgICBoZXhUb0JpZ0ludChyZWNlaXZlZE11U2hhcmUubXUpLFxuICAgICAgICBoZXhUb0JpZ0ludChyZWNlaXZlZE11U2hhcmUud1Byb29mLngpXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCB2ZXJpZnkgc2hhcmUgZm9yIHdQcm9vZicpO1xuICAgIH1cbiAgICBjb25zdCBzayA9IG5ldyBwYWlsbGllckJpZ2ludC5Qcml2YXRlS2V5KGhleFRvQmlnSW50KHNoYXJlcy5iU2hhcmUubCksIGhleFRvQmlnSW50KHNoYXJlcy5iU2hhcmUubSksIHBrYSk7XG4gICAgY29uc3QgYWxwaGEgPSBzay5kZWNyeXB0KGhleFRvQmlnSW50KHJlY2VpdmVkTXVTaGFyZS5hbHBoYSkpO1xuICAgIGNvbnN0IGdTaGFyZUFscGhhID0gYmlnSW50VG9CdWZmZXJCRShFY2RzYS5jdXJ2ZS5zY2FsYXJSZWR1Y2UoYWxwaGEpLCAzMikudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IG11ID0gc2suZGVjcnlwdChoZXhUb0JpZ0ludChyZWNlaXZlZE11U2hhcmUubXUgYXMgc3RyaW5nKSk7IC8vIHJlY2hlY2sgZW5jcnlwdGVkIG51bWJlclxuICAgIGNvbnN0IGdTaGFyZU11ID0gYmlnSW50VG9CdWZmZXJCRShFY2RzYS5jdXJ2ZS5zY2FsYXJSZWR1Y2UobXUpLCAzMikudG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgY29uc3QgW2lUb0JlU2VudCwgalRvQmVTZW50XSA9IFtyZWNlaXZlZE11U2hhcmUuaiwgcmVjZWl2ZWRNdVNoYXJlLmldO1xuICAgIHJldHVybiB7XG4gICAgICBnU2hhcmU6IHtcbiAgICAgICAgaTogc2hhcmVzLmJTaGFyZS5pLFxuICAgICAgICBuOiBzaGFyZXMuYlNoYXJlLm4sXG4gICAgICAgIHk6IHNoYXJlcy5iU2hhcmUueSxcbiAgICAgICAgazogc2hhcmVzLmJTaGFyZS5rLFxuICAgICAgICB3OiBzaGFyZXMuYlNoYXJlLncsXG4gICAgICAgIGdhbW1hOiBzaGFyZXMuYlNoYXJlLmdhbW1hLFxuICAgICAgICBhbHBoYTogZ1NoYXJlQWxwaGEsXG4gICAgICAgIG11OiBnU2hhcmVNdSxcbiAgICAgICAgYmV0YTogc2hhcmVzLmJTaGFyZS5iZXRhLFxuICAgICAgICBudTogc2hhcmVzLmJTaGFyZS5udSxcbiAgICAgIH0sXG4gICAgICBzaWduSW5kZXg6IHtcbiAgICAgICAgaTogaVRvQmVTZW50LFxuICAgICAgICBqOiBqVG9CZVNlbnQsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBtdWx0aXBsaWNpdGl2ZS10by1hZGRpdGl2ZSAoTXRBKSBzaGFyZSBjb252ZXJzaW9uIHdpdGggYW5vdGhlciBzaWduZXIuXG4gICAqIEBkZXByZWNhdGVkIC0gdXNlIG9uZSBvZiBbc2lnbkNvbnZlcnRTdGVwMSwgc2lnbkNvbnZlcnRTdGVwMiwgc2lnbkNvbnZlcnRTdGVwM10gaW5zdGVhZFxuICAgKiBAcGFyYW0ge1NpZ25Db252ZXJ0fSBzaGFyZXNcbiAgICogQHJldHVybnMge1NpZ25Db252ZXJ0UlR9XG4gICAqL1xuICBhc3luYyBzaWduQ29udmVydChzaGFyZXM6IFNpZ25Db252ZXJ0KTogUHJvbWlzZTxTaWduQ29udmVydFJUPiB7XG4gICAgbGV0IHNoYXJlUGFydGljaXBhbnQ6IFBhcnRpYWw8QlNoYXJlPiB8IFBhcnRpYWw8R1NoYXJlPiwgc2hhcmVUb0JlU2VudDogUGFydGlhbDxBU2hhcmU+IHwgTVVTaGFyZTtcbiAgICBsZXQgaXNHYW1tYVNoYXJlID0gZmFsc2U7XG4gICAgbGV0IGtTaGFyZTogUGFydGlhbDxLU2hhcmU+ID0ge307XG4gICAgaWYgKHNoYXJlcy54U2hhcmUgJiYgc2hhcmVzLnlTaGFyZSAmJiBzaGFyZXMua1NoYXJlKSB7XG4gICAgICBjb25zdCB4U2hhcmUgPSBzaGFyZXMueFNoYXJlOyAvLyBjdXJyZW50UGFydGljaXBhbnQgc2VjcmV0IHhTaGFyZVxuICAgICAgY29uc3QgeVNoYXJlOiBZU2hhcmVXaXRoQ2hhbGxlbmdlcyA9IHtcbiAgICAgICAgLi4uc2hhcmVzLnlTaGFyZSxcbiAgICAgICAgbnRpbGRlOiBzaGFyZXMua1NoYXJlLm50aWxkZSxcbiAgICAgICAgaDE6IHNoYXJlcy5rU2hhcmUuaDEsXG4gICAgICAgIGgyOiBzaGFyZXMua1NoYXJlLmgyLFxuICAgICAgICBwOiBzaGFyZXMua1NoYXJlLnAsXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2lnblNoYXJlID0gYXdhaXQgdGhpcy5zaWduU2hhcmUoeFNoYXJlLCB5U2hhcmUpO1xuICAgICAga1NoYXJlID0gc2lnblNoYXJlLmtTaGFyZTtcbiAgICAgIHNoYXJlVG9CZVNlbnQgPSB7IC4uLnNoYXJlcy5rU2hhcmUgfSBhcyBQYXJ0aWFsPEFTaGFyZT47XG4gICAgICBzaGFyZVBhcnRpY2lwYW50ID0geyAuLi5zaWduU2hhcmUud1NoYXJlIH0gYXMgUGFydGlhbDxCU2hhcmU+O1xuICAgIH0gZWxzZSBpZiAoKHNoYXJlcy5iU2hhcmUgJiYgc2hhcmVzLm11U2hhcmUpIHx8IChzaGFyZXMuYVNoYXJlICYmIHNoYXJlcy53U2hhcmUpKSB7XG4gICAgICBpc0dhbW1hU2hhcmUgPSB0cnVlO1xuICAgICAgc2hhcmVUb0JlU2VudCA9IHNoYXJlcy5hU2hhcmUgPyAoeyAuLi5zaGFyZXMuYVNoYXJlIH0gYXMgTVVTaGFyZSkgOiAoeyAuLi5zaGFyZXMubXVTaGFyZSB9IGFzIE1VU2hhcmUpO1xuICAgICAgc2hhcmVQYXJ0aWNpcGFudCA9IHNoYXJlcy53U2hhcmUgPyAoeyAuLi5zaGFyZXMud1NoYXJlIH0gYXMgUGFydGlhbDxHU2hhcmU+KSA6ICh7IC4uLnNoYXJlcy5iU2hhcmUgfSBhcyBHU2hhcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29uZmlnIGZvciBTaWduIENvbnZlcnQnKTtcbiAgICB9XG4gICAgaWYgKHNoYXJlUGFydGljaXBhbnQuaSAhPT0gc2hhcmVUb0JlU2VudC5pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXJlcyBmcm9tIHNhbWUgcGFydGljaXBhbnQnKTtcbiAgICB9XG4gICAgaWYgKChzaGFyZVRvQmVTZW50IGFzIEFTaGFyZSkuYWxwaGEpIHtcbiAgICAgIGNvbnN0IGJTaGFyZVBhcnRpY2lwYW50ID0gc2hhcmVQYXJ0aWNpcGFudCBhcyBCU2hhcmU7XG4gICAgICBjb25zdCBhU2hhcmVUb0JlU2VudCA9IHNoYXJlVG9CZVNlbnQgYXMgQVNoYXJlO1xuICAgICAgaWYgKCFhU2hhcmVUb0JlU2VudC5nYW1tYVByb29mKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBtaXNzaW5nIGdhbW1hUHJvb2Ygb24gYVNoYXJlVG9CZVNlbnQnKTtcbiAgICAgIH1cbiAgICAgIGlmICghYVNoYXJlVG9CZVNlbnQud1Byb29mKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBtaXNzaW5nIHdQcm9vZiBvbiBhU2hhcmVUb0JlU2VudCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGthID0gZ2V0UGFpbGxpZXJQdWJsaWNLZXkoaGV4VG9CaWdJbnQoYlNoYXJlUGFydGljaXBhbnQubikpO1xuICAgICAgbGV0IG50aWxkZWEsIGgxYSwgaDJhLCBjaztcbiAgICAgIGlmIChiU2hhcmVQYXJ0aWNpcGFudC5udGlsZGUpIHtcbiAgICAgICAgbnRpbGRlYSA9IGhleFRvQmlnSW50KGJTaGFyZVBhcnRpY2lwYW50Lm50aWxkZSk7XG4gICAgICAgIGgxYSA9IGhleFRvQmlnSW50KGJTaGFyZVBhcnRpY2lwYW50LmgxKTtcbiAgICAgICAgaDJhID0gaGV4VG9CaWdJbnQoYlNoYXJlUGFydGljaXBhbnQuaDIpO1xuICAgICAgICBjayA9IGhleFRvQmlnSW50KGJTaGFyZVBhcnRpY2lwYW50LmNrKTtcbiAgICAgIH1cbiAgICAgIC8vIFZlcmlmeSAkXFxnYW1tYV9pIFxcaW4gWl97Tl4yfSQuXG4gICAgICBpZiAoXG4gICAgICAgICFFY2RzYVJhbmdlUHJvb2YudmVyaWZ5V2l0aENoZWNrKFxuICAgICAgICAgIEVjZHNhLmN1cnZlLFxuICAgICAgICAgIG1pbk1vZHVsdXNCaXRMZW5ndGgsXG4gICAgICAgICAgcGthLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG50aWxkZTogbnRpbGRlYSxcbiAgICAgICAgICAgIGgxOiBoMWEsXG4gICAgICAgICAgICBoMjogaDJhLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgejogaGV4VG9CaWdJbnQoYVNoYXJlVG9CZVNlbnQuZ2FtbWFQcm9vZi56KSxcbiAgICAgICAgICAgIHpwcm06IGhleFRvQmlnSW50KGFTaGFyZVRvQmVTZW50LmdhbW1hUHJvb2YuenBybSksXG4gICAgICAgICAgICB0OiBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC5nYW1tYVByb29mLnQpLFxuICAgICAgICAgICAgdjogaGV4VG9CaWdJbnQoYVNoYXJlVG9CZVNlbnQuZ2FtbWFQcm9vZi52KSxcbiAgICAgICAgICAgIHc6IGhleFRvQmlnSW50KGFTaGFyZVRvQmVTZW50LmdhbW1hUHJvb2YudyksXG4gICAgICAgICAgICBzOiBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC5nYW1tYVByb29mLnMpLFxuICAgICAgICAgICAgczE6IGhleFRvQmlnSW50KGFTaGFyZVRvQmVTZW50LmdhbW1hUHJvb2YuczEpLFxuICAgICAgICAgICAgczI6IGhleFRvQmlnSW50KGFTaGFyZVRvQmVTZW50LmdhbW1hUHJvb2YuczIpLFxuICAgICAgICAgICAgdDE6IGhleFRvQmlnSW50KGFTaGFyZVRvQmVTZW50LmdhbW1hUHJvb2YudDEpLFxuICAgICAgICAgICAgdDI6IGhleFRvQmlnSW50KGFTaGFyZVRvQmVTZW50LmdhbW1hUHJvb2YudDIpLFxuICAgICAgICAgICAgdTogaGV4VG9CaWdJbnQoYVNoYXJlVG9CZVNlbnQuZ2FtbWFQcm9vZi51KSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNrLFxuICAgICAgICAgIGhleFRvQmlnSW50KGFTaGFyZVRvQmVTZW50LmFscGhhKSxcbiAgICAgICAgICBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC5nYW1tYVByb29mLngpXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCB2ZXJpZnkgc2lnbmluZyBzaGFyZSBmb3IgZ2FtbWEgcHJvb2YnKTtcbiAgICAgIH1cbiAgICAgIC8vIFZlcmlmeSAkXFx3X2kgXFxpbiBaX3tOXjJ9JC5cbiAgICAgIGlmIChcbiAgICAgICAgIUVjZHNhUmFuZ2VQcm9vZi52ZXJpZnlXaXRoQ2hlY2soXG4gICAgICAgICAgRWNkc2EuY3VydmUsXG4gICAgICAgICAgbWluTW9kdWx1c0JpdExlbmd0aCxcbiAgICAgICAgICBwa2EsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbnRpbGRlOiBudGlsZGVhLFxuICAgICAgICAgICAgaDE6IGgxYSxcbiAgICAgICAgICAgIGgyOiBoMmEsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB6OiBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC53UHJvb2YueiksXG4gICAgICAgICAgICB6cHJtOiBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC53UHJvb2YuenBybSksXG4gICAgICAgICAgICB0OiBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC53UHJvb2YudCksXG4gICAgICAgICAgICB2OiBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC53UHJvb2YudiksXG4gICAgICAgICAgICB3OiBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC53UHJvb2YudyksXG4gICAgICAgICAgICBzOiBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC53UHJvb2YucyksXG4gICAgICAgICAgICBzMTogaGV4VG9CaWdJbnQoYVNoYXJlVG9CZVNlbnQud1Byb29mLnMxKSxcbiAgICAgICAgICAgIHMyOiBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC53UHJvb2YuczIpLFxuICAgICAgICAgICAgdDE6IGhleFRvQmlnSW50KGFTaGFyZVRvQmVTZW50LndQcm9vZi50MSksXG4gICAgICAgICAgICB0MjogaGV4VG9CaWdJbnQoYVNoYXJlVG9CZVNlbnQud1Byb29mLnQyKSxcbiAgICAgICAgICAgIHU6IGhleFRvQmlnSW50KGFTaGFyZVRvQmVTZW50LndQcm9vZi51KSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNrLFxuICAgICAgICAgIGhleFRvQmlnSW50KGFTaGFyZVRvQmVTZW50Lm11KSxcbiAgICAgICAgICBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC53UHJvb2YueClcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHZlcmlmeSBzaGFyZSBmb3Igd1Byb29mJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBzayA9IG5ldyBwYWlsbGllckJpZ2ludC5Qcml2YXRlS2V5KFxuICAgICAgICBoZXhUb0JpZ0ludChiU2hhcmVQYXJ0aWNpcGFudC5sIGFzIHN0cmluZyksXG4gICAgICAgIGhleFRvQmlnSW50KGJTaGFyZVBhcnRpY2lwYW50Lm0gYXMgc3RyaW5nKSxcbiAgICAgICAgcGthXG4gICAgICApO1xuICAgICAgY29uc3QgZ1NoYXJlUGFydGljaXBhbnQgPSBzaGFyZVBhcnRpY2lwYW50IGFzIEdTaGFyZTtcbiAgICAgIGNvbnN0IG11U2hhcmVUb0JlU2VudCA9IHNoYXJlVG9CZVNlbnQgYXMgTVVTaGFyZTtcbiAgICAgIGNvbnN0IGFscGhhID0gc2suZGVjcnlwdChoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC5hbHBoYSkpO1xuICAgICAgZ1NoYXJlUGFydGljaXBhbnQuYWxwaGEgPSBiaWdJbnRUb0J1ZmZlckJFKEVjZHNhLmN1cnZlLnNjYWxhclJlZHVjZShhbHBoYSksIDMyKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICBjb25zdCBtdSA9IHNrLmRlY3J5cHQoaGV4VG9CaWdJbnQoYVNoYXJlVG9CZVNlbnQubXUgYXMgc3RyaW5nKSk7IC8vIHJlY2hlY2sgZW5jcnlwdGVkIG51bWJlclxuICAgICAgZ1NoYXJlUGFydGljaXBhbnQubXUgPSBiaWdJbnRUb0J1ZmZlckJFKEVjZHNhLmN1cnZlLnNjYWxhclJlZHVjZShtdSksIDMyKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICBjb25zdCBwYXJ0aWFsU2hhcmVQYXJ0aWNpcGFudCA9IHNoYXJlUGFydGljaXBhbnQgYXMgUGFydGlhbDxHU2hhcmU+O1xuICAgICAgY29uc3QgcGFydGlhbFNoYXJlVG9CZVNlbnQgPSBtdVNoYXJlVG9CZVNlbnQgYXMgUGFydGlhbDxNVVNoYXJlPjtcbiAgICAgIGRlbGV0ZSBwYXJ0aWFsU2hhcmVQYXJ0aWNpcGFudC5sO1xuICAgICAgZGVsZXRlIHBhcnRpYWxTaGFyZVBhcnRpY2lwYW50Lm07XG4gICAgICBkZWxldGUgcGFydGlhbFNoYXJlVG9CZVNlbnQuYWxwaGE7XG4gICAgICBkZWxldGUgcGFydGlhbFNoYXJlVG9CZVNlbnQubXU7XG4gICAgfVxuICAgIGlmICgoc2hhcmVUb0JlU2VudCBhcyBBU2hhcmUpLmspIHtcbiAgICAgIGNvbnN0IGJTaGFyZVBhcnRpY2lwYW50ID0gc2hhcmVQYXJ0aWNpcGFudCBhcyBCU2hhcmU7XG4gICAgICBjb25zdCBhU2hhcmVUb0JlU2VudCA9IHNoYXJlVG9CZVNlbnQgYXMgQVNoYXJlO1xuICAgICAgaWYgKCFhU2hhcmVUb0JlU2VudC5wcm9vZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgbWlzc2luZyBwcm9vZiBvbiBhU2hhcmVUb0JlU2VudCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgbiA9IGhleFRvQmlnSW50KGFTaGFyZVRvQmVTZW50Lm4pOyAvLyBQYWlsbGllciBwdWIgZnJvbSBvdGhlciBzaWduZXJcbiAgICAgIGNvbnN0IHBrYSA9IGdldFBhaWxsaWVyUHVibGljS2V5KG4pO1xuICAgICAgY29uc3QgbnRpbGRlYSA9IGhleFRvQmlnSW50KGFTaGFyZVRvQmVTZW50Lm50aWxkZSk7XG4gICAgICBjb25zdCBoMWEgPSBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC5oMSk7XG4gICAgICBjb25zdCBoMmEgPSBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC5oMik7XG4gICAgICBjb25zdCBudGlsZGViID0gaGV4VG9CaWdJbnQoYlNoYXJlUGFydGljaXBhbnQubnRpbGRlKTtcbiAgICAgIGNvbnN0IGgxYiA9IGhleFRvQmlnSW50KGJTaGFyZVBhcnRpY2lwYW50LmgxKTtcbiAgICAgIGNvbnN0IGgyYiA9IGhleFRvQmlnSW50KGJTaGFyZVBhcnRpY2lwYW50LmgyKTtcbiAgICAgIGNvbnN0IGsgPSBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC5rKTtcbiAgICAgIGlmIChcbiAgICAgICAgIUVjZHNhUmFuZ2VQcm9vZi52ZXJpZnkoXG4gICAgICAgICAgRWNkc2EuY3VydmUsXG4gICAgICAgICAgbWluTW9kdWx1c0JpdExlbmd0aCxcbiAgICAgICAgICBwa2EsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbnRpbGRlOiBudGlsZGViLFxuICAgICAgICAgICAgaDE6IGgxYixcbiAgICAgICAgICAgIGgyOiBoMmIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB6OiBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC5wcm9vZi56KSxcbiAgICAgICAgICAgIHU6IGhleFRvQmlnSW50KGFTaGFyZVRvQmVTZW50LnByb29mLnUpLFxuICAgICAgICAgICAgdzogaGV4VG9CaWdJbnQoYVNoYXJlVG9CZVNlbnQucHJvb2YudyksXG4gICAgICAgICAgICBzOiBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC5wcm9vZi5zKSxcbiAgICAgICAgICAgIHMxOiBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC5wcm9vZi5zMSksXG4gICAgICAgICAgICBzMjogaGV4VG9CaWdJbnQoYVNoYXJlVG9CZVNlbnQucHJvb2YuczIpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAga1xuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgdmVyaWZ5IHNpZ25pbmcgQSBzaGFyZSBwcm9vZicpO1xuICAgICAgfVxuICAgICAgLy8gTXRBICRrX2osIFxcZ2FtbWFfaSQuXG4gICAgICBjb25zdCBiZXRhMCA9IGJpZ2ludENyeXB0b1V0aWxzLnJhbmRCZXR3ZWVuKEVjZHNhLmN1cnZlLm9yZGVyKCkgKiogXzVuKTtcbiAgICAgIGJTaGFyZVBhcnRpY2lwYW50LmJldGEgPSBiaWdJbnRUb0J1ZmZlckJFKEVjZHNhLmN1cnZlLnNjYWxhck5lZ2F0ZShFY2RzYS5jdXJ2ZS5zY2FsYXJSZWR1Y2UoYmV0YTApKSwgMzIpLnRvU3RyaW5nKFxuICAgICAgICAnaGV4J1xuICAgICAgKTtcbiAgICAgIGNvbnN0IGcgPSBoZXhUb0JpZ0ludChiU2hhcmVQYXJ0aWNpcGFudC5nYW1tYSk7XG4gICAgICBjb25zdCByYiA9IGF3YWl0IHJhbmRvbVBvc2l0aXZlQ29QcmltZVRvKHBrYS5uKTtcbiAgICAgIGNvbnN0IGNiID0gcGthLmVuY3J5cHQoYmV0YTAsIHJiKTtcbiAgICAgIGNvbnN0IGFscGhhID0gcGthLmFkZGl0aW9uKHBrYS5tdWx0aXBseShrLCBnKSwgY2IpO1xuICAgICAgYVNoYXJlVG9CZVNlbnQuYWxwaGEgPSBiaWdJbnRUb0J1ZmZlckJFKGFscGhhLCAzMikudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgLy8gUHJvdmUgJFxcZ2FtbWFfaSBcXGluIFpfe05eMn0kLlxuICAgICAgY29uc3QgZ3ggPSBFY2RzYS5jdXJ2ZS5iYXNlUG9pbnRNdWx0KGcpO1xuICAgICAgbGV0IHByb29mID0gYXdhaXQgRWNkc2FSYW5nZVByb29mLnByb3ZlV2l0aENoZWNrKFxuICAgICAgICBFY2RzYS5jdXJ2ZSxcbiAgICAgICAgbWluTW9kdWx1c0JpdExlbmd0aCxcbiAgICAgICAgcGthLFxuICAgICAgICB7XG4gICAgICAgICAgbnRpbGRlOiBudGlsZGVhLFxuICAgICAgICAgIGgxOiBoMWEsXG4gICAgICAgICAgaDI6IGgyYSxcbiAgICAgICAgfSxcbiAgICAgICAgayxcbiAgICAgICAgYWxwaGEsXG4gICAgICAgIGcsXG4gICAgICAgIGJldGEwLFxuICAgICAgICByYixcbiAgICAgICAgZ3hcbiAgICAgICk7XG4gICAgICBPYmplY3QuYXNzaWduKGFTaGFyZVRvQmVTZW50LCB7XG4gICAgICAgIGdhbW1hUHJvb2Y6IHtcbiAgICAgICAgICB6OiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnosIDM4NCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgIHpwcm06IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YuenBybSwgMzg0KS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgdDogYmlnSW50VG9CdWZmZXJCRShwcm9vZi50LCAzODQpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICB2OiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnYsIDc2OCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgIHc6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudywgMzg0KS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgczogYmlnSW50VG9CdWZmZXJCRShwcm9vZi5zLCAzODQpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICBzMTogYmlnSW50VG9CdWZmZXJCRShwcm9vZi5zMSwgOTYpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICBzMjogYmlnSW50VG9CdWZmZXJCRShwcm9vZi5zMiwgNDgwKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgdDE6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudDEsIDIyNCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgIHQyOiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnQyLCA0ODApLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICB1OiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnUsIDMzKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgeDogYmlnSW50VG9CdWZmZXJCRShneCwgMzMpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgLy8gTXRBICRrX2osIHdfaSQuXG4gICAgICBjb25zdCBudTAgPSBiaWdpbnRDcnlwdG9VdGlscy5yYW5kQmV0d2VlbihFY2RzYS5jdXJ2ZS5vcmRlcigpICoqIF81bik7XG4gICAgICBzaGFyZVBhcnRpY2lwYW50Lm51ID0gYmlnSW50VG9CdWZmZXJCRShFY2RzYS5jdXJ2ZS5zY2FsYXJOZWdhdGUoRWNkc2EuY3VydmUuc2NhbGFyUmVkdWNlKG51MCkpLCAzMikudG9TdHJpbmcoXG4gICAgICAgICdoZXgnXG4gICAgICApO1xuICAgICAgY29uc3QgdyA9IGhleFRvQmlnSW50KGJTaGFyZVBhcnRpY2lwYW50LncpO1xuICAgICAgY29uc3Qgcm4gPSBhd2FpdCByYW5kb21Qb3NpdGl2ZUNvUHJpbWVUbyhwa2Eubik7XG4gICAgICBjb25zdCBjbiA9IHBrYS5lbmNyeXB0KG51MCwgcm4pO1xuICAgICAgY29uc3QgbXUgPSBwa2EuYWRkaXRpb24ocGthLm11bHRpcGx5KGssIHcpLCBjbik7XG4gICAgICBzaGFyZVRvQmVTZW50Lm11ID0gYmlnSW50VG9CdWZmZXJCRShtdSwgMzIpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIC8vIFByb3ZlICRcXHdfaSBcXGluIFpfe05eMn0kLlxuICAgICAgY29uc3Qgd3ggPSBFY2RzYS5jdXJ2ZS5iYXNlUG9pbnRNdWx0KHcpO1xuICAgICAgcHJvb2YgPSBhd2FpdCBFY2RzYVJhbmdlUHJvb2YucHJvdmVXaXRoQ2hlY2soXG4gICAgICAgIEVjZHNhLmN1cnZlLFxuICAgICAgICBtaW5Nb2R1bHVzQml0TGVuZ3RoLFxuICAgICAgICBwa2EsXG4gICAgICAgIHtcbiAgICAgICAgICBudGlsZGU6IG50aWxkZWEsXG4gICAgICAgICAgaDE6IGgxYSxcbiAgICAgICAgICBoMjogaDJhLFxuICAgICAgICB9LFxuICAgICAgICBrLFxuICAgICAgICBoZXhUb0JpZ0ludChhU2hhcmVUb0JlU2VudC5tdSksXG4gICAgICAgIHcsXG4gICAgICAgIG51MCxcbiAgICAgICAgcm4sXG4gICAgICAgIHd4XG4gICAgICApO1xuICAgICAgT2JqZWN0LmFzc2lnbihzaGFyZVRvQmVTZW50LCB7XG4gICAgICAgIHdQcm9vZjoge1xuICAgICAgICAgIHo6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YueiwgMzg0KS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgenBybTogYmlnSW50VG9CdWZmZXJCRShwcm9vZi56cHJtLCAzODQpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICB0OiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnQsIDM4NCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgIHY6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudiwgNzY4KS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgdzogYmlnSW50VG9CdWZmZXJCRShwcm9vZi53LCAzODQpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICBzOiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnMsIDM4NCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgIHMxOiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnMxLCA5NikudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgIHMyOiBiaWdJbnRUb0J1ZmZlckJFKHByb29mLnMyLCA0ODApLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICB0MTogYmlnSW50VG9CdWZmZXJCRShwcm9vZi50MSwgMjI0KS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgdDI6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudDIsIDQ4MCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgIHU6IGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudSwgMzMpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICB4OiBiaWdJbnRUb0J1ZmZlckJFKHd4LCAzMykudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBpZiAoKHNoYXJlUGFydGljaXBhbnQgYXMgR1NoYXJlKS5hbHBoYSkge1xuICAgICAgICBjb25zdCBwYXJ0aWFsU2hhcmVQYXJ0aWNpcGFudCA9IHNoYXJlUGFydGljaXBhbnQgYXMgUGFydGlhbDxCU2hhcmU+O1xuICAgICAgICBjb25zdCBwYXJ0aWFsU2hhcmVUb0JlU2VudCA9IHNoYXJlVG9CZVNlbnQgYXMgUGFydGlhbDxBU2hhcmU+O1xuICAgICAgICBkZWxldGUgcGFydGlhbFNoYXJlUGFydGljaXBhbnQubnRpbGRlO1xuICAgICAgICBkZWxldGUgcGFydGlhbFNoYXJlUGFydGljaXBhbnQuaDE7XG4gICAgICAgIGRlbGV0ZSBwYXJ0aWFsU2hhcmVQYXJ0aWNpcGFudC5oMjtcbiAgICAgICAgZGVsZXRlIHBhcnRpYWxTaGFyZVBhcnRpY2lwYW50LmNrO1xuICAgICAgICBkZWxldGUgcGFydGlhbFNoYXJlVG9CZVNlbnQubjtcbiAgICAgICAgZGVsZXRlIHBhcnRpYWxTaGFyZVRvQmVTZW50Lm50aWxkZTtcbiAgICAgICAgZGVsZXRlIHBhcnRpYWxTaGFyZVRvQmVTZW50LmgxO1xuICAgICAgICBkZWxldGUgcGFydGlhbFNoYXJlVG9CZVNlbnQuaDI7XG4gICAgICAgIGRlbGV0ZSBwYXJ0aWFsU2hhcmVUb0JlU2VudC5rO1xuICAgICAgICBkZWxldGUgcGFydGlhbFNoYXJlVG9CZVNlbnQucHJvb2Y7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKHNoYXJlVG9CZVNlbnQsIHtcbiAgICAgICAgICBuOiBrU2hhcmUubixcbiAgICAgICAgICBudGlsZGU6IGJpZ0ludFRvQnVmZmVyQkUobnRpbGRlYiwgMzg0KS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgaDE6IGJpZ0ludFRvQnVmZmVyQkUoaDFiLCAzODQpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICBoMjogYmlnSW50VG9CdWZmZXJCRShoMmIsIDM4NCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgIGs6IGtTaGFyZS5rLFxuICAgICAgICAgIHByb29mOiBrU2hhcmUucHJvb2YsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISgnYWxwaGEnIGluIHNoYXJlVG9CZVNlbnQpICYmICEoJ2snIGluIHNoYXJlVG9CZVNlbnQpKSB7XG4gICAgICBjb25zdCBwYXJ0aWFsU2hhcmVQYXJ0aWNpcGFudCA9IHNoYXJlUGFydGljaXBhbnQgYXMgUGFydGlhbDxCU2hhcmU+O1xuICAgICAgZGVsZXRlIHBhcnRpYWxTaGFyZVBhcnRpY2lwYW50Lm50aWxkZTtcbiAgICAgIGRlbGV0ZSBwYXJ0aWFsU2hhcmVQYXJ0aWNpcGFudC5oMTtcbiAgICAgIGRlbGV0ZSBwYXJ0aWFsU2hhcmVQYXJ0aWNpcGFudC5oMjtcbiAgICAgIGRlbGV0ZSBwYXJ0aWFsU2hhcmVQYXJ0aWNpcGFudC5jaztcbiAgICAgIGNvbnN0IG11U2hhcmVUb0JlU2VudCA9IHNoYXJlVG9CZVNlbnQgYXMgTVVTaGFyZTtcbiAgICAgIHNoYXJlVG9CZVNlbnQgPSB7XG4gICAgICAgIGk6IG11U2hhcmVUb0JlU2VudC5pLFxuICAgICAgICBqOiBtdVNoYXJlVG9CZVNlbnQuaixcbiAgICAgIH0gYXMgTVVTaGFyZTtcbiAgICB9XG4gICAgW3NoYXJlVG9CZVNlbnQuaSwgc2hhcmVUb0JlU2VudC5qXSA9IFtzaGFyZVRvQmVTZW50LmosIHNoYXJlVG9CZVNlbnQuaV07XG4gICAgaWYgKGlzR2FtbWFTaGFyZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbXVTaGFyZTogc2hhcmVUb0JlU2VudCBhcyBNVVNoYXJlLFxuICAgICAgICBnU2hhcmU6IHNoYXJlUGFydGljaXBhbnQgYXMgR1NoYXJlLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGFTaGFyZTogc2hhcmVUb0JlU2VudCBhcyBBU2hhcmUsXG4gICAgICBiU2hhcmU6IHNoYXJlUGFydGljaXBhbnQgYXMgQlNoYXJlLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29tYmluZSBnYW1tYSBzaGFyZXMgdG8gZ2V0IHRoZSBwcml2YXRlIG9taWNyb24gLyBkZWx0YSBzaGFyZXNcbiAgICogQHBhcmFtIHtTaWduQ29tYmluZX0gc2hhcmVzXG4gICAqIEByZXR1cm5zIHtTaWduQ29tYmluZVJUfVxuICAgKi9cbiAgc2lnbkNvbWJpbmUoc2hhcmVzOiBTaWduQ29tYmluZSk6IFNpZ25Db21iaW5lUlQge1xuICAgIGNvbnN0IGdTaGFyZSA9IHNoYXJlcy5nU2hhcmU7XG4gICAgY29uc3QgUyA9IHNoYXJlcy5zaWduSW5kZXg7XG4gICAgY29uc3QgZ2FtbWEgPSBoZXhUb0JpZ0ludChnU2hhcmUuZ2FtbWEpO1xuICAgIGNvbnN0IGFscGhhID0gaGV4VG9CaWdJbnQoZ1NoYXJlLmFscGhhKTtcbiAgICBjb25zdCBiZXRhID0gaGV4VG9CaWdJbnQoZ1NoYXJlLmJldGEpO1xuICAgIGNvbnN0IG11ID0gaGV4VG9CaWdJbnQoZ1NoYXJlLm11KTtcbiAgICBjb25zdCBudSA9IGhleFRvQmlnSW50KGdTaGFyZS5udSk7XG4gICAgY29uc3QgayA9IGhleFRvQmlnSW50KGdTaGFyZS5rKTtcbiAgICBjb25zdCB3ID0gaGV4VG9CaWdJbnQoZ1NoYXJlLncpO1xuXG4gICAgY29uc3QgZGVsdGEgPSBFY2RzYS5jdXJ2ZS5zY2FsYXJBZGQoRWNkc2EuY3VydmUuc2NhbGFyTXVsdChrLCBnYW1tYSksIEVjZHNhLmN1cnZlLnNjYWxhckFkZChhbHBoYSwgYmV0YSkpO1xuICAgIGNvbnN0IG9taWNyb24gPSBFY2RzYS5jdXJ2ZS5zY2FsYXJBZGQoRWNkc2EuY3VydmUuc2NhbGFyTXVsdChrLCB3KSwgRWNkc2EuY3VydmUuc2NhbGFyQWRkKG11LCBudSkpO1xuICAgIGNvbnN0IEdhbW1hID0gRWNkc2EuY3VydmUuYmFzZVBvaW50TXVsdChnYW1tYSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgb1NoYXJlOiB7XG4gICAgICAgIGk6IGdTaGFyZS5pLFxuICAgICAgICB5OiBnU2hhcmUueSxcbiAgICAgICAgazogYmlnSW50VG9CdWZmZXJCRShrLCAzMikudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICBvbWljcm9uOiBiaWdJbnRUb0J1ZmZlckJFKG9taWNyb24sIDMyKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgIGRlbHRhOiBiaWdJbnRUb0J1ZmZlckJFKGRlbHRhLCAzMikudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICBHYW1tYTogYmlnSW50VG9CdWZmZXJCRShHYW1tYSwgMzMpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIH0sXG4gICAgICBkU2hhcmU6IHtcbiAgICAgICAgaTogUy5pLFxuICAgICAgICBqOiBnU2hhcmUuaSxcbiAgICAgICAgZGVsdGE6IGJpZ0ludFRvQnVmZmVyQkUoZGVsdGEsIDMyKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgIEdhbW1hOiBiaWdJbnRUb0J1ZmZlckJFKEdhbW1hLCAzMykudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gYSBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gTSBNZXNzYWdlIHRvIGJlIHNpZ25lZFxuICAgKiBAcGFyYW0ge09TaGFyZX0gb1NoYXJlIHByaXZhdGUgb21pY3JvbiBzaGFyZSBvZiBjdXJyZW50IHBhcnRpY2lwYW50XG4gICAqIEBwYXJhbSB7RFNoYXJlfSBkU2hhcmUgZGVsdGEgc2hhcmUgcmVjZWl2ZWQgZnJvbSB0aGUgb3RoZXIgcGFydGljaXBhbnRcbiAgICogQHBhcmFtIHtIYXNofSBoYXNoIGhhc2hpbmcgYWxnb3JpdGhtIGltcGxlbWVudGluZyBOb2RlYHMgc3RhbmRhcmQgY3J5cHRvIGhhc2ggaW50ZXJmYWNlXG4gICAqIEBwYXJhbSBzaG91bGRIYXNoIGlmIHRydWUsIHdlIGhhc2ggdGhlIHByb3ZpZGVkIGJ1ZmZlciBiZWZvcmUgc2lnbmluZ1xuICAgKiBAcmV0dXJucyB7VkFTaGFyZX1cbiAgICovXG4gIHNpZ24oTTogQnVmZmVyLCBvU2hhcmU6IE9TaGFyZSwgZFNoYXJlOiBEU2hhcmUsIGhhc2g/OiBIYXNoLCBzaG91bGRIYXNoID0gdHJ1ZSk6IFZBU2hhcmUge1xuICAgIGNvbnN0IG0gPSBzaG91bGRIYXNoID8gKGhhc2ggfHwgY3JlYXRlSGFzaCgnc2hhMjU2JykpLnVwZGF0ZShNKS5kaWdlc3QoKSA6IE07XG5cbiAgICBjb25zdCBkZWx0YSA9IEVjZHNhLmN1cnZlLnNjYWxhckFkZChoZXhUb0JpZ0ludChvU2hhcmUuZGVsdGEpLCBoZXhUb0JpZ0ludChkU2hhcmUuZGVsdGEpKTtcblxuICAgIGNvbnN0IFIgPSBFY2RzYS5jdXJ2ZS5wb2ludE11bHRpcGx5KFxuICAgICAgRWNkc2EuY3VydmUucG9pbnRBZGQoaGV4VG9CaWdJbnQob1NoYXJlLkdhbW1hKSwgaGV4VG9CaWdJbnQoZFNoYXJlLkdhbW1hKSksXG4gICAgICBFY2RzYS5jdXJ2ZS5zY2FsYXJJbnZlcnQoZGVsdGEpXG4gICAgKTtcbiAgICBjb25zdCBwb2ludFIgPSBzZWNwLlBvaW50LmZyb21IZXgoYmlnSW50VG9CdWZmZXJCRShSLCAzMikpO1xuICAgIGNvbnN0IHIgPSBwb2ludFIueDtcblxuICAgIGNvbnN0IHMgPSBFY2RzYS5jdXJ2ZS5zY2FsYXJBZGQoXG4gICAgICBFY2RzYS5jdXJ2ZS5zY2FsYXJNdWx0KGJpZ0ludEZyb21VOEFCRShtKSwgaGV4VG9CaWdJbnQob1NoYXJlLmspKSxcbiAgICAgIEVjZHNhLmN1cnZlLnNjYWxhck11bHQociwgaGV4VG9CaWdJbnQob1NoYXJlLm9taWNyb24pKVxuICAgICk7XG5cbiAgICBjb25zdCBsID0gRWNkc2EuY3VydmUuc2NhbGFyUmFuZG9tKCk7XG4gICAgY29uc3QgcmhvID0gRWNkc2EuY3VydmUuc2NhbGFyUmFuZG9tKCk7XG4gICAgY29uc3QgViA9IEVjZHNhLmN1cnZlLnBvaW50QWRkKEVjZHNhLmN1cnZlLnBvaW50TXVsdGlwbHkoUiwgcyksIEVjZHNhLmN1cnZlLmJhc2VQb2ludE11bHQobCkpO1xuICAgIGNvbnN0IEEgPSBFY2RzYS5jdXJ2ZS5iYXNlUG9pbnRNdWx0KHJobyk7XG5cbiAgICBjb25zdCBjb21EZWNvbV9WX0EgPSBIYXNoQ29tbWl0bWVudC5jcmVhdGVDb21taXRtZW50KFxuICAgICAgQnVmZmVyLmNvbmNhdChbYmlnSW50VG9CdWZmZXJCRShWLCBFY2RzYS5jdXJ2ZS5wb2ludEJ5dGVzKSwgYmlnSW50VG9CdWZmZXJCRShBLCBFY2RzYS5jdXJ2ZS5wb2ludEJ5dGVzKV0pXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpOiBvU2hhcmUuaSxcbiAgICAgIHk6IG9TaGFyZS55LFxuICAgICAgUjogcG9pbnRSLnRvSGV4KHRydWUpLFxuICAgICAgczogYmlnSW50VG9CdWZmZXJCRShzLCAzMikudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgbTogbSxcbiAgICAgIGw6IGwsXG4gICAgICByaG86IHJobyxcbiAgICAgIFY6IFYsXG4gICAgICBBOiBBLFxuICAgICAgY29tRGVjb21WQTogY29tRGVjb21fVl9BLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgcHJvb2ZzIG9mIFZfaSBhbmQgQV9pIHZhbHVlcy5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IE0gTWVzc2FnZSB0byBjb21taXQgdG8gYXMgcGFydCBvZiB0aGUgY29udGV4dCBvZiB0aGUgcHJvb2YuXG4gICAqICAgIFRoaXMgZG9lc24ndCBuZWVkIHRvIGJlIHRoZSBzYW1lIG1lc3NhZ2UgdGhhdCB3YXMgc2lnbmVkIGluIHRoZSBzaWduIGZ1bmN0aW9uIGFib3ZlLlxuICAgKiAgICBCdXQgaXQgc2hvdWxkIGJlIHRoZSBzYW1lIGZvciBhbGwgcGFydGljaXBhbnRzIGZvciB0aGUgcHVycG9zZSBvZiBwcm92aWRpbmcgcHJvb2YgY29udGV4dC5cbiAgICogQHBhcmFtIHtWQVNoYXJlfSB2YVNoYXJlIFRoZSBWQVNoYXJlIHRvIHByb3ZlLlxuICAgKiBAcmV0dXJucyB7VkFTaGFyZVdpdGhQcm9vZnN9XG4gICAqL1xuICBnZW5lcmF0ZVZBUHJvb2ZzKE06IEJ1ZmZlciwgdmFTaGFyZTogVkFTaGFyZSk6IFZBU2hhcmVXaXRoUHJvb2ZzIHtcbiAgICBjb25zdCBzID0gaGV4VG9CaWdJbnQodmFTaGFyZS5zKTtcbiAgICBjb25zdCBSID0gYmlnSW50RnJvbVU4QUJFKHNlY3AuUG9pbnQuZnJvbUhleCh2YVNoYXJlLlIpLnRvUmF3Qnl0ZXModHJ1ZSkpO1xuXG4gICAgY29uc3QgcHJvb2ZDb250ZXh0ID0gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKE0pLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKFIsIEVjZHNhLmN1cnZlLnBvaW50Qnl0ZXMpKS5kaWdlc3QoKTtcblxuICAgIGNvbnN0IHprVlByb29mID0gRWNkc2Faa1ZQcm9vZi5jcmVhdGVaa1ZQcm9vZih2YVNoYXJlLlYsIHMsIHZhU2hhcmUubCwgUiwgRWNkc2EuY3VydmUsIHByb29mQ29udGV4dCk7XG4gICAgY29uc3Qgc2Nobm9yclByb29mID0gU2Nobm9yci5jcmVhdGVTY2hub3JyUHJvb2YodmFTaGFyZS5BLCB2YVNoYXJlLnJobywgRWNkc2EuY3VydmUsIHByb29mQ29udGV4dCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4udmFTaGFyZSxcbiAgICAgIHByb29mQ29udGV4dDogcHJvb2ZDb250ZXh0LFxuICAgICAgemtWUHJvb2ZWOiB6a1ZQcm9vZixcbiAgICAgIHNjaG5vcnJQcm9vZkE6IHNjaG5vcnJQcm9vZixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBWX2kgYW5kIEFfaSB2YWx1ZXMgb2YgYWxsIG90aGVyIHBhcnRpY2lwYW50cyBkdXJpbmcgc2lnbmluZyBwaGFzZSA1IHN0ZXBzIDVBIGFuZCA1Qi5cbiAgICogQHBhcmFtIHtWQVNoYXJlV2l0aFByb29mc30gdmFTaGFyZSBWX2ksIEFfaSBpbmZvIGluY2x1ZGluZyBTU2hhcmUgdmFsdWVzIG9mIHRoZSBjdXJyZW5jdCBwYXJ0aWNpcGFudFxuICAgKiBAcGFyYW0ge1B1YmxpY1ZBU2hhcmVXaXRoUHJvb2ZzW119IHB1YmxpY1ZBU2hhcmVzIHB1YmxpYyBWX2ksIEFfaSBpbmZvIG9mIGFsbCBvdGhlciBwYXJ0aWNpcGFudHNcbiAgICogQHJldHVybnMge1VUU2hhcmV9IFVfaSwgVF9pIGluZm8gb2YgdGhlIGN1cnJlbnQgcGFydGljaXBhbnQgaWYgYWxsIHZlcmlmaWNhdGlvbnMgcGFzc1xuICAgKi9cbiAgdmVyaWZ5VkFTaGFyZXModmFTaGFyZTogVkFTaGFyZVdpdGhQcm9vZnMsIHB1YmxpY1ZBU2hhcmVzOiBQdWJsaWNWQVNoYXJlV2l0aFByb29mc1tdKTogVVRTaGFyZSB7XG4gICAgcHVibGljVkFTaGFyZXMuZm9yRWFjaCgocHVibGljVkFTaGFyZSkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAhSGFzaENvbW1pdG1lbnQudmVyaWZ5Q29tbWl0bWVudChwdWJsaWNWQVNoYXJlLmNvbURlY29tVkEuY29tbWl0bWVudCwge1xuICAgICAgICAgIHNlY3JldDogQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICBiaWdJbnRUb0J1ZmZlckJFKHB1YmxpY1ZBU2hhcmUuViwgRWNkc2EuY3VydmUucG9pbnRCeXRlcyksXG4gICAgICAgICAgICBiaWdJbnRUb0J1ZmZlckJFKHB1YmxpY1ZBU2hhcmUuQSwgRWNkc2EuY3VydmUucG9pbnRCeXRlcyksXG4gICAgICAgICAgXSksXG4gICAgICAgICAgYmxpbmRpbmdGYWN0b3I6IHB1YmxpY1ZBU2hhcmUuY29tRGVjb21WQS5kZWNvbW1pdG1lbnQuYmxpbmRpbmdGYWN0b3IsXG4gICAgICAgIH0pXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgdmVyaWZ5IGNvbW1pdG1lbnQgb2YgVl9pIGFuZCBBX2knKTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgIVNjaG5vcnIudmVyaWZ5U2Nobm9yclByb29mKHB1YmxpY1ZBU2hhcmUuQSwgcHVibGljVkFTaGFyZS5zY2hub3JyUHJvb2ZBLCBFY2RzYS5jdXJ2ZSwgdmFTaGFyZS5wcm9vZkNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgdmVyaWZ5IFNjaG5vcnIgcHJvb2Ygb2YgQV9pJyk7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgICFFY2RzYVprVlByb29mLnZlcmlmeVprVlByb29mKFxuICAgICAgICAgIHB1YmxpY1ZBU2hhcmUuVixcbiAgICAgICAgICBwdWJsaWNWQVNoYXJlLnprVlByb29mVixcbiAgICAgICAgICBoZXhUb0JpZ0ludCh2YVNoYXJlLlIpLFxuICAgICAgICAgIEVjZHNhLmN1cnZlLFxuICAgICAgICAgIHZhU2hhcmUucHJvb2ZDb250ZXh0XG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCB2ZXJpZnkgWksgcHJvb2Ygb2YgVl9pJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB5ID0gaGV4VG9CaWdJbnQodmFTaGFyZS55KTtcbiAgICAvLyByIGlzIFIncyB4IGNvb3JkaW5hdGUuICBSIGlzIGluIGNvbXByZXNzZWQgZm9ybSwgc28gd2UgbmVlZCB0byBzbGljZSBvZmYgdGhlIGZpcnN0IGJ5dGUuXG4gICAgY29uc3QgciA9IGhleFRvQmlnSW50KHZhU2hhcmUuUi5zbGljZSgyKSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgYWdncmVnYXRpb24gb2YgYWxsIFZfaSBhbmQgQV9pLlxuICAgIGxldCBWID0gRWNkc2EuY3VydmUucG9pbnRBZGQoXG4gICAgICBFY2RzYS5jdXJ2ZS5wb2ludEFkZChcbiAgICAgICAgRWNkc2EuY3VydmUuYmFzZVBvaW50TXVsdChFY2RzYS5jdXJ2ZS5zY2FsYXJOZWdhdGUoYmlnSW50RnJvbVU4QUJFKHZhU2hhcmUubSkpKSxcbiAgICAgICAgRWNkc2EuY3VydmUucG9pbnRNdWx0aXBseSh5LCBFY2RzYS5jdXJ2ZS5zY2FsYXJOZWdhdGUocikpXG4gICAgICApLFxuICAgICAgdmFTaGFyZS5WXG4gICAgKTtcbiAgICBsZXQgQSA9IHZhU2hhcmUuQTtcbiAgICBwdWJsaWNWQVNoYXJlcy5mb3JFYWNoKChwdWJsaWNWQVNoYXJlKSA9PiB7XG4gICAgICBWID0gRWNkc2EuY3VydmUucG9pbnRBZGQoViwgcHVibGljVkFTaGFyZS5WKTtcbiAgICAgIEEgPSBFY2RzYS5jdXJ2ZS5wb2ludEFkZChBLCBwdWJsaWNWQVNoYXJlLkEpO1xuICAgIH0pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIFVfaSA9IHJob19pICogViBhbmQgVF9pID0gbF9pICogQS5cbiAgICBjb25zdCBVID0gRWNkc2EuY3VydmUucG9pbnRNdWx0aXBseShWLCB2YVNoYXJlLnJobyk7XG4gICAgY29uc3QgVCA9IEVjZHNhLmN1cnZlLnBvaW50TXVsdGlwbHkoQSwgdmFTaGFyZS5sKTtcbiAgICBjb25zdCBjb21EZWNvbV9VX1QgPSBIYXNoQ29tbWl0bWVudC5jcmVhdGVDb21taXRtZW50KFxuICAgICAgQnVmZmVyLmNvbmNhdChbYmlnSW50VG9CdWZmZXJCRShVLCBFY2RzYS5jdXJ2ZS5wb2ludEJ5dGVzKSwgYmlnSW50VG9CdWZmZXJCRShULCBFY2RzYS5jdXJ2ZS5wb2ludEJ5dGVzKV0pXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi52YVNoYXJlLFxuICAgICAgVSxcbiAgICAgIFQsXG4gICAgICBjb21EZWNvbVVUOiBjb21EZWNvbV9VX1QsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgVV9pIGFuZCBWX2kgdmFsdWVzIG9mIGFsbCBvdGhlciBwYXJ0aWNpcGFudHMgZHVyaW5nIHNpZ25pbmcgcGhhc2UgNSBzdGVwcyA1QyBhbmQgNUQuXG4gICAqIEBwYXJhbSB7VVRTaGFyZX0gdXRTaGFyZSBVX2ksIFRfaSBpbmZvIGluY2x1ZGluZyBTU2hhcmUgdmFsdWVzIG9mIHRoZSBjdXJyZW5jdCBwYXJ0aWNpcGFudFxuICAgKiBAcGFyYW0ge1B1YmxpY1VUU2hhcmVbXX0gcHVibGljVVRTaGFyZXMgcHVibGljIFVfaSwgVF9pIGluZm8gb2YgYWxsIG90aGVyIHBhcnRpY2lwYW50c1xuICAgKiBAcmV0dXJucyB7U1NoYXJlfSBTU2hhcmUgb2YgdGhlIGN1cnJlbnQgcGFydGljaXBhbnQgaWYgYWxsIHZlcmlmaWNhdGlvbnMgcGFzc1xuICAgKi9cbiAgdmVyaWZ5VVRTaGFyZXModXRTaGFyZTogVVRTaGFyZSwgcHVibGljVVRTaGFyZXM6IFB1YmxpY1VUU2hhcmVbXSk6IFNTaGFyZSB7XG4gICAgbGV0IHNpZ21hVSA9IHV0U2hhcmUuVTtcbiAgICBsZXQgc2lnbWFUID0gdXRTaGFyZS5UO1xuXG4gICAgcHVibGljVVRTaGFyZXMuZm9yRWFjaCgocHVibGljVVRTaGFyZSkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAhSGFzaENvbW1pdG1lbnQudmVyaWZ5Q29tbWl0bWVudChwdWJsaWNVVFNoYXJlLmNvbURlY29tVVQuY29tbWl0bWVudCwge1xuICAgICAgICAgIHNlY3JldDogQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICBiaWdJbnRUb0J1ZmZlckJFKHB1YmxpY1VUU2hhcmUuVSwgRWNkc2EuY3VydmUucG9pbnRCeXRlcyksXG4gICAgICAgICAgICBiaWdJbnRUb0J1ZmZlckJFKHB1YmxpY1VUU2hhcmUuVCwgRWNkc2EuY3VydmUucG9pbnRCeXRlcyksXG4gICAgICAgICAgXSksXG4gICAgICAgICAgYmxpbmRpbmdGYWN0b3I6IHB1YmxpY1VUU2hhcmUuY29tRGVjb21VVC5kZWNvbW1pdG1lbnQuYmxpbmRpbmdGYWN0b3IsXG4gICAgICAgIH0pXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgdmVyaWZ5IGNvbW1pdG1lbnQgb2YgVV9pIGFuZCBUX2knKTtcbiAgICAgIH1cblxuICAgICAgc2lnbWFVID0gRWNkc2EuY3VydmUucG9pbnRBZGQoc2lnbWFVLCBwdWJsaWNVVFNoYXJlLlUpO1xuICAgICAgc2lnbWFUID0gRWNkc2EuY3VydmUucG9pbnRBZGQoc2lnbWFULCBwdWJsaWNVVFNoYXJlLlQpO1xuICAgIH0pO1xuXG4gICAgaWYgKHNpZ21hVSAhPT0gc2lnbWFUKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1bSBvZiBhbGwgVV9pIGRvZXMgbm90IG1hdGNoIHN1bSBvZiBhbGwgVF9pJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgLi4udXRTaGFyZSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBmdWxsIHNpZ25hdHVyZSBieSBjb21iaW5pbmcgU2lnbiBTaGFyZXNcbiAgICogQHBhcmFtIHtTU2hhcmVbXX0gc2hhcmVzXG4gICAqIEByZXR1cm5zIHtTaWduYXR1cmV9XG4gICAqL1xuICBjb25zdHJ1Y3RTaWduYXR1cmUoc2hhcmVzOiBTU2hhcmVbXSk6IFNpZ25hdHVyZSB7XG4gICAgLy8gRXZlcnkgUiBtdXN0IG1hdGNoLlxuICAgIGNvbnN0IFIgPSBzaGFyZXNbMF1bJ1InXTtcbiAgICBjb25zdCBpc1JNYXRjaGluZyA9IHNoYXJlcy5tYXAoKHNoYXJlKSA9PiBzaGFyZVsnUiddID09PSBSKS5yZWR1Y2UoKGEsIGIpID0+IGEgJiYgYik7XG4gICAgaWYgKCFpc1JNYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSIHZhbHVlIHNob3VsZCBiZSBjb25zaXN0ZW50IGFjcm9zcyBhbGwgc2hhcmVzJyk7XG4gICAgfVxuXG4gICAgbGV0IHMgPSBzaGFyZXMubWFwKChzaGFyZSkgPT4gaGV4VG9CaWdJbnQoc2hhcmVbJ3MnXSkpLnJlZHVjZShFY2RzYS5jdXJ2ZS5zY2FsYXJBZGQpO1xuICAgIGNvbnN0IHJlY2lkID0gKFIuc2xpY2UoMCwgMikgPT09ICcwMycgPyAxIDogMCkgXiAocyA+IEVjZHNhLmN1cnZlLm9yZGVyKCkgLyBCaWdJbnQoMikgPyAxIDogMCk7XG5cbiAgICAvLyBOb3JtYWxpemUgcy5cbiAgICBzID0gcyA+IEVjZHNhLmN1cnZlLm9yZGVyKCkgLyBCaWdJbnQoMikgPyBFY2RzYS5jdXJ2ZS5vcmRlcigpIC0gcyA6IHM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHk6IHNoYXJlc1swXVsneSddLFxuICAgICAgcjogUi5zbGljZSgyKSxcbiAgICAgIHM6IGJpZ0ludFRvQnVmZmVyQkUocywgMzIpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHJlY2lkOiByZWNpZCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBlY2RzYSBzaWduYXR1cmVzXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7U2lnbmF0dXJlIH0gc2lnbmF0dXJlXG4gICAqIEBwYXJhbSB7SGFzaH0gaGFzaCBoYXNoaW5nIGFsZ29yaXRobSBpbXBsZW1lbnRpbmcgTm9kZWBzIHN0YW5kYXJkIGNyeXB0byBoYXNoIGludGVyZmFjZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZEhhc2ggaWYgdHJ1ZSwgd2UgaGFzaCB0aGUgcHJvdmlkZWQgYnVmZmVyIGJlZm9yZSB2ZXJpZnlpbmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgc2lnbmF0dXJlIGlzIHZhbGlkOyBGYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHZlcmlmeShtZXNzYWdlOiBCdWZmZXIsIHNpZ25hdHVyZTogU2lnbmF0dXJlLCBoYXNoPzogSGFzaCwgc2hvdWxkSGFzaCA9IHRydWUpOiBib29sZWFuIHtcbiAgICBjb25zdCBtZXNzYWdlVG9WZXJpZnkgPSBzaG91bGRIYXNoID8gKGhhc2ggfHwgY3JlYXRlSGFzaCgnc2hhMjU2JykpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKSA6IG1lc3NhZ2U7XG4gICAgcmV0dXJuIEVjZHNhLmN1cnZlLnZlcmlmeShcbiAgICAgIG1lc3NhZ2VUb1ZlcmlmeSxcbiAgICAgIEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICBCdWZmZXIuZnJvbShbc2lnbmF0dXJlWydyZWNpZCddXSksXG4gICAgICAgIGJpZ0ludFRvQnVmZmVyQkUoaGV4VG9CaWdJbnQoc2lnbmF0dXJlWydyJ10pLCAzMiksXG4gICAgICAgIGJpZ0ludFRvQnVmZmVyQkUoaGV4VG9CaWdJbnQoc2lnbmF0dXJlWydzJ10pLCAzMiksXG4gICAgICBdKSxcbiAgICAgIGhleFRvQmlnSW50KHNpZ25hdHVyZVsneSddKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIGEgY2hhbGxlbmdlIGFuZCBpdCdzIHByb29mcyBmcm9tIGhleCBzdHJpbmdzIHRvIGJpZ2ludFxuICAgKiBAZGVwcmVjYXRlZCB1c2Ugc2RrLWxpYi1tcGMgRWNkc2FUeXBlcy5kZXNlcmlhbGl6ZU50aWxkZSBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgZGVzZXJpYWxpemVOdGlsZGUoY2hhbGxlbmdlOiBFY2RzYVR5cGVzLlNlcmlhbGl6ZWROdGlsZGUpOiBFY2RzYVR5cGVzLkRlc2VyaWFsaXplZE50aWxkZSB7XG4gICAgcmV0dXJuIEVjZHNhVHlwZXMuZGVzZXJpYWxpemVOdGlsZGUoY2hhbGxlbmdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGEgY2hhbGxlbmdlIGFuZCBpdCdzIHByb29mcyBmcm9tIGJpZyBpbnQgdG8gaGV4IHN0cmluZ3MuXG4gICAqIEBkZXByZWNhdGVkIHVzZSBzZGstbGliLW1wYyBFY2RzYVR5cGVzLmRlc2VyaWFsaXplTnRpbGRlIGluc3RlYWRcbiAgICogQHBhcmFtIGNoYWxsZW5nZVxuICAgKi9cbiAgc3RhdGljIHNlcmlhbGl6ZU50aWxkZShjaGFsbGVuZ2U6IEVjZHNhVHlwZXMuRGVzZXJpYWxpemVkTnRpbGRlKTogRWNkc2FUeXBlcy5TZXJpYWxpemVkTnRpbGRlIHtcbiAgICByZXR1cm4gRWNkc2FUeXBlcy5zZXJpYWxpemVOdGlsZGUoY2hhbGxlbmdlKTtcbiAgfVxufVxuIl19