/// <reference types="node" />
/// <reference types="node" />
import { Hash } from 'crypto';
import { Secp256k1Curve } from '../../curves';
import { EcdsaTypes, HDTree, Shamir, SchnorrProof } from '@bitgo/sdk-lib-mpc';
import { DShare, KeyCombined, KeyShare, NShare, OShare, PShare, PublicUTShare, Signature, SignCombine, SignCombineRT, SignConvert, SignConvertRT, SignConvertStep1, SignConvertStep1Response, SignConvertStep2, SignConvertStep2Response, SignConvertStep3, SignConvertStep3Response, SignShareRT, SShare, SubkeyShare, UTShare, VAShareWithProofs, VAShare, XShareWithChallenges, YShareWithChallenges, PublicVAShareWithProofs } from './types';
/**
 * ECDSA TSS implementation supporting 2:n Threshold
 */
export default class Ecdsa {
    static curve: Secp256k1Curve;
    static hdTree: HDTree;
    static shamir: Shamir;
    /**
     * Generate shares for participant at index and split keys `(threshold,numShares)` ways.
     * @param {number} index participant index
     * @param {number} threshold Signing threshold
     * @param {number} numShares  Number of shares
     * @param {Buffer} seed optional 64 byte seed to use for key generation
     * @param sync optional sync flag, if true then a synchronous version of Paillier key generation is used that does not spawn Worker threads.
     * @returns {Promise<KeyShare>} Returns the private p-share
     * and n-shares to be distributed to participants at their corresponding index.
     */
    keyShare(index: number, threshold: number, numShares: number, seed?: Buffer, sync?: boolean): Promise<KeyShare>;
    /**
     * Combine data shared during the key generation protocol.
     * @param {KeyShare} participantShares private p-share and
     * n-shares received from all other participants.
     * @returns {KeyCombined} Returns the participant private x-share
     * and y-shares to be used when generating signing shares.
     */
    keyCombine(pShare: PShare, nShares: NShare[]): KeyCombined;
    /**
     * Derive shares for a BIP-32 subkey.
     * @param {PShare} The user's p-share.
     * @param {NShare[]} The n-shares received from the other participants.
     * @param {string} The BIP-32 path to derive.
     * @returns {SubkeyShare} Returns the private x-share and n-shares to
     * be distributed to participants at their corresponding index.
     */
    keyDerive(pShare: PShare, nShares: NShare[], path: string): SubkeyShare;
    /**
     * Verify Schnorr proof of knowledge of the discrete log of X_i = x_i * G.
     * @param Y The combined public key.
     * @param VSSs The VSS shares received from all participants.
     * @param index The i of X_i.
     * @param proof The schnorr proof.
     * @returns True if it's a valid proof with regards to Y and VSSs.
     */
    verifySchnorrProofX(Y: bigint, VSSs: bigint[][], index: number, proof: SchnorrProof): boolean;
    /**
     * Derives a child common keychain from common keychain
     *
     * @param {commonKeychain} The common keychain as a hex string.
     * @param {path} The BIP-32 path to derive.
     * @return {string} The derived common keychain as a hex string.
     */
    deriveUnhardened(commonKeychain: string, path: string): string;
    /**
     * Appends a given range proof challenge to the shares previously created
     * by #keyCombine. Generates a new challenge if not provided.
     * @param {XShare | YShare} share Private xShare or yShare of the signing operation
     * @param rangeProofChallenge - challenge generated via generateNtilde
     * @param paillierProofChallenge
     * @returns {KeyCombined} The share with amended challenge values
     */
    appendChallenge<T>(share: T, rangeProofChallenge: EcdsaTypes.SerializedNtilde, paillierProofChallenge: EcdsaTypes.SerializedPaillierChallenge): T & EcdsaTypes.SerializedEcdsaChallenges;
    /**
     * Create signing shares.
     * @param {xShare} xShare Private xShare of current participant signer
     * @param {YShare} yShare yShare corresponding to the other participant signer
     * @returns {SignShareRT} Returns the participant private w-share
     * and k-share to be distributed to other participant signer
     */
    signShare(xShare: XShareWithChallenges, yShare: YShareWithChallenges): Promise<SignShareRT>;
    /**
     * Perform multiplicitive-to-additive (MtA) share conversion with another signer.
     * Connection 1.2 in https://lucid.app/lucidchart/7061785b-bc5c-4002-b546-3f4a3612fc62/edit?page=IAVmvYO4FvKc#
     * If signer A completed signShare initially (input to this fn), then this step is completed by signer B.
     * @param {SignConvert} shares
     * @returns {SignConvertRT}
     */
    signConvertStep1(shares: SignConvertStep1): Promise<SignConvertStep1Response>;
    /**
     * Perform multiplicitive-to-additive (MtA) share conversion with another
     * signer.
     * Connection 2.1 in https://lucid.app/lucidchart/7061785b-bc5c-4002-b546-3f4a3612fc62/edit?page=IAVmvYO4FvKc#
     * If signer B completed signConvertStep1, then this step is completed by signer A.
     * @param {SignConvert} shares
     * @returns {SignConvertRT}
     */
    signConvertStep2(shares: SignConvertStep2): Promise<SignConvertStep2Response>;
    /**
     * Perform multiplicitive-to-additive (MtA) share conversion with another signer.
     * Connection 2.2 in https://lucid.app/lucidchart/7061785b-bc5c-4002-b546-3f4a3612fc62/edit?page=IAVmvYO4FvKc#
     * If signer A completed signConvertStep2, then this step is completed by signer B.
     * @param {SignConvert} shares
     * @returns {SignConvertRT}
     */
    signConvertStep3(shares: SignConvertStep3): Promise<SignConvertStep3Response>;
    /**
     * Perform multiplicitive-to-additive (MtA) share conversion with another signer.
     * @deprecated - use one of [signConvertStep1, signConvertStep2, signConvertStep3] instead
     * @param {SignConvert} shares
     * @returns {SignConvertRT}
     */
    signConvert(shares: SignConvert): Promise<SignConvertRT>;
    /**
     * Combine gamma shares to get the private omicron / delta shares
     * @param {SignCombine} shares
     * @returns {SignCombineRT}
     */
    signCombine(shares: SignCombine): SignCombineRT;
    /**
     * Sign a message.
     * @param {Buffer} M Message to be signed
     * @param {OShare} oShare private omicron share of current participant
     * @param {DShare} dShare delta share received from the other participant
     * @param {Hash} hash hashing algorithm implementing Node`s standard crypto hash interface
     * @param shouldHash if true, we hash the provided buffer before signing
     * @returns {VAShare}
     */
    sign(M: Buffer, oShare: OShare, dShare: DShare, hash?: Hash, shouldHash?: boolean): VAShare;
    /**
     * Generate proofs of V_i and A_i values.
     * @param {Buffer} M Message to commit to as part of the context of the proof.
     *    This doesn't need to be the same message that was signed in the sign function above.
     *    But it should be the same for all participants for the purpose of providing proof context.
     * @param {VAShare} vaShare The VAShare to prove.
     * @returns {VAShareWithProofs}
     */
    generateVAProofs(M: Buffer, vaShare: VAShare): VAShareWithProofs;
    /**
     * Verify V_i and A_i values of all other participants during signing phase 5 steps 5A and 5B.
     * @param {VAShareWithProofs} vaShare V_i, A_i info including SShare values of the currenct participant
     * @param {PublicVAShareWithProofs[]} publicVAShares public V_i, A_i info of all other participants
     * @returns {UTShare} U_i, T_i info of the current participant if all verifications pass
     */
    verifyVAShares(vaShare: VAShareWithProofs, publicVAShares: PublicVAShareWithProofs[]): UTShare;
    /**
     * Verify U_i and V_i values of all other participants during signing phase 5 steps 5C and 5D.
     * @param {UTShare} utShare U_i, T_i info including SShare values of the currenct participant
     * @param {PublicUTShare[]} publicUTShares public U_i, T_i info of all other participants
     * @returns {SShare} SShare of the current participant if all verifications pass
     */
    verifyUTShares(utShare: UTShare, publicUTShares: PublicUTShare[]): SShare;
    /**
     * Construct full signature by combining Sign Shares
     * @param {SShare[]} shares
     * @returns {Signature}
     */
    constructSignature(shares: SShare[]): Signature;
    /**
     * Verify ecdsa signatures
     * @param {Buffer} message
     * @param {Signature } signature
     * @param {Hash} hash hashing algorithm implementing Node`s standard crypto hash interface
     * @param {boolean} shouldHash if true, we hash the provided buffer before verifying
     * @returns {boolean} True if signature is valid; False otherwise
     */
    verify(message: Buffer, signature: Signature, hash?: Hash, shouldHash?: boolean): boolean;
    /**
     * Deserializes a challenge and it's proofs from hex strings to bigint
     * @deprecated use sdk-lib-mpc EcdsaTypes.deserializeNtilde instead
     */
    static deserializeNtilde(challenge: EcdsaTypes.SerializedNtilde): EcdsaTypes.DeserializedNtilde;
    /**
     * Serializes a challenge and it's proofs from big int to hex strings.
     * @deprecated use sdk-lib-mpc EcdsaTypes.deserializeNtilde instead
     * @param challenge
     */
    static serializeNtilde(challenge: EcdsaTypes.DeserializedNtilde): EcdsaTypes.SerializedNtilde;
}
//# sourceMappingURL=ecdsa.d.ts.map