/// <reference types="node" />
import { EcdsaTypes, HashCommitDecommit, SchnorrProof } from '@bitgo/sdk-lib-mpc';
/**
 * @deprecated use DeserializedNtildeProof from sdk-lib-mpc instead
 */
export declare type DeserializedNtildeProof = EcdsaTypes.DeserializedNtildeProof;
/**
 * @deprecated use DeserializedNtildeProofs from sdk-lib-mpc instead
 */
export declare type DeserializedNtildeProofs = EcdsaTypes.DeserializedNtildeProofs;
/**
 * @deprecated use DeserializedNtildeProofs from sdk-lib-mpc instead
 */
export declare type DeserializedNtilde = EcdsaTypes.DeserializedNtilde;
/**
 * @deprecated use DeserializedNtildeWithProofs from sdk-lib-mpc instead
 */
export declare type DeserializedNtildeWithProofs = EcdsaTypes.DeserializedNtildeWithProofs;
/**
 * @deprecated use SerializedNtildeProof from sdk-lib-mpc instead
 */
export declare type SerializedNtildeProof = EcdsaTypes.SerializedNtildeProof;
/**
 * @deprecated use SerializedNtildeProofs from sdk-lib-mpc instead
 */
export declare type SerializedNtildeProofs = EcdsaTypes.SerializedNtildeProofs;
/**
 * @deprecated use SerializedNtilde from sdk-lib-mpc instead
 */
export declare type SerializedNtilde = EcdsaTypes.SerializedNtilde;
/**
 * @deprecated use SerializedNtildeWithProofs from sdk-lib-mpc instead
 */
export declare type SerializedNtildeWithProofs = EcdsaTypes.SerializedNtildeWithProofs;
/**
 * @deprecated use XShare from sdk-lib-mpc instead
 */
export declare type XShare = EcdsaTypes.XShare;
export declare type PShare = {
    i: number;
    t?: number;
    c?: number;
    l: string;
    m: string;
    u: string;
    uu: string;
    n: string;
    y: string;
    chaincode: string;
};
export declare type SignIndex = {
    i: number;
    j: number;
};
export declare type NShare = SignIndex & {
    n: string;
    u: string;
    y: string;
    v?: string;
    chaincode: string;
};
export declare type KeyShare = {
    pShare: PShare;
    nShares: Record<number, NShare>;
};
export declare type XShareWithChallenges = EcdsaTypes.XShare & EcdsaTypes.SerializedNtilde & EcdsaTypes.SerializedPaillierChallenge;
export declare type YShare = SignIndex & {
    n: string;
};
export declare type YShareWithChallenges = YShare & EcdsaTypes.SerializedNtilde & EcdsaTypes.SerializedPaillierChallenge;
export interface KeyCombined {
    xShare: EcdsaTypes.XShare;
    yShares: Record<number, YShare>;
}
export declare type KeyCombinedWithNtilde = {
    xShare: XShareWithChallenges;
    yShares: Record<number, YShareWithChallenges>;
};
export declare type SubkeyShare = {
    xShare: EcdsaTypes.XShare;
    nShares: Record<number, NShare>;
};
export declare type WShare = EcdsaTypes.SerializedNtilde & EcdsaTypes.SerializedPaillierChallenge & {
    i: number;
    l: string;
    m: string;
    n: string;
    y: string;
    ck: string;
    k: string;
    w: string;
    gamma: string;
};
export declare type RangeProofShare = {
    z: string;
    u: string;
    w: string;
    s: string;
    s1: string;
    s2: string;
};
export declare type KShare = SignIndex & EcdsaTypes.SerializedNtilde & EcdsaTypes.SerializedPaillierChallenge & EcdsaTypes.SerializedPaillierChallengeProofs & {
    n: string;
    k: string;
    proof?: RangeProofShare;
};
export declare type SignShareRT = {
    wShare: WShare;
    kShare: KShare;
};
export declare type RangeProofWithCheckShare = {
    z: string;
    zprm: string;
    t: string;
    v: string;
    w: string;
    s: string;
    s1: string;
    s2: string;
    t1: string;
    t2: string;
    u: string;
    x: string;
};
export declare type AShare = SignIndex & EcdsaTypes.SerializedNtilde & EcdsaTypes.SerializedPaillierChallengeProofs & {
    n: string;
    k: string;
    alpha: string;
    mu: string;
    proof?: RangeProofShare;
    gammaProof?: RangeProofWithCheckShare;
    wProof?: RangeProofWithCheckShare;
};
export declare type BShare = WShare & {
    beta: string;
    nu: string;
};
export declare type MUShare = SignIndex & {
    alpha: string;
    mu: string;
    gammaProof: RangeProofWithCheckShare;
    wProof: RangeProofWithCheckShare;
};
export declare type GShare = {
    i: number;
    l?: string;
    m?: string;
    n: string;
    y: string;
    k: string;
    w: string;
    gamma: string;
    alpha: string;
    mu: string;
    beta: string;
    nu: string;
};
export declare type SignConvert = {
    xShare?: XShareWithChallenges;
    yShare?: YShare;
    kShare?: KShare;
    bShare?: BShare;
    muShare?: MUShare;
    aShare?: AShare;
    wShare?: WShare;
};
export declare type SignConvertStep1 = {
    xShare: XShareWithChallenges;
    yShare: YShare;
    kShare: KShare;
};
export declare type SignConvertStep1Response = {
    bShare: BShare;
    aShare: AShare;
};
export declare type SignConvertStep2 = {
    wShare: WShare;
    aShare: AShare;
};
export declare type SignConvertStep2Response = {
    gShare: GShare;
    muShare: MUShare;
};
export declare type SignConvertStep3 = {
    bShare: BShare;
    muShare: MUShare;
};
export declare type SignConvertStep3Response = {
    gShare: GShare;
    signIndex: SignIndex;
};
export declare type SignConvertRT = {
    aShare?: AShare;
    bShare?: BShare;
    muShare?: MUShare;
    gShare?: GShare;
};
export declare type OShare = {
    i: number;
    y: string;
    k: string;
    omicron: string;
    delta: string;
    Gamma: string;
};
export declare type DShare = SignIndex & {
    delta: string;
    Gamma: string;
};
export declare type SShare = {
    i: number;
    R: string;
    s: string;
    y: string;
};
export declare type SignCombine = {
    gShare: GShare;
    signIndex: SignIndex;
};
export declare type SignCombineRT = {
    oShare: OShare;
    dShare: DShare;
};
export declare type Signature = {
    y: string;
    recid: number;
    r: string;
    s: string;
};
export interface PublicVAShare {
    V: bigint;
    A: bigint;
    comDecomVA: HashCommitDecommit;
}
export interface PublicVAShareWithProofs extends PublicVAShare, VAProofs {
}
export interface VAShare extends SShare, PublicVAShare {
    m: Buffer;
    l: bigint;
    rho: bigint;
}
export interface VAProofs {
    zkVProofV: EcdsaTypes.ZkVProof;
    schnorrProofA: SchnorrProof;
}
export interface VAShareWithProofs extends VAShare, VAProofs {
    proofContext: Buffer;
}
export interface PublicUTShare {
    U: bigint;
    T: bigint;
    comDecomUT: HashCommitDecommit;
}
export interface UTShare extends SShare, PublicUTShare {
}
//# sourceMappingURL=types.d.ts.map