"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTransaction = void 0;
const errors_1 = require("./errors");
/**
 * Generic transaction to be extended with coin specific logic.
 */
class BaseTransaction {
    /**
     * Base constructor.
     *
     * @param _coinConfig BaseCoin from statics library
     */
    constructor(_coinConfig) {
        this._coinConfig = _coinConfig;
        this._inputs = [];
        this._outputs = [];
        this._signatures = [];
        this._id = undefined;
        this._type = undefined;
    }
    /**
     * Get the transaction id as seen in the blockchain. Transactions computed offline may not have an
     * id, however, this is left to the coin implementation.
     */
    get id() {
        return this._id;
    }
    /**
     * One of {@link TransactionType}
     */
    get type() {
        return this._type;
    }
    /**
     * Get the list of outputs. Amounts are expressed in absolute value.
     */
    get outputs() {
        return this._outputs;
    }
    /**
     * Get the list of inputs. Amounts are expressed in absolute value.
     */
    get inputs() {
        return this._inputs;
    }
    /**
     * Get the list of signatures (if any) produced for this transaction.
     */
    get signature() {
        return this._signatures;
    }
    /**
     * Returns the portion of the transaction that needs to be signed in Buffer format.
     * Only needed for coins that support adding signatures directly (e.g. TSS).
     */
    get signablePayload() {
        throw new errors_1.NotImplementedError('signablePayload not implemented');
    }
    /**
     * Explain/parse a given coin transaction
     * TODO: Move all previous explainTransactions from 'core' to 'account-lib' for other coins,
     * TODO: convert to abstract
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    explainTransaction() { }
}
exports.BaseTransaction = BaseTransaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZVRyYW5zYWN0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2FjY291bnQtbGliL2Jhc2VDb2luL2Jhc2VUcmFuc2FjdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFHQSxxQ0FBK0M7QUFFL0M7O0dBRUc7QUFDSCxNQUFzQixlQUFlO0lBT25DOzs7O09BSUc7SUFDSCxZQUFzQixXQUFpQztRQUNyRCxJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztRQUMvQixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztRQUNsQixJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztRQUNuQixJQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsR0FBRyxHQUFHLFNBQVMsQ0FBQztRQUNyQixJQUFJLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQztJQUN6QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFBSSxFQUFFO1FBQ0osT0FBTyxJQUFJLENBQUMsR0FBYSxDQUFDO0lBQzVCLENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksSUFBSTtRQUNOLE9BQU8sSUFBSSxDQUFDLEtBQXdCLENBQUM7SUFDdkMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBSSxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksTUFBTTtRQUNSLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN0QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQztJQXNCRDs7O09BR0c7SUFDSCxJQUFJLGVBQWU7UUFDakIsTUFBTSxJQUFJLDRCQUFtQixDQUFDLGlDQUFpQyxDQUFDLENBQUM7SUFDbkUsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxnRUFBZ0U7SUFDaEUsa0JBQWtCLEtBQVMsQ0FBQztDQUM3QjtBQTVGRCwwQ0E0RkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ29pbiBhcyBDb2luQ29uZmlnIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHsgQmFzZUtleSwgRW50cnkgfSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJy4vZW51bSc7XG5pbXBvcnQgeyBOb3RJbXBsZW1lbnRlZEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuXG4vKipcbiAqIEdlbmVyaWMgdHJhbnNhY3Rpb24gdG8gYmUgZXh0ZW5kZWQgd2l0aCBjb2luIHNwZWNpZmljIGxvZ2ljLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVRyYW5zYWN0aW9uIHtcbiAgcHJvdGVjdGVkIF9pZDogc3RyaW5nIHwgdW5kZWZpbmVkOyAvLyBUaGUgdHJhbnNhY3Rpb24gaWQgYXMgc2VlbiBpbiB0aGUgYmxvY2tjaGFpblxuICBwcm90ZWN0ZWQgX2lucHV0czogRW50cnlbXTtcbiAgcHJvdGVjdGVkIF9vdXRwdXRzOiBFbnRyeVtdO1xuICBwcm90ZWN0ZWQgX3R5cGU6IFRyYW5zYWN0aW9uVHlwZSB8IHVuZGVmaW5lZDtcbiAgcHJvdGVjdGVkIF9zaWduYXR1cmVzOiBzdHJpbmdbXTtcbiAgcHJvdGVjdGVkIF9jb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPjtcbiAgLyoqXG4gICAqIEJhc2UgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBfY29pbkNvbmZpZyBCYXNlQ29pbiBmcm9tIHN0YXRpY3MgbGlicmFyeVxuICAgKi9cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKF9jb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xuICAgIHRoaXMuX2NvaW5Db25maWcgPSBfY29pbkNvbmZpZztcbiAgICB0aGlzLl9pbnB1dHMgPSBbXTtcbiAgICB0aGlzLl9vdXRwdXRzID0gW107XG4gICAgdGhpcy5fc2lnbmF0dXJlcyA9IFtdO1xuICAgIHRoaXMuX2lkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3R5cGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0cmFuc2FjdGlvbiBpZCBhcyBzZWVuIGluIHRoZSBibG9ja2NoYWluLiBUcmFuc2FjdGlvbnMgY29tcHV0ZWQgb2ZmbGluZSBtYXkgbm90IGhhdmUgYW5cbiAgICogaWQsIGhvd2V2ZXIsIHRoaXMgaXMgbGVmdCB0byB0aGUgY29pbiBpbXBsZW1lbnRhdGlvbi5cbiAgICovXG4gIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9pZCBhcyBzdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogT25lIG9mIHtAbGluayBUcmFuc2FjdGlvblR5cGV9XG4gICAqL1xuICBnZXQgdHlwZSgpOiBUcmFuc2FjdGlvblR5cGUge1xuICAgIHJldHVybiB0aGlzLl90eXBlIGFzIFRyYW5zYWN0aW9uVHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2Ygb3V0cHV0cy4gQW1vdW50cyBhcmUgZXhwcmVzc2VkIGluIGFic29sdXRlIHZhbHVlLlxuICAgKi9cbiAgZ2V0IG91dHB1dHMoKTogRW50cnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuX291dHB1dHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0IG9mIGlucHV0cy4gQW1vdW50cyBhcmUgZXhwcmVzc2VkIGluIGFic29sdXRlIHZhbHVlLlxuICAgKi9cbiAgZ2V0IGlucHV0cygpOiBFbnRyeVtdIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdCBvZiBzaWduYXR1cmVzIChpZiBhbnkpIHByb2R1Y2VkIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgZ2V0IHNpZ25hdHVyZSgpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZXM7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcHJpdmF0ZSBrZXkgY2FuIHNpZ24gdGhpcyB0cmFuc2FjdGlvbiBpbiBpdHMgY3VycmVudCBzdGF0ZSBvciBub3QuIGl0IGlzIHBvc3NpYmxlXG4gICAqIHNvbWUgdHJhbnNhY3Rpb25zIGNhbiBvbmx5IGVuZm9yY2UgdGhpcyBjaGVjayBhZnRlciBzb21lIG90aGVyIGZpZWxkcyBoYXZlIGJlZW4gZmlsbGVkIGFscmVhZHlcbiAgICogb3IgZXZlbiBkdXJpbmcgYnVpbGQgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtCYXNlS2V5fSBrZXkgUHJpdmF0ZSBrZXkgdG8gdmVyaWZ5IHBlcm1pc3Npb25zIG9uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZiB0aGUga2V5IGNhbm5vdCBzaWduIHRoZSB0cmFuc2FjdGlvbiB3aXRob3V0IGEgZG91YnQsIHRydWUgb3RoZXJ3aXNlXG4gICAqL1xuICBhYnN0cmFjdCBjYW5TaWduKGtleTogQmFzZUtleSk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdHJhbnNhY3Rpb24gaW4gYSBjb2luIHNwZWNpZmljIEpTT04gZm9ybWF0LlxuICAgKi9cbiAgYWJzdHJhY3QgdG9Kc29uKCk6IGFueTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0cmFuc2FjdGlvbiBpbiBhIGZvcm1hdCBpdCBjYW4gYmUgYnJvYWRjYXN0ZWQgdG8gdGhlIGJsb2NrY2hhaW4uXG4gICAqL1xuICBhYnN0cmFjdCB0b0Jyb2FkY2FzdEZvcm1hdCgpOiBhbnk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBvcnRpb24gb2YgdGhlIHRyYW5zYWN0aW9uIHRoYXQgbmVlZHMgdG8gYmUgc2lnbmVkIGluIEJ1ZmZlciBmb3JtYXQuXG4gICAqIE9ubHkgbmVlZGVkIGZvciBjb2lucyB0aGF0IHN1cHBvcnQgYWRkaW5nIHNpZ25hdHVyZXMgZGlyZWN0bHkgKGUuZy4gVFNTKS5cbiAgICovXG4gIGdldCBzaWduYWJsZVBheWxvYWQoKTogQnVmZmVyIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignc2lnbmFibGVQYXlsb2FkIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGxhaW4vcGFyc2UgYSBnaXZlbiBjb2luIHRyYW5zYWN0aW9uXG4gICAqIFRPRE86IE1vdmUgYWxsIHByZXZpb3VzIGV4cGxhaW5UcmFuc2FjdGlvbnMgZnJvbSAnY29yZScgdG8gJ2FjY291bnQtbGliJyBmb3Igb3RoZXIgY29pbnMsXG4gICAqIFRPRE86IGNvbnZlcnQgdG8gYWJzdHJhY3RcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgZXhwbGFpblRyYW5zYWN0aW9uKCk6IGFueSB7fVxufVxuIl19