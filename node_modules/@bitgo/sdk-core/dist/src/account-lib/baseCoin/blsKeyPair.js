"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlsKeyPair = void 0;
const assert_1 = __importDefault(require("assert"));
const crypto_1 = require("crypto");
const BLS = __importStar(require("@bitgo/bls-dkg"));
const errors_1 = require("./errors");
const iface_1 = require("./iface");
const crypto_2 = require("../util/crypto");
const DEFAULT_SIGNATURE_THRESHOLD = 2;
const DEFAULT_SIGNATURE_PARTICIPANTS = 3;
/**
 * Base class for BLS keypairs.
 */
class BlsKeyPair {
    /**
     * Public constructor. By default, creates a key pair with a random polynomial.
     *
     * @param {KeyPairOptions} source Either a dkg options, a public and secret shares, or a private key
     */
    constructor(source) {
        if (!source) {
            this.createShares(DEFAULT_SIGNATURE_THRESHOLD, DEFAULT_SIGNATURE_PARTICIPANTS);
        }
        else if ((0, iface_1.isDkg)(source)) {
            this.createShares(source.threshold, source.participants);
        }
        else if ((0, iface_1.isBlsKey)(source)) {
            (0, assert_1.default)(source.secretShares.every(crypto_2.isValidBLSPrivateKey), 'Invalid private keys');
            (0, assert_1.default)((0, crypto_2.isValidBLSPublicKey)(source.publicShare), 'Invalid public key');
            this.keyPair = source;
        }
        else if ((0, iface_1.isPrivateKey)(source)) {
            this.keyPair = {
                prv: source.prv,
                publicShare: '',
                secretShares: [],
                seed: '',
                chaincode: '',
            };
        }
        else {
            throw new Error('Invalid key pair options');
        }
    }
    createShares(threshold, participants) {
        if (participants < threshold) {
            throw new Error('Participants should be greater than threshold');
        }
        const polynomial = BLS.generatePolynomial(threshold);
        const keySecretShares = BLS.secretShares(polynomial, participants);
        const keyPublicShare = BLS.publicShare(polynomial);
        this.keyPair = {
            seed: (0, crypto_2.bigIntToHex)(polynomial[0], 64),
            chaincode: (0, crypto_1.randomBytes)(32).toString('hex'),
            secretShares: keySecretShares.map((secretShare) => (0, crypto_2.bigIntToHex)(secretShare, 64)),
            publicShare: (0, crypto_2.bigIntToHex)(keyPublicShare),
        };
    }
    /**
     * Note - this is not possible using BLS. BLS does not support prvkey derived key gen
     *
     * @param {string[]} prv a hexadecimal private key
     */
    recordKeysFromPrivateKey(prv) {
        throw new errors_1.NotImplementedError('Private key derivation is not supported in bls');
    }
    /**
     * Note - this is not possible using BLS. BLS does not support pubkey derived key gen
     *
     * @param {string} pub - An extended, compressed, or uncompressed public key
     */
    recordKeysFromPublicKey(pub) {
        throw new errors_1.NotImplementedError('Public key derivation is not supported in bls');
    }
    getAddress(format) {
        throw new errors_1.NotImplementedError('getAddress not implemented');
    }
    getKeys() {
        throw new errors_1.NotImplementedError('getKeys not implemented');
    }
    /**
     * Signs bytes using the key pair
     *
     * @param msg The message bytes to sign
     * @return signature of the bytes using this keypair
     */
    async sign(msg) {
        if (this.keyPair.prv) {
            const signedMessage = await BLS.sign(msg, BigInt('0x' + this.keyPair.prv));
            return '0x' + (0, crypto_2.bigIntToHex)(signedMessage);
        }
        throw new Error('Missing private key');
    }
    static keyDerive(seed, pk, chaincode, path) {
        const seedBI = BigInt('0x' + seed);
        const pkBI = BigInt('0x' + pk);
        const chaincodeBI = BigInt('0x' + chaincode);
        const childKey = BLS.privateDerive(seedBI, pkBI, chaincodeBI, path);
        const childChaincode = (0, crypto_2.bigIntToHex)(childKey.chaincode);
        const entropy = BigInt('0x' + (0, crypto_1.randomBytes)(32).toString('hex'));
        const secretShares = BLS.secretShares([childKey.sk, entropy], DEFAULT_SIGNATURE_PARTICIPANTS);
        const publicShare = BLS.publicShare([childKey.sk]);
        return {
            seed,
            chaincode: childChaincode,
            secretShares: secretShares.map((secretShare) => (0, crypto_2.bigIntToHex)(secretShare)),
            publicShare: (0, crypto_2.bigIntToHex)(publicShare),
        };
    }
    /**
     * Aggregates the secret shares of different key pairs into one private key
     *
     * @param prvKeys an array of secret shares
     * @returns a private key
     */
    static aggregatePrvkeys(prvKeys) {
        (0, assert_1.default)(prvKeys.every(crypto_2.isValidBLSPrivateKey), 'Invalid private keys');
        try {
            const secretShares = prvKeys.map((secretShare) => BigInt('0x' + secretShare));
            const prv = BLS.mergeSecretShares(secretShares);
            return (0, crypto_2.bigIntToHex)(prv);
        }
        catch (e) {
            throw new Error('Error aggregating prvkeys: ' + e);
        }
    }
    /**
     * Aggregates the public shares of different key pairs into a common public key
     *
     * @param pubKeys an array of public shares
     * @returns a common public key
     */
    static aggregatePubkeys(pubKeys) {
        try {
            const publicShares = pubKeys.map((publicShare) => BigInt('0x' + publicShare));
            const commonPubKey = BLS.mergePublicShares(publicShares);
            return (0, crypto_2.bigIntToHex)(commonPubKey);
        }
        catch (e) {
            throw new Error('Error aggregating pubkeys: ' + e);
        }
    }
    static aggregateChaincodes(chaincodeContributions) {
        try {
            const chaincodes = chaincodeContributions.map((chaincode) => BigInt('0x' + chaincode));
            const commonChaincode = BLS.mergeChaincodes(chaincodes);
            return (0, crypto_2.bigIntToHex)(commonChaincode, 64);
        }
        catch (e) {
            throw new Error('Error aggregating chaincodes: ' + e);
        }
    }
    /**
     * Aggregates the message signed by different key pairs into one sign
     *
     * @param signatures the message signed by different key pairs. The signer id is relevant to ensure a valid signature.
     * @example <caption> E.g., the message is signed by user and wallet, then signatures would be:</caption>
     * {
     *   1: BigInt(messageSignedWithUserPrv),
     *   3: BigInt(messageSignedWithWalletPrv),
     * }
     * @returns a signature combining all the provided signed messages
     */
    static aggregateSignatures(signatures) {
        try {
            const signature = BLS.mergeSignatures(signatures);
            return '0x' + (0, crypto_2.bigIntToHex)(signature);
        }
        catch (e) {
            throw new Error('Error aggregating signatures: ' + e);
        }
    }
    /**
     * Verifies the signature for this key pair
     * @param pub The public key with which to verify the signature
     * @param msg The message to verify the signature with
     * @param signature the signature to verify
     * @return true if the signature is valid, else false
     */
    static async verifySignature(pub, msg, signature) {
        (0, assert_1.default)((0, crypto_2.isValidBLSPublicKey)(pub), `Invalid public key: ${pub}`);
        return await BLS.verify(BigInt(signature), msg, BigInt('0x' + pub));
    }
}
exports.BlsKeyPair = BlsKeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmxzS2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hY2NvdW50LWxpYi9iYXNlQ29pbi9ibHNLZXlQYWlyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0RBQTRCO0FBQzVCLG1DQUFxQztBQUNyQyxvREFBc0M7QUFHdEMscUNBQStDO0FBQy9DLG1DQUFpRjtBQUNqRiwyQ0FBd0Y7QUFFeEYsTUFBTSwyQkFBMkIsR0FBRyxDQUFDLENBQUM7QUFDdEMsTUFBTSw4QkFBOEIsR0FBRyxDQUFDLENBQUM7QUFFekM7O0dBRUc7QUFDSCxNQUFzQixVQUFVO0lBRzlCOzs7O09BSUc7SUFDSCxZQUFzQixNQUF1QjtRQUMzQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1gsSUFBSSxDQUFDLFlBQVksQ0FBQywyQkFBMkIsRUFBRSw4QkFBOEIsQ0FBQyxDQUFDO1NBQ2hGO2FBQU0sSUFBSSxJQUFBLGFBQUssRUFBQyxNQUFNLENBQUMsRUFBRTtZQUN4QixJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQzFEO2FBQU0sSUFBSSxJQUFBLGdCQUFRLEVBQUMsTUFBTSxDQUFDLEVBQUU7WUFDM0IsSUFBQSxnQkFBTSxFQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLDZCQUFvQixDQUFDLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztZQUNoRixJQUFBLGdCQUFNLEVBQUMsSUFBQSw0QkFBbUIsRUFBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztZQUN0RSxJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztTQUN2QjthQUFNLElBQUksSUFBQSxvQkFBWSxFQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQy9CLElBQUksQ0FBQyxPQUFPLEdBQUc7Z0JBQ2IsR0FB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QUN0QztRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQ0FBZ0MsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUN2RDtJQUNILENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxHQUFXLEVBQUUsR0FBVyxFQUFFLFNBQWlCO1FBQzdFLElBQUEsZ0JBQU0sRUFBQyxJQUFBLDRCQUFtQixFQUFDLEdBQUcsQ0FBQyxFQUFFLHVCQUF1QixHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQy9ELE9BQU8sTUFBTSxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRSxHQUFHLEVBQUUsTUFBTSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7Q0FDRjtBQWhMRCxnQ0FnTEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgKiBhcyBCTFMgZnJvbSAnQGJpdGdvL2Jscy1ka2cnO1xuaW1wb3J0IHsgQmFzZUtleVBhaXIgfSBmcm9tICcuL2Jhc2VLZXlQYWlyJztcbmltcG9ydCB7IEFkZHJlc3NGb3JtYXQgfSBmcm9tICcuL2VudW0nO1xuaW1wb3J0IHsgTm90SW1wbGVtZW50ZWRFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IEJsc0tleXMsIEtleVBhaXJPcHRpb25zLCBpc0RrZywgaXNCbHNLZXksIGlzUHJpdmF0ZUtleSB9IGZyb20gJy4vaWZhY2UnO1xuaW1wb3J0IHsgaXNWYWxpZEJMU1B1YmxpY0tleSwgaXNWYWxpZEJMU1ByaXZhdGVLZXksIGJpZ0ludFRvSGV4IH0gZnJvbSAnLi4vdXRpbC9jcnlwdG8nO1xuXG5jb25zdCBERUZBVUxUX1NJR05BVFVSRV9USFJFU0hPTEQgPSAyO1xuY29uc3QgREVGQVVMVF9TSUdOQVRVUkVfUEFSVElDSVBBTlRTID0gMztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBCTFMga2V5cGFpcnMuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCbHNLZXlQYWlyIGltcGxlbWVudHMgQmFzZUtleVBhaXIge1xuICBwcm90ZWN0ZWQga2V5UGFpcjogQmxzS2V5cztcblxuICAvKipcbiAgICogUHVibGljIGNvbnN0cnVjdG9yLiBCeSBkZWZhdWx0LCBjcmVhdGVzIGEga2V5IHBhaXIgd2l0aCBhIHJhbmRvbSBwb2x5bm9taWFsLlxuICAgKlxuICAgKiBAcGFyYW0ge0tleVBhaXJPcHRpb25zfSBzb3VyY2UgRWl0aGVyIGEgZGtnIG9wdGlvbnMsIGEgcHVibGljIGFuZCBzZWNyZXQgc2hhcmVzLCBvciBhIHByaXZhdGUga2V5XG4gICAqL1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3Ioc291cmNlPzogS2V5UGFpck9wdGlvbnMpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgdGhpcy5jcmVhdGVTaGFyZXMoREVGQVVMVF9TSUdOQVRVUkVfVEhSRVNIT0xELCBERUZBVUxUX1NJR05BVFVSRV9QQVJUSUNJUEFOVFMpO1xuICAgIH0gZWxzZSBpZiAoaXNEa2coc291cmNlKSkge1xuICAgICAgdGhpcy5jcmVhdGVTaGFyZXMoc291cmNlLnRocmVzaG9sZCwgc291cmNlLnBhcnRpY2lwYW50cyk7XG4gICAgfSBlbHNlIGlmIChpc0Jsc0tleShzb3VyY2UpKSB7XG4gICAgICBhc3NlcnQoc291cmNlLnNlY3JldFNoYXJlcy5ldmVyeShpc1ZhbGlkQkxTUHJpdmF0ZUtleSksICdJbnZhbGlkIHByaXZhdGUga2V5cycpO1xuICAgICAgYXNzZXJ0KGlzVmFsaWRCTFNQdWJsaWNLZXkoc291cmNlLnB1YmxpY1NoYXJlKSwgJ0ludmFsaWQgcHVibGljIGtleScpO1xuICAgICAgdGhpcy5rZXlQYWlyID0gc291cmNlO1xuICAgIH0gZWxzZSBpZiAoaXNQcml2YXRlS2V5KHNvdXJjZSkpIHtcbiAgICAgIHRoaXMua2V5UGFpciA9IHtcbiAgICAgICAgcHJ2OiBzb3VyY2UucHJ2LFxuICAgICAgICBwdWJsaWNTaGFyZTogJycsXG4gICAgICAgIHNlY3JldFNoYXJlczogW10sXG4gICAgICAgIHNlZWQ6ICcnLFxuICAgICAgICBjaGFpbmNvZGU6ICcnLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSBwYWlyIG9wdGlvbnMnKTtcbiAgICB9XG4gIH1cblxuICBjcmVhdGVTaGFyZXModGhyZXNob2xkOiBudW1iZXIsIHBhcnRpY2lwYW50czogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHBhcnRpY2lwYW50cyA8IHRocmVzaG9sZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJ0aWNpcGFudHMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiB0aHJlc2hvbGQnKTtcbiAgICB9XG4gICAgY29uc3QgcG9seW5vbWlhbCA9IEJMUy5nZW5lcmF0ZVBvbHlub21pYWwodGhyZXNob2xkKTtcbiAgICBjb25zdCBrZXlTZWNyZXRTaGFyZXMgPSBCTFMuc2VjcmV0U2hhcmVzKHBvbHlub21pYWwsIHBhcnRpY2lwYW50cyk7XG4gICAgY29uc3Qga2V5UHVibGljU2hhcmUgPSBCTFMucHVibGljU2hhcmUocG9seW5vbWlhbCk7XG4gICAgdGhpcy5rZXlQYWlyID0ge1xuICAgICAgc2VlZDogYmlnSW50VG9IZXgocG9seW5vbWlhbFswXSwgNjQpLFxuICAgICAgY2hhaW5jb2RlOiByYW5kb21CeXRlcygzMikudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgc2VjcmV0U2hhcmVzOiBrZXlTZWNyZXRTaGFyZXMubWFwKChzZWNyZXRTaGFyZSkgPT4gYmlnSW50VG9IZXgoc2VjcmV0U2hhcmUsIDY0KSksXG4gICAgICBwdWJsaWNTaGFyZTogYmlnSW50VG9IZXgoa2V5UHVibGljU2hhcmUpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTm90ZSAtIHRoaXMgaXMgbm90IHBvc3NpYmxlIHVzaW5nIEJMUy4gQkxTIGRvZXMgbm90IHN1cHBvcnQgcHJ2a2V5IGRlcml2ZWQga2V5IGdlblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwcnYgYSBoZXhhZGVjaW1hbCBwcml2YXRlIGtleVxuICAgKi9cbiAgcmVjb3JkS2V5c0Zyb21Qcml2YXRlS2V5KHBydjogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ1ByaXZhdGUga2V5IGRlcml2YXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiBibHMnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RlIC0gdGhpcyBpcyBub3QgcG9zc2libGUgdXNpbmcgQkxTLiBCTFMgZG9lcyBub3Qgc3VwcG9ydCBwdWJrZXkgZGVyaXZlZCBrZXkgZ2VuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwdWIgLSBBbiBleHRlbmRlZCwgY29tcHJlc3NlZCwgb3IgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXlcbiAgICovXG4gIHJlY29yZEtleXNGcm9tUHVibGljS2V5KHB1Yjogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ1B1YmxpYyBrZXkgZGVyaXZhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIGJscycpO1xuICB9XG5cbiAgZ2V0QWRkcmVzcyhmb3JtYXQ/OiBBZGRyZXNzRm9ybWF0KTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignZ2V0QWRkcmVzcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIGdldEtleXMoKTogYW55IHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignZ2V0S2V5cyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyBieXRlcyB1c2luZyB0aGUga2V5IHBhaXJcbiAgICpcbiAgICogQHBhcmFtIG1zZyBUaGUgbWVzc2FnZSBieXRlcyB0byBzaWduXG4gICAqIEByZXR1cm4gc2lnbmF0dXJlIG9mIHRoZSBieXRlcyB1c2luZyB0aGlzIGtleXBhaXJcbiAgICovXG4gIGFzeW5jIHNpZ24obXNnOiBCdWZmZXIpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICh0aGlzLmtleVBhaXIucHJ2KSB7XG4gICAgICBjb25zdCBzaWduZWRNZXNzYWdlID0gYXdhaXQgQkxTLnNpZ24obXNnLCBCaWdJbnQoJzB4JyArIHRoaXMua2V5UGFpci5wcnYpKTtcbiAgICAgIHJldHVybiAnMHgnICsgYmlnSW50VG9IZXgoc2lnbmVkTWVzc2FnZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcml2YXRlIGtleScpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBrZXlEZXJpdmUoc2VlZDogc3RyaW5nLCBwazogc3RyaW5nLCBjaGFpbmNvZGU6IHN0cmluZywgcGF0aDogc3RyaW5nKTogQmxzS2V5cyB7XG4gICAgY29uc3Qgc2VlZEJJID0gQmlnSW50KCcweCcgKyBzZWVkKTtcbiAgICBjb25zdCBwa0JJID0gQmlnSW50KCcweCcgKyBwayk7XG4gICAgY29uc3QgY2hhaW5jb2RlQkkgPSBCaWdJbnQoJzB4JyArIGNoYWluY29kZSk7XG4gICAgY29uc3QgY2hpbGRLZXkgPSBCTFMucHJpdmF0ZURlcml2ZShzZWVkQkksIHBrQkksIGNoYWluY29kZUJJLCBwYXRoKTtcbiAgICBjb25zdCBjaGlsZENoYWluY29kZSA9IGJpZ0ludFRvSGV4KGNoaWxkS2V5LmNoYWluY29kZSk7XG4gICAgY29uc3QgZW50cm9weSA9IEJpZ0ludCgnMHgnICsgcmFuZG9tQnl0ZXMoMzIpLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgY29uc3Qgc2VjcmV0U2hhcmVzID0gQkxTLnNlY3JldFNoYXJlcyhbY2hpbGRLZXkuc2ssIGVudHJvcHldLCBERUZBVUxUX1NJR05BVFVSRV9QQVJUSUNJUEFOVFMpO1xuICAgIGNvbnN0IHB1YmxpY1NoYXJlID0gQkxTLnB1YmxpY1NoYXJlKFtjaGlsZEtleS5za10pO1xuICAgIHJldHVybiB7XG4gICAgICBzZWVkLFxuICAgICAgY2hhaW5jb2RlOiBjaGlsZENoYWluY29kZSxcbiAgICAgIHNlY3JldFNoYXJlczogc2VjcmV0U2hhcmVzLm1hcCgoc2VjcmV0U2hhcmUpID0+IGJpZ0ludFRvSGV4KHNlY3JldFNoYXJlKSksXG4gICAgICBwdWJsaWNTaGFyZTogYmlnSW50VG9IZXgocHVibGljU2hhcmUpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWdncmVnYXRlcyB0aGUgc2VjcmV0IHNoYXJlcyBvZiBkaWZmZXJlbnQga2V5IHBhaXJzIGludG8gb25lIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSBwcnZLZXlzIGFuIGFycmF5IG9mIHNlY3JldCBzaGFyZXNcbiAgICogQHJldHVybnMgYSBwcml2YXRlIGtleVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhZ2dyZWdhdGVQcnZrZXlzKHBydktleXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICBhc3NlcnQocHJ2S2V5cy5ldmVyeShpc1ZhbGlkQkxTUHJpdmF0ZUtleSksICdJbnZhbGlkIHByaXZhdGUga2V5cycpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZWNyZXRTaGFyZXMgPSBwcnZLZXlzLm1hcCgoc2VjcmV0U2hhcmUpID0+IEJpZ0ludCgnMHgnICsgc2VjcmV0U2hhcmUpKTtcbiAgICAgIGNvbnN0IHBydiA9IEJMUy5tZXJnZVNlY3JldFNoYXJlcyhzZWNyZXRTaGFyZXMpO1xuICAgICAgcmV0dXJuIGJpZ0ludFRvSGV4KHBydik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZ2dyZWdhdGluZyBwcnZrZXlzOiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFnZ3JlZ2F0ZXMgdGhlIHB1YmxpYyBzaGFyZXMgb2YgZGlmZmVyZW50IGtleSBwYWlycyBpbnRvIGEgY29tbW9uIHB1YmxpYyBrZXlcbiAgICpcbiAgICogQHBhcmFtIHB1YktleXMgYW4gYXJyYXkgb2YgcHVibGljIHNoYXJlc1xuICAgKiBAcmV0dXJucyBhIGNvbW1vbiBwdWJsaWMga2V5XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFnZ3JlZ2F0ZVB1YmtleXMocHViS2V5czogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwdWJsaWNTaGFyZXMgPSBwdWJLZXlzLm1hcCgocHVibGljU2hhcmUpID0+IEJpZ0ludCgnMHgnICsgcHVibGljU2hhcmUpKTtcbiAgICAgIGNvbnN0IGNvbW1vblB1YktleSA9IEJMUy5tZXJnZVB1YmxpY1NoYXJlcyhwdWJsaWNTaGFyZXMpO1xuICAgICAgcmV0dXJuIGJpZ0ludFRvSGV4KGNvbW1vblB1YktleSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZ2dyZWdhdGluZyBwdWJrZXlzOiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBhZ2dyZWdhdGVDaGFpbmNvZGVzKGNoYWluY29kZUNvbnRyaWJ1dGlvbnM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2hhaW5jb2RlcyA9IGNoYWluY29kZUNvbnRyaWJ1dGlvbnMubWFwKChjaGFpbmNvZGUpID0+IEJpZ0ludCgnMHgnICsgY2hhaW5jb2RlKSk7XG4gICAgICBjb25zdCBjb21tb25DaGFpbmNvZGUgPSBCTFMubWVyZ2VDaGFpbmNvZGVzKGNoYWluY29kZXMpO1xuICAgICAgcmV0dXJuIGJpZ0ludFRvSGV4KGNvbW1vbkNoYWluY29kZSwgNjQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYWdncmVnYXRpbmcgY2hhaW5jb2RlczogJyArIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZ2dyZWdhdGVzIHRoZSBtZXNzYWdlIHNpZ25lZCBieSBkaWZmZXJlbnQga2V5IHBhaXJzIGludG8gb25lIHNpZ25cbiAgICpcbiAgICogQHBhcmFtIHNpZ25hdHVyZXMgdGhlIG1lc3NhZ2Ugc2lnbmVkIGJ5IGRpZmZlcmVudCBrZXkgcGFpcnMuIFRoZSBzaWduZXIgaWQgaXMgcmVsZXZhbnQgdG8gZW5zdXJlIGEgdmFsaWQgc2lnbmF0dXJlLlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj4gRS5nLiwgdGhlIG1lc3NhZ2UgaXMgc2lnbmVkIGJ5IHVzZXIgYW5kIHdhbGxldCwgdGhlbiBzaWduYXR1cmVzIHdvdWxkIGJlOjwvY2FwdGlvbj5cbiAgICoge1xuICAgKiAgIDE6IEJpZ0ludChtZXNzYWdlU2lnbmVkV2l0aFVzZXJQcnYpLFxuICAgKiAgIDM6IEJpZ0ludChtZXNzYWdlU2lnbmVkV2l0aFdhbGxldFBydiksXG4gICAqIH1cbiAgICogQHJldHVybnMgYSBzaWduYXR1cmUgY29tYmluaW5nIGFsbCB0aGUgcHJvdmlkZWQgc2lnbmVkIG1lc3NhZ2VzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFnZ3JlZ2F0ZVNpZ25hdHVyZXMoc2lnbmF0dXJlczogeyBbbjogbnVtYmVyXTogYmlnaW50IH0pOiBzdHJpbmcge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBCTFMubWVyZ2VTaWduYXR1cmVzKHNpZ25hdHVyZXMpO1xuICAgICAgcmV0dXJuICcweCcgKyBiaWdJbnRUb0hleChzaWduYXR1cmUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYWdncmVnYXRpbmcgc2lnbmF0dXJlczogJyArIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGUgc2lnbmF0dXJlIGZvciB0aGlzIGtleSBwYWlyXG4gICAqIEBwYXJhbSBwdWIgVGhlIHB1YmxpYyBrZXkgd2l0aCB3aGljaCB0byB2ZXJpZnkgdGhlIHNpZ25hdHVyZVxuICAgKiBAcGFyYW0gbXNnIFRoZSBtZXNzYWdlIHRvIHZlcmlmeSB0aGUgc2lnbmF0dXJlIHdpdGhcbiAgICogQHBhcmFtIHNpZ25hdHVyZSB0aGUgc2lnbmF0dXJlIHRvIHZlcmlmeVxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZCwgZWxzZSBmYWxzZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyB2ZXJpZnlTaWduYXR1cmUocHViOiBzdHJpbmcsIG1zZzogQnVmZmVyLCBzaWduYXR1cmU6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGFzc2VydChpc1ZhbGlkQkxTUHVibGljS2V5KHB1YiksIGBJbnZhbGlkIHB1YmxpYyBrZXk6ICR7cHVifWApO1xuICAgIHJldHVybiBhd2FpdCBCTFMudmVyaWZ5KEJpZ0ludChzaWduYXR1cmUpLCBtc2csIEJpZ0ludCgnMHgnICsgcHViKSk7XG4gIH1cbn1cbiJdfQ==