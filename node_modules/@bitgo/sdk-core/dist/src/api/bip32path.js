"use strict";
/**
 * @prettier
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.sanitizeLegacyPath = void 0;
/**
 * BitGoJS includes some custom hand-rolled bip32 derivation logic in `bitcoin.ts`, which sadly
 * has numerous bugs.
 *
 * One of the effects is that the methods accept invalid bip32 paths:
 * - the `m` prefix is ignored ('m/0' === '0')
 * - path components that cannot be parsed as base-10 numbers are mapped to `0` ('0/x' === '0/0')
 * - path components with trailing characters after numerals are accepted, trailing characters
 *   are ignored ('1x' === '1')
 *
 * This probably does not cover everything but it should cover most bugs encountered in our code.
 *
 * This method attempts to convert a "legacy path", which may be invalid, to a standard bip32 path:
 * meaning the result should be equivalent to the input path when passed to either our custom
 * derivation log or when passed to a standard bip32 library.
 *
 * @param path - legacy path
 * @return string - somewhat sanitized path that can be passed to standard bip32 libraries
 */
function sanitizeLegacyPath(path) {
    const parts = path
        .split('/')
        .filter((p) => p !== '')
        .filter((p, i) => i !== 0 || p !== 'm')
        .map((p) => {
        const hardened = p.slice(-1) === "'";
        const v = parseInt(p.slice(0, hardened ? -1 : undefined), 10);
        if (Number.isNaN(v)) {
            return '0';
        }
        return String(v) + (hardened ? "'" : '');
    });
    if (parts.length === 0) {
        throw new Error(`empty path`);
    }
    return parts.join('/');
}
exports.sanitizeLegacyPath = sanitizeLegacyPath;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmlwMzJwYXRoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2FwaS9iaXAzMnBhdGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOztHQUVHOzs7QUFFSDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JHO0FBQ0gsU0FBZ0Isa0JBQWtCLENBQUMsSUFBWTtJQUM3QyxNQUFNLEtBQUssR0FBYSxJQUFJO1NBQ3pCLEtBQUssQ0FBQyxHQUFHLENBQUM7U0FDVixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDdkIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDO1NBQ3RDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1FBQ1QsTUFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQztRQUNyQyxNQUFNLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDOUQsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ25CLE9BQU8sR0FBRyxDQUFDO1NBQ1o7UUFDRCxPQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUMzQyxDQUFDLENBQUMsQ0FBQztJQUVMLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztLQUMvQjtJQUNELE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN6QixDQUFDO0FBbEJELGdEQWtCQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cblxuLyoqXG4gKiBCaXRHb0pTIGluY2x1ZGVzIHNvbWUgY3VzdG9tIGhhbmQtcm9sbGVkIGJpcDMyIGRlcml2YXRpb24gbG9naWMgaW4gYGJpdGNvaW4udHNgLCB3aGljaCBzYWRseVxuICogaGFzIG51bWVyb3VzIGJ1Z3MuXG4gKlxuICogT25lIG9mIHRoZSBlZmZlY3RzIGlzIHRoYXQgdGhlIG1ldGhvZHMgYWNjZXB0IGludmFsaWQgYmlwMzIgcGF0aHM6XG4gKiAtIHRoZSBgbWAgcHJlZml4IGlzIGlnbm9yZWQgKCdtLzAnID09PSAnMCcpXG4gKiAtIHBhdGggY29tcG9uZW50cyB0aGF0IGNhbm5vdCBiZSBwYXJzZWQgYXMgYmFzZS0xMCBudW1iZXJzIGFyZSBtYXBwZWQgdG8gYDBgICgnMC94JyA9PT0gJzAvMCcpXG4gKiAtIHBhdGggY29tcG9uZW50cyB3aXRoIHRyYWlsaW5nIGNoYXJhY3RlcnMgYWZ0ZXIgbnVtZXJhbHMgYXJlIGFjY2VwdGVkLCB0cmFpbGluZyBjaGFyYWN0ZXJzXG4gKiAgIGFyZSBpZ25vcmVkICgnMXgnID09PSAnMScpXG4gKlxuICogVGhpcyBwcm9iYWJseSBkb2VzIG5vdCBjb3ZlciBldmVyeXRoaW5nIGJ1dCBpdCBzaG91bGQgY292ZXIgbW9zdCBidWdzIGVuY291bnRlcmVkIGluIG91ciBjb2RlLlxuICpcbiAqIFRoaXMgbWV0aG9kIGF0dGVtcHRzIHRvIGNvbnZlcnQgYSBcImxlZ2FjeSBwYXRoXCIsIHdoaWNoIG1heSBiZSBpbnZhbGlkLCB0byBhIHN0YW5kYXJkIGJpcDMyIHBhdGg6XG4gKiBtZWFuaW5nIHRoZSByZXN1bHQgc2hvdWxkIGJlIGVxdWl2YWxlbnQgdG8gdGhlIGlucHV0IHBhdGggd2hlbiBwYXNzZWQgdG8gZWl0aGVyIG91ciBjdXN0b21cbiAqIGRlcml2YXRpb24gbG9nIG9yIHdoZW4gcGFzc2VkIHRvIGEgc3RhbmRhcmQgYmlwMzIgbGlicmFyeS5cbiAqXG4gKiBAcGFyYW0gcGF0aCAtIGxlZ2FjeSBwYXRoXG4gKiBAcmV0dXJuIHN0cmluZyAtIHNvbWV3aGF0IHNhbml0aXplZCBwYXRoIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBzdGFuZGFyZCBiaXAzMiBsaWJyYXJpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplTGVnYWN5UGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBwYXJ0czogc3RyaW5nW10gPSBwYXRoXG4gICAgLnNwbGl0KCcvJylcbiAgICAuZmlsdGVyKChwKSA9PiBwICE9PSAnJylcbiAgICAuZmlsdGVyKChwLCBpKSA9PiBpICE9PSAwIHx8IHAgIT09ICdtJylcbiAgICAubWFwKChwKSA9PiB7XG4gICAgICBjb25zdCBoYXJkZW5lZCA9IHAuc2xpY2UoLTEpID09PSBcIidcIjtcbiAgICAgIGNvbnN0IHYgPSBwYXJzZUludChwLnNsaWNlKDAsIGhhcmRlbmVkID8gLTEgOiB1bmRlZmluZWQpLCAxMCk7XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKHYpKSB7XG4gICAgICAgIHJldHVybiAnMCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nKHYpICsgKGhhcmRlbmVkID8gXCInXCIgOiAnJyk7XG4gICAgfSk7XG5cbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgZW1wdHkgcGF0aGApO1xuICB9XG4gIHJldHVybiBwYXJ0cy5qb2luKCcvJyk7XG59XG4iXX0=