"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseCoin = void 0;
/**
 * @prettier
 */
const crypto = __importStar(require("crypto"));
const utxo_lib_1 = require("@bitgo/utxo-lib");
const bignumber_js_1 = require("bignumber.js");
const utxolib = __importStar(require("@bitgo/utxo-lib"));
const bip32util_1 = require("../bip32util");
const account_lib_1 = require("../../account-lib");
const enterprise_1 = require("../enterprise");
const keychain_1 = require("../keychain");
const market_1 = require("../market");
const pendingApproval_1 = require("../pendingApproval");
const wallet_1 = require("../wallet");
const webhook_1 = require("../webhook");
class BaseCoin {
    constructor(bitgo) {
        this.bitgo = bitgo;
        this._url = this.bitgo.url('/', 2);
        this._wallets = new wallet_1.Wallets(this.bitgo, this);
        this._keychains = new keychain_1.Keychains(this.bitgo, this);
        this._webhooks = new webhook_1.Webhooks(this.bitgo, this);
        this._pendingApprovals = new pendingApproval_1.PendingApprovals(this.bitgo, this);
        this._enterprises = new enterprise_1.Enterprises(this.bitgo, this);
        this._markets = new market_1.Markets(this.bitgo, this);
    }
    url(suffix) {
        return this._url + this.getChain() + suffix;
    }
    wallets() {
        return this._wallets;
    }
    enterprises() {
        return this._enterprises;
    }
    keychains() {
        return this._keychains;
    }
    webhooks() {
        return this._webhooks;
    }
    pendingApprovals() {
        return this._pendingApprovals;
    }
    markets() {
        return this._markets;
    }
    static get coinTokenPatternSeparator() {
        return this._coinTokenPatternSeparator;
    }
    get type() {
        return this.getChain();
    }
    /**
     * Gets the statics coin object
     * @returns {Readonly<StaticsBaseCoin>} the statics coin object
     */
    getConfig() {
        return this._staticsCoin;
    }
    /**
     * Flag for sending value of 0.
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return false;
    }
    /**
     * Use `sendMany()` to perform wallet sweep.
     * FIXME(BG-39738): add coin.sweepWallet() instead
     */
    sweepWithSendMany() {
        return false;
    }
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    transactionDataAllowed() {
        return false;
    }
    /**
     * Flag for determining whether this coin supports account consolidations
     * from its receive addresses to the root address.
     * @returns {boolean} True if okay to consolidate over this coin; false, otherwise
     */
    allowsAccountConsolidations() {
        return false;
    }
    /**
     * Gets config for how token enablements work for this coin
     * @returns
     *    requiresTokenEnablement: True if tokens need to be enabled for this coin
     *    supportsMultipleTokenEnablements: True if multiple tokens can be enabled in one transaction
     */
    getTokenEnablementConfig() {
        return {
            requiresTokenEnablement: false,
            supportsMultipleTokenEnablements: false,
        };
    }
    /**
     * Flag indicating if this coin supports TSS wallets.
     * @returns {boolean} True if TSS Wallets can be created for this coin
     */
    supportsTss() {
        return false;
    }
    /**
     * Flag indicating if the coin supports deriving a key with a seed (keyID)
     * to the user/backup keys.
     */
    supportsDeriveKeyWithSeed() {
        return true;
    }
    /**
     * Flag indicating if this blockchain runs on EVM architecture.
     * @returns {boolean} True if the blockchain runs on EVM architecture.
     */
    isEVM() {
        return false;
    }
    /**
     * Flag indicating if this coin supports BLS-DKG wallets.
     * @returns {boolean} True if BLS-DKG Wallets can be created for this coin
     */
    supportsBlsDkg() {
        return false;
    }
    /**
     * Convert a currency amount represented in base units (satoshi, wei, atoms, drops, stroops)
     * to big units (btc, eth, xrp, xlm)
     */
    baseUnitsToBigUnits(baseUnits) {
        bignumber_js_1.BigNumber.set({ DECIMAL_PLACES: 24 });
        const dividend = this.getBaseFactor();
        const bigNumber = new bignumber_js_1.BigNumber(baseUnits).dividedBy(dividend);
        // set the format so commas aren't added to large coin amounts
        return bigNumber.toFormat(null, null, { groupSeparator: '', decimalSeparator: '.' });
    }
    /**
     * Convert a currency amount represented in big units (btc, eth, xrp, xlm)
     * to base units (satoshi, wei, atoms, drops, stroops)
     * @param bigUnits
     */
    bigUnitsToBaseUnits(bigUnits) {
        const multiplier = this.getBaseFactor();
        const bigNumber = new bignumber_js_1.BigNumber(bigUnits).times(multiplier);
        if (!bigNumber.isInteger()) {
            throw new Error(`non-integer output resulted from multiplying ${bigUnits} by ${multiplier}`);
        }
        return bigNumber.toFixed(0);
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        return (0, bip32util_1.signMessage)(message, utxo_lib_1.bip32.fromBase58(key.prv), utxolib.networks.bitcoin);
    }
    /**
     * Create signatures for the backup and bitgo keys using the user key.
     * We can verify the signatures when fetching the keys from wallet-platform later.
     * Currently only `AbstractUtxoCoin` implements and uses the complementary `verifyKeySignature` method.
     * @param prv - the user private key
     * @param backupKeychain - contains the backup public key
     * @param bitgoKeychain - contains the bitgo public key
     */
    async createKeySignatures(prv, backupKeychain, bitgoKeychain) {
        return {
            backup: (await this.signMessage({ prv }, backupKeychain.pub)).toString('hex'),
            bitgo: (await this.signMessage({ prv }, bitgoKeychain.pub)).toString('hex'),
        };
    }
    /**
     * Decompose a raw transaction into useful information.
     * @param options - coin-specific
     */
    explainTransaction(options) {
        throw new Error(`not implemented`);
    }
    /**
     * @deprecated use {@see isWalletAddress} instead
     */
    verifyAddress(params) {
        return this.isWalletAddress(params);
    }
    /**
     * convert address into desired address format.
     * @param address
     * @param format
     */
    canonicalAddress(address, format) {
        return address;
    }
    /**
     * Check whether a coin supports blockTarget for transactions to be included in
     * @returns {boolean}
     */
    supportsBlockTarget() {
        return false;
    }
    /**
     * Check whether a coin supports lightning transactions
     * @returns {boolean}
     */
    supportsLightning() {
        return false;
    }
    /**
     * Check whether a coin supports message signing
     * @returns {boolean}
     */
    supportsMessageSigning() {
        return false;
    }
    /**
     * Check whether a coin supports signing of Typed data
     * @returns {boolean}
     */
    supportsSigningTypedData() {
        return false;
    }
    /**
     * Hook to add additional parameters to the wallet generation
     * @param walletParams
     * @param keychains
     * @return {*}
     */
    supplementGenerateWallet(walletParams, keychains) {
        return Promise.resolve(walletParams);
    }
    /**
     * Get extra parameters for prebuilding a tx. Add things like hop transaction params
     */
    getExtraPrebuildParams(buildParams) {
        return Promise.resolve({});
    }
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    postProcessPrebuild(prebuildResponse) {
        return Promise.resolve(prebuildResponse);
    }
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     */
    presignTransaction(params) {
        return Promise.resolve(params);
    }
    /**
     * Create a new wallet object from a wallet data object
     * @param walletParams
     */
    newWalletObject(walletParams) {
        return new wallet_1.Wallet(this.bitgo, this, walletParams);
    }
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Integer} params.numBlocks The number of blocks to target for conformation (Only works for btc)
     * @returns {Object} The info returned from the merchant server
     */
    async feeEstimate(params) {
        const query = {};
        if (params && params.numBlocks) {
            query.numBlocks = params.numBlocks;
        }
        return this.bitgo.get(this.url('/tx/fee')).query(query).result();
    }
    /**
     * The cold wallet tool uses this function to derive an extended key that is based on the passed key and seed
     * @param key
     * @param seed
     * @returns {{key: string, derivationPath: string}}
     */
    deriveKeyWithSeed({ key, seed }) {
        function sha256(input) {
            return crypto.createHash('sha256').update(input).digest();
        }
        const derivationPathInput = sha256(sha256(`${seed}`)).toString('hex');
        const derivationPathParts = [
            parseInt(derivationPathInput.slice(0, 7), 16),
            parseInt(derivationPathInput.slice(7, 14), 16),
        ];
        const derivationPath = 'm/999999/' + derivationPathParts.join('/');
        const keyNode = utxo_lib_1.bip32.fromBase58(key);
        const derivedKeyNode = keyNode.derivePath(derivationPath);
        return {
            key: derivedKeyNode.toBase58(),
            derivationPath: derivationPath,
        };
    }
    /**
     * Specifies what key we will need for signing - right now we just need the
     * user key.
     */
    keyIdsForSigning() {
        return [keychain_1.KeyIndices.USER];
    }
    /**
     * Perform additional checks before adding a bitgo key. Base controller
     * is a no-op, but coin-specific controller may do something
     * @param params
     */
    preCreateBitGo(params) {
        return;
    }
    /**
     * @deprecated - use getBip32Keys() in conjunction with isValidAddress instead
     */
    initiateRecovery(params) {
        throw new Error('deprecated method');
    }
    /**
     * Generate a root key pair on the curve used by the coin
     * @param {Buffer} seed - seed to use for key pair generation
     * @returns {KeyPair} the generated key pair
     */
    generateRootKeyPair(seed) {
        throw new account_lib_1.NotImplementedError('generateRootKeyPair is not supported for this coin');
    }
    /**
     * Return wether the given m of n wallet signers/ key amounts are valid for the coin
     */
    isValidMofNSetup({ m, n }) {
        return m === 2 && n === 3;
    }
    /**
     * Returns the portion of the transaction that needs to be signed in Buffer format.
     * Only needed for coins that support adding signatures directly (e.g. TSS).
     *
     * @param {String} serializedTx - the unsigned transaction in broadcast format
     * @returns {Promise<Buffer>} - the portion of the transaction that needs to be signed
     */
    async getSignablePayload(serializedTx) {
        return Buffer.from(serializedTx);
    }
    /**
     * Returns the MPC algorithm (ecdsa or eddsa) used for coins that support TSS
     */
    getMPCAlgorithm() {
        throw new Error('no MPC algorithm is defined for this coin');
    }
    async recoverToken(params) {
        throw new account_lib_1.NotImplementedError('recoverToken is not supported for this coin');
    }
    getInscriptionBuilder(wallet) {
        throw new account_lib_1.NotImplementedError('Inscription Builder is not supported for this coin');
    }
    /**
     * Function to get coin specific hash function used to generate transaction digests.
     * @returns {@see Hash} hash function if implemented, otherwise throws exception
     */
    getHashFunction() {
        throw new account_lib_1.NotImplementedError('getHashFunction is not supported for this coin');
    }
    buildNftTransferData(params) {
        throw new account_lib_1.NotImplementedError('buildNftTransferData is not supported for this coin');
    }
    /**
     * Broadcast a transaction to the network
     * @param params options for broadcasting
     * @returns {Promise<BaseBroadcastTransactionResult>} result of broadcast
     * @throws {NotImplementedError} if not implemented
     */
    broadcastTransaction(params) {
        throw new account_lib_1.NotImplementedError('broadcastTransaction is not supported for this coin');
    }
}
exports.BaseCoin = BaseCoin;
BaseCoin._coinTokenPatternSeparator = ':';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZUNvaW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYml0Z28vYmFzZUNvaW4vYmFzZUNvaW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILCtDQUFpQztBQUNqQyw4Q0FBd0M7QUFDeEMsK0NBQXlDO0FBRXpDLHlEQUEyQztBQUkzQyw0Q0FBMkM7QUFDM0MsbURBQXdEO0FBRXhELDhDQUE0QztBQUM1QywwQ0FBb0Q7QUFDcEQsc0NBQW9DO0FBQ3BDLHdEQUFzRDtBQUN0RCxzQ0FBcUQ7QUFDckQsd0NBQXNDO0FBNkJ0QyxNQUFzQixRQUFRO0lBWTVCLFlBQXNCLEtBQWdCO1FBQ3BDLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ25DLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxnQkFBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLG9CQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksa0JBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ2hELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLGtDQUFnQixDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDaEUsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLHdCQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztRQUN0RCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksZ0JBQU8s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MWVILDRCQTJlQztBQWxlMkIsbUNBQTBCLEdBQUcsR0FBRyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBiaXAzMiB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuXG5pbXBvcnQgKiBhcyB1dHhvbGliIGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgeyBCYXNlQ29pbiBhcyBTdGF0aWNzQmFzZUNvaW4gfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5cbmltcG9ydCB7IEluaXRpYXRlUmVjb3ZlcnlPcHRpb25zIH0gZnJvbSAnLi4vcmVjb3ZlcnknO1xuaW1wb3J0IHsgc2lnbk1lc3NhZ2UgfSBmcm9tICcuLi9iaXAzMnV0aWwnO1xuaW1wb3J0IHsgTm90SW1wbGVtZW50ZWRFcnJvciB9IGZyb20gJy4uLy4uL2FjY291bnQtbGliJztcbmltcG9ydCB7IEJpdEdvQmFzZSB9IGZyb20gJy4uL2JpdGdvQmFzZSc7XG5pbXBvcnQgeyBFbnRlcnByaXNlcyB9IGZyb20gJy4uL2VudGVycHJpc2UnO1xuaW1wb3J0IHsgS2V5Y2hhaW5zLCBLZXlJbmRpY2VzIH0gZnJvbSAnLi4va2V5Y2hhaW4nO1xuaW1wb3J0IHsgTWFya2V0cyB9IGZyb20gJy4uL21hcmtldCc7XG5pbXBvcnQgeyBQZW5kaW5nQXBwcm92YWxzIH0gZnJvbSAnLi4vcGVuZGluZ0FwcHJvdmFsJztcbmltcG9ydCB7IFdhbGxldHMsIElXYWxsZXQsIFdhbGxldCB9IGZyb20gJy4uL3dhbGxldCc7XG5pbXBvcnQgeyBXZWJob29rcyB9IGZyb20gJy4uL3dlYmhvb2snO1xuaW1wb3J0IHtcbiAgRXh0cmFQcmVidWlsZFBhcmFtc09wdGlvbnMsXG4gIEZlZUVzdGltYXRlT3B0aW9ucyxcbiAgSUJhc2VDb2luLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgSVRyYW5zYWN0aW9uRXhwbGFuYXRpb24sXG4gIEtleWNoYWluc1RyaXBsZXQsXG4gIEtleVBhaXIsXG4gIE1QQ0FsZ29yaXRobSxcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFByZWNyZWF0ZUJpdEdvT3B0aW9ucyxcbiAgUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgUmVjb3ZlclRva2VuVHJhbnNhY3Rpb24sXG4gIFJlY292ZXJXYWxsZXRUb2tlbk9wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zLFxuICBUb2tlbkVuYWJsZW1lbnRDb25maWcsXG4gIFRyYW5zYWN0aW9uUHJlYnVpbGQsXG4gIFZlcmlmeUFkZHJlc3NPcHRpb25zLFxuICBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIEJ1aWxkTmZ0VHJhbnNmZXJEYXRhT3B0aW9ucyxcbiAgQmFzZUJyb2FkY2FzdFRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgQmFzZUJyb2FkY2FzdFRyYW5zYWN0aW9uUmVzdWx0LFxufSBmcm9tICcuL2lCYXNlQ29pbic7XG5pbXBvcnQgeyBJSW5zY3JpcHRpb25CdWlsZGVyIH0gZnJvbSAnLi4vaW5zY3JpcHRpb25CdWlsZGVyJztcbmltcG9ydCB7IEhhc2ggfSBmcm9tICdjcnlwdG8nO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUNvaW4gaW1wbGVtZW50cyBJQmFzZUNvaW4ge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgYml0Z286IEJpdEdvQmFzZTtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF91cmw6IHN0cmluZztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9lbnRlcnByaXNlczogRW50ZXJwcmlzZXM7XG4gIHByb3RlY3RlZCByZWFkb25seSBfd2FsbGV0czogV2FsbGV0cztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9rZXljaGFpbnM6IEtleWNoYWlucztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF93ZWJob29rczogV2ViaG9va3M7XG4gIHByb3RlY3RlZCByZWFkb25seSBfcGVuZGluZ0FwcHJvdmFsczogUGVuZGluZ0FwcHJvdmFscztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9tYXJrZXRzOiBNYXJrZXRzO1xuICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IF9jb2luVG9rZW5QYXR0ZXJuU2VwYXJhdG9yID0gJzonO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3N0YXRpY3NDb2luOiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+O1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlKSB7XG4gICAgdGhpcy5iaXRnbyA9IGJpdGdvO1xuICAgIHRoaXMuX3VybCA9IHRoaXMuYml0Z28udXJsKCcvJywgMik7XG4gICAgdGhpcy5fd2FsbGV0cyA9IG5ldyBXYWxsZXRzKHRoaXMuYml0Z28sIHRoaXMpO1xuICAgIHRoaXMuX2tleWNoYWlucyA9IG5ldyBLZXljaGFpbnModGhpcy5iaXRnbywgdGhpcyk7XG4gICAgdGhpcy5fd2ViaG9va3MgPSBuZXcgV2ViaG9va3ModGhpcy5iaXRnbywgdGhpcyk7XG4gICAgdGhpcy5fcGVuZGluZ0FwcHJvdmFscyA9IG5ldyBQZW5kaW5nQXBwcm92YWxzKHRoaXMuYml0Z28sIHRoaXMpO1xuICAgIHRoaXMuX2VudGVycHJpc2VzID0gbmV3IEVudGVycHJpc2VzKHRoaXMuYml0Z28sIHRoaXMpO1xuICAgIHRoaXMuX21hcmtldHMgPSBuZXcgTWFya2V0cyh0aGlzLmJpdGdvLCB0aGlzKTtcbiAgfVxuXG4gIHB1YmxpYyB1cmwoc3VmZml4OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl91cmwgKyB0aGlzLmdldENoYWluKCkgKyBzdWZmaXg7XG4gIH1cblxuICBwdWJsaWMgd2FsbGV0cygpOiBXYWxsZXRzIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0cztcbiAgfVxuXG4gIHB1YmxpYyBlbnRlcnByaXNlcygpOiBFbnRlcnByaXNlcyB7XG4gICAgcmV0dXJuIHRoaXMuX2VudGVycHJpc2VzO1xuICB9XG5cbiAgcHVibGljIGtleWNoYWlucygpOiBLZXljaGFpbnMge1xuICAgIHJldHVybiB0aGlzLl9rZXljaGFpbnM7XG4gIH1cblxuICBwdWJsaWMgd2ViaG9va3MoKTogV2ViaG9va3Mge1xuICAgIHJldHVybiB0aGlzLl93ZWJob29rcztcbiAgfVxuXG4gIHB1YmxpYyBwZW5kaW5nQXBwcm92YWxzKCk6IFBlbmRpbmdBcHByb3ZhbHMge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWxzO1xuICB9XG5cbiAgcHVibGljIG1hcmtldHMoKTogTWFya2V0cyB7XG4gICAgcmV0dXJuIHRoaXMuX21hcmtldHM7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGdldCBjb2luVG9rZW5QYXR0ZXJuU2VwYXJhdG9yKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2NvaW5Ub2tlblBhdHRlcm5TZXBhcmF0b3I7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHR5cGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDaGFpbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0YXRpY3MgY29pbiBvYmplY3RcbiAgICogQHJldHVybnMge1JlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj59IHRoZSBzdGF0aWNzIGNvaW4gb2JqZWN0XG4gICAqL1xuICBnZXRDb25maWcoKTogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPiB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luO1xuICB9XG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGNoYWluIHdoaWNoIHN1cHBvcnRzIHRoaXMgY29pbiAoZWcsICdidGMnLCAnZXRoJylcbiAgICovXG4gIGFic3RyYWN0IGdldENoYWluKCk6IHN0cmluZztcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgY29pbiBmYW1pbHkgKGVnLiBmb3IgdGJ0YywgdGhpcyB3b3VsZCBiZSBidGMpXG4gICAqL1xuICBhYnN0cmFjdCBnZXRGYW1pbHkoKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBIdW1hbiByZWFkYWJsZSBmdWxsIG5hbWUgZm9yIHRoZSBjb2luXG4gICAqL1xuICBhYnN0cmFjdCBnZXRGdWxsTmFtZSgpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgdmFsdWUgb2YgMC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIDAgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgYHNlbmRNYW55KClgIHRvIHBlcmZvcm0gd2FsbGV0IHN3ZWVwLlxuICAgKiBGSVhNRShCRy0zOTczOCk6IGFkZCBjb2luLnN3ZWVwV2FsbGV0KCkgaW5zdGVhZFxuICAgKi9cbiAgc3dlZXBXaXRoU2VuZE1hbnkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgZGF0YSBhbG9uZyB3aXRoIHRyYW5zYWN0aW9uc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgdHggZGF0YSAoRVRIKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB0cmFuc2FjdGlvbkRhdGFBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoaXMgY29pbiBzdXBwb3J0cyBhY2NvdW50IGNvbnNvbGlkYXRpb25zXG4gICAqIGZyb20gaXRzIHJlY2VpdmUgYWRkcmVzc2VzIHRvIHRoZSByb290IGFkZHJlc3MuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gY29uc29saWRhdGUgb3ZlciB0aGlzIGNvaW47IGZhbHNlLCBvdGhlcndpc2VcbiAgICovXG4gIGFsbG93c0FjY291bnRDb25zb2xpZGF0aW9ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjb25maWcgZm9yIGhvdyB0b2tlbiBlbmFibGVtZW50cyB3b3JrIGZvciB0aGlzIGNvaW5cbiAgICogQHJldHVybnNcbiAgICogICAgcmVxdWlyZXNUb2tlbkVuYWJsZW1lbnQ6IFRydWUgaWYgdG9rZW5zIG5lZWQgdG8gYmUgZW5hYmxlZCBmb3IgdGhpcyBjb2luXG4gICAqICAgIHN1cHBvcnRzTXVsdGlwbGVUb2tlbkVuYWJsZW1lbnRzOiBUcnVlIGlmIG11bHRpcGxlIHRva2VucyBjYW4gYmUgZW5hYmxlZCBpbiBvbmUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGdldFRva2VuRW5hYmxlbWVudENvbmZpZygpOiBUb2tlbkVuYWJsZW1lbnRDb25maWcge1xuICAgIHJldHVybiB7XG4gICAgICByZXF1aXJlc1Rva2VuRW5hYmxlbWVudDogZmFsc2UsXG4gICAgICBzdXBwb3J0c011bHRpcGxlVG9rZW5FbmFibGVtZW50czogZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBjb2luIHN1cHBvcnRzIFRTUyB3YWxsZXRzLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBUU1MgV2FsbGV0cyBjYW4gYmUgY3JlYXRlZCBmb3IgdGhpcyBjb2luXG4gICAqL1xuICBzdXBwb3J0c1RzcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBjb2luIHN1cHBvcnRzIGRlcml2aW5nIGEga2V5IHdpdGggYSBzZWVkIChrZXlJRClcbiAgICogdG8gdGhlIHVzZXIvYmFja3VwIGtleXMuXG4gICAqL1xuICBzdXBwb3J0c0Rlcml2ZUtleVdpdGhTZWVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIGJsb2NrY2hhaW4gcnVucyBvbiBFVk0gYXJjaGl0ZWN0dXJlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYmxvY2tjaGFpbiBydW5zIG9uIEVWTSBhcmNoaXRlY3R1cmUuXG4gICAqL1xuICBpc0VWTSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgY29pbiBzdXBwb3J0cyBCTFMtREtHIHdhbGxldHMuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIEJMUy1ES0cgV2FsbGV0cyBjYW4gYmUgY3JlYXRlZCBmb3IgdGhpcyBjb2luXG4gICAqL1xuICBzdXBwb3J0c0Jsc0RrZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmFjdG9yIGJldHdlZW4gdGhlIGJhc2UgdW5pdCBhbmQgaXRzIHNtYWxsZXN0IHN1YmRpdmlzb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgYWJzdHJhY3QgZ2V0QmFzZUZhY3RvcigpOiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBjdXJyZW5jeSBhbW91bnQgcmVwcmVzZW50ZWQgaW4gYmFzZSB1bml0cyAoc2F0b3NoaSwgd2VpLCBhdG9tcywgZHJvcHMsIHN0cm9vcHMpXG4gICAqIHRvIGJpZyB1bml0cyAoYnRjLCBldGgsIHhycCwgeGxtKVxuICAgKi9cbiAgYmFzZVVuaXRzVG9CaWdVbml0cyhiYXNlVW5pdHM6IHN0cmluZyB8IG51bWJlcik6IHN0cmluZyB7XG4gICAgQmlnTnVtYmVyLnNldCh7IERFQ0lNQUxfUExBQ0VTOiAyNCB9KTtcbiAgICBjb25zdCBkaXZpZGVuZCA9IHRoaXMuZ2V0QmFzZUZhY3RvcigpO1xuICAgIGNvbnN0IGJpZ051bWJlciA9IG5ldyBCaWdOdW1iZXIoYmFzZVVuaXRzKS5kaXZpZGVkQnkoZGl2aWRlbmQpO1xuICAgIC8vIHNldCB0aGUgZm9ybWF0IHNvIGNvbW1hcyBhcmVuJ3QgYWRkZWQgdG8gbGFyZ2UgY29pbiBhbW91bnRzXG4gICAgcmV0dXJuIGJpZ051bWJlci50b0Zvcm1hdChudWxsIGFzIGFueSwgbnVsbCBhcyBhbnksIHsgZ3JvdXBTZXBhcmF0b3I6ICcnLCBkZWNpbWFsU2VwYXJhdG9yOiAnLicgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIGN1cnJlbmN5IGFtb3VudCByZXByZXNlbnRlZCBpbiBiaWcgdW5pdHMgKGJ0YywgZXRoLCB4cnAsIHhsbSlcbiAgICogdG8gYmFzZSB1bml0cyAoc2F0b3NoaSwgd2VpLCBhdG9tcywgZHJvcHMsIHN0cm9vcHMpXG4gICAqIEBwYXJhbSBiaWdVbml0c1xuICAgKi9cbiAgYmlnVW5pdHNUb0Jhc2VVbml0cyhiaWdVbml0czogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgICBjb25zdCBtdWx0aXBsaWVyID0gdGhpcy5nZXRCYXNlRmFjdG9yKCk7XG4gICAgY29uc3QgYmlnTnVtYmVyID0gbmV3IEJpZ051bWJlcihiaWdVbml0cykudGltZXMobXVsdGlwbGllcik7XG4gICAgaWYgKCFiaWdOdW1iZXIuaXNJbnRlZ2VyKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbm9uLWludGVnZXIgb3V0cHV0IHJlc3VsdGVkIGZyb20gbXVsdGlwbHlpbmcgJHtiaWdVbml0c30gYnkgJHttdWx0aXBsaWVyfWApO1xuICAgIH1cbiAgICByZXR1cm4gYmlnTnVtYmVyLnRvRml4ZWQoMCk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBtZXNzYWdlIHdpdGggcHJpdmF0ZSBrZXlcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKi9cbiAgYXN5bmMgc2lnbk1lc3NhZ2Uoa2V5OiB7IHBydjogc3RyaW5nIH0sIG1lc3NhZ2U6IHN0cmluZyk6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgcmV0dXJuIHNpZ25NZXNzYWdlKG1lc3NhZ2UsIGJpcDMyLmZyb21CYXNlNTgoa2V5LnBydiksIHV0eG9saWIubmV0d29ya3MuYml0Y29pbik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHNpZ25hdHVyZXMgZm9yIHRoZSBiYWNrdXAgYW5kIGJpdGdvIGtleXMgdXNpbmcgdGhlIHVzZXIga2V5LlxuICAgKiBXZSBjYW4gdmVyaWZ5IHRoZSBzaWduYXR1cmVzIHdoZW4gZmV0Y2hpbmcgdGhlIGtleXMgZnJvbSB3YWxsZXQtcGxhdGZvcm0gbGF0ZXIuXG4gICAqIEN1cnJlbnRseSBvbmx5IGBBYnN0cmFjdFV0eG9Db2luYCBpbXBsZW1lbnRzIGFuZCB1c2VzIHRoZSBjb21wbGVtZW50YXJ5IGB2ZXJpZnlLZXlTaWduYXR1cmVgIG1ldGhvZC5cbiAgICogQHBhcmFtIHBydiAtIHRoZSB1c2VyIHByaXZhdGUga2V5XG4gICAqIEBwYXJhbSBiYWNrdXBLZXljaGFpbiAtIGNvbnRhaW5zIHRoZSBiYWNrdXAgcHVibGljIGtleVxuICAgKiBAcGFyYW0gYml0Z29LZXljaGFpbiAtIGNvbnRhaW5zIHRoZSBiaXRnbyBwdWJsaWMga2V5XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY3JlYXRlS2V5U2lnbmF0dXJlcyhcbiAgICBwcnY6IHN0cmluZyxcbiAgICBiYWNrdXBLZXljaGFpbjogeyBwdWI6IHN0cmluZyB9LFxuICAgIGJpdGdvS2V5Y2hhaW46IHsgcHViOiBzdHJpbmcgfVxuICApOiBQcm9taXNlPHtcbiAgICBiYWNrdXA6IHN0cmluZztcbiAgICBiaXRnbzogc3RyaW5nO1xuICB9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhY2t1cDogKGF3YWl0IHRoaXMuc2lnbk1lc3NhZ2UoeyBwcnYgfSwgYmFja3VwS2V5Y2hhaW4ucHViKSkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgYml0Z286IChhd2FpdCB0aGlzLnNpZ25NZXNzYWdlKHsgcHJ2IH0sIGJpdGdvS2V5Y2hhaW4ucHViKSkudG9TdHJpbmcoJ2hleCcpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wb3NlIGEgcmF3IHRyYW5zYWN0aW9uIGludG8gdXNlZnVsIGluZm9ybWF0aW9uLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGNvaW4tc3BlY2lmaWNcbiAgICovXG4gIGV4cGxhaW5UcmFuc2FjdGlvbihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUHJvbWlzZTxJVHJhbnNhY3Rpb25FeHBsYW5hdGlvbjxhbnksIHN0cmluZyB8IG51bWJlcj4gfCB1bmRlZmluZWQ+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBpbXBsZW1lbnRlZGApO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGF0IGEgdHJhbnNhY3Rpb24gcHJlYnVpbGQgY29tcGxpZXMgd2l0aCB0aGUgb3JpZ2luYWwgaW50ZW50aW9uXG4gICAqL1xuICBhYnN0cmFjdCB2ZXJpZnlUcmFuc2FjdGlvbihwYXJhbXM6IFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj47XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSB7QHNlZSBpc1dhbGxldEFkZHJlc3N9IGluc3RlYWRcbiAgICovXG4gIHZlcmlmeUFkZHJlc3MocGFyYW1zOiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLmlzV2FsbGV0QWRkcmVzcyhwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybiB0cnVlIGlmZiBhZGRyZXNzIGlzIGEgd2FsbGV0IGFkZHJlc3MuIE11c3QgcmV0dXJuIGZhbHNlIGlmIGFkZHJlc3MgaXMgb3V0c2lkZSB3YWxsZXQuXG4gICAqL1xuICBhYnN0cmFjdCBpc1dhbGxldEFkZHJlc3MocGFyYW1zOiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj47XG5cbiAgLyoqXG4gICAqIGNvbnZlcnQgYWRkcmVzcyBpbnRvIGRlc2lyZWQgYWRkcmVzcyBmb3JtYXQuXG4gICAqIEBwYXJhbSBhZGRyZXNzXG4gICAqIEBwYXJhbSBmb3JtYXRcbiAgICovXG4gIGNhbm9uaWNhbEFkZHJlc3MoYWRkcmVzczogc3RyaW5nLCBmb3JtYXQ/OiB1bmtub3duKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYWRkcmVzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGEgY29pbiBzdXBwb3J0cyBibG9ja1RhcmdldCBmb3IgdHJhbnNhY3Rpb25zIHRvIGJlIGluY2x1ZGVkIGluXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3VwcG9ydHNCbG9ja1RhcmdldCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBhIGNvaW4gc3VwcG9ydHMgbGlnaHRuaW5nIHRyYW5zYWN0aW9uc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN1cHBvcnRzTGlnaHRuaW5nKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGEgY29pbiBzdXBwb3J0cyBtZXNzYWdlIHNpZ25pbmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdXBwb3J0c01lc3NhZ2VTaWduaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGEgY29pbiBzdXBwb3J0cyBzaWduaW5nIG9mIFR5cGVkIGRhdGFcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdXBwb3J0c1NpZ25pbmdUeXBlZERhdGEoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhvb2sgdG8gYWRkIGFkZGl0aW9uYWwgcGFyYW1ldGVycyB0byB0aGUgd2FsbGV0IGdlbmVyYXRpb25cbiAgICogQHBhcmFtIHdhbGxldFBhcmFtc1xuICAgKiBAcGFyYW0ga2V5Y2hhaW5zXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBzdXBwbGVtZW50R2VuZXJhdGVXYWxsZXQod2FsbGV0UGFyYW1zOiBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zLCBrZXljaGFpbnM6IEtleWNoYWluc1RyaXBsZXQpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUod2FsbGV0UGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZXh0cmEgcGFyYW1ldGVycyBmb3IgcHJlYnVpbGRpbmcgYSB0eC4gQWRkIHRoaW5ncyBsaWtlIGhvcCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAgICovXG4gIGdldEV4dHJhUHJlYnVpbGRQYXJhbXMoYnVpbGRQYXJhbXM6IEV4dHJhUHJlYnVpbGRQYXJhbXNPcHRpb25zKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmeSBwcmVidWlsZCBhZnRlciByZWNlaXZpbmcgaXQgZnJvbSB0aGUgc2VydmVyLiBBZGQgdGhpbmdzIGxpa2UgbmxvY2t0aW1lXG4gICAqL1xuICBwb3N0UHJvY2Vzc1ByZWJ1aWxkKHByZWJ1aWxkUmVzcG9uc2U6IFRyYW5zYWN0aW9uUHJlYnVpbGQpOiBQcm9taXNlPFRyYW5zYWN0aW9uUHJlYnVpbGQ+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByZWJ1aWxkUmVzcG9uc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvaW4tc3BlY2lmaWMgdGhpbmdzIGRvbmUgYmVmb3JlIHNpZ25pbmcgYSB0cmFuc2FjdGlvbiwgaS5lLiB2ZXJpZmljYXRpb25cbiAgICovXG4gIHByZXNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnM+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHdhbGxldCBvYmplY3QgZnJvbSBhIHdhbGxldCBkYXRhIG9iamVjdFxuICAgKiBAcGFyYW0gd2FsbGV0UGFyYW1zXG4gICAqL1xuICBuZXdXYWxsZXRPYmplY3Qod2FsbGV0UGFyYW1zOiBhbnkpOiBJV2FsbGV0IHtcbiAgICByZXR1cm4gbmV3IFdhbGxldCh0aGlzLmJpdGdvLCB0aGlzLCB3YWxsZXRQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGZlZSBlc3RpbWF0ZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBUaGUgcGFyYW1zIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IHBhcmFtcy5udW1CbG9ja3MgVGhlIG51bWJlciBvZiBibG9ja3MgdG8gdGFyZ2V0IGZvciBjb25mb3JtYXRpb24gKE9ubHkgd29ya3MgZm9yIGJ0YylcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGluZm8gcmV0dXJuZWQgZnJvbSB0aGUgbWVyY2hhbnQgc2VydmVyXG4gICAqL1xuICBhc3luYyBmZWVFc3RpbWF0ZShwYXJhbXM6IEZlZUVzdGltYXRlT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcXVlcnk6IGFueSA9IHt9O1xuICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLm51bUJsb2Nrcykge1xuICAgICAgcXVlcnkubnVtQmxvY2tzID0gcGFyYW1zLm51bUJsb2NrcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy51cmwoJy90eC9mZWUnKSkucXVlcnkocXVlcnkpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjb2xkIHdhbGxldCB0b29sIHVzZXMgdGhpcyBmdW5jdGlvbiB0byBkZXJpdmUgYW4gZXh0ZW5kZWQga2V5IHRoYXQgaXMgYmFzZWQgb24gdGhlIHBhc3NlZCBrZXkgYW5kIHNlZWRcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gc2VlZFxuICAgKiBAcmV0dXJucyB7e2tleTogc3RyaW5nLCBkZXJpdmF0aW9uUGF0aDogc3RyaW5nfX1cbiAgICovXG4gIGRlcml2ZUtleVdpdGhTZWVkKHsga2V5LCBzZWVkIH06IHsga2V5OiBzdHJpbmc7IHNlZWQ6IHN0cmluZyB9KTogeyBrZXk6IHN0cmluZzsgZGVyaXZhdGlvblBhdGg6IHN0cmluZyB9IHtcbiAgICBmdW5jdGlvbiBzaGEyNTYoaW5wdXQpIHtcbiAgICAgIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGlucHV0KS5kaWdlc3QoKTtcbiAgICB9XG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGhJbnB1dCA9IHNoYTI1NihzaGEyNTYoYCR7c2VlZH1gKSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoUGFydHMgPSBbXG4gICAgICBwYXJzZUludChkZXJpdmF0aW9uUGF0aElucHV0LnNsaWNlKDAsIDcpLCAxNiksXG4gICAgICBwYXJzZUludChkZXJpdmF0aW9uUGF0aElucHV0LnNsaWNlKDcsIDE0KSwgMTYpLFxuICAgIF07XG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGggPSAnbS85OTk5OTkvJyArIGRlcml2YXRpb25QYXRoUGFydHMuam9pbignLycpO1xuICAgIGNvbnN0IGtleU5vZGUgPSBiaXAzMi5mcm9tQmFzZTU4KGtleSk7XG4gICAgY29uc3QgZGVyaXZlZEtleU5vZGUgPSBrZXlOb2RlLmRlcml2ZVBhdGgoZGVyaXZhdGlvblBhdGgpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGRlcml2ZWRLZXlOb2RlLnRvQmFzZTU4KCksXG4gICAgICBkZXJpdmF0aW9uUGF0aDogZGVyaXZhdGlvblBhdGgsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgd2hhdCBrZXkgd2Ugd2lsbCBuZWVkIGZvciBzaWduaW5nIC0gcmlnaHQgbm93IHdlIGp1c3QgbmVlZCB0aGVcbiAgICogdXNlciBrZXkuXG4gICAqL1xuICBrZXlJZHNGb3JTaWduaW5nKCk6IG51bWJlcltdIHtcbiAgICByZXR1cm4gW0tleUluZGljZXMuVVNFUl07XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhZGRpdGlvbmFsIGNoZWNrcyBiZWZvcmUgYWRkaW5nIGEgYml0Z28ga2V5LiBCYXNlIGNvbnRyb2xsZXJcbiAgICogaXMgYSBuby1vcCwgYnV0IGNvaW4tc3BlY2lmaWMgY29udHJvbGxlciBtYXkgZG8gc29tZXRoaW5nXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIHByZUNyZWF0ZUJpdEdvKHBhcmFtczogUHJlY3JlYXRlQml0R29PcHRpb25zKTogdm9pZCB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIC0gdXNlIGdldEJpcDMyS2V5cygpIGluIGNvbmp1bmN0aW9uIHdpdGggaXNWYWxpZEFkZHJlc3MgaW5zdGVhZFxuICAgKi9cbiAgaW5pdGlhdGVSZWNvdmVyeShwYXJhbXM6IEluaXRpYXRlUmVjb3ZlcnlPcHRpb25zKTogbmV2ZXIge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVwcmVjYXRlZCBtZXRob2QnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPbmx5IHVzZWQgaW4gUGVuZGluZ0FwcHJvdmFsIGZvciBjb21wYXJpbmcgUEFZR28gZmVlcyBwdXJwb3NlXG4gICAqIEBwYXJhbSBwYXJhbXMgb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgKi9cbiAgYWJzdHJhY3QgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxQYXJzZWRUcmFuc2FjdGlvbj47XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEga2V5IHBhaXIgb24gdGhlIGN1cnZlIHVzZWQgYnkgdGhlIGNvaW5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IHNlZWQgLSBzZWVkIHRvIHVzZSBmb3Iga2V5IHBhaXIgZ2VuZXJhdGlvblxuICAgKiBAcmV0dXJucyB7S2V5UGFpcn0gdGhlIGdlbmVyYXRlZCBrZXkgcGFpclxuICAgKi9cbiAgYWJzdHJhY3QgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHJvb3Qga2V5IHBhaXIgb24gdGhlIGN1cnZlIHVzZWQgYnkgdGhlIGNvaW5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IHNlZWQgLSBzZWVkIHRvIHVzZSBmb3Iga2V5IHBhaXIgZ2VuZXJhdGlvblxuICAgKiBAcmV0dXJucyB7S2V5UGFpcn0gdGhlIGdlbmVyYXRlZCBrZXkgcGFpclxuICAgKi9cbiAgZ2VuZXJhdGVSb290S2V5UGFpcihzZWVkPzogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ2dlbmVyYXRlUm9vdEtleVBhaXIgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhpcyBjb2luJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHViIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBhYnN0cmFjdCBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmV0dXJuIHdldGhlciB0aGUgZ2l2ZW4gbSBvZiBuIHdhbGxldCBzaWduZXJzLyBrZXkgYW1vdW50cyBhcmUgdmFsaWQgZm9yIHRoZSBjb2luXG4gICAqL1xuICBpc1ZhbGlkTW9mTlNldHVwKHsgbSwgbiB9OiB7IG0/OiBudW1iZXI7IG4/OiBudW1iZXIgfSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBtID09PSAyICYmIG4gPT09IDM7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYGFkZHJlc3NgIGlzIGEgcGxhdXNpYmx5IHZhbGlkIGFkZHJlc3MgZm9yIHRoZSBnaXZlbiBjb2luLlxuICAgKlxuICAgKiBEb2VzIG5vdCB2ZXJpZnkgdGhhdCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvIGEgd2FsbGV0LiBGb3IgdGhhdCxcbiAgICogdXNlIFtbdmVyaWZ5QWRkcmVzc11dXG4gICAqIEBwYXJhbSBhZGRyZXNzXG4gICAqL1xuICBhYnN0cmFjdCBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTaWduIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFic3RyYWN0IHNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPjtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcG9ydGlvbiBvZiB0aGUgdHJhbnNhY3Rpb24gdGhhdCBuZWVkcyB0byBiZSBzaWduZWQgaW4gQnVmZmVyIGZvcm1hdC5cbiAgICogT25seSBuZWVkZWQgZm9yIGNvaW5zIHRoYXQgc3VwcG9ydCBhZGRpbmcgc2lnbmF0dXJlcyBkaXJlY3RseSAoZS5nLiBUU1MpLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VyaWFsaXplZFR4IC0gdGhlIHVuc2lnbmVkIHRyYW5zYWN0aW9uIGluIGJyb2FkY2FzdCBmb3JtYXRcbiAgICogQHJldHVybnMge1Byb21pc2U8QnVmZmVyPn0gLSB0aGUgcG9ydGlvbiBvZiB0aGUgdHJhbnNhY3Rpb24gdGhhdCBuZWVkcyB0byBiZSBzaWduZWRcbiAgICovXG4gIGFzeW5jIGdldFNpZ25hYmxlUGF5bG9hZChzZXJpYWxpemVkVHg6IHN0cmluZyk6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWRUeCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgTVBDIGFsZ29yaXRobSAoZWNkc2Egb3IgZWRkc2EpIHVzZWQgZm9yIGNvaW5zIHRoYXQgc3VwcG9ydCBUU1NcbiAgICovXG4gIGdldE1QQ0FsZ29yaXRobSgpOiBNUENBbGdvcml0aG0ge1xuICAgIHRocm93IG5ldyBFcnJvcignbm8gTVBDIGFsZ29yaXRobSBpcyBkZWZpbmVkIGZvciB0aGlzIGNvaW4nKTtcbiAgfVxuXG4gIGFzeW5jIHJlY292ZXJUb2tlbihwYXJhbXM6IFJlY292ZXJXYWxsZXRUb2tlbk9wdGlvbnMpOiBQcm9taXNlPFJlY292ZXJUb2tlblRyYW5zYWN0aW9uPiB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ3JlY292ZXJUb2tlbiBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIGNvaW4nKTtcbiAgfVxuXG4gIGdldEluc2NyaXB0aW9uQnVpbGRlcih3YWxsZXQ6IFdhbGxldCk6IElJbnNjcmlwdGlvbkJ1aWxkZXIge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCdJbnNjcmlwdGlvbiBCdWlsZGVyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHRoaXMgY29pbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRvIGdldCBjb2luIHNwZWNpZmljIGhhc2ggZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0cmFuc2FjdGlvbiBkaWdlc3RzLlxuICAgKiBAcmV0dXJucyB7QHNlZSBIYXNofSBoYXNoIGZ1bmN0aW9uIGlmIGltcGxlbWVudGVkLCBvdGhlcndpc2UgdGhyb3dzIGV4Y2VwdGlvblxuICAgKi9cbiAgZ2V0SGFzaEZ1bmN0aW9uKCk6IEhhc2gge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCdnZXRIYXNoRnVuY3Rpb24gaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhpcyBjb2luJyk7XG4gIH1cblxuICBidWlsZE5mdFRyYW5zZmVyRGF0YShwYXJhbXM6IEJ1aWxkTmZ0VHJhbnNmZXJEYXRhT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ2J1aWxkTmZ0VHJhbnNmZXJEYXRhIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHRoaXMgY29pbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJyb2FkY2FzdCBhIHRyYW5zYWN0aW9uIHRvIHRoZSBuZXR3b3JrXG4gICAqIEBwYXJhbSBwYXJhbXMgb3B0aW9ucyBmb3IgYnJvYWRjYXN0aW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJhc2VCcm9hZGNhc3RUcmFuc2FjdGlvblJlc3VsdD59IHJlc3VsdCBvZiBicm9hZGNhc3RcbiAgICogQHRocm93cyB7Tm90SW1wbGVtZW50ZWRFcnJvcn0gaWYgbm90IGltcGxlbWVudGVkXG4gICAqL1xuICBicm9hZGNhc3RUcmFuc2FjdGlvbihwYXJhbXM6IEJhc2VCcm9hZGNhc3RUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPEJhc2VCcm9hZGNhc3RUcmFuc2FjdGlvblJlc3VsdD4ge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCdicm9hZGNhc3RUcmFuc2FjdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIGNvaW4nKTtcbiAgfVxufVxuIl19