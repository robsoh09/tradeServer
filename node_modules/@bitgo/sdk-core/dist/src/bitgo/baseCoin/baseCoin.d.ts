/// <reference types="node" />
/// <reference types="node" />
import { BaseCoin as StaticsBaseCoin } from '@bitgo/statics';
import { InitiateRecoveryOptions } from '../recovery';
import { BitGoBase } from '../bitgoBase';
import { Enterprises } from '../enterprise';
import { Keychains } from '../keychain';
import { Markets } from '../market';
import { PendingApprovals } from '../pendingApproval';
import { Wallets, IWallet, Wallet } from '../wallet';
import { Webhooks } from '../webhook';
import { ExtraPrebuildParamsOptions, FeeEstimateOptions, IBaseCoin, ParsedTransaction, ITransactionExplanation, KeychainsTriplet, KeyPair, MPCAlgorithm, ParseTransactionOptions, PrecreateBitGoOptions, PresignTransactionOptions, RecoverTokenTransaction, RecoverWalletTokenOptions, SignedTransaction, SignTransactionOptions, SupplementGenerateWalletOptions, TokenEnablementConfig, TransactionPrebuild, VerifyAddressOptions, VerifyTransactionOptions, BuildNftTransferDataOptions, BaseBroadcastTransactionOptions, BaseBroadcastTransactionResult } from './iBaseCoin';
import { IInscriptionBuilder } from '../inscriptionBuilder';
import { Hash } from 'crypto';
export declare abstract class BaseCoin implements IBaseCoin {
    protected readonly bitgo: BitGoBase;
    protected readonly _url: string;
    protected readonly _enterprises: Enterprises;
    protected readonly _wallets: Wallets;
    protected readonly _keychains: Keychains;
    protected readonly _webhooks: Webhooks;
    protected readonly _pendingApprovals: PendingApprovals;
    protected readonly _markets: Markets;
    protected static readonly _coinTokenPatternSeparator = ":";
    protected readonly _staticsCoin: Readonly<StaticsBaseCoin>;
    protected constructor(bitgo: BitGoBase);
    url(suffix: string): string;
    wallets(): Wallets;
    enterprises(): Enterprises;
    keychains(): Keychains;
    webhooks(): Webhooks;
    pendingApprovals(): PendingApprovals;
    markets(): Markets;
    static get coinTokenPatternSeparator(): string;
    get type(): string;
    /**
     * Gets the statics coin object
     * @returns {Readonly<StaticsBaseCoin>} the statics coin object
     */
    getConfig(): Readonly<StaticsBaseCoin>;
    /**
     * Name of the chain which supports this coin (eg, 'btc', 'eth')
     */
    abstract getChain(): string;
    /**
     * Name of the coin family (eg. for tbtc, this would be btc)
     */
    abstract getFamily(): string;
    /**
     * Human readable full name for the coin
     */
    abstract getFullName(): string;
    /**
     * Flag for sending value of 0.
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed(): boolean;
    /**
     * Use `sendMany()` to perform wallet sweep.
     * FIXME(BG-39738): add coin.sweepWallet() instead
     */
    sweepWithSendMany(): boolean;
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    transactionDataAllowed(): boolean;
    /**
     * Flag for determining whether this coin supports account consolidations
     * from its receive addresses to the root address.
     * @returns {boolean} True if okay to consolidate over this coin; false, otherwise
     */
    allowsAccountConsolidations(): boolean;
    /**
     * Gets config for how token enablements work for this coin
     * @returns
     *    requiresTokenEnablement: True if tokens need to be enabled for this coin
     *    supportsMultipleTokenEnablements: True if multiple tokens can be enabled in one transaction
     */
    getTokenEnablementConfig(): TokenEnablementConfig;
    /**
     * Flag indicating if this coin supports TSS wallets.
     * @returns {boolean} True if TSS Wallets can be created for this coin
     */
    supportsTss(): boolean;
    /**
     * Flag indicating if the coin supports deriving a key with a seed (keyID)
     * to the user/backup keys.
     */
    supportsDeriveKeyWithSeed(): boolean;
    /**
     * Flag indicating if this blockchain runs on EVM architecture.
     * @returns {boolean} True if the blockchain runs on EVM architecture.
     */
    isEVM(): boolean;
    /**
     * Flag indicating if this coin supports BLS-DKG wallets.
     * @returns {boolean} True if BLS-DKG Wallets can be created for this coin
     */
    supportsBlsDkg(): boolean;
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    abstract getBaseFactor(): number | string;
    /**
     * Convert a currency amount represented in base units (satoshi, wei, atoms, drops, stroops)
     * to big units (btc, eth, xrp, xlm)
     */
    baseUnitsToBigUnits(baseUnits: string | number): string;
    /**
     * Convert a currency amount represented in big units (btc, eth, xrp, xlm)
     * to base units (satoshi, wei, atoms, drops, stroops)
     * @param bigUnits
     */
    bigUnitsToBaseUnits(bigUnits: string | number): string;
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    signMessage(key: {
        prv: string;
    }, message: string): Promise<Buffer>;
    /**
     * Create signatures for the backup and bitgo keys using the user key.
     * We can verify the signatures when fetching the keys from wallet-platform later.
     * Currently only `AbstractUtxoCoin` implements and uses the complementary `verifyKeySignature` method.
     * @param prv - the user private key
     * @param backupKeychain - contains the backup public key
     * @param bitgoKeychain - contains the bitgo public key
     */
    createKeySignatures(prv: string, backupKeychain: {
        pub: string;
    }, bitgoKeychain: {
        pub: string;
    }): Promise<{
        backup: string;
        bitgo: string;
    }>;
    /**
     * Decompose a raw transaction into useful information.
     * @param options - coin-specific
     */
    explainTransaction(options: Record<string, any>): Promise<ITransactionExplanation<any, string | number> | undefined>;
    /**
     * Verify that a transaction prebuild complies with the original intention
     */
    abstract verifyTransaction(params: VerifyTransactionOptions): Promise<boolean>;
    /**
     * @deprecated use {@see isWalletAddress} instead
     */
    verifyAddress(params: VerifyAddressOptions): Promise<boolean>;
    /**
     * @param params
     * @return true iff address is a wallet address. Must return false if address is outside wallet.
     */
    abstract isWalletAddress(params: VerifyAddressOptions): Promise<boolean>;
    /**
     * convert address into desired address format.
     * @param address
     * @param format
     */
    canonicalAddress(address: string, format?: unknown): string;
    /**
     * Check whether a coin supports blockTarget for transactions to be included in
     * @returns {boolean}
     */
    supportsBlockTarget(): boolean;
    /**
     * Check whether a coin supports lightning transactions
     * @returns {boolean}
     */
    supportsLightning(): boolean;
    /**
     * Check whether a coin supports message signing
     * @returns {boolean}
     */
    supportsMessageSigning(): boolean;
    /**
     * Check whether a coin supports signing of Typed data
     * @returns {boolean}
     */
    supportsSigningTypedData(): boolean;
    /**
     * Hook to add additional parameters to the wallet generation
     * @param walletParams
     * @param keychains
     * @return {*}
     */
    supplementGenerateWallet(walletParams: SupplementGenerateWalletOptions, keychains: KeychainsTriplet): Promise<any>;
    /**
     * Get extra parameters for prebuilding a tx. Add things like hop transaction params
     */
    getExtraPrebuildParams(buildParams: ExtraPrebuildParamsOptions): Promise<Record<string, unknown>>;
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    postProcessPrebuild(prebuildResponse: TransactionPrebuild): Promise<TransactionPrebuild>;
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     */
    presignTransaction(params: PresignTransactionOptions): Promise<PresignTransactionOptions>;
    /**
     * Create a new wallet object from a wallet data object
     * @param walletParams
     */
    newWalletObject(walletParams: any): IWallet;
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Integer} params.numBlocks The number of blocks to target for conformation (Only works for btc)
     * @returns {Object} The info returned from the merchant server
     */
    feeEstimate(params: FeeEstimateOptions): Promise<any>;
    /**
     * The cold wallet tool uses this function to derive an extended key that is based on the passed key and seed
     * @param key
     * @param seed
     * @returns {{key: string, derivationPath: string}}
     */
    deriveKeyWithSeed({ key, seed }: {
        key: string;
        seed: string;
    }): {
        key: string;
        derivationPath: string;
    };
    /**
     * Specifies what key we will need for signing - right now we just need the
     * user key.
     */
    keyIdsForSigning(): number[];
    /**
     * Perform additional checks before adding a bitgo key. Base controller
     * is a no-op, but coin-specific controller may do something
     * @param params
     */
    preCreateBitGo(params: PrecreateBitGoOptions): void;
    /**
     * @deprecated - use getBip32Keys() in conjunction with isValidAddress instead
     */
    initiateRecovery(params: InitiateRecoveryOptions): never;
    /**
     * Only used in PendingApproval for comparing PAYGo fees purpose
     * @param params options for parsing
     */
    abstract parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
    /**
     * Generate a key pair on the curve used by the coin
     * @param {Buffer} seed - seed to use for key pair generation
     * @returns {KeyPair} the generated key pair
     */
    abstract generateKeyPair(seed?: Buffer): KeyPair;
    /**
     * Generate a root key pair on the curve used by the coin
     * @param {Buffer} seed - seed to use for key pair generation
     * @returns {KeyPair} the generated key pair
     */
    generateRootKeyPair(seed?: Buffer): KeyPair;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    abstract isValidPub(pub: string): boolean;
    /**
     * Return wether the given m of n wallet signers/ key amounts are valid for the coin
     */
    isValidMofNSetup({ m, n }: {
        m?: number;
        n?: number;
    }): boolean;
    /**
     * Check if `address` is a plausibly valid address for the given coin.
     *
     * Does not verify that the address belongs to a wallet. For that,
     * use [[verifyAddress]]
     * @param address
     */
    abstract isValidAddress(address: string): boolean;
    /**
     * Sign a transaction
     */
    abstract signTransaction(params: SignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Returns the portion of the transaction that needs to be signed in Buffer format.
     * Only needed for coins that support adding signatures directly (e.g. TSS).
     *
     * @param {String} serializedTx - the unsigned transaction in broadcast format
     * @returns {Promise<Buffer>} - the portion of the transaction that needs to be signed
     */
    getSignablePayload(serializedTx: string): Promise<Buffer>;
    /**
     * Returns the MPC algorithm (ecdsa or eddsa) used for coins that support TSS
     */
    getMPCAlgorithm(): MPCAlgorithm;
    recoverToken(params: RecoverWalletTokenOptions): Promise<RecoverTokenTransaction>;
    getInscriptionBuilder(wallet: Wallet): IInscriptionBuilder;
    /**
     * Function to get coin specific hash function used to generate transaction digests.
     * @returns {@see Hash} hash function if implemented, otherwise throws exception
     */
    getHashFunction(): Hash;
    buildNftTransferData(params: BuildNftTransferDataOptions): string;
    /**
     * Broadcast a transaction to the network
     * @param params options for broadcasting
     * @returns {Promise<BaseBroadcastTransactionResult>} result of broadcast
     * @throws {NotImplementedError} if not implemented
     */
    broadcastTransaction(params: BaseBroadcastTransactionOptions): Promise<BaseBroadcastTransactionResult>;
}
//# sourceMappingURL=baseCoin.d.ts.map