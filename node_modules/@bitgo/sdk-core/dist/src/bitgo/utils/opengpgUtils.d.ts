import * as pgp from 'openpgp';
import { Key } from 'openpgp';
import { BitGoBase } from '../bitgoBase';
export declare type KeyValidityDict = {
    keyID: pgp.KeyID;
    valid: boolean | null;
}[];
export declare type AuthEncMessage = {
    encryptedMessage: string;
    signature: string;
};
/**
 * Fetches BitGo's public gpg key used in MPC flows
 * @param {BitGoBase} bitgo BitGo object
 * @return {Key} public gpg key
 */
export declare function getBitgoGpgPubKey(bitgo: BitGoBase): Promise<{
    mpcV1: Key;
    mpcV2: Key | undefined;
}>;
/**
 * Verifies the primary user on a GPG key using a reference key representing the user to be checked.
 * Allows a verification without a date check by wrapping verifyPrimaryUser of openpgp.
 * @param {Key} pubKey gpg key to check the primary user of.
 * @param {Key} primaryUser gpg key of the user to check.
 * @param {boolean} checkDates If false, disable date checks in the openpgp call to check the primary user.
 * @return {KeyValidityDict} list of users checked and whether each passed as a primary user in pubKey or not.
 */
export declare function verifyPrimaryUserWrapper(pubKey: Key, primaryUser: Key, checkDates: boolean): Promise<KeyValidityDict>;
/**
 * Fetches Trust pub key string
 * @param bitgo
 */
export declare function getTrustGpgPubKey(bitgo: BitGoBase): Promise<Key>;
/**
 * Verify an Eddsa or Ecdsa KeyShare Proof.
 *
 * @param senderPubKey public key of the sender of the privateShareProof
 * @param privateShareProof u value proof
 * @param uValue u value from an Eddsa keyshare
 * @param algo
 * @return {boolean} whether uValue proof actually was signed by sender as part of their subkeys
 */
export declare function verifyShareProof(senderPubKey: string, privateShareProof: string, uValue: string, algo: 'eddsa' | 'ecdsa'): Promise<boolean>;
/**
 * Verify a shared data proof.
 *
 * @param senderPubKeyArm public key of the signer of the key with proof data
 * @param keyWithNotation signed reciever key with notation data
 * @param dataToVerify data to be checked against notation data in the signed key
 * @return {boolean} whether proof is valid
 */
export declare function verifySharedDataProof(senderPubKeyArm: string, keyWithNotation: string, dataToVerify: {
    name: string;
    value: string;
}[]): Promise<boolean>;
/**
 * Creates a proof through adding notation data to a GPG ceritifying signature.
 *
 * @param privateKeyArmored gpg private key in armor format of the sender
 * @param publicKeyToCertArmored gpg public key in armor fomrat of the reciever
 * @param notations data to be proofed
 * @return {string} keyshare proof
 */
export declare function createSharedDataProof(privateKeyArmored: string, publicKeyToCertArmored: string, notations: {
    name: string;
    value: string;
}[]): Promise<string>;
/**
 * Creates a KeyShare Proof based on given algo.
 *
 * Creates an EdDSA KeyShare Proof by appending an ed25519 subkey (auth) to an armored gpg private key.
 * Creates an ECDSA KeyShare Proof by Append a secp256k1 subkey (auth) to a PGP keychain.
 *
 * @param privateArmor gpg private key in armor format
 * @param uValue u value from an Eddsa keyshare
 * @param algo algo to use, eddsa or ecdsa
 * @return {string} keyshare proof
 */
export declare function createShareProof(privateArmor: string, uValue: string, algo: string): Promise<string>;
/**
 * Encrypts string using gpg key
 * @DEPRECATED - should use encryptAndSignText instead for added security
 *
 * @param text string to encrypt
 * @param key encryption key
 * @return {string} encrypted string
 *
 * TODO(BG-47170): Delete once gpg signatures are fully supported
 */
export declare function encryptText(text: string, key: Key): Promise<string>;
/**
 * Encrypts and signs a string
 * @param text string to encrypt and sign
 * @param publicArmor public key to encrypt with
 * @param privateArmor private key to sign with
 */
export declare function encryptAndSignText(text: string, publicArmor: string, privateArmor: string): Promise<string>;
/**
 * Reads a signed and encrypted message
 *
 * @param signed signed and encrypted message
 * @param publicArmor public key to verify signature
 * @param privateArmor private key to decrypt message
 */
export declare function readSignedMessage(signed: string, publicArmor: string, privateArmor: string): Promise<string>;
/**
 * Generates a signature
 *
 * @param text string to generate a signature for
 * @param privateArmor private key as armored string
 * @return {string} armored signature string
 */
export declare function signText(text: string, privateArmor: string): Promise<string>;
/**
 * Verifies signature was generated by the public key and matches the expected text
 *
 * @param text text that the signature was for
 * @param armoredSignature signed message as an armored string
 * @param publicArmor public key that generated the signature
 */
export declare function verifySignature(text: string, armoredSignature: string, publicArmor: string): Promise<boolean>;
/**
 * Generate a GPG key pair
 *
 * @param: keyCurve the curve to create a key with
 * @param: username name of the user (optional)
 * @param: email email of the user (optional)
 */
export declare function generateGPGKeyPair(keyCurve: pgp.EllipticCurveName, username?: string | undefined, email?: string | undefined): Promise<pgp.SerializedKeyPair<string>>;
//# sourceMappingURL=opengpgUtils.d.ts.map