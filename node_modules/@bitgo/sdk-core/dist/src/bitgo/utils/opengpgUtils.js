"use strict";
/* eslint-disable @typescript-eslint/ban-ts-comment */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateGPGKeyPair = exports.verifySignature = exports.signText = exports.readSignedMessage = exports.encryptAndSignText = exports.encryptText = exports.createShareProof = exports.createSharedDataProof = exports.verifySharedDataProof = exports.verifyShareProof = exports.getTrustGpgPubKey = exports.verifyPrimaryUserWrapper = exports.getBitgoGpgPubKey = void 0;
const pgp = __importStar(require("openpgp"));
const openpgp_1 = require("openpgp");
const _ = __importStar(require("lodash"));
const utxo_lib_1 = require("@bitgo/utxo-lib");
const crypto_1 = __importDefault(require("crypto"));
const sodium = require('libsodium-wrappers-sumo');
/**
 * Fetches BitGo's public gpg key used in MPC flows
 * @param {BitGoBase} bitgo BitGo object
 * @return {Key} public gpg key
 */
async function getBitgoGpgPubKey(bitgo) {
    const constants = await bitgo.fetchConstants();
    if (!constants.mpc || !constants.mpc.bitgoPublicKey) {
        throw new Error('Unable to create MPC keys - bitgoPublicKey is missing from constants');
    }
    const bitgoPublicKeyStr = constants.mpc.bitgoPublicKey;
    const bitgoMPCv2PublicKeyStr = constants.mpc.bitgoMPCv2PublicKey
        ? await (0, openpgp_1.readKey)({ armoredKey: constants.mpc.bitgoMPCv2PublicKey })
        : undefined;
    return { mpcV1: await (0, openpgp_1.readKey)({ armoredKey: bitgoPublicKeyStr }), mpcV2: bitgoMPCv2PublicKeyStr };
}
exports.getBitgoGpgPubKey = getBitgoGpgPubKey;
/**
 * Verifies the primary user on a GPG key using a reference key representing the user to be checked.
 * Allows a verification without a date check by wrapping verifyPrimaryUser of openpgp.
 * @param {Key} pubKey gpg key to check the primary user of.
 * @param {Key} primaryUser gpg key of the user to check.
 * @param {boolean} checkDates If false, disable date checks in the openpgp call to check the primary user.
 * @return {KeyValidityDict} list of users checked and whether each passed as a primary user in pubKey or not.
 */
async function verifyPrimaryUserWrapper(pubKey, primaryUser, checkDates) {
    if (checkDates) {
        return await pubKey.verifyPrimaryUser([primaryUser]);
    }
    else {
        return await pubKey.verifyPrimaryUser([primaryUser], null);
    }
}
exports.verifyPrimaryUserWrapper = verifyPrimaryUserWrapper;
/**
 * Fetches Trust pub key string
 * @param bitgo
 */
async function getTrustGpgPubKey(bitgo) {
    const constants = await bitgo.fetchConstants();
    if (!constants.trustPubKey) {
        throw new Error('Unable to get trustPubKey');
    }
    return (0, openpgp_1.readKey)({ armoredKey: constants.trustPubKey });
}
exports.getTrustGpgPubKey = getTrustGpgPubKey;
/**
 * Verify an Eddsa or Ecdsa KeyShare Proof.
 *
 * @param senderPubKey public key of the sender of the privateShareProof
 * @param privateShareProof u value proof
 * @param uValue u value from an Eddsa keyshare
 * @param algo
 * @return {boolean} whether uValue proof actually was signed by sender as part of their subkeys
 */
async function verifyShareProof(senderPubKey, privateShareProof, uValue, algo) {
    const decodedProof = await pgp.readKey({ armoredKey: privateShareProof });
    const senderGpgKey = await pgp.readKey({ armoredKey: senderPubKey });
    if (!(await verifyPrimaryUserWrapper(decodedProof, senderGpgKey, true))[0].valid) {
        return false;
    }
    const proofSubkeys = decodedProof.getSubkeys()[1];
    if (algo === 'eddsa') {
        const decodedUValueProof = Buffer.from(proofSubkeys.keyPacket.publicParams['Q'].slice(1)).toString('hex');
        const rawUValueProof = Buffer.from(sodium.crypto_scalarmult_ed25519_base_noclamp(Buffer.from(uValue, 'hex'))).toString('hex');
        return decodedUValueProof === rawUValueProof;
    }
    else if (algo === 'ecdsa') {
        const decodedUValueProof = Buffer.from(proofSubkeys.keyPacket.publicParams['Q']).toString('hex');
        const rawUValueProof = utxo_lib_1.ecc.pointFromScalar(Buffer.from(uValue, 'hex'), false);
        return rawUValueProof !== null && decodedUValueProof === Buffer.from(rawUValueProof).toString('hex');
    }
    else {
        throw new Error('Invalid algorithm provided');
    }
}
exports.verifyShareProof = verifyShareProof;
/**
 * Verify a shared data proof.
 *
 * @param senderPubKeyArm public key of the signer of the key with proof data
 * @param keyWithNotation signed reciever key with notation data
 * @param dataToVerify data to be checked against notation data in the signed key
 * @return {boolean} whether proof is valid
 */
async function verifySharedDataProof(senderPubKeyArm, keyWithNotation, dataToVerify) {
    const senderPubKey = await pgp.readKey({ armoredKey: senderPubKeyArm });
    const signedKey = await pgp.readKey({ armoredKey: keyWithNotation });
    if (!(await verifyPrimaryUserWrapper(signedKey, senderPubKey, true).then((values) => _.some(values, (value) => value.valid)))) {
        return false;
    }
    const primaryUser = await signedKey.getPrimaryUser();
    const anyInvalidProof = _.some(
    // @ts-ignore
    primaryUser.user.otherCertifications[0].rawNotations, (notation) => { var _a; return ((_a = dataToVerify.find((i) => i.name === notation.name)) === null || _a === void 0 ? void 0 : _a.value) !== Buffer.from(notation.value).toString(); });
    return !anyInvalidProof;
}
exports.verifySharedDataProof = verifySharedDataProof;
/**
 * Creates a proof through adding notation data to a GPG ceritifying signature.
 *
 * @param privateKeyArmored gpg private key in armor format of the sender
 * @param publicKeyToCertArmored gpg public key in armor fomrat of the reciever
 * @param notations data to be proofed
 * @return {string} keyshare proof
 */
async function createSharedDataProof(privateKeyArmored, publicKeyToCertArmored, notations) {
    const certifyingKey = await pgp.readKey({ armoredKey: privateKeyArmored });
    const publicKeyToCert = await pgp.readKey({ armoredKey: publicKeyToCertArmored });
    const dateTime = new Date();
    // UserId Packet.
    const userIdPkt = new pgp.UserIDPacket();
    const primaryUser = await publicKeyToCert.getPrimaryUser();
    // @ts-ignore
    userIdPkt.userID = primaryUser.user.userID.userID;
    // Signature packet.
    const signaturePacket = new pgp.SignaturePacket();
    signaturePacket.signatureType = pgp.enums.signature.certPositive;
    signaturePacket.publicKeyAlgorithm = pgp.enums.publicKey.ecdsa;
    signaturePacket.hashAlgorithm = pgp.enums.hash.sha256;
    // @ts-ignore
    signaturePacket.issuerFingerprint = await primaryUser.user.mainKey.keyPacket.getFingerprintBytes();
    // @ts-ignore
    signaturePacket.issuerKeyID = primaryUser.user.mainKey.keyPacket.keyID;
    // @ts-ignore
    signaturePacket.signingKeyID = primaryUser.user.mainKey.keyPacket.keyID;
    // @ts-ignore
    signaturePacket.signersUserID = primaryUser.user.userID.userID;
    // @ts-ignore
    signaturePacket.features = [1];
    notations.forEach(({ name, value }) => {
        signaturePacket.rawNotations.push({
            name: name,
            value: new Uint8Array(Buffer.from(value)),
            humanReadable: true,
            critical: false,
        });
    });
    // Prepare signing data.
    const keydataToSign = {};
    // @ts-ignore
    keydataToSign.key = publicKeyToCert.keyPacket;
    // @ts-ignore
    keydataToSign.userID = userIdPkt;
    // Sign the data (create certification).
    // @ts-ignore
    await signaturePacket.sign(certifyingKey.keyPacket, keydataToSign, dateTime);
    // Assemble packets together.
    const publicKeyToCertPkts = publicKeyToCert.toPacketList();
    const newKeyPktList = new pgp.PacketList();
    newKeyPktList.push(...publicKeyToCertPkts.slice(0, 3), signaturePacket, ...publicKeyToCertPkts.slice(3));
    // @ts-ignore
    const newPubKey = new pgp.PublicKey(newKeyPktList);
    return newPubKey.armor().replace(/\r\n/g, '\n');
}
exports.createSharedDataProof = createSharedDataProof;
/**
 * Creates a KeyShare Proof based on given algo.
 *
 * Creates an EdDSA KeyShare Proof by appending an ed25519 subkey (auth) to an armored gpg private key.
 * Creates an ECDSA KeyShare Proof by Append a secp256k1 subkey (auth) to a PGP keychain.
 *
 * @param privateArmor gpg private key in armor format
 * @param uValue u value from an Eddsa keyshare
 * @param algo algo to use, eddsa or ecdsa
 * @return {string} keyshare proof
 */
async function createShareProof(privateArmor, uValue, algo) {
    const privateKey = await (0, openpgp_1.readKey)({ armoredKey: privateArmor });
    const dateTime = new Date();
    // @ts-ignore - type inconsistency, this ctor supports a date param: https://docs.openpgpjs.org/SecretSubkeyPacket.html
    const secretSubkeyPacket = new pgp.SecretSubkeyPacket(dateTime);
    secretSubkeyPacket.algorithm = pgp.enums.publicKey[algo];
    // @ts-ignore - same as above
    secretSubkeyPacket.isEncrypted = false;
    let oid;
    let Q;
    if (algo === 'eddsa') {
        await sodium.ready;
        const subKeyVal = Buffer.from(sodium.crypto_scalarmult_ed25519_base_noclamp(Buffer.from(uValue, 'hex'), 'uint8array'));
        // Sub-key (encryption key) packet.
        oid = [0x2b, 0x06, 0x01, 0x04, 0x01, 0xda, 0x47, 0x0f, 0x01];
        // @ts-ignore
        oid.write = () => new Uint8Array(Buffer.from('092b06010401da470f01', 'hex'));
        Q = new Uint8Array([0x40, ...subKeyVal]);
    }
    else if (algo === 'ecdsa') {
        oid = [0x2b, 0x81, 0x04, 0x00, 0x0a];
        // @ts-ignore - same as above
        oid.write = () => new Uint8Array(Buffer.from('052b8104000a', 'hex'));
        Q = utxo_lib_1.ecc.pointFromScalar(new Uint8Array(Buffer.from(uValue, 'hex')), false);
    }
    secretSubkeyPacket.publicParams = {
        oid,
        Q,
    };
    // @ts-ignore - same as above
    await secretSubkeyPacket.computeFingerprintAndKeyID();
    // Sub-key signature packet.
    const subKeydataToSign = {
        key: privateKey.keyPacket,
        bind: secretSubkeyPacket,
    };
    const subkeySignaturePacket = new pgp.SignaturePacket();
    subkeySignaturePacket.signatureType = pgp.enums.signature.subkeyBinding;
    subkeySignaturePacket.publicKeyAlgorithm = pgp.enums.publicKey.ecdsa;
    subkeySignaturePacket.hashAlgorithm = pgp.enums.hash.sha256;
    subkeySignaturePacket.keyFlags = new Uint8Array([pgp.enums.keyFlags.authentication]);
    // Sign the subkey
    // @ts-ignore - sign supports arbitrary data for 2nd param: https://docs.openpgpjs.org/SignaturePacket.html
    await subkeySignaturePacket.sign(privateKey.keyPacket, subKeydataToSign, dateTime);
    // Assemble packets together.
    const newKeyPktList = new pgp.PacketList();
    const privateKeyPkts = privateKey.toPacketList();
    privateKeyPkts.forEach((packet) => newKeyPktList.push(packet));
    newKeyPktList.push(secretSubkeyPacket, subkeySignaturePacket);
    // @ts-ignore - supports packet list as ctor param: https://docs.openpgpjs.org/PrivateKey.html
    const newPubKey = new pgp.PrivateKey(newKeyPktList).toPublic();
    if (!(await verifyPrimaryUserWrapper(newPubKey, privateKey, true))[0].valid) {
        throw new Error('Incorrect signature');
    }
    return newPubKey.armor().replace(/\r\n/g, '\n');
}
exports.createShareProof = createShareProof;
/**
 * Encrypts string using gpg key
 * @DEPRECATED - should use encryptAndSignText instead for added security
 *
 * @param text string to encrypt
 * @param key encryption key
 * @return {string} encrypted string
 *
 * TODO(BG-47170): Delete once gpg signatures are fully supported
 */
async function encryptText(text, key) {
    const messageToEncrypt = await (0, openpgp_1.createMessage)({
        text,
    });
    return await (0, openpgp_1.encrypt)({
        message: messageToEncrypt,
        encryptionKeys: [key],
        format: 'armored',
        config: {
            rejectCurves: new Set(),
            showVersion: false,
            showComment: false,
        },
    });
}
exports.encryptText = encryptText;
/**
 * Encrypts and signs a string
 * @param text string to encrypt and sign
 * @param publicArmor public key to encrypt with
 * @param privateArmor private key to sign with
 */
async function encryptAndSignText(text, publicArmor, privateArmor) {
    const publicKey = await (0, openpgp_1.readKey)({ armoredKey: publicArmor });
    const privateKey = await (0, openpgp_1.readPrivateKey)({ armoredKey: privateArmor });
    const message = await (0, openpgp_1.createMessage)({ text });
    const signedMessage = await (0, openpgp_1.encrypt)({
        message,
        encryptionKeys: publicKey,
        signingKeys: privateKey,
        format: 'armored',
        config: {
            rejectCurves: new Set(),
            showVersion: false,
            showComment: false,
        },
    });
    return signedMessage;
}
exports.encryptAndSignText = encryptAndSignText;
/**
 * Reads a signed and encrypted message
 *
 * @param signed signed and encrypted message
 * @param publicArmor public key to verify signature
 * @param privateArmor private key to decrypt message
 */
async function readSignedMessage(signed, publicArmor, privateArmor) {
    const publicKey = await (0, openpgp_1.readKey)({ armoredKey: publicArmor });
    const privateKey = await (0, openpgp_1.readPrivateKey)({ armoredKey: privateArmor });
    const message = await (0, openpgp_1.readMessage)({ armoredMessage: signed });
    const decrypted = await (0, openpgp_1.decrypt)({
        message,
        verificationKeys: publicKey,
        decryptionKeys: privateKey,
        expectSigned: true,
        config: { rejectCurves: new Set() },
    });
    return decrypted.data;
}
exports.readSignedMessage = readSignedMessage;
/**
 * Generates a signature
 *
 * @param text string to generate a signature for
 * @param privateArmor private key as armored string
 * @return {string} armored signature string
 */
async function signText(text, privateArmor) {
    const privateKey = await (0, openpgp_1.readPrivateKey)({ armoredKey: privateArmor });
    const message = await (0, openpgp_1.createMessage)({ text });
    const signature = await (0, openpgp_1.sign)({
        message,
        signingKeys: privateKey,
        format: 'armored',
        detached: true,
    });
    return signature;
}
exports.signText = signText;
/**
 * Verifies signature was generated by the public key and matches the expected text
 *
 * @param text text that the signature was for
 * @param armoredSignature signed message as an armored string
 * @param publicArmor public key that generated the signature
 */
async function verifySignature(text, armoredSignature, publicArmor) {
    const publicKey = await (0, openpgp_1.readKey)({ armoredKey: publicArmor });
    const signature = await (0, openpgp_1.readSignature)({ armoredSignature });
    const message = await (0, openpgp_1.createMessage)({ text });
    const verificationResult = await (0, openpgp_1.verify)({
        message,
        signature,
        verificationKeys: publicKey,
    });
    if (verificationResult.signatures.length !== 1) {
        throw new Error('Invalid number of signatures');
    }
    try {
        await verificationResult.signatures[0].verified;
        return text === verificationResult.data;
    }
    catch {
        return false;
    }
}
exports.verifySignature = verifySignature;
/**
 * Generate a GPG key pair
 *
 * @param: keyCurve the curve to create a key with
 * @param: username name of the user (optional)
 * @param: email email of the user (optional)
 */
async function generateGPGKeyPair(keyCurve, username, email) {
    const randomHexString = crypto_1.default.randomBytes(12).toString('hex');
    username = username !== null && username !== void 0 ? username : randomHexString;
    email = email !== null && email !== void 0 ? email : `user-${randomHexString}@${randomHexString}.com`;
    // Allow generating secp256k1 key pairs
    pgp.config.rejectCurves = new Set();
    const gpgKey = await pgp.generateKey({
        userIDs: [
            {
                name: username,
                email,
            },
        ],
        curve: keyCurve,
    });
    return gpgKey;
}
exports.generateGPGKeyPair = generateGPGKeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3BlbmdwZ1V0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2JpdGdvL3V0aWxzL29wZW5ncGdVdGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsc0RBQXNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUV0RCw2Q0FBK0I7QUFDL0IscUNBV2lCO0FBQ2pCLDBDQUE0QjtBQUM1Qiw4Q0FBbUQ7QUFFbkQsb0RBQTRCO0FBRTVCLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0FBWWxEOzs7O0dBSUc7QUFDSSxLQUFLLFVBQVUsaUJBQWlCLENBQUMsS0FBZ0I7SUFDdEQsTUFBTSxTQUFTLEdBQUcsTUFBTSxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDL0MsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRTtRQUNuRCxNQUFNLElBQUksS0FBSyxDQUFDLHNFQUFzRSxDQUFDLENBQUM7S0FDekY7SUFFRCxNQUFNLGlCQUFpQixHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsY0FBd0IsQ0FBQztJQUNqRSxNQUFNLHNCQUFzQixHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsbUJBQW1CO1FBQzlELENBQUMsQ0FBQyxNQUFNLElBQUEsaUJBQU8sRUFBQyxFQUFFLFVBQVUsRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDLG1CQUE2QixFQUFFLENBQUM7UUFDNUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQztJQUNkLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxJQUFBLGlCQUFPLEVBQUMsRUFBRSxVQUFVLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxzQkFBc0IsRUFBRSxDQUFDO0FBQ3BHLENBQUM7QUFYRCw4Q0FXQztBQUVEOzs7Ozs7O0dBT0c7QUFDSSxLQUFLLFVBQVUsd0JBQXdCLENBQzVD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LGFBQVIsUUFBUSxjQUFSLFFBQVEsR0FBSSxlQUFlLENBQUM7SUFDdkMsS0FBSyxHQUFHLEtBQUssYUFBTCxLQUFLLGNBQUwsS0FBSyxHQUFJLFFBQVEsZUFBZSxJQUFJLGVBQWUsTUFBTSxDQUFDO0lBRWxFLHVDQUF1QztJQUN2QyxHQUFHLENBQUMsTUFBTSxDQUFDLFlBQVksR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQ3BDLE1BQU0sTUFBTSxHQUFHLE1BQU0sR0FBRyxDQUFDLFdBQVcsQ0FBQztRQUNuQyxPQUFPLEVBQUU7WUFDUDtnQkFDRSxJQUFJLEVBQUUsUUFBUTtnQkFDZCxLQUFLO2FBQ047U0FDRjtRQUNELEtBQUssRUFBRSxRQUFRO0tBQ2hCLENBQUMsQ0FBQztJQUVILE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUF0QkQsZ0RBc0JDIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50ICovXG5cbmltcG9ydCAqIGFzIHBncCBmcm9tICdvcGVucGdwJztcbmltcG9ydCB7XG4gIGNyZWF0ZU1lc3NhZ2UsXG4gIGRlY3J5cHQsXG4gIGVuY3J5cHQsXG4gIEtleSxcbiAgcmVhZEtleSxcbiAgcmVhZE1lc3NhZ2UsXG4gIHJlYWRQcml2YXRlS2V5LFxuICByZWFkU2lnbmF0dXJlLFxuICBzaWduLFxuICB2ZXJpZnksXG59IGZyb20gJ29wZW5wZ3AnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZWNjIGFzIHNlY3AyNTZrMSB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgeyBCaXRHb0Jhc2UgfSBmcm9tICcuLi9iaXRnb0Jhc2UnO1xuaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG5jb25zdCBzb2RpdW0gPSByZXF1aXJlKCdsaWJzb2RpdW0td3JhcHBlcnMtc3VtbycpO1xuXG5leHBvcnQgdHlwZSBLZXlWYWxpZGl0eURpY3QgPSB7XG4gIGtleUlEOiBwZ3AuS2V5SUQ7XG4gIHZhbGlkOiBib29sZWFuIHwgbnVsbDtcbn1bXTtcblxuZXhwb3J0IHR5cGUgQXV0aEVuY01lc3NhZ2UgPSB7XG4gIGVuY3J5cHRlZE1lc3NhZ2U6IHN0cmluZztcbiAgc2lnbmF0dXJlOiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIEZldGNoZXMgQml0R28ncyBwdWJsaWMgZ3BnIGtleSB1c2VkIGluIE1QQyBmbG93c1xuICogQHBhcmFtIHtCaXRHb0Jhc2V9IGJpdGdvIEJpdEdvIG9iamVjdFxuICogQHJldHVybiB7S2V5fSBwdWJsaWMgZ3BnIGtleVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Qml0Z29HcGdQdWJLZXkoYml0Z286IEJpdEdvQmFzZSk6IFByb21pc2U8eyBtcGNWMTogS2V5OyBtcGNWMjogS2V5IHwgdW5kZWZpbmVkIH0+IHtcbiAgY29uc3QgY29uc3RhbnRzID0gYXdhaXQgYml0Z28uZmV0Y2hDb25zdGFudHMoKTtcbiAgaWYgKCFjb25zdGFudHMubXBjIHx8ICFjb25zdGFudHMubXBjLmJpdGdvUHVibGljS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gY3JlYXRlIE1QQyBrZXlzIC0gYml0Z29QdWJsaWNLZXkgaXMgbWlzc2luZyBmcm9tIGNvbnN0YW50cycpO1xuICB9XG5cbiAgY29uc3QgYml0Z29QdWJsaWNLZXlTdHIgPSBjb25zdGFudHMubXBjLmJpdGdvUHVibGljS2V5IGFzIHN0cmluZztcbiAgY29uc3QgYml0Z29NUEN2MlB1YmxpY0tleVN0ciA9IGNvbnN0YW50cy5tcGMuYml0Z29NUEN2MlB1YmxpY0tleVxuICAgID8gYXdhaXQgcmVhZEtleSh7IGFybW9yZWRLZXk6IGNvbnN0YW50cy5tcGMuYml0Z29NUEN2MlB1YmxpY0tleSBhcyBzdHJpbmcgfSlcbiAgICA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHsgbXBjVjE6IGF3YWl0IHJlYWRLZXkoeyBhcm1vcmVkS2V5OiBiaXRnb1B1YmxpY0tleVN0ciB9KSwgbXBjVjI6IGJpdGdvTVBDdjJQdWJsaWNLZXlTdHIgfTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGUgcHJpbWFyeSB1c2VyIG9uIGEgR1BHIGtleSB1c2luZyBhIHJlZmVyZW5jZSBrZXkgcmVwcmVzZW50aW5nIHRoZSB1c2VyIHRvIGJlIGNoZWNrZWQuXG4gKiBBbGxvd3MgYSB2ZXJpZmljYXRpb24gd2l0aG91dCBhIGRhdGUgY2hlY2sgYnkgd3JhcHBpbmcgdmVyaWZ5UHJpbWFyeVVzZXIgb2Ygb3BlbnBncC5cbiAqIEBwYXJhbSB7S2V5fSBwdWJLZXkgZ3BnIGtleSB0byBjaGVjayB0aGUgcHJpbWFyeSB1c2VyIG9mLlxuICogQHBhcmFtIHtLZXl9IHByaW1hcnlVc2VyIGdwZyBrZXkgb2YgdGhlIHVzZXIgdG8gY2hlY2suXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrRGF0ZXMgSWYgZmFsc2UsIGRpc2FibGUgZGF0ZSBjaGVja3MgaW4gdGhlIG9wZW5wZ3AgY2FsbCB0byBjaGVjayB0aGUgcHJpbWFyeSB1c2VyLlxuICogQHJldHVybiB7S2V5VmFsaWRpdHlEaWN0fSBsaXN0IG9mIHVzZXJzIGNoZWNrZWQgYW5kIHdoZXRoZXIgZWFjaCBwYXNzZWQgYXMgYSBwcmltYXJ5IHVzZXIgaW4gcHViS2V5IG9yIG5vdC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeVByaW1hcnlVc2VyV3JhcHBlcihcbiAgcHViS2V5OiBLZXksXG4gIHByaW1hcnlVc2VyOiBLZXksXG4gIGNoZWNrRGF0ZXM6IGJvb2xlYW5cbik6IFByb21pc2U8S2V5VmFsaWRpdHlEaWN0PiB7XG4gIGlmIChjaGVja0RhdGVzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHB1YktleS52ZXJpZnlQcmltYXJ5VXNlcihbcHJpbWFyeVVzZXJdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXdhaXQgcHViS2V5LnZlcmlmeVByaW1hcnlVc2VyKFtwcmltYXJ5VXNlcl0sIG51bGwgYXMgdW5rbm93biBhcyB1bmRlZmluZWQpO1xuICB9XG59XG5cbi8qKlxuICogRmV0Y2hlcyBUcnVzdCBwdWIga2V5IHN0cmluZ1xuICogQHBhcmFtIGJpdGdvXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUcnVzdEdwZ1B1YktleShiaXRnbzogQml0R29CYXNlKTogUHJvbWlzZTxLZXk+IHtcbiAgY29uc3QgY29uc3RhbnRzID0gYXdhaXQgYml0Z28uZmV0Y2hDb25zdGFudHMoKTtcbiAgaWYgKCFjb25zdGFudHMudHJ1c3RQdWJLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgdHJ1c3RQdWJLZXknKTtcbiAgfVxuICByZXR1cm4gcmVhZEtleSh7IGFybW9yZWRLZXk6IGNvbnN0YW50cy50cnVzdFB1YktleSB9KTtcbn1cblxuLyoqXG4gKiBWZXJpZnkgYW4gRWRkc2Egb3IgRWNkc2EgS2V5U2hhcmUgUHJvb2YuXG4gKlxuICogQHBhcmFtIHNlbmRlclB1YktleSBwdWJsaWMga2V5IG9mIHRoZSBzZW5kZXIgb2YgdGhlIHByaXZhdGVTaGFyZVByb29mXG4gKiBAcGFyYW0gcHJpdmF0ZVNoYXJlUHJvb2YgdSB2YWx1ZSBwcm9vZlxuICogQHBhcmFtIHVWYWx1ZSB1IHZhbHVlIGZyb20gYW4gRWRkc2Ega2V5c2hhcmVcbiAqIEBwYXJhbSBhbGdvXG4gKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHVWYWx1ZSBwcm9vZiBhY3R1YWxseSB3YXMgc2lnbmVkIGJ5IHNlbmRlciBhcyBwYXJ0IG9mIHRoZWlyIHN1YmtleXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeVNoYXJlUHJvb2YoXG4gIHNlbmRlclB1YktleTogc3RyaW5nLFxuICBwcml2YXRlU2hhcmVQcm9vZjogc3RyaW5nLFxuICB1VmFsdWU6IHN0cmluZyxcbiAgYWxnbzogJ2VkZHNhJyB8ICdlY2RzYSdcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCBkZWNvZGVkUHJvb2YgPSBhd2FpdCBwZ3AucmVhZEtleSh7IGFybW9yZWRLZXk6IHByaXZhdGVTaGFyZVByb29mIH0pO1xuICBjb25zdCBzZW5kZXJHcGdLZXkgPSBhd2FpdCBwZ3AucmVhZEtleSh7IGFybW9yZWRLZXk6IHNlbmRlclB1YktleSB9KTtcbiAgaWYgKCEoYXdhaXQgdmVyaWZ5UHJpbWFyeVVzZXJXcmFwcGVyKGRlY29kZWRQcm9vZiwgc2VuZGVyR3BnS2V5LCB0cnVlKSlbMF0udmFsaWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcHJvb2ZTdWJrZXlzID0gZGVjb2RlZFByb29mLmdldFN1YmtleXMoKVsxXTtcbiAgaWYgKGFsZ28gPT09ICdlZGRzYScpIHtcbiAgICBjb25zdCBkZWNvZGVkVVZhbHVlUHJvb2YgPSBCdWZmZXIuZnJvbShwcm9vZlN1YmtleXMua2V5UGFja2V0LnB1YmxpY1BhcmFtc1snUSddLnNsaWNlKDEpKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgcmF3VVZhbHVlUHJvb2YgPSBCdWZmZXIuZnJvbShcbiAgICAgIHNvZGl1bS5jcnlwdG9fc2NhbGFybXVsdF9lZDI1NTE5X2Jhc2Vfbm9jbGFtcChCdWZmZXIuZnJvbSh1VmFsdWUsICdoZXgnKSlcbiAgICApLnRvU3RyaW5nKCdoZXgnKTtcbiAgICByZXR1cm4gZGVjb2RlZFVWYWx1ZVByb29mID09PSByYXdVVmFsdWVQcm9vZjtcbiAgfSBlbHNlIGlmIChhbGdvID09PSAnZWNkc2EnKSB7XG4gICAgY29uc3QgZGVjb2RlZFVWYWx1ZVByb29mID0gQnVmZmVyLmZyb20ocHJvb2ZTdWJrZXlzLmtleVBhY2tldC5wdWJsaWNQYXJhbXNbJ1EnXSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IHJhd1VWYWx1ZVByb29mID0gc2VjcDI1NmsxLnBvaW50RnJvbVNjYWxhcihCdWZmZXIuZnJvbSh1VmFsdWUsICdoZXgnKSwgZmFsc2UpO1xuICAgIHJldHVybiByYXdVVmFsdWVQcm9vZiAhPT0gbnVsbCAmJiBkZWNvZGVkVVZhbHVlUHJvb2YgPT09IEJ1ZmZlci5mcm9tKHJhd1VWYWx1ZVByb29mKS50b1N0cmluZygnaGV4Jyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFsZ29yaXRobSBwcm92aWRlZCcpO1xuICB9XG59XG5cbi8qKlxuICogVmVyaWZ5IGEgc2hhcmVkIGRhdGEgcHJvb2YuXG4gKlxuICogQHBhcmFtIHNlbmRlclB1YktleUFybSBwdWJsaWMga2V5IG9mIHRoZSBzaWduZXIgb2YgdGhlIGtleSB3aXRoIHByb29mIGRhdGFcbiAqIEBwYXJhbSBrZXlXaXRoTm90YXRpb24gc2lnbmVkIHJlY2lldmVyIGtleSB3aXRoIG5vdGF0aW9uIGRhdGFcbiAqIEBwYXJhbSBkYXRhVG9WZXJpZnkgZGF0YSB0byBiZSBjaGVja2VkIGFnYWluc3Qgbm90YXRpb24gZGF0YSBpbiB0aGUgc2lnbmVkIGtleVxuICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciBwcm9vZiBpcyB2YWxpZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5U2hhcmVkRGF0YVByb29mKFxuICBzZW5kZXJQdWJLZXlBcm06IHN0cmluZyxcbiAga2V5V2l0aE5vdGF0aW9uOiBzdHJpbmcsXG4gIGRhdGFUb1ZlcmlmeTogeyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBzdHJpbmcgfVtdXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3Qgc2VuZGVyUHViS2V5ID0gYXdhaXQgcGdwLnJlYWRLZXkoeyBhcm1vcmVkS2V5OiBzZW5kZXJQdWJLZXlBcm0gfSk7XG4gIGNvbnN0IHNpZ25lZEtleSA9IGF3YWl0IHBncC5yZWFkS2V5KHsgYXJtb3JlZEtleToga2V5V2l0aE5vdGF0aW9uIH0pO1xuICBpZiAoXG4gICAgIShhd2FpdCB2ZXJpZnlQcmltYXJ5VXNlcldyYXBwZXIoc2lnbmVkS2V5LCBzZW5kZXJQdWJLZXksIHRydWUpLnRoZW4oKHZhbHVlcykgPT5cbiAgICAgIF8uc29tZSh2YWx1ZXMsICh2YWx1ZSkgPT4gdmFsdWUudmFsaWQpXG4gICAgKSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHByaW1hcnlVc2VyID0gYXdhaXQgc2lnbmVkS2V5LmdldFByaW1hcnlVc2VyKCk7XG4gIGNvbnN0IGFueUludmFsaWRQcm9vZiA9IF8uc29tZShcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcHJpbWFyeVVzZXIudXNlci5vdGhlckNlcnRpZmljYXRpb25zWzBdLnJhd05vdGF0aW9ucyxcbiAgICAobm90YXRpb24pID0+IGRhdGFUb1ZlcmlmeS5maW5kKChpKSA9PiBpLm5hbWUgPT09IG5vdGF0aW9uLm5hbWUpPy52YWx1ZSAhPT0gQnVmZmVyLmZyb20obm90YXRpb24udmFsdWUpLnRvU3RyaW5nKClcbiAgKTtcbiAgcmV0dXJuICFhbnlJbnZhbGlkUHJvb2Y7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByb29mIHRocm91Z2ggYWRkaW5nIG5vdGF0aW9uIGRhdGEgdG8gYSBHUEcgY2VyaXRpZnlpbmcgc2lnbmF0dXJlLlxuICpcbiAqIEBwYXJhbSBwcml2YXRlS2V5QXJtb3JlZCBncGcgcHJpdmF0ZSBrZXkgaW4gYXJtb3IgZm9ybWF0IG9mIHRoZSBzZW5kZXJcbiAqIEBwYXJhbSBwdWJsaWNLZXlUb0NlcnRBcm1vcmVkIGdwZyBwdWJsaWMga2V5IGluIGFybW9yIGZvbXJhdCBvZiB0aGUgcmVjaWV2ZXJcbiAqIEBwYXJhbSBub3RhdGlvbnMgZGF0YSB0byBiZSBwcm9vZmVkXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGtleXNoYXJlIHByb29mXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVTaGFyZWREYXRhUHJvb2YoXG4gIHByaXZhdGVLZXlBcm1vcmVkOiBzdHJpbmcsXG4gIHB1YmxpY0tleVRvQ2VydEFybW9yZWQ6IHN0cmluZyxcbiAgbm90YXRpb25zOiB7IG5hbWU6IHN0cmluZzsgdmFsdWU6IHN0cmluZyB9W11cbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IGNlcnRpZnlpbmdLZXkgPSBhd2FpdCBwZ3AucmVhZEtleSh7IGFybW9yZWRLZXk6IHByaXZhdGVLZXlBcm1vcmVkIH0pO1xuICBjb25zdCBwdWJsaWNLZXlUb0NlcnQgPSBhd2FpdCBwZ3AucmVhZEtleSh7IGFybW9yZWRLZXk6IHB1YmxpY0tleVRvQ2VydEFybW9yZWQgfSk7XG4gIGNvbnN0IGRhdGVUaW1lID0gbmV3IERhdGUoKTtcbiAgLy8gVXNlcklkIFBhY2tldC5cbiAgY29uc3QgdXNlcklkUGt0ID0gbmV3IHBncC5Vc2VySURQYWNrZXQoKTtcbiAgY29uc3QgcHJpbWFyeVVzZXIgPSBhd2FpdCBwdWJsaWNLZXlUb0NlcnQuZ2V0UHJpbWFyeVVzZXIoKTtcbiAgLy8gQHRzLWlnbm9yZVxuICB1c2VySWRQa3QudXNlcklEID0gcHJpbWFyeVVzZXIudXNlci51c2VySUQudXNlcklEO1xuICAvLyBTaWduYXR1cmUgcGFja2V0LlxuICBjb25zdCBzaWduYXR1cmVQYWNrZXQgPSBuZXcgcGdwLlNpZ25hdHVyZVBhY2tldCgpO1xuICBzaWduYXR1cmVQYWNrZXQuc2lnbmF0dXJlVHlwZSA9IHBncC5lbnVtcy5zaWduYXR1cmUuY2VydFBvc2l0aXZlO1xuICBzaWduYXR1cmVQYWNrZXQucHVibGljS2V5QWxnb3JpdGhtID0gcGdwLmVudW1zLnB1YmxpY0tleS5lY2RzYTtcbiAgc2lnbmF0dXJlUGFja2V0Lmhhc2hBbGdvcml0aG0gPSBwZ3AuZW51bXMuaGFzaC5zaGEyNTY7XG4gIC8vIEB0cy1pZ25vcmVcbiAgc2lnbmF0dXJlUGFja2V0Lmlzc3VlckZpbmdlcnByaW50ID0gYXdhaXQgcHJpbWFyeVVzZXIudXNlci5tYWluS2V5LmtleVBhY2tldC5nZXRGaW5nZXJwcmludEJ5dGVzKCk7XG4gIC8vIEB0cy1pZ25vcmVcbiAgc2lnbmF0dXJlUGFja2V0Lmlzc3VlcktleUlEID0gcHJpbWFyeVVzZXIudXNlci5tYWluS2V5LmtleVBhY2tldC5rZXlJRDtcbiAgLy8gQHRzLWlnbm9yZVxuICBzaWduYXR1cmVQYWNrZXQuc2lnbmluZ0tleUlEID0gcHJpbWFyeVVzZXIudXNlci5tYWluS2V5LmtleVBhY2tldC5rZXlJRDtcbiAgLy8gQHRzLWlnbm9yZVxuICBzaWduYXR1cmVQYWNrZXQuc2lnbmVyc1VzZXJJRCA9IHByaW1hcnlVc2VyLnVzZXIudXNlcklELnVzZXJJRDtcbiAgLy8gQHRzLWlnbm9yZVxuICBzaWduYXR1cmVQYWNrZXQuZmVhdHVyZXMgPSBbMV07XG4gIG5vdGF0aW9ucy5mb3JFYWNoKCh7IG5hbWUsIHZhbHVlIH0pID0+IHtcbiAgICBzaWduYXR1cmVQYWNrZXQucmF3Tm90YXRpb25zLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbSh2YWx1ZSkpLFxuICAgICAgaHVtYW5SZWFkYWJsZTogdHJ1ZSxcbiAgICAgIGNyaXRpY2FsOiBmYWxzZSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gUHJlcGFyZSBzaWduaW5nIGRhdGEuXG4gIGNvbnN0IGtleWRhdGFUb1NpZ24gPSB7fTtcbiAgLy8gQHRzLWlnbm9yZVxuICBrZXlkYXRhVG9TaWduLmtleSA9IHB1YmxpY0tleVRvQ2VydC5rZXlQYWNrZXQ7XG4gIC8vIEB0cy1pZ25vcmVcbiAga2V5ZGF0YVRvU2lnbi51c2VySUQgPSB1c2VySWRQa3Q7XG5cbiAgLy8gU2lnbiB0aGUgZGF0YSAoY3JlYXRlIGNlcnRpZmljYXRpb24pLlxuICAvLyBAdHMtaWdub3JlXG4gIGF3YWl0IHNpZ25hdHVyZVBhY2tldC5zaWduKGNlcnRpZnlpbmdLZXkua2V5UGFja2V0LCBrZXlkYXRhVG9TaWduLCBkYXRlVGltZSk7XG5cbiAgLy8gQXNzZW1ibGUgcGFja2V0cyB0b2dldGhlci5cbiAgY29uc3QgcHVibGljS2V5VG9DZXJ0UGt0cyA9IHB1YmxpY0tleVRvQ2VydC50b1BhY2tldExpc3QoKTtcbiAgY29uc3QgbmV3S2V5UGt0TGlzdCA9IG5ldyBwZ3AuUGFja2V0TGlzdCgpO1xuICBuZXdLZXlQa3RMaXN0LnB1c2goLi4ucHVibGljS2V5VG9DZXJ0UGt0cy5zbGljZSgwLCAzKSwgc2lnbmF0dXJlUGFja2V0LCAuLi5wdWJsaWNLZXlUb0NlcnRQa3RzLnNsaWNlKDMpKTtcbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBuZXdQdWJLZXkgPSBuZXcgcGdwLlB1YmxpY0tleShuZXdLZXlQa3RMaXN0KTtcbiAgcmV0dXJuIG5ld1B1YktleS5hcm1vcigpLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIEtleVNoYXJlIFByb29mIGJhc2VkIG9uIGdpdmVuIGFsZ28uXG4gKlxuICogQ3JlYXRlcyBhbiBFZERTQSBLZXlTaGFyZSBQcm9vZiBieSBhcHBlbmRpbmcgYW4gZWQyNTUxOSBzdWJrZXkgKGF1dGgpIHRvIGFuIGFybW9yZWQgZ3BnIHByaXZhdGUga2V5LlxuICogQ3JlYXRlcyBhbiBFQ0RTQSBLZXlTaGFyZSBQcm9vZiBieSBBcHBlbmQgYSBzZWNwMjU2azEgc3Via2V5IChhdXRoKSB0byBhIFBHUCBrZXljaGFpbi5cbiAqXG4gKiBAcGFyYW0gcHJpdmF0ZUFybW9yIGdwZyBwcml2YXRlIGtleSBpbiBhcm1vciBmb3JtYXRcbiAqIEBwYXJhbSB1VmFsdWUgdSB2YWx1ZSBmcm9tIGFuIEVkZHNhIGtleXNoYXJlXG4gKiBAcGFyYW0gYWxnbyBhbGdvIHRvIHVzZSwgZWRkc2Egb3IgZWNkc2FcbiAqIEByZXR1cm4ge3N0cmluZ30ga2V5c2hhcmUgcHJvb2ZcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNoYXJlUHJvb2YocHJpdmF0ZUFybW9yOiBzdHJpbmcsIHVWYWx1ZTogc3RyaW5nLCBhbGdvOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBwcml2YXRlS2V5ID0gYXdhaXQgcmVhZEtleSh7IGFybW9yZWRLZXk6IHByaXZhdGVBcm1vciB9KTtcbiAgY29uc3QgZGF0ZVRpbWUgPSBuZXcgRGF0ZSgpO1xuICAvLyBAdHMtaWdub3JlIC0gdHlwZSBpbmNvbnNpc3RlbmN5LCB0aGlzIGN0b3Igc3VwcG9ydHMgYSBkYXRlIHBhcmFtOiBodHRwczovL2RvY3Mub3BlbnBncGpzLm9yZy9TZWNyZXRTdWJrZXlQYWNrZXQuaHRtbFxuICBjb25zdCBzZWNyZXRTdWJrZXlQYWNrZXQgPSBuZXcgcGdwLlNlY3JldFN1YmtleVBhY2tldChkYXRlVGltZSk7XG4gIHNlY3JldFN1YmtleVBhY2tldC5hbGdvcml0aG0gPSBwZ3AuZW51bXMucHVibGljS2V5W2FsZ29dO1xuICAvLyBAdHMtaWdub3JlIC0gc2FtZSBhcyBhYm92ZVxuICBzZWNyZXRTdWJrZXlQYWNrZXQuaXNFbmNyeXB0ZWQgPSBmYWxzZTtcbiAgbGV0IG9pZDtcbiAgbGV0IFE7XG4gIGlmIChhbGdvID09PSAnZWRkc2EnKSB7XG4gICAgYXdhaXQgc29kaXVtLnJlYWR5O1xuICAgIGNvbnN0IHN1YktleVZhbCA9IEJ1ZmZlci5mcm9tKFxuICAgICAgc29kaXVtLmNyeXB0b19zY2FsYXJtdWx0X2VkMjU1MTlfYmFzZV9ub2NsYW1wKEJ1ZmZlci5mcm9tKHVWYWx1ZSwgJ2hleCcpLCAndWludDhhcnJheScpXG4gICAgKTtcbiAgICAvLyBTdWIta2V5IChlbmNyeXB0aW9uIGtleSkgcGFja2V0LlxuICAgIG9pZCA9IFsweDJiLCAweDA2LCAweDAxLCAweDA0LCAweDAxLCAweGRhLCAweDQ3LCAweDBmLCAweDAxXTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgb2lkLndyaXRlID0gKCkgPT4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20oJzA5MmIwNjAxMDQwMWRhNDcwZjAxJywgJ2hleCcpKTtcbiAgICBRID0gbmV3IFVpbnQ4QXJyYXkoWzB4NDAsIC4uLnN1YktleVZhbF0pO1xuICB9IGVsc2UgaWYgKGFsZ28gPT09ICdlY2RzYScpIHtcbiAgICBvaWQgPSBbMHgyYiwgMHg4MSwgMHgwNCwgMHgwMCwgMHgwYV07XG4gICAgLy8gQHRzLWlnbm9yZSAtIHNhbWUgYXMgYWJvdmVcbiAgICBvaWQud3JpdGUgPSAoKSA9PiBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbSgnMDUyYjgxMDQwMDBhJywgJ2hleCcpKTtcbiAgICBRID0gc2VjcDI1NmsxLnBvaW50RnJvbVNjYWxhcihuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbSh1VmFsdWUsICdoZXgnKSksIGZhbHNlKTtcbiAgfVxuICBzZWNyZXRTdWJrZXlQYWNrZXQucHVibGljUGFyYW1zID0ge1xuICAgIG9pZCxcbiAgICBRLFxuICB9O1xuICAvLyBAdHMtaWdub3JlIC0gc2FtZSBhcyBhYm92ZVxuICBhd2FpdCBzZWNyZXRTdWJrZXlQYWNrZXQuY29tcHV0ZUZpbmdlcnByaW50QW5kS2V5SUQoKTtcblxuICAvLyBTdWIta2V5IHNpZ25hdHVyZSBwYWNrZXQuXG4gIGNvbnN0IHN1YktleWRhdGFUb1NpZ24gPSB7XG4gICAga2V5OiBwcml2YXRlS2V5LmtleVBhY2tldCxcbiAgICBiaW5kOiBzZWNyZXRTdWJrZXlQYWNrZXQsXG4gIH07XG4gIGNvbnN0IHN1YmtleVNpZ25hdHVyZVBhY2tldCA9IG5ldyBwZ3AuU2lnbmF0dXJlUGFja2V0KCk7XG4gIHN1YmtleVNpZ25hdHVyZVBhY2tldC5zaWduYXR1cmVUeXBlID0gcGdwLmVudW1zLnNpZ25hdHVyZS5zdWJrZXlCaW5kaW5nO1xuICBzdWJrZXlTaWduYXR1cmVQYWNrZXQucHVibGljS2V5QWxnb3JpdGhtID0gcGdwLmVudW1zLnB1YmxpY0tleS5lY2RzYTtcbiAgc3Via2V5U2lnbmF0dXJlUGFja2V0Lmhhc2hBbGdvcml0aG0gPSBwZ3AuZW51bXMuaGFzaC5zaGEyNTY7XG4gIHN1YmtleVNpZ25hdHVyZVBhY2tldC5rZXlGbGFncyA9IG5ldyBVaW50OEFycmF5KFtwZ3AuZW51bXMua2V5RmxhZ3MuYXV0aGVudGljYXRpb25dKTtcblxuICAvLyBTaWduIHRoZSBzdWJrZXlcbiAgLy8gQHRzLWlnbm9yZSAtIHNpZ24gc3VwcG9ydHMgYXJiaXRyYXJ5IGRhdGEgZm9yIDJuZCBwYXJhbTogaHR0cHM6Ly9kb2NzLm9wZW5wZ3Bqcy5vcmcvU2lnbmF0dXJlUGFja2V0Lmh0bWxcbiAgYXdhaXQgc3Via2V5U2lnbmF0dXJlUGFja2V0LnNpZ24ocHJpdmF0ZUtleS5rZXlQYWNrZXQsIHN1YktleWRhdGFUb1NpZ24sIGRhdGVUaW1lKTtcblxuICAvLyBBc3NlbWJsZSBwYWNrZXRzIHRvZ2V0aGVyLlxuICBjb25zdCBuZXdLZXlQa3RMaXN0ID0gbmV3IHBncC5QYWNrZXRMaXN0KCk7XG4gIGNvbnN0IHByaXZhdGVLZXlQa3RzID0gcHJpdmF0ZUtleS50b1BhY2tldExpc3QoKTtcbiAgcHJpdmF0ZUtleVBrdHMuZm9yRWFjaCgocGFja2V0KSA9PiBuZXdLZXlQa3RMaXN0LnB1c2gocGFja2V0KSk7XG4gIG5ld0tleVBrdExpc3QucHVzaChzZWNyZXRTdWJrZXlQYWNrZXQsIHN1YmtleVNpZ25hdHVyZVBhY2tldCk7XG4gIC8vIEB0cy1pZ25vcmUgLSBzdXBwb3J0cyBwYWNrZXQgbGlzdCBhcyBjdG9yIHBhcmFtOiBodHRwczovL2RvY3Mub3BlbnBncGpzLm9yZy9Qcml2YXRlS2V5Lmh0bWxcbiAgY29uc3QgbmV3UHViS2V5ID0gbmV3IHBncC5Qcml2YXRlS2V5KG5ld0tleVBrdExpc3QpLnRvUHVibGljKCk7XG5cbiAgaWYgKCEoYXdhaXQgdmVyaWZ5UHJpbWFyeVVzZXJXcmFwcGVyKG5ld1B1YktleSwgcHJpdmF0ZUtleSwgdHJ1ZSkpWzBdLnZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3Qgc2lnbmF0dXJlJyk7XG4gIH1cblxuICByZXR1cm4gbmV3UHViS2V5LmFybW9yKCkucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKTtcbn1cblxuLyoqXG4gKiBFbmNyeXB0cyBzdHJpbmcgdXNpbmcgZ3BnIGtleVxuICogQERFUFJFQ0FURUQgLSBzaG91bGQgdXNlIGVuY3J5cHRBbmRTaWduVGV4dCBpbnN0ZWFkIGZvciBhZGRlZCBzZWN1cml0eVxuICpcbiAqIEBwYXJhbSB0ZXh0IHN0cmluZyB0byBlbmNyeXB0XG4gKiBAcGFyYW0ga2V5IGVuY3J5cHRpb24ga2V5XG4gKiBAcmV0dXJuIHtzdHJpbmd9IGVuY3J5cHRlZCBzdHJpbmdcbiAqXG4gKiBUT0RPKEJHLTQ3MTcwKTogRGVsZXRlIG9uY2UgZ3BnIHNpZ25hdHVyZXMgYXJlIGZ1bGx5IHN1cHBvcnRlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdFRleHQodGV4dDogc3RyaW5nLCBrZXk6IEtleSk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IG1lc3NhZ2VUb0VuY3J5cHQgPSBhd2FpdCBjcmVhdGVNZXNzYWdlKHtcbiAgICB0ZXh0LFxuICB9KTtcbiAgcmV0dXJuIGF3YWl0IGVuY3J5cHQoe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2VUb0VuY3J5cHQsXG4gICAgZW5jcnlwdGlvbktleXM6IFtrZXldLFxuICAgIGZvcm1hdDogJ2FybW9yZWQnLFxuICAgIGNvbmZpZzoge1xuICAgICAgcmVqZWN0Q3VydmVzOiBuZXcgU2V0KCksXG4gICAgICBzaG93VmVyc2lvbjogZmFsc2UsXG4gICAgICBzaG93Q29tbWVudDogZmFsc2UsXG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogRW5jcnlwdHMgYW5kIHNpZ25zIGEgc3RyaW5nXG4gKiBAcGFyYW0gdGV4dCBzdHJpbmcgdG8gZW5jcnlwdCBhbmQgc2lnblxuICogQHBhcmFtIHB1YmxpY0FybW9yIHB1YmxpYyBrZXkgdG8gZW5jcnlwdCB3aXRoXG4gKiBAcGFyYW0gcHJpdmF0ZUFybW9yIHByaXZhdGUga2V5IHRvIHNpZ24gd2l0aFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdEFuZFNpZ25UZXh0KHRleHQ6IHN0cmluZywgcHVibGljQXJtb3I6IHN0cmluZywgcHJpdmF0ZUFybW9yOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBwdWJsaWNLZXkgPSBhd2FpdCByZWFkS2V5KHsgYXJtb3JlZEtleTogcHVibGljQXJtb3IgfSk7XG4gIGNvbnN0IHByaXZhdGVLZXkgPSBhd2FpdCByZWFkUHJpdmF0ZUtleSh7IGFybW9yZWRLZXk6IHByaXZhdGVBcm1vciB9KTtcblxuICBjb25zdCBtZXNzYWdlID0gYXdhaXQgY3JlYXRlTWVzc2FnZSh7IHRleHQgfSk7XG5cbiAgY29uc3Qgc2lnbmVkTWVzc2FnZSA9IGF3YWl0IGVuY3J5cHQoe1xuICAgIG1lc3NhZ2UsXG4gICAgZW5jcnlwdGlvbktleXM6IHB1YmxpY0tleSxcbiAgICBzaWduaW5nS2V5czogcHJpdmF0ZUtleSxcbiAgICBmb3JtYXQ6ICdhcm1vcmVkJyxcbiAgICBjb25maWc6IHtcbiAgICAgIHJlamVjdEN1cnZlczogbmV3IFNldCgpLFxuICAgICAgc2hvd1ZlcnNpb246IGZhbHNlLFxuICAgICAgc2hvd0NvbW1lbnQ6IGZhbHNlLFxuICAgIH0sXG4gIH0pO1xuXG4gIHJldHVybiBzaWduZWRNZXNzYWdlO1xufVxuXG4vKipcbiAqIFJlYWRzIGEgc2lnbmVkIGFuZCBlbmNyeXB0ZWQgbWVzc2FnZVxuICpcbiAqIEBwYXJhbSBzaWduZWQgc2lnbmVkIGFuZCBlbmNyeXB0ZWQgbWVzc2FnZVxuICogQHBhcmFtIHB1YmxpY0FybW9yIHB1YmxpYyBrZXkgdG8gdmVyaWZ5IHNpZ25hdHVyZVxuICogQHBhcmFtIHByaXZhdGVBcm1vciBwcml2YXRlIGtleSB0byBkZWNyeXB0IG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWRTaWduZWRNZXNzYWdlKHNpZ25lZDogc3RyaW5nLCBwdWJsaWNBcm1vcjogc3RyaW5nLCBwcml2YXRlQXJtb3I6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IHJlYWRLZXkoeyBhcm1vcmVkS2V5OiBwdWJsaWNBcm1vciB9KTtcbiAgY29uc3QgcHJpdmF0ZUtleSA9IGF3YWl0IHJlYWRQcml2YXRlS2V5KHsgYXJtb3JlZEtleTogcHJpdmF0ZUFybW9yIH0pO1xuXG4gIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCByZWFkTWVzc2FnZSh7IGFybW9yZWRNZXNzYWdlOiBzaWduZWQgfSk7XG4gIGNvbnN0IGRlY3J5cHRlZCA9IGF3YWl0IGRlY3J5cHQoe1xuICAgIG1lc3NhZ2UsXG4gICAgdmVyaWZpY2F0aW9uS2V5czogcHVibGljS2V5LFxuICAgIGRlY3J5cHRpb25LZXlzOiBwcml2YXRlS2V5LFxuICAgIGV4cGVjdFNpZ25lZDogdHJ1ZSxcbiAgICBjb25maWc6IHsgcmVqZWN0Q3VydmVzOiBuZXcgU2V0KCkgfSxcbiAgfSk7XG5cbiAgcmV0dXJuIGRlY3J5cHRlZC5kYXRhO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHNpZ25hdHVyZVxuICpcbiAqIEBwYXJhbSB0ZXh0IHN0cmluZyB0byBnZW5lcmF0ZSBhIHNpZ25hdHVyZSBmb3JcbiAqIEBwYXJhbSBwcml2YXRlQXJtb3IgcHJpdmF0ZSBrZXkgYXMgYXJtb3JlZCBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ30gYXJtb3JlZCBzaWduYXR1cmUgc3RyaW5nXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduVGV4dCh0ZXh0OiBzdHJpbmcsIHByaXZhdGVBcm1vcjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgcHJpdmF0ZUtleSA9IGF3YWl0IHJlYWRQcml2YXRlS2V5KHsgYXJtb3JlZEtleTogcHJpdmF0ZUFybW9yIH0pO1xuICBjb25zdCBtZXNzYWdlID0gYXdhaXQgY3JlYXRlTWVzc2FnZSh7IHRleHQgfSk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ24oe1xuICAgIG1lc3NhZ2UsXG4gICAgc2lnbmluZ0tleXM6IHByaXZhdGVLZXksXG4gICAgZm9ybWF0OiAnYXJtb3JlZCcsXG4gICAgZGV0YWNoZWQ6IHRydWUsXG4gIH0pO1xuXG4gIHJldHVybiBzaWduYXR1cmU7XG59XG5cbi8qKlxuICogVmVyaWZpZXMgc2lnbmF0dXJlIHdhcyBnZW5lcmF0ZWQgYnkgdGhlIHB1YmxpYyBrZXkgYW5kIG1hdGNoZXMgdGhlIGV4cGVjdGVkIHRleHRcbiAqXG4gKiBAcGFyYW0gdGV4dCB0ZXh0IHRoYXQgdGhlIHNpZ25hdHVyZSB3YXMgZm9yXG4gKiBAcGFyYW0gYXJtb3JlZFNpZ25hdHVyZSBzaWduZWQgbWVzc2FnZSBhcyBhbiBhcm1vcmVkIHN0cmluZ1xuICogQHBhcmFtIHB1YmxpY0FybW9yIHB1YmxpYyBrZXkgdGhhdCBnZW5lcmF0ZWQgdGhlIHNpZ25hdHVyZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlKHRleHQ6IHN0cmluZywgYXJtb3JlZFNpZ25hdHVyZTogc3RyaW5nLCBwdWJsaWNBcm1vcjogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IHJlYWRLZXkoeyBhcm1vcmVkS2V5OiBwdWJsaWNBcm1vciB9KTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgcmVhZFNpZ25hdHVyZSh7IGFybW9yZWRTaWduYXR1cmUgfSk7XG4gIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCBjcmVhdGVNZXNzYWdlKHsgdGV4dCB9KTtcbiAgY29uc3QgdmVyaWZpY2F0aW9uUmVzdWx0ID0gYXdhaXQgdmVyaWZ5KHtcbiAgICBtZXNzYWdlLFxuICAgIHNpZ25hdHVyZSxcbiAgICB2ZXJpZmljYXRpb25LZXlzOiBwdWJsaWNLZXksXG4gIH0pO1xuXG4gIGlmICh2ZXJpZmljYXRpb25SZXN1bHQuc2lnbmF0dXJlcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIHNpZ25hdHVyZXMnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYXdhaXQgdmVyaWZpY2F0aW9uUmVzdWx0LnNpZ25hdHVyZXNbMF0udmVyaWZpZWQ7XG4gICAgcmV0dXJuIHRleHQgPT09IHZlcmlmaWNhdGlvblJlc3VsdC5kYXRhO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIEdQRyBrZXkgcGFpclxuICpcbiAqIEBwYXJhbToga2V5Q3VydmUgdGhlIGN1cnZlIHRvIGNyZWF0ZSBhIGtleSB3aXRoXG4gKiBAcGFyYW06IHVzZXJuYW1lIG5hbWUgb2YgdGhlIHVzZXIgKG9wdGlvbmFsKVxuICogQHBhcmFtOiBlbWFpbCBlbWFpbCBvZiB0aGUgdXNlciAob3B0aW9uYWwpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUdQR0tleVBhaXIoXG4gIGtleUN1cnZlOiBwZ3AuRWxsaXB0aWNDdXJ2ZU5hbWUsXG4gIHVzZXJuYW1lPzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBlbWFpbD86IHN0cmluZyB8IHVuZGVmaW5lZFxuKTogUHJvbWlzZTxwZ3AuU2VyaWFsaXplZEtleVBhaXI8c3RyaW5nPj4ge1xuICBjb25zdCByYW5kb21IZXhTdHJpbmcgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTIpLnRvU3RyaW5nKCdoZXgnKTtcbiAgdXNlcm5hbWUgPSB1c2VybmFtZSA/PyByYW5kb21IZXhTdHJpbmc7XG4gIGVtYWlsID0gZW1haWwgPz8gYHVzZXItJHtyYW5kb21IZXhTdHJpbmd9QCR7cmFuZG9tSGV4U3RyaW5nfS5jb21gO1xuXG4gIC8vIEFsbG93IGdlbmVyYXRpbmcgc2VjcDI1NmsxIGtleSBwYWlyc1xuICBwZ3AuY29uZmlnLnJlamVjdEN1cnZlcyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgZ3BnS2V5ID0gYXdhaXQgcGdwLmdlbmVyYXRlS2V5KHtcbiAgICB1c2VySURzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IHVzZXJuYW1lLFxuICAgICAgICBlbWFpbCxcbiAgICAgIH0sXG4gICAgXSxcbiAgICBjdXJ2ZToga2V5Q3VydmUsXG4gIH0pO1xuXG4gIHJldHVybiBncGdLZXk7XG59XG4iXX0=