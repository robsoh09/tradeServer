"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeOrElse = exports.decode = exports.validationErrors = void 0;
const function_1 = require("fp-ts/function");
const E = __importStar(require("fp-ts/Either"));
const Json = __importStar(require("fp-ts/Json"));
const O = __importStar(require("fp-ts/Option"));
const NEA = __importStar(require("fp-ts/ReadonlyNonEmptyArray"));
/**
 * Format an `Errors` object as a human-readable `string`. See `decode` in `decode.ts` for an example.
 * Inspired by
 * https://github.com/mmkal/ts/blob/94a9ba8f2931c9c91122d00b0bf1bd21b2be05cd/packages/io-ts-extra/src/reporters.ts#L11.
 */
const validationErrors = (typeAlias) => (errors) => {
    return errors
        .map((error) => (0, function_1.pipe)(NEA.fromReadonlyArray(error.context), O.map((context) => {
        const name = typeAlias || NEA.head(context).type.name;
        const lastType = NEA.last(context).type.name;
        const path = name + error.context.map((c) => c.key).join('.');
        return (0, function_1.pipe)(Json.stringify(error.value), E.getOrElse(() => error.value), (value) => `Invalid value '${value}' supplied to ${path}, expected ${lastType}.`);
    }), O.getOrElse(() => `Unable to decode ${typeAlias}, but no error reported`)))
        .join('\n');
};
exports.validationErrors = validationErrors;
function decode(codecName, codec, u) {
    return (0, function_1.pipe)(codec.decode(u), E.mapLeft((errors) => (0, exports.validationErrors)(codecName)(errors)));
}
exports.decode = decode;
/**
 * Decodes input `value` with `codec`. When decoding fails, calls the `orElse` function with the error message from
 * `validationErrors`.
 */
function decodeOrElse(codecName, codec, value, orElse) {
    return (0, function_1.pipe)(decode(codecName, codec, value), E.getOrElseW(orElse));
}
exports.decodeOrElse = decodeOrElse;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjb2RlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2JpdGdvL3V0aWxzL2RlY29kZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZDQUFzQztBQUN0QyxnREFBa0M7QUFDbEMsaURBQW1DO0FBQ25DLGdEQUFrQztBQUNsQyxpRUFBbUQ7QUFHbkQ7Ozs7R0FJRztBQUNJLE1BQU0sZ0JBQWdCLEdBQzNCLENBQUMsU0FBaUIsRUFBRSxFQUFFLENBQ3RCLENBQUMsTUFBZ0IsRUFBVSxFQUFFO0lBQzNCLE9BQU8sTUFBTTtTQUNWLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQ2IsSUFBQSxlQUFJLEVBQ0YsR0FBRyxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFDcEMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFO1FBQ2hCLE1BQU0sSUFBSSxHQUFHLFNBQVMsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDdEQsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQzdDLE1BQU0sSUFBSSxHQUFHLElBQUksR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM5RCxPQUFPLElBQUEsZUFBSSxFQUNULElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUMzQixDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFDOUIsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixLQUFLLGlCQUFpQixJQUFJLGNBQWMsUUFBUSxHQUFHLENBQ2pGLENBQUM7SUFDSixDQUFDLENBQUMsRUFDRixDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLG9CQUFvQixTQUFTLHlCQUF5QixDQUFDLENBQzFFLENBQ0Y7U0FDQSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDaEIsQ0FBQyxDQUFDO0FBckJTLFFBQUEsZ0JBQWdCLG9CQXFCekI7QUFFSixTQUFnQixNQUFNLENBQVUsU0FBaUIsRUFBRSxLQUFzQixFQUFFLENBQUk7SUFDN0UsT0FBTyxJQUFBLGVBQUksRUFDVCxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUNmLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLElBQUEsd0JBQWdCLEVBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FDM0QsQ0FBQztBQUNKLENBQUM7QUFMRCx3QkFLQztBQUVEOzs7R0FHRztBQUNILFNBQWdCLFlBQVksQ0FDMUIsU0FBaUIsRUFDakIsS0FBc0IsRUFDdEIsS0FBUSxFQUNSLE1BQTZCO0lBRTdCLE9BQU8sSUFBQSxlQUFJLEVBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3JFLENBQUM7QUFQRCxvQ0FPQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBpcGUgfSBmcm9tICdmcC10cy9mdW5jdGlvbic7XG5pbXBvcnQgKiBhcyBFIGZyb20gJ2ZwLXRzL0VpdGhlcic7XG5pbXBvcnQgKiBhcyBKc29uIGZyb20gJ2ZwLXRzL0pzb24nO1xuaW1wb3J0ICogYXMgTyBmcm9tICdmcC10cy9PcHRpb24nO1xuaW1wb3J0ICogYXMgTkVBIGZyb20gJ2ZwLXRzL1JlYWRvbmx5Tm9uRW1wdHlBcnJheSc7XG5pbXBvcnQgKiBhcyB0IGZyb20gJ2lvLXRzJztcblxuLyoqXG4gKiBGb3JtYXQgYW4gYEVycm9yc2Agb2JqZWN0IGFzIGEgaHVtYW4tcmVhZGFibGUgYHN0cmluZ2AuIFNlZSBgZGVjb2RlYCBpbiBgZGVjb2RlLnRzYCBmb3IgYW4gZXhhbXBsZS5cbiAqIEluc3BpcmVkIGJ5XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbW1rYWwvdHMvYmxvYi85NGE5YmE4ZjI5MzFjOWM5MTEyMmQwMGIwYmYxYmQyMWIyYmUwNWNkL3BhY2thZ2VzL2lvLXRzLWV4dHJhL3NyYy9yZXBvcnRlcnMudHMjTDExLlxuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGlvbkVycm9ycyA9XG4gICh0eXBlQWxpYXM6IHN0cmluZykgPT5cbiAgKGVycm9yczogdC5FcnJvcnMpOiBzdHJpbmcgPT4ge1xuICAgIHJldHVybiBlcnJvcnNcbiAgICAgIC5tYXAoKGVycm9yKSA9PlxuICAgICAgICBwaXBlKFxuICAgICAgICAgIE5FQS5mcm9tUmVhZG9ubHlBcnJheShlcnJvci5jb250ZXh0KSxcbiAgICAgICAgICBPLm1hcCgoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHR5cGVBbGlhcyB8fCBORUEuaGVhZChjb250ZXh0KS50eXBlLm5hbWU7XG4gICAgICAgICAgICBjb25zdCBsYXN0VHlwZSA9IE5FQS5sYXN0KGNvbnRleHQpLnR5cGUubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBuYW1lICsgZXJyb3IuY29udGV4dC5tYXAoKGMpID0+IGMua2V5KS5qb2luKCcuJyk7XG4gICAgICAgICAgICByZXR1cm4gcGlwZShcbiAgICAgICAgICAgICAgSnNvbi5zdHJpbmdpZnkoZXJyb3IudmFsdWUpLFxuICAgICAgICAgICAgICBFLmdldE9yRWxzZSgoKSA9PiBlcnJvci52YWx1ZSksXG4gICAgICAgICAgICAgICh2YWx1ZSkgPT4gYEludmFsaWQgdmFsdWUgJyR7dmFsdWV9JyBzdXBwbGllZCB0byAke3BhdGh9LCBleHBlY3RlZCAke2xhc3RUeXBlfS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIE8uZ2V0T3JFbHNlKCgpID0+IGBVbmFibGUgdG8gZGVjb2RlICR7dHlwZUFsaWFzfSwgYnV0IG5vIGVycm9yIHJlcG9ydGVkYClcbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgLmpvaW4oJ1xcbicpO1xuICB9O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlPEEsIE8sIEk+KGNvZGVjTmFtZTogc3RyaW5nLCBjb2RlYzogdC5UeXBlPEEsIE8sIEk+LCB1OiBJKTogRS5FaXRoZXI8c3RyaW5nLCBBPiB7XG4gIHJldHVybiBwaXBlKFxuICAgIGNvZGVjLmRlY29kZSh1KSxcbiAgICBFLm1hcExlZnQoKGVycm9ycykgPT4gdmFsaWRhdGlvbkVycm9ycyhjb2RlY05hbWUpKGVycm9ycykpXG4gICk7XG59XG5cbi8qKlxuICogRGVjb2RlcyBpbnB1dCBgdmFsdWVgIHdpdGggYGNvZGVjYC4gV2hlbiBkZWNvZGluZyBmYWlscywgY2FsbHMgdGhlIGBvckVsc2VgIGZ1bmN0aW9uIHdpdGggdGhlIGVycm9yIG1lc3NhZ2UgZnJvbVxuICogYHZhbGlkYXRpb25FcnJvcnNgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlT3JFbHNlPEEsIE8sIEksIEU+KFxuICBjb2RlY05hbWU6IHN0cmluZyxcbiAgY29kZWM6IHQuVHlwZTxBLCBPLCBJPixcbiAgdmFsdWU6IEksXG4gIG9yRWxzZTogKGVycm9yczogc3RyaW5nKSA9PiBFXG4pOiBFIHwgQSB7XG4gIHJldHVybiBwaXBlKGRlY29kZShjb2RlY05hbWUsIGNvZGVjLCB2YWx1ZSksIEUuZ2V0T3JFbHNlVyhvckVsc2UpKTtcbn1cbiJdfQ==