"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const openpgp_1 = require("openpgp");
const tss_1 = require("../../tss");
const mpcUtils_1 = require("../mpcUtils");
const _ = __importStar(require("lodash"));
const util_1 = require("../util");
/**
 * BaseTssUtil class which different signature schemes have to extend
 */
class BaseTssUtils extends mpcUtils_1.MpcUtils {
    constructor(bitgo, baseCoin, wallet) {
        super(bitgo, baseCoin);
        this._wallet = wallet;
    }
    get wallet() {
        if (_.isNil(this._wallet)) {
            throw new Error('Wallet not defined');
        }
        return this._wallet;
    }
    async createBitgoHeldBackupKeyShare(userGpgKey, enterprise) {
        const keyResponse = await this.bitgo
            .post(this.baseCoin.url('/krs/backupkeys'))
            .send({
            enterprise,
            userGPGPublicKey: userGpgKey.publicKey,
        })
            .result();
        if (!keyResponse || !keyResponse.keyShares) {
            throw new Error('Failed to get backup shares from BitGo.');
        }
        return {
            id: keyResponse.id,
            keyShares: keyResponse.keyShares,
        };
    }
    finalizeBitgoHeldBackupKeyShare(keyId, commonKeychain, userKeyShare, bitgoKeychain, userGpgKey, backupGpgKey) {
        throw new Error('Method not implemented.');
    }
    createUserKeychain(params) {
        throw new Error('Method not implemented.');
    }
    createBackupKeychain(params) {
        throw new Error('Method not implemented.');
    }
    createBitgoKeychain(params) {
        throw new Error('Method not implemented.');
    }
    createKeychains(params) {
        throw new Error('Method not implemented.');
    }
    signTxRequest(params) {
        throw new Error('Method not implemented.');
    }
    signTxRequestForMessage(params) {
        throw new Error('Method not implemented.');
    }
    /**
     * Signs a transaction using TSS for EdDSA and through utilization of custom share generators
     *
     * @param {string | TxRequest} txRequest - transaction request with unsigned transaction
     * @param {CustomRShareGeneratingFunction} externalSignerRShareGenerator a function that creates R shares in the EdDSA TSS flow
     * @param {CustomGShareGeneratingFunction} externalSignerGShareGenerator a function that creates G shares in the EdDSA TSS flow
     * @returns {Promise<TxRequest>} - a signed tx request
     */
    signEddsaTssUsingExternalSigner(txRequest, externalSignerCommitmentGenerator, externalSignerRShareGenerator, externalSignerGShareGenerator) {
        throw new Error('Method not implemented.');
    }
    /**
     * Signs a transaction using TSS for ECDSA and through utilization of custom share generators
     *
     * @param {params: TSSParams | TSSParamsForMessage} params - params object that represents parameters to sign a transaction or a message.
     * @param {RequestType} requestType - the type of the request to sign (transaction or message).
     * @param {CustomPaillierModulusGetterFunction} externalSignerPaillierModulusGetter a function that creates Paillier Modulus shares in the ECDSA TSS flow.
     * @param {CustomKShareGeneratingFunction} externalSignerKShareGenerator a function that creates K shares in the ECDSA TSS flow.
     * @param {CustomMuDeltaShareGeneratingFunction} externalSignerMuDeltaShareGenerator a function that creates Mu and Delta shares in the ECDSA TSS flow.
     * @param {CustomSShareGeneratingFunction} externalSignerSShareGenerator a function that creates S shares in the ECDSA TSS flow.
     */
    signEcdsaTssUsingExternalSigner(params, requestType, externalSignerPaillierModulusGetter, externalSignerKShareGenerator, externalSignerMuDeltaShareGenerator, externalSignerSShareGenerator) {
        throw new Error('Method not implemented.');
    }
    /**
     * Create an Commitment (User to BitGo) share from an unsigned transaction and private user signing material
     * EDDSA only
     *
     * @param {Object} params - params object
     * @param {TxRequest} params.txRequest - transaction request with unsigned transaction
     * @param {string} params.prv - user signing material
     * @param {string} params.walletPassphrase - wallet passphrase
     *
     * @returns {Promise<{ userToBitgoCommitment: CommitmentShareRecor, encryptedSignerShare: EncryptedSignerShareRecord }>} - Commitment Share and the Encrypted Signer Share to BitGo
     */
    createCommitmentShareFromTxRequest(params) {
        throw new Error('Method not implemented.');
    }
    /**
     * Create an R (User to BitGo) share from an unsigned transaction and private user signing material
     *
     * @param {Object} params - params object
     * @param {TxRequest} params.txRequest - transaction request with unsigned transaction
     * @param {string} params.prv - user signing material
     * @param {string} [params.walletPassphrase] - wallet passphrase
     * @param {EncryptedSignerShareRecord} [params.encryptedUserToBitgoRShare] - encrypted user to bitgo R share generated in the commitment phase
     * @returns {Promise<{ rShare: SignShare }>} - R Share to BitGo
     */
    createRShareFromTxRequest(params) {
        throw new Error('Method not implemented.');
    }
    /**
     * Create a G (User to BitGo) share from an unsigned transaction and private user signing material
     *
     * @param {Object} params - params object
     * @param {TxRequest} params.txRequest - transaction request with unsigned transaction
     * @param {string} params.prv - user signing material
     * @param {SignatureShareRecord} params.bitgoToUserRShare - BitGo to User R Share
     * @param {SignShare} params.userToBitgoRShare - User to BitGo R Share
     * @param {CommitmentShareRecord} params.bitgoToUserCommitment - BitGo to User Commitment
     * @returns {Promise<GShare>} - GShare from User to BitGo
     */
    createGShareFromTxRequest(params) {
        throw new Error('Method not implemented.');
    }
    /**
     * Builds a tx request from params and verify it
     *
     * @param {PrebuildTransactionWithIntentOptions} params - parameters to build the tx
     * @param {TxRequestVersion} apiVersion lite or full
     * @param {boolean} preview boolean indicating if this is to preview a tx request, which will not initiate policy checks or pending approvals
     * @returns {Promise<TxRequest>} - a built tx request
     */
    async prebuildTxWithIntent(params, apiVersion = 'lite', preview) {
        const intentOptions = this.populateIntent(this.baseCoin, params);
        const whitelistedParams = {
            intent: {
                ...intentOptions,
            },
            apiVersion: apiVersion,
            preview,
        };
        const unsignedTx = (await this.bitgo
            .post(this.bitgo.url('/wallet/' + this.wallet.id() + '/txrequests', 2))
            .send(whitelistedParams)
            .result());
        return unsignedTx;
    }
    /**
     * Create a tx request from params for message signing
     *
     * @param params
     * @param apiVersion
     * @param preview
     */
    async createTxRequestWithIntentForMessageSigning(params, apiVersion = 'full', preview) {
        var _a, _b;
        const intentOptions = {
            custodianMessageId: params.custodianMessageId,
            intentType: params.intentType,
            sequenceId: params.sequenceId,
            comment: params.comment,
            memo: (_a = params.memo) === null || _a === void 0 ? void 0 : _a.value,
            isTss: params.isTss,
            messageRaw: params.messageRaw,
            messageEncoded: (_b = params.messageEncoded) !== null && _b !== void 0 ? _b : '',
        };
        return this.createTxRequestBase(intentOptions, apiVersion, preview);
    }
    /**
     * Create a tx request from params for type data signing
     *
     * @param params
     * @param apiVersion
     * @param preview
     */
    async createTxRequestWithIntentForTypedDataSigning(params, apiVersion = 'full', preview) {
        var _a, _b;
        const intentOptions = {
            custodianMessageId: params.custodianMessageId,
            intentType: params.intentType,
            sequenceId: params.sequenceId,
            comment: params.comment,
            memo: (_a = params.memo) === null || _a === void 0 ? void 0 : _a.value,
            isTss: params.isTss,
            messageRaw: params.typedDataRaw,
            messageEncoded: (_b = params.typedDataEncoded) !== null && _b !== void 0 ? _b : '',
        };
        return this.createTxRequestBase(intentOptions, apiVersion, preview);
    }
    /**
     * Calls Bitgo API to create tx request.
     *
     * @private
     */
    async createTxRequestBase(intentOptions, apiVersion, preview) {
        const whitelistedParams = {
            intent: {
                ...intentOptions,
            },
            apiVersion,
            preview,
        };
        return this.bitgo
            .post(this.bitgo.url(`/wallet/${this.wallet.id()}/txrequests`, 2))
            .send(whitelistedParams)
            .result();
    }
    /**
     * Call delete signature shares for a txRequest, the endpoint delete the signatures and return them
     *
     * @param {string} txRequestId tx id reference to delete signature shares
     * @param {IRequestTracer} reqId - the request tracer request id
     * @returns {SignatureShareRecord[]}
     */
    async deleteSignatureShares(txRequestId, reqId) {
        const reqTracer = reqId || new util_1.RequestTracer();
        this.bitgo.setRequestTracer(reqTracer);
        return this.bitgo
            .del(this.bitgo.url(`/wallet/${this.wallet.id()}/txrequests/${txRequestId}/signatureshares`, 2))
            .send()
            .result();
    }
    /**
     * Initialize the send procedure once Bitgo has the User To Bitgo GShare
     *
     * @param {String} txRequestId - the txRequest Id
     * @param {IRequestTracer} reqId - the request tracer request id
     * @returns {Promise<any>}
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async sendTxRequest(txRequestId, reqId) {
        const reqTracer = reqId || new util_1.RequestTracer();
        this.bitgo.setRequestTracer(reqTracer);
        return this.bitgo
            .post(this.baseCoin.url('/wallet/' + this.wallet.id() + '/tx/send'))
            .send({ txRequestId })
            .result();
    }
    /**
     * Delete signature shares, get the tx request without them from the db and sign it to finally send it.
     *
     * Note : This can be performed in order to reach latest network conditions required on pending approval flow.
     *
     * @param {String} txRequestId - the txRequest Id to make the requests.
     * @param {String} decryptedPrv - decrypted prv to sign the tx request.
     * @param {RequestTracer} reqId id tracer.
     * @returns {Promise<any>}
     */
    async recreateTxRequest(txRequestId, decryptedPrv, reqId) {
        await this.deleteSignatureShares(txRequestId);
        // after delete signatures shares get the tx without them
        const txRequest = await (0, tss_1.getTxRequest)(this.bitgo, this.wallet.id(), txRequestId);
        return await this.signTxRequest({ txRequest, prv: decryptedPrv, reqId });
    }
    /**
     * Gets the latest Tx Request by id
     *
     * @param {String} txRequestId - the txRequest Id
     * @param {IRequestTracer} reqId - request tracer request id
     * @returns {Promise<TxRequest>}
     */
    async getTxRequest(txRequestId, reqId) {
        return (0, tss_1.getTxRequest)(this.bitgo, this.wallet.id(), txRequestId, reqId);
    }
    /**
     * Checks whether the third party backup provider is valid/supported
     * @param backupProvider - the backup provider client selected
     */
    isValidThirdPartyBackupProvider(backupProvider) {
        // As of now, BitGo is the only supported KRS provider for TSS
        return !!(backupProvider && backupProvider === 'BitGoTrustAsKrs');
    }
    /**
     * It gets the appropriate BitGo GPG public key for key creation based on a
     * combination of coin and the feature flags on the user and their enterprise if set.
     * @param enterpriseId - enterprise under which user wants to create the wallet
     * @param isMPCv2 - true to get the MPCv2 GPG public key, defaults to false
     */
    async getBitgoGpgPubkeyBasedOnFeatureFlags(enterpriseId, isMPCv2 = false) {
        const response = await this.bitgo
            .get(this.baseCoin.url('/tss/pubkey'))
            .query({ enterpriseId })
            .retry(3)
            .result();
        const bitgoPublicKeyStr = isMPCv2 ? response.mpcv2PublicKey : response.publicKey;
        return (0, openpgp_1.readKey)({ armoredKey: bitgoPublicKeyStr });
    }
    /**
     * Returns supported TxRequest versions for this wallet
     */
    supportedTxRequestVersions() {
        var _a, _b, _c, _d;
        const walletType = (_a = this._wallet) === null || _a === void 0 ? void 0 : _a.type();
        const supportedWalletTypes = ['custodial', 'cold', 'hot'];
        if (!walletType || ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.multisigType()) !== 'tss' || !supportedWalletTypes.includes(walletType)) {
            return [];
        }
        else if (((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.baseCoin.getMPCAlgorithm()) === 'ecdsa') {
            return ['full'];
        }
        else if (walletType === 'custodial' || walletType === 'cold') {
            return ['full'];
        }
        else if (((_d = this._wallet) === null || _d === void 0 ? void 0 : _d.baseCoin.getMPCAlgorithm()) === 'eddsa' && walletType === 'hot') {
            return ['lite', 'full'];
        }
        return [];
    }
    /**
     * Returns true if the txRequest is using apiVersion == full and is pending approval
     * @param txRequest
     * @returns boolean
     */
    isPendingApprovalTxRequestFull(txRequest) {
        const { apiVersion, state } = txRequest;
        return apiVersion === 'full' && 'pendingApproval' === state;
    }
}
exports.default = BaseTssUtils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZVRTU1V0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2JpdGdvL3V0aWxzL3Rzcy9iYXNlVFNTVXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLHFDQUEwRDtBQUkxRCxtQ0FBeUM7QUFFekMsMENBQXVDO0FBQ3ZDLDBDQUE0QjtBQTZCNUIsa0NBQXdDO0FBRXhDOztHQUVHO0FBQ0gsTUFBcUIsWUFBdUIsU0FBUSxtQkFBUTtJQUcxRCxZQUFZLEtBQWdCLEVBQUUsUUFBbUIsRUFBRSxNQUFnQjtRQUNqRSxLQUFLLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO0lBQ3hCLENBQUM7SUFFRCxJQUFJLE1BQU07UUFDUixJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3pCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0JBQW9CLENBQUMsQ0FBQztTQUN2QztRQUNELE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN0QixDQUFDO0lBRUQsS0FBSyxDQUFDLDZCQUE2QixDQUNqQyxVQUFxQyxFQUNyQyxVQUE4QjtRQUU5QixNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyxLQUFLO2FBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO2FBQzFDLElBQUksQ0FBQztZQUNKLFVBQVU7WUFDVixnQkFBZ0IsRUFBRSxVQUFVLENBQUMsU0FBUztTQUN2QyxDQUFDO2FBQ0QsTUFBTSxFQUFFLENBQUM7UUFDWixJQUFJLENBQUMsV0FBVyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRTtZQUMxQyxNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7U0FDNUQ7UUFD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Q0FBQyxlQUFlLEVBQUUsTUFBSyxPQUFPLElBQUksVUFBVSxLQUFLLEtBQUssRUFBRTtZQUN2RixPQUFPLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ3pCO1FBQ0QsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDhCQUE4QixDQUFDLFNBQW9CO1FBQ2pELE1BQU0sRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLEdBQUcsU0FBUyxDQUFDO1FBQ3hDLE9BQU8sVUFBVSxLQUFLLE1BQU0sSUFBSSxpQkFBaUIsS0FBSyxLQUFLLENBQUM7SUFDOUQsQ0FBQztDQUNGO0FBMVlELCtCQTBZQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElSZXF1ZXN0VHJhY2VyIH0gZnJvbSAnLi4vLi4vLi4vYXBpJztcbmltcG9ydCB7IEtleSwgcmVhZEtleSwgU2VyaWFsaXplZEtleVBhaXIgfSBmcm9tICdvcGVucGdwJztcbmltcG9ydCB7IElCYXNlQ29pbiwgS2V5Y2hhaW5zVHJpcGxldCB9IGZyb20gJy4uLy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IEJpdEdvQmFzZSB9IGZyb20gJy4uLy4uL2JpdGdvQmFzZSc7XG5pbXBvcnQgeyBLZXljaGFpbiB9IGZyb20gJy4uLy4uL2tleWNoYWluJztcbmltcG9ydCB7IGdldFR4UmVxdWVzdCB9IGZyb20gJy4uLy4uL3Rzcyc7XG5pbXBvcnQgeyBJV2FsbGV0LCBCYWNrdXBQcm92aWRlciB9IGZyb20gJy4uLy4uL3dhbGxldCc7XG5pbXBvcnQgeyBNcGNVdGlscyB9IGZyb20gJy4uL21wY1V0aWxzJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7XG4gIEJpdGdvR1BHUHVibGljS2V5LFxuICBCaXRnb0hlbGRCYWNrdXBLZXlTaGFyZSxcbiAgQ3VzdG9tR1NoYXJlR2VuZXJhdGluZ0Z1bmN0aW9uLFxuICBDdXN0b21SU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb24sXG4gIElUc3NVdGlscyxcbiAgUHJlYnVpbGRUcmFuc2FjdGlvbldpdGhJbnRlbnRPcHRpb25zLFxuICBTaWduYXR1cmVTaGFyZVJlY29yZCxcbiAgVFNTUGFyYW1zLFxuICBUeFJlcXVlc3QsXG4gIFR4UmVxdWVzdFZlcnNpb24sXG4gIENyZWF0ZUtleWNoYWluUGFyYW1zQmFzZSxcbiAgSW50ZW50T3B0aW9uc0Zvck1lc3NhZ2UsXG4gIFBvcHVsYXRlZEludGVudEZvck1lc3NhZ2VTaWduaW5nLFxuICBJbnRlbnRPcHRpb25zRm9yVHlwZWREYXRhLFxuICBQb3B1bGF0ZWRJbnRlbnRGb3JUeXBlZERhdGFTaWduaW5nLFxuICBDcmVhdGVCaXRHb0tleWNoYWluUGFyYW1zQmFzZSxcbiAgQ29tbWl0bWVudFNoYXJlUmVjb3JkLFxuICBFbmNyeXB0ZWRTaWduZXJTaGFyZVJlY29yZCxcbiAgQ3VzdG9tQ29tbWl0bWVudEdlbmVyYXRpbmdGdW5jdGlvbixcbiAgVFNTUGFyYW1zRm9yTWVzc2FnZSxcbiAgUmVxdWVzdFR5cGUsXG4gIEN1c3RvbVBhaWxsaWVyTW9kdWx1c0dldHRlckZ1bmN0aW9uLFxuICBDdXN0b21LU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb24sXG4gIEN1c3RvbU11RGVsdGFTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbixcbiAgQ3VzdG9tU1NoYXJlR2VuZXJhdGluZ0Z1bmN0aW9uLFxufSBmcm9tICcuL2Jhc2VUeXBlcyc7XG5pbXBvcnQgeyBHU2hhcmUsIFNpZ25TaGFyZSB9IGZyb20gJy4uLy4uLy4uL2FjY291bnQtbGliL21wYy90c3MnO1xuaW1wb3J0IHsgUmVxdWVzdFRyYWNlciB9IGZyb20gJy4uL3V0aWwnO1xuXG4vKipcbiAqIEJhc2VUc3NVdGlsIGNsYXNzIHdoaWNoIGRpZmZlcmVudCBzaWduYXR1cmUgc2NoZW1lcyBoYXZlIHRvIGV4dGVuZFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlVHNzVXRpbHM8S2V5U2hhcmU+IGV4dGVuZHMgTXBjVXRpbHMgaW1wbGVtZW50cyBJVHNzVXRpbHM8S2V5U2hhcmU+IHtcbiAgcHJpdmF0ZSBfd2FsbGV0PzogSVdhbGxldDtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlLCBiYXNlQ29pbjogSUJhc2VDb2luLCB3YWxsZXQ/OiBJV2FsbGV0KSB7XG4gICAgc3VwZXIoYml0Z28sIGJhc2VDb2luKTtcbiAgICB0aGlzLl93YWxsZXQgPSB3YWxsZXQ7XG4gIH1cblxuICBnZXQgd2FsbGV0KCk6IElXYWxsZXQge1xuICAgIGlmIChfLmlzTmlsKHRoaXMuX3dhbGxldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93YWxsZXQ7XG4gIH1cblxuICBhc3luYyBjcmVhdGVCaXRnb0hlbGRCYWNrdXBLZXlTaGFyZShcbiAgICB1c2VyR3BnS2V5OiBTZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+LFxuICAgIGVudGVycHJpc2U6IHN0cmluZyB8IHVuZGVmaW5lZFxuICApOiBQcm9taXNlPEJpdGdvSGVsZEJhY2t1cEtleVNoYXJlPiB7XG4gICAgY29uc3Qga2V5UmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL2tycy9iYWNrdXBrZXlzJykpXG4gICAgICAuc2VuZCh7XG4gICAgICAgIGVudGVycHJpc2UsXG4gICAgICAgIHVzZXJHUEdQdWJsaWNLZXk6IHVzZXJHcGdLZXkucHVibGljS2V5LFxuICAgICAgfSlcbiAgICAgIC5yZXN1bHQoKTtcbiAgICBpZiAoIWtleVJlc3BvbnNlIHx8ICFrZXlSZXNwb25zZS5rZXlTaGFyZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBiYWNrdXAgc2hhcmVzIGZyb20gQml0R28uJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpZDoga2V5UmVzcG9uc2UuaWQsXG4gICAgICBrZXlTaGFyZXM6IGtleVJlc3BvbnNlLmtleVNoYXJlcyxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGZpbmFsaXplQml0Z29IZWxkQmFja3VwS2V5U2hhcmUoXG4gICAga2V5SWQ6IHN0cmluZyxcbiAgICBjb21tb25LZXljaGFpbjogc3RyaW5nLFxuICAgIHVzZXJLZXlTaGFyZTogS2V5U2hhcmUsXG4gICAgYml0Z29LZXljaGFpbjogS2V5Y2hhaW4sXG4gICAgdXNlckdwZ0tleTogU2VyaWFsaXplZEtleVBhaXI8c3RyaW5nPixcbiAgICBiYWNrdXBHcGdLZXk6IEtleVxuICApOiBQcm9taXNlPEJpdGdvSGVsZEJhY2t1cEtleVNoYXJlPiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgY3JlYXRlVXNlcktleWNoYWluKHBhcmFtczogQ3JlYXRlS2V5Y2hhaW5QYXJhbXNCYXNlKTogUHJvbWlzZTxLZXljaGFpbj4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIGNyZWF0ZUJhY2t1cEtleWNoYWluKHBhcmFtczogQ3JlYXRlS2V5Y2hhaW5QYXJhbXNCYXNlKTogUHJvbWlzZTxLZXljaGFpbj4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIGNyZWF0ZUJpdGdvS2V5Y2hhaW4ocGFyYW1zOiBDcmVhdGVCaXRHb0tleWNoYWluUGFyYW1zQmFzZSk6IFByb21pc2U8S2V5Y2hhaW4+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBjcmVhdGVLZXljaGFpbnMocGFyYW1zOiB7XG4gICAgcGFzc3BocmFzZTogc3RyaW5nO1xuICAgIGVudGVycHJpc2U/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGlzVGhpcmRQYXJ0eUJhY2t1cD86IGJvb2xlYW47XG4gICAgYmFja3VwUHJvdmlkZXI/OiBCYWNrdXBQcm92aWRlcjtcbiAgfSk6IFByb21pc2U8S2V5Y2hhaW5zVHJpcGxldD4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIHNpZ25UeFJlcXVlc3QocGFyYW1zOiBUU1NQYXJhbXMpOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIHNpZ25UeFJlcXVlc3RGb3JNZXNzYWdlKHBhcmFtczogVFNTUGFyYW1zKTogUHJvbWlzZTxUeFJlcXVlc3Q+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbnMgYSB0cmFuc2FjdGlvbiB1c2luZyBUU1MgZm9yIEVkRFNBIGFuZCB0aHJvdWdoIHV0aWxpemF0aW9uIG9mIGN1c3RvbSBzaGFyZSBnZW5lcmF0b3JzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVHhSZXF1ZXN0fSB0eFJlcXVlc3QgLSB0cmFuc2FjdGlvbiByZXF1ZXN0IHdpdGggdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtDdXN0b21SU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb259IGV4dGVybmFsU2lnbmVyUlNoYXJlR2VuZXJhdG9yIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIFIgc2hhcmVzIGluIHRoZSBFZERTQSBUU1MgZmxvd1xuICAgKiBAcGFyYW0ge0N1c3RvbUdTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbn0gZXh0ZXJuYWxTaWduZXJHU2hhcmVHZW5lcmF0b3IgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgRyBzaGFyZXMgaW4gdGhlIEVkRFNBIFRTUyBmbG93XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFR4UmVxdWVzdD59IC0gYSBzaWduZWQgdHggcmVxdWVzdFxuICAgKi9cbiAgc2lnbkVkZHNhVHNzVXNpbmdFeHRlcm5hbFNpZ25lcihcbiAgICB0eFJlcXVlc3Q6IHN0cmluZyB8IFR4UmVxdWVzdCxcbiAgICBleHRlcm5hbFNpZ25lckNvbW1pdG1lbnRHZW5lcmF0b3I6IEN1c3RvbUNvbW1pdG1lbnRHZW5lcmF0aW5nRnVuY3Rpb24sXG4gICAgZXh0ZXJuYWxTaWduZXJSU2hhcmVHZW5lcmF0b3I6IEN1c3RvbVJTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbixcbiAgICBleHRlcm5hbFNpZ25lckdTaGFyZUdlbmVyYXRvcjogQ3VzdG9tR1NoYXJlR2VuZXJhdGluZ0Z1bmN0aW9uXG4gICk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25zIGEgdHJhbnNhY3Rpb24gdXNpbmcgVFNTIGZvciBFQ0RTQSBhbmQgdGhyb3VnaCB1dGlsaXphdGlvbiBvZiBjdXN0b20gc2hhcmUgZ2VuZXJhdG9yc1xuICAgKlxuICAgKiBAcGFyYW0ge3BhcmFtczogVFNTUGFyYW1zIHwgVFNTUGFyYW1zRm9yTWVzc2FnZX0gcGFyYW1zIC0gcGFyYW1zIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgcGFyYW1ldGVycyB0byBzaWduIGEgdHJhbnNhY3Rpb24gb3IgYSBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge1JlcXVlc3RUeXBlfSByZXF1ZXN0VHlwZSAtIHRoZSB0eXBlIG9mIHRoZSByZXF1ZXN0IHRvIHNpZ24gKHRyYW5zYWN0aW9uIG9yIG1lc3NhZ2UpLlxuICAgKiBAcGFyYW0ge0N1c3RvbVBhaWxsaWVyTW9kdWx1c0dldHRlckZ1bmN0aW9ufSBleHRlcm5hbFNpZ25lclBhaWxsaWVyTW9kdWx1c0dldHRlciBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBQYWlsbGllciBNb2R1bHVzIHNoYXJlcyBpbiB0aGUgRUNEU0EgVFNTIGZsb3cuXG4gICAqIEBwYXJhbSB7Q3VzdG9tS1NoYXJlR2VuZXJhdGluZ0Z1bmN0aW9ufSBleHRlcm5hbFNpZ25lcktTaGFyZUdlbmVyYXRvciBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBLIHNoYXJlcyBpbiB0aGUgRUNEU0EgVFNTIGZsb3cuXG4gICAqIEBwYXJhbSB7Q3VzdG9tTXVEZWx0YVNoYXJlR2VuZXJhdGluZ0Z1bmN0aW9ufSBleHRlcm5hbFNpZ25lck11RGVsdGFTaGFyZUdlbmVyYXRvciBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBNdSBhbmQgRGVsdGEgc2hhcmVzIGluIHRoZSBFQ0RTQSBUU1MgZmxvdy5cbiAgICogQHBhcmFtIHtDdXN0b21TU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb259IGV4dGVybmFsU2lnbmVyU1NoYXJlR2VuZXJhdG9yIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIFMgc2hhcmVzIGluIHRoZSBFQ0RTQSBUU1MgZmxvdy5cbiAgICovXG4gIHNpZ25FY2RzYVRzc1VzaW5nRXh0ZXJuYWxTaWduZXIoXG4gICAgcGFyYW1zOiBUU1NQYXJhbXMgfCBUU1NQYXJhbXNGb3JNZXNzYWdlLFxuICAgIHJlcXVlc3RUeXBlOiBSZXF1ZXN0VHlwZSxcbiAgICBleHRlcm5hbFNpZ25lclBhaWxsaWVyTW9kdWx1c0dldHRlcjogQ3VzdG9tUGFpbGxpZXJNb2R1bHVzR2V0dGVyRnVuY3Rpb24sXG4gICAgZXh0ZXJuYWxTaWduZXJLU2hhcmVHZW5lcmF0b3I6IEN1c3RvbUtTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbixcbiAgICBleHRlcm5hbFNpZ25lck11RGVsdGFTaGFyZUdlbmVyYXRvcjogQ3VzdG9tTXVEZWx0YVNoYXJlR2VuZXJhdGluZ0Z1bmN0aW9uLFxuICAgIGV4dGVybmFsU2lnbmVyU1NoYXJlR2VuZXJhdG9yOiBDdXN0b21TU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb25cbiAgKTogUHJvbWlzZTxUeFJlcXVlc3Q+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIENvbW1pdG1lbnQgKFVzZXIgdG8gQml0R28pIHNoYXJlIGZyb20gYW4gdW5zaWduZWQgdHJhbnNhY3Rpb24gYW5kIHByaXZhdGUgdXNlciBzaWduaW5nIG1hdGVyaWFsXG4gICAqIEVERFNBIG9ubHlcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHBhcmFtcyBvYmplY3RcbiAgICogQHBhcmFtIHtUeFJlcXVlc3R9IHBhcmFtcy50eFJlcXVlc3QgLSB0cmFuc2FjdGlvbiByZXF1ZXN0IHdpdGggdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wcnYgLSB1c2VyIHNpZ25pbmcgbWF0ZXJpYWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIC0gd2FsbGV0IHBhc3NwaHJhc2VcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8eyB1c2VyVG9CaXRnb0NvbW1pdG1lbnQ6IENvbW1pdG1lbnRTaGFyZVJlY29yLCBlbmNyeXB0ZWRTaWduZXJTaGFyZTogRW5jcnlwdGVkU2lnbmVyU2hhcmVSZWNvcmQgfT59IC0gQ29tbWl0bWVudCBTaGFyZSBhbmQgdGhlIEVuY3J5cHRlZCBTaWduZXIgU2hhcmUgdG8gQml0R29cbiAgICovXG4gIGNyZWF0ZUNvbW1pdG1lbnRTaGFyZUZyb21UeFJlcXVlc3QocGFyYW1zOiB7IHR4UmVxdWVzdDogVHhSZXF1ZXN0OyBwcnY6IHN0cmluZzsgd2FsbGV0UGFzc3BocmFzZTogc3RyaW5nIH0pOiBQcm9taXNlPHtcbiAgICB1c2VyVG9CaXRnb0NvbW1pdG1lbnQ6IENvbW1pdG1lbnRTaGFyZVJlY29yZDtcbiAgICBlbmNyeXB0ZWRTaWduZXJTaGFyZTogRW5jcnlwdGVkU2lnbmVyU2hhcmVSZWNvcmQ7XG4gICAgZW5jcnlwdGVkVXNlclRvQml0Z29SU2hhcmU6IEVuY3J5cHRlZFNpZ25lclNoYXJlUmVjb3JkO1xuICB9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBSIChVc2VyIHRvIEJpdEdvKSBzaGFyZSBmcm9tIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uIGFuZCBwcml2YXRlIHVzZXIgc2lnbmluZyBtYXRlcmlhbFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gcGFyYW1zIG9iamVjdFxuICAgKiBAcGFyYW0ge1R4UmVxdWVzdH0gcGFyYW1zLnR4UmVxdWVzdCAtIHRyYW5zYWN0aW9uIHJlcXVlc3Qgd2l0aCB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBydiAtIHVzZXIgc2lnbmluZyBtYXRlcmlhbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy53YWxsZXRQYXNzcGhyYXNlXSAtIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqIEBwYXJhbSB7RW5jcnlwdGVkU2lnbmVyU2hhcmVSZWNvcmR9IFtwYXJhbXMuZW5jcnlwdGVkVXNlclRvQml0Z29SU2hhcmVdIC0gZW5jcnlwdGVkIHVzZXIgdG8gYml0Z28gUiBzaGFyZSBnZW5lcmF0ZWQgaW4gdGhlIGNvbW1pdG1lbnQgcGhhc2VcbiAgICogQHJldHVybnMge1Byb21pc2U8eyByU2hhcmU6IFNpZ25TaGFyZSB9Pn0gLSBSIFNoYXJlIHRvIEJpdEdvXG4gICAqL1xuICBjcmVhdGVSU2hhcmVGcm9tVHhSZXF1ZXN0KHBhcmFtczoge1xuICAgIHR4UmVxdWVzdDogVHhSZXF1ZXN0O1xuICAgIHdhbGxldFBhc3NwaHJhc2U6IHN0cmluZztcbiAgICBlbmNyeXB0ZWRVc2VyVG9CaXRnb1JTaGFyZTogRW5jcnlwdGVkU2lnbmVyU2hhcmVSZWNvcmQ7XG4gIH0pOiBQcm9taXNlPHsgclNoYXJlOiBTaWduU2hhcmUgfT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBHIChVc2VyIHRvIEJpdEdvKSBzaGFyZSBmcm9tIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uIGFuZCBwcml2YXRlIHVzZXIgc2lnbmluZyBtYXRlcmlhbFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gcGFyYW1zIG9iamVjdFxuICAgKiBAcGFyYW0ge1R4UmVxdWVzdH0gcGFyYW1zLnR4UmVxdWVzdCAtIHRyYW5zYWN0aW9uIHJlcXVlc3Qgd2l0aCB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBydiAtIHVzZXIgc2lnbmluZyBtYXRlcmlhbFxuICAgKiBAcGFyYW0ge1NpZ25hdHVyZVNoYXJlUmVjb3JkfSBwYXJhbXMuYml0Z29Ub1VzZXJSU2hhcmUgLSBCaXRHbyB0byBVc2VyIFIgU2hhcmVcbiAgICogQHBhcmFtIHtTaWduU2hhcmV9IHBhcmFtcy51c2VyVG9CaXRnb1JTaGFyZSAtIFVzZXIgdG8gQml0R28gUiBTaGFyZVxuICAgKiBAcGFyYW0ge0NvbW1pdG1lbnRTaGFyZVJlY29yZH0gcGFyYW1zLmJpdGdvVG9Vc2VyQ29tbWl0bWVudCAtIEJpdEdvIHRvIFVzZXIgQ29tbWl0bWVudFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHU2hhcmU+fSAtIEdTaGFyZSBmcm9tIFVzZXIgdG8gQml0R29cbiAgICovXG4gIGNyZWF0ZUdTaGFyZUZyb21UeFJlcXVlc3QocGFyYW1zOiB7XG4gICAgdHhSZXF1ZXN0OiBUeFJlcXVlc3Q7XG4gICAgcHJ2OiBzdHJpbmc7XG4gICAgYml0Z29Ub1VzZXJSU2hhcmU6IFNpZ25hdHVyZVNoYXJlUmVjb3JkO1xuICAgIHVzZXJUb0JpdGdvUlNoYXJlOiBTaWduU2hhcmU7XG4gICAgYml0Z29Ub1VzZXJDb21taXRtZW50OiBDb21taXRtZW50U2hhcmVSZWNvcmQ7XG4gIH0pOiBQcm9taXNlPEdTaGFyZT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSB0eCByZXF1ZXN0IGZyb20gcGFyYW1zIGFuZCB2ZXJpZnkgaXRcbiAgICpcbiAgICogQHBhcmFtIHtQcmVidWlsZFRyYW5zYWN0aW9uV2l0aEludGVudE9wdGlvbnN9IHBhcmFtcyAtIHBhcmFtZXRlcnMgdG8gYnVpbGQgdGhlIHR4XG4gICAqIEBwYXJhbSB7VHhSZXF1ZXN0VmVyc2lvbn0gYXBpVmVyc2lvbiBsaXRlIG9yIGZ1bGxcbiAgICogQHBhcmFtIHtib29sZWFufSBwcmV2aWV3IGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGlzIGlzIHRvIHByZXZpZXcgYSB0eCByZXF1ZXN0LCB3aGljaCB3aWxsIG5vdCBpbml0aWF0ZSBwb2xpY3kgY2hlY2tzIG9yIHBlbmRpbmcgYXBwcm92YWxzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFR4UmVxdWVzdD59IC0gYSBidWlsdCB0eCByZXF1ZXN0XG4gICAqL1xuICBhc3luYyBwcmVidWlsZFR4V2l0aEludGVudChcbiAgICBwYXJhbXM6IFByZWJ1aWxkVHJhbnNhY3Rpb25XaXRoSW50ZW50T3B0aW9ucyxcbiAgICBhcGlWZXJzaW9uOiBUeFJlcXVlc3RWZXJzaW9uID0gJ2xpdGUnLFxuICAgIHByZXZpZXc/OiBib29sZWFuXG4gICk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgY29uc3QgaW50ZW50T3B0aW9ucyA9IHRoaXMucG9wdWxhdGVJbnRlbnQodGhpcy5iYXNlQ29pbiwgcGFyYW1zKTtcblxuICAgIGNvbnN0IHdoaXRlbGlzdGVkUGFyYW1zID0ge1xuICAgICAgaW50ZW50OiB7XG4gICAgICAgIC4uLmludGVudE9wdGlvbnMsXG4gICAgICB9LFxuICAgICAgYXBpVmVyc2lvbjogYXBpVmVyc2lvbixcbiAgICAgIHByZXZpZXcsXG4gICAgfTtcblxuICAgIGNvbnN0IHVuc2lnbmVkVHggPSAoYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgLnBvc3QodGhpcy5iaXRnby51cmwoJy93YWxsZXQvJyArIHRoaXMud2FsbGV0LmlkKCkgKyAnL3R4cmVxdWVzdHMnLCAyKSlcbiAgICAgIC5zZW5kKHdoaXRlbGlzdGVkUGFyYW1zKVxuICAgICAgLnJlc3VsdCgpKSBhcyBUeFJlcXVlc3Q7XG5cbiAgICByZXR1cm4gdW5zaWduZWRUeDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0eCByZXF1ZXN0IGZyb20gcGFyYW1zIGZvciBtZXNzYWdlIHNpZ25pbmdcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gYXBpVmVyc2lvblxuICAgKiBAcGFyYW0gcHJldmlld1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlVHhSZXF1ZXN0V2l0aEludGVudEZvck1lc3NhZ2VTaWduaW5nKFxuICAgIHBhcmFtczogSW50ZW50T3B0aW9uc0Zvck1lc3NhZ2UsXG4gICAgYXBpVmVyc2lvbjogVHhSZXF1ZXN0VmVyc2lvbiA9ICdmdWxsJyxcbiAgICBwcmV2aWV3PzogYm9vbGVhblxuICApOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICAgIGNvbnN0IGludGVudE9wdGlvbnM6IFBvcHVsYXRlZEludGVudEZvck1lc3NhZ2VTaWduaW5nID0ge1xuICAgICAgY3VzdG9kaWFuTWVzc2FnZUlkOiBwYXJhbXMuY3VzdG9kaWFuTWVzc2FnZUlkLFxuICAgICAgaW50ZW50VHlwZTogcGFyYW1zLmludGVudFR5cGUsXG4gICAgICBzZXF1ZW5jZUlkOiBwYXJhbXMuc2VxdWVuY2VJZCxcbiAgICAgIGNvbW1lbnQ6IHBhcmFtcy5jb21tZW50LFxuICAgICAgbWVtbzogcGFyYW1zLm1lbW8/LnZhbHVlLFxuICAgICAgaXNUc3M6IHBhcmFtcy5pc1RzcyxcbiAgICAgIG1lc3NhZ2VSYXc6IHBhcmFtcy5tZXNzYWdlUmF3LFxuICAgICAgbWVzc2FnZUVuY29kZWQ6IHBhcmFtcy5tZXNzYWdlRW5jb2RlZCA/PyAnJyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlVHhSZXF1ZXN0QmFzZShpbnRlbnRPcHRpb25zLCBhcGlWZXJzaW9uLCBwcmV2aWV3KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0eCByZXF1ZXN0IGZyb20gcGFyYW1zIGZvciB0eXBlIGRhdGEgc2lnbmluZ1xuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBhcGlWZXJzaW9uXG4gICAqIEBwYXJhbSBwcmV2aWV3XG4gICAqL1xuICBhc3luYyBjcmVhdGVUeFJlcXVlc3RXaXRoSW50ZW50Rm9yVHlwZWREYXRhU2lnbmluZyhcbiAgICBwYXJhbXM6IEludGVudE9wdGlvbnNGb3JUeXBlZERhdGEsXG4gICAgYXBpVmVyc2lvbjogVHhSZXF1ZXN0VmVyc2lvbiA9ICdmdWxsJyxcbiAgICBwcmV2aWV3PzogYm9vbGVhblxuICApOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICAgIGNvbnN0IGludGVudE9wdGlvbnM6IFBvcHVsYXRlZEludGVudEZvclR5cGVkRGF0YVNpZ25pbmcgPSB7XG4gICAgICBjdXN0b2RpYW5NZXNzYWdlSWQ6IHBhcmFtcy5jdXN0b2RpYW5NZXNzYWdlSWQsXG4gICAgICBpbnRlbnRUeXBlOiBwYXJhbXMuaW50ZW50VHlwZSxcbiAgICAgIHNlcXVlbmNlSWQ6IHBhcmFtcy5zZXF1ZW5jZUlkLFxuICAgICAgY29tbWVudDogcGFyYW1zLmNvbW1lbnQsXG4gICAgICBtZW1vOiBwYXJhbXMubWVtbz8udmFsdWUsXG4gICAgICBpc1RzczogcGFyYW1zLmlzVHNzLFxuICAgICAgbWVzc2FnZVJhdzogcGFyYW1zLnR5cGVkRGF0YVJhdyxcbiAgICAgIG1lc3NhZ2VFbmNvZGVkOiBwYXJhbXMudHlwZWREYXRhRW5jb2RlZCA/PyAnJyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlVHhSZXF1ZXN0QmFzZShpbnRlbnRPcHRpb25zLCBhcGlWZXJzaW9uLCBwcmV2aWV3KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBCaXRnbyBBUEkgdG8gY3JlYXRlIHR4IHJlcXVlc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNyZWF0ZVR4UmVxdWVzdEJhc2UoXG4gICAgaW50ZW50T3B0aW9uczogUG9wdWxhdGVkSW50ZW50Rm9yVHlwZWREYXRhU2lnbmluZyB8IFBvcHVsYXRlZEludGVudEZvck1lc3NhZ2VTaWduaW5nLFxuICAgIGFwaVZlcnNpb246IFR4UmVxdWVzdFZlcnNpb24sXG4gICAgcHJldmlldz86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxUeFJlcXVlc3Q+IHtcbiAgICBjb25zdCB3aGl0ZWxpc3RlZFBhcmFtcyA9IHtcbiAgICAgIGludGVudDoge1xuICAgICAgICAuLi5pbnRlbnRPcHRpb25zLFxuICAgICAgfSxcbiAgICAgIGFwaVZlcnNpb24sXG4gICAgICBwcmV2aWV3LFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnb1xuICAgICAgLnBvc3QodGhpcy5iaXRnby51cmwoYC93YWxsZXQvJHt0aGlzLndhbGxldC5pZCgpfS90eHJlcXVlc3RzYCwgMikpXG4gICAgICAuc2VuZCh3aGl0ZWxpc3RlZFBhcmFtcylcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGRlbGV0ZSBzaWduYXR1cmUgc2hhcmVzIGZvciBhIHR4UmVxdWVzdCwgdGhlIGVuZHBvaW50IGRlbGV0ZSB0aGUgc2lnbmF0dXJlcyBhbmQgcmV0dXJuIHRoZW1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR4UmVxdWVzdElkIHR4IGlkIHJlZmVyZW5jZSB0byBkZWxldGUgc2lnbmF0dXJlIHNoYXJlc1xuICAgKiBAcGFyYW0ge0lSZXF1ZXN0VHJhY2VyfSByZXFJZCAtIHRoZSByZXF1ZXN0IHRyYWNlciByZXF1ZXN0IGlkXG4gICAqIEByZXR1cm5zIHtTaWduYXR1cmVTaGFyZVJlY29yZFtdfVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlU2lnbmF0dXJlU2hhcmVzKHR4UmVxdWVzdElkOiBzdHJpbmcsIHJlcUlkPzogSVJlcXVlc3RUcmFjZXIpOiBQcm9taXNlPFNpZ25hdHVyZVNoYXJlUmVjb3JkW10+IHtcbiAgICBjb25zdCByZXFUcmFjZXIgPSByZXFJZCB8fCBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFUcmFjZXIpO1xuICAgIHJldHVybiB0aGlzLmJpdGdvXG4gICAgICAuZGVsKHRoaXMuYml0Z28udXJsKGAvd2FsbGV0LyR7dGhpcy53YWxsZXQuaWQoKX0vdHhyZXF1ZXN0cy8ke3R4UmVxdWVzdElkfS9zaWduYXR1cmVzaGFyZXNgLCAyKSlcbiAgICAgIC5zZW5kKClcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBzZW5kIHByb2NlZHVyZSBvbmNlIEJpdGdvIGhhcyB0aGUgVXNlciBUbyBCaXRnbyBHU2hhcmVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR4UmVxdWVzdElkIC0gdGhlIHR4UmVxdWVzdCBJZFxuICAgKiBAcGFyYW0ge0lSZXF1ZXN0VHJhY2VyfSByZXFJZCAtIHRoZSByZXF1ZXN0IHRyYWNlciByZXF1ZXN0IGlkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBhc3luYyBzZW5kVHhSZXF1ZXN0KHR4UmVxdWVzdElkOiBzdHJpbmcsIHJlcUlkPzogSVJlcXVlc3RUcmFjZXIpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHJlcVRyYWNlciA9IHJlcUlkIHx8IG5ldyBSZXF1ZXN0VHJhY2VyKCk7XG4gICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHJlcVRyYWNlcik7XG4gICAgcmV0dXJuIHRoaXMuYml0Z29cbiAgICAgIC5wb3N0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyB0aGlzLndhbGxldC5pZCgpICsgJy90eC9zZW5kJykpXG4gICAgICAuc2VuZCh7IHR4UmVxdWVzdElkIH0pXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIHNpZ25hdHVyZSBzaGFyZXMsIGdldCB0aGUgdHggcmVxdWVzdCB3aXRob3V0IHRoZW0gZnJvbSB0aGUgZGIgYW5kIHNpZ24gaXQgdG8gZmluYWxseSBzZW5kIGl0LlxuICAgKlxuICAgKiBOb3RlIDogVGhpcyBjYW4gYmUgcGVyZm9ybWVkIGluIG9yZGVyIHRvIHJlYWNoIGxhdGVzdCBuZXR3b3JrIGNvbmRpdGlvbnMgcmVxdWlyZWQgb24gcGVuZGluZyBhcHByb3ZhbCBmbG93LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHhSZXF1ZXN0SWQgLSB0aGUgdHhSZXF1ZXN0IElkIHRvIG1ha2UgdGhlIHJlcXVlc3RzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGVjcnlwdGVkUHJ2IC0gZGVjcnlwdGVkIHBydiB0byBzaWduIHRoZSB0eCByZXF1ZXN0LlxuICAgKiBAcGFyYW0ge1JlcXVlc3RUcmFjZXJ9IHJlcUlkIGlkIHRyYWNlci5cbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICovXG4gIGFzeW5jIHJlY3JlYXRlVHhSZXF1ZXN0KHR4UmVxdWVzdElkOiBzdHJpbmcsIGRlY3J5cHRlZFBydjogc3RyaW5nLCByZXFJZDogSVJlcXVlc3RUcmFjZXIpOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICAgIGF3YWl0IHRoaXMuZGVsZXRlU2lnbmF0dXJlU2hhcmVzKHR4UmVxdWVzdElkKTtcbiAgICAvLyBhZnRlciBkZWxldGUgc2lnbmF0dXJlcyBzaGFyZXMgZ2V0IHRoZSB0eCB3aXRob3V0IHRoZW1cbiAgICBjb25zdCB0eFJlcXVlc3QgPSBhd2FpdCBnZXRUeFJlcXVlc3QodGhpcy5iaXRnbywgdGhpcy53YWxsZXQuaWQoKSwgdHhSZXF1ZXN0SWQpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNpZ25UeFJlcXVlc3QoeyB0eFJlcXVlc3QsIHBydjogZGVjcnlwdGVkUHJ2LCByZXFJZCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsYXRlc3QgVHggUmVxdWVzdCBieSBpZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHhSZXF1ZXN0SWQgLSB0aGUgdHhSZXF1ZXN0IElkXG4gICAqIEBwYXJhbSB7SVJlcXVlc3RUcmFjZXJ9IHJlcUlkIC0gcmVxdWVzdCB0cmFjZXIgcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUeFJlcXVlc3Q+fVxuICAgKi9cbiAgYXN5bmMgZ2V0VHhSZXF1ZXN0KHR4UmVxdWVzdElkOiBzdHJpbmcsIHJlcUlkPzogSVJlcXVlc3RUcmFjZXIpOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICAgIHJldHVybiBnZXRUeFJlcXVlc3QodGhpcy5iaXRnbywgdGhpcy53YWxsZXQuaWQoKSwgdHhSZXF1ZXN0SWQsIHJlcUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgdGhpcmQgcGFydHkgYmFja3VwIHByb3ZpZGVyIGlzIHZhbGlkL3N1cHBvcnRlZFxuICAgKiBAcGFyYW0gYmFja3VwUHJvdmlkZXIgLSB0aGUgYmFja3VwIHByb3ZpZGVyIGNsaWVudCBzZWxlY3RlZFxuICAgKi9cbiAgaXNWYWxpZFRoaXJkUGFydHlCYWNrdXBQcm92aWRlcihcbiAgICBiYWNrdXBQcm92aWRlcjogQmFja3VwUHJvdmlkZXIgfCBzdHJpbmcgfCB1bmRlZmluZWRcbiAgKTogYmFja3VwUHJvdmlkZXIgaXMgQmFja3VwUHJvdmlkZXIge1xuICAgIC8vIEFzIG9mIG5vdywgQml0R28gaXMgdGhlIG9ubHkgc3VwcG9ydGVkIEtSUyBwcm92aWRlciBmb3IgVFNTXG4gICAgcmV0dXJuICEhKGJhY2t1cFByb3ZpZGVyICYmIGJhY2t1cFByb3ZpZGVyID09PSAnQml0R29UcnVzdEFzS3JzJyk7XG4gIH1cblxuICAvKipcbiAgICogSXQgZ2V0cyB0aGUgYXBwcm9wcmlhdGUgQml0R28gR1BHIHB1YmxpYyBrZXkgZm9yIGtleSBjcmVhdGlvbiBiYXNlZCBvbiBhXG4gICAqIGNvbWJpbmF0aW9uIG9mIGNvaW4gYW5kIHRoZSBmZWF0dXJlIGZsYWdzIG9uIHRoZSB1c2VyIGFuZCB0aGVpciBlbnRlcnByaXNlIGlmIHNldC5cbiAgICogQHBhcmFtIGVudGVycHJpc2VJZCAtIGVudGVycHJpc2UgdW5kZXIgd2hpY2ggdXNlciB3YW50cyB0byBjcmVhdGUgdGhlIHdhbGxldFxuICAgKiBAcGFyYW0gaXNNUEN2MiAtIHRydWUgdG8gZ2V0IHRoZSBNUEN2MiBHUEcgcHVibGljIGtleSwgZGVmYXVsdHMgdG8gZmFsc2VcbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRCaXRnb0dwZ1B1YmtleUJhc2VkT25GZWF0dXJlRmxhZ3MoZW50ZXJwcmlzZUlkOiBzdHJpbmcgfCB1bmRlZmluZWQsIGlzTVBDdjIgPSBmYWxzZSk6IFByb21pc2U8S2V5PiB7XG4gICAgY29uc3QgcmVzcG9uc2U6IEJpdGdvR1BHUHVibGljS2V5ID0gYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL3Rzcy9wdWJrZXknKSlcbiAgICAgIC5xdWVyeSh7IGVudGVycHJpc2VJZCB9KVxuICAgICAgLnJldHJ5KDMpXG4gICAgICAucmVzdWx0KCk7XG4gICAgY29uc3QgYml0Z29QdWJsaWNLZXlTdHIgPSBpc01QQ3YyID8gcmVzcG9uc2UubXBjdjJQdWJsaWNLZXkgOiByZXNwb25zZS5wdWJsaWNLZXk7XG4gICAgcmV0dXJuIHJlYWRLZXkoeyBhcm1vcmVkS2V5OiBiaXRnb1B1YmxpY0tleVN0ciBhcyBzdHJpbmcgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzdXBwb3J0ZWQgVHhSZXF1ZXN0IHZlcnNpb25zIGZvciB0aGlzIHdhbGxldFxuICAgKi9cbiAgcHVibGljIHN1cHBvcnRlZFR4UmVxdWVzdFZlcnNpb25zKCk6IFR4UmVxdWVzdFZlcnNpb25bXSB7XG4gICAgY29uc3Qgd2FsbGV0VHlwZSA9IHRoaXMuX3dhbGxldD8udHlwZSgpO1xuICAgIGNvbnN0IHN1cHBvcnRlZFdhbGxldFR5cGVzID0gWydjdXN0b2RpYWwnLCAnY29sZCcsICdob3QnXTtcbiAgICBpZiAoIXdhbGxldFR5cGUgfHwgdGhpcy5fd2FsbGV0Py5tdWx0aXNpZ1R5cGUoKSAhPT0gJ3RzcycgfHwgIXN1cHBvcnRlZFdhbGxldFR5cGVzLmluY2x1ZGVzKHdhbGxldFR5cGUpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIGlmICh0aGlzLl93YWxsZXQ/LmJhc2VDb2luLmdldE1QQ0FsZ29yaXRobSgpID09PSAnZWNkc2EnKSB7XG4gICAgICByZXR1cm4gWydmdWxsJ107XG4gICAgfSBlbHNlIGlmICh3YWxsZXRUeXBlID09PSAnY3VzdG9kaWFsJyB8fCB3YWxsZXRUeXBlID09PSAnY29sZCcpIHtcbiAgICAgIHJldHVybiBbJ2Z1bGwnXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3dhbGxldD8uYmFzZUNvaW4uZ2V0TVBDQWxnb3JpdGhtKCkgPT09ICdlZGRzYScgJiYgd2FsbGV0VHlwZSA9PT0gJ2hvdCcpIHtcbiAgICAgIHJldHVybiBbJ2xpdGUnLCAnZnVsbCddO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0eFJlcXVlc3QgaXMgdXNpbmcgYXBpVmVyc2lvbiA9PSBmdWxsIGFuZCBpcyBwZW5kaW5nIGFwcHJvdmFsXG4gICAqIEBwYXJhbSB0eFJlcXVlc3RcbiAgICogQHJldHVybnMgYm9vbGVhblxuICAgKi9cbiAgaXNQZW5kaW5nQXBwcm92YWxUeFJlcXVlc3RGdWxsKHR4UmVxdWVzdDogVHhSZXF1ZXN0KTogYm9vbGVhbiB7XG4gICAgY29uc3QgeyBhcGlWZXJzaW9uLCBzdGF0ZSB9ID0gdHhSZXF1ZXN0O1xuICAgIHJldHVybiBhcGlWZXJzaW9uID09PSAnZnVsbCcgJiYgJ3BlbmRpbmdBcHByb3ZhbCcgPT09IHN0YXRlO1xuICB9XG59XG4iXX0=