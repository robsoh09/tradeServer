import { IRequestTracer } from '../../../api';
import { Key, SerializedKeyPair } from 'openpgp';
import { IBaseCoin, KeychainsTriplet } from '../../baseCoin';
import { BitGoBase } from '../../bitgoBase';
import { Keychain } from '../../keychain';
import { IWallet, BackupProvider } from '../../wallet';
import { MpcUtils } from '../mpcUtils';
import { BitgoHeldBackupKeyShare, CustomGShareGeneratingFunction, CustomRShareGeneratingFunction, ITssUtils, PrebuildTransactionWithIntentOptions, SignatureShareRecord, TSSParams, TxRequest, TxRequestVersion, CreateKeychainParamsBase, IntentOptionsForMessage, IntentOptionsForTypedData, CreateBitGoKeychainParamsBase, CommitmentShareRecord, EncryptedSignerShareRecord, CustomCommitmentGeneratingFunction, TSSParamsForMessage, RequestType, CustomPaillierModulusGetterFunction, CustomKShareGeneratingFunction, CustomMuDeltaShareGeneratingFunction, CustomSShareGeneratingFunction } from './baseTypes';
import { GShare, SignShare } from '../../../account-lib/mpc/tss';
/**
 * BaseTssUtil class which different signature schemes have to extend
 */
export default class BaseTssUtils<KeyShare> extends MpcUtils implements ITssUtils<KeyShare> {
    private _wallet?;
    constructor(bitgo: BitGoBase, baseCoin: IBaseCoin, wallet?: IWallet);
    get wallet(): IWallet;
    createBitgoHeldBackupKeyShare(userGpgKey: SerializedKeyPair<string>, enterprise: string | undefined): Promise<BitgoHeldBackupKeyShare>;
    finalizeBitgoHeldBackupKeyShare(keyId: string, commonKeychain: string, userKeyShare: KeyShare, bitgoKeychain: Keychain, userGpgKey: SerializedKeyPair<string>, backupGpgKey: Key): Promise<BitgoHeldBackupKeyShare>;
    createUserKeychain(params: CreateKeychainParamsBase): Promise<Keychain>;
    createBackupKeychain(params: CreateKeychainParamsBase): Promise<Keychain>;
    createBitgoKeychain(params: CreateBitGoKeychainParamsBase): Promise<Keychain>;
    createKeychains(params: {
        passphrase: string;
        enterprise?: string | undefined;
        originalPasscodeEncryptionCode?: string | undefined;
        isThirdPartyBackup?: boolean;
        backupProvider?: BackupProvider;
    }): Promise<KeychainsTriplet>;
    signTxRequest(params: TSSParams): Promise<TxRequest>;
    signTxRequestForMessage(params: TSSParams): Promise<TxRequest>;
    /**
     * Signs a transaction using TSS for EdDSA and through utilization of custom share generators
     *
     * @param {string | TxRequest} txRequest - transaction request with unsigned transaction
     * @param {CustomRShareGeneratingFunction} externalSignerRShareGenerator a function that creates R shares in the EdDSA TSS flow
     * @param {CustomGShareGeneratingFunction} externalSignerGShareGenerator a function that creates G shares in the EdDSA TSS flow
     * @returns {Promise<TxRequest>} - a signed tx request
     */
    signEddsaTssUsingExternalSigner(txRequest: string | TxRequest, externalSignerCommitmentGenerator: CustomCommitmentGeneratingFunction, externalSignerRShareGenerator: CustomRShareGeneratingFunction, externalSignerGShareGenerator: CustomGShareGeneratingFunction): Promise<TxRequest>;
    /**
     * Signs a transaction using TSS for ECDSA and through utilization of custom share generators
     *
     * @param {params: TSSParams | TSSParamsForMessage} params - params object that represents parameters to sign a transaction or a message.
     * @param {RequestType} requestType - the type of the request to sign (transaction or message).
     * @param {CustomPaillierModulusGetterFunction} externalSignerPaillierModulusGetter a function that creates Paillier Modulus shares in the ECDSA TSS flow.
     * @param {CustomKShareGeneratingFunction} externalSignerKShareGenerator a function that creates K shares in the ECDSA TSS flow.
     * @param {CustomMuDeltaShareGeneratingFunction} externalSignerMuDeltaShareGenerator a function that creates Mu and Delta shares in the ECDSA TSS flow.
     * @param {CustomSShareGeneratingFunction} externalSignerSShareGenerator a function that creates S shares in the ECDSA TSS flow.
     */
    signEcdsaTssUsingExternalSigner(params: TSSParams | TSSParamsForMessage, requestType: RequestType, externalSignerPaillierModulusGetter: CustomPaillierModulusGetterFunction, externalSignerKShareGenerator: CustomKShareGeneratingFunction, externalSignerMuDeltaShareGenerator: CustomMuDeltaShareGeneratingFunction, externalSignerSShareGenerator: CustomSShareGeneratingFunction): Promise<TxRequest>;
    /**
     * Create an Commitment (User to BitGo) share from an unsigned transaction and private user signing material
     * EDDSA only
     *
     * @param {Object} params - params object
     * @param {TxRequest} params.txRequest - transaction request with unsigned transaction
     * @param {string} params.prv - user signing material
     * @param {string} params.walletPassphrase - wallet passphrase
     *
     * @returns {Promise<{ userToBitgoCommitment: CommitmentShareRecor, encryptedSignerShare: EncryptedSignerShareRecord }>} - Commitment Share and the Encrypted Signer Share to BitGo
     */
    createCommitmentShareFromTxRequest(params: {
        txRequest: TxRequest;
        prv: string;
        walletPassphrase: string;
    }): Promise<{
        userToBitgoCommitment: CommitmentShareRecord;
        encryptedSignerShare: EncryptedSignerShareRecord;
        encryptedUserToBitgoRShare: EncryptedSignerShareRecord;
    }>;
    /**
     * Create an R (User to BitGo) share from an unsigned transaction and private user signing material
     *
     * @param {Object} params - params object
     * @param {TxRequest} params.txRequest - transaction request with unsigned transaction
     * @param {string} params.prv - user signing material
     * @param {string} [params.walletPassphrase] - wallet passphrase
     * @param {EncryptedSignerShareRecord} [params.encryptedUserToBitgoRShare] - encrypted user to bitgo R share generated in the commitment phase
     * @returns {Promise<{ rShare: SignShare }>} - R Share to BitGo
     */
    createRShareFromTxRequest(params: {
        txRequest: TxRequest;
        walletPassphrase: string;
        encryptedUserToBitgoRShare: EncryptedSignerShareRecord;
    }): Promise<{
        rShare: SignShare;
    }>;
    /**
     * Create a G (User to BitGo) share from an unsigned transaction and private user signing material
     *
     * @param {Object} params - params object
     * @param {TxRequest} params.txRequest - transaction request with unsigned transaction
     * @param {string} params.prv - user signing material
     * @param {SignatureShareRecord} params.bitgoToUserRShare - BitGo to User R Share
     * @param {SignShare} params.userToBitgoRShare - User to BitGo R Share
     * @param {CommitmentShareRecord} params.bitgoToUserCommitment - BitGo to User Commitment
     * @returns {Promise<GShare>} - GShare from User to BitGo
     */
    createGShareFromTxRequest(params: {
        txRequest: TxRequest;
        prv: string;
        bitgoToUserRShare: SignatureShareRecord;
        userToBitgoRShare: SignShare;
        bitgoToUserCommitment: CommitmentShareRecord;
    }): Promise<GShare>;
    /**
     * Builds a tx request from params and verify it
     *
     * @param {PrebuildTransactionWithIntentOptions} params - parameters to build the tx
     * @param {TxRequestVersion} apiVersion lite or full
     * @param {boolean} preview boolean indicating if this is to preview a tx request, which will not initiate policy checks or pending approvals
     * @returns {Promise<TxRequest>} - a built tx request
     */
    prebuildTxWithIntent(params: PrebuildTransactionWithIntentOptions, apiVersion?: TxRequestVersion, preview?: boolean): Promise<TxRequest>;
    /**
     * Create a tx request from params for message signing
     *
     * @param params
     * @param apiVersion
     * @param preview
     */
    createTxRequestWithIntentForMessageSigning(params: IntentOptionsForMessage, apiVersion?: TxRequestVersion, preview?: boolean): Promise<TxRequest>;
    /**
     * Create a tx request from params for type data signing
     *
     * @param params
     * @param apiVersion
     * @param preview
     */
    createTxRequestWithIntentForTypedDataSigning(params: IntentOptionsForTypedData, apiVersion?: TxRequestVersion, preview?: boolean): Promise<TxRequest>;
    /**
     * Calls Bitgo API to create tx request.
     *
     * @private
     */
    private createTxRequestBase;
    /**
     * Call delete signature shares for a txRequest, the endpoint delete the signatures and return them
     *
     * @param {string} txRequestId tx id reference to delete signature shares
     * @param {IRequestTracer} reqId - the request tracer request id
     * @returns {SignatureShareRecord[]}
     */
    deleteSignatureShares(txRequestId: string, reqId?: IRequestTracer): Promise<SignatureShareRecord[]>;
    /**
     * Initialize the send procedure once Bitgo has the User To Bitgo GShare
     *
     * @param {String} txRequestId - the txRequest Id
     * @param {IRequestTracer} reqId - the request tracer request id
     * @returns {Promise<any>}
     */
    sendTxRequest(txRequestId: string, reqId?: IRequestTracer): Promise<any>;
    /**
     * Delete signature shares, get the tx request without them from the db and sign it to finally send it.
     *
     * Note : This can be performed in order to reach latest network conditions required on pending approval flow.
     *
     * @param {String} txRequestId - the txRequest Id to make the requests.
     * @param {String} decryptedPrv - decrypted prv to sign the tx request.
     * @param {RequestTracer} reqId id tracer.
     * @returns {Promise<any>}
     */
    recreateTxRequest(txRequestId: string, decryptedPrv: string, reqId: IRequestTracer): Promise<TxRequest>;
    /**
     * Gets the latest Tx Request by id
     *
     * @param {String} txRequestId - the txRequest Id
     * @param {IRequestTracer} reqId - request tracer request id
     * @returns {Promise<TxRequest>}
     */
    getTxRequest(txRequestId: string, reqId?: IRequestTracer): Promise<TxRequest>;
    /**
     * Checks whether the third party backup provider is valid/supported
     * @param backupProvider - the backup provider client selected
     */
    isValidThirdPartyBackupProvider(backupProvider: BackupProvider | string | undefined): backupProvider is BackupProvider;
    /**
     * It gets the appropriate BitGo GPG public key for key creation based on a
     * combination of coin and the feature flags on the user and their enterprise if set.
     * @param enterpriseId - enterprise under which user wants to create the wallet
     * @param isMPCv2 - true to get the MPCv2 GPG public key, defaults to false
     */
    getBitgoGpgPubkeyBasedOnFeatureFlags(enterpriseId: string | undefined, isMPCv2?: boolean): Promise<Key>;
    /**
     * Returns supported TxRequest versions for this wallet
     */
    supportedTxRequestVersions(): TxRequestVersion[];
    /**
     * Returns true if the txRequest is using apiVersion == full and is pending approval
     * @param txRequest
     * @returns boolean
     */
    isPendingApprovalTxRequestFull(txRequest: TxRequest): boolean;
}
//# sourceMappingURL=baseTSSUtils.d.ts.map