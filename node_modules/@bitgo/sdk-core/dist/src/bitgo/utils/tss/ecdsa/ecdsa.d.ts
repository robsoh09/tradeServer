/// <reference types="node" />
import { Buffer } from 'buffer';
import * as openpgp from 'openpgp';
import { Key, SerializedKeyPair } from 'openpgp';
import { EcdsaTypes } from '@bitgo/sdk-lib-mpc';
import { ApiKeyShare, Keychain } from '../../../keychain';
import { KeychainsTriplet } from '../../../baseCoin';
import { BitGoProofSignatures, CreateEcdsaBitGoKeychainParams, CreateEcdsaKeychainParams, GetBitGoChallengesApi, KeyShare } from './types';
import { BackupKeyShare, BitgoHeldBackupKeyShare, CustomKShareGeneratingFunction, CustomMuDeltaShareGeneratingFunction, CustomPaillierModulusGetterFunction, CustomSShareGeneratingFunction, RequestType, TSSParams, TSSParamsForMessage, TxRequest } from '../baseTypes';
import { AShare, DShare, EncryptedNShare, SShare } from '../../../tss/ecdsa/types';
import { BitGoBase } from '../../../bitgoBase';
import { BackupProvider } from '../../../wallet';
import { TssEcdsaStep1ReturnMessage, TssEcdsaStep2ReturnMessage, TxRequestChallengeResponse } from '../../../tss/types';
import { BaseEcdsaUtils } from './base';
import { IRequestTracer } from '../../../../api';
/** @inheritdoc */
export declare class EcdsaUtils extends BaseEcdsaUtils {
    finalizeBitgoHeldBackupKeyShare(keyId: string, commonKeychain: string, userKeyShare: KeyShare, bitgoKeychain: Keychain, userGpgKey: SerializedKeyPair<string>, thirdPartyBackupPublicGpgKey: Key): Promise<BitgoHeldBackupKeyShare>;
    /** @inheritdoc */
    createKeychains(params: {
        passphrase: string;
        enterprise?: string | undefined;
        originalPasscodeEncryptionCode?: string | undefined;
        backupProvider?: BackupProvider;
    }): Promise<KeychainsTriplet>;
    /**
     * If a third party backup is requested, it will create backup shares from
     * a third party (BitGo as of now), otherwise the key shares will be client generated
     */
    createBackupKeyShares(isThirdPartyBackup: boolean | undefined, userGpgPubKey: SerializedKeyPair<string>, enterprise: string | undefined): Promise<BackupKeyShare>;
    createUserKeychain({ userGpgKey, backupGpgKey, bitgoPublicGpgKey, userKeyShare, backupKeyShare, bitgoKeychain, passphrase, originalPasscodeEncryptionCode, isThirdPartyBackup, }: CreateEcdsaKeychainParams): Promise<Keychain>;
    createBackupKeychain({ userGpgKey, userKeyShare, backupGpgKey, backupKeyShare, bitgoKeychain, bitgoPublicGpgKey, passphrase, backupProvider, }: CreateEcdsaKeychainParams): Promise<Keychain>;
    /** @inheritdoc */
    createBitgoKeychain({ userGpgKey, backupGpgKey, userKeyShare, backupKeyShare, enterprise, bitgoPublicGpgKey, isThirdPartyBackup, }: CreateEcdsaBitGoKeychainParams): Promise<Keychain>;
    /**
     * This builds the relevant backup encryptedNShare based on whether the
     * backup key is user or third party generated
     * @param backupShare can either have key shares from the user or third party
     * @param recipientIndex index of the party receiving the backup shares
     * @param recipientGpgPublicArmor gpg armor of the party receiving the backup shares
     * @param backupGpgKey backup gpg key
     * @param isThirdPartyBackup whether the backup is generated by third party
     */
    getBackupEncryptedNShare(backupShare: BackupKeyShare, recipientIndex: number, recipientGpgPublicArmor: string, backupGpgKey: SerializedKeyPair<string>, isThirdPartyBackup?: boolean): Promise<EncryptedNShare>;
    /**
     * This uses the backup key from a third party (bitgo in this case)
     * to create the user keychain via WP.
     */
    createUserKeychainFromThirdPartyBackup(userGpgKey: openpgp.SerializedKeyPair<string>, bitgoPublicGpgKey: Key, thirdPartyBackupPublicGpgKey: Key, userKeyShare: KeyShare, thirdPartybackupKeyShares: ApiKeyShare[], bitgoKeychain: Keychain, passphrase: string, originalPasscodeEncryptionCode?: string): Promise<Keychain>;
    /** @inheritdoc */
    createParticipantKeychain(userGpgKey: openpgp.SerializedKeyPair<string>, userLocalBackupGpgKey: openpgp.SerializedKeyPair<string>, bitgoPublicGpgKey: Key, recipientIndex: number, userKeyShare: KeyShare, backupKeyShare: KeyShare, bitgoKeychain: Keychain, passphrase: string, originalPasscodeEncryptionCode?: string): Promise<Keychain>;
    private createTssEcdsaStep1SigningMaterial;
    private createTssEcdsaStep2SigningMaterial;
    getOfflineSignerPaillierModulus(params: {
        prv: string;
    }): {
        userPaillierModulus: string;
    };
    createOfflineKShare(params: {
        tssParams: TSSParams | TSSParamsForMessage;
        challenges: {
            enterpriseChallenge: EcdsaTypes.SerializedEcdsaChallenges;
            bitgoChallenge: TxRequestChallengeResponse;
        };
        requestType: RequestType;
        prv: string;
        walletPassphrase: string;
    }): Promise<TssEcdsaStep1ReturnMessage>;
    createOfflineMuDeltaShare(params: {
        aShareFromBitgo: Omit<AShare, 'ntilde' | 'h1' | 'h2'>;
        bitgoChallenge: TxRequestChallengeResponse;
        encryptedWShare: string;
        walletPassphrase: string;
    }): Promise<TssEcdsaStep2ReturnMessage>;
    createOfflineSShare(params: {
        tssParams: TSSParams | TSSParamsForMessage;
        dShareFromBitgo: DShare;
        requestType: RequestType;
        encryptedOShare: string;
        walletPassphrase: string;
    }): Promise<SShare>;
    signEcdsaTssUsingExternalSigner(params: TSSParams | TSSParamsForMessage, requestType: RequestType, externalSignerPaillierModulusGetter: CustomPaillierModulusGetterFunction, externalSignerKShareGenerator: CustomKShareGeneratingFunction, externalSignerMuDeltaShareGenerator: CustomMuDeltaShareGeneratingFunction, externalSignerSShareGenerator: CustomSShareGeneratingFunction): Promise<TxRequest>;
    /**
     * Gets signing key, txRequestResolved and txRequestId
     * @param {string | TxRequest} params.txRequest - transaction request object or id
     * @param {string} params.prv - decrypted private key
     * @param { string} params.reqId - request id
     * @returns {Promise<TxRequest>}
     */
    private signRequestBase;
    /**
     * Signs the transaction associated to the transaction request.
     * @param {string | TxRequest} params.txRequest - transaction request object or id
     * @param {string} params.prv - decrypted private key
     * @param {string} params.reqId - request id
     * @returns {Promise<TxRequest>} fully signed TxRequest object
     */
    signTxRequest(params: TSSParams): Promise<TxRequest>;
    /**
     * Signs the message associated to the transaction request.
     * @param {string | TxRequest} params.txRequest - transaction request object or id
     * @param {string} params.prv - decrypted private key
     * @param {string} params.reqId - request id
     * @returns {Promise<TxRequest>} fully signed TxRequest object
     */
    signTxRequestForMessage(params: TSSParamsForMessage): Promise<TxRequest>;
    /**
     * Get the challenge values for enterprise and BitGo in ECDSA signing
     * Only returns the challenges if they are verified by the user's enterprise admin's ecdh key
     * @param {string} txRequestId - transaction request id
     * @param {RequestType} requestType -  (0 for tx, 1 for message)
     * @param {string} walletPaillierModulus - paillier pubkey $n$
     * @param {number} index - index of the requestType
     * @param {IRequestTracer} reqId - request tracer request id
     */
    getEcdsaSigningChallenges(txRequestId: string, requestType: RequestType, walletPaillierModulus: string, index?: number, reqId?: IRequestTracer): Promise<{
        enterpriseChallenge: EcdsaTypes.SerializedEcdsaChallenges;
        bitgoChallenge: TxRequestChallengeResponse;
    }>;
    /**
     * Verifies the u-value proofs and GPG keys used in generating a TSS ECDSA wallet.
     * @param userGpgPub The user's public GPG key for encryption between user/server
     * @param backupGpgPub The backup's public GPG key for encryption between backup/server
     * @param bitgoKeychain previously created BitGo keychain; must be compatible with user and backup key shares
     * @param decryptedShare The decrypted bitgo-to-user/backup private share retrieved from the keychain
     * @param verifierIndex The index of the party to verify: 1 = user, 2 = backup
     */
    verifyWalletSignatures(userGpgPub: string, backupGpgPub: string, bitgoKeychain: Keychain, decryptedShare: string, verifierIndex: 1 | 2): Promise<void>;
    /**
     * Signs a challenge with the provided v1 ecdh key at a derived path
     * @param challenge challenge to sign
     * @param ecdhXprv xprv of the ecdh key
     * @param derivationPath the derived path at which the ecdh key will sign
     */
    static signChallenge(challenge: EcdsaTypes.SerializedNtilde, ecdhXprv: string, derivationPath: string): Buffer;
    /**
     * Converts challenge to a common message format which can be signed.
     * @param challenge
     */
    static getMessageToSignFromChallenge(challenge: EcdsaTypes.SerializedNtilde): string;
    /**
     Verifies ZK proofs of BitGo's challenges for both nitro and institutional HSMs
     which are fetched from the WP API.
     */
    static verifyBitGoChallenges(bitgoChallenges: GetBitGoChallengesApi): Promise<boolean>;
    /**
     * Verifies ZK proof for a single BitGo challenge
     * @param bitgoChallenge
     */
    static verifyBitGoChallenge(bitgoChallenge: EcdsaTypes.SerializedNtildeWithProofs): Promise<boolean>;
    /**
     * Gets the bitgo challenges for both nitro and institutional HSMs from WP API.
     * @param bitgo
     */
    static getBitGoChallenges(bitgo: BitGoBase): Promise<GetBitGoChallengesApi>;
    /**
     * Gets BitGo's proofs from API and signs them if the proofs are valid.
     * @param bitgo
     * @param enterpriseId
     * @param userPassword
     */
    static getVerifyAndSignBitGoChallenges(bitgo: BitGoBase, enterpriseId: string, userPassword: string): Promise<BitGoProofSignatures>;
    /**
     * Sign Bitgo's proofs, verification of proofs is left to the caller
     * @param bitgo
     * @param enterpriseId
     * @param userPassword
     * @param bitgoChallengesWithProofs Optionally provide Bitgo Challaenge & Proofs instead of fetching from API
     */
    static signBitgoChallenges(bitgo: BitGoBase, enterpriseId: string, userPassword: string, bitgoChallengesWithProofs?: GetBitGoChallengesApi): Promise<BitGoProofSignatures>;
    /**
     * This is needed to enable ecdsa signing on the enterprise.
     * It receives the enterprise challenge and signatures of verified bitgo proofs
     * and uploads them on the enterprise.
     * @param bitgo
     * @param entId - enterprise id to enable ecdsa signing on
     * @param userPassword - enterprise admin's login pw
     * @param bitgoInstChallengeProofSignature - signature on bitgo's institutional HSM challenge after verification
     * @param bitgoNitroChallengeProofSignature - signature on bitgo's nitro HSM challenge after verification
     * @param challenge - optionally use the challenge for enterprise challenge
     */
    static initiateChallengesForEnterprise(bitgo: BitGoBase, entId: string, userPassword: string, bitgoInstChallengeProofSignature: Buffer, bitgoNitroChallengeProofSignature: Buffer, challenge?: EcdsaTypes.DeserializedNtildeWithProofs): Promise<void>;
    /**
     * Uploads the signed challenges and their proofs on the enterprise.
     * This initiates ecdsa signing for the enterprise users.
     * @param bitgo
     * @param entId - enterprise to enable ecdsa signing on
     * @param entChallenge - client side generated ent challenge with ZK proofs
     * @param entChallengeSignature - signature on enterprise challenge
     * @param bitgoIntChallengeSignature - signature on BitGo's institutional HSM challenge
     * @param bitgoNitroChallengeSignature - signature on BitGo's nitro HSM challenge
     */
    static uploadChallengesToEnterprise(bitgo: BitGoBase, entId: string, entChallenge: EcdsaTypes.SerializedNtilde | EcdsaTypes.SerializedNtildeWithProofs, entChallengeSignature: string, bitgoIntChallengeSignature: string, bitgoNitroChallengeSignature: string): Promise<void>;
}
//# sourceMappingURL=ecdsa.d.ts.map