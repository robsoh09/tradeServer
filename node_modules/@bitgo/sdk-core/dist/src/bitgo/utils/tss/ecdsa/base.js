"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseEcdsaUtils = void 0;
const elliptic_1 = require("elliptic");
const baseTSSUtils_1 = __importDefault(require("../baseTSSUtils"));
const opengpgUtils_1 = require("../../opengpgUtils");
/** @inheritdoc */
class BaseEcdsaUtils extends baseTSSUtils_1.default {
    constructor(bitgo, baseCoin, wallet) {
        super(bitgo, baseCoin, wallet);
        this.setBitgoGpgPubKey(bitgo);
    }
    async setBitgoGpgPubKey(bitgo) {
        const { mpcV1, mpcV2 } = await (0, opengpgUtils_1.getBitgoGpgPubKey)(bitgo);
        this.bitgoPublicGpgKey = mpcV1;
        this.bitgoMPCv2PublicGpgKey = mpcV2;
    }
    async getBitgoPublicGpgKey() {
        if (!this.bitgoPublicGpgKey) {
            // retry getting bitgo's gpg key
            await this.setBitgoGpgPubKey(this.bitgo);
            if (!this.bitgoPublicGpgKey) {
                throw new Error("Failed to get Bitgo's gpg key");
            }
        }
        return this.bitgoPublicGpgKey;
    }
    /**
     * Gets backup pub gpg key string
     * if a third party provided then get from trust
     * @param isThirdPartyBackup
     */
    async getBackupGpgPubKey(isThirdPartyBackup = false) {
        return isThirdPartyBackup ? (0, opengpgUtils_1.getTrustGpgPubKey)(this.bitgo) : (0, opengpgUtils_1.generateGPGKeyPair)('secp256k1');
    }
    /**
     * util function that checks that a commonKeychain is valid and can ultimately resolve to a valid public key
     * @param commonKeychain - a user uploaded commonKeychain string
     * @throws if the commonKeychain is invalid length or invalid format
     */
    static validateCommonKeychainPublicKey(commonKeychain) {
        const pub = BaseEcdsaUtils.getPublicKeyFromCommonKeychain(commonKeychain);
        const secp256k1 = new elliptic_1.ec('secp256k1');
        const key = secp256k1.keyFromPublic(pub, 'hex');
        return key.getPublic().encode('hex', false).slice(2);
    }
    /**
     * Gets the common public key from commonKeychain.
     *
     * @param {String} commonKeychain common key chain between n parties
     * @returns {string} encoded public key
     */
    static getPublicKeyFromCommonKeychain(commonKeychain) {
        if (commonKeychain.length !== 130) {
            throw new Error(`Invalid commonKeychain length, expected 130, got ${commonKeychain.length}`);
        }
        const commonPubHexStr = commonKeychain.slice(0, 66);
        return commonPubHexStr;
    }
}
exports.BaseEcdsaUtils = BaseEcdsaUtils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9iaXRnby91dGlscy90c3MvZWNkc2EvYmFzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSx1Q0FBOEI7QUFHOUIsbUVBQTJDO0FBRzNDLHFEQUE4RjtBQUk5RixrQkFBa0I7QUFDbEIsTUFBYSxjQUFlLFNBQVEsc0JBQXNCO0lBS3hELFlBQVksS0FBZ0IsRUFBRSxRQUFtQixFQUFFLE1BQWdCO1FBQ2pFLEtBQUssQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQy9CLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRU8sS0FBSyxDQUFDLGlCQUFpQixDQUFDLEtBQUs7UUFDbkMsTUFBTSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsR0FBRyxNQUFNLElBQUEsZ0NBQWlCLEVBQUMsS0FBSyxDQUFDLENBQUM7UUFDeEQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLEtBQUssQ0FBQztRQUMvQixJQUFJLENBQUMsc0JBQXNCLEdBQUcsS0FBSyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxLQUFLLENBQUMsb0JBQW9CO1FBQ3hCLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDM0IsZ0NBQWdDO1lBQ2hDLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFO2dCQUMzQixNQUFNLElBQUksS0FBSyxDQUFDLCtCQUErQixDQUFDLENBQUM7YUFDbEQ7U0FDRjtRQUVELE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDO0lBQ2hDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLGtCQUFrQixDQUFDLGtCQUFrQixHQUFHLEtBQUs7UUFDakQsT0FBTyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsSUFBQSxnQ0FBaUIsRUFBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUEsaUNBQWtCLEVBQUMsV0FBVyxDQUFDLENBQUM7SUFDOUYsQ0FBQztJQUVEOzs7O09BSUc7SUFFSCxNQUFNLENBQUMsK0JBQStCLENBQUMsY0FBc0I7UUFDM0QsTUFBTSxHQUFHLEdBQUcsY0FBYyxDQUFDLDhCQUE4QixDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQzFFLE1BQU0sU0FBUyxHQUFHLElBQUksYUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3RDLE1BQU0sR0FBRyxHQUFHLFNBQVMsQ0FBQyxhQUFhLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ2hELE9BQU8sR0FBRyxDQUFDLFNBQVMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyw4QkFBOEIsQ0FBQyxjQUFzQjtRQUMxRCxJQUFJLGNBQWMsQ0FBQyxNQUFNLEtBQUssR0FBRyxFQUFFO1lBQ2pDLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1NBQzlGO1FBQ0QsTUFBTSxlQUFlLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDcEQsT0FBTyxlQUFlLENBQUM7SUFDekIsQ0FBQztDQUNGO0FBL0RELHdDQStEQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG9wZW5wZ3AgZnJvbSAnb3BlbnBncCc7XG5pbXBvcnQgeyBlYyB9IGZyb20gJ2VsbGlwdGljJztcblxuaW1wb3J0IHsgSUJhc2VDb2luIH0gZnJvbSAnLi4vLi4vLi4vYmFzZUNvaW4nO1xuaW1wb3J0IGJhc2VUU1NVdGlscyBmcm9tICcuLi9iYXNlVFNTVXRpbHMnO1xuaW1wb3J0IHsgS2V5U2hhcmUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IEJhY2t1cEdwZ0tleSB9IGZyb20gJy4uL2Jhc2VUeXBlcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUdQR0tleVBhaXIsIGdldEJpdGdvR3BnUHViS2V5LCBnZXRUcnVzdEdwZ1B1YktleSB9IGZyb20gJy4uLy4uL29wZW5ncGdVdGlscyc7XG5pbXBvcnQgeyBCaXRHb0Jhc2UgfSBmcm9tICcuLi8uLi8uLi9iaXRnb0Jhc2UnO1xuaW1wb3J0IHsgSVdhbGxldCB9IGZyb20gJy4uLy4uLy4uL3dhbGxldCc7XG5cbi8qKiBAaW5oZXJpdGRvYyAqL1xuZXhwb3J0IGNsYXNzIEJhc2VFY2RzYVV0aWxzIGV4dGVuZHMgYmFzZVRTU1V0aWxzPEtleVNoYXJlPiB7XG4gIC8vIFdlIGRvIG5vdCBoYXZlIGZ1bGwgc3VwcG9ydCBmb3IgMy1wYXJ0eSB2ZXJpZmljYXRpb24gKHcvIGV4dGVybmFsIHNvdXJjZSkgb2Yga2V5IHNoYXJlcyBhbmQgc2lnbmF0dXJlIHNoYXJlcy4gVGhlcmUgaXMgbm8gM3JkIHBhcnR5IGtleSBzZXJ2aWNlIHN1cHBvcnQgd2l0aCB0aGlzIHJlbGVhc2UuXG4gIHByb3RlY3RlZCBiaXRnb1B1YmxpY0dwZ0tleTogb3BlbnBncC5LZXk7XG4gIHByb3RlY3RlZCBiaXRnb01QQ3YyUHVibGljR3BnS2V5OiBvcGVucGdwLktleSB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlLCBiYXNlQ29pbjogSUJhc2VDb2luLCB3YWxsZXQ/OiBJV2FsbGV0KSB7XG4gICAgc3VwZXIoYml0Z28sIGJhc2VDb2luLCB3YWxsZXQpO1xuICAgIHRoaXMuc2V0Qml0Z29HcGdQdWJLZXkoYml0Z28pO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzZXRCaXRnb0dwZ1B1YktleShiaXRnbykge1xuICAgIGNvbnN0IHsgbXBjVjEsIG1wY1YyIH0gPSBhd2FpdCBnZXRCaXRnb0dwZ1B1YktleShiaXRnbyk7XG4gICAgdGhpcy5iaXRnb1B1YmxpY0dwZ0tleSA9IG1wY1YxO1xuICAgIHRoaXMuYml0Z29NUEN2MlB1YmxpY0dwZ0tleSA9IG1wY1YyO1xuICB9XG5cbiAgYXN5bmMgZ2V0Qml0Z29QdWJsaWNHcGdLZXkoKTogUHJvbWlzZTxvcGVucGdwLktleT4ge1xuICAgIGlmICghdGhpcy5iaXRnb1B1YmxpY0dwZ0tleSkge1xuICAgICAgLy8gcmV0cnkgZ2V0dGluZyBiaXRnbydzIGdwZyBrZXlcbiAgICAgIGF3YWl0IHRoaXMuc2V0Qml0Z29HcGdQdWJLZXkodGhpcy5iaXRnbyk7XG4gICAgICBpZiAoIXRoaXMuYml0Z29QdWJsaWNHcGdLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCBCaXRnbydzIGdwZyBrZXlcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYml0Z29QdWJsaWNHcGdLZXk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBiYWNrdXAgcHViIGdwZyBrZXkgc3RyaW5nXG4gICAqIGlmIGEgdGhpcmQgcGFydHkgcHJvdmlkZWQgdGhlbiBnZXQgZnJvbSB0cnVzdFxuICAgKiBAcGFyYW0gaXNUaGlyZFBhcnR5QmFja3VwXG4gICAqL1xuICBhc3luYyBnZXRCYWNrdXBHcGdQdWJLZXkoaXNUaGlyZFBhcnR5QmFja3VwID0gZmFsc2UpOiBQcm9taXNlPEJhY2t1cEdwZ0tleT4ge1xuICAgIHJldHVybiBpc1RoaXJkUGFydHlCYWNrdXAgPyBnZXRUcnVzdEdwZ1B1YktleSh0aGlzLmJpdGdvKSA6IGdlbmVyYXRlR1BHS2V5UGFpcignc2VjcDI1NmsxJyk7XG4gIH1cblxuICAvKipcbiAgICogdXRpbCBmdW5jdGlvbiB0aGF0IGNoZWNrcyB0aGF0IGEgY29tbW9uS2V5Y2hhaW4gaXMgdmFsaWQgYW5kIGNhbiB1bHRpbWF0ZWx5IHJlc29sdmUgdG8gYSB2YWxpZCBwdWJsaWMga2V5XG4gICAqIEBwYXJhbSBjb21tb25LZXljaGFpbiAtIGEgdXNlciB1cGxvYWRlZCBjb21tb25LZXljaGFpbiBzdHJpbmdcbiAgICogQHRocm93cyBpZiB0aGUgY29tbW9uS2V5Y2hhaW4gaXMgaW52YWxpZCBsZW5ndGggb3IgaW52YWxpZCBmb3JtYXRcbiAgICovXG5cbiAgc3RhdGljIHZhbGlkYXRlQ29tbW9uS2V5Y2hhaW5QdWJsaWNLZXkoY29tbW9uS2V5Y2hhaW46IHN0cmluZykge1xuICAgIGNvbnN0IHB1YiA9IEJhc2VFY2RzYVV0aWxzLmdldFB1YmxpY0tleUZyb21Db21tb25LZXljaGFpbihjb21tb25LZXljaGFpbik7XG4gICAgY29uc3Qgc2VjcDI1NmsxID0gbmV3IGVjKCdzZWNwMjU2azEnKTtcbiAgICBjb25zdCBrZXkgPSBzZWNwMjU2azEua2V5RnJvbVB1YmxpYyhwdWIsICdoZXgnKTtcbiAgICByZXR1cm4ga2V5LmdldFB1YmxpYygpLmVuY29kZSgnaGV4JywgZmFsc2UpLnNsaWNlKDIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvbW1vbiBwdWJsaWMga2V5IGZyb20gY29tbW9uS2V5Y2hhaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb21tb25LZXljaGFpbiBjb21tb24ga2V5IGNoYWluIGJldHdlZW4gbiBwYXJ0aWVzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGVuY29kZWQgcHVibGljIGtleVxuICAgKi9cbiAgc3RhdGljIGdldFB1YmxpY0tleUZyb21Db21tb25LZXljaGFpbihjb21tb25LZXljaGFpbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoY29tbW9uS2V5Y2hhaW4ubGVuZ3RoICE9PSAxMzApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb21tb25LZXljaGFpbiBsZW5ndGgsIGV4cGVjdGVkIDEzMCwgZ290ICR7Y29tbW9uS2V5Y2hhaW4ubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjb21tb25QdWJIZXhTdHIgPSBjb21tb25LZXljaGFpbi5zbGljZSgwLCA2Nik7XG4gICAgcmV0dXJuIGNvbW1vblB1YkhleFN0cjtcbiAgfVxufVxuIl19