import { SignShare, GShare } from '../../../../account-lib/mpc/tss';
import { Keychain } from '../../../keychain';
import { CommitmentShareRecord, CustomCommitmentGeneratingFunction, CustomGShareGeneratingFunction, CustomRShareGeneratingFunction, EncryptedSignerShareRecord, SignatureShareRecord, TSSParams, TxRequest } from '../baseTypes';
import { CreateEddsaBitGoKeychainParams, CreateEddsaKeychainParams, KeyShare } from './types';
import baseTSSUtils from '../baseTSSUtils';
import { KeychainsTriplet } from '../../../baseCoin';
import { IRequestTracer } from '../../../../api';
/**
 * Utility functions for TSS work flows.
 */
export declare class EddsaUtils extends baseTSSUtils<KeyShare> {
    verifyWalletSignatures(userGpgPub: string, backupGpgPub: string, bitgoKeychain: Keychain, decryptedShare: string, verifierIndex: 1 | 2): Promise<void>;
    /**
     * Creates a Keychain containing the User's TSS signing materials.
     * We need to have the passphrase be optional to allow for the client to store their backup key on their premises
     *
     * @param userGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between user and server
     * @param userKeyShare - user's TSS key share
     * @param backupKeyShare - backup's TSS key share
     * @param bitgoKeychain - previously created BitGo keychain; must be compatible with user and backup key shares
     * @param [passphrase] - optional wallet passphrase used to encrypt user's signing materials
     * @param [originalPasscodeEncryptionCode] - optional encryption code needed for wallet password reset for hot wallets
     */
    createUserKeychain({ userGpgKey, backupGpgKey, userKeyShare, backupKeyShare, bitgoKeychain, passphrase, originalPasscodeEncryptionCode, }: CreateEddsaKeychainParams): Promise<Keychain>;
    /**
     * Creates a Keychain containing the Backup party's TSS signing materials.
     * We need to have the passphrase be optional to allow for the client to store their backup key on their premises
     *
     * @param userGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between user and server
     * @param userKeyShare - User's TSS Keyshare
     * @param backupGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between backup and server
     * @param backupKeyShare - Backup's TSS Keyshare
     * @param bitgoKeychain - previously created BitGo keychain; must be compatible with user and backup key shares
     * @param [passphrase] - optional wallet passphrase used to encrypt user's signing materials
     */
    createBackupKeychain({ userGpgKey, backupGpgKey, userKeyShare, backupKeyShare, bitgoKeychain, passphrase, }: CreateEddsaKeychainParams): Promise<Keychain>;
    /**
     * Creates a Keychain containing BitGo's TSS signing materials.
     *
     * @param userGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between user and server
     * @param userKeyShare - user's TSS key share
     * @param backupKeyShare - backup's TSS key share
     * @param enterprise - enterprise associated to the wallet
     */
    createBitgoKeychain({ userGpgKey, backupGpgKey, userKeyShare, backupKeyShare, enterprise, }: CreateEddsaBitGoKeychainParams): Promise<Keychain>;
    /**
     * Creates User, Backup, and BitGo TSS Keychains.
     *
     * @param params.passphrase - passphrase used to encrypt signing materials created for User and Backup
     */
    createKeychains(params: {
        passphrase?: string;
        enterprise?: string;
        originalPasscodeEncryptionCode?: string;
    }): Promise<KeychainsTriplet>;
    createCommitmentShareFromTxRequest(params: {
        txRequest: TxRequest;
        prv: string;
        walletPassphrase: string;
    }): Promise<{
        userToBitgoCommitment: CommitmentShareRecord;
        encryptedSignerShare: EncryptedSignerShareRecord;
        encryptedUserToBitgoRShare: EncryptedSignerShareRecord;
    }>;
    createRShareFromTxRequest(params: {
        txRequest: TxRequest;
        walletPassphrase: string;
        encryptedUserToBitgoRShare: EncryptedSignerShareRecord;
    }): Promise<{
        rShare: SignShare;
    }>;
    createGShareFromTxRequest(params: {
        txRequest: string | TxRequest;
        prv: string;
        bitgoToUserRShare: SignatureShareRecord;
        userToBitgoRShare: SignShare;
        bitgoToUserCommitment: CommitmentShareRecord;
    }): Promise<GShare>;
    signEddsaTssUsingExternalSigner(txRequest: string | TxRequest, externalSignerCommitmentGenerator: CustomCommitmentGeneratingFunction, externalSignerRShareGenerator: CustomRShareGeneratingFunction, externalSignerGShareGenerator: CustomGShareGeneratingFunction, reqId?: IRequestTracer): Promise<TxRequest>;
    /**
     * Signs the transaction associated to the transaction request.
     *
     * @param txRequest - transaction request object or id
     * @param prv - decrypted private key
     * @param reqId - request id
     * @returns {Promise<TxRequest>} fully signed TxRequest object
     */
    signTxRequest(params: TSSParams): Promise<TxRequest>;
    /**
     * Get the commonPub portion of the commonKeychain.
     *
     * @param {String} commonKeychain
     * @returns {string}
     */
    static getPublicKeyFromCommonKeychain(commonKeychain: string): string;
    createUserToBitgoCommitmentShare(commitment: string): CommitmentShareRecord;
    createUserToBitgoEncryptedSignerShare(encryptedSignerShare: string): EncryptedSignerShareRecord;
    createUserToBitgoEncryptedRShare(encryptedRShare: string): EncryptedSignerShareRecord;
}
/**
 * @deprecated - use EddsaUtils
 */
export declare const TssUtils: typeof EddsaUtils;
//# sourceMappingURL=eddsa.d.ts.map