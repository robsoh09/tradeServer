import * as openpgp from 'openpgp';
import { IBaseCoin } from '../../../baseCoin';
import baseTSSUtils from '../baseTSSUtils';
import { KeyShare } from './types';
import { BackupGpgKey } from '../baseTypes';
import { BitGoBase } from '../../../bitgoBase';
import { IWallet } from '../../../wallet';
/** @inheritdoc */
export declare class BaseEcdsaUtils extends baseTSSUtils<KeyShare> {
    protected bitgoPublicGpgKey: openpgp.Key;
    protected bitgoMPCv2PublicGpgKey: openpgp.Key | undefined;
    constructor(bitgo: BitGoBase, baseCoin: IBaseCoin, wallet?: IWallet);
    private setBitgoGpgPubKey;
    getBitgoPublicGpgKey(): Promise<openpgp.Key>;
    /**
     * Gets backup pub gpg key string
     * if a third party provided then get from trust
     * @param isThirdPartyBackup
     */
    getBackupGpgPubKey(isThirdPartyBackup?: boolean): Promise<BackupGpgKey>;
    /**
     * util function that checks that a commonKeychain is valid and can ultimately resolve to a valid public key
     * @param commonKeychain - a user uploaded commonKeychain string
     * @throws if the commonKeychain is invalid length or invalid format
     */
    static validateCommonKeychainPublicKey(commonKeychain: string): string;
    /**
     * Gets the common public key from commonKeychain.
     *
     * @param {String} commonKeychain common key chain between n parties
     * @returns {string} encoded public key
     */
    static getPublicKeyFromCommonKeychain(commonKeychain: string): string;
}
//# sourceMappingURL=base.d.ts.map