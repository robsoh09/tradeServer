import { IBaseCoin, NFTTransferOptions, SignedMessage, SignedTransaction } from '../baseCoin';
import { BitGoBase } from '../bitgoBase';
import { KeychainWithEncryptedPrv } from '../keychain';
import { IPendingApproval } from '../pendingApproval';
import { TradingAccount } from '../trading';
import { TxRequest } from '../utils';
import { AccelerateTransactionOptions, AddressesOptions, BuildConsolidationTransactionOptions, BuildTokenEnablementOptions, ChangeFeeOptions, ConsolidateUnspentsOptions, CreateAddressOptions, CreatePolicyRuleOptions, CreateShareOptions, CrossChainUTXO, DeployForwardersOptions, DownloadKeycardOptions, FanoutUnspentsOptions, FetchCrossChainUTXOsOptions, FlushForwarderTokenOptions, ForwarderBalance, ForwarderBalanceOptions, FreezeOptions, FundForwardersOptions, GetAddressOptions, GetPrvOptions, GetTransactionOptions, GetTransferOptions, GetUserPrvOptions, IWallet, MaximumSpendable, MaximumSpendableOptions, ModifyWebhookOptions, NftBalance, PaginationOptions, PrebuildAndSignTransactionOptions, PrebuildTransactionOptions, PrebuildTransactionResult, RecoverTokenOptions, RemovePolicyRuleOptions, RemoveUserOptions, SendManyOptions, SendNFTOptions, SendNFTResult, SendOptions, ShareWalletOptions, SimulateWebhookOptions, SubmitTransactionOptions, SubWalletType, SweepOptions, TransferBySequenceIdOptions, TransferCommentOptions, TransfersOptions, UnspentsOptions, UpdateAddressOptions, UpdateBuildDefaultOptions, WalletCoinSpecific, WalletData, WalletEcdsaChallenges, WalletSignMessageOptions, WalletSignTransactionOptions, WalletSignTypedDataOptions, WalletType } from './iWallet';
import { StakingWallet } from '../staking';
import { Lightning } from '../lightning';
import { IAddressBook } from '../address-book';
import { IRequestTracer } from '../../api';
export declare enum ManageUnspentsOptions {
    BUILD_ONLY = 0,
    BUILD_SIGN_SEND = 1
}
export declare class Wallet implements IWallet {
    readonly bitgo: BitGoBase;
    readonly baseCoin: IBaseCoin;
    _wallet: WalletData;
    private readonly tssUtils;
    private readonly _permissions?;
    constructor(bitgo: BitGoBase, baseCoin: IBaseCoin, walletData: any);
    /**
     * Build a URL using this wallet's id which can be used for BitGo API operations
     * @param extra API specific string to append to the wallet id
     */
    url(extra?: string): string;
    /**
     * Get this wallet's id
     */
    id(): string;
    /**
     * Get the number of approvals required for spending funds from this wallet
     */
    approvalsRequired(): number;
    /**
     * Get the current balance of this wallet
     */
    balance(): number;
    /** @deprecated use codec instead: t.exact(BuildParams).encode(v) */
    prebuildWhitelistedParams(): string[];
    /**
     * This is a strict sub-set of prebuildWhitelistedParams
     */
    prebuildConsolidateAccountParams(): string[];
    /**
     * Get the confirmed balance of this wallet
     */
    confirmedBalance(): number;
    /**
     * Get the spendable balance of this wallet
     */
    spendableBalance(): number;
    /**
     * Get a string representation of the balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    balanceString(): string;
    /**
     * Get a string representation of the confirmed balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    confirmedBalanceString(): string;
    /**
     * Get a string representation of the spendable balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    spendableBalanceString(): string;
    /**
     * Get the coin identifier for the type of coin this wallet holds
     */
    coin(): string;
    type(): WalletType | undefined;
    multisigType(): 'onchain' | 'tss';
    multisigTypeVersion(): 'MPCv2' | undefined;
    subType(): SubWalletType | undefined;
    /**
     * Get the label (name) for this wallet
     */
    label(): string;
    flags(): {
        name: string;
        value: string;
    }[];
    flag(name: string): string | undefined;
    /**
     * Get the public object ids for the keychains on this wallet.
     */
    keyIds(): string[];
    /**
     * Get a receive address for this wallet
     */
    receiveAddress(): string;
    /**
     * Get the wallet id of the wallet that this wallet was migrated from.
     *
     * For example, if this is a BCH wallet that was created from a BTC wallet,
     * the BCH wallet migrated from field would have the BTC wallet id.
     */
    migratedFrom(): string | undefined;
    /**
     * Return the token flush thresholds for this wallet
     * @return {*|Object} pairs of { [tokenName]: thresholds } base units
     */
    tokenFlushThresholds(): any;
    /**
     * Get wallet properties which are specific to certain coin implementations
     */
    coinSpecific(): WalletCoinSpecific | undefined;
    /**
     * Get all pending approvals on this wallet
     */
    pendingApprovals(): IPendingApproval[];
    /**
     * Refresh the wallet object by syncing with the back-end
     * @param params
     * @returns {Wallet}
     */
    refresh(params?: Record<string, never>): Promise<Wallet>;
    /**
     * List the transactions for a given wallet
     * @param params
     * @returns {*}
     */
    transactions(params?: PaginationOptions): Promise<any>;
    /**
     * Return a list of nft tokens for this wallet. Will always return undefined if the wallet
     * was not initialized with the allTokens flag.
     *
     * @returns {NftBalance[] | undefined}
     */
    nftBalances(): NftBalance[] | undefined;
    /**
     * Return a list of unsupported nft tokens for this wallet. Will always return undefined if the wallet
     * was not initialized with the allTokens flag.
     *
     * @returns {NftBalance[] | undefined}
     */
    unsupportedNftBalances(): NftBalance[] | undefined;
    /**
     * Returns a list of the wallets nft & unsupported nfts.
     *
     * @returns {NftBalance[]}
     */
    getNftBalances(): Promise<NftBalance[]>;
    /**
     * List the transactions for a given wallet
     * @param params
     *  - txHash the transaction hash to search for
     * @returns {*}
     */
    getTransaction(params?: GetTransactionOptions): Promise<any>;
    /**
     * List the transfers for a given wallet
     * @param params
     * @returns {*}
     */
    transfers(params?: TransfersOptions): Promise<any>;
    /**
     * Get transfers on this wallet
     * @param params
     */
    getTransfer(params?: GetTransferOptions): Promise<any>;
    /**
     * Get a transaction by sequence id for a given wallet
     * @param params
     */
    transferBySequenceId(params?: TransferBySequenceIdOptions): Promise<any>;
    /**
     * Get the maximum amount you can spend in a single transaction
     *
     * @param {Object} params - parameters object
     * @param {Number} params.limit - maximum number of selectable unspents
     * @param {Number | String} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number | String} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
     * @param {Number} params.feeRate - fee rate to use in calculation of maximum spendable in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {String} params.recipientAddress - recipient addresses for a more accurate calculation of the maximum available to send
     * @returns {{maximumSpendable: Number, coin: String}}
     * NOTE : feeTxConfirmTarget omitted on purpose because gauging the maximum spendable amount with dynamic fees does not make sense
     */
    maximumSpendable(params?: MaximumSpendableOptions): Promise<MaximumSpendable>;
    /**
     * List the unspents for a given wallet
     * @param params
     * @returns {*}
     */
    unspents(params?: UnspentsOptions): Promise<any>;
    /**
     * Consolidate or fanout unspents on a wallet
     *
     * @param {String} routeName - either `consolidate` or `fanout`
     *
     * @param {Object} params - parameters object
     *
     * Wallet parameters:
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     *
     * Fee parameters:
     * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     *
     * Input parameters:
     * @param {Number | String} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number | String} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - if true, minConfirms also applies to change outputs
     * @param {Number} params.limit                for routeName === 'consolidate'
     *                 params.maxNumInputsToUse    for routeName === 'fanout'
     *                  - maximum number of unspents you want to use in the transaction
     * Output parameters:
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     * @param {Boolean} params.bulk - if set to True, this enables the consolidation of large number of unspents by creating multiple transactions,
     *                                with each transaction composed of 200 unspents, except for the last transaction which may have fewer unspents.
     */
    private manageUnspents;
    /**
     * Consolidate unspents on a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     * @param {Number | String} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number | String} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - if true, minConfirms also applies to change outputs
     * @param {Number} params.limit                for routeName === 'consolidate'
     *                 params.maxNumInputsToUse    for routeName === 'fanout'
     *                  - maximum number of unspents you want to use in the transaction
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make. It is not applicable for if bulk consolidate.
     * @param {Boolean} params.bulk - if set to True, this enables the consolidation of large number of unspents by creating multiple transactions,
     *                                with each transaction composed of 200 unspents, except for the last transaction which may have fewer unspents.
     */
    consolidateUnspents(params?: ConsolidateUnspentsOptions, option?: ManageUnspentsOptions): Promise<unknown>;
    /**
     * Fanout unspents on a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {Number | String} params.minValue - the minimum value of unspents to use
     * @param {Number | String} params.maxValue - the maximum value of unspents to use
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Number} params.maxFeePercentage - the maximum proportion of an unspent you are willing to lose to fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
     * @param {Number} params.maxFeeRate - The max limit for a fee rate in satoshis/kB
     * @param {Number} params.maxNumInputsToUse - the number of unspents you want to use in the transaction
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     */
    fanoutUnspents(params?: FanoutUnspentsOptions): Promise<unknown>;
    /**
     * Set the token flush thresholds for the wallet. Updates the wallet.
     * Tokens will only be flushed from forwarder contracts if the balance is greater than the threshold defined here.
     * @param thresholds {Object} - pairs of { [tokenName]: threshold } (base units)
     */
    updateTokenFlushThresholds(thresholds?: any): Promise<any>;
    /**
        * Updates the wallet. Sets flags for deployForwardersManually and flushForwardersManually of the wallet.
        * @param forwarderFlags {Object} - {
          "coinSpecific": {
            [coinName]: {
              "deployForwardersManually": {Boolean},
              "flushForwardersManually": {Boolean}
            }
          }
        }
        */
    updateForwarders(forwarderFlags?: any): Promise<any>;
    /**
     * To manually deploy an ETH address
     *
     * @param {Object} params - parameters object
     * @param {String} [params.address] - addressId
     * @param {String} [params.id] - addressId could be received also as id
     * @returns {Object} Http response
     */
    deployForwarders(params: DeployForwardersOptions): Promise<any>;
    /**
     * To manually forward tokens from an ETH or CELO address
     *
     * @param {Object} params - parameters object
     * @param {String} params.tokenName - Name of token that needs to be forwarded from the address
     * @param {String} [params.address] -
     * @param {String} [params.address] - addressId
     * @param {String} [params.id] - addressId could be received also as id
     * @param {String} [params.gasPrice] - Explicit gas price to use when forwarding token from the forwarder contract (ETH and Celo only). If not given, defaults to the current estimated network gas price.
     * @param {String} [params.eip1559] - Specify eip1559 fee parameters in token forwarding transaction.
     * @returns {Object} Http response
     */
    flushForwarderToken(params: FlushForwarderTokenOptions): Promise<any>;
    /**
     * Sweep funds for a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.address - The address to send all the funds in the wallet to
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {String} params.otp - Two factor auth code to enable sending the transaction
     * @param {Number} params.feeTxConfirmTarget - Estimate the fees to aim for first confirmation within this number of blocks
     * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
     * @param {Number} [params.maxFeeRate] - upper limit for feeRate in satoshis/kB
     * @param {Boolean} [params.allowPartialSweep] - allows sweeping 200 unspents when the wallet has more than that
     * @returns txHex {String} the txHex of the signed transaction
     */
    sweep(params?: SweepOptions): Promise<any>;
    /**
     * Freeze a given wallet
     * @param params
     * @returns {*}
     */
    freeze(params?: FreezeOptions): Promise<any>;
    /**
     * Update comment of a transfer
     * @param params
     * @returns {*}
     */
    transferComment(params?: TransferCommentOptions): Promise<any>;
    /**
     * List the addresses for a given wallet
     * @param params
     * @returns {*}
     */
    addresses(params?: AddressesOptions): Promise<any>;
    /**
     * Get a single wallet address by its id
     * @param params
     * @returns {*}
     */
    getAddress(params?: GetAddressOptions): Promise<any>;
    /**
     * Create one or more new address(es) for use with this wallet.
     *
     * If the `count` field is defined and greater than 1, an object with a single
     * array property named `addresses` containing `count` address objects
     * will be returned. Otherwise, a single address object is returned.
     *
     * @param params
     * @param {Number} params.chain on which the new address should be created
     * @param {(Number|String)} params.gasPrice gas price for new address creation, if applicable
     * @param {String} params.label label for the new address(es)
     * @param {Number} params.count=1 number of new addresses which should be created (maximum 250)
     * @param {Number} params.forwarderVersion The version of address to create, if applicable
     * @param {Boolean} params.lowPriority Ethereum-specific param to create address using low priority fee address
     * @param {String} params.baseAddress base address of the wallet(optional parameter)
     * @param {Boolean} params.allowSkipVerifyAddress When set to false, it throws error if address verification is skipped for any reason. Default is true.
     * @param {String} params.onToken mandatory in case of the OFC wallet, the name of token to create address for
     * Address verification can be skipped when forwarderVersion is 0 and pendingChainInitialization is true OR
     * if 'coinSpecific' is not part of the response from api call to create address
     */
    createAddress(params?: CreateAddressOptions): Promise<any>;
    /**
     * Update properties on an address
     * @param params
     * @returns {*}
     */
    updateAddress(params?: UpdateAddressOptions): Promise<any>;
    updateWalletBuildDefaults(params: UpdateBuildDefaultOptions): Promise<unknown>;
    /**
     * List webhooks on this wallet
     * @param params
     */
    listWebhooks(params?: PaginationOptions): Promise<any>;
    /**
     * Simulate wallet webhook, currently for webhooks of type transfer and pending approval
     * @param params
     * - webhookId (required) id of the webhook to be simulated
     * - transferId (optional but required for transfer webhooks) id of the simulated transfer
     * - pendingApprovalId (optional but required for pending approval webhooks) id of the simulated pending approval
     * @returns {*}
     */
    simulateWebhook(params?: SimulateWebhookOptions): Promise<any>;
    /**
     * Add a webhook to this wallet
     * @param params
     */
    addWebhook(params?: ModifyWebhookOptions): Promise<any>;
    /**
     * Remove a webhook from this wallet
     * @param params
     */
    removeWebhook(params?: ModifyWebhookOptions): Promise<any>;
    /**
     * Gets the user keychain for this wallet
     *
     * The user keychain is the first keychain of the wallet and usually has the encrypted prv stored on BitGo.
     * Useful when trying to get the users' keychain from the server before decrypting to sign a transaction.
     */
    getEncryptedUserKeychain(): Promise<KeychainWithEncryptedPrv>;
    /**
     * Gets the unencrypted private key for this wallet (be careful!)
     * Requires wallet passphrase
     *
     * @param params
     */
    getPrv(params?: GetPrvOptions): Promise<any>;
    /**
     * Send an encrypted wallet share to BitGo.
     * @param params
     */
    createShare(params?: CreateShareOptions): Promise<any>;
    /**
     * Share this wallet with another BitGo user.
     * @param params
     * @returns {*}
     */
    shareWallet(params?: ShareWalletOptions): Promise<any>;
    /**
     * Remove user from wallet
     * @param params
     * - userId Id of the user to remove
     * @return {*}
     */
    removeUser(params?: RemoveUserOptions): Promise<any>;
    /**
     * Fetch a transaction prebuild (unsigned transaction) from BitGo
     *
     * @param {Object} params
     * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
     * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
     * @param {Number} params.feeRate - the desired feeRate for the transaction in base units/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in base units/kB
     * @param {Number} params.minConfirms - Minimum number of confirmations unspents going into this transaction should have
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforce minimum number of confirmations on change (internal) inputs.
     * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet. If the walletâ€™s current unspent count is lower than the target, up to four additional change outputs will be added to the transaction.
     * @param {Number | String} params.minValue - Ignore unspents smaller than this amount of base units
     * @param {Number | String} params.maxValue - Ignore unspents larger than this amount of base units
     * @param {Number} params.sequenceId - The sequence ID of the transaction
     * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
     * @param {Number} params.gasLimit - Custom gas limit to be used for sending the transaction
     * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
     * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
     * @param {String} params.changeAddress - Specifies the destination of the change output
     * @param {Boolean} params.nonParticipation - (Algorand) Non participating key reg transaction
     * @param {Number} params.validFromBlock - (Algorand) The minimum round this will run on
     * @param {Number} params.validToBlock - (Algorand) The maximum round this will run on
     * @param {Boolean} params.instant - Build this transaction to conform with instant sending coin-specific method (if available)
     * @param {Boolean} params.keepAlive - (Polkadot) keep address alive by sending the address minimum funding amount, used during wallet consolidation, true by default
     * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
     * @param {String} param.transferId - transfer Id to use in transaction (supported by casper)
     * @param {String} params.addressType - The type of address to create for change. One of `p2sh`, `p2shP2wsh`, and `p2wsh`. Case-sensitive.
     * @param {Boolean} params.hop - Build this as an Ethereum hop transaction
     * @param {Object} params.reservation - Object to reserve the unspents that this tx build uses. Format is reservation = { expireTime: ISODateString, pendingApprovalId: String }
     * @param {String} params.walletPassphrase The passphrase to the wallet user key, to sign commitment data for Ethereum hop transactions
     * @param {String} params.walletContractAddress - The contract address used as the "to" field of a transaction
     * @returns {*}
     */
    prebuildTransaction(params?: PrebuildTransactionOptions): Promise<PrebuildTransactionResult>;
    /**
     * Gets the User Keychain and sign a TSS transaction
     * @param txRequestId The transaction request id
     * @param walletPassphrase The wallet passphrase
     * @return Promise<SignedTransaction>
     */
    getUserKeyAndSignTssTransaction({ txRequestId, walletPassphrase, }: {
        txRequestId: string;
        walletPassphrase: string;
    }): Promise<SignedTransaction>;
    /**
     * Sign a transaction
     * @param params
     * - txPrebuild
     * - [keychain / key] (object) or prv (string)
     * - walletPassphrase
     * @return {*}
     */
    signTransaction(params?: WalletSignTransactionOptions): Promise<SignedTransaction | TxRequest>;
    /**
     * Sign a typed structured data using TSS
     * @param params
     */
    signTypedData(params: WalletSignTypedDataOptions): Promise<SignedMessage>;
    /**
     *  Sign a message using TSS
     * @param params
     * - Message
     * - custodianMessageId
     */
    signMessage(params?: WalletSignMessageOptions): Promise<SignedMessage>;
    /**
     * Get the user private key from either a derivation or an encrypted keychain
     * @param [params.keychain / params.key] (object) or params.prv (string)
     * @param params.walletPassphrase (string)
     */
    getUserPrv(params?: GetUserPrvOptions): string;
    /**
     * Get a transaction prebuild from BitGo, validate it, and then decrypt the user key and sign the transaction
     * @param params
     */
    prebuildAndSignTransaction(params?: PrebuildAndSignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Accelerate a transaction's confirmation using Child-Pays-For-Parent (CPFP)
     * @param params
     */
    accelerateTransaction(params?: AccelerateTransactionOptions): Promise<any>;
    private validateAccelerationParams;
    private validateRbfParams;
    private validateCpfpParams;
    /**
     * Submit a half-signed transaction to BitGo
     * @param params
     * - txHex: transaction hex to submit
     * - halfSigned: object containing transaction (txHex or txBase64) to submit
     * @param reqId - request tracer request id
     */
    submitTransaction(params?: SubmitTransactionOptions, reqId?: IRequestTracer): Promise<any>;
    /**
     * Send coins to a recipient
     * @param params
     * @param params.address - the destination address
     * @param params.amount - the amount in satoshis/wei/base value to be sent
     * @param params.message - optional message to attach to transaction
     * @param params.data - [Ethereum Specific] optional data to pass to transaction
     * @param params.custodianTransactionId - [Ethereum/MMI Specific] id of transaction created via metamask
     * @param params.walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
     * @param params.prv - the private key in string form, if walletPassphrase is not available
     * @param params.minConfirms - the minimum confirmation threshold for inputs
     * @param params.enforceMinConfirmsForChange - whether to enforce minConfirms for change inputs
     * @returns {*}
     */
    send(params?: SendOptions): Promise<any>;
    /**
     * Send an ERC-721 NFT or ERC-1155 NFT(s).
     *
     * This function constructs the appropriate call data for an ERC-721/1155 token transfer,
     * and calls the token contract with the data, and amount 0. This transaction will always produce
     * a pending approval.
     *
     * @param sendOptions Options to specify how the transaction should be sent.
     * @param sendNftOptions Options to specify the NFT(s) to be sent.
     *
     * @return A pending approval for the transaction.
     */
    sendNft(sendOptions: SendNFTOptions, sendNftOptions: NFTTransferOptions): Promise<SendNFTResult>;
    /**
     * Send money to multiple recipients
     * 1. Gets the user keychain by checking the wallet for a key which has an encrypted prv
     * 2. Decrypts user key
     * 3. Creates the transaction with default fee
     * 4. Signs transaction with decrypted user key
     * 5. Sends the transaction to BitGo
     * @param {object} params
     * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
     * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
     * @param {Number} params.feeRate - the desired feeRate for the transaction in satothis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
     * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet
     * @param {String} params.message - optional message to attach to transaction
     * @param {Number | String} params.minValue - Ignore unspents smaller than this amount of satoshis
     * @param {Number | String} params.maxValue - Ignore unspents larger than this amount of satoshis
     * @param {Number} params.sequenceId - The sequence ID of the transaction
     * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
     * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
     * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
     * @param {String} params.comment - Any additional comment to attach to the transaction
     * @param {String} params.otp - Two factor auth code to enable sending the transaction
     * @param {String} params.changeAddress - Specifies the destination of the change output
     * @param {Boolean} params.instant - Send this transaction using coin-specific instant sending method (if available)
     * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
     * @param {String} params.type - Type of the transaction (e.g. trustline)
     * @param {{token: params, action: String, limit: String}[]} options.trustlines - Array of trustlines to manage (supported by Stellar)
     * @returns {*}
     */
    sendMany(params?: SendManyOptions): Promise<any>;
    /**
     * Recover an unsupported token from a BitGo multisig wallet
     * params are validated in Eth.prototype.recoverToken
     * @param params
     * @param params.tokenContractAddress the contract address of the unsupported token
     * @param params.recipient the destination address recovered tokens should be sent to
     * @param params.walletPassphrase the wallet passphrase
     * @param params.prv the xprv
     */
    recoverToken(params?: RecoverTokenOptions): Promise<any>;
    /**
     * Get transaction metadata for the oldest transaction that is still pending or attempted
     * @param params
     * @returns {Object} Object with txid, walletId, tx, and fee (if supported for coin)
     */
    getFirstPendingTransaction(params?: Record<string, never>): Promise<any>;
    /**
     * Change the fee on the pending transaction that corresponds to the given txid to the given new fee
     * @param params
     * @param {String} params.txid The transaction Id corresponding to the transaction whose fee is to be changed
     * @param {String} [params.fee] Optional - The new fee to apply to the denoted transaction
     * @param {Object} [params.eip1559] Optional - the eip1559 values to apply to the denoted transaction
     * @returns {String} The transaction ID of the new transaction that contains the new fee rate
     */
    changeFee(params?: ChangeFeeOptions): Promise<any>;
    /**
     * Fetch info from merchant server
     * @param {Object} params The params passed into the function
     * @param {String} params.url The Url to retrieve info from
     * @returns {Object} The info returned from the merchant server
     * @deprecated
     */
    getPaymentInfo(params?: {
        url?: string;
    }): Promise<any>;
    /**
     * Send json payment response
     * @param {Object} params The params passed into the function
     * @param {String} params.paymentUrl - The url to send the fully signed transaction to
     * @param {String} params.txHex - The transaction hex of the payment
     * @param {String} params.memo {String} - A memo supplied by the merchant, to be inserted into the transfer as the comment
     * @param {String} params.expires {String} - ISO Date format of when the payment request expires
     * @returns {Object} The info returned from the merchant server Payment Ack
     * @deprecated
     */
    sendPaymentResponse(params?: any): Promise<any>;
    /**
     * Create a policy rule
     * @param params
     * @param params.condition condition object
     * @param params.action action object
     * @returns {*}
     */
    createPolicyRule(params?: CreatePolicyRuleOptions): Promise<any>;
    /**
     * Update a policy rule
     * @param params
     * @param params.condition condition object
     * @param params.action action object
     * @returns {*}
     */
    setPolicyRule(params?: any): Promise<any>;
    /**
     * Remove Policy Rule
     * @param params
     * @returns {*}
     */
    removePolicyRule(params?: RemovePolicyRuleOptions): Promise<any>;
    /**
     * Remove this wallet
     * @param params
     * @returns {*}
     */
    remove(params?: Record<string, never>): Promise<any>;
    /**
     * Fetches crossChain UTXOs
     * Currently only for AVAX
     * @param {string} params.sourceChain the sourcechain to pick UTXOs, if not given, then pick from all available chains [P, C]
     */
    fetchCrossChainUTXOs(params: FetchCrossChainUTXOsOptions): Promise<CrossChainUTXO[]>;
    /**
     * Extract a JSON representable version of this wallet
     */
    toJSON(): WalletData;
    /**
     * Create a trading account from this wallet
     */
    toTradingAccount(): TradingAccount;
    /**
     * Get the address book for this wallet
     */
    toAddressBook(): IAddressBook;
    /**
     * Create a staking wallet from this wallet
     */
    toStakingWallet(): StakingWallet;
    /**
     * Creates and downloads PDF keycard for wallet (requires response from wallets.generateWallet)
     *
     * Note: this is example code and is not the version used on bitgo.com
     *
     * @param params
     *   * jsPDF - an instance of the jsPDF library
     *   * QRCode - an instance of the QRious library
     *   * userKeychain - a wallet's private user keychain
     *   * backupKeychain - a wallet's private backup keychain
     *   * bitgoKeychain - a wallet's private bitgo keychain
     *   * passphrase - the wallet passphrase
     *   * passcodeEncryptionCode - the encryption secret used for Box D
     *   * activationCode - a randomly generated six-digit activation code
     *   * walletKeyID - the Key ID used for deriving a cold wallet's signing key
     *   * backupKeyID - the Key ID used for deriving a cold wallet's backup key
     * @returns {*}
     */
    downloadKeycard(params?: DownloadKeycardOptions): void;
    /**
     * Builds a set of consolidation transactions for a wallet.
     * @param params
     *     consolidateAddresses - these are the on-chain receive addresses we want to pick a consolidation amount from
     */
    buildAccountConsolidations(params?: BuildConsolidationTransactionOptions): Promise<PrebuildTransactionResult[]>;
    /**
     * Builds and sends a set of consolidation transactions for a wallet.
     * @param params
     *     prebuildTx   - this is the pre-build consolidation tx. this is a normally built tx with
     *                    an additional parameter of consolidateId.
     *     verification - normal keychains, etc. for verification
     */
    sendAccountConsolidation(params?: PrebuildAndSignTransactionOptions): Promise<any>;
    /**
     * Builds and sends a set of account consolidations. This is intended to flush many balances to the root wallet balance.
     * @param params -
     *     consolidateAddresses - these are the on-chain receive addresses we want to pick a consolidation amount from
     */
    sendAccountConsolidations(params?: BuildConsolidationTransactionOptions): Promise<any>;
    /**
     * Builds a set of transactions that enables the specified tokens
     * @param params -
     *    enableTokens: Token enablement operations we want to perform
     * @returns Unsigned transactions that enables the specified tokens
     */
    buildTokenEnablements(params?: BuildTokenEnablementOptions): Promise<PrebuildTransactionResult[]>;
    /**
     * Signs and sends a single unsigned token enablement transaction
     * @param params
     * @returns
     *   - The response from sending the transaction for hot/cold wallets
     *   - The response from initiating the transaction for custodial wallets
     */
    sendTokenEnablement(params?: PrebuildAndSignTransactionOptions): Promise<any>;
    /**
     * Some chains require tokens to be enabled before they can be received/sent.
     * This is a dedicated function that enables tokens.
     *
     * Builds, signs, and sends a set of transactions that enables the specified tokens
     * @param params -
     *    enableTokens: Token enablement operations we want to perform
     * @return
     *    success: Successful responses from sendTokenEnablement
     *    failure: Errors from failed transactions
     */
    sendTokenEnablements(params?: BuildTokenEnablementOptions): Promise<{
        success: any[];
        failure: Error[];
    }>;
    /**
     * Create lightning for btc/tbtc from this wallet
     */
    lightning(): Lightning;
    /**
     * Prebuilds a transaction for a TSS wallet.
     *
     * @param params prebuild transaction options
     */
    private prebuildTransactionTss;
    /**
     * Signs a transaction from a TSS EdDSA wallet using external signer.
     *
     * @param params signing options
     */
    private signTransactionTssExternalSignerEdDSA;
    /**
     * Signs a transaction from a TSS ECDSA wallet using external signer.
     *
     * @param params signing options
     */
    private signTransactionTssExternalSignerECDSA;
    /**
     * Signs a transaction from a TSS wallet.
     *
     * @param params signing options
     */
    private signTransactionTss;
    /**
     * Signs a message from a TSS wallet.
     *
     * @param params signing options
     */
    private signMessageTss;
    /**
     * Signs a typed data from a TSS wallet.
     * @param params
     * @private
     */
    private signTypedDataTss;
    /**
     * Builds, signs, and sends a transaction from a TSS wallet.
     *
     * @param params send options
     */
    private sendManyTss;
    /**
     * Send funds from a fee address to a forwarder. Only supports eth-like coins.
     *
     * @param {Object} params - parameters object
     * @param {String} params.forwarderAddress - Address of the forwarder to send funds to.
     * @param {String} params.amount - Amount to send the forwarder (optional). If not given, defaults to sending an estimate of the amount needed for a fund recovery
     * @returns {*}
     */
    fundForwarder(params: FundForwardersOptions): Promise<any>;
    /**
     * Gets forwarder's balance
     * @param params - optional query parameters
     * @returns List of forwarder address and balance
     * if params is not set then returns low balance forwarders
     */
    getForwarderBalance(params?: ForwarderBalanceOptions): Promise<ForwarderBalance[]>;
    /**
     * Gets the ecdsa tss challenges for a wallet.
     * These are static challenges that have been verified by an enterprise admin.
     * Callers should verify that an enterprise admin signed the challenge values before using them.
     *
     * @returns {Promise<WalletEcdsaChallenges>}
     */
    getChallengesForEcdsaSigning(): Promise<WalletEcdsaChallenges>;
    private sendTransaction;
    private initiateTransaction;
    /**
     * Get wallet keychains and validate passphrase if necessary
     * @param {PrebuildTransactionOptions} params - prebuild transaction options
     * @param {string} params.walletPassphrase - wallet passphrase
     * @param {string} params.reqId - request id for tracing purposes
     * @param {Function} params.customSigningFunction - custom signing function for external signing
     * @returns {Promise<Keychain[]>}
     */
    private getKeychainsAndValidatePassphrase;
}
//# sourceMappingURL=wallet.d.ts.map