import { IBaseCoin, NFTTransferOptions, SignedMessage, SignedTransaction } from '../baseCoin';
import { BitGoBase } from '../bitgoBase';
import { KeychainWithEncryptedPrv } from '../keychain';
import { IPendingApproval } from '../pendingApproval';
import { TradingAccount } from '../trading';
import { TxRequest } from '../utils';
import { AccelerateTransactionOptions, AddressesOptions, BuildConsolidationTransactionOptions, BuildTokenEnablementOptions, ChangeFeeOptions, ConsolidateUnspentsOptions, CreateAddressOptions, CreatePolicyRuleOptions, CreateShareOptions, CrossChainUTXO, DeployForwardersOptions, DownloadKeycardOptions, FanoutUnspentsOptions, FetchCrossChainUTXOsOptions, FlushForwarderTokenOptions, ForwarderBalance, ForwarderBalanceOptions, FreezeOptions, FundForwardersOptions, GetAddressOptions, GetPrvOptions, GetTransactionOptions, GetTransferOptions, GetUserPrvOptions, IWallet, MaximumSpendable, MaximumSpendableOptions, ModifyWebhookOptions, NftBalance, PaginationOptions, PrebuildAndSignTransactionOptions, PrebuildTransactionOptions, PrebuildTransactionResult, RecoverTokenOptions, RemovePolicyRuleOptions, RemoveUserOptions, SendManyOptions, SendNFTOptions, SendNFTResult, SendOptions, ShareWalletOptions, SimulateWebhookOptions, SubmitTransactionOptions, SubWalletType, SweepOptions, TransferBySequenceIdOptions, TransferCommentOptions, TransfersOptions, UnspentsOptions, UpdateAddressOptions, UpdateBuildDefaultOptions, WalletCoinSpecific, WalletData, WalletEcdsaChallenges, WalletSignMessageOptions, WalletSignTransactionOptions, WalletSignTypedDataOptions, WalletType } from './iWallet';
import { StakingWallet } from '../staking';
import { Lightning } from '../lightning';
import { IAddressBook } from '../address-book';
import { IRequestTracer } from '../../api';
export declare enum ManageUnspentsOptions {
    BUILD_ONLY = 0,
    BUILD_SIGN_SEND = 1
}
export declare class Wallet implements IWallet {
    readonly bitgo: BitGoBase;
    readonly baseCoin: IBaseCoin;
    _wallet: WalletData;
    private readonly tssUtils;
    private readonly _permissions?;
    constructor(bitgo: BitGoBase, baseCoin: IBaseCoin, walletData: any);
    /**
     * Build a URL using this wallet's id which can be used for BitGo API operations
     * @param extra API specific string to append to the wallet id
     */
    url(extra?: string): string;
    /**
     * Get this wallet's id
     */
    id(): string;
    /**
     * Get the number of approvals required for spending funds from this wallet
     */
    approvalsRequired(): number;
    /**
     * Get the current balance of this wallet
     */
    balance(): number;
    /** @deprecated use codec instead: t.exact(BuildParams).encode(v) */
    prebuildWhitelistedParams(): string[];
    /**
     * This is a strict sub-set of prebuildWhitelistedParams
     */
    prebuildConsolidateAccountParams(): string[];
    /**
     * Get the confirmed balance of this wallet
     */
    confirmedBalance(): number;
    /**
     * Get the spendable balance of this wallet
     */
    spendableBalance(): number;
    /**
     * Get a string representation of the balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    balanceString(): string;
    /**
     * Get a string representation of the confirmed balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    confirmedBalanceString(): string;
    /**
     * Get a string representation of the spendable balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    spendableBalanceString(): string;
    /**
     * Get the coin identifier for the type of coin this wallet holds
     */
    coin(): string;
    type(): WalletType | undefined;
    multisigType(): 'onchain' | 'tss';
    multisigTypeVersion(): 'MPCv2' | undefined;
    subType(): SubWalletType | undefined;
    /**
     * Get the label (name) for this wallet
     */
    label(): string;
    flags(): {
        name: string;
        value: string;
    }[];
    flag(name: string): string | undefined;
    /**
     * Get the public object ids for the keychains on this wallet.
     */
    keyIds(): string[];
    /**
     * Get a receive address for this wallet
     */
    receiveAddress(): string;
    /**
     * Get the wallet id of the wallet that this wallet was migrated from.
     *
     * For example, if this is a BCH wallet that was created from a BTC wallet,
     * the BCH wallet migrated from field would have the BTC wallet id.
     */
    migratedFrom(): string | undefined;
    /**
     * Return the token flush thresholds for this wallet
     * @return {*|Object} pairs of { [tokenName]: thresholds } base units
     */
    tokenFlushThresholds(): any;
    /**
     * Get wallet properties which are specific to certain coin implementations
     */
    coinSpecific(): WalletCoinSpecific | undefined;
    /**
     * Get all pending approvals on this wallet
     */
    pendingApprovals(): IPendingApproval[];
    /**
     * Refresh the wallet object by syncing with the back-end
     * @param params
     * @returns {Wallet}
     */
    refresh(params?: Record<string, never>): Promise<Wallet>;
    /**
     * List the transactions for a given wallet
     * @param params
     * @returns {*}
     */
    transactions(params?: PaginationOptions): Promise<any>;
    /**
     * Return a list of nft tokens for this wallet. Will always return undefined if the wallet
     * was not initialized with the allTokens flag.
     *
     * @returns {NftBalance[] | undefined}
     */
    nftBalances(): NftBalance[] | undefined;
    /**
     * Return a list of unsupported nft tokens for this wallet. Will always return undefined if the wallet
     * was not initialized with the allTokens flag.
     *
     * @returns {NftBalance[] | undefined}
     */
    unsupportedNftBalances(): NftBalance[] | undefined;
    /**
     * Returns a list of the wallets nft & unsupported nfts.
     *
     * @returns {NftBalance[]}
     */
    getNftBalances(): Promise<NftBalance[]>;
    /**
     * List the transactions for a given wallet
     * @param params
     *  - txHash the transaction hash to search for
     * @returns {*}
     */
    getTransaction(params?: GetTransactionOptions): Promise<any>;
    /**
     * List the transfers for a given wallet
     * @param params
     * @returns {*}
     */
    transfers(params?: TransfersOptions): Promise<any>;
    /**
     * Get transfers on this wallet
     * @param params
     */
    getTransfer(params?: GetTransferOptions): Promise<any>;
    /**
     * Get a transaction by sequence id for a given wallet
     * @param params
     */
    transferBySequenceId(params?: TransferBySequenceIdOptions): Promise<any>;
    /**
     * Get the maximum amount you can spend in a single transaction
     *
     * @param {Object} params - parameters object
     * @param {Number} params.limit - maximum number of selectable unspents
     * @param {Number | String} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number | String} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
     * @param {Number} params.feeRate - fee rate to use in calculation of maximum spendable in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {String} params.recipientAddress - recipient addresses for a more accurate calculation of the maximum available to send
     * @returns {{maximumSpendable: Number, coin: String}}
     * NOTE : feeTxConfirmTarget omitted on purpose because gauging the maximum spendable amount with dynamic fees does not make sense
     */
    maximumSpendable(params?: MaximumSpendableOptions): Promise<MaximumSpendable>;
    /**
     * List the unspents for a given wallet
     * @param params
     * @returns {*}
     */
    unspents(params?: UnspentsOptions): Promise<any>;
    /**
     * Consolidate or fanout unspents on a wallet
     *
     * @param {String} routeName - either `consolidate` or `fanout`
     *
     * @param {Object} params - parameters object
     *
     * Wallet parameters:
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     *
     * Fee parameters:
     * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     *
     * Input parameters:
     * @param {Number | String} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number | String} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - if true, minConfirms also applies to change outputs
     * @param {Number} params.limit                for routeName === 'consolidate'
     *                 params.maxNumInputsToUse    for routeName === 'fanout'
     *                  - maximum number of unspents you want to use in the transaction
     * Output parameters:
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     * @param {Boolean} params.bulk - if set to True, this enables the consolidation of large number of unspents by creating multiple transactions,
     *                                with each transaction composed of 200 unspents, except for the last transaction which may have fewer unspents.
     */
    private manageUnspents;
    /**
     * Consolidate unspents on a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     * @param {Number | String} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number | String} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - if true, minConfirms also applies to change outputs
     * @param {Number} params.limit                for routeName === 'consolidate'
     *                 params.maxNumInputsToUse    for routeName === 'fanout'
     *                  - maximum number of unspents you want to use in the transaction
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make. It is not applicable for if bulk consolidate.
     * @param {Boolean} params.bulk - if set to True, this enables the consolidation of large number of unspents by creating multiple transactions,
     *                                with each transaction composed of 200 unspents, except for the last transaction which may have fewer unspents.
     */
    consolidateUnspents(params?: ConsolidateUnspentsOptions, option?: ManageUnspentsOptions): Promise<unknown>;
    /**
     * Fanout unspents on a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {Number | String} params.minValue - the minimum value of unspents to use
     * @param {Number | String} params.maxValue - the maximum value of unspents to use
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Number} params.maxFeePercentage - the maximum proportion of an unspent you are willing to lose to fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
     * @param {Number} params.maxFeeRate - The max limit for a fee rate in satoshis/kB
     * @param {Number} params.maxNumInputsToUse - the number of unspents you want to use in the transaction
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     */
    fanoutUnspents(params?: FanoutUnspentsOptions): Promise<unknown>;
    /**
     * Set the token flush thresholds for the wallet. Updates the wallet.
     * Tokens will only be flushed from forwarder contracts if the balance is greater than the threshold defined here.
     * @param thresholds {Object} - pairs of { [tokenName]: threshold } (base units)
     */
    updateTokenFlushThresholds(thresholds?: any): Promise<any>;
    /**
        * Updates the wallet. Sets flags for deployForwardersManually and flushForwardersManually of the wallet.
        * @param forwarderFlags {Object} - {
          "coinSpecific": {
            [coinName]: {
              "deployForwardersManually": {Boolean},
              "flushForwardersManually": {Boolean}
            }
          }
        }
        */
    updateForwarders(forwarderFlags?: any): Promise<any>;
    /**
     * To manually deploy an ETH address
     *
     * @param {Object} params - parameters object
     * @param {String} [params.address] - addressId
     * @param {String} [params.id] - addressId could be received also as id
     * @returns {Object} Http response
     */
    deployForwarders(params: DeployForwardersOptions): Promise<any>;
    /**
     * To manually forward tokens from an ETH or CELO address
     *
     * @param {Object} params - parameters object
     * @param {String} params.tokenName - Name of token that needs to be forwarded from the address
     * @param {String} [params.address] -
     * @param {String} [params.address] - addressId
     * @param {String} [params.id] - addressId could be received also as id
     * @param {String} [params.gasPrice] - Explicit gas price to use when forwarding token from the forwarder contract (ETH and Celo only). If not given, defaults to the current estimated network gas price.
     * @param {String} [params.eip1559] - Specify eip1559 fee parameters in token forwarding transaction.
     * @returns {Object} Http response
     */
    flushForwarderToken(params: FlushForwarderTokenOptions): Promise<any>;
    /**
     * Sweep funds for a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.address - The address to send all the funds in the wallet to
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {String} params.otp - Two factor auth code to enable sending the transaction
     * @param {Number} params.feeTxConfirmTarget - Estimate the fees to aim for first confirmation within this number of blocks
     * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
     * @param {Number} [params.maxFeeRate] - upper limit for feeRate in satoshis/kB
     * @param {Boolean} [params.allowPartialSweep] - allows sweeping 200 unspents when the wallet has more than that
     * @returns txHex {String} the txHex of the signed transaction
     */
    sweep(params?: SweepOptions): Promise<any>;
    /**
     * Freeze a given wallet
     * @param params
     * @returns {*}
     */
    freeze(params?: FreezeOptions): Promise<any>;
    /**
     * Update comment of a transfer
     * @param params
     * @returns {*}
     */
    transferComment(params?: TransferCommentOptions): Promise<any>;
    /**
     * List the addresses for a given wallet
     * @param params
     * @returns {*}
     */
    addresses(params?: AddressesOptions): Promise<any>;
    /**
     * Get a single wallet address by its id
     * @param params
     * @returns {*}
     */
    getAddress(params?: GetAddressOptions): Promise<any>;
    /**
     * Create one or more new address(es) for use with this wallet.
     *
     * If the `count` field is defined and greater than 1, an object with a single
     * array property named `addresses` containing `count` address objects
     * will be returned. Otherwise, a single address object is returned.
     *
     * @param params
     * @param {Number} params.chain on which the new address should be created
     * @param {(Number|String)} params.gasPrice gas price for new address creation, if applicable
     * @param {String} params.label label for the new address(es)
     * @param {Number} params.count=1 number of new addresses which should be created (maximum 250)
     * @param {Number} params.forwarderVersion The version of address to create, if applicable
     * @param {Boolean} params.lowPriority Ethereum-specific param to create address using low priority fee address
     * @param {String} params.baseAddress base address of the wallet(optional parameter)
     * @param {Boolean} params.allowSkipVerifyAddress When set to false, it throws error if address verification is skipped for any reason. Default is true.
     * @param {String} params.onToken mandatory in case of the OFC wallet, the name of token to create address for
     * Address verification can be skipped when forwarderVersion is 0 and pendingChainInitialization is true OR
     * if 'coinSpecific' is not part of the response from api call to create address
     */
    createAddress(params?: CreateAddressOptions): Promise<any>;
    /**
     * Update properties on an address
     * @param params
     * @returns {*}
     */
    updateAddress(params?: UpdateAddressOptions): Promise<any>;
    updateWalletBuildDefaults(params: UpdateBuildDefaultOptions): Promise<unknown>;
    /**
     * List webhooks on this wallet
     * @param params
     */
    listWebhooks(params?: PaginationOptions): Promise<any>;
    /**
     * Simulate wallet webhook, currently for webhooks of type transfer and pending approval
     * @param params
     * - webhookId (required) id of the webhook to be simulated
     * - transferId (optional but required for transfer webhooks) id of the simulated transfer
     * - pendingApprovalId (optional but required for pending approval webhooks) id of the simulated pending approval
     * @returns {*}
     */
    simulateWebhook(params?: SimulateWebhookOptions): Promise<any>;
    /**
     * Add a webhook to this wallet
     * @param params
     */
    addWebhook(params?: ModifyWebhookOptions): Promise<any>;
    /**
     * Remove a webhook from this wallet
     * @param params
     */
    removeWebhook(params?: ModifyWebhookOptions): Promise<any>;
    /**
     * Gets the user keychain for this wallet
     *
     * The user keychain is the first keychain of the wallet and usually has the encrypted prv stored on BitGo.
     * Useful when trying to get the users' keychain from the server before decrypting to sign a transaction.
     */
    getEncryptedUserKeychain(): Promise<KeychainWithEncryptedPrv>;
    /**
     * Gets the unencrypted private key for this wallet (be careful!)
     * Requires wallet passphrase
     *
     * @param params
     */
    getPrv(params?: GetPrvOptions): Promise<any>;
    /**
     * Send an encrypted wallet share to BitGo.
     * @param params
     */
    createShare(params?: CreateShareOptions): Promise<any>;
    /**
     * Share this wallet with another BitGo user.
     * @param params
     * @returns {*}
     */
    shareWallet(params?: ShareWalletOptions): Promise<any>;
    /**
     * Remove user from wallet
     * @param params
     * - userId Id of the user to remove
     * @return {*}
     */
    removeUser(params?: RemoveUserOptions): Promise<any>;
    /**
     * Fetch a transaction prebuild (unsigned transaction) from BitGo
     *
     * @param {Object} params
     * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
     * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
     * @param {Number} params.feeRate - the desired feeRate for the transaction in base units/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in base units/kB
     * @param {Number} params.minConfirms - Minimum number of confirmations unspents going into this transaction should have
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforce minimum number of confirmations on change (internal) inputs.
     * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet. If the wallet’s current unspent count is lower than the target, up to four additional change outputs will be added to the transaction.
     * @param {Number | String} params.minValue - Ignore unspents smaller than this amount of base units
     * @param {Number | String} params.maxValue - Ignore unspents larger than this amount of base units
     * @param {Number} params.sequenceId - The sequence ID of the transaction
     * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
     * @param {Number} params.gasLimit - Custom gas limit to be used for sending the transaction
     * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
     * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
     * @param {String} params.changeAddress - Specifies the destination of the change output
     * @param {Boolean} params.nonParticipation - (Algorand) Non participating key reg transaction
     * @param {Number} params.validFromBlock - (Algorand) The minimum round this will run on
     * @param {Number} params.validToBlock - (Algorand) The maximum round this will run on
     * @param {Boolean} params.instant - Build this transaction to conform with instant sending coin-specific method (if available)
     * @param {Boolean} params.keepAlive - (Polkadot) keep address alive by sending the address minimum funding amount, used during wallet consolidation, true by default
     * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
     * @param {String} param.transferId - transfer Id to use in transaction (supported by casper)
     * @param {String} params.addressType - The type of address to create for change. One of `p2sh`, `p2shP2wsh`, and `p2wsh`. Case-sensitive.
     * @param {Boolean} params.hop - Build this as an Ethereum hop transaction
     * @param {Object} params.reservation - Object to reserve the unspents that this tx build uses. Format is reservation = { expireTime: ISODateString, pendingApprovalId: String }
     * @param {String} params.walletPassphrase The passphrase to the wallet user key, to sign commitment data for Ethereum hop transactions
     * @param {String} params.walletContractAddress - The contract address used as the "to" field of a transaction
     * @returns {*}
     */
    prebuildTransaction(params?: PrebuildTransactionOptions): Promise<PrebuildTransactionResult>;
    /**
     * Gets the User Keychain and sign a TSS transaction
     * @param txRequestId The transaction request id
     * @param walletPassphrase The wallet passphrase
     * @return Promise<SignedTransaction>
     */
    getUserKeyAndSignTssTransaction({ txRequestId, walletPassphrase, }: {
        txRequestId: string;
        walletPassphrase: string;
    }): Promise<SignedTransaction>;
    /**
     * Sign a transaction
     * @param params
     * - txPrebuild
     * - [keychain / key] (object) or prv (string)
     * - walletPassphrase
     * @return {*}
     */
    signTransaction(params?: WalletSignTransactionOptions): Promise<SignedTransaction | TxRequest>;
    /**
     * Sign a typed structured data using TSS
     * @param params
     */
    signTypedData(params: WalletSignTypedDataOptions): Promise<SignedMessage>;
    /**
     *  Sign a message using TSS
     * @param params
     * - Message
     * - custodianMessageId
     */
    signMessage(params?: WalletSignMessageOptions): Promise<SignedMessage>;
    /**
     * Get the user private key from either a derivation or an encrypted keychain
     * @param [params.keychain / params.key] (object) or params.prv (string)
     * @param params.walletPassphrase (string)
     */
    getUserPrv(params?: GetUserPrvOptions): string;
    /**
     * Get a transaction prebuild from BitGo, validate it, and then decrypt the user key and sign the transaction
     * @param params
     */
    prebuildAndSignTransaction(params?: PrebuildAndSignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Accelerate a transaction's confirmation using Child-Pays-For-Parent (CPFP)
     * @param params
     */
    accelerateTransaction(params?: AccelerateTransactionOptions): Promise<any>;
    private validateAccelerationParams;
    private validateRbfParams;
    private validateCpfpParams;
    /**
     * Submit a half-signed transaction to BitGo
     * @param params
     * - txHex: transaction hex to submit
     * - halfSigned: object containing transaction (txHex or txBase64) to submit
     * @param reqId - request tracer request id
     */
    submitTransaction(params?: SubmitTransactionOptions, reqId?: IRequestTracer): Promise<any>;
    /**
     * Send coins to a recipient
     * @param params
     * @param params.address - the destination address
     * @param params.amount - the amount in satoshis/wei/base value to be sent
     * @param params.message - optional message to attach to transaction
     * @param params.data - [Ethereum Specific] optional data to pass to transaction
     * @param params.custodianTransactionId - [Ethereum/MMI Specific] id of transaction created via metamask
     * @param params.walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
     * @param params.prv - the private key in string form, if walletPassphrase is not available
     * @param params.minConfirms - the minimum confirmation threshold for inputs
     * @param params.enforceMinConfirmsForChange - whether to enforce minConfirms for change inputs
     * @returns {*}
     */
    send(params?: SendOptions): Promise<any>;
    /**
     * Send an ERC-721 NFT or ERC-1155 NFT(s).
     *
     * This function constructs the appropriate call data for an ERC-721/1155 token transfer,
     * and calls the token contract with the data, and amount 0. This transaction will always produce
     * a pending approval.
     *
     * @param sendOptions Options to specify how the transaction should be sent.
     * @param sendNftOptions Options to specify the NFT(s) to be sent.
     *
     * @return A pending approval for the transaction.
     */
    sendNft(sendOptions: SendNFTOptions, sendNftOptions: NFTTransferOptions): Promise<SendNFTResult>;
    /**
     * Send money to multiple recipients
     * 1. Gets the user keychain by checking the wallet for a key which has an encrypted prv
     * 2. Decrypts user key
     * 3. Creates the transaction with default fee
     * 4. Signs transaction with decrypted user key
     * 5. Sends the transaction to BitGo
     * @param {object} params
     * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
     * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
     * @param {Number} params.feeRate - the desired feeRate for the transaction in satothis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
     * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet
     * @param {String} params.message - optional message to attach to transaction
     * @param {Number | String} params.minValue - Ignore unspents smaller than this amount of satoshis
     * @param {Number | String} params.maxValue - Ignore unspents larger than this amount of satoshis
     * @param {Number} params.sequenceId - The sequence ID of the transaction
     * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
     * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
     * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
     * @param {String} params.comment - Any additional comment to attach to the transaction
     * @param {String} params.otp - Two factor auth code to enable sending the transaction
     * @param {String} params.changeAddress - Specifies the destination of the change output
     * @param {Boolean} params.instant - Send this transaction using coin-specific instant sending method (if available)
     * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
     * @param {String} params.type - Type of the transaction (e.g. trustline)
     * @param {{token: params, action: String, limit: String}[]} options.trustlines - Array of trustlines to manage (supported by Stellar)
     * @returns {*}
     */
    sendMany(params?: SendManyOptions): Promise<any>;
    /**
     * Recover an unsupported token from a BitGo multisig wallet
     * params are validated in Eth.prototype.recoverToken
     * @param params
     * @param params.tokenContractAddress the contract address of the unsupported token
     * @param params.recipient the destination address recovered tokens should be sent to
     * @param params.walletPassphrase the wallet passphrase
     * @param params.prv the xprv
     */
    recoverToken(params?: RecoverTokenOptions): Promise<any>;
    /**
     * Get transaction metadata for the oldest transaction that is still pending or attempted
     * @param params
     * @returns {Object} Object with txid, walletId, tx, and fee (if supported for coin)
     */
    getFirstPendingTransaction(params?: Record<string, never>): Promise<any>;
    /**
     * Change the fee on the pending transaction that corresponds to the given txid to the given new fee
     * @param params
     * @param {String} params.txid The transaction Id corresponding to the transaction whose fee is to be changed
     * @param {String} [params.fee] Optional - The new fee to apply to the denoted transaction
     * @param {Object} [params.eip1559] Optional - the eip1559 values to apply to the denoted transaction
     * @returns {String} The transaction ID of the new transaction that contains the new fee rate
     */
    changeFee(params?: ChangeFeeOptions): Promise<any>;
    /**
     * Fetch info from merchant server
     * @param {Object} params The params passed into the function
     * @param {String} params.url The Url to retrieve info from
     * @returns {Object} The info returned from the merchant server
     * @deprecated
     */
    getPaymentInfo(params?: {
        url?: string;
    }): Promise<any>;
    /**
     * Send json payment response
     * @param {Object} params The params passed into the function
     * @param {String} params.paymentUrl - The url to send the fully signed transaction to
     * @param {String} params.txHex - The transaction hex of the payment
     * @param {String} params.memo {String} - A memo supplied by the merchant, to be inserted into the transfer as the comment
     * @param {String} params.expires {String} - ISO Date format of when the payment request expires
     * @returns {Object} The info returned from the merchant server Payment Ack
     * @deprecated
     */
    sendPaymentResponse(params?: any): Promise<any>;
    /**
     * Create a policy rule
     * @param params
     * @param params.condition condition object
     * @param params.action action object
     * @returns {*}
     */
    createPolicyRule(params?: CreatePolicyRuleOptions): Promise<any>;
    /**
     * Update a policy rule
     * @param params
     * @param params.condition condition object
     * @param params.action action object
     * @returns {*}
     */
    setPolicyRule(params?: any): Promise<any>;
    /**
     * Remove Policy Rule
     * @param params
     * @returns {*}
     */
    removePolicyRule(params?: RemovePolicyRuleOptions): Promise<any>;
    /**
     * Remove this wallet
     * @param params
     * @returns {*}
     */
    remove(params?: Record<string, never>): Promise<any>;
    /**
     * Fetches crossChain UTXOs
     * Currently only for AVAX
     * @param {string} params.sourceChain the sourcechain to pick UTXOs, if not given, then pick from all available chains [P, C]
     */
    fetchCrossChainUTXOs(params: FetchCrossChainUTXOsOptions): Promise<CrossChainUTXO[]>;
    /**
     * Extract a JSON representable version of this wallet
     */
    toJSON(): WalletData;
    /**
     * Create a trading account from this wallet
     */
    toTradingAccount(): TradingAccount;
    /**
     * Get the address book for this wallet
     */
    toAddressBook(): IAddressBook;
    /**
     * Create a staking wallet from this wallet
     */
    toStakingWallet(): StakingWallet;
    /**
     * Creates and downloads PDF keycard for wallet (requires response from wallets.generateWallet)
     *
     * Note: this is example code and is not the version used on bitgo.com
     *
     * @param params
     *   * jsPDF - an instance of the jsPDF library
     *   * QRCode - an instance of the QRious library
     *   * userKeychain - a wallet's private user keychain
     *   * backupKeychain - a wallet's private backup keychain
     *   * bitgoKeychain - a wallet's private bitgo keychain
     *   * passphrase - the wallet passphrase
     *   * passcodeEncryptionCode - the encryption secret used for Box D
     *   * activationCode - a randomly generated six-digit activation code
     *   * walletKeyID - the Key ID used for deriving a cold wallet's signing key
     *   * backupKeyID - the Key ID used for deriving a cold wallet's backup key
     * @returns {*}
     */
    downloadKeycard(params?: DownloadKeycardOptions): void;
    /**
     * Builds a set of consolidation transactions for a wallet.
     * @param params
     *     consolidateAddresses - these are the on-chain receive addresses we want to pick a consolidation amount from
     */
    buildAccountConsolidations(params?: BuildConsolidationTransactionOptions): Promise<PrebuildTransactionResult[]>;
    /**
     * Builds and sends a set of consolidation transactions for a wallet.
     * @param params
     *     prebuildTx   - this is the pre-build consolidation tx. this is a normally built tx with
     *                    an additional parameter of consolidateId.
     *     verification - normal keychains, etc. for verification
     */
    sendAccountConsolidation(params?: PrebuildAndSignTransactionOptions): Promise<any>;
    /**
     * Builds and sends a set of account consolidations. This is intended to flush many balances to the root wallet balance.
     * @param params -
     *     consolidateAddresses - these are the on-chain receive addresses we want to pick a consolidation amount from
     */
    sendAccountConsolidations(params?: BuildConsolidationTransactionOptions): Promise<any>;
    /**
     * Builds a set of transactions that enables the specified tokens
     * @param params -
     *    enableTokens: Token enablement operations we want to perform
     * @returns Unsigned transactions that enables the specified tokens
     */
    buildTokenEnablements(params?: BuildTokenEnablementOptions): Promise<PrebuildTransactionResult[]>;
    /**
     * Signs and sends a single unsigned token enablement transaction
     * @param params
     * @returns
     *   - The response from sending the transaction for hot/cold wallets
     *   - The response from initiating the transaction for custodial wallets
     */
    sendTokenEnablement(params?: PrebuildAndSignTransactionOptions): Promise<any>;
    /**
     * Some chains require tokens to be enabled before they can be received/sent.
     * This is a dedicated function that enables tokens.
     *
     * Builds, signs, and sends a set of transactions that enables the specified tokens
     * @param params -
     *    enableTokens: Token enablement operations we want to perform
     * @return
     *    success: Successful responses from sendTokenEnablement
     *    failure: Errors from failed transactions
     */
    sendTokenEnablements(params?: BuildTokenEnablementOptions): Promise<{
        success: any[];
        failure: Error[];
    }>;
    /**
     * Create lightning for btc/tbtc from this wallet
     */
    lightning(): Lightning;
    /**
     * Prebuilds a transaction for a TSS wallet.
     *
     * @param params prebuild transaction options
     */
    private prebuildTransactionTss;
    /**
     * Signs a transaction from a TSS EdDSA wallet using external signer.
     *
     * @param params signing options
     */
    private signTransactionTssExternalSignerEdDSA;
    /**
     * Signs a transaction from a TSS ECDSA wallet using external signer.
     *
     * @param params signing options
     */
    private signTransactionTssExternalSignerECDSA;
    /**
     * Signs a transaction from a TSS wallet.
     *
     * @param params signing options
     */
    private signTransactionTss;
    /**
     * Signs a message from a TSS wallet.
     *
     * @param params signing options
     */
    private signMessageTss;
    /**
     * Signs a typed data from a TSS wallet.
     * @param params
     * @private
     */
    private signTypedDataTss;
    /**
     * Builds, signs, and sends a transaction from a TSS wallet.
     *
     * @param params send options
     */
    private sendManyTss;
    /**
     * Send funds from a fee address to a forwarder. Only supports eth-like coins.
     *
     * @param {Object} params - parameters object
     * @param {String} params.forwarderAddress - Address of the forwarder to send funds to.
     * @param {String} params.amount - Amount to send the forwarder (optional). If not given, defaults to sending an estimate of the amount needed for a fund recovery
     * @returns {*}
     */
    fundForwarder(params: FundForwardersOptions): Promise<any>;
    /**
     * Gets forwarder's balance
     * @param params - optional query parameters
     * @returns List of forwarder address and balance
     * if params is not set then returns low balance forwarders
     */
    getForwarderBalance(params?: ForwarderBalanceOptions): Promise<ForwarderBalance[]>;
    /**
     * Gets the ecdsa tss challenges for a wallet.
     * These are static challenges that have been verified by an enterprise admin.
     * Callers should verify that an enterprise admin signed the challenge values before using them.
     *
     * @returns {Promise<WalletEcdsaChallenges>}
     */
    getChallengesForEcdsaSigning(): Promise<WalletEcdsaChallenges>;
    private sendTransaction;
    private initiateTransaction;
    /**
     * Get wallet keychains and validate passphrase if necessary
     * @param {PrebuildTransactionOptions} params - prebuild transaction options
     * @param {string} params.walletPassphrase - wallet passphrase
     * @param {string} params.reqId - request id for tracing purposes
     * @param {Function} params.customSigningFunction - custom signing function for external signing
     * @returns {Promise<Keychain[]>}
     */
    private getKeychainsAndValidatePassphrase;
}
//# sourceMappingURL=wallet.d.ts.map