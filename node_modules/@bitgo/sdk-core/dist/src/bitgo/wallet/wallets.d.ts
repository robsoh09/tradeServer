import { IBaseCoin } from '../baseCoin';
import { BitGoBase } from '../bitgoBase';
import { AcceptShareOptions, AddWalletOptions, GenerateWalletOptions, GetWalletByAddressOptions, GetWalletOptions, IWallets, ListWalletOptions, UpdateShareOptions, WalletWithKeychains } from './iWallets';
import { Wallet } from './wallet';
export declare class Wallets implements IWallets {
    private readonly bitgo;
    private readonly baseCoin;
    constructor(bitgo: BitGoBase, baseCoin: IBaseCoin);
    /**
     * Get a wallet by ID (proxy for getWallet)
     * @param params
     */
    get(params?: GetWalletOptions): Promise<Wallet>;
    /**
     * List a user's wallets
     * @param params
     * @returns {*}
     */
    list(params?: ListWalletOptions): Promise<{
        wallets: Wallet[];
    }>;
    /**
     * add
     * Add a new wallet (advanced mode).
     * This allows you to manually submit the keys, type, m and n of the wallet
     * Parameters include:
     *    "label": label of the wallet to be shown in UI
     *    "m": number of keys required to unlock wallet (2)
     *    "n": number of keys available on the wallet (3)
     *    "keys": array of keychain ids
     */
    add(params: AddWalletOptions): Promise<any>;
    /**
     * Generate a new wallet
     * 1. Creates the user keychain locally on the client, and encrypts it with the provided passphrase
     * 2. If no pub was provided, creates the backup keychain locally on the client, and encrypts it with the provided passphrase
     * 3. Uploads the encrypted user and backup keychains to BitGo
     * 4. Creates the BitGo key on the service
     * 5. Creates the wallet on BitGo with the 3 public keys above
     * @param params
     * @param params.label Label for the wallet
     * @param params.passphrase Passphrase to be used to encrypt the user and backup keychains
     * @param params.userKey User xpub
     * @param params.backupXpub Backup xpub
     * @param params.backupXpubProvider
     * @param params.backupProvider Third party backup provider for TSS
     * @param params.enterprise the enterpriseId
     * @param params.disableTransactionNotifications
     * @param params.passcodeEncryptionCode optional this is a recovery code that can be used to decrypt the original passphrase in a recovery case.
     *                                      The user must generate and keep the encrypted original passphrase safe while this code is stored on BitGo
     * @param params.coldDerivationSeed optional seed for SMC wallets
     * @param params.gasPrice
     * @param params.disableKRSEmail
     * @param params.walletVersion
     * @param params.multisigType optional multisig type, 'onchain' or 'tss' or 'blsdkg'; if absent, we will defer to the coin's default type
     * @param params.isDistributedCustody optional parameter for creating bitgo key. This is only necessary if you want to create
     *                                    a distributed custody wallet. If provided, you must have the enterprise license and pass in
     *                                    `params.enterprise` into `generateWallet` as well.
     * @param params.type optional wallet type, 'hot' or 'cold' or 'custodial'; if absent, we will defer to 'hot'
     * @param params.bitgoKeyId optional bitgo key id for SMC TSS wallets
     * @param params.commonKeychain optional common keychain for SMC TSS wallets
     *
     * @returns {*}
     */
    generateWallet(params?: GenerateWalletOptions): Promise<WalletWithKeychains>;
    /**
     * List the user's wallet shares
     * @param params
     */
    listShares(params?: Record<string, unknown>): Promise<any>;
    /**
     * Gets a wallet share information, including the encrypted sharing keychain. requires unlock if keychain is present.
     * @param params
     * @param params.walletShareId - the wallet share to get information on
     */
    getShare(params?: {
        walletShareId?: string;
    }): Promise<any>;
    /**
     * Update a wallet share
     * @param params.walletShareId - the wallet share to update
     * @param params.state - the new state of the wallet share
     * @param params
     */
    updateShare(params?: UpdateShareOptions): Promise<any>;
    /**
     * Resend a wallet share invitation email
     * @param params
     * @param params.walletShareId - the wallet share whose invitiation should be resent
     */
    resendShareInvite(params?: {
        walletShareId?: string;
    }): Promise<any>;
    /**
     * Cancel a wallet share
     * @param params
     * @param params.walletShareId - the wallet share to update
     */
    cancelShare(params?: {
        walletShareId?: string;
    }): Promise<any>;
    /**
     * Re-share wallet with existing spenders of the wallet
     * @param walletId
     * @param userPassword
     */
    reshareWalletWithSpenders(walletId: string, userPassword: string): Promise<void>;
    /**
     * Accepts a wallet share, adding the wallet to the user's list
     * Needs a user's password to decrypt the shared key
     *
     * @param params
     * @param params.walletShareId - the wallet share to accept
     * @param params.userPassword - (required if more a keychain was shared) user's password to decrypt the shared wallet
     * @param params.newWalletPassphrase - new wallet passphrase for saving the shared wallet prv.
     *                                     If left blank and a wallet with more than view permissions was shared,
     *                                     then the user's login password is used.
     * @param params.overrideEncryptedPrv - set only if the prv was received out-of-band.
     */
    acceptShare(params?: AcceptShareOptions): Promise<any>;
    /**
     * Get a wallet by its ID
     * @param params
     * @param params.id wallet id
     * @returns {*}
     */
    getWallet(params?: GetWalletOptions): Promise<Wallet>;
    /**
     * Get a wallet by its address
     * @param params
     * @param params.address wallet address
     * @returns {*}
     */
    getWalletByAddress(params?: GetWalletByAddressOptions): Promise<Wallet>;
    /**
     * For any given supported coin, get total balances for all wallets of that
     * coin type on the account.
     * @param params
     * @returns {*}
     */
    getTotalBalances(params?: Record<string, never>): Promise<any>;
    /**
     * Generates a TSS or BLS-DKG Wallet.
     * @param params
     * @private
     */
    private generateMpcWallet;
    /**
     * Generates a Self-Managed Cold TSS Wallet.
     * @param params
     * @private
     */
    private generateSMCMpcWallet;
    /**
     * Generates a Custodial TSS Wallet.
     * @param params
     * @private
     */
    private generateCustodialMpcWallet;
}
//# sourceMappingURL=wallets.d.ts.map