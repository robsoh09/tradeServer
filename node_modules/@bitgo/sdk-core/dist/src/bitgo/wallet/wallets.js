"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallets = void 0;
/**
 * @prettier
 */
const assert_1 = __importDefault(require("assert"));
const bignumber_js_1 = require("bignumber.js");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const _ = __importStar(require("lodash"));
const statics_1 = require("@bitgo/statics");
const api_1 = require("../../api");
const common = __importStar(require("../../common"));
const ecdh_1 = require("../ecdh");
const utils_1 = require("../utils");
const wallet_1 = require("./wallet");
class Wallets {
    constructor(bitgo, baseCoin) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
    }
    /**
     * Get a wallet by ID (proxy for getWallet)
     * @param params
     */
    async get(params = {}) {
        return this.getWallet(params);
    }
    /**
     * List a user's wallets
     * @param params
     * @returns {*}
     */
    async list(params = {}) {
        const queryObject = {};
        if (params.skip && params.prevId) {
            throw new Error('cannot specify both skip and prevId');
        }
        if (params.getbalances) {
            if (!_.isBoolean(params.getbalances)) {
                throw new Error('invalid getbalances argument, expecting boolean');
            }
            queryObject.getbalances = params.getbalances;
        }
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            queryObject.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            queryObject.limit = params.limit;
        }
        if (params.allTokens) {
            if (!_.isBoolean(params.allTokens)) {
                throw new Error('invalid allTokens argument, expecting boolean');
            }
            queryObject.allTokens = params.allTokens;
        }
        const body = (await this.bitgo.get(this.baseCoin.url('/wallet')).query(queryObject).result());
        body.wallets = body.wallets.map((w) => new wallet_1.Wallet(this.bitgo, this.baseCoin, w));
        return body;
    }
    /**
     * add
     * Add a new wallet (advanced mode).
     * This allows you to manually submit the keys, type, m and n of the wallet
     * Parameters include:
     *    "label": label of the wallet to be shown in UI
     *    "m": number of keys required to unlock wallet (2)
     *    "n": number of keys available on the wallet (3)
     *    "keys": array of keychain ids
     */
    async add(params) {
        var _a, _b;
        params = params || {};
        common.validateParams(params, [], ['label', 'enterprise', 'type']);
        if (typeof params.label !== 'string') {
            throw new Error('missing required string parameter label');
        }
        // no need to pass keys for (single) custodial wallets
        if (params.type !== 'custodial') {
            if (Array.isArray(params.keys) === false || !_.isNumber(params.m) || !_.isNumber(params.n)) {
                throw new Error('invalid argument');
            }
            // TODO: support more types of multisig
            if (!this.baseCoin.isValidMofNSetup(params)) {
                throw new Error('unsupported multi-sig type');
            }
        }
        if (params.gasPrice && !_.isNumber(params.gasPrice)) {
            throw new Error('invalid argument for gasPrice - number expected');
        }
        if (params.walletVersion) {
            if (!_.isNumber(params.walletVersion)) {
                throw new Error('invalid argument for walletVersion - number expected');
            }
            if (params.multisigType === 'tss' && this.baseCoin.getMPCAlgorithm() === 'ecdsa' && params.walletVersion === 3) {
                const tssSettings = await this.bitgo
                    .get(this.bitgo.microservicesUrl('/api/v2/tss/settings'))
                    .result();
                const multisigTypeVersion = (_b = (_a = tssSettings.coinSettings[this.baseCoin.getFamily()]) === null || _a === void 0 ? void 0 : _a.walletCreationSettings) === null || _b === void 0 ? void 0 : _b.multiSigTypeVersion;
                if (multisigTypeVersion === 'MPCv2') {
                    params.walletVersion = 5;
                }
            }
        }
        if (params.tags && Array.isArray(params.tags) === false) {
            throw new Error('invalid argument for tags - array expected');
        }
        if (params.clientFlags && Array.isArray(params.clientFlags) === false) {
            throw new Error('invalid argument for clientFlags - array expected');
        }
        if (params.isCold && !_.isBoolean(params.isCold)) {
            throw new Error('invalid argument for isCold - boolean expected');
        }
        if (params.isCustodial && !_.isBoolean(params.isCustodial)) {
            throw new Error('invalid argument for isCustodial - boolean expected');
        }
        if (params.address && (!_.isString(params.address) || !this.baseCoin.isValidAddress(params.address))) {
            throw new Error('invalid argument for address - valid address string expected');
        }
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(params).result();
        return {
            wallet: new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet),
        };
    }
    /**
     * Generate a new wallet
     * 1. Creates the user keychain locally on the client, and encrypts it with the provided passphrase
     * 2. If no pub was provided, creates the backup keychain locally on the client, and encrypts it with the provided passphrase
     * 3. Uploads the encrypted user and backup keychains to BitGo
     * 4. Creates the BitGo key on the service
     * 5. Creates the wallet on BitGo with the 3 public keys above
     * @param params
     * @param params.label Label for the wallet
     * @param params.passphrase Passphrase to be used to encrypt the user and backup keychains
     * @param params.userKey User xpub
     * @param params.backupXpub Backup xpub
     * @param params.backupXpubProvider
     * @param params.backupProvider Third party backup provider for TSS
     * @param params.enterprise the enterpriseId
     * @param params.disableTransactionNotifications
     * @param params.passcodeEncryptionCode optional this is a recovery code that can be used to decrypt the original passphrase in a recovery case.
     *                                      The user must generate and keep the encrypted original passphrase safe while this code is stored on BitGo
     * @param params.coldDerivationSeed optional seed for SMC wallets
     * @param params.gasPrice
     * @param params.disableKRSEmail
     * @param params.walletVersion
     * @param params.multisigType optional multisig type, 'onchain' or 'tss' or 'blsdkg'; if absent, we will defer to the coin's default type
     * @param params.isDistributedCustody optional parameter for creating bitgo key. This is only necessary if you want to create
     *                                    a distributed custody wallet. If provided, you must have the enterprise license and pass in
     *                                    `params.enterprise` into `generateWallet` as well.
     * @param params.type optional wallet type, 'hot' or 'cold' or 'custodial'; if absent, we will defer to 'hot'
     * @param params.bitgoKeyId optional bitgo key id for SMC TSS wallets
     * @param params.commonKeychain optional common keychain for SMC TSS wallets
     *
     * @returns {*}
     */
    async generateWallet(params = {}) {
        var _a;
        common.validateParams(params, ['label'], ['passphrase', 'userKey', 'backupXpub']);
        if (typeof params.label !== 'string') {
            throw new Error('missing required string parameter label');
        }
        const { type = 'hot', label, passphrase, enterprise, isDistributedCustody } = params;
        const isTss = params.multisigType === 'tss' && this.baseCoin.supportsTss();
        const canEncrypt = !!passphrase && typeof passphrase === 'string';
        const walletParams = {
            label: label,
            m: 2,
            n: 3,
            keys: [],
            type: !!params.userKey && params.multisigType !== 'onchain' ? 'cold' : type,
        };
        if (!_.isUndefined(params.passcodeEncryptionCode)) {
            if (!_.isString(params.passcodeEncryptionCode)) {
                throw new Error('passcodeEncryptionCode must be a string');
            }
        }
        if (!_.isUndefined(enterprise)) {
            if (!_.isString(enterprise)) {
                throw new Error('invalid enterprise argument, expecting string');
            }
            walletParams.enterprise = enterprise;
        }
        // EVM TSS wallets must use wallet version 3 and 5
        if (isTss && this.baseCoin.isEVM() && !(params.walletVersion === 3 || params.walletVersion === 5)) {
            throw new Error('EVM TSS wallets are only supported for wallet version 3 and 5');
        }
        if (isTss) {
            if (!this.baseCoin.supportsTss()) {
                throw new Error(`coin ${this.baseCoin.getFamily()} does not support TSS at this time`);
            }
            if (params.walletVersion === 5 && !this.baseCoin.getConfig().features.includes(statics_1.CoinFeature.MPCV2)) {
                throw new Error(`coin ${this.baseCoin.getFamily()} does not support TSS MPCv2 at this time`);
            }
            (0, assert_1.default)(enterprise, 'enterprise is required for TSS wallet');
            if (type === 'cold') {
                if (params.walletVersion === 5) {
                    throw new Error('EVM TSS MPCv2 wallets are not supported for cold wallets');
                }
                // validate
                (0, assert_1.default)(params.bitgoKeyId, 'bitgoKeyId is required for SMC TSS wallet');
                (0, assert_1.default)(params.commonKeychain, 'commonKeychain is required for SMC TSS wallet');
                return this.generateSMCMpcWallet({
                    multisigType: 'tss',
                    label,
                    enterprise,
                    walletVersion: params.walletVersion,
                    bitgoKeyId: params.bitgoKeyId,
                    commonKeychain: params.commonKeychain,
                    coldDerivationSeed: params.coldDerivationSeed,
                });
            }
            if (type === 'custodial') {
                if (params.walletVersion === 5) {
                    throw new Error('EVM TSS MPCv2 wallets are not supported for custodial wallets');
                }
                return this.generateCustodialMpcWallet({
                    multisigType: 'tss',
                    label,
                    enterprise,
                    walletVersion: params.walletVersion,
                });
            }
            (0, assert_1.default)(passphrase, 'cannot generate TSS keys without passphrase');
            return this.generateMpcWallet({
                multisigType: 'tss',
                label,
                passphrase,
                originalPasscodeEncryptionCode: params.passcodeEncryptionCode,
                enterprise,
                walletVersion: params.walletVersion,
                backupProvider: params.backupProvider,
            });
        }
        const isBlsDkg = params.multisigType ? params.multisigType === 'blsdkg' : this.baseCoin.supportsBlsDkg();
        if (isBlsDkg) {
            if (!this.baseCoin.supportsBlsDkg()) {
                throw new Error(`coin ${this.baseCoin.getFamily()} does not support BLS-DKG at this time`);
            }
            (0, assert_1.default)(enterprise, 'enterprise is required for BLS-DKG wallet');
            if (type === 'cold') {
                throw new Error('BLS-DKG SMC wallets are not supported at this time');
            }
            if (type === 'custodial') {
                throw new Error('BLS-DKG custodial wallets are not supported at this time');
            }
            (0, assert_1.default)(passphrase, 'cannot generate BLS-DKG keys without passphrase');
            return this.generateMpcWallet({ multisigType: 'blsdkg', label, passphrase, enterprise });
        }
        // Handle distributed custody
        if (isDistributedCustody) {
            if (!enterprise) {
                throw new Error('must provide enterprise when creating distributed custody wallet');
            }
            if (!type || type !== 'cold') {
                throw new Error('distributed custody wallets must be type: cold');
            }
        }
        const hasBackupXpub = !!params.backupXpub;
        const hasBackupXpubProvider = !!params.backupXpubProvider;
        if (hasBackupXpub && hasBackupXpubProvider) {
            throw new Error('Cannot provide more than one backupXpub or backupXpubProvider flag');
        }
        if (params.gasPrice && params.eip1559) {
            throw new Error('can not use both eip1559 and gasPrice values');
        }
        if (!_.isUndefined(params.disableTransactionNotifications)) {
            if (!_.isBoolean(params.disableTransactionNotifications)) {
                throw new Error('invalid disableTransactionNotifications argument, expecting boolean');
            }
            walletParams.disableTransactionNotifications = params.disableTransactionNotifications;
        }
        if (!_.isUndefined(params.gasPrice)) {
            const gasPriceBN = new bignumber_js_1.BigNumber(params.gasPrice);
            if (gasPriceBN.isNaN()) {
                throw new Error('invalid gas price argument, expecting number or number as string');
            }
            walletParams.gasPrice = gasPriceBN.toString();
        }
        if (!_.isUndefined(params.eip1559) && !_.isEmpty(params.eip1559)) {
            const maxFeePerGasBN = new bignumber_js_1.BigNumber(params.eip1559.maxFeePerGas);
            if (maxFeePerGasBN.isNaN()) {
                throw new Error('invalid max fee argument, expecting number or number as string');
            }
            const maxPriorityFeePerGasBN = new bignumber_js_1.BigNumber(params.eip1559.maxPriorityFeePerGas);
            if (maxPriorityFeePerGasBN.isNaN()) {
                throw new Error('invalid priority fee argument, expecting number or number as string');
            }
            walletParams.eip1559 = {
                maxFeePerGas: maxFeePerGasBN.toString(),
                maxPriorityFeePerGas: maxPriorityFeePerGasBN.toString(),
            };
        }
        if (!_.isUndefined(params.disableKRSEmail)) {
            if (!_.isBoolean(params.disableKRSEmail)) {
                throw new Error('invalid disableKRSEmail argument, expecting boolean');
            }
            walletParams.disableKRSEmail = params.disableKRSEmail;
        }
        if (!_.isUndefined(params.walletVersion)) {
            if (!_.isNumber(params.walletVersion)) {
                throw new Error('invalid walletVersion provided, expecting number');
            }
            walletParams.walletVersion = params.walletVersion;
        }
        // Ensure each krsSpecific param is either a string, boolean, or number
        const { krsSpecific } = params;
        if (!_.isUndefined(krsSpecific)) {
            Object.keys(krsSpecific).forEach((key) => {
                const val = krsSpecific[key];
                if (!_.isBoolean(val) && !_.isString(val) && !_.isNumber(val)) {
                    throw new Error('krsSpecific object contains illegal values. values must be strings, booleans, or numbers');
                }
            });
        }
        let derivationPath = undefined;
        const reqId = new utils_1.RequestTracer();
        // Add the user keychain
        const userKeychainPromise = async () => {
            let userKeychainParams;
            let userKeychain;
            // User provided user key
            if (params.userKey) {
                userKeychain = { pub: params.userKey };
                userKeychainParams = userKeychain;
                if (params.coldDerivationSeed) {
                    // the derivation only makes sense when a key already exists
                    const derivation = this.baseCoin.deriveKeyWithSeed({
                        key: params.userKey,
                        seed: params.coldDerivationSeed,
                    });
                    derivationPath = derivation.derivationPath;
                    userKeychain.pub = derivation.key;
                    userKeychain.derivedFromParentWithSeed = params.coldDerivationSeed;
                }
            }
            else {
                if (!canEncrypt) {
                    throw new Error('cannot generate user keypair without passphrase');
                }
                // Create the user key.
                userKeychain = this.baseCoin.keychains().create();
                userKeychain.encryptedPrv = this.bitgo.encrypt({ password: passphrase, input: userKeychain.prv });
                userKeychainParams = {
                    pub: userKeychain.pub,
                    encryptedPrv: userKeychain.encryptedPrv,
                    originalPasscodeEncryptionCode: params.passcodeEncryptionCode,
                };
            }
            userKeychainParams.reqId = reqId;
            const newUserKeychain = await this.baseCoin.keychains().add(userKeychainParams);
            return _.extend({}, newUserKeychain, userKeychain);
        };
        const backupKeychainPromise = async () => {
            if (params.backupXpubProvider) {
                // If requested, use a KRS or backup key provider
                return this.baseCoin.keychains().createBackup({
                    provider: params.backupXpubProvider || 'defaultRMGBackupProvider',
                    disableKRSEmail: params.disableKRSEmail,
                    krsSpecific: params.krsSpecific,
                    type: this.baseCoin.getChain(),
                    passphrase: params.passphrase,
                    reqId,
                });
            }
            // User provided backup xpub
            if (params.backupXpub) {
                // user provided backup ethereum address
                return this.baseCoin.keychains().add({
                    pub: params.backupXpub,
                    source: 'backup',
                    reqId,
                });
            }
            else {
                if (!canEncrypt) {
                    throw new Error('cannot generate backup keypair without passphrase');
                }
                // No provided backup xpub or address, so default to creating one here
                return this.baseCoin.keychains().createBackup({ reqId, passphrase: params.passphrase });
            }
        };
        const { userKeychain, backupKeychain, bitgoKeychain } = await (0, utils_1.promiseProps)({
            userKeychain: userKeychainPromise(),
            backupKeychain: backupKeychainPromise(),
            bitgoKeychain: this.baseCoin
                .keychains()
                .createBitGo({ enterprise: params.enterprise, reqId, isDistributedCustody: params.isDistributedCustody }),
        });
        walletParams.keys = [userKeychain.id, backupKeychain.id, bitgoKeychain.id];
        const { prv } = userKeychain;
        if (_.isString(prv)) {
            (0, assert_1.default)(backupKeychain.pub);
            (0, assert_1.default)(bitgoKeychain.pub);
            walletParams.keySignatures = {
                backup: (await this.baseCoin.signMessage({ prv }, backupKeychain.pub)).toString('hex'),
                bitgo: (await this.baseCoin.signMessage({ prv }, bitgoKeychain.pub)).toString('hex'),
            };
        }
        if (_.includes(['xrp', 'xlm', 'cspr'], this.baseCoin.getFamily()) && !_.isUndefined(params.rootPrivateKey)) {
            walletParams.rootPrivateKey = params.rootPrivateKey;
        }
        // Custodial onchain wallets do not need m, n, keys, or keySignatures
        if (params.type === 'custodial' && ((_a = params.multisigType) !== null && _a !== void 0 ? _a : 'onchain') === 'onchain') {
            walletParams.n = undefined;
            walletParams.m = undefined;
            walletParams.keys = undefined;
            walletParams.keySignatures = undefined;
        }
        const keychains = {
            userKeychain,
            backupKeychain,
            bitgoKeychain,
        };
        const finalWalletParams = await this.baseCoin.supplementGenerateWallet(walletParams, keychains);
        this.bitgo.setRequestTracer(reqId);
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(finalWalletParams).result();
        const result = {
            wallet: new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet),
            userKeychain: userKeychain,
            backupKeychain: backupKeychain,
            bitgoKeychain: bitgoKeychain,
        };
        if (!_.isUndefined(backupKeychain.prv)) {
            result.warning = 'Be sure to backup the backup keychain -- it is not stored anywhere else!';
        }
        if (!_.isUndefined(derivationPath)) {
            userKeychain.derivationPath = derivationPath;
        }
        return result;
    }
    /**
     * List the user's wallet shares
     * @param params
     */
    async listShares(params = {}) {
        return await this.bitgo.get(this.baseCoin.url('/walletshare')).result();
    }
    /**
     * Gets a wallet share information, including the encrypted sharing keychain. requires unlock if keychain is present.
     * @param params
     * @param params.walletShareId - the wallet share to get information on
     */
    async getShare(params = {}) {
        common.validateParams(params, ['walletShareId'], []);
        return await this.bitgo.get(this.baseCoin.url('/walletshare/' + params.walletShareId)).result();
    }
    /**
     * Update a wallet share
     * @param params.walletShareId - the wallet share to update
     * @param params.state - the new state of the wallet share
     * @param params
     */
    async updateShare(params = {}) {
        common.validateParams(params, ['walletShareId'], []);
        return await this.bitgo
            .post(this.baseCoin.url('/walletshare/' + params.walletShareId))
            .send(params)
            .result();
    }
    /**
     * Resend a wallet share invitation email
     * @param params
     * @param params.walletShareId - the wallet share whose invitiation should be resent
     */
    async resendShareInvite(params = {}) {
        common.validateParams(params, ['walletShareId'], []);
        const urlParts = params.walletShareId + '/resendemail';
        return this.bitgo.post(this.baseCoin.url('/walletshare/' + urlParts)).result();
    }
    /**
     * Cancel a wallet share
     * @param params
     * @param params.walletShareId - the wallet share to update
     */
    async cancelShare(params = {}) {
        common.validateParams(params, ['walletShareId'], []);
        return await this.bitgo
            .del(this.baseCoin.url('/walletshare/' + params.walletShareId))
            .send()
            .result();
    }
    /**
     * Re-share wallet with existing spenders of the wallet
     * @param walletId
     * @param userPassword
     */
    async reshareWalletWithSpenders(walletId, userPassword) {
        var _a, _b;
        const wallet = await this.get({ id: walletId });
        if (!((_a = wallet === null || wallet === void 0 ? void 0 : wallet._wallet) === null || _a === void 0 ? void 0 : _a.enterprise)) {
            throw new Error('Enterprise not found for the wallet');
        }
        const enterpriseUsersResponse = await this.bitgo
            .get(this.bitgo.url(`/enterprise/${(_b = wallet === null || wallet === void 0 ? void 0 : wallet._wallet) === null || _b === void 0 ? void 0 : _b.enterprise}/user`))
            .result();
        // create a map of users for easy lookup - we need the user email id to share the wallet
        const usersMap = new Map([...enterpriseUsersResponse === null || enterpriseUsersResponse === void 0 ? void 0 : enterpriseUsersResponse.adminUsers, ...enterpriseUsersResponse === null || enterpriseUsersResponse === void 0 ? void 0 : enterpriseUsersResponse.nonAdminUsers].map((obj) => [obj.id, obj]));
        if (wallet._wallet.users) {
            for (const user of wallet._wallet.users) {
                const userObject = usersMap.get(user.user);
                if (user.permissions.includes('spend') && !user.permissions.includes('admin') && userObject) {
                    const shareParams = {
                        walletId: walletId,
                        user: user.user,
                        permissions: user.permissions.join(','),
                        walletPassphrase: userPassword,
                        email: userObject.email.email,
                        reshare: true,
                        skipKeychain: false,
                    };
                    await wallet.shareWallet(shareParams);
                }
            }
        }
    }
    /**
     * Accepts a wallet share, adding the wallet to the user's list
     * Needs a user's password to decrypt the shared key
     *
     * @param params
     * @param params.walletShareId - the wallet share to accept
     * @param params.userPassword - (required if more a keychain was shared) user's password to decrypt the shared wallet
     * @param params.newWalletPassphrase - new wallet passphrase for saving the shared wallet prv.
     *                                     If left blank and a wallet with more than view permissions was shared,
     *                                     then the user's login password is used.
     * @param params.overrideEncryptedPrv - set only if the prv was received out-of-band.
     */
    async acceptShare(params = {}) {
        common.validateParams(params, ['walletShareId'], ['overrideEncryptedPrv', 'userPassword', 'newWalletPassphrase']);
        let encryptedPrv = params.overrideEncryptedPrv;
        const walletShare = await this.getShare({ walletShareId: params.walletShareId });
        if (walletShare.keychainOverrideRequired &&
            walletShare.permissions.indexOf('admin') !== -1 &&
            walletShare.permissions.indexOf('spend') !== -1) {
            if (_.isUndefined(params.userPassword)) {
                throw new Error('userPassword param must be provided to decrypt shared key');
            }
            const walletKeychain = await this.baseCoin.keychains().createUserKeychain(params.userPassword);
            if (_.isUndefined(walletKeychain.encryptedPrv)) {
                throw new Error('encryptedPrv was not found on wallet keychain');
            }
            const payload = {
                tradingAccountId: walletShare.wallet,
                pubkey: walletKeychain.pub,
                timestamp: new Date().toISOString(),
            };
            const payloadString = JSON.stringify(payload);
            const privateKey = this.bitgo.decrypt({
                password: params.userPassword,
                input: walletKeychain.encryptedPrv,
            });
            const signature = await this.baseCoin.signMessage({ prv: privateKey }, payloadString);
            const response = await this.updateShare({
                walletShareId: params.walletShareId,
                state: 'accepted',
                keyId: walletKeychain.id,
                signature: signature.toString('hex'),
                payload: payloadString,
            });
            // If the wallet share was accepted successfully (changed=true), reshare the wallet with the spenders
            if (response.changed && response.state === 'accepted') {
                try {
                    await this.reshareWalletWithSpenders(walletShare.wallet, params.userPassword);
                }
                catch (e) {
                    // TODO: PX-3826
                    // Do nothing
                }
            }
            return response;
        }
        // Return right away if there is no keychain to decrypt, or if explicit encryptedPrv was provided
        if (!walletShare.keychain || !walletShare.keychain.encryptedPrv || encryptedPrv) {
            return this.updateShare({
                walletShareId: params.walletShareId,
                state: 'accepted',
            });
        }
        // More than viewing was requested, so we need to process the wallet keys using the shared ecdh scheme
        if (_.isUndefined(params.userPassword)) {
            throw new Error('userPassword param must be provided to decrypt shared key');
        }
        const sharingKeychain = (await this.bitgo.getECDHKeychain());
        if (_.isUndefined(sharingKeychain.encryptedXprv)) {
            throw new Error('encryptedXprv was not found on sharing keychain');
        }
        // Now we have the sharing keychain, we can work out the secret used for sharing the wallet with us
        sharingKeychain.prv = this.bitgo.decrypt({
            password: params.userPassword,
            input: sharingKeychain.encryptedXprv,
        });
        const secret = (0, ecdh_1.getSharedSecret)(
        // Derive key by path (which is used between these 2 users only)
        utxo_lib_1.bip32.fromBase58(sharingKeychain.prv).derivePath((0, api_1.sanitizeLegacyPath)(walletShare.keychain.path)), Buffer.from(walletShare.keychain.fromPubKey, 'hex')).toString('hex');
        // Yes! We got the secret successfully here, now decrypt the shared wallet prv
        const decryptedSharedWalletPrv = this.bitgo.decrypt({
            password: secret,
            input: walletShare.keychain.encryptedPrv,
        });
        // We will now re-encrypt the wallet with our own password
        const newWalletPassphrase = params.newWalletPassphrase || params.userPassword;
        encryptedPrv = this.bitgo.encrypt({
            password: newWalletPassphrase,
            input: decryptedSharedWalletPrv,
        });
        const updateParams = {
            walletShareId: params.walletShareId,
            state: 'accepted',
        };
        if (encryptedPrv) {
            updateParams.encryptedPrv = encryptedPrv;
        }
        return this.updateShare(updateParams);
    }
    /**
     * Get a wallet by its ID
     * @param params
     * @param params.id wallet id
     * @returns {*}
     */
    async getWallet(params = {}) {
        common.validateParams(params, ['id'], []);
        const query = {};
        if (params.allTokens) {
            if (!_.isBoolean(params.allTokens)) {
                throw new Error('invalid allTokens argument, expecting boolean');
            }
            query.allTokens = params.allTokens;
        }
        this.bitgo.setRequestTracer(params.reqId || new utils_1.RequestTracer());
        const wallet = await this.bitgo
            .get(this.baseCoin.url('/wallet/' + params.id))
            .query(query)
            .result();
        return new wallet_1.Wallet(this.bitgo, this.baseCoin, wallet);
    }
    /**
     * Get a wallet by its address
     * @param params
     * @param params.address wallet address
     * @returns {*}
     */
    async getWalletByAddress(params = {}) {
        common.validateParams(params, ['address'], []);
        this.bitgo.setRequestTracer(params.reqId || new utils_1.RequestTracer());
        const wallet = await this.bitgo.get(this.baseCoin.url('/wallet/address/' + params.address)).result();
        return new wallet_1.Wallet(this.bitgo, this.baseCoin, wallet);
    }
    /**
     * For any given supported coin, get total balances for all wallets of that
     * coin type on the account.
     * @param params
     * @returns {*}
     */
    async getTotalBalances(params = {}) {
        return await this.bitgo.get(this.baseCoin.url('/wallet/balances')).result();
    }
    /**
     * Generates a TSS or BLS-DKG Wallet.
     * @param params
     * @private
     */
    async generateMpcWallet({ passphrase, label, multisigType, enterprise, walletVersion, originalPasscodeEncryptionCode, backupProvider, }) {
        var _a, _b;
        if (multisigType === 'tss' && this.baseCoin.getMPCAlgorithm() === 'ecdsa' && walletVersion === 3) {
            const tssSettings = await this.bitgo
                .get(this.bitgo.microservicesUrl('/api/v2/tss/settings'))
                .result();
            const multisigTypeVersion = (_b = (_a = tssSettings.coinSettings[this.baseCoin.getFamily()]) === null || _a === void 0 ? void 0 : _a.walletCreationSettings) === null || _b === void 0 ? void 0 : _b.multiSigTypeVersion;
            if (multisigTypeVersion === 'MPCv2') {
                walletVersion = 5;
            }
        }
        const reqId = new utils_1.RequestTracer();
        this.bitgo.setRequestTracer(reqId);
        // Create MPC Keychains
        const keychains = await this.baseCoin.keychains().createMpc({
            multisigType,
            passphrase,
            enterprise,
            originalPasscodeEncryptionCode,
            backupProvider,
        });
        // Create Wallet
        const { userKeychain, backupKeychain, bitgoKeychain } = keychains;
        const walletParams = {
            label,
            m: 2,
            n: 3,
            keys: [userKeychain.id, backupKeychain.id, bitgoKeychain.id],
            type: 'hot',
            multisigType,
            enterprise,
            walletVersion,
        };
        const finalWalletParams = await this.baseCoin.supplementGenerateWallet(walletParams, keychains);
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(finalWalletParams).result();
        const result = {
            wallet: new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet),
            userKeychain,
            backupKeychain,
            bitgoKeychain,
        };
        if (!_.isUndefined(backupKeychain.prv) && !_.isUndefined(backupProvider)) {
            result.warning = 'Be sure to backup the backup keychain -- it is not stored anywhere else!';
        }
        return result;
    }
    /**
     * Generates a Self-Managed Cold TSS Wallet.
     * @param params
     * @private
     */
    async generateSMCMpcWallet({ label, multisigType, enterprise, walletVersion, bitgoKeyId, commonKeychain, coldDerivationSeed, }) {
        const reqId = new utils_1.RequestTracer();
        this.bitgo.setRequestTracer(reqId);
        // Create MPC Keychains
        const bitgoKeychain = await this.baseCoin.keychains().get({ id: bitgoKeyId });
        if (!bitgoKeychain || !bitgoKeychain.commonKeychain) {
            throw new Error('BitGo keychain not found');
        }
        if (bitgoKeychain.source !== 'bitgo') {
            throw new Error('The provided bitgoKeyId is not a BitGo keychain');
        }
        if (bitgoKeychain.commonKeychain !== commonKeychain) {
            throw new Error('The provided Common keychain mismatch with the provided Bitgo key');
        }
        if (!coldDerivationSeed) {
            throw new Error('derivedFromParentWithSeed is required');
        }
        const userKeychainParams = {
            source: 'user',
            keyType: 'tss',
            commonKeychain: commonKeychain,
            derivedFromParentWithSeed: coldDerivationSeed,
        };
        const userKeychain = await this.baseCoin.keychains().add(userKeychainParams);
        const backupKeyChainParams = {
            source: 'backup',
            keyType: 'tss',
            commonKeychain: commonKeychain,
            derivedFromParentWithSeed: coldDerivationSeed,
        };
        const backupKeychain = await this.baseCoin.keychains().add(backupKeyChainParams);
        // Create Wallet
        const keychains = { userKeychain, backupKeychain, bitgoKeychain };
        const walletParams = {
            label,
            m: 2,
            n: 3,
            keys: [userKeychain.id, backupKeychain.id, bitgoKeychain.id],
            type: 'cold',
            multisigType,
            enterprise,
            walletVersion,
        };
        const finalWalletParams = await this.baseCoin.supplementGenerateWallet(walletParams, keychains);
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(finalWalletParams).result();
        const result = {
            wallet: new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet),
            userKeychain,
            backupKeychain,
            bitgoKeychain,
        };
        return result;
    }
    /**
     * Generates a Custodial TSS Wallet.
     * @param params
     * @private
     */
    async generateCustodialMpcWallet({ label, multisigType, enterprise, walletVersion, }) {
        const reqId = new utils_1.RequestTracer();
        this.bitgo.setRequestTracer(reqId);
        const finalWalletParams = {
            label,
            multisigType,
            enterprise,
            walletVersion,
            type: 'custodial',
        };
        // Create Wallet
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(finalWalletParams).result();
        const wallet = new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet);
        const keychains = wallet.keyIds();
        const result = {
            wallet,
            userKeychain: { id: keychains[0], type: multisigType, source: 'user' },
            backupKeychain: { id: keychains[1], type: multisigType, source: 'backup' },
            bitgoKeychain: { id: keychains[2], type: multisigType, source: 'bitgo' },
        };
        return result;
    }
}
exports.Wallets = Wallets;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9iaXRnby93YWxsZXQvd2FsbGV0cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0gsb0RBQTRCO0FBQzVCLCtDQUF5QztBQUN6Qyw4Q0FBd0M7QUFDeEMsMENBQTRCO0FBQzVCLDRDQUE2QztBQUU3QyxtQ0FBK0M7QUFDL0MscURBQXVDO0FBR3ZDLGtDQUEwQztBQUUxQyxvQ0FBdUQ7QUFldkQscUNBQWtDO0FBR2xDLE1BQWEsT0FBTztJQUlsQixZQUFZLEtBQWdCLEVBQUUsUUFBbUI7UUFDL0MsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxHQUFHLENBQUMsU0FBMkIsRUFBRTtRQUNyQyxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQTRCLEVBQUU7UUFDdkMsTUFBTSxXQUFXLEdBQXNCLEVBQUUsQ0FBQztRQUUxQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTtZQUNoQyxNQUFNLElBQUksS0FBSyxDQUFDLHFDQUFxQyxDQUFDLENBQUM7U0FDeEQ7UUFFRCxJQUFJLE1BQU0sQ0FBQyxXQUFXLEVBQUU7WUFDdEIsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFFO2dCQUNwQyxNQUFNLElBQUksS0FBSyxDQUFDLGlEQUFpRCxDQUFDLENBQUM7YUFDcEU7WUFDRCxXQUFXLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUM7U0FDOUM7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RUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFO1lBQ3RFLGNBQWMsRUFBRSxFQUFFLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFO1lBQzFFLGFBQWEsRUFBRSxFQUFFLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFO1NBQ3pFLENBQUM7UUFFRixPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0NBQ0Y7QUE1NUJELDBCQTQ1QkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgYmlwMzIgfSBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgQ29pbkZlYXR1cmUgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5cbmltcG9ydCB7IHNhbml0aXplTGVnYWN5UGF0aCB9IGZyb20gJy4uLy4uL2FwaSc7XG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi4vLi4vY29tbW9uJztcbmltcG9ydCB7IElCYXNlQ29pbiwgS2V5Y2hhaW5zVHJpcGxldCwgU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyB9IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IEJpdEdvQmFzZSB9IGZyb20gJy4uL2JpdGdvQmFzZSc7XG5pbXBvcnQgeyBnZXRTaGFyZWRTZWNyZXQgfSBmcm9tICcuLi9lY2RoJztcbmltcG9ydCB7IEFkZEtleWNoYWluT3B0aW9ucywgS2V5Y2hhaW4gfSBmcm9tICcuLi9rZXljaGFpbic7XG5pbXBvcnQgeyBwcm9taXNlUHJvcHMsIFJlcXVlc3RUcmFjZXIgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQge1xuICBBY2NlcHRTaGFyZU9wdGlvbnMsXG4gIEFkZFdhbGxldE9wdGlvbnMsXG4gIEdlbmVyYXRlQmFzZU1wY1dhbGxldE9wdGlvbnMsXG4gIEdlbmVyYXRlTXBjV2FsbGV0T3B0aW9ucyxcbiAgR2VuZXJhdGVTTUNNcGNXYWxsZXRPcHRpb25zLFxuICBHZW5lcmF0ZVdhbGxldE9wdGlvbnMsXG4gIEdldFdhbGxldEJ5QWRkcmVzc09wdGlvbnMsXG4gIEdldFdhbGxldE9wdGlvbnMsXG4gIElXYWxsZXRzLFxuICBMaXN0V2FsbGV0T3B0aW9ucyxcbiAgVXBkYXRlU2hhcmVPcHRpb25zLFxuICBXYWxsZXRXaXRoS2V5Y2hhaW5zLFxufSBmcm9tICcuL2lXYWxsZXRzJztcbmltcG9ydCB7IFdhbGxldCB9IGZyb20gJy4vd2FsbGV0JztcbmltcG9ydCB7IFRzc1NldHRpbmdzIH0gZnJvbSAnQGJpdGdvL3B1YmxpYy10eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXYWxsZXRzIGltcGxlbWVudHMgSVdhbGxldHMge1xuICBwcml2YXRlIHJlYWRvbmx5IGJpdGdvOiBCaXRHb0Jhc2U7XG4gIHByaXZhdGUgcmVhZG9ubHkgYmFzZUNvaW46IElCYXNlQ29pbjtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlLCBiYXNlQ29pbjogSUJhc2VDb2luKSB7XG4gICAgdGhpcy5iaXRnbyA9IGJpdGdvO1xuICAgIHRoaXMuYmFzZUNvaW4gPSBiYXNlQ29pbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB3YWxsZXQgYnkgSUQgKHByb3h5IGZvciBnZXRXYWxsZXQpXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIGdldChwYXJhbXM6IEdldFdhbGxldE9wdGlvbnMgPSB7fSk6IFByb21pc2U8V2FsbGV0PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V2FsbGV0KHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCBhIHVzZXIncyB3YWxsZXRzXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyBsaXN0KHBhcmFtczogTGlzdFdhbGxldE9wdGlvbnMgPSB7fSk6IFByb21pc2U8eyB3YWxsZXRzOiBXYWxsZXRbXSB9PiB7XG4gICAgY29uc3QgcXVlcnlPYmplY3Q6IExpc3RXYWxsZXRPcHRpb25zID0ge307XG5cbiAgICBpZiAocGFyYW1zLnNraXAgJiYgcGFyYW1zLnByZXZJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3BlY2lmeSBib3RoIHNraXAgYW5kIHByZXZJZCcpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuZ2V0YmFsYW5jZXMpIHtcbiAgICAgIGlmICghXy5pc0Jvb2xlYW4ocGFyYW1zLmdldGJhbGFuY2VzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZ2V0YmFsYW5jZXMgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICB9XG4gICAgICBxdWVyeU9iamVjdC5nZXRiYWxhbmNlcyA9IHBhcmFtcy5nZXRiYWxhbmNlcztcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5wcmV2SWQpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucHJldklkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJldklkIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBxdWVyeU9iamVjdC5wcmV2SWQgPSBwYXJhbXMucHJldklkO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmxpbWl0KSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLmxpbWl0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGltaXQgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5T2JqZWN0LmxpbWl0ID0gcGFyYW1zLmxpbWl0O1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuYWxsVG9rZW5zKSB7XG4gICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5hbGxUb2tlbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhbGxUb2tlbnMgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICB9XG4gICAgICBxdWVyeU9iamVjdC5hbGxUb2tlbnMgPSBwYXJhbXMuYWxsVG9rZW5zO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHkgPSAoYXdhaXQgdGhpcy5iaXRnby5nZXQodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQnKSkucXVlcnkocXVlcnlPYmplY3QpLnJlc3VsdCgpKSBhcyBhbnk7XG4gICAgYm9keS53YWxsZXRzID0gYm9keS53YWxsZXRzLm1hcCgodykgPT4gbmV3IFdhbGxldCh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luLCB3KSk7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cblxuICAvKipcbiAgICogYWRkXG4gICAqIEFkZCBhIG5ldyB3YWxsZXQgKGFkdmFuY2VkIG1vZGUpLlxuICAgKiBUaGlzIGFsbG93cyB5b3UgdG8gbWFudWFsbHkgc3VibWl0IHRoZSBrZXlzLCB0eXBlLCBtIGFuZCBuIG9mIHRoZSB3YWxsZXRcbiAgICogUGFyYW1ldGVycyBpbmNsdWRlOlxuICAgKiAgICBcImxhYmVsXCI6IGxhYmVsIG9mIHRoZSB3YWxsZXQgdG8gYmUgc2hvd24gaW4gVUlcbiAgICogICAgXCJtXCI6IG51bWJlciBvZiBrZXlzIHJlcXVpcmVkIHRvIHVubG9jayB3YWxsZXQgKDIpXG4gICAqICAgIFwiblwiOiBudW1iZXIgb2Yga2V5cyBhdmFpbGFibGUgb24gdGhlIHdhbGxldCAoMylcbiAgICogICAgXCJrZXlzXCI6IGFycmF5IG9mIGtleWNoYWluIGlkc1xuICAgKi9cbiAgYXN5bmMgYWRkKHBhcmFtczogQWRkV2FsbGV0T3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsnbGFiZWwnLCAnZW50ZXJwcmlzZScsICd0eXBlJ10pO1xuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMubGFiZWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgc3RyaW5nIHBhcmFtZXRlciBsYWJlbCcpO1xuICAgIH1cblxuICAgIC8vIG5vIG5lZWQgdG8gcGFzcyBrZXlzIGZvciAoc2luZ2xlKSBjdXN0b2RpYWwgd2FsbGV0c1xuICAgIGlmIChwYXJhbXMudHlwZSAhPT0gJ2N1c3RvZGlhbCcpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcy5rZXlzKSA9PT0gZmFsc2UgfHwgIV8uaXNOdW1iZXIocGFyYW1zLm0pIHx8ICFfLmlzTnVtYmVyKHBhcmFtcy5uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogc3VwcG9ydCBtb3JlIHR5cGVzIG9mIG11bHRpc2lnXG4gICAgICBpZiAoIXRoaXMuYmFzZUNvaW4uaXNWYWxpZE1vZk5TZXR1cChwYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgbXVsdGktc2lnIHR5cGUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmdhc1ByaWNlICYmICFfLmlzTnVtYmVyKHBhcmFtcy5nYXNQcmljZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgZ2FzUHJpY2UgLSBudW1iZXIgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLndhbGxldFZlcnNpb24pIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMud2FsbGV0VmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciB3YWxsZXRWZXJzaW9uIC0gbnVtYmVyIGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLm11bHRpc2lnVHlwZSA9PT0gJ3RzcycgJiYgdGhpcy5iYXNlQ29pbi5nZXRNUENBbGdvcml0aG0oKSA9PT0gJ2VjZHNhJyAmJiBwYXJhbXMud2FsbGV0VmVyc2lvbiA9PT0gMykge1xuICAgICAgICBjb25zdCB0c3NTZXR0aW5nczogVHNzU2V0dGluZ3MgPSBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAgICAgLmdldCh0aGlzLmJpdGdvLm1pY3Jvc2VydmljZXNVcmwoJy9hcGkvdjIvdHNzL3NldHRpbmdzJykpXG4gICAgICAgICAgLnJlc3VsdCgpO1xuICAgICAgICBjb25zdCBtdWx0aXNpZ1R5cGVWZXJzaW9uID1cbiAgICAgICAgICB0c3NTZXR0aW5ncy5jb2luU2V0dGluZ3NbdGhpcy5iYXNlQ29pbi5nZXRGYW1pbHkoKV0/LndhbGxldENyZWF0aW9uU2V0dGluZ3M/Lm11bHRpU2lnVHlwZVZlcnNpb247XG4gICAgICAgIGlmIChtdWx0aXNpZ1R5cGVWZXJzaW9uID09PSAnTVBDdjInKSB7XG4gICAgICAgICAgcGFyYW1zLndhbGxldFZlcnNpb24gPSA1O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy50YWdzICYmIEFycmF5LmlzQXJyYXkocGFyYW1zLnRhZ3MpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciB0YWdzIC0gYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmNsaWVudEZsYWdzICYmIEFycmF5LmlzQXJyYXkocGFyYW1zLmNsaWVudEZsYWdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgY2xpZW50RmxhZ3MgLSBhcnJheSBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuaXNDb2xkICYmICFfLmlzQm9vbGVhbihwYXJhbXMuaXNDb2xkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBpc0NvbGQgLSBib29sZWFuIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5pc0N1c3RvZGlhbCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmlzQ3VzdG9kaWFsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBpc0N1c3RvZGlhbCAtIGJvb2xlYW4gZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmFkZHJlc3MgJiYgKCFfLmlzU3RyaW5nKHBhcmFtcy5hZGRyZXNzKSB8fCAhdGhpcy5iYXNlQ29pbi5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMuYWRkcmVzcykpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGFkZHJlc3MgLSB2YWxpZCBhZGRyZXNzIHN0cmluZyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1dhbGxldCA9IGF3YWl0IHRoaXMuYml0Z28ucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldCcpKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhbGxldDogbmV3IFdhbGxldCh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luLCBuZXdXYWxsZXQpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBuZXcgd2FsbGV0XG4gICAqIDEuIENyZWF0ZXMgdGhlIHVzZXIga2V5Y2hhaW4gbG9jYWxseSBvbiB0aGUgY2xpZW50LCBhbmQgZW5jcnlwdHMgaXQgd2l0aCB0aGUgcHJvdmlkZWQgcGFzc3BocmFzZVxuICAgKiAyLiBJZiBubyBwdWIgd2FzIHByb3ZpZGVkLCBjcmVhdGVzIHRoZSBiYWNrdXAga2V5Y2hhaW4gbG9jYWxseSBvbiB0aGUgY2xpZW50LCBhbmQgZW5jcnlwdHMgaXQgd2l0aCB0aGUgcHJvdmlkZWQgcGFzc3BocmFzZVxuICAgKiAzLiBVcGxvYWRzIHRoZSBlbmNyeXB0ZWQgdXNlciBhbmQgYmFja3VwIGtleWNoYWlucyB0byBCaXRHb1xuICAgKiA0LiBDcmVhdGVzIHRoZSBCaXRHbyBrZXkgb24gdGhlIHNlcnZpY2VcbiAgICogNS4gQ3JlYXRlcyB0aGUgd2FsbGV0IG9uIEJpdEdvIHdpdGggdGhlIDMgcHVibGljIGtleXMgYWJvdmVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmxhYmVsIExhYmVsIGZvciB0aGUgd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXMucGFzc3BocmFzZSBQYXNzcGhyYXNlIHRvIGJlIHVzZWQgdG8gZW5jcnlwdCB0aGUgdXNlciBhbmQgYmFja3VwIGtleWNoYWluc1xuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJLZXkgVXNlciB4cHViXG4gICAqIEBwYXJhbSBwYXJhbXMuYmFja3VwWHB1YiBCYWNrdXAgeHB1YlxuICAgKiBAcGFyYW0gcGFyYW1zLmJhY2t1cFhwdWJQcm92aWRlclxuICAgKiBAcGFyYW0gcGFyYW1zLmJhY2t1cFByb3ZpZGVyIFRoaXJkIHBhcnR5IGJhY2t1cCBwcm92aWRlciBmb3IgVFNTXG4gICAqIEBwYXJhbSBwYXJhbXMuZW50ZXJwcmlzZSB0aGUgZW50ZXJwcmlzZUlkXG4gICAqIEBwYXJhbSBwYXJhbXMuZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9uc1xuICAgKiBAcGFyYW0gcGFyYW1zLnBhc3Njb2RlRW5jcnlwdGlvbkNvZGUgb3B0aW9uYWwgdGhpcyBpcyBhIHJlY292ZXJ5IGNvZGUgdGhhdCBjYW4gYmUgdXNlZCB0byBkZWNyeXB0IHRoZSBvcmlnaW5hbCBwYXNzcGhyYXNlIGluIGEgcmVjb3ZlcnkgY2FzZS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSB1c2VyIG11c3QgZ2VuZXJhdGUgYW5kIGtlZXAgdGhlIGVuY3J5cHRlZCBvcmlnaW5hbCBwYXNzcGhyYXNlIHNhZmUgd2hpbGUgdGhpcyBjb2RlIGlzIHN0b3JlZCBvbiBCaXRHb1xuICAgKiBAcGFyYW0gcGFyYW1zLmNvbGREZXJpdmF0aW9uU2VlZCBvcHRpb25hbCBzZWVkIGZvciBTTUMgd2FsbGV0c1xuICAgKiBAcGFyYW0gcGFyYW1zLmdhc1ByaWNlXG4gICAqIEBwYXJhbSBwYXJhbXMuZGlzYWJsZUtSU0VtYWlsXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0VmVyc2lvblxuICAgKiBAcGFyYW0gcGFyYW1zLm11bHRpc2lnVHlwZSBvcHRpb25hbCBtdWx0aXNpZyB0eXBlLCAnb25jaGFpbicgb3IgJ3Rzcycgb3IgJ2Jsc2RrZyc7IGlmIGFic2VudCwgd2Ugd2lsbCBkZWZlciB0byB0aGUgY29pbidzIGRlZmF1bHQgdHlwZVxuICAgKiBAcGFyYW0gcGFyYW1zLmlzRGlzdHJpYnV0ZWRDdXN0b2R5IG9wdGlvbmFsIHBhcmFtZXRlciBmb3IgY3JlYXRpbmcgYml0Z28ga2V5LiBUaGlzIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIHlvdSB3YW50IHRvIGNyZWF0ZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZGlzdHJpYnV0ZWQgY3VzdG9keSB3YWxsZXQuIElmIHByb3ZpZGVkLCB5b3UgbXVzdCBoYXZlIHRoZSBlbnRlcnByaXNlIGxpY2Vuc2UgYW5kIHBhc3MgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgcGFyYW1zLmVudGVycHJpc2VgIGludG8gYGdlbmVyYXRlV2FsbGV0YCBhcyB3ZWxsLlxuICAgKiBAcGFyYW0gcGFyYW1zLnR5cGUgb3B0aW9uYWwgd2FsbGV0IHR5cGUsICdob3QnIG9yICdjb2xkJyBvciAnY3VzdG9kaWFsJzsgaWYgYWJzZW50LCB3ZSB3aWxsIGRlZmVyIHRvICdob3QnXG4gICAqIEBwYXJhbSBwYXJhbXMuYml0Z29LZXlJZCBvcHRpb25hbCBiaXRnbyBrZXkgaWQgZm9yIFNNQyBUU1Mgd2FsbGV0c1xuICAgKiBAcGFyYW0gcGFyYW1zLmNvbW1vbktleWNoYWluIG9wdGlvbmFsIGNvbW1vbiBrZXljaGFpbiBmb3IgU01DIFRTUyB3YWxsZXRzXG4gICAqXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVXYWxsZXQocGFyYW1zOiBHZW5lcmF0ZVdhbGxldE9wdGlvbnMgPSB7fSk6IFByb21pc2U8V2FsbGV0V2l0aEtleWNoYWlucz4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnbGFiZWwnXSwgWydwYXNzcGhyYXNlJywgJ3VzZXJLZXknLCAnYmFja3VwWHB1YiddKTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5sYWJlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBzdHJpbmcgcGFyYW1ldGVyIGxhYmVsJyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyB0eXBlID0gJ2hvdCcsIGxhYmVsLCBwYXNzcGhyYXNlLCBlbnRlcnByaXNlLCBpc0Rpc3RyaWJ1dGVkQ3VzdG9keSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGlzVHNzID0gcGFyYW1zLm11bHRpc2lnVHlwZSA9PT0gJ3RzcycgJiYgdGhpcy5iYXNlQ29pbi5zdXBwb3J0c1RzcygpO1xuICAgIGNvbnN0IGNhbkVuY3J5cHQgPSAhIXBhc3NwaHJhc2UgJiYgdHlwZW9mIHBhc3NwaHJhc2UgPT09ICdzdHJpbmcnO1xuXG4gICAgY29uc3Qgd2FsbGV0UGFyYW1zOiBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zID0ge1xuICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgbTogMixcbiAgICAgIG46IDMsXG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHR5cGU6ICEhcGFyYW1zLnVzZXJLZXkgJiYgcGFyYW1zLm11bHRpc2lnVHlwZSAhPT0gJ29uY2hhaW4nID8gJ2NvbGQnIDogdHlwZSxcbiAgICB9O1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlKSkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3Njb2RlRW5jcnlwdGlvbkNvZGUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChlbnRlcnByaXNlKSkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKGVudGVycHJpc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBlbnRlcnByaXNlIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICB3YWxsZXRQYXJhbXMuZW50ZXJwcmlzZSA9IGVudGVycHJpc2U7XG4gICAgfVxuXG4gICAgLy8gRVZNIFRTUyB3YWxsZXRzIG11c3QgdXNlIHdhbGxldCB2ZXJzaW9uIDMgYW5kIDVcbiAgICBpZiAoaXNUc3MgJiYgdGhpcy5iYXNlQ29pbi5pc0VWTSgpICYmICEocGFyYW1zLndhbGxldFZlcnNpb24gPT09IDMgfHwgcGFyYW1zLndhbGxldFZlcnNpb24gPT09IDUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VWTSBUU1Mgd2FsbGV0cyBhcmUgb25seSBzdXBwb3J0ZWQgZm9yIHdhbGxldCB2ZXJzaW9uIDMgYW5kIDUnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNUc3MpIHtcbiAgICAgIGlmICghdGhpcy5iYXNlQ29pbi5zdXBwb3J0c1RzcygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29pbiAke3RoaXMuYmFzZUNvaW4uZ2V0RmFtaWx5KCl9IGRvZXMgbm90IHN1cHBvcnQgVFNTIGF0IHRoaXMgdGltZWApO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy53YWxsZXRWZXJzaW9uID09PSA1ICYmICF0aGlzLmJhc2VDb2luLmdldENvbmZpZygpLmZlYXR1cmVzLmluY2x1ZGVzKENvaW5GZWF0dXJlLk1QQ1YyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvaW4gJHt0aGlzLmJhc2VDb2luLmdldEZhbWlseSgpfSBkb2VzIG5vdCBzdXBwb3J0IFRTUyBNUEN2MiBhdCB0aGlzIHRpbWVgKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChlbnRlcnByaXNlLCAnZW50ZXJwcmlzZSBpcyByZXF1aXJlZCBmb3IgVFNTIHdhbGxldCcpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2NvbGQnKSB7XG4gICAgICAgIGlmIChwYXJhbXMud2FsbGV0VmVyc2lvbiA9PT0gNSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRVZNIFRTUyBNUEN2MiB3YWxsZXRzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBjb2xkIHdhbGxldHMnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB2YWxpZGF0ZVxuICAgICAgICBhc3NlcnQocGFyYW1zLmJpdGdvS2V5SWQsICdiaXRnb0tleUlkIGlzIHJlcXVpcmVkIGZvciBTTUMgVFNTIHdhbGxldCcpO1xuICAgICAgICBhc3NlcnQocGFyYW1zLmNvbW1vbktleWNoYWluLCAnY29tbW9uS2V5Y2hhaW4gaXMgcmVxdWlyZWQgZm9yIFNNQyBUU1Mgd2FsbGV0Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlU01DTXBjV2FsbGV0KHtcbiAgICAgICAgICBtdWx0aXNpZ1R5cGU6ICd0c3MnLFxuICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgIGVudGVycHJpc2UsXG4gICAgICAgICAgd2FsbGV0VmVyc2lvbjogcGFyYW1zLndhbGxldFZlcnNpb24sXG4gICAgICAgICAgYml0Z29LZXlJZDogcGFyYW1zLmJpdGdvS2V5SWQsXG4gICAgICAgICAgY29tbW9uS2V5Y2hhaW46IHBhcmFtcy5jb21tb25LZXljaGFpbixcbiAgICAgICAgICBjb2xkRGVyaXZhdGlvblNlZWQ6IHBhcmFtcy5jb2xkRGVyaXZhdGlvblNlZWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gJ2N1c3RvZGlhbCcpIHtcbiAgICAgICAgaWYgKHBhcmFtcy53YWxsZXRWZXJzaW9uID09PSA1KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFVk0gVFNTIE1QQ3YyIHdhbGxldHMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGN1c3RvZGlhbCB3YWxsZXRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVDdXN0b2RpYWxNcGNXYWxsZXQoe1xuICAgICAgICAgIG11bHRpc2lnVHlwZTogJ3RzcycsXG4gICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgZW50ZXJwcmlzZSxcbiAgICAgICAgICB3YWxsZXRWZXJzaW9uOiBwYXJhbXMud2FsbGV0VmVyc2lvbixcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGFzc2VydChwYXNzcGhyYXNlLCAnY2Fubm90IGdlbmVyYXRlIFRTUyBrZXlzIHdpdGhvdXQgcGFzc3BocmFzZScpO1xuXG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZU1wY1dhbGxldCh7XG4gICAgICAgIG11bHRpc2lnVHlwZTogJ3RzcycsXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBwYXNzcGhyYXNlLFxuICAgICAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGU6IHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgICAgICBlbnRlcnByaXNlLFxuICAgICAgICB3YWxsZXRWZXJzaW9uOiBwYXJhbXMud2FsbGV0VmVyc2lvbixcbiAgICAgICAgYmFja3VwUHJvdmlkZXI6IHBhcmFtcy5iYWNrdXBQcm92aWRlcixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGlzQmxzRGtnID0gcGFyYW1zLm11bHRpc2lnVHlwZSA/IHBhcmFtcy5tdWx0aXNpZ1R5cGUgPT09ICdibHNka2cnIDogdGhpcy5iYXNlQ29pbi5zdXBwb3J0c0Jsc0RrZygpO1xuICAgIGlmIChpc0Jsc0RrZykge1xuICAgICAgaWYgKCF0aGlzLmJhc2VDb2luLnN1cHBvcnRzQmxzRGtnKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb2luICR7dGhpcy5iYXNlQ29pbi5nZXRGYW1pbHkoKX0gZG9lcyBub3Qgc3VwcG9ydCBCTFMtREtHIGF0IHRoaXMgdGltZWApO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGVudGVycHJpc2UsICdlbnRlcnByaXNlIGlzIHJlcXVpcmVkIGZvciBCTFMtREtHIHdhbGxldCcpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2NvbGQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQkxTLURLRyBTTUMgd2FsbGV0cyBhcmUgbm90IHN1cHBvcnRlZCBhdCB0aGlzIHRpbWUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdjdXN0b2RpYWwnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQkxTLURLRyBjdXN0b2RpYWwgd2FsbGV0cyBhcmUgbm90IHN1cHBvcnRlZCBhdCB0aGlzIHRpbWUnKTtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KHBhc3NwaHJhc2UsICdjYW5ub3QgZ2VuZXJhdGUgQkxTLURLRyBrZXlzIHdpdGhvdXQgcGFzc3BocmFzZScpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVNcGNXYWxsZXQoeyBtdWx0aXNpZ1R5cGU6ICdibHNka2cnLCBsYWJlbCwgcGFzc3BocmFzZSwgZW50ZXJwcmlzZSB9KTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZGlzdHJpYnV0ZWQgY3VzdG9keVxuICAgIGlmIChpc0Rpc3RyaWJ1dGVkQ3VzdG9keSkge1xuICAgICAgaWYgKCFlbnRlcnByaXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBwcm92aWRlIGVudGVycHJpc2Ugd2hlbiBjcmVhdGluZyBkaXN0cmlidXRlZCBjdXN0b2R5IHdhbGxldCcpO1xuICAgICAgfVxuICAgICAgaWYgKCF0eXBlIHx8IHR5cGUgIT09ICdjb2xkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3RyaWJ1dGVkIGN1c3RvZHkgd2FsbGV0cyBtdXN0IGJlIHR5cGU6IGNvbGQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBoYXNCYWNrdXBYcHViID0gISFwYXJhbXMuYmFja3VwWHB1YjtcbiAgICBjb25zdCBoYXNCYWNrdXBYcHViUHJvdmlkZXIgPSAhIXBhcmFtcy5iYWNrdXBYcHViUHJvdmlkZXI7XG4gICAgaWYgKGhhc0JhY2t1cFhwdWIgJiYgaGFzQmFja3VwWHB1YlByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwcm92aWRlIG1vcmUgdGhhbiBvbmUgYmFja3VwWHB1YiBvciBiYWNrdXBYcHViUHJvdmlkZXIgZmxhZycpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuZ2FzUHJpY2UgJiYgcGFyYW1zLmVpcDE1NTkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FuIG5vdCB1c2UgYm90aCBlaXAxNTU5IGFuZCBnYXNQcmljZSB2YWx1ZXMnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMpKSB7XG4gICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5kaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucyBhcmd1bWVudCwgZXhwZWN0aW5nIGJvb2xlYW4nKTtcbiAgICAgIH1cbiAgICAgIHdhbGxldFBhcmFtcy5kaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zID0gcGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5nYXNQcmljZSkpIHtcbiAgICAgIGNvbnN0IGdhc1ByaWNlQk4gPSBuZXcgQmlnTnVtYmVyKHBhcmFtcy5nYXNQcmljZSk7XG4gICAgICBpZiAoZ2FzUHJpY2VCTi5pc05hTigpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBnYXMgcHJpY2UgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXIgb3IgbnVtYmVyIGFzIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgd2FsbGV0UGFyYW1zLmdhc1ByaWNlID0gZ2FzUHJpY2VCTi50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZWlwMTU1OSkgJiYgIV8uaXNFbXB0eShwYXJhbXMuZWlwMTU1OSkpIHtcbiAgICAgIGNvbnN0IG1heEZlZVBlckdhc0JOID0gbmV3IEJpZ051bWJlcihwYXJhbXMuZWlwMTU1OS5tYXhGZWVQZXJHYXMpO1xuICAgICAgaWYgKG1heEZlZVBlckdhc0JOLmlzTmFOKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1heCBmZWUgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXIgb3IgbnVtYmVyIGFzIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF4UHJpb3JpdHlGZWVQZXJHYXNCTiA9IG5ldyBCaWdOdW1iZXIocGFyYW1zLmVpcDE1NTkubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgaWYgKG1heFByaW9yaXR5RmVlUGVyR2FzQk4uaXNOYU4oKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpb3JpdHkgZmVlIGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyIG9yIG51bWJlciBhcyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHdhbGxldFBhcmFtcy5laXAxNTU5ID0ge1xuICAgICAgICBtYXhGZWVQZXJHYXM6IG1heEZlZVBlckdhc0JOLnRvU3RyaW5nKCksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBtYXhQcmlvcml0eUZlZVBlckdhc0JOLnRvU3RyaW5nKCksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZGlzYWJsZUtSU0VtYWlsKSkge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuZGlzYWJsZUtSU0VtYWlsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGlzYWJsZUtSU0VtYWlsIGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgd2FsbGV0UGFyYW1zLmRpc2FibGVLUlNFbWFpbCA9IHBhcmFtcy5kaXNhYmxlS1JTRW1haWw7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy53YWxsZXRWZXJzaW9uKSkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy53YWxsZXRWZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgd2FsbGV0VmVyc2lvbiBwcm92aWRlZCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgd2FsbGV0UGFyYW1zLndhbGxldFZlcnNpb24gPSBwYXJhbXMud2FsbGV0VmVyc2lvbjtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgZWFjaCBrcnNTcGVjaWZpYyBwYXJhbSBpcyBlaXRoZXIgYSBzdHJpbmcsIGJvb2xlYW4sIG9yIG51bWJlclxuICAgIGNvbnN0IHsga3JzU3BlY2lmaWMgfSA9IHBhcmFtcztcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoa3JzU3BlY2lmaWMpKSB7XG4gICAgICBPYmplY3Qua2V5cyhrcnNTcGVjaWZpYykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGtyc1NwZWNpZmljW2tleV07XG4gICAgICAgIGlmICghXy5pc0Jvb2xlYW4odmFsKSAmJiAhXy5pc1N0cmluZyh2YWwpICYmICFfLmlzTnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tyc1NwZWNpZmljIG9iamVjdCBjb250YWlucyBpbGxlZ2FsIHZhbHVlcy4gdmFsdWVzIG11c3QgYmUgc3RyaW5ncywgYm9vbGVhbnMsIG9yIG51bWJlcnMnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IGRlcml2YXRpb25QYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCByZXFJZCA9IG5ldyBSZXF1ZXN0VHJhY2VyKCk7XG5cbiAgICAvLyBBZGQgdGhlIHVzZXIga2V5Y2hhaW5cbiAgICBjb25zdCB1c2VyS2V5Y2hhaW5Qcm9taXNlID0gYXN5bmMgKCk6IFByb21pc2U8S2V5Y2hhaW4+ID0+IHtcbiAgICAgIGxldCB1c2VyS2V5Y2hhaW5QYXJhbXM7XG4gICAgICBsZXQgdXNlcktleWNoYWluO1xuICAgICAgLy8gVXNlciBwcm92aWRlZCB1c2VyIGtleVxuICAgICAgaWYgKHBhcmFtcy51c2VyS2V5KSB7XG4gICAgICAgIHVzZXJLZXljaGFpbiA9IHsgcHViOiBwYXJhbXMudXNlcktleSB9O1xuICAgICAgICB1c2VyS2V5Y2hhaW5QYXJhbXMgPSB1c2VyS2V5Y2hhaW47XG4gICAgICAgIGlmIChwYXJhbXMuY29sZERlcml2YXRpb25TZWVkKSB7XG4gICAgICAgICAgLy8gdGhlIGRlcml2YXRpb24gb25seSBtYWtlcyBzZW5zZSB3aGVuIGEga2V5IGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgY29uc3QgZGVyaXZhdGlvbiA9IHRoaXMuYmFzZUNvaW4uZGVyaXZlS2V5V2l0aFNlZWQoe1xuICAgICAgICAgICAga2V5OiBwYXJhbXMudXNlcktleSxcbiAgICAgICAgICAgIHNlZWQ6IHBhcmFtcy5jb2xkRGVyaXZhdGlvblNlZWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVyaXZhdGlvblBhdGggPSBkZXJpdmF0aW9uLmRlcml2YXRpb25QYXRoO1xuICAgICAgICAgIHVzZXJLZXljaGFpbi5wdWIgPSBkZXJpdmF0aW9uLmtleTtcbiAgICAgICAgICB1c2VyS2V5Y2hhaW4uZGVyaXZlZEZyb21QYXJlbnRXaXRoU2VlZCA9IHBhcmFtcy5jb2xkRGVyaXZhdGlvblNlZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY2FuRW5jcnlwdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdlbmVyYXRlIHVzZXIga2V5cGFpciB3aXRob3V0IHBhc3NwaHJhc2UnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIHVzZXIga2V5LlxuICAgICAgICB1c2VyS2V5Y2hhaW4gPSB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmNyZWF0ZSgpO1xuICAgICAgICB1c2VyS2V5Y2hhaW4uZW5jcnlwdGVkUHJ2ID0gdGhpcy5iaXRnby5lbmNyeXB0KHsgcGFzc3dvcmQ6IHBhc3NwaHJhc2UsIGlucHV0OiB1c2VyS2V5Y2hhaW4ucHJ2IH0pO1xuICAgICAgICB1c2VyS2V5Y2hhaW5QYXJhbXMgPSB7XG4gICAgICAgICAgcHViOiB1c2VyS2V5Y2hhaW4ucHViLFxuICAgICAgICAgIGVuY3J5cHRlZFBydjogdXNlcktleWNoYWluLmVuY3J5cHRlZFBydixcbiAgICAgICAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGU6IHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB1c2VyS2V5Y2hhaW5QYXJhbXMucmVxSWQgPSByZXFJZDtcbiAgICAgIGNvbnN0IG5ld1VzZXJLZXljaGFpbiA9IGF3YWl0IHRoaXMuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuYWRkKHVzZXJLZXljaGFpblBhcmFtcyk7XG4gICAgICByZXR1cm4gXy5leHRlbmQoe30sIG5ld1VzZXJLZXljaGFpbiwgdXNlcktleWNoYWluKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYmFja3VwS2V5Y2hhaW5Qcm9taXNlID0gYXN5bmMgKCk6IFByb21pc2U8S2V5Y2hhaW4+ID0+IHtcbiAgICAgIGlmIChwYXJhbXMuYmFja3VwWHB1YlByb3ZpZGVyKSB7XG4gICAgICAgIC8vIElmIHJlcXVlc3RlZCwgdXNlIGEgS1JTIG9yIGJhY2t1cCBrZXkgcHJvdmlkZXJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuY3JlYXRlQmFja3VwKHtcbiAgICAgICAgICBwcm92aWRlcjogcGFyYW1zLmJhY2t1cFhwdWJQcm92aWRlciB8fCAnZGVmYXVsdFJNR0JhY2t1cFByb3ZpZGVyJyxcbiAgICAgICAgICBkaXNhYmxlS1JTRW1haWw6IHBhcmFtcy5kaXNhYmxlS1JTRW1haWwsXG4gICAgICAgICAga3JzU3BlY2lmaWM6IHBhcmFtcy5rcnNTcGVjaWZpYyxcbiAgICAgICAgICB0eXBlOiB0aGlzLmJhc2VDb2luLmdldENoYWluKCksXG4gICAgICAgICAgcGFzc3BocmFzZTogcGFyYW1zLnBhc3NwaHJhc2UsXG4gICAgICAgICAgcmVxSWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2VyIHByb3ZpZGVkIGJhY2t1cCB4cHViXG4gICAgICBpZiAocGFyYW1zLmJhY2t1cFhwdWIpIHtcbiAgICAgICAgLy8gdXNlciBwcm92aWRlZCBiYWNrdXAgZXRoZXJldW0gYWRkcmVzc1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlQ29pbi5rZXljaGFpbnMoKS5hZGQoe1xuICAgICAgICAgIHB1YjogcGFyYW1zLmJhY2t1cFhwdWIsXG4gICAgICAgICAgc291cmNlOiAnYmFja3VwJyxcbiAgICAgICAgICByZXFJZCxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWNhbkVuY3J5cHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBnZW5lcmF0ZSBiYWNrdXAga2V5cGFpciB3aXRob3V0IHBhc3NwaHJhc2UnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBwcm92aWRlZCBiYWNrdXAgeHB1YiBvciBhZGRyZXNzLCBzbyBkZWZhdWx0IHRvIGNyZWF0aW5nIG9uZSBoZXJlXG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmNyZWF0ZUJhY2t1cCh7IHJlcUlkLCBwYXNzcGhyYXNlOiBwYXJhbXMucGFzc3BocmFzZSB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgeyB1c2VyS2V5Y2hhaW4sIGJhY2t1cEtleWNoYWluLCBiaXRnb0tleWNoYWluIH06IEtleWNoYWluc1RyaXBsZXQgPSBhd2FpdCBwcm9taXNlUHJvcHMoe1xuICAgICAgdXNlcktleWNoYWluOiB1c2VyS2V5Y2hhaW5Qcm9taXNlKCksXG4gICAgICBiYWNrdXBLZXljaGFpbjogYmFja3VwS2V5Y2hhaW5Qcm9taXNlKCksXG4gICAgICBiaXRnb0tleWNoYWluOiB0aGlzLmJhc2VDb2luXG4gICAgICAgIC5rZXljaGFpbnMoKVxuICAgICAgICAuY3JlYXRlQml0R28oeyBlbnRlcnByaXNlOiBwYXJhbXMuZW50ZXJwcmlzZSwgcmVxSWQsIGlzRGlzdHJpYnV0ZWRDdXN0b2R5OiBwYXJhbXMuaXNEaXN0cmlidXRlZEN1c3RvZHkgfSksXG4gICAgfSk7XG5cbiAgICB3YWxsZXRQYXJhbXMua2V5cyA9IFt1c2VyS2V5Y2hhaW4uaWQsIGJhY2t1cEtleWNoYWluLmlkLCBiaXRnb0tleWNoYWluLmlkXTtcblxuICAgIGNvbnN0IHsgcHJ2IH0gPSB1c2VyS2V5Y2hhaW47XG4gICAgaWYgKF8uaXNTdHJpbmcocHJ2KSkge1xuICAgICAgYXNzZXJ0KGJhY2t1cEtleWNoYWluLnB1Yik7XG4gICAgICBhc3NlcnQoYml0Z29LZXljaGFpbi5wdWIpO1xuICAgICAgd2FsbGV0UGFyYW1zLmtleVNpZ25hdHVyZXMgPSB7XG4gICAgICAgIGJhY2t1cDogKGF3YWl0IHRoaXMuYmFzZUNvaW4uc2lnbk1lc3NhZ2UoeyBwcnYgfSwgYmFja3VwS2V5Y2hhaW4ucHViKSkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICBiaXRnbzogKGF3YWl0IHRoaXMuYmFzZUNvaW4uc2lnbk1lc3NhZ2UoeyBwcnYgfSwgYml0Z29LZXljaGFpbi5wdWIpKS50b1N0cmluZygnaGV4JyksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChfLmluY2x1ZGVzKFsneHJwJywgJ3hsbScsICdjc3ByJ10sIHRoaXMuYmFzZUNvaW4uZ2V0RmFtaWx5KCkpICYmICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5yb290UHJpdmF0ZUtleSkpIHtcbiAgICAgIHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleSA9IHBhcmFtcy5yb290UHJpdmF0ZUtleTtcbiAgICB9XG5cbiAgICAvLyBDdXN0b2RpYWwgb25jaGFpbiB3YWxsZXRzIGRvIG5vdCBuZWVkIG0sIG4sIGtleXMsIG9yIGtleVNpZ25hdHVyZXNcbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdjdXN0b2RpYWwnICYmIChwYXJhbXMubXVsdGlzaWdUeXBlID8/ICdvbmNoYWluJykgPT09ICdvbmNoYWluJykge1xuICAgICAgd2FsbGV0UGFyYW1zLm4gPSB1bmRlZmluZWQ7XG4gICAgICB3YWxsZXRQYXJhbXMubSA9IHVuZGVmaW5lZDtcbiAgICAgIHdhbGxldFBhcmFtcy5rZXlzID0gdW5kZWZpbmVkO1xuICAgICAgd2FsbGV0UGFyYW1zLmtleVNpZ25hdHVyZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5Y2hhaW5zID0ge1xuICAgICAgdXNlcktleWNoYWluLFxuICAgICAgYmFja3VwS2V5Y2hhaW4sXG4gICAgICBiaXRnb0tleWNoYWluLFxuICAgIH07XG4gICAgY29uc3QgZmluYWxXYWxsZXRQYXJhbXMgPSBhd2FpdCB0aGlzLmJhc2VDb2luLnN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldCh3YWxsZXRQYXJhbXMsIGtleWNoYWlucyk7XG4gICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHJlcUlkKTtcbiAgICBjb25zdCBuZXdXYWxsZXQgPSBhd2FpdCB0aGlzLmJpdGdvLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQnKSkuc2VuZChmaW5hbFdhbGxldFBhcmFtcykucmVzdWx0KCk7XG5cbiAgICBjb25zdCByZXN1bHQ6IFdhbGxldFdpdGhLZXljaGFpbnMgPSB7XG4gICAgICB3YWxsZXQ6IG5ldyBXYWxsZXQodGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbiwgbmV3V2FsbGV0KSxcbiAgICAgIHVzZXJLZXljaGFpbjogdXNlcktleWNoYWluLFxuICAgICAgYmFja3VwS2V5Y2hhaW46IGJhY2t1cEtleWNoYWluLFxuICAgICAgYml0Z29LZXljaGFpbjogYml0Z29LZXljaGFpbixcbiAgICB9O1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGJhY2t1cEtleWNoYWluLnBydikpIHtcbiAgICAgIHJlc3VsdC53YXJuaW5nID0gJ0JlIHN1cmUgdG8gYmFja3VwIHRoZSBiYWNrdXAga2V5Y2hhaW4gLS0gaXQgaXMgbm90IHN0b3JlZCBhbnl3aGVyZSBlbHNlISc7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGRlcml2YXRpb25QYXRoKSkge1xuICAgICAgdXNlcktleWNoYWluLmRlcml2YXRpb25QYXRoID0gZGVyaXZhdGlvblBhdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHRoZSB1c2VyJ3Mgd2FsbGV0IHNoYXJlc1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBsaXN0U2hhcmVzKHBhcmFtczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z28uZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0c2hhcmUnKSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIHdhbGxldCBzaGFyZSBpbmZvcm1hdGlvbiwgaW5jbHVkaW5nIHRoZSBlbmNyeXB0ZWQgc2hhcmluZyBrZXljaGFpbi4gcmVxdWlyZXMgdW5sb2NrIGlmIGtleWNoYWluIGlzIHByZXNlbnQuXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRTaGFyZUlkIC0gdGhlIHdhbGxldCBzaGFyZSB0byBnZXQgaW5mb3JtYXRpb24gb25cbiAgICovXG4gIGFzeW5jIGdldFNoYXJlKHBhcmFtczogeyB3YWxsZXRTaGFyZUlkPzogc3RyaW5nIH0gPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3YWxsZXRTaGFyZUlkJ10sIFtdKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldHNoYXJlLycgKyBwYXJhbXMud2FsbGV0U2hhcmVJZCkpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIHdhbGxldCBzaGFyZVxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFNoYXJlSWQgLSB0aGUgd2FsbGV0IHNoYXJlIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gcGFyYW1zLnN0YXRlIC0gdGhlIG5ldyBzdGF0ZSBvZiB0aGUgd2FsbGV0IHNoYXJlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIHVwZGF0ZVNoYXJlKHBhcmFtczogVXBkYXRlU2hhcmVPcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnd2FsbGV0U2hhcmVJZCddLCBbXSk7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXRzaGFyZS8nICsgcGFyYW1zLndhbGxldFNoYXJlSWQpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2VuZCBhIHdhbGxldCBzaGFyZSBpbnZpdGF0aW9uIGVtYWlsXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRTaGFyZUlkIC0gdGhlIHdhbGxldCBzaGFyZSB3aG9zZSBpbnZpdGlhdGlvbiBzaG91bGQgYmUgcmVzZW50XG4gICAqL1xuICBhc3luYyByZXNlbmRTaGFyZUludml0ZShwYXJhbXM6IHsgd2FsbGV0U2hhcmVJZD86IHN0cmluZyB9ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnd2FsbGV0U2hhcmVJZCddLCBbXSk7XG5cbiAgICBjb25zdCB1cmxQYXJ0cyA9IHBhcmFtcy53YWxsZXRTaGFyZUlkICsgJy9yZXNlbmRlbWFpbCc7XG4gICAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldHNoYXJlLycgKyB1cmxQYXJ0cykpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCBhIHdhbGxldCBzaGFyZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0U2hhcmVJZCAtIHRoZSB3YWxsZXQgc2hhcmUgdG8gdXBkYXRlXG4gICAqL1xuICBhc3luYyBjYW5jZWxTaGFyZShwYXJhbXM6IHsgd2FsbGV0U2hhcmVJZD86IHN0cmluZyB9ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnd2FsbGV0U2hhcmVJZCddLCBbXSk7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgLmRlbCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldHNoYXJlLycgKyBwYXJhbXMud2FsbGV0U2hhcmVJZCkpXG4gICAgICAuc2VuZCgpXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmUtc2hhcmUgd2FsbGV0IHdpdGggZXhpc3Rpbmcgc3BlbmRlcnMgb2YgdGhlIHdhbGxldFxuICAgKiBAcGFyYW0gd2FsbGV0SWRcbiAgICogQHBhcmFtIHVzZXJQYXNzd29yZFxuICAgKi9cbiAgYXN5bmMgcmVzaGFyZVdhbGxldFdpdGhTcGVuZGVycyh3YWxsZXRJZDogc3RyaW5nLCB1c2VyUGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHdhbGxldCA9IGF3YWl0IHRoaXMuZ2V0KHsgaWQ6IHdhbGxldElkIH0pO1xuICAgIGlmICghd2FsbGV0Py5fd2FsbGV0Py5lbnRlcnByaXNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudGVycHJpc2Ugbm90IGZvdW5kIGZvciB0aGUgd2FsbGV0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgZW50ZXJwcmlzZVVzZXJzUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAuZ2V0KHRoaXMuYml0Z28udXJsKGAvZW50ZXJwcmlzZS8ke3dhbGxldD8uX3dhbGxldD8uZW50ZXJwcmlzZX0vdXNlcmApKVxuICAgICAgLnJlc3VsdCgpO1xuICAgIC8vIGNyZWF0ZSBhIG1hcCBvZiB1c2VycyBmb3IgZWFzeSBsb29rdXAgLSB3ZSBuZWVkIHRoZSB1c2VyIGVtYWlsIGlkIHRvIHNoYXJlIHRoZSB3YWxsZXRcbiAgICBjb25zdCB1c2Vyc01hcCA9IG5ldyBNYXAoXG4gICAgICBbLi4uZW50ZXJwcmlzZVVzZXJzUmVzcG9uc2U/LmFkbWluVXNlcnMsIC4uLmVudGVycHJpc2VVc2Vyc1Jlc3BvbnNlPy5ub25BZG1pblVzZXJzXS5tYXAoKG9iaikgPT4gW29iai5pZCwgb2JqXSlcbiAgICApO1xuXG4gICAgaWYgKHdhbGxldC5fd2FsbGV0LnVzZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IHVzZXIgb2Ygd2FsbGV0Ll93YWxsZXQudXNlcnMpIHtcbiAgICAgICAgY29uc3QgdXNlck9iamVjdCA9IHVzZXJzTWFwLmdldCh1c2VyLnVzZXIpO1xuICAgICAgICBpZiAodXNlci5wZXJtaXNzaW9ucy5pbmNsdWRlcygnc3BlbmQnKSAmJiAhdXNlci5wZXJtaXNzaW9ucy5pbmNsdWRlcygnYWRtaW4nKSAmJiB1c2VyT2JqZWN0KSB7XG4gICAgICAgICAgY29uc3Qgc2hhcmVQYXJhbXMgPSB7XG4gICAgICAgICAgICB3YWxsZXRJZDogd2FsbGV0SWQsXG4gICAgICAgICAgICB1c2VyOiB1c2VyLnVzZXIsXG4gICAgICAgICAgICBwZXJtaXNzaW9uczogdXNlci5wZXJtaXNzaW9ucy5qb2luKCcsJyksXG4gICAgICAgICAgICB3YWxsZXRQYXNzcGhyYXNlOiB1c2VyUGFzc3dvcmQsXG4gICAgICAgICAgICBlbWFpbDogdXNlck9iamVjdC5lbWFpbC5lbWFpbCxcbiAgICAgICAgICAgIHJlc2hhcmU6IHRydWUsXG4gICAgICAgICAgICBza2lwS2V5Y2hhaW46IGZhbHNlLFxuICAgICAgICAgIH07XG4gICAgICAgICAgYXdhaXQgd2FsbGV0LnNoYXJlV2FsbGV0KHNoYXJlUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRzIGEgd2FsbGV0IHNoYXJlLCBhZGRpbmcgdGhlIHdhbGxldCB0byB0aGUgdXNlcidzIGxpc3RcbiAgICogTmVlZHMgYSB1c2VyJ3MgcGFzc3dvcmQgdG8gZGVjcnlwdCB0aGUgc2hhcmVkIGtleVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0U2hhcmVJZCAtIHRoZSB3YWxsZXQgc2hhcmUgdG8gYWNjZXB0XG4gICAqIEBwYXJhbSBwYXJhbXMudXNlclBhc3N3b3JkIC0gKHJlcXVpcmVkIGlmIG1vcmUgYSBrZXljaGFpbiB3YXMgc2hhcmVkKSB1c2VyJ3MgcGFzc3dvcmQgdG8gZGVjcnlwdCB0aGUgc2hhcmVkIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zLm5ld1dhbGxldFBhc3NwaHJhc2UgLSBuZXcgd2FsbGV0IHBhc3NwaHJhc2UgZm9yIHNhdmluZyB0aGUgc2hhcmVkIHdhbGxldCBwcnYuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGxlZnQgYmxhbmsgYW5kIGEgd2FsbGV0IHdpdGggbW9yZSB0aGFuIHZpZXcgcGVybWlzc2lvbnMgd2FzIHNoYXJlZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiB0aGUgdXNlcidzIGxvZ2luIHBhc3N3b3JkIGlzIHVzZWQuXG4gICAqIEBwYXJhbSBwYXJhbXMub3ZlcnJpZGVFbmNyeXB0ZWRQcnYgLSBzZXQgb25seSBpZiB0aGUgcHJ2IHdhcyByZWNlaXZlZCBvdXQtb2YtYmFuZC5cbiAgICovXG4gIGFzeW5jIGFjY2VwdFNoYXJlKHBhcmFtczogQWNjZXB0U2hhcmVPcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnd2FsbGV0U2hhcmVJZCddLCBbJ292ZXJyaWRlRW5jcnlwdGVkUHJ2JywgJ3VzZXJQYXNzd29yZCcsICduZXdXYWxsZXRQYXNzcGhyYXNlJ10pO1xuXG4gICAgbGV0IGVuY3J5cHRlZFBydiA9IHBhcmFtcy5vdmVycmlkZUVuY3J5cHRlZFBydjtcbiAgICBjb25zdCB3YWxsZXRTaGFyZSA9IGF3YWl0IHRoaXMuZ2V0U2hhcmUoeyB3YWxsZXRTaGFyZUlkOiBwYXJhbXMud2FsbGV0U2hhcmVJZCB9KTtcbiAgICBpZiAoXG4gICAgICB3YWxsZXRTaGFyZS5rZXljaGFpbk92ZXJyaWRlUmVxdWlyZWQgJiZcbiAgICAgIHdhbGxldFNoYXJlLnBlcm1pc3Npb25zLmluZGV4T2YoJ2FkbWluJykgIT09IC0xICYmXG4gICAgICB3YWxsZXRTaGFyZS5wZXJtaXNzaW9ucy5pbmRleE9mKCdzcGVuZCcpICE9PSAtMVxuICAgICkge1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnVzZXJQYXNzd29yZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VyUGFzc3dvcmQgcGFyYW0gbXVzdCBiZSBwcm92aWRlZCB0byBkZWNyeXB0IHNoYXJlZCBrZXknKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd2FsbGV0S2V5Y2hhaW4gPSBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmNyZWF0ZVVzZXJLZXljaGFpbihwYXJhbXMudXNlclBhc3N3b3JkKTtcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHdhbGxldEtleWNoYWluLmVuY3J5cHRlZFBydikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmNyeXB0ZWRQcnYgd2FzIG5vdCBmb3VuZCBvbiB3YWxsZXQga2V5Y2hhaW4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdHJhZGluZ0FjY291bnRJZDogd2FsbGV0U2hhcmUud2FsbGV0LFxuICAgICAgICBwdWJrZXk6IHdhbGxldEtleWNoYWluLnB1YixcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuICAgICAgY29uc3QgcGF5bG9hZFN0cmluZyA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuXG4gICAgICBjb25zdCBwcml2YXRlS2V5ID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgcGFzc3dvcmQ6IHBhcmFtcy51c2VyUGFzc3dvcmQsXG4gICAgICAgIGlucHV0OiB3YWxsZXRLZXljaGFpbi5lbmNyeXB0ZWRQcnYsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuYmFzZUNvaW4uc2lnbk1lc3NhZ2UoeyBwcnY6IHByaXZhdGVLZXkgfSwgcGF5bG9hZFN0cmluZyk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy51cGRhdGVTaGFyZSh7XG4gICAgICAgIHdhbGxldFNoYXJlSWQ6IHBhcmFtcy53YWxsZXRTaGFyZUlkLFxuICAgICAgICBzdGF0ZTogJ2FjY2VwdGVkJyxcbiAgICAgICAga2V5SWQ6IHdhbGxldEtleWNoYWluLmlkLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZS50b1N0cmluZygnaGV4JyksXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWRTdHJpbmcsXG4gICAgICB9KTtcbiAgICAgIC8vIElmIHRoZSB3YWxsZXQgc2hhcmUgd2FzIGFjY2VwdGVkIHN1Y2Nlc3NmdWxseSAoY2hhbmdlZD10cnVlKSwgcmVzaGFyZSB0aGUgd2FsbGV0IHdpdGggdGhlIHNwZW5kZXJzXG4gICAgICBpZiAocmVzcG9uc2UuY2hhbmdlZCAmJiByZXNwb25zZS5zdGF0ZSA9PT0gJ2FjY2VwdGVkJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucmVzaGFyZVdhbGxldFdpdGhTcGVuZGVycyh3YWxsZXRTaGFyZS53YWxsZXQsIHBhcmFtcy51c2VyUGFzc3dvcmQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gVE9ETzogUFgtMzgyNlxuICAgICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gcmlnaHQgYXdheSBpZiB0aGVyZSBpcyBubyBrZXljaGFpbiB0byBkZWNyeXB0LCBvciBpZiBleHBsaWNpdCBlbmNyeXB0ZWRQcnYgd2FzIHByb3ZpZGVkXG4gICAgaWYgKCF3YWxsZXRTaGFyZS5rZXljaGFpbiB8fCAhd2FsbGV0U2hhcmUua2V5Y2hhaW4uZW5jcnlwdGVkUHJ2IHx8IGVuY3J5cHRlZFBydikge1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlU2hhcmUoe1xuICAgICAgICB3YWxsZXRTaGFyZUlkOiBwYXJhbXMud2FsbGV0U2hhcmVJZCxcbiAgICAgICAgc3RhdGU6ICdhY2NlcHRlZCcsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBNb3JlIHRoYW4gdmlld2luZyB3YXMgcmVxdWVzdGVkLCBzbyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIHdhbGxldCBrZXlzIHVzaW5nIHRoZSBzaGFyZWQgZWNkaCBzY2hlbWVcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMudXNlclBhc3N3b3JkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VyUGFzc3dvcmQgcGFyYW0gbXVzdCBiZSBwcm92aWRlZCB0byBkZWNyeXB0IHNoYXJlZCBrZXknKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaGFyaW5nS2V5Y2hhaW4gPSAoYXdhaXQgdGhpcy5iaXRnby5nZXRFQ0RIS2V5Y2hhaW4oKSkgYXMgYW55O1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKHNoYXJpbmdLZXljaGFpbi5lbmNyeXB0ZWRYcHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmNyeXB0ZWRYcHJ2IHdhcyBub3QgZm91bmQgb24gc2hhcmluZyBrZXljaGFpbicpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIHRoZSBzaGFyaW5nIGtleWNoYWluLCB3ZSBjYW4gd29yayBvdXQgdGhlIHNlY3JldCB1c2VkIGZvciBzaGFyaW5nIHRoZSB3YWxsZXQgd2l0aCB1c1xuICAgIHNoYXJpbmdLZXljaGFpbi5wcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgcGFzc3dvcmQ6IHBhcmFtcy51c2VyUGFzc3dvcmQsXG4gICAgICBpbnB1dDogc2hhcmluZ0tleWNoYWluLmVuY3J5cHRlZFhwcnYsXG4gICAgfSk7XG4gICAgY29uc3Qgc2VjcmV0ID0gZ2V0U2hhcmVkU2VjcmV0KFxuICAgICAgLy8gRGVyaXZlIGtleSBieSBwYXRoICh3aGljaCBpcyB1c2VkIGJldHdlZW4gdGhlc2UgMiB1c2VycyBvbmx5KVxuICAgICAgYmlwMzIuZnJvbUJhc2U1OChzaGFyaW5nS2V5Y2hhaW4ucHJ2KS5kZXJpdmVQYXRoKHNhbml0aXplTGVnYWN5UGF0aCh3YWxsZXRTaGFyZS5rZXljaGFpbi5wYXRoKSksXG4gICAgICBCdWZmZXIuZnJvbSh3YWxsZXRTaGFyZS5rZXljaGFpbi5mcm9tUHViS2V5LCAnaGV4JylcbiAgICApLnRvU3RyaW5nKCdoZXgnKTtcblxuICAgIC8vIFllcyEgV2UgZ290IHRoZSBzZWNyZXQgc3VjY2Vzc2Z1bGx5IGhlcmUsIG5vdyBkZWNyeXB0IHRoZSBzaGFyZWQgd2FsbGV0IHBydlxuICAgIGNvbnN0IGRlY3J5cHRlZFNoYXJlZFdhbGxldFBydiA9IHRoaXMuYml0Z28uZGVjcnlwdCh7XG4gICAgICBwYXNzd29yZDogc2VjcmV0LFxuICAgICAgaW5wdXQ6IHdhbGxldFNoYXJlLmtleWNoYWluLmVuY3J5cHRlZFBydixcbiAgICB9KTtcblxuICAgIC8vIFdlIHdpbGwgbm93IHJlLWVuY3J5cHQgdGhlIHdhbGxldCB3aXRoIG91ciBvd24gcGFzc3dvcmRcbiAgICBjb25zdCBuZXdXYWxsZXRQYXNzcGhyYXNlID0gcGFyYW1zLm5ld1dhbGxldFBhc3NwaHJhc2UgfHwgcGFyYW1zLnVzZXJQYXNzd29yZDtcbiAgICBlbmNyeXB0ZWRQcnYgPSB0aGlzLmJpdGdvLmVuY3J5cHQoe1xuICAgICAgcGFzc3dvcmQ6IG5ld1dhbGxldFBhc3NwaHJhc2UsXG4gICAgICBpbnB1dDogZGVjcnlwdGVkU2hhcmVkV2FsbGV0UHJ2LFxuICAgIH0pO1xuICAgIGNvbnN0IHVwZGF0ZVBhcmFtczogVXBkYXRlU2hhcmVPcHRpb25zID0ge1xuICAgICAgd2FsbGV0U2hhcmVJZDogcGFyYW1zLndhbGxldFNoYXJlSWQsXG4gICAgICBzdGF0ZTogJ2FjY2VwdGVkJyxcbiAgICB9O1xuXG4gICAgaWYgKGVuY3J5cHRlZFBydikge1xuICAgICAgdXBkYXRlUGFyYW1zLmVuY3J5cHRlZFBydiA9IGVuY3J5cHRlZFBydjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlU2hhcmUodXBkYXRlUGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB3YWxsZXQgYnkgaXRzIElEXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5pZCB3YWxsZXQgaWRcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyBnZXRXYWxsZXQocGFyYW1zOiBHZXRXYWxsZXRPcHRpb25zID0ge30pOiBQcm9taXNlPFdhbGxldD4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaWQnXSwgW10pO1xuXG4gICAgY29uc3QgcXVlcnk6IEdldFdhbGxldE9wdGlvbnMgPSB7fTtcbiAgICBpZiAocGFyYW1zLmFsbFRva2Vucykge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuYWxsVG9rZW5zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWxsVG9rZW5zIGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgcXVlcnkuYWxsVG9rZW5zID0gcGFyYW1zLmFsbFRva2VucztcbiAgICB9XG5cbiAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocGFyYW1zLnJlcUlkIHx8IG5ldyBSZXF1ZXN0VHJhY2VyKCkpO1xuXG4gICAgY29uc3Qgd2FsbGV0ID0gYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgcGFyYW1zLmlkKSlcbiAgICAgIC5xdWVyeShxdWVyeSlcbiAgICAgIC5yZXN1bHQoKTtcbiAgICByZXR1cm4gbmV3IFdhbGxldCh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luLCB3YWxsZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHdhbGxldCBieSBpdHMgYWRkcmVzc1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMuYWRkcmVzcyB3YWxsZXQgYWRkcmVzc1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGFzeW5jIGdldFdhbGxldEJ5QWRkcmVzcyhwYXJhbXM6IEdldFdhbGxldEJ5QWRkcmVzc09wdGlvbnMgPSB7fSk6IFByb21pc2U8V2FsbGV0PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydhZGRyZXNzJ10sIFtdKTtcblxuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihwYXJhbXMucmVxSWQgfHwgbmV3IFJlcXVlc3RUcmFjZXIoKSk7XG5cbiAgICBjb25zdCB3YWxsZXQgPSBhd2FpdCB0aGlzLmJpdGdvLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldC9hZGRyZXNzLycgKyBwYXJhbXMuYWRkcmVzcykpLnJlc3VsdCgpO1xuICAgIHJldHVybiBuZXcgV2FsbGV0KHRoaXMuYml0Z28sIHRoaXMuYmFzZUNvaW4sIHdhbGxldCk7XG4gIH1cblxuICAvKipcbiAgICogRm9yIGFueSBnaXZlbiBzdXBwb3J0ZWQgY29pbiwgZ2V0IHRvdGFsIGJhbGFuY2VzIGZvciBhbGwgd2FsbGV0cyBvZiB0aGF0XG4gICAqIGNvaW4gdHlwZSBvbiB0aGUgYWNjb3VudC5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGFzeW5jIGdldFRvdGFsQmFsYW5jZXMocGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBuZXZlcj4gPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z28uZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0L2JhbGFuY2VzJykpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIFRTUyBvciBCTFMtREtHIFdhbGxldC5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZU1wY1dhbGxldCh7XG4gICAgcGFzc3BocmFzZSxcbiAgICBsYWJlbCxcbiAgICBtdWx0aXNpZ1R5cGUsXG4gICAgZW50ZXJwcmlzZSxcbiAgICB3YWxsZXRWZXJzaW9uLFxuICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICBiYWNrdXBQcm92aWRlcixcbiAgfTogR2VuZXJhdGVNcGNXYWxsZXRPcHRpb25zKTogUHJvbWlzZTxXYWxsZXRXaXRoS2V5Y2hhaW5zPiB7XG4gICAgaWYgKG11bHRpc2lnVHlwZSA9PT0gJ3RzcycgJiYgdGhpcy5iYXNlQ29pbi5nZXRNUENBbGdvcml0aG0oKSA9PT0gJ2VjZHNhJyAmJiB3YWxsZXRWZXJzaW9uID09PSAzKSB7XG4gICAgICBjb25zdCB0c3NTZXR0aW5nczogVHNzU2V0dGluZ3MgPSBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAgIC5nZXQodGhpcy5iaXRnby5taWNyb3NlcnZpY2VzVXJsKCcvYXBpL3YyL3Rzcy9zZXR0aW5ncycpKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgICBjb25zdCBtdWx0aXNpZ1R5cGVWZXJzaW9uID1cbiAgICAgICAgdHNzU2V0dGluZ3MuY29pblNldHRpbmdzW3RoaXMuYmFzZUNvaW4uZ2V0RmFtaWx5KCldPy53YWxsZXRDcmVhdGlvblNldHRpbmdzPy5tdWx0aVNpZ1R5cGVWZXJzaW9uO1xuICAgICAgaWYgKG11bHRpc2lnVHlwZVZlcnNpb24gPT09ICdNUEN2MicpIHtcbiAgICAgICAgd2FsbGV0VmVyc2lvbiA9IDU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVxSWQgPSBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG5cbiAgICAvLyBDcmVhdGUgTVBDIEtleWNoYWluc1xuICAgIGNvbnN0IGtleWNoYWlucyA9IGF3YWl0IHRoaXMuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuY3JlYXRlTXBjKHtcbiAgICAgIG11bHRpc2lnVHlwZSxcbiAgICAgIHBhc3NwaHJhc2UsXG4gICAgICBlbnRlcnByaXNlLFxuICAgICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgICAgYmFja3VwUHJvdmlkZXIsXG4gICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgV2FsbGV0XG4gICAgY29uc3QgeyB1c2VyS2V5Y2hhaW4sIGJhY2t1cEtleWNoYWluLCBiaXRnb0tleWNoYWluIH0gPSBrZXljaGFpbnM7XG4gICAgY29uc3Qgd2FsbGV0UGFyYW1zOiBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zID0ge1xuICAgICAgbGFiZWwsXG4gICAgICBtOiAyLFxuICAgICAgbjogMyxcbiAgICAgIGtleXM6IFt1c2VyS2V5Y2hhaW4uaWQsIGJhY2t1cEtleWNoYWluLmlkLCBiaXRnb0tleWNoYWluLmlkXSxcbiAgICAgIHR5cGU6ICdob3QnLFxuICAgICAgbXVsdGlzaWdUeXBlLFxuICAgICAgZW50ZXJwcmlzZSxcbiAgICAgIHdhbGxldFZlcnNpb24sXG4gICAgfTtcbiAgICBjb25zdCBmaW5hbFdhbGxldFBhcmFtcyA9IGF3YWl0IHRoaXMuYmFzZUNvaW4uc3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0KHdhbGxldFBhcmFtcywga2V5Y2hhaW5zKTtcbiAgICBjb25zdCBuZXdXYWxsZXQgPSBhd2FpdCB0aGlzLmJpdGdvLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQnKSkuc2VuZChmaW5hbFdhbGxldFBhcmFtcykucmVzdWx0KCk7XG5cbiAgICBjb25zdCByZXN1bHQ6IFdhbGxldFdpdGhLZXljaGFpbnMgPSB7XG4gICAgICB3YWxsZXQ6IG5ldyBXYWxsZXQodGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbiwgbmV3V2FsbGV0KSxcbiAgICAgIHVzZXJLZXljaGFpbixcbiAgICAgIGJhY2t1cEtleWNoYWluLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICB9O1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGJhY2t1cEtleWNoYWluLnBydikgJiYgIV8uaXNVbmRlZmluZWQoYmFja3VwUHJvdmlkZXIpKSB7XG4gICAgICByZXN1bHQud2FybmluZyA9ICdCZSBzdXJlIHRvIGJhY2t1cCB0aGUgYmFja3VwIGtleWNoYWluIC0tIGl0IGlzIG5vdCBzdG9yZWQgYW55d2hlcmUgZWxzZSEnO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgU2VsZi1NYW5hZ2VkIENvbGQgVFNTIFdhbGxldC5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZVNNQ01wY1dhbGxldCh7XG4gICAgbGFiZWwsXG4gICAgbXVsdGlzaWdUeXBlLFxuICAgIGVudGVycHJpc2UsXG4gICAgd2FsbGV0VmVyc2lvbixcbiAgICBiaXRnb0tleUlkLFxuICAgIGNvbW1vbktleWNoYWluLFxuICAgIGNvbGREZXJpdmF0aW9uU2VlZCxcbiAgfTogR2VuZXJhdGVTTUNNcGNXYWxsZXRPcHRpb25zKTogUHJvbWlzZTxXYWxsZXRXaXRoS2V5Y2hhaW5zPiB7XG4gICAgY29uc3QgcmVxSWQgPSBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG5cbiAgICAvLyBDcmVhdGUgTVBDIEtleWNoYWluc1xuICAgIGNvbnN0IGJpdGdvS2V5Y2hhaW4gPSBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmdldCh7IGlkOiBiaXRnb0tleUlkIH0pO1xuXG4gICAgaWYgKCFiaXRnb0tleWNoYWluIHx8ICFiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpdEdvIGtleWNoYWluIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGlmIChiaXRnb0tleWNoYWluLnNvdXJjZSAhPT0gJ2JpdGdvJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgYml0Z29LZXlJZCBpcyBub3QgYSBCaXRHbyBrZXljaGFpbicpO1xuICAgIH1cblxuICAgIGlmIChiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluICE9PSBjb21tb25LZXljaGFpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgQ29tbW9uIGtleWNoYWluIG1pc21hdGNoIHdpdGggdGhlIHByb3ZpZGVkIEJpdGdvIGtleScpO1xuICAgIH1cblxuICAgIGlmICghY29sZERlcml2YXRpb25TZWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlcml2ZWRGcm9tUGFyZW50V2l0aFNlZWQgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyS2V5Y2hhaW5QYXJhbXM6IEFkZEtleWNoYWluT3B0aW9ucyA9IHtcbiAgICAgIHNvdXJjZTogJ3VzZXInLFxuICAgICAga2V5VHlwZTogJ3RzcycsXG4gICAgICBjb21tb25LZXljaGFpbjogY29tbW9uS2V5Y2hhaW4sXG4gICAgICBkZXJpdmVkRnJvbVBhcmVudFdpdGhTZWVkOiBjb2xkRGVyaXZhdGlvblNlZWQsXG4gICAgfTtcbiAgICBjb25zdCB1c2VyS2V5Y2hhaW4gPSBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmFkZCh1c2VyS2V5Y2hhaW5QYXJhbXMpO1xuXG4gICAgY29uc3QgYmFja3VwS2V5Q2hhaW5QYXJhbXM6IEFkZEtleWNoYWluT3B0aW9ucyA9IHtcbiAgICAgIHNvdXJjZTogJ2JhY2t1cCcsXG4gICAgICBrZXlUeXBlOiAndHNzJyxcbiAgICAgIGNvbW1vbktleWNoYWluOiBjb21tb25LZXljaGFpbixcbiAgICAgIGRlcml2ZWRGcm9tUGFyZW50V2l0aFNlZWQ6IGNvbGREZXJpdmF0aW9uU2VlZCxcbiAgICB9O1xuXG4gICAgY29uc3QgYmFja3VwS2V5Y2hhaW4gPSBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmFkZChiYWNrdXBLZXlDaGFpblBhcmFtcyk7XG5cbiAgICAvLyBDcmVhdGUgV2FsbGV0XG4gICAgY29uc3Qga2V5Y2hhaW5zID0geyB1c2VyS2V5Y2hhaW4sIGJhY2t1cEtleWNoYWluLCBiaXRnb0tleWNoYWluIH07XG4gICAgY29uc3Qgd2FsbGV0UGFyYW1zOiBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zID0ge1xuICAgICAgbGFiZWwsXG4gICAgICBtOiAyLFxuICAgICAgbjogMyxcbiAgICAgIGtleXM6IFt1c2VyS2V5Y2hhaW4uaWQsIGJhY2t1cEtleWNoYWluLmlkLCBiaXRnb0tleWNoYWluLmlkXSxcbiAgICAgIHR5cGU6ICdjb2xkJyxcbiAgICAgIG11bHRpc2lnVHlwZSxcbiAgICAgIGVudGVycHJpc2UsXG4gICAgICB3YWxsZXRWZXJzaW9uLFxuICAgIH07XG5cbiAgICBjb25zdCBmaW5hbFdhbGxldFBhcmFtcyA9IGF3YWl0IHRoaXMuYmFzZUNvaW4uc3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0KHdhbGxldFBhcmFtcywga2V5Y2hhaW5zKTtcbiAgICBjb25zdCBuZXdXYWxsZXQgPSBhd2FpdCB0aGlzLmJpdGdvLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQnKSkuc2VuZChmaW5hbFdhbGxldFBhcmFtcykucmVzdWx0KCk7XG5cbiAgICBjb25zdCByZXN1bHQ6IFdhbGxldFdpdGhLZXljaGFpbnMgPSB7XG4gICAgICB3YWxsZXQ6IG5ldyBXYWxsZXQodGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbiwgbmV3V2FsbGV0KSxcbiAgICAgIHVzZXJLZXljaGFpbixcbiAgICAgIGJhY2t1cEtleWNoYWluLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDdXN0b2RpYWwgVFNTIFdhbGxldC5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZUN1c3RvZGlhbE1wY1dhbGxldCh7XG4gICAgbGFiZWwsXG4gICAgbXVsdGlzaWdUeXBlLFxuICAgIGVudGVycHJpc2UsXG4gICAgd2FsbGV0VmVyc2lvbixcbiAgfTogR2VuZXJhdGVCYXNlTXBjV2FsbGV0T3B0aW9ucyk6IFByb21pc2U8V2FsbGV0V2l0aEtleWNoYWlucz4ge1xuICAgIGNvbnN0IHJlcUlkID0gbmV3IFJlcXVlc3RUcmFjZXIoKTtcbiAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuXG4gICAgY29uc3QgZmluYWxXYWxsZXRQYXJhbXMgPSB7XG4gICAgICBsYWJlbCxcbiAgICAgIG11bHRpc2lnVHlwZSxcbiAgICAgIGVudGVycHJpc2UsXG4gICAgICB3YWxsZXRWZXJzaW9uLFxuICAgICAgdHlwZTogJ2N1c3RvZGlhbCcsXG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBXYWxsZXRcbiAgICBjb25zdCBuZXdXYWxsZXQgPSBhd2FpdCB0aGlzLmJpdGdvLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQnKSkuc2VuZChmaW5hbFdhbGxldFBhcmFtcykucmVzdWx0KCk7XG4gICAgY29uc3Qgd2FsbGV0ID0gbmV3IFdhbGxldCh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luLCBuZXdXYWxsZXQpO1xuICAgIGNvbnN0IGtleWNoYWlucyA9IHdhbGxldC5rZXlJZHMoKTtcbiAgICBjb25zdCByZXN1bHQ6IFdhbGxldFdpdGhLZXljaGFpbnMgPSB7XG4gICAgICB3YWxsZXQsXG4gICAgICB1c2VyS2V5Y2hhaW46IHsgaWQ6IGtleWNoYWluc1swXSwgdHlwZTogbXVsdGlzaWdUeXBlLCBzb3VyY2U6ICd1c2VyJyB9LFxuICAgICAgYmFja3VwS2V5Y2hhaW46IHsgaWQ6IGtleWNoYWluc1sxXSwgdHlwZTogbXVsdGlzaWdUeXBlLCBzb3VyY2U6ICdiYWNrdXAnIH0sXG4gICAgICBiaXRnb0tleWNoYWluOiB7IGlkOiBrZXljaGFpbnNbMl0sIHR5cGU6IG11bHRpc2lnVHlwZSwgc291cmNlOiAnYml0Z28nIH0sXG4gICAgfTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbiJdfQ==