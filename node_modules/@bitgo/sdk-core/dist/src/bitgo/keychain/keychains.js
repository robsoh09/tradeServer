"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Keychains = void 0;
const _ = __importStar(require("lodash"));
const assert_1 = __importDefault(require("assert"));
const common = __importStar(require("../../common"));
const utils_1 = require("../utils");
const ovcJsonCodec_1 = require("./ovcJsonCodec");
class Keychains {
    constructor(bitgo, baseCoin) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
    }
    /**
     * Get a keychain by ID
     * @param params
     * @param params.id
     * @param params.xpub (optional)
     * @param params.ethAddress (optional)
     * @param params.reqId (optional)
     */
    async get(params) {
        common.validateParams(params, [], ['xpub', 'ethAddress']);
        if (_.isUndefined(params.id)) {
            throw new Error('id must be defined');
        }
        const id = params.id;
        if (params.reqId) {
            this.bitgo.setRequestTracer(params.reqId);
        }
        return await this.bitgo.get(this.baseCoin.url('/key/' + encodeURIComponent(id))).result();
    }
    /**
     * list the users keychains
     * @param params
     * @param params.limit - Max number of results in a single call.
     * @param params.prevId - Continue iterating (provided by nextBatchPrevId in the previous list)
     * @returns {*}
     */
    async list(params = {}) {
        const queryObject = {};
        if (!_.isUndefined(params.limit)) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            queryObject.limit = params.limit;
        }
        if (!_.isUndefined(params.prevId)) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            queryObject.prevId = params.prevId;
        }
        return this.bitgo.get(this.baseCoin.url('/key')).query(queryObject).result();
    }
    /**
     * Change the decryption password for all possible keychains associated with a user.
     *
     * This function iterates through all keys associated with the user, decrypts
     * them with the old password and re-encrypts them with the new password.
     *
     * This should be called when a user changes their login password, and are expecting
     * that their wallet passwords are changed to match the new login password.
     *
     * @param params
     * @param params.oldPassword - The old password used for encrypting the key
     * @param params.newPassword - The new password to be used for encrypting the key
     * @returns changedKeys Object - e.g.:
     *  {
     *    xpub1: encryptedPrv,
     *    ...
     *  }
     */
    async updatePassword(params) {
        common.validateParams(params, ['oldPassword', 'newPassword'], []);
        const changedKeys = {};
        let prevId;
        let keysLeft = true;
        while (keysLeft) {
            const result = await this.list({ limit: 500, prevId });
            for (const key of result.keys) {
                const oldEncryptedPrv = key.encryptedPrv;
                if (_.isUndefined(oldEncryptedPrv)) {
                    continue;
                }
                try {
                    const updatedKeychain = this.updateSingleKeychainPassword({
                        keychain: key,
                        oldPassword: params.oldPassword,
                        newPassword: params.newPassword,
                    });
                    if (updatedKeychain.encryptedPrv) {
                        const changedKeyIdentifier = updatedKeychain.type === 'tss' ? updatedKeychain.id : updatedKeychain.pub;
                        if (changedKeyIdentifier) {
                            changedKeys[changedKeyIdentifier] = updatedKeychain.encryptedPrv;
                        }
                    }
                }
                catch (e) {
                    // if the password was incorrect, silence the error, throw otherwise
                    if (!e.message.includes('private key is incorrect')) {
                        throw e;
                    }
                }
            }
            if (result.nextBatchPrevId) {
                prevId = result.nextBatchPrevId;
            }
            else {
                keysLeft = false;
            }
        }
        return changedKeys;
    }
    /**
     * Update the password used to decrypt a single keychain
     * @param params
     * @param params.keychain - The keychain whose password should be updated
     * @param params.oldPassword - The old password used for encrypting the key
     * @param params.newPassword - The new password to be used for encrypting the key
     * @returns {object}
     */
    updateSingleKeychainPassword(params = {}) {
        if (!_.isString(params.oldPassword)) {
            throw new Error('expected old password to be a string');
        }
        if (!_.isString(params.newPassword)) {
            throw new Error('expected new password to be a string');
        }
        if (!_.isObject(params.keychain) || !_.isString(params.keychain.encryptedPrv)) {
            throw new Error('expected keychain to be an object with an encryptedPrv property');
        }
        const oldEncryptedPrv = params.keychain.encryptedPrv;
        try {
            const decryptedPrv = this.bitgo.decrypt({ input: oldEncryptedPrv, password: params.oldPassword });
            const newEncryptedPrv = this.bitgo.encrypt({ input: decryptedPrv, password: params.newPassword });
            return _.assign({}, params.keychain, { encryptedPrv: newEncryptedPrv });
        }
        catch (e) {
            // catching an error here means that the password was incorrect or, less likely, the input to decrypt is corrupted
            throw new Error('password used to decrypt keychain private key is incorrect');
        }
    }
    /**
     * Create a public/private key pair
     * @param params - optional params
     * @param params.seed optional - seed to use for keypair generation
     * @param params.isRootKey optional - whether the resulting keypair should be a root key
     * @returns {KeyPair} - the generated keypair
     */
    create(params = {}) {
        if (params === null || params === void 0 ? void 0 : params.isRootKey) {
            return this.baseCoin.generateRootKeyPair(params.seed);
        }
        return this.baseCoin.generateKeyPair(params.seed);
    }
    /**
     * Add a keychain to BitGo's records
     * @param params
     */
    async add(params = {}) {
        params = params || {};
        common.validateParams(params, [], [
            'pub',
            'encryptedPrv',
            'keyType',
            'type',
            'source',
            'originalPasscodeEncryptionCode',
            'enterprise',
            'derivedFromParentWithSeed',
        ]);
        if (!_.isUndefined(params.disableKRSEmail)) {
            if (!_.isBoolean(params.disableKRSEmail)) {
                throw new Error('invalid disableKRSEmail argument, expecting boolean');
            }
        }
        if (params.reqId) {
            this.bitgo.setRequestTracer(params.reqId);
        }
        return await this.bitgo
            .post(this.baseCoin.url('/key'))
            .send({
            pub: params.pub,
            commonPub: params.commonPub,
            commonKeychain: params.commonKeychain,
            encryptedPrv: params.encryptedPrv,
            type: params.type,
            keyType: params.keyType,
            source: params.source,
            provider: params.provider,
            originalPasscodeEncryptionCode: params.originalPasscodeEncryptionCode,
            enterprise: params.enterprise,
            derivedFromParentWithSeed: params.derivedFromParentWithSeed,
            disableKRSEmail: params.disableKRSEmail,
            krsSpecific: params.krsSpecific,
            keyShares: params.keyShares,
            userGPGPublicKey: params.userGPGPublicKey,
            backupGPGPublicKey: params.backupGPGPublicKey,
            algoUsed: params.algoUsed,
            isDistributedCustody: params.isDistributedCustody,
            isMPCv2: params.isMPCv2,
        })
            .result();
    }
    /**
     * Create a BitGo key
     * @param params (empty)
     */
    async createBitGo(params = {}) {
        params.source = 'bitgo';
        this.baseCoin.preCreateBitGo(params);
        return await this.add(params);
    }
    /**
     * Create a backup key
     * @param params
     * @param params.provider (optional)
     */
    async createBackup(params = {}) {
        params.source = 'backup';
        const isTssBackupKey = params.prv && (params.commonKeychain || params.commonPub);
        if (_.isUndefined(params.provider) && !isTssBackupKey) {
            // if the provider is undefined, we generate a local key and add the source details
            const key = this.create();
            _.extend(params, key);
            if (params.passphrase !== undefined) {
                _.extend(params, { encryptedPrv: this.bitgo.encrypt({ input: key.prv, password: params.passphrase }) });
            }
        }
        const serverResponse = await this.add(params);
        return _.extend({}, serverResponse, _.pick(params, ['prv', 'encryptedPrv', 'provider', 'source']));
    }
    /**
     * Gets keys for signing from a wallet
     * @param params
     * @returns {Promise<Keychain[]>}
     */
    async getKeysForSigning(params = {}) {
        if (!_.isObject(params.wallet)) {
            throw new Error('missing required param wallet');
        }
        const wallet = params.wallet;
        const reqId = params.reqId || new utils_1.RequestTracer();
        const ids = wallet.baseCoin.keyIdsForSigning();
        const keychainQueriesBluebirds = ids.map((id) => this.get({ id: wallet.keyIds()[id], reqId }));
        return Promise.all(keychainQueriesBluebirds);
    }
    /**
     * Convenience function to create and store MPC keychains with BitGo.
     * @param params passphrase used to encrypt secret materials
     * @return {Promise<KeychainsTriplet>} newly created User, Backup, and BitGo keys
     */
    async createMpc(params) {
        var _a, _b;
        let MpcUtils;
        let multisigTypeVersion = undefined;
        if (params.multisigType === 'tss' && this.baseCoin.getMPCAlgorithm() === 'ecdsa') {
            const tssSettings = await this.bitgo
                .get(this.bitgo.microservicesUrl('/api/v2/tss/settings'))
                .result();
            multisigTypeVersion =
                (_b = (_a = tssSettings.coinSettings[this.baseCoin.getFamily()]) === null || _a === void 0 ? void 0 : _a.walletCreationSettings) === null || _b === void 0 ? void 0 : _b.multiSigTypeVersion;
        }
        switch (params.multisigType) {
            case 'tss':
                MpcUtils =
                    this.baseCoin.getMPCAlgorithm() === 'eddsa'
                        ? utils_1.EDDSAUtils.default
                        : multisigTypeVersion === 'MPCv2'
                            ? utils_1.ECDSAUtils.EcdsaMPCv2Utils
                            : utils_1.ECDSAUtils.EcdsaUtils;
                break;
            case 'blsdkg':
                if (_.isUndefined(params.passphrase)) {
                    throw new Error('missing required param passphrase');
                }
                MpcUtils = utils_1.BlsUtils;
                break;
            default:
                throw new Error('Unsupported multi-sig type');
        }
        const mpcUtils = new MpcUtils(this.bitgo, this.baseCoin);
        return await mpcUtils.createKeychains({
            passphrase: params.passphrase,
            enterprise: params.enterprise,
            originalPasscodeEncryptionCode: params.originalPasscodeEncryptionCode,
            backupProvider: params.backupProvider,
        });
    }
    /**
     * It parses the JSON downloaded from the OVC for platform (BitGo),
     * and creates a corresponding TSS BitGo key. It also returns the JSON that needs
     * to be uploaded back to the OVCs containing the BitGo -> OVC shares.
     * @param ovcOutputJson JSON format of the file downloaded from the OVC for platform
     * @returns {BitGoKeyFromOvcShares}
     */
    async createTssBitGoKeyFromOvcShares(ovcOutputJson) {
        var _a, _b, _c, _d;
        const decodedOvcOutput = (0, utils_1.decodeOrElse)(ovcJsonCodec_1.OvcToBitGoJSON.name, ovcJsonCodec_1.OvcToBitGoJSON, ovcOutputJson, (errors) => {
            throw new Error(`Error(s) parsing OVC JSON: ${errors}`);
        });
        if (decodedOvcOutput.state !== 1) {
            throw new Error('State expected to be "1". Please complete the first two OVC operations');
        }
        // OVC-1 is responsible for the User key
        const ovc1 = decodedOvcOutput.ovc[1];
        // OVC-2 is responsible for the Backup key
        const ovc2 = decodedOvcOutput.ovc[2];
        const keyShares = [
            {
                from: 'user',
                to: 'bitgo',
                publicShare: ovc1.ovcToBitgoShare.publicShare,
                privateShare: ovc1.ovcToBitgoShare.privateShare,
                privateShareProof: (_a = ovc1.ovcToBitgoShare.uSig.toString()) !== null && _a !== void 0 ? _a : '',
                vssProof: (_b = ovc1.ovcToBitgoShare.vssProof) !== null && _b !== void 0 ? _b : '',
            },
            {
                from: 'backup',
                to: 'bitgo',
                publicShare: ovc2.ovcToBitgoShare.publicShare,
                privateShare: ovc2.ovcToBitgoShare.privateShare,
                privateShareProof: (_c = ovc2.ovcToBitgoShare.uSig.toString()) !== null && _c !== void 0 ? _c : '',
                vssProof: (_d = ovc2.ovcToBitgoShare.vssProof) !== null && _d !== void 0 ? _d : '',
            },
        ];
        const key = await this.baseCoin.keychains().add({
            source: 'bitgo',
            keyShares,
            keyType: 'tss',
            userGPGPublicKey: ovc1.gpgPubKey,
            backupGPGPublicKey: ovc2.gpgPubKey,
        });
        (0, assert_1.default)(key.keyShares);
        (0, assert_1.default)(key.commonKeychain);
        (0, assert_1.default)(key.walletHSMGPGPublicKeySigs);
        const bitgoToUserShare = key.keyShares.find((value) => value.from === 'bitgo' && value.to === 'user');
        (0, assert_1.default)(bitgoToUserShare);
        (0, assert_1.default)(bitgoToUserShare.vssProof);
        (0, assert_1.default)(bitgoToUserShare.paillierPublicKey);
        const bitgoToBackupShare = key.keyShares.find((value) => value.from === 'bitgo' && value.to === 'backup');
        (0, assert_1.default)(bitgoToBackupShare);
        (0, assert_1.default)(bitgoToBackupShare.vssProof);
        (0, assert_1.default)(bitgoToBackupShare.paillierPublicKey);
        // Create JSON data with platform shares for OVC-1 and OVC-2
        const bitgoToOvcOutput = {
            wallet: {
                ...decodedOvcOutput,
                platform: {
                    commonKeychain: key.commonKeychain,
                    walletGpgPubKeySigs: key.walletHSMGPGPublicKeySigs,
                    ovc: {
                        // BitGo to User (OVC-1)
                        1: {
                            bitgoToOvcShare: {
                                i: 1,
                                j: 3,
                                publicShare: bitgoToUserShare.publicShare,
                                privateShare: bitgoToUserShare.privateShare,
                                paillierPublicKey: bitgoToUserShare.paillierPublicKey,
                                vssProof: bitgoToUserShare.vssProof,
                            },
                        },
                        // BitGo to Backup (OVC-2)
                        2: {
                            bitgoToOvcShare: {
                                i: 2,
                                j: 3,
                                publicShare: bitgoToBackupShare.publicShare,
                                privateShare: bitgoToBackupShare.privateShare,
                                paillierPublicKey: bitgoToBackupShare.paillierPublicKey,
                                vssProof: bitgoToBackupShare.vssProof,
                            },
                        },
                    },
                },
            },
        };
        // Mark it ready for next operation, should be 2
        bitgoToOvcOutput.wallet.state += 1;
        const output = {
            bitGoKeyId: key.id,
            bitGoOutputJsonForOvc: bitgoToOvcOutput,
        };
        return (0, utils_1.decodeOrElse)(ovcJsonCodec_1.BitGoKeyFromOvcShares.name, ovcJsonCodec_1.BitGoKeyFromOvcShares, output, (errors) => {
            throw new Error(`Error producing the output: ${errors}`);
        });
    }
    /**
     * Create keychain for ofc wallet using the password
     * @param userPassword
     * @returns
     */
    async createUserKeychain(userPassword) {
        const keychains = this.baseCoin.keychains();
        const newKeychain = keychains.create();
        const originalPasscodeEncryptionCode = (0, utils_1.generateRandomPassword)(5);
        const encryptedPrv = this.bitgo.encrypt({
            password: userPassword,
            input: newKeychain.prv,
        });
        return await keychains.add({
            encryptedPrv,
            originalPasscodeEncryptionCode,
            pub: newKeychain.pub,
            source: 'user',
        });
    }
}
exports.Keychains = Keychains;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5Y2hhaW5zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2JpdGdvL2tleWNoYWluL2tleWNoYWlucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDBDQUE0QjtBQUM1QixvREFBNEI7QUFDNUIscURBQXVDO0FBR3ZDLG9DQUFpSDtBQWlCakgsaURBQXVGO0FBR3ZGLE1BQWEsU0FBUztJQUlwQixZQUFZLEtBQWdCLEVBQUUsUUFBbUI7UUFDL0MsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQTBCO1FBQ2xDLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBRTFELElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1NBQ3ZDO1FBRUQsTUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQztRQUNyQixJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUU7WUFDaEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDM0M7UUFDRCxPQUFPLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxHQUFHLGtCQUFrQixDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUM1RixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsS0FBSyxD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QUFLLENBQUMsa0JBQWtCLENBQUMsWUFBb0I7UUFDM0MsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUM1QyxNQUFNLFdBQVcsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDdkMsTUFBTSw4QkFBOEIsR0FBRyxJQUFBLDhCQUFzQixFQUFDLENBQUMsQ0FBQyxDQUFDO1FBRWpFLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDO1lBQ3RDLFFBQVEsRUFBRSxZQUFZO1lBQ3RCLEtBQUssRUFBRSxXQUFXLENBQUMsR0FBRztTQUN2QixDQUFDLENBQUM7UUFFSCxPQUFPLE1BQU0sU0FBUyxDQUFDLEdBQUcsQ0FBQztZQUN6QixZQUFZO1lBQ1osOEJBQThCO1lBQzlCLEdBQUcsRUFBRSxXQUFXLENBQUMsR0FBRztZQUNwQixNQUFNLEVBQUUsTUFBTTtTQUNmLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQTdiRCw4QkE2YkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi4vLi4vY29tbW9uJztcbmltcG9ydCB7IElCYXNlQ29pbiwgS2V5Y2hhaW5zVHJpcGxldCwgS2V5UGFpciB9IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IEJpdEdvQmFzZSB9IGZyb20gJy4uL2JpdGdvQmFzZSc7XG5pbXBvcnQgeyBCbHNVdGlscywgUmVxdWVzdFRyYWNlciwgRUREU0FVdGlscywgRUNEU0FVdGlscywgZGVjb2RlT3JFbHNlLCBnZW5lcmF0ZVJhbmRvbVBhc3N3b3JkIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtcbiAgQWRkS2V5Y2hhaW5PcHRpb25zLFxuICBBcGlLZXlTaGFyZSxcbiAgQ2hhbmdlZEtleWNoYWlucyxcbiAgQ3JlYXRlQmFja3VwT3B0aW9ucyxcbiAgQ3JlYXRlQml0R29PcHRpb25zLFxuICBDcmVhdGVNcGNPcHRpb25zLFxuICBHZXRLZXljaGFpbk9wdGlvbnMsXG4gIEdldEtleXNGb3JTaWduaW5nT3B0aW9ucyxcbiAgSUtleWNoYWlucyxcbiAgS2V5Y2hhaW4sXG4gIExpc3RLZXljaGFpbk9wdGlvbnMsXG4gIExpc3RLZXljaGFpbnNSZXN1bHQsXG4gIFVwZGF0ZVBhc3N3b3JkT3B0aW9ucyxcbiAgVXBkYXRlU2luZ2xlS2V5Y2hhaW5QYXNzd29yZE9wdGlvbnMsXG59IGZyb20gJy4vaUtleWNoYWlucyc7XG5pbXBvcnQgeyBCaXRHb0tleUZyb21PdmNTaGFyZXMsIEJpdEdvVG9PdmNKU09OLCBPdmNUb0JpdEdvSlNPTiB9IGZyb20gJy4vb3ZjSnNvbkNvZGVjJztcbmltcG9ydCB7IFRzc1NldHRpbmdzIH0gZnJvbSAnQGJpdGdvL3B1YmxpYy10eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBLZXljaGFpbnMgaW1wbGVtZW50cyBJS2V5Y2hhaW5zIHtcbiAgcHJpdmF0ZSByZWFkb25seSBiaXRnbzogQml0R29CYXNlO1xuICBwcml2YXRlIHJlYWRvbmx5IGJhc2VDb2luOiBJQmFzZUNvaW47XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSwgYmFzZUNvaW46IElCYXNlQ29pbikge1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgICB0aGlzLmJhc2VDb2luID0gYmFzZUNvaW47XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEga2V5Y2hhaW4gYnkgSURcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmlkXG4gICAqIEBwYXJhbSBwYXJhbXMueHB1YiAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSBwYXJhbXMuZXRoQWRkcmVzcyAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSBwYXJhbXMucmVxSWQgKG9wdGlvbmFsKVxuICAgKi9cbiAgYXN5bmMgZ2V0KHBhcmFtczogR2V0S2V5Y2hhaW5PcHRpb25zKTogUHJvbWlzZTxLZXljaGFpbj4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ3hwdWInLCAnZXRoQWRkcmVzcyddKTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5pZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaWQgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBwYXJhbXMuaWQ7XG4gICAgaWYgKHBhcmFtcy5yZXFJZCkge1xuICAgICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHBhcmFtcy5yZXFJZCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL2tleS8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGlkKSkpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIGxpc3QgdGhlIHVzZXJzIGtleWNoYWluc1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMubGltaXQgLSBNYXggbnVtYmVyIG9mIHJlc3VsdHMgaW4gYSBzaW5nbGUgY2FsbC5cbiAgICogQHBhcmFtIHBhcmFtcy5wcmV2SWQgLSBDb250aW51ZSBpdGVyYXRpbmcgKHByb3ZpZGVkIGJ5IG5leHRCYXRjaFByZXZJZCBpbiB0aGUgcHJldmlvdXMgbGlzdClcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyBsaXN0KHBhcmFtczogTGlzdEtleWNoYWluT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxMaXN0S2V5Y2hhaW5zUmVzdWx0PiB7XG4gICAgY29uc3QgcXVlcnlPYmplY3Q6IGFueSA9IHt9O1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubGltaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgcXVlcnlPYmplY3QubGltaXQgPSBwYXJhbXMubGltaXQ7XG4gICAgfVxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMucHJldklkKSkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcmV2SWQgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5T2JqZWN0LnByZXZJZCA9IHBhcmFtcy5wcmV2SWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcva2V5JykpLnF1ZXJ5KHF1ZXJ5T2JqZWN0KS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGRlY3J5cHRpb24gcGFzc3dvcmQgZm9yIGFsbCBwb3NzaWJsZSBrZXljaGFpbnMgYXNzb2NpYXRlZCB3aXRoIGEgdXNlci5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBpdGVyYXRlcyB0aHJvdWdoIGFsbCBrZXlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlciwgZGVjcnlwdHNcbiAgICogdGhlbSB3aXRoIHRoZSBvbGQgcGFzc3dvcmQgYW5kIHJlLWVuY3J5cHRzIHRoZW0gd2l0aCB0aGUgbmV3IHBhc3N3b3JkLlxuICAgKlxuICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgd2hlbiBhIHVzZXIgY2hhbmdlcyB0aGVpciBsb2dpbiBwYXNzd29yZCwgYW5kIGFyZSBleHBlY3RpbmdcbiAgICogdGhhdCB0aGVpciB3YWxsZXQgcGFzc3dvcmRzIGFyZSBjaGFuZ2VkIHRvIG1hdGNoIHRoZSBuZXcgbG9naW4gcGFzc3dvcmQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5vbGRQYXNzd29yZCAtIFRoZSBvbGQgcGFzc3dvcmQgdXNlZCBmb3IgZW5jcnlwdGluZyB0aGUga2V5XG4gICAqIEBwYXJhbSBwYXJhbXMubmV3UGFzc3dvcmQgLSBUaGUgbmV3IHBhc3N3b3JkIHRvIGJlIHVzZWQgZm9yIGVuY3J5cHRpbmcgdGhlIGtleVxuICAgKiBAcmV0dXJucyBjaGFuZ2VkS2V5cyBPYmplY3QgLSBlLmcuOlxuICAgKiAge1xuICAgKiAgICB4cHViMTogZW5jcnlwdGVkUHJ2LFxuICAgKiAgICAuLi5cbiAgICogIH1cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVBhc3N3b3JkKHBhcmFtczogVXBkYXRlUGFzc3dvcmRPcHRpb25zKTogUHJvbWlzZTxDaGFuZ2VkS2V5Y2hhaW5zPiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydvbGRQYXNzd29yZCcsICduZXdQYXNzd29yZCddLCBbXSk7XG4gICAgY29uc3QgY2hhbmdlZEtleXM6IENoYW5nZWRLZXljaGFpbnMgPSB7fTtcbiAgICBsZXQgcHJldklkO1xuICAgIGxldCBrZXlzTGVmdCA9IHRydWU7XG4gICAgd2hpbGUgKGtleXNMZWZ0KSB7XG4gICAgICBjb25zdCByZXN1bHQ6IExpc3RLZXljaGFpbnNSZXN1bHQgPSBhd2FpdCB0aGlzLmxpc3QoeyBsaW1pdDogNTAwLCBwcmV2SWQgfSk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiByZXN1bHQua2V5cykge1xuICAgICAgICBjb25zdCBvbGRFbmNyeXB0ZWRQcnYgPSBrZXkuZW5jcnlwdGVkUHJ2O1xuICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChvbGRFbmNyeXB0ZWRQcnYpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkS2V5Y2hhaW4gPSB0aGlzLnVwZGF0ZVNpbmdsZUtleWNoYWluUGFzc3dvcmQoe1xuICAgICAgICAgICAga2V5Y2hhaW46IGtleSxcbiAgICAgICAgICAgIG9sZFBhc3N3b3JkOiBwYXJhbXMub2xkUGFzc3dvcmQsXG4gICAgICAgICAgICBuZXdQYXNzd29yZDogcGFyYW1zLm5ld1Bhc3N3b3JkLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh1cGRhdGVkS2V5Y2hhaW4uZW5jcnlwdGVkUHJ2KSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VkS2V5SWRlbnRpZmllciA9IHVwZGF0ZWRLZXljaGFpbi50eXBlID09PSAndHNzJyA/IHVwZGF0ZWRLZXljaGFpbi5pZCA6IHVwZGF0ZWRLZXljaGFpbi5wdWI7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZEtleUlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgY2hhbmdlZEtleXNbY2hhbmdlZEtleUlkZW50aWZpZXJdID0gdXBkYXRlZEtleWNoYWluLmVuY3J5cHRlZFBydjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgcGFzc3dvcmQgd2FzIGluY29ycmVjdCwgc2lsZW5jZSB0aGUgZXJyb3IsIHRocm93IG90aGVyd2lzZVxuICAgICAgICAgIGlmICghZS5tZXNzYWdlLmluY2x1ZGVzKCdwcml2YXRlIGtleSBpcyBpbmNvcnJlY3QnKSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQubmV4dEJhdGNoUHJldklkKSB7XG4gICAgICAgIHByZXZJZCA9IHJlc3VsdC5uZXh0QmF0Y2hQcmV2SWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzTGVmdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZEtleXM7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBwYXNzd29yZCB1c2VkIHRvIGRlY3J5cHQgYSBzaW5nbGUga2V5Y2hhaW5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmtleWNoYWluIC0gVGhlIGtleWNoYWluIHdob3NlIHBhc3N3b3JkIHNob3VsZCBiZSB1cGRhdGVkXG4gICAqIEBwYXJhbSBwYXJhbXMub2xkUGFzc3dvcmQgLSBUaGUgb2xkIHBhc3N3b3JkIHVzZWQgZm9yIGVuY3J5cHRpbmcgdGhlIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zLm5ld1Bhc3N3b3JkIC0gVGhlIG5ldyBwYXNzd29yZCB0byBiZSB1c2VkIGZvciBlbmNyeXB0aW5nIHRoZSBrZXlcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHVwZGF0ZVNpbmdsZUtleWNoYWluUGFzc3dvcmQocGFyYW1zOiBVcGRhdGVTaW5nbGVLZXljaGFpblBhc3N3b3JkT3B0aW9ucyA9IHt9KTogS2V5Y2hhaW4ge1xuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMub2xkUGFzc3dvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIG9sZCBwYXNzd29yZCB0byBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMubmV3UGFzc3dvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIG5ldyBwYXNzd29yZCB0byBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghXy5pc09iamVjdChwYXJhbXMua2V5Y2hhaW4pIHx8ICFfLmlzU3RyaW5nKHBhcmFtcy5rZXljaGFpbi5lbmNyeXB0ZWRQcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGtleWNoYWluIHRvIGJlIGFuIG9iamVjdCB3aXRoIGFuIGVuY3J5cHRlZFBydiBwcm9wZXJ0eScpO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZEVuY3J5cHRlZFBydiA9IHBhcmFtcy5rZXljaGFpbi5lbmNyeXB0ZWRQcnY7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRlY3J5cHRlZFBydiA9IHRoaXMuYml0Z28uZGVjcnlwdCh7IGlucHV0OiBvbGRFbmNyeXB0ZWRQcnYsIHBhc3N3b3JkOiBwYXJhbXMub2xkUGFzc3dvcmQgfSk7XG4gICAgICBjb25zdCBuZXdFbmNyeXB0ZWRQcnYgPSB0aGlzLmJpdGdvLmVuY3J5cHQoeyBpbnB1dDogZGVjcnlwdGVkUHJ2LCBwYXNzd29yZDogcGFyYW1zLm5ld1Bhc3N3b3JkIH0pO1xuICAgICAgcmV0dXJuIF8uYXNzaWduKHt9LCBwYXJhbXMua2V5Y2hhaW4sIHsgZW5jcnlwdGVkUHJ2OiBuZXdFbmNyeXB0ZWRQcnYgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gY2F0Y2hpbmcgYW4gZXJyb3IgaGVyZSBtZWFucyB0aGF0IHRoZSBwYXNzd29yZCB3YXMgaW5jb3JyZWN0IG9yLCBsZXNzIGxpa2VseSwgdGhlIGlucHV0IHRvIGRlY3J5cHQgaXMgY29ycnVwdGVkXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3N3b3JkIHVzZWQgdG8gZGVjcnlwdCBrZXljaGFpbiBwcml2YXRlIGtleSBpcyBpbmNvcnJlY3QnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcHVibGljL3ByaXZhdGUga2V5IHBhaXJcbiAgICogQHBhcmFtIHBhcmFtcyAtIG9wdGlvbmFsIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnNlZWQgb3B0aW9uYWwgLSBzZWVkIHRvIHVzZSBmb3Iga2V5cGFpciBnZW5lcmF0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXMuaXNSb290S2V5IG9wdGlvbmFsIC0gd2hldGhlciB0aGUgcmVzdWx0aW5nIGtleXBhaXIgc2hvdWxkIGJlIGEgcm9vdCBrZXlcbiAgICogQHJldHVybnMge0tleVBhaXJ9IC0gdGhlIGdlbmVyYXRlZCBrZXlwYWlyXG4gICAqL1xuICBjcmVhdGUocGFyYW1zOiB7IHNlZWQ/OiBCdWZmZXI7IGlzUm9vdEtleT86IGJvb2xlYW4gfSA9IHt9KTogS2V5UGFpciB7XG4gICAgaWYgKHBhcmFtcz8uaXNSb290S2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5iYXNlQ29pbi5nZW5lcmF0ZVJvb3RLZXlQYWlyKHBhcmFtcy5zZWVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYmFzZUNvaW4uZ2VuZXJhdGVLZXlQYWlyKHBhcmFtcy5zZWVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBrZXljaGFpbiB0byBCaXRHbydzIHJlY29yZHNcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgYWRkKHBhcmFtczogQWRkS2V5Y2hhaW5PcHRpb25zID0ge30pOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhcbiAgICAgIHBhcmFtcyxcbiAgICAgIFtdLFxuICAgICAgW1xuICAgICAgICAncHViJyxcbiAgICAgICAgJ2VuY3J5cHRlZFBydicsXG4gICAgICAgICdrZXlUeXBlJyxcbiAgICAgICAgJ3R5cGUnLFxuICAgICAgICAnc291cmNlJyxcbiAgICAgICAgJ29yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZScsXG4gICAgICAgICdlbnRlcnByaXNlJyxcbiAgICAgICAgJ2Rlcml2ZWRGcm9tUGFyZW50V2l0aFNlZWQnLFxuICAgICAgXVxuICAgICk7XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmRpc2FibGVLUlNFbWFpbCkpIHtcbiAgICAgIGlmICghXy5pc0Jvb2xlYW4ocGFyYW1zLmRpc2FibGVLUlNFbWFpbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRpc2FibGVLUlNFbWFpbCBhcmd1bWVudCwgZXhwZWN0aW5nIGJvb2xlYW4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnJlcUlkKSB7XG4gICAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocGFyYW1zLnJlcUlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy9rZXknKSlcbiAgICAgIC5zZW5kKHtcbiAgICAgICAgcHViOiBwYXJhbXMucHViLFxuICAgICAgICBjb21tb25QdWI6IHBhcmFtcy5jb21tb25QdWIsXG4gICAgICAgIGNvbW1vbktleWNoYWluOiBwYXJhbXMuY29tbW9uS2V5Y2hhaW4sXG4gICAgICAgIGVuY3J5cHRlZFBydjogcGFyYW1zLmVuY3J5cHRlZFBydixcbiAgICAgICAgdHlwZTogcGFyYW1zLnR5cGUsXG4gICAgICAgIGtleVR5cGU6IHBhcmFtcy5rZXlUeXBlLFxuICAgICAgICBzb3VyY2U6IHBhcmFtcy5zb3VyY2UsXG4gICAgICAgIHByb3ZpZGVyOiBwYXJhbXMucHJvdmlkZXIsXG4gICAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZTogcGFyYW1zLm9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICAgICAgZW50ZXJwcmlzZTogcGFyYW1zLmVudGVycHJpc2UsXG4gICAgICAgIGRlcml2ZWRGcm9tUGFyZW50V2l0aFNlZWQ6IHBhcmFtcy5kZXJpdmVkRnJvbVBhcmVudFdpdGhTZWVkLFxuICAgICAgICBkaXNhYmxlS1JTRW1haWw6IHBhcmFtcy5kaXNhYmxlS1JTRW1haWwsXG4gICAgICAgIGtyc1NwZWNpZmljOiBwYXJhbXMua3JzU3BlY2lmaWMsXG4gICAgICAgIGtleVNoYXJlczogcGFyYW1zLmtleVNoYXJlcyxcbiAgICAgICAgdXNlckdQR1B1YmxpY0tleTogcGFyYW1zLnVzZXJHUEdQdWJsaWNLZXksXG4gICAgICAgIGJhY2t1cEdQR1B1YmxpY0tleTogcGFyYW1zLmJhY2t1cEdQR1B1YmxpY0tleSxcbiAgICAgICAgYWxnb1VzZWQ6IHBhcmFtcy5hbGdvVXNlZCxcbiAgICAgICAgaXNEaXN0cmlidXRlZEN1c3RvZHk6IHBhcmFtcy5pc0Rpc3RyaWJ1dGVkQ3VzdG9keSxcbiAgICAgICAgaXNNUEN2MjogcGFyYW1zLmlzTVBDdjIsXG4gICAgICB9KVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIEJpdEdvIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zIChlbXB0eSlcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUJpdEdvKHBhcmFtczogQ3JlYXRlQml0R29PcHRpb25zID0ge30pOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgcGFyYW1zLnNvdXJjZSA9ICdiaXRnbyc7XG5cbiAgICB0aGlzLmJhc2VDb2luLnByZUNyZWF0ZUJpdEdvKHBhcmFtcyBhcyBhbnkpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkZChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJhY2t1cCBrZXlcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnByb3ZpZGVyIChvcHRpb25hbClcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUJhY2t1cChwYXJhbXM6IENyZWF0ZUJhY2t1cE9wdGlvbnMgPSB7fSk6IFByb21pc2U8S2V5Y2hhaW4+IHtcbiAgICBwYXJhbXMuc291cmNlID0gJ2JhY2t1cCc7XG5cbiAgICBjb25zdCBpc1Rzc0JhY2t1cEtleSA9IHBhcmFtcy5wcnYgJiYgKHBhcmFtcy5jb21tb25LZXljaGFpbiB8fCBwYXJhbXMuY29tbW9uUHViKTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5wcm92aWRlcikgJiYgIWlzVHNzQmFja3VwS2V5KSB7XG4gICAgICAvLyBpZiB0aGUgcHJvdmlkZXIgaXMgdW5kZWZpbmVkLCB3ZSBnZW5lcmF0ZSBhIGxvY2FsIGtleSBhbmQgYWRkIHRoZSBzb3VyY2UgZGV0YWlsc1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5jcmVhdGUoKTtcbiAgICAgIF8uZXh0ZW5kKHBhcmFtcywga2V5KTtcbiAgICAgIGlmIChwYXJhbXMucGFzc3BocmFzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF8uZXh0ZW5kKHBhcmFtcywgeyBlbmNyeXB0ZWRQcnY6IHRoaXMuYml0Z28uZW5jcnlwdCh7IGlucHV0OiBrZXkucHJ2LCBwYXNzd29yZDogcGFyYW1zLnBhc3NwaHJhc2UgfSkgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFkZChwYXJhbXMpO1xuICAgIHJldHVybiBfLmV4dGVuZCh7fSwgc2VydmVyUmVzcG9uc2UsIF8ucGljayhwYXJhbXMsIFsncHJ2JywgJ2VuY3J5cHRlZFBydicsICdwcm92aWRlcicsICdzb3VyY2UnXSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMga2V5cyBmb3Igc2lnbmluZyBmcm9tIGEgd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMge1Byb21pc2U8S2V5Y2hhaW5bXT59XG4gICAqL1xuICBhc3luYyBnZXRLZXlzRm9yU2lnbmluZyhwYXJhbXM6IEdldEtleXNGb3JTaWduaW5nT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxLZXljaGFpbltdPiB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcy53YWxsZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcGFyYW0gd2FsbGV0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHdhbGxldCA9IHBhcmFtcy53YWxsZXQ7XG4gICAgY29uc3QgcmVxSWQgPSBwYXJhbXMucmVxSWQgfHwgbmV3IFJlcXVlc3RUcmFjZXIoKTtcbiAgICBjb25zdCBpZHMgPSB3YWxsZXQuYmFzZUNvaW4ua2V5SWRzRm9yU2lnbmluZygpO1xuICAgIGNvbnN0IGtleWNoYWluUXVlcmllc0JsdWViaXJkcyA9IGlkcy5tYXAoKGlkKSA9PiB0aGlzLmdldCh7IGlkOiB3YWxsZXQua2V5SWRzKClbaWRdLCByZXFJZCB9KSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGtleWNoYWluUXVlcmllc0JsdWViaXJkcyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gY3JlYXRlIGFuZCBzdG9yZSBNUEMga2V5Y2hhaW5zIHdpdGggQml0R28uXG4gICAqIEBwYXJhbSBwYXJhbXMgcGFzc3BocmFzZSB1c2VkIHRvIGVuY3J5cHQgc2VjcmV0IG1hdGVyaWFsc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPEtleWNoYWluc1RyaXBsZXQ+fSBuZXdseSBjcmVhdGVkIFVzZXIsIEJhY2t1cCwgYW5kIEJpdEdvIGtleXNcbiAgICovXG4gIGFzeW5jIGNyZWF0ZU1wYyhwYXJhbXM6IENyZWF0ZU1wY09wdGlvbnMpOiBQcm9taXNlPEtleWNoYWluc1RyaXBsZXQ+IHtcbiAgICBsZXQgTXBjVXRpbHM7XG4gICAgbGV0IG11bHRpc2lnVHlwZVZlcnNpb246ICdNUEN2MicgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmFtcy5tdWx0aXNpZ1R5cGUgPT09ICd0c3MnICYmIHRoaXMuYmFzZUNvaW4uZ2V0TVBDQWxnb3JpdGhtKCkgPT09ICdlY2RzYScpIHtcbiAgICAgIGNvbnN0IHRzc1NldHRpbmdzOiBUc3NTZXR0aW5ncyA9IGF3YWl0IHRoaXMuYml0Z29cbiAgICAgICAgLmdldCh0aGlzLmJpdGdvLm1pY3Jvc2VydmljZXNVcmwoJy9hcGkvdjIvdHNzL3NldHRpbmdzJykpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICAgIG11bHRpc2lnVHlwZVZlcnNpb24gPVxuICAgICAgICB0c3NTZXR0aW5ncy5jb2luU2V0dGluZ3NbdGhpcy5iYXNlQ29pbi5nZXRGYW1pbHkoKV0/LndhbGxldENyZWF0aW9uU2V0dGluZ3M/Lm11bHRpU2lnVHlwZVZlcnNpb247XG4gICAgfVxuXG4gICAgc3dpdGNoIChwYXJhbXMubXVsdGlzaWdUeXBlKSB7XG4gICAgICBjYXNlICd0c3MnOlxuICAgICAgICBNcGNVdGlscyA9XG4gICAgICAgICAgdGhpcy5iYXNlQ29pbi5nZXRNUENBbGdvcml0aG0oKSA9PT0gJ2VkZHNhJ1xuICAgICAgICAgICAgPyBFRERTQVV0aWxzLmRlZmF1bHRcbiAgICAgICAgICAgIDogbXVsdGlzaWdUeXBlVmVyc2lvbiA9PT0gJ01QQ3YyJ1xuICAgICAgICAgICAgPyBFQ0RTQVV0aWxzLkVjZHNhTVBDdjJVdGlsc1xuICAgICAgICAgICAgOiBFQ0RTQVV0aWxzLkVjZHNhVXRpbHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYmxzZGtnJzpcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnBhc3NwaHJhc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHBhcmFtIHBhc3NwaHJhc2UnKTtcbiAgICAgICAgfVxuICAgICAgICBNcGNVdGlscyA9IEJsc1V0aWxzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgbXVsdGktc2lnIHR5cGUnKTtcbiAgICB9XG4gICAgY29uc3QgbXBjVXRpbHMgPSBuZXcgTXBjVXRpbHModGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbik7XG4gICAgcmV0dXJuIGF3YWl0IG1wY1V0aWxzLmNyZWF0ZUtleWNoYWlucyh7XG4gICAgICBwYXNzcGhyYXNlOiBwYXJhbXMucGFzc3BocmFzZSxcbiAgICAgIGVudGVycHJpc2U6IHBhcmFtcy5lbnRlcnByaXNlLFxuICAgICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlOiBwYXJhbXMub3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgICAgYmFja3VwUHJvdmlkZXI6IHBhcmFtcy5iYWNrdXBQcm92aWRlcixcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdCBwYXJzZXMgdGhlIEpTT04gZG93bmxvYWRlZCBmcm9tIHRoZSBPVkMgZm9yIHBsYXRmb3JtIChCaXRHbyksXG4gICAqIGFuZCBjcmVhdGVzIGEgY29ycmVzcG9uZGluZyBUU1MgQml0R28ga2V5LiBJdCBhbHNvIHJldHVybnMgdGhlIEpTT04gdGhhdCBuZWVkc1xuICAgKiB0byBiZSB1cGxvYWRlZCBiYWNrIHRvIHRoZSBPVkNzIGNvbnRhaW5pbmcgdGhlIEJpdEdvIC0+IE9WQyBzaGFyZXMuXG4gICAqIEBwYXJhbSBvdmNPdXRwdXRKc29uIEpTT04gZm9ybWF0IG9mIHRoZSBmaWxlIGRvd25sb2FkZWQgZnJvbSB0aGUgT1ZDIGZvciBwbGF0Zm9ybVxuICAgKiBAcmV0dXJucyB7Qml0R29LZXlGcm9tT3ZjU2hhcmVzfVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlVHNzQml0R29LZXlGcm9tT3ZjU2hhcmVzKG92Y091dHB1dEpzb246IHVua25vd24pOiBQcm9taXNlPEJpdEdvS2V5RnJvbU92Y1NoYXJlcz4ge1xuICAgIGNvbnN0IGRlY29kZWRPdmNPdXRwdXQgPSBkZWNvZGVPckVsc2UoT3ZjVG9CaXRHb0pTT04ubmFtZSwgT3ZjVG9CaXRHb0pTT04sIG92Y091dHB1dEpzb24sIChlcnJvcnMpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IocykgcGFyc2luZyBPVkMgSlNPTjogJHtlcnJvcnN9YCk7XG4gICAgfSk7XG5cbiAgICBpZiAoZGVjb2RlZE92Y091dHB1dC5zdGF0ZSAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZSBleHBlY3RlZCB0byBiZSBcIjFcIi4gUGxlYXNlIGNvbXBsZXRlIHRoZSBmaXJzdCB0d28gT1ZDIG9wZXJhdGlvbnMnKTtcbiAgICB9XG5cbiAgICAvLyBPVkMtMSBpcyByZXNwb25zaWJsZSBmb3IgdGhlIFVzZXIga2V5XG4gICAgY29uc3Qgb3ZjMSA9IGRlY29kZWRPdmNPdXRwdXQub3ZjWzFdO1xuICAgIC8vIE9WQy0yIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgQmFja3VwIGtleVxuICAgIGNvbnN0IG92YzIgPSBkZWNvZGVkT3ZjT3V0cHV0Lm92Y1syXTtcblxuICAgIGNvbnN0IGtleVNoYXJlczogQXBpS2V5U2hhcmVbXSA9IFtcbiAgICAgIHtcbiAgICAgICAgZnJvbTogJ3VzZXInLFxuICAgICAgICB0bzogJ2JpdGdvJyxcbiAgICAgICAgcHVibGljU2hhcmU6IG92YzEub3ZjVG9CaXRnb1NoYXJlLnB1YmxpY1NoYXJlLFxuICAgICAgICBwcml2YXRlU2hhcmU6IG92YzEub3ZjVG9CaXRnb1NoYXJlLnByaXZhdGVTaGFyZSxcbiAgICAgICAgcHJpdmF0ZVNoYXJlUHJvb2Y6IG92YzEub3ZjVG9CaXRnb1NoYXJlLnVTaWcudG9TdHJpbmcoKSA/PyAnJyxcbiAgICAgICAgdnNzUHJvb2Y6IG92YzEub3ZjVG9CaXRnb1NoYXJlLnZzc1Byb29mID8/ICcnLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZnJvbTogJ2JhY2t1cCcsXG4gICAgICAgIHRvOiAnYml0Z28nLFxuICAgICAgICBwdWJsaWNTaGFyZTogb3ZjMi5vdmNUb0JpdGdvU2hhcmUucHVibGljU2hhcmUsXG4gICAgICAgIHByaXZhdGVTaGFyZTogb3ZjMi5vdmNUb0JpdGdvU2hhcmUucHJpdmF0ZVNoYXJlLFxuICAgICAgICBwcml2YXRlU2hhcmVQcm9vZjogb3ZjMi5vdmNUb0JpdGdvU2hhcmUudVNpZy50b1N0cmluZygpID8/ICcnLFxuICAgICAgICB2c3NQcm9vZjogb3ZjMi5vdmNUb0JpdGdvU2hhcmUudnNzUHJvb2YgPz8gJycsXG4gICAgICB9LFxuICAgIF07XG5cbiAgICBjb25zdCBrZXkgPSBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmFkZCh7XG4gICAgICBzb3VyY2U6ICdiaXRnbycsXG4gICAgICBrZXlTaGFyZXMsXG4gICAgICBrZXlUeXBlOiAndHNzJyxcbiAgICAgIHVzZXJHUEdQdWJsaWNLZXk6IG92YzEuZ3BnUHViS2V5LFxuICAgICAgYmFja3VwR1BHUHVibGljS2V5OiBvdmMyLmdwZ1B1YktleSxcbiAgICB9KTtcbiAgICBhc3NlcnQoa2V5LmtleVNoYXJlcyk7XG4gICAgYXNzZXJ0KGtleS5jb21tb25LZXljaGFpbik7XG4gICAgYXNzZXJ0KGtleS53YWxsZXRIU01HUEdQdWJsaWNLZXlTaWdzKTtcblxuICAgIGNvbnN0IGJpdGdvVG9Vc2VyU2hhcmUgPSBrZXkua2V5U2hhcmVzLmZpbmQoXG4gICAgICAodmFsdWU6IHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nIH0pID0+IHZhbHVlLmZyb20gPT09ICdiaXRnbycgJiYgdmFsdWUudG8gPT09ICd1c2VyJ1xuICAgICk7XG4gICAgYXNzZXJ0KGJpdGdvVG9Vc2VyU2hhcmUpO1xuICAgIGFzc2VydChiaXRnb1RvVXNlclNoYXJlLnZzc1Byb29mKTtcbiAgICBhc3NlcnQoYml0Z29Ub1VzZXJTaGFyZS5wYWlsbGllclB1YmxpY0tleSk7XG4gICAgY29uc3QgYml0Z29Ub0JhY2t1cFNoYXJlID0ga2V5LmtleVNoYXJlcy5maW5kKFxuICAgICAgKHZhbHVlOiB7IGZyb206IHN0cmluZzsgdG86IHN0cmluZyB9KSA9PiB2YWx1ZS5mcm9tID09PSAnYml0Z28nICYmIHZhbHVlLnRvID09PSAnYmFja3VwJ1xuICAgICk7XG4gICAgYXNzZXJ0KGJpdGdvVG9CYWNrdXBTaGFyZSk7XG4gICAgYXNzZXJ0KGJpdGdvVG9CYWNrdXBTaGFyZS52c3NQcm9vZik7XG4gICAgYXNzZXJ0KGJpdGdvVG9CYWNrdXBTaGFyZS5wYWlsbGllclB1YmxpY0tleSk7XG5cbiAgICAvLyBDcmVhdGUgSlNPTiBkYXRhIHdpdGggcGxhdGZvcm0gc2hhcmVzIGZvciBPVkMtMSBhbmQgT1ZDLTJcbiAgICBjb25zdCBiaXRnb1RvT3ZjT3V0cHV0OiBCaXRHb1RvT3ZjSlNPTiA9IHtcbiAgICAgIHdhbGxldDoge1xuICAgICAgICAuLi5kZWNvZGVkT3ZjT3V0cHV0LFxuICAgICAgICBwbGF0Zm9ybToge1xuICAgICAgICAgIGNvbW1vbktleWNoYWluOiBrZXkuY29tbW9uS2V5Y2hhaW4sXG4gICAgICAgICAgd2FsbGV0R3BnUHViS2V5U2lnczoga2V5LndhbGxldEhTTUdQR1B1YmxpY0tleVNpZ3MsXG4gICAgICAgICAgb3ZjOiB7XG4gICAgICAgICAgICAvLyBCaXRHbyB0byBVc2VyIChPVkMtMSlcbiAgICAgICAgICAgIDE6IHtcbiAgICAgICAgICAgICAgYml0Z29Ub092Y1NoYXJlOiB7XG4gICAgICAgICAgICAgICAgaTogMSxcbiAgICAgICAgICAgICAgICBqOiAzLFxuICAgICAgICAgICAgICAgIHB1YmxpY1NoYXJlOiBiaXRnb1RvVXNlclNoYXJlLnB1YmxpY1NoYXJlLFxuICAgICAgICAgICAgICAgIHByaXZhdGVTaGFyZTogYml0Z29Ub1VzZXJTaGFyZS5wcml2YXRlU2hhcmUsXG4gICAgICAgICAgICAgICAgcGFpbGxpZXJQdWJsaWNLZXk6IGJpdGdvVG9Vc2VyU2hhcmUucGFpbGxpZXJQdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgdnNzUHJvb2Y6IGJpdGdvVG9Vc2VyU2hhcmUudnNzUHJvb2YsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gQml0R28gdG8gQmFja3VwIChPVkMtMilcbiAgICAgICAgICAgIDI6IHtcbiAgICAgICAgICAgICAgYml0Z29Ub092Y1NoYXJlOiB7XG4gICAgICAgICAgICAgICAgaTogMixcbiAgICAgICAgICAgICAgICBqOiAzLFxuICAgICAgICAgICAgICAgIHB1YmxpY1NoYXJlOiBiaXRnb1RvQmFja3VwU2hhcmUucHVibGljU2hhcmUsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZVNoYXJlOiBiaXRnb1RvQmFja3VwU2hhcmUucHJpdmF0ZVNoYXJlLFxuICAgICAgICAgICAgICAgIHBhaWxsaWVyUHVibGljS2V5OiBiaXRnb1RvQmFja3VwU2hhcmUucGFpbGxpZXJQdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgdnNzUHJvb2Y6IGJpdGdvVG9CYWNrdXBTaGFyZS52c3NQcm9vZixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIC8vIE1hcmsgaXQgcmVhZHkgZm9yIG5leHQgb3BlcmF0aW9uLCBzaG91bGQgYmUgMlxuICAgIGJpdGdvVG9PdmNPdXRwdXQud2FsbGV0LnN0YXRlICs9IDE7XG5cbiAgICBjb25zdCBvdXRwdXQ6IEJpdEdvS2V5RnJvbU92Y1NoYXJlcyA9IHtcbiAgICAgIGJpdEdvS2V5SWQ6IGtleS5pZCxcbiAgICAgIGJpdEdvT3V0cHV0SnNvbkZvck92YzogYml0Z29Ub092Y091dHB1dCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlY29kZU9yRWxzZShCaXRHb0tleUZyb21PdmNTaGFyZXMubmFtZSwgQml0R29LZXlGcm9tT3ZjU2hhcmVzLCBvdXRwdXQsIChlcnJvcnMpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgcHJvZHVjaW5nIHRoZSBvdXRwdXQ6ICR7ZXJyb3JzfWApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBrZXljaGFpbiBmb3Igb2ZjIHdhbGxldCB1c2luZyB0aGUgcGFzc3dvcmRcbiAgICogQHBhcmFtIHVzZXJQYXNzd29yZFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlVXNlcktleWNoYWluKHVzZXJQYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxLZXljaGFpbj4ge1xuICAgIGNvbnN0IGtleWNoYWlucyA9IHRoaXMuYmFzZUNvaW4ua2V5Y2hhaW5zKCk7XG4gICAgY29uc3QgbmV3S2V5Y2hhaW4gPSBrZXljaGFpbnMuY3JlYXRlKCk7XG4gICAgY29uc3Qgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlID0gZ2VuZXJhdGVSYW5kb21QYXNzd29yZCg1KTtcblxuICAgIGNvbnN0IGVuY3J5cHRlZFBydiA9IHRoaXMuYml0Z28uZW5jcnlwdCh7XG4gICAgICBwYXNzd29yZDogdXNlclBhc3N3b3JkLFxuICAgICAgaW5wdXQ6IG5ld0tleWNoYWluLnBydixcbiAgICB9KTtcblxuICAgIHJldHVybiBhd2FpdCBrZXljaGFpbnMuYWRkKHtcbiAgICAgIGVuY3J5cHRlZFBydixcbiAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICAgIHB1YjogbmV3S2V5Y2hhaW4ucHViLFxuICAgICAgc291cmNlOiAndXNlcicsXG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==