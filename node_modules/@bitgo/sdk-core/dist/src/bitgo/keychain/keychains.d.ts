/// <reference types="node" />
import { IBaseCoin, KeychainsTriplet, KeyPair } from '../baseCoin';
import { BitGoBase } from '../bitgoBase';
import { AddKeychainOptions, ChangedKeychains, CreateBackupOptions, CreateBitGoOptions, CreateMpcOptions, GetKeychainOptions, GetKeysForSigningOptions, IKeychains, Keychain, ListKeychainOptions, ListKeychainsResult, UpdatePasswordOptions, UpdateSingleKeychainPasswordOptions } from './iKeychains';
import { BitGoKeyFromOvcShares } from './ovcJsonCodec';
export declare class Keychains implements IKeychains {
    private readonly bitgo;
    private readonly baseCoin;
    constructor(bitgo: BitGoBase, baseCoin: IBaseCoin);
    /**
     * Get a keychain by ID
     * @param params
     * @param params.id
     * @param params.xpub (optional)
     * @param params.ethAddress (optional)
     * @param params.reqId (optional)
     */
    get(params: GetKeychainOptions): Promise<Keychain>;
    /**
     * list the users keychains
     * @param params
     * @param params.limit - Max number of results in a single call.
     * @param params.prevId - Continue iterating (provided by nextBatchPrevId in the previous list)
     * @returns {*}
     */
    list(params?: ListKeychainOptions): Promise<ListKeychainsResult>;
    /**
     * Change the decryption password for all possible keychains associated with a user.
     *
     * This function iterates through all keys associated with the user, decrypts
     * them with the old password and re-encrypts them with the new password.
     *
     * This should be called when a user changes their login password, and are expecting
     * that their wallet passwords are changed to match the new login password.
     *
     * @param params
     * @param params.oldPassword - The old password used for encrypting the key
     * @param params.newPassword - The new password to be used for encrypting the key
     * @returns changedKeys Object - e.g.:
     *  {
     *    xpub1: encryptedPrv,
     *    ...
     *  }
     */
    updatePassword(params: UpdatePasswordOptions): Promise<ChangedKeychains>;
    /**
     * Update the password used to decrypt a single keychain
     * @param params
     * @param params.keychain - The keychain whose password should be updated
     * @param params.oldPassword - The old password used for encrypting the key
     * @param params.newPassword - The new password to be used for encrypting the key
     * @returns {object}
     */
    updateSingleKeychainPassword(params?: UpdateSingleKeychainPasswordOptions): Keychain;
    /**
     * Create a public/private key pair
     * @param params - optional params
     * @param params.seed optional - seed to use for keypair generation
     * @param params.isRootKey optional - whether the resulting keypair should be a root key
     * @returns {KeyPair} - the generated keypair
     */
    create(params?: {
        seed?: Buffer;
        isRootKey?: boolean;
    }): KeyPair;
    /**
     * Add a keychain to BitGo's records
     * @param params
     */
    add(params?: AddKeychainOptions): Promise<Keychain>;
    /**
     * Create a BitGo key
     * @param params (empty)
     */
    createBitGo(params?: CreateBitGoOptions): Promise<Keychain>;
    /**
     * Create a backup key
     * @param params
     * @param params.provider (optional)
     */
    createBackup(params?: CreateBackupOptions): Promise<Keychain>;
    /**
     * Gets keys for signing from a wallet
     * @param params
     * @returns {Promise<Keychain[]>}
     */
    getKeysForSigning(params?: GetKeysForSigningOptions): Promise<Keychain[]>;
    /**
     * Convenience function to create and store MPC keychains with BitGo.
     * @param params passphrase used to encrypt secret materials
     * @return {Promise<KeychainsTriplet>} newly created User, Backup, and BitGo keys
     */
    createMpc(params: CreateMpcOptions): Promise<KeychainsTriplet>;
    /**
     * It parses the JSON downloaded from the OVC for platform (BitGo),
     * and creates a corresponding TSS BitGo key. It also returns the JSON that needs
     * to be uploaded back to the OVCs containing the BitGo -> OVC shares.
     * @param ovcOutputJson JSON format of the file downloaded from the OVC for platform
     * @returns {BitGoKeyFromOvcShares}
     */
    createTssBitGoKeyFromOvcShares(ovcOutputJson: unknown): Promise<BitGoKeyFromOvcShares>;
    /**
     * Create keychain for ofc wallet using the password
     * @param userPassword
     * @returns
     */
    createUserKeychain(userPassword: string): Promise<Keychain>;
}
//# sourceMappingURL=keychains.d.ts.map