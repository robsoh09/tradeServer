"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeKey = exports.ab2str = exports.str2ab = void 0;
const crypto_1 = __importDefault(require("crypto"));
/**
 * str2ab - Convert a string to an ArrayBuffer
 * @param {string} str The string to convert
 * @returns {ArrayBuffer} The ArrayBuffer
 */
function str2ab(str) {
    const buf = new ArrayBuffer(str.length);
    const bufView = new Uint8Array(buf);
    for (let i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}
exports.str2ab = str2ab;
/**
 * ab2str - Convert a buffer to a string
 * @param {ArrayBuffer} buf The buffer to convert
 * @returns {string} The string
 */
function ab2str(buf) {
    return String.fromCharCode.apply(null, Array.from(new Uint8Array(buf)));
}
exports.ab2str = ab2str;
/**
 * computeKey - Compute a key from a password and salt
 * @param {string | Buffer} pass The password to use
 * @param {Buffer} salt The salt to use
 * @returns {Promise<Buffer>} The computed key
 */
async function computeKey(pass, salt) {
    let resolvePromise;
    let rejectPromise;
    const promise = new Promise((resolve, reject) => {
        resolvePromise = resolve;
        rejectPromise = reject;
    });
    crypto_1.default.pbkdf2(pass, salt, 200000, 32, 'sha256', (err, derivedKey) => {
        if (err !== null) {
            rejectPromise(err);
        }
        else {
            resolvePromise(derivedKey);
        }
    });
    return promise;
}
exports.computeKey = computeKey;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvYml0Z28vdHJhZGluZy9uZXR3b3JrL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG9EQUE0QjtBQUU1Qjs7OztHQUlHO0FBQ0gsU0FBZ0IsTUFBTSxDQUFDLEdBQVc7SUFDaEMsTUFBTSxHQUFHLEdBQUcsSUFBSSxXQUFXLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hDLE1BQU0sT0FBTyxHQUFHLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3BDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLE1BQU0sR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDcEQsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDaEM7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFQRCx3QkFPQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQixNQUFNLENBQUMsR0FBZ0I7SUFDckMsT0FBTyxNQUFNLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUUsQ0FBQztBQUZELHdCQUVDO0FBRUQ7Ozs7O0dBS0c7QUFDSSxLQUFLLFVBQVUsVUFBVSxDQUFDLElBQXFCLEVBQUUsSUFBWTtJQUNsRSxJQUFJLGNBQXdDLENBQUM7SUFDN0MsSUFBSSxhQUF3QyxDQUFDO0lBRTdDLE1BQU0sT0FBTyxHQUFvQixJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtRQUMvRCxjQUFjLEdBQUcsT0FBTyxDQUFDO1FBQ3pCLGFBQWEsR0FBRyxNQUFNLENBQUM7SUFDekIsQ0FBQyxDQUFDLENBQUM7SUFFSCxnQkFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsUUFBUSxFQUFFLENBQUMsR0FBRyxFQUFFLFVBQVUsRUFBRSxFQUFFO1FBQ2xFLElBQUksR0FBRyxLQUFLLElBQUksRUFBRTtZQUNoQixhQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDcEI7YUFBTTtZQUNMLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUM1QjtJQUNILENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTyxPQUFPLENBQUM7QUFDakIsQ0FBQztBQWxCRCxnQ0FrQkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbi8qKlxuICogc3RyMmFiIC0gQ29udmVydCBhIHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gVGhlIEFycmF5QnVmZmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIyYWIoc3RyOiBzdHJpbmcpOiBBcnJheUJ1ZmZlciB7XG4gIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihzdHIubGVuZ3RoKTtcbiAgY29uc3QgYnVmVmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gIGZvciAobGV0IGkgPSAwLCBzdHJMZW4gPSBzdHIubGVuZ3RoOyBpIDwgc3RyTGVuOyBpKyspIHtcbiAgICBidWZWaWV3W2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuLyoqXG4gKiBhYjJzdHIgLSBDb252ZXJ0IGEgYnVmZmVyIHRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhYjJzdHIoYnVmOiBBcnJheUJ1ZmZlcik6IHN0cmluZyB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoYnVmKSkpO1xufVxuXG4vKipcbiAqIGNvbXB1dGVLZXkgLSBDb21wdXRlIGEga2V5IGZyb20gYSBwYXNzd29yZCBhbmQgc2FsdFxuICogQHBhcmFtIHtzdHJpbmcgfCBCdWZmZXJ9IHBhc3MgVGhlIHBhc3N3b3JkIHRvIHVzZVxuICogQHBhcmFtIHtCdWZmZXJ9IHNhbHQgVGhlIHNhbHQgdG8gdXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXI+fSBUaGUgY29tcHV0ZWQga2V5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb21wdXRlS2V5KHBhc3M6IHN0cmluZyB8IEJ1ZmZlciwgc2FsdDogQnVmZmVyKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgbGV0IHJlc29sdmVQcm9taXNlOiAocmVzdWx0OiBCdWZmZXIpID0+IHZvaWQ7XG4gIGxldCByZWplY3RQcm9taXNlOiAocmVqZWN0OiB1bmtub3duKSA9PiB2b2lkO1xuXG4gIGNvbnN0IHByb21pc2U6IFByb21pc2U8QnVmZmVyPiA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcbiAgfSk7XG5cbiAgY3J5cHRvLnBia2RmMihwYXNzLCBzYWx0LCAyMDAwMDAsIDMyLCAnc2hhMjU2JywgKGVyciwgZGVyaXZlZEtleSkgPT4ge1xuICAgIGlmIChlcnIgIT09IG51bGwpIHtcbiAgICAgIHJlamVjdFByb21pc2UoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZVByb21pc2UoZGVyaXZlZEtleSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcHJvbWlzZTtcbn1cbiJdfQ==