"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports._encryptBrowserRsa = void 0;
const crypto_1 = __importDefault(require("crypto"));
const utils_1 = require("./utils");
/**
 * Import a public RSA key and encrypt a plaintext
 * @param {string} publicKey PEM-formatted public RSA key
 * @param {string} text The text to encrypt
 * @returns {string} The encrypted text
 */
async function _encryptBrowserRsa(publicKey, text) {
    const pub = await importPublicKey(publicKey);
    const encrypted = await encryptRSA(pub, new TextEncoder().encode(text));
    return btoa((0, utils_1.ab2str)(encrypted));
}
exports._encryptBrowserRsa = _encryptBrowserRsa;
/**
 * Import a public RSA key from a PEM string
 * @param {string} spkiPem
 * @returns {CryptoKey}
 */
async function importPublicKey(spkiPem) {
    // Pull from window.crypto when running in the browser.
    // This is due to libraries like crypto-browserify overriding "crypto" while not supporting various crypto functions.
    let cryptoJS = crypto_1.default;
    if (typeof window !== 'undefined') {
        cryptoJS = window.crypto;
    }
    return await cryptoJS.subtle.importKey('spki', getSpkiDer(spkiPem), {
        name: 'RSA-OAEP',
        hash: 'SHA-256',
    }, true, ['encrypt']);
}
/**
 * Encrypt a plaintext using RSA-OAEP
 * @param {CryptoKey} key The public key to use for encryption
 * @param {ArrayBuffer} plaintext The plaintext to encrypt
 * @returns {ArrayBuffer} The encrypted text
 */
async function encryptRSA(key, plaintext) {
    // Pull from window.crypto when running in the browser.
    // This is due to libraries like crypto-browserify overriding "crypto" while not supporting various crypto functions.
    let cryptoJS = crypto_1.default;
    if (typeof window !== 'undefined') {
        cryptoJS = window.crypto;
    }
    const encrypted = await cryptoJS.subtle.encrypt({
        name: 'RSA-OAEP',
    }, key, plaintext);
    return encrypted;
}
/**
 * Convert a PEM-formatted SPKI key to a DER-formatted ArrayBuffer
 * @param {string} spkiPem PEM-formatted SPKI key
 * @returns {ArrayBuffer} DER-formatted public key
 */
function getSpkiDer(spkiPem) {
    spkiPem = spkiPem.replace(/-----[^-]+-----/g, '').replace(/\s+/g, '');
    const binaryDerString = atob(spkiPem);
    return (0, utils_1.str2ab)(binaryDerString);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW5jcnlwdC1yc2EtYnJvd3Nlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9iaXRnby90cmFkaW5nL25ldHdvcmsvZW5jcnlwdC1yc2EtYnJvd3Nlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxvREFBNEI7QUFDNUIsbUNBQXlDO0FBRXpDOzs7OztHQUtHO0FBQ0ksS0FBSyxVQUFVLGtCQUFrQixDQUFDLFNBQWlCLEVBQUUsSUFBWTtJQUN0RSxNQUFNLEdBQUcsR0FBRyxNQUFNLGVBQWUsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUM3QyxNQUFNLFNBQVMsR0FBRyxNQUFNLFVBQVUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxXQUFXLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUN4RSxPQUFPLElBQUksQ0FBQyxJQUFBLGNBQU0sRUFBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBQ2pDLENBQUM7QUFKRCxnREFJQztBQUVEOzs7O0dBSUc7QUFDSCxLQUFLLFVBQVUsZUFBZSxDQUFDLE9BQWU7SUFDNUMsdURBQXVEO0lBQ3ZELHFIQUFxSDtJQUNySCxJQUFJLFFBQVEsR0FBUSxnQkFBTSxDQUFDO0lBQzNCLElBQUksT0FBTyxNQUFNLEtBQUssV0FBVyxFQUFFO1FBQ2pDLFFBQVEsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0tBQzFCO0lBRUQsT0FBTyxNQUFNLFFBQVEsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUNwQyxNQUFNLEVBQ04sVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUNuQjtRQUNFLElBQUksRUFBRSxVQUFVO1FBQ2hCLElBQUksRUFBRSxTQUFTO0tBQ2hCLEVBQ0QsSUFBSSxFQUNKLENBQUMsU0FBUyxDQUFDLENBQ1osQ0FBQztBQUNKLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILEtBQUssVUFBVSxVQUFVLENBQUMsR0FBYyxFQUFFLFNBQXNCO0lBQzlELHVEQUF1RDtJQUN2RCxxSEFBcUg7SUFDckgsSUFBSSxRQUFRLEdBQVEsZ0JBQU0sQ0FBQztJQUMzQixJQUFJLE9BQU8sTUFBTSxLQUFLLFdBQVcsRUFBRTtRQUNqQyxRQUFRLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztLQUMxQjtJQUVELE1BQU0sU0FBUyxHQUFHLE1BQU0sUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQzdDO1FBQ0UsSUFBSSxFQUFFLFVBQVU7S0FDakIsRUFDRCxHQUFHLEVBQ0gsU0FBUyxDQUNWLENBQUM7SUFDRixPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsVUFBVSxDQUFDLE9BQWU7SUFDakMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztJQUN0RSxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDdEMsT0FBTyxJQUFBLGNBQU0sRUFBQyxlQUFlLENBQUMsQ0FBQztBQUNqQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgYWIyc3RyLCBzdHIyYWIgfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBJbXBvcnQgYSBwdWJsaWMgUlNBIGtleSBhbmQgZW5jcnlwdCBhIHBsYWludGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0tleSBQRU0tZm9ybWF0dGVkIHB1YmxpYyBSU0Ega2V5XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBlbmNyeXB0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jcnlwdGVkIHRleHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIF9lbmNyeXB0QnJvd3NlclJzYShwdWJsaWNLZXk6IHN0cmluZywgdGV4dDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgcHViID0gYXdhaXQgaW1wb3J0UHVibGljS2V5KHB1YmxpY0tleSk7XG4gIGNvbnN0IGVuY3J5cHRlZCA9IGF3YWl0IGVuY3J5cHRSU0EocHViLCBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dCkpO1xuICByZXR1cm4gYnRvYShhYjJzdHIoZW5jcnlwdGVkKSk7XG59XG5cbi8qKlxuICogSW1wb3J0IGEgcHVibGljIFJTQSBrZXkgZnJvbSBhIFBFTSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcGtpUGVtXG4gKiBAcmV0dXJucyB7Q3J5cHRvS2V5fVxuICovXG5hc3luYyBmdW5jdGlvbiBpbXBvcnRQdWJsaWNLZXkoc3BraVBlbTogc3RyaW5nKSB7XG4gIC8vIFB1bGwgZnJvbSB3aW5kb3cuY3J5cHRvIHdoZW4gcnVubmluZyBpbiB0aGUgYnJvd3Nlci5cbiAgLy8gVGhpcyBpcyBkdWUgdG8gbGlicmFyaWVzIGxpa2UgY3J5cHRvLWJyb3dzZXJpZnkgb3ZlcnJpZGluZyBcImNyeXB0b1wiIHdoaWxlIG5vdCBzdXBwb3J0aW5nIHZhcmlvdXMgY3J5cHRvIGZ1bmN0aW9ucy5cbiAgbGV0IGNyeXB0b0pTOiBhbnkgPSBjcnlwdG87XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNyeXB0b0pTID0gd2luZG93LmNyeXB0bztcbiAgfVxuXG4gIHJldHVybiBhd2FpdCBjcnlwdG9KUy5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICdzcGtpJyxcbiAgICBnZXRTcGtpRGVyKHNwa2lQZW0pLFxuICAgIHtcbiAgICAgIG5hbWU6ICdSU0EtT0FFUCcsXG4gICAgICBoYXNoOiAnU0hBLTI1NicsXG4gICAgfSxcbiAgICB0cnVlLFxuICAgIFsnZW5jcnlwdCddXG4gICk7XG59XG5cbi8qKlxuICogRW5jcnlwdCBhIHBsYWludGV4dCB1c2luZyBSU0EtT0FFUFxuICogQHBhcmFtIHtDcnlwdG9LZXl9IGtleSBUaGUgcHVibGljIGtleSB0byB1c2UgZm9yIGVuY3J5cHRpb25cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IHBsYWludGV4dCBUaGUgcGxhaW50ZXh0IHRvIGVuY3J5cHRcbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gVGhlIGVuY3J5cHRlZCB0ZXh0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRSU0Eoa2V5OiBDcnlwdG9LZXksIHBsYWludGV4dDogQXJyYXlCdWZmZXIpIHtcbiAgLy8gUHVsbCBmcm9tIHdpbmRvdy5jcnlwdG8gd2hlbiBydW5uaW5nIGluIHRoZSBicm93c2VyLlxuICAvLyBUaGlzIGlzIGR1ZSB0byBsaWJyYXJpZXMgbGlrZSBjcnlwdG8tYnJvd3NlcmlmeSBvdmVycmlkaW5nIFwiY3J5cHRvXCIgd2hpbGUgbm90IHN1cHBvcnRpbmcgdmFyaW91cyBjcnlwdG8gZnVuY3Rpb25zLlxuICBsZXQgY3J5cHRvSlM6IGFueSA9IGNyeXB0bztcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY3J5cHRvSlMgPSB3aW5kb3cuY3J5cHRvO1xuICB9XG5cbiAgY29uc3QgZW5jcnlwdGVkID0gYXdhaXQgY3J5cHRvSlMuc3VidGxlLmVuY3J5cHQoXG4gICAge1xuICAgICAgbmFtZTogJ1JTQS1PQUVQJyxcbiAgICB9LFxuICAgIGtleSxcbiAgICBwbGFpbnRleHRcbiAgKTtcbiAgcmV0dXJuIGVuY3J5cHRlZDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgUEVNLWZvcm1hdHRlZCBTUEtJIGtleSB0byBhIERFUi1mb3JtYXR0ZWQgQXJyYXlCdWZmZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcGtpUGVtIFBFTS1mb3JtYXR0ZWQgU1BLSSBrZXlcbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gREVSLWZvcm1hdHRlZCBwdWJsaWMga2V5XG4gKi9cbmZ1bmN0aW9uIGdldFNwa2lEZXIoc3BraVBlbTogc3RyaW5nKSB7XG4gIHNwa2lQZW0gPSBzcGtpUGVtLnJlcGxhY2UoLy0tLS0tW14tXSstLS0tLS9nLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gIGNvbnN0IGJpbmFyeURlclN0cmluZyA9IGF0b2Ioc3BraVBlbSk7XG4gIHJldHVybiBzdHIyYWIoYmluYXJ5RGVyU3RyaW5nKTtcbn1cbiJdfQ==