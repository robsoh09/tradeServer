"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encryptBrowserRsaWithAesGcm = exports.encryptRsaWithAesGcm = void 0;
const crypto_1 = __importDefault(require("crypto"));
const encrypt_aes_gcm_1 = require("./encrypt-aes-gcm");
const encrypt_rsa_1 = require("./encrypt-rsa");
const encrypt_rsa_browser_1 = require("./encrypt-rsa-browser");
/**
 * Provided an X.509/ OpenSSL PEM public key, and a string of text to encrypt,
 * This function will
 * 1. Generate a random 256-bit key
 * 2. Encrypt the text using AES-GCM with the generated key
 * 3. Encrypt the generated key using RSA-OAEP with the provided public key
 * 4. Return the encrypted key and the encrypted text in the format `${encryptedKey}\n${encryptedText}`
 *
 * @param {string} publicKey - RSA Public Key
 * @param {string} text - text to encrypt
 * @returns {string} The encrypted text
 *
 * @example
 * const publicKey = '-----BEGIN PUBLIC KEY-----\n.....\n-----END PUBLIC KEY-----';
 * const text = 'This text contains sensitive information';
 * const encrypted = await encryptRsaWithAesGcm(publicKey, text);
 */
async function encryptRsaWithAesGcm(publicKey, text) {
    const gcmKey = crypto_1.default.randomBytes(32).toString('base64');
    const encrypted = await (0, encrypt_aes_gcm_1._encryptAesGcm)(gcmKey, text);
    const encryptedRsa = await (0, encrypt_rsa_1._encryptRsa)(publicKey, Buffer.from(gcmKey).toString('base64'));
    return `${encryptedRsa}\n${encrypted}`;
}
exports.encryptRsaWithAesGcm = encryptRsaWithAesGcm;
/**
 * Provided an X.509/ OpenSSL PEM public key, and a string of text to encrypt,
 * This function will
 * 1. Generate a random 256-bit key
 * 2. Encrypt the text using AES-GCM with the generated key
 * 3. Encrypt the generated key using RSA-OAEP with the provided public key
 * 4. Return the encrypted key and the encrypted text in the format `${encryptedKey}\n${encryptedText}`
 *
 * @param {string} publicKey - RSA Public Key
 * @param {string} text - text to encrypt
 * @returns {string} The encrypted text
 *
 * @example
 * const publicKey = '-----BEGIN PUBLIC KEY-----\n.....\n-----END PUBLIC KEY-----';
 * const text = 'This text contains sensitive information';
 * const encrypted = await encryptBrowserRsaWithAesGcm(publicKey, text);
 */
async function encryptBrowserRsaWithAesGcm(publicKey, text) {
    const gcmKey = crypto_1.default.randomBytes(32).toString('base64');
    const encrypted = await (0, encrypt_aes_gcm_1._encryptAesGcm)(gcmKey, text);
    const encryptedRsa = await (0, encrypt_rsa_browser_1._encryptBrowserRsa)(publicKey, Buffer.from(gcmKey).toString('base64'));
    return `${encryptedRsa}\n${encrypted}`;
}
exports.encryptBrowserRsaWithAesGcm = encryptBrowserRsaWithAesGcm;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW5jcnlwdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9iaXRnby90cmFkaW5nL25ldHdvcmsvZW5jcnlwdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxvREFBNEI7QUFDNUIsdURBQW1EO0FBQ25ELCtDQUE0QztBQUM1QywrREFBMkQ7QUFFM0Q7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7QUFDSSxLQUFLLFVBQVUsb0JBQW9CLENBQUMsU0FBaUIsRUFBRSxJQUFZO0lBQ3hFLE1BQU0sTUFBTSxHQUFHLGdCQUFNLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUV6RCxNQUFNLFNBQVMsR0FBRyxNQUFNLElBQUEsZ0NBQWMsRUFBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDckQsTUFBTSxZQUFZLEdBQUcsTUFBTSxJQUFBLHlCQUFXLEVBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFFMUYsT0FBTyxHQUFHLFlBQVksS0FBSyxTQUFTLEVBQUUsQ0FBQztBQUN6QyxDQUFDO0FBUEQsb0RBT0M7QUFFRDs7Ozs7Ozs7Ozs7Ozs7OztHQWdCRztBQUNJLEtBQUssVUFBVSwyQkFBMkIsQ0FBQyxTQUFpQixFQUFFLElBQVk7SUFDL0UsTUFBTSxNQUFNLEdBQUcsZ0JBQU0sQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBRXpELE1BQU0sU0FBUyxHQUFHLE1BQU0sSUFBQSxnQ0FBYyxFQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNyRCxNQUFNLFlBQVksR0FBRyxNQUFNLElBQUEsd0NBQWtCLEVBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFFakcsT0FBTyxHQUFHLFlBQVksS0FBSyxTQUFTLEVBQUUsQ0FBQztBQUN6QyxDQUFDO0FBUEQsa0VBT0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBfZW5jcnlwdEFlc0djbSB9IGZyb20gJy4vZW5jcnlwdC1hZXMtZ2NtJztcbmltcG9ydCB7IF9lbmNyeXB0UnNhIH0gZnJvbSAnLi9lbmNyeXB0LXJzYSc7XG5pbXBvcnQgeyBfZW5jcnlwdEJyb3dzZXJSc2EgfSBmcm9tICcuL2VuY3J5cHQtcnNhLWJyb3dzZXInO1xuXG4vKipcbiAqIFByb3ZpZGVkIGFuIFguNTA5LyBPcGVuU1NMIFBFTSBwdWJsaWMga2V5LCBhbmQgYSBzdHJpbmcgb2YgdGV4dCB0byBlbmNyeXB0LFxuICogVGhpcyBmdW5jdGlvbiB3aWxsXG4gKiAxLiBHZW5lcmF0ZSBhIHJhbmRvbSAyNTYtYml0IGtleVxuICogMi4gRW5jcnlwdCB0aGUgdGV4dCB1c2luZyBBRVMtR0NNIHdpdGggdGhlIGdlbmVyYXRlZCBrZXlcbiAqIDMuIEVuY3J5cHQgdGhlIGdlbmVyYXRlZCBrZXkgdXNpbmcgUlNBLU9BRVAgd2l0aCB0aGUgcHJvdmlkZWQgcHVibGljIGtleVxuICogNC4gUmV0dXJuIHRoZSBlbmNyeXB0ZWQga2V5IGFuZCB0aGUgZW5jcnlwdGVkIHRleHQgaW4gdGhlIGZvcm1hdCBgJHtlbmNyeXB0ZWRLZXl9XFxuJHtlbmNyeXB0ZWRUZXh0fWBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljS2V5IC0gUlNBIFB1YmxpYyBLZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBlbmNyeXB0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jcnlwdGVkIHRleHRcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcHVibGljS2V5ID0gJy0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXFxuLi4uLi5cXG4tLS0tLUVORCBQVUJMSUMgS0VZLS0tLS0nO1xuICogY29uc3QgdGV4dCA9ICdUaGlzIHRleHQgY29udGFpbnMgc2Vuc2l0aXZlIGluZm9ybWF0aW9uJztcbiAqIGNvbnN0IGVuY3J5cHRlZCA9IGF3YWl0IGVuY3J5cHRSc2FXaXRoQWVzR2NtKHB1YmxpY0tleSwgdGV4dCk7XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNyeXB0UnNhV2l0aEFlc0djbShwdWJsaWNLZXk6IHN0cmluZywgdGV4dDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgZ2NtS2V5ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDMyKS50b1N0cmluZygnYmFzZTY0Jyk7XG5cbiAgY29uc3QgZW5jcnlwdGVkID0gYXdhaXQgX2VuY3J5cHRBZXNHY20oZ2NtS2V5LCB0ZXh0KTtcbiAgY29uc3QgZW5jcnlwdGVkUnNhID0gYXdhaXQgX2VuY3J5cHRSc2EocHVibGljS2V5LCBCdWZmZXIuZnJvbShnY21LZXkpLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG5cbiAgcmV0dXJuIGAke2VuY3J5cHRlZFJzYX1cXG4ke2VuY3J5cHRlZH1gO1xufVxuXG4vKipcbiAqIFByb3ZpZGVkIGFuIFguNTA5LyBPcGVuU1NMIFBFTSBwdWJsaWMga2V5LCBhbmQgYSBzdHJpbmcgb2YgdGV4dCB0byBlbmNyeXB0LFxuICogVGhpcyBmdW5jdGlvbiB3aWxsXG4gKiAxLiBHZW5lcmF0ZSBhIHJhbmRvbSAyNTYtYml0IGtleVxuICogMi4gRW5jcnlwdCB0aGUgdGV4dCB1c2luZyBBRVMtR0NNIHdpdGggdGhlIGdlbmVyYXRlZCBrZXlcbiAqIDMuIEVuY3J5cHQgdGhlIGdlbmVyYXRlZCBrZXkgdXNpbmcgUlNBLU9BRVAgd2l0aCB0aGUgcHJvdmlkZWQgcHVibGljIGtleVxuICogNC4gUmV0dXJuIHRoZSBlbmNyeXB0ZWQga2V5IGFuZCB0aGUgZW5jcnlwdGVkIHRleHQgaW4gdGhlIGZvcm1hdCBgJHtlbmNyeXB0ZWRLZXl9XFxuJHtlbmNyeXB0ZWRUZXh0fWBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljS2V5IC0gUlNBIFB1YmxpYyBLZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBlbmNyeXB0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jcnlwdGVkIHRleHRcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcHVibGljS2V5ID0gJy0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXFxuLi4uLi5cXG4tLS0tLUVORCBQVUJMSUMgS0VZLS0tLS0nO1xuICogY29uc3QgdGV4dCA9ICdUaGlzIHRleHQgY29udGFpbnMgc2Vuc2l0aXZlIGluZm9ybWF0aW9uJztcbiAqIGNvbnN0IGVuY3J5cHRlZCA9IGF3YWl0IGVuY3J5cHRCcm93c2VyUnNhV2l0aEFlc0djbShwdWJsaWNLZXksIHRleHQpO1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdEJyb3dzZXJSc2FXaXRoQWVzR2NtKHB1YmxpY0tleTogc3RyaW5nLCB0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBnY21LZXkgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMzIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcblxuICBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCBfZW5jcnlwdEFlc0djbShnY21LZXksIHRleHQpO1xuICBjb25zdCBlbmNyeXB0ZWRSc2EgPSBhd2FpdCBfZW5jcnlwdEJyb3dzZXJSc2EocHVibGljS2V5LCBCdWZmZXIuZnJvbShnY21LZXkpLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG5cbiAgcmV0dXJuIGAke2VuY3J5cHRlZFJzYX1cXG4ke2VuY3J5cHRlZH1gO1xufVxuIl19