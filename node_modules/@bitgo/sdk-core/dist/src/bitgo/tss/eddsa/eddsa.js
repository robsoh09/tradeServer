"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyWalletSignature = exports.getTSSSignature = exports.getInitializedMpcInstance = exports.encryptYShare = exports.sendUserToBitgoGShare = exports.getBitgoToUserRShare = exports.offerUserToBitgoRShare = exports.createUserToBitGoGShare = exports.createUserSignShare = exports.createCombinedKey = exports.sendSignatureShare = exports.getTxRequest = void 0;
const assert_1 = __importDefault(require("assert"));
const libsodium_wrappers_sumo_1 = __importDefault(require("libsodium-wrappers-sumo"));
const tss_1 = __importDefault(require("./../../../account-lib/mpc/tss"));
const types_1 = require("../types");
const utils_1 = require("../../utils");
const sdk_lib_mpc_1 = require("@bitgo/sdk-lib-mpc");
const _ = require("lodash");
const common_1 = require("../common");
Object.defineProperty(exports, "getTxRequest", { enumerable: true, get: function () { return common_1.getTxRequest; } });
Object.defineProperty(exports, "sendSignatureShare", { enumerable: true, get: function () { return common_1.sendSignatureShare; } });
/**
 * Combines YShares to combine the final TSS key
 * This can only be used to create the User or Backup key since it requires the common keychain from BitGo first
 *
 * @param params.keyShare - TSS key share
 * @param params.encryptedYShares - encrypted YShares with information on how to decrypt
 * @param params.commonKeychain - expected common keychain of the combined key
 * @returns {CombinedKey} combined TSS key
 */
async function createCombinedKey(params) {
    await tss_1.default.initialize();
    const MPC = new tss_1.default();
    const { keyShare, encryptedYShares, commonKeychain } = params;
    const yShares = [];
    let bitgoYShare;
    let userYShare;
    let backupYShare;
    for (const encryptedYShare of encryptedYShares) {
        const privateShare = await (0, utils_1.readSignedMessage)(encryptedYShare.yShare.encryptedPrivateShare, encryptedYShare.senderPublicArmor, encryptedYShare.recipientPrivateArmor);
        const yShare = {
            i: encryptedYShare.yShare.i,
            j: encryptedYShare.yShare.j,
            y: encryptedYShare.yShare.publicShare.slice(0, 64),
            v: encryptedYShare.yShare.publicShare.slice(64, 128),
            u: privateShare.slice(0, 64),
            chaincode: privateShare.slice(64),
        };
        switch (encryptedYShare.yShare.j) {
            case 1:
                userYShare = yShare;
                break;
            case 2:
                backupYShare = yShare;
                break;
            case 3:
                bitgoYShare = yShare;
                break;
            default:
                throw new Error('Invalid YShare index');
        }
        yShares.push(yShare);
    }
    const combinedKey = MPC.keyCombine(keyShare.uShare, yShares);
    if (combinedKey.pShare.y + combinedKey.pShare.chaincode !== commonKeychain) {
        throw new Error('Common keychains do not match');
    }
    if (!bitgoYShare) {
        throw new Error('Missing BitGo Y Share');
    }
    const signingMaterial = {
        uShare: keyShare.uShare,
        bitgoYShare,
        backupYShare,
        userYShare,
    };
    return {
        signingMaterial,
        commonKeychain,
    };
}
exports.createCombinedKey = createCombinedKey;
/**
 * Creates the User Sign Share containing the User XShare , the User to Bitgo RShare and User to Bitgo commitment
 *
 * @param {Buffer} signablePayload - the signablePayload as a buffer
 * @param {PShare} pShare - User's signing material
 * @returns {Promise<SignShare>} - User Sign Share
 */
async function createUserSignShare(signablePayload, pShare) {
    const MPC = await tss_1.default.initialize();
    if (pShare.i !== types_1.ShareKeyPosition.USER) {
        throw new Error('Invalid PShare, PShare doesnt belong to the User');
    }
    const jShare = { i: types_1.ShareKeyPosition.BITGO, j: types_1.ShareKeyPosition.USER };
    return MPC.signShare(signablePayload, pShare, [jShare]);
}
exports.createUserSignShare = createUserSignShare;
/**
 * Creates the User to Bitgo GShare
 *
 * @param {SignShare} userSignShare - the User Sign Share
 * @param {SignatureShareRecord} bitgoToUserRShare - the Bitgo to User RShare
 * @param {YShare} backupToUserYShare - the backup key Y share received during wallet creation
 * @param {Buffer} signablePayload - the signable payload from a tx
 * @param {CommitmentShareRecord} [bitgoToUserCommitment] - the Bitgo to User Commitment
 * @returns {Promise<GShare>} - the User to Bitgo GShare
 */
async function createUserToBitGoGShare(userSignShare, bitgoToUserRShare, backupToUserYShare, bitgoToUserYShare, signablePayload, bitgoToUserCommitment) {
    if (userSignShare.xShare.i !== types_1.ShareKeyPosition.USER) {
        throw new Error('Invalid XShare, doesnt belong to the User');
    }
    if (bitgoToUserRShare.from !== utils_1.SignatureShareType.BITGO || bitgoToUserRShare.to !== utils_1.SignatureShareType.USER) {
        throw new Error('Invalid RShare, is not from Bitgo to User');
    }
    if (backupToUserYShare.i !== types_1.ShareKeyPosition.USER) {
        throw new Error('Invalid YShare, doesnt belong to the User');
    }
    if (backupToUserYShare.j !== types_1.ShareKeyPosition.BACKUP) {
        throw new Error('Invalid YShare, is not backup key');
    }
    let v, r, R;
    if (bitgoToUserRShare.share.length > 128) {
        v = bitgoToUserRShare.share.substring(0, 64);
        r = bitgoToUserRShare.share.substring(64, 128);
        R = bitgoToUserRShare.share.substring(128, 192);
    }
    else {
        r = bitgoToUserRShare.share.substring(0, 64);
        R = bitgoToUserRShare.share.substring(64, 128);
    }
    const updatedBitgoToUserRShare = {
        i: types_1.ShareKeyPosition.USER,
        j: types_1.ShareKeyPosition.BITGO,
        u: bitgoToUserYShare.u,
        v,
        r,
        R,
    };
    const MPC = await tss_1.default.initialize();
    if (bitgoToUserCommitment) {
        if (bitgoToUserCommitment.from !== utils_1.SignatureShareType.BITGO ||
            bitgoToUserCommitment.to !== utils_1.SignatureShareType.USER) {
            throw new Error('Invalid Commitment, is not from Bitgo to User');
        }
        if (bitgoToUserCommitment.type !== utils_1.CommitmentType.COMMITMENT) {
            throw new Error('Invalid Commitment type, got: ' + bitgoToUserCommitment.type + ' expected: commitment');
        }
        updatedBitgoToUserRShare.commitment = bitgoToUserCommitment.share;
    }
    return MPC.sign(signablePayload, userSignShare.xShare, [updatedBitgoToUserRShare], [backupToUserYShare]);
}
exports.createUserToBitGoGShare = createUserToBitGoGShare;
/**
 * Sends the User to Bitgo RShare to Bitgo
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id
 * @param {String} txRequestId - the txRequest Id
 * @param {SignShare} userSignShare - the user Sign Share
 * @param {String} encryptedSignerShare - signer share encrypted to bitgo key
 * @returns {Promise<void>}
 * @param {IRequestTracer} reqId - the request tracer request id
 */
async function offerUserToBitgoRShare(bitgo, walletId, txRequestId, userSignShare, encryptedSignerShare, apiMode = 'lite', vssProof, privateShareProof, userPublicGpgKey, publicShare, reqId) {
    const rShare = userSignShare.rShares[types_1.ShareKeyPosition.BITGO];
    if (_.isNil(rShare)) {
        throw new Error('userToBitgo RShare not found');
    }
    if (rShare.i !== types_1.ShareKeyPosition.BITGO || rShare.j !== types_1.ShareKeyPosition.USER) {
        throw new Error('Invalid RShare, is not from User to Bitgo');
    }
    const signatureShare = {
        from: utils_1.SignatureShareType.USER,
        to: utils_1.SignatureShareType.BITGO,
        share: rShare.r + rShare.R,
        vssProof,
        privateShareProof,
        publicShare,
    };
    // TODO (BG-57944): implement message signing for EDDSA
    await (0, common_1.sendSignatureShare)(bitgo, walletId, txRequestId, signatureShare, utils_1.RequestType.tx, encryptedSignerShare, 'eddsa', apiMode, userPublicGpgKey, reqId);
}
exports.offerUserToBitgoRShare = offerUserToBitgoRShare;
/**
 * Gets the Bitgo to User RShare from Bitgo
 *
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id
 * @param {String} txRequestId - the txRequest Id
 * @param {IRequestTracer} reqId - the request tracer request id
 * @returns {Promise<SignatureShareRecord>} - a Signature Share
 */
async function getBitgoToUserRShare(bitgo, walletId, txRequestId, reqId) {
    const txRequest = await (0, common_1.getTxRequest)(bitgo, walletId, txRequestId, reqId);
    let signatureShares;
    if (txRequest.apiVersion === 'full') {
        (0, assert_1.default)(txRequest.transactions, 'transactions required as part of txRequest');
        signatureShares = txRequest.transactions[0].signatureShares;
    }
    else {
        signatureShares = txRequest.signatureShares;
    }
    if (_.isNil(signatureShares) || _.isEmpty(signatureShares)) {
        throw new Error(`No signatures shares found for id: ${txRequestId}`);
    }
    // at this point we expect the only share to be the RShare
    const bitgoToUserRShare = signatureShares.find((sigShare) => sigShare.from === utils_1.SignatureShareType.BITGO && sigShare.to === utils_1.SignatureShareType.USER);
    if (_.isNil(bitgoToUserRShare)) {
        throw new Error(`Bitgo to User RShare not found for id: ${txRequestId}`);
    }
    return bitgoToUserRShare;
}
exports.getBitgoToUserRShare = getBitgoToUserRShare;
/**
 * Sends the User to Bitgo GShare to Bitgo
 *
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id
 * @param {String} txRequestId - the txRequest Id
 * @param {GShare} userToBitgoGShare - the User to Bitgo GShare
 * @param {IRequestTracer} reqId - the request tracer request id
 * @returns {Promise<void>}
 */
async function sendUserToBitgoGShare(bitgo, walletId, txRequestId, userToBitgoGShare, apiMode = 'lite', reqId) {
    if (userToBitgoGShare.i !== types_1.ShareKeyPosition.USER) {
        throw new Error('Invalid GShare, doesnt belong to the User');
    }
    const signatureShare = {
        from: utils_1.SignatureShareType.USER,
        to: utils_1.SignatureShareType.BITGO,
        share: userToBitgoGShare.R + userToBitgoGShare.gamma,
    };
    // TODO (BG-57944): implement message signing for EDDSA
    await (0, common_1.sendSignatureShare)(bitgo, walletId, txRequestId, signatureShare, utils_1.RequestType.tx, undefined, 'eddsa', apiMode, undefined, reqId);
}
exports.sendUserToBitgoGShare = sendUserToBitgoGShare;
/**
 * Prepares a YShare to be exchanged with other key holders.
 * Output is in a format that is usable within BitGo's ecosystem.
 *
 * @param params.keyShare - TSS key share of the party preparing exchange materials
 * @param params.recipientIndex - index of the recipient (1, 2, or 3)
 * @param params.recipientGpgPublicArmor - recipient's public gpg key in armor format
 * @param params.senderGpgPrivateArmor - sender's private gpg key in armor format
 * @returns { EncryptedYShare } encrypted Y Share
 */
async function encryptYShare(params) {
    const { keyShare, recipientIndex, recipientGpgPublicArmor, senderGpgPrivateArmor } = params;
    const yShare = keyShare.yShares[recipientIndex];
    if (!yShare) {
        throw new Error('Invalid recipient');
    }
    const publicShare = Buffer.concat([
        Buffer.from(keyShare.uShare.y, 'hex'),
        Buffer.from(yShare.v, 'hex'),
        Buffer.from(keyShare.uShare.chaincode, 'hex'),
    ]).toString('hex');
    const privateShare = Buffer.concat([Buffer.from(yShare.u, 'hex'), Buffer.from(yShare.chaincode, 'hex')]).toString('hex');
    const encryptedPrivateShare = await (0, utils_1.encryptAndSignText)(privateShare, recipientGpgPublicArmor, senderGpgPrivateArmor);
    return {
        i: yShare.i,
        j: yShare.j,
        publicShare,
        encryptedPrivateShare,
    };
}
exports.encryptYShare = encryptYShare;
/**
 *
 * Initializes Eddsa instance
 *
 * @returns {Promise<Eddsa>} the Eddsa instance
 */
async function getInitializedMpcInstance() {
    const hdTree = await sdk_lib_mpc_1.Ed25519Bip32HdTree.initialize();
    return await tss_1.default.initialize(hdTree);
}
exports.getInitializedMpcInstance = getInitializedMpcInstance;
/**
 *
 * Generates a TSS signature using the user and backup key
 *
 * @param {UserSigningMaterial} userSigningMaterial decrypted user TSS key
 * @param {BackupSigningMaterial} backupSigningMaterial decrypted backup TSS key
 * @param {string} path bip32 derivation path
 * @param {BaseTransaction} transaction the transaction to sign
 * @returns {Buffer} the signature
 */
async function getTSSSignature(userSigningMaterial, backupSigningMaterial, path = 'm/0', transaction) {
    const MPC = await getInitializedMpcInstance();
    const userCombine = MPC.keyCombine(userSigningMaterial.uShare, [
        userSigningMaterial.bitgoYShare,
        userSigningMaterial.backupYShare,
    ]);
    const backupCombine = MPC.keyCombine(backupSigningMaterial.uShare, [
        backupSigningMaterial.bitgoYShare,
        backupSigningMaterial.userYShare,
    ]);
    const userSubkey = MPC.keyDerive(userSigningMaterial.uShare, [userSigningMaterial.bitgoYShare, userSigningMaterial.backupYShare], path);
    const backupSubkey = MPC.keyCombine(backupSigningMaterial.uShare, [
        userSubkey.yShares[2],
        backupSigningMaterial.bitgoYShare,
    ]);
    const messageBuffer = transaction.signablePayload;
    const userSignShare = MPC.signShare(messageBuffer, userSubkey.pShare, [userCombine.jShares[2]]);
    const backupSignShare = MPC.signShare(messageBuffer, backupSubkey.pShare, [backupCombine.jShares[1]]);
    const userSign = MPC.sign(messageBuffer, userSignShare.xShare, [backupSignShare.rShares[1]], [userSigningMaterial.bitgoYShare]);
    const backupSign = MPC.sign(messageBuffer, backupSignShare.xShare, [userSignShare.rShares[2]], [backupSigningMaterial.bitgoYShare]);
    const signature = MPC.signCombine([userSign, backupSign]);
    const result = MPC.verify(messageBuffer, signature);
    if (!result) {
        throw new Error('Invalid signature');
    }
    const rawSignature = Buffer.concat([Buffer.from(signature.R, 'hex'), Buffer.from(signature.sigma, 'hex')]);
    return rawSignature;
}
exports.getTSSSignature = getTSSSignature;
/**
 * Verifies that a TSS wallet signature was produced with the expected key and that the signed data contains the
 * expected common keychain, the expected user and backup key ids as well as the public share that is generated from the
 * private share that was passed in.
 */
async function verifyWalletSignature(params) {
    const rawNotations = await (0, common_1.commonVerifyWalletSignature)(params);
    const { decryptedShare, verifierIndex } = params;
    const publicShare = Buffer.from(await libsodium_wrappers_sumo_1.default.crypto_scalarmult_ed25519_base_noclamp(Buffer.from(decryptedShare.slice(0, 64), 'hex'))).toString('hex') + decryptedShare.slice(64);
    const publicShareRawNotationIndex = 2 + verifierIndex;
    (0, assert_1.default)(publicShare === Buffer.from(rawNotations[publicShareRawNotationIndex].value).toString(), 'bitgo share mismatch');
}
exports.verifyWalletSignature = verifyWalletSignature;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWRkc2EuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvYml0Z28vdHNzL2VkZHNhL2VkZHNhLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG9EQUE0QjtBQUU1QixzRkFBNkM7QUFDN0MseUVBQW9IO0FBVXBILG9DQUE0QztBQUM1Qyx1Q0FRcUI7QUFFckIsb0RBQXdEO0FBQ3hELDRCQUE2QjtBQUM3QixzQ0FBMEY7QUFHakYsNkZBSDZCLHFCQUFZLE9BRzdCO0FBQUUsbUdBSDZCLDJCQUFrQixPQUc3QjtBQUV6Qzs7Ozs7Ozs7R0FRRztBQUNJLEtBQUssVUFBVSxpQkFBaUIsQ0FBQyxNQUl2QztJQUNDLE1BQU0sYUFBSyxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQ3pCLE1BQU0sR0FBRyxHQUFHLElBQUksYUFBSyxFQUFFLENBQUM7SUFFeEIsTUFBTSxFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRSxjQUFjLEVBQUUsR0FBRyxNQUFNLENBQUM7SUFDOUQsTUFBTSxPQUFPLEdBQWEsRUFBRSxDQUFDO0lBRTdCLElBQUksV0FBK0IsQ0FBQztJQUNwQyxJQUFJLFVBQThCLENBQUM7SUFDbkMsSUFBSSxZQUFnQyxDQUFDO0lBRXJDLEtBQUssTUFBTSxlQUFlLElBQUksZ0JBQWdCLEVBQUU7UUFDOUMsTUFBTSxZQUFZLEdBQUcsTUFBTSxJQUFBLHlCQUFpQixFQUMxQyxlQUFlLENBQUMsTUFBTSxDQUFDLHFCQUFxQixFQUM1QyxlQUFlLENBQUMsaUJBQWlCLEVBQ2pDLGVBQWUsQ0FBQyxxQkFBcUIsQ0FDdEMsQ0FBQztRQUVGLE1BQU0sTUFBTSxHQUFXO1lBQ3JCLENBQUMsRUFBRSxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDM0IsQ0FBQyxFQUFFLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUMzQixDQUFDLEVBQUUsZUFBZSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENB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LENBQUM7SUFDM0csT0FBTyxZQUFZLENBQUM7QUFDdEIsQ0FBQztBQWxERCwwQ0FrREM7QUFFRDs7OztHQUlHO0FBQ0ksS0FBSyxVQUFVLHFCQUFxQixDQUFDLE1BUTNDO0lBQ0MsTUFBTSxZQUFZLEdBQUcsTUFBTSxJQUFBLG9DQUEyQixFQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRS9ELE1BQU0sRUFBRSxjQUFjLEVBQUUsYUFBYSxFQUFFLEdBQUcsTUFBTSxDQUFDO0lBRWpELE1BQU0sV0FBVyxHQUNmLE1BQU0sQ0FBQyxJQUFJLENBQ1QsTUFBTSxpQ0FBTSxDQUFDLHNDQUFzQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FDckcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUMvQyxNQUFNLDJCQUEyQixHQUFHLENBQUMsR0FBRyxhQUFhLENBQUM7SUFFdEQsSUFBQSxnQkFBTSxFQUNKLFdBQVcsS0FBSyxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQywyQkFBMkIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUN2RixzQkFBc0IsQ0FDdkIsQ0FBQztBQUNKLENBQUM7QUF2QkQsc0RBdUJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IG9wZW5wZ3AgZnJvbSAnb3BlbnBncCc7XG5pbXBvcnQgc29kaXVtIGZyb20gJ2xpYnNvZGl1bS13cmFwcGVycy1zdW1vJztcbmltcG9ydCBFZGRzYSwgeyBHU2hhcmUsIEpTaGFyZSwgS2V5U2hhcmUsIFBTaGFyZSwgUlNoYXJlLCBTaWduU2hhcmUsIFlTaGFyZSB9IGZyb20gJy4vLi4vLi4vLi4vYWNjb3VudC1saWIvbXBjL3Rzcyc7XG5pbXBvcnQgeyBCaXRHb0Jhc2UgfSBmcm9tICcuLi8uLi9iaXRnb0Jhc2UnO1xuaW1wb3J0IHtcbiAgRGVjcnlwdGFibGVZU2hhcmUsXG4gIENvbWJpbmVkS2V5LFxuICBTaWduaW5nTWF0ZXJpYWwsXG4gIEVuY3J5cHRlZFlTaGFyZSxcbiAgVXNlclNpZ25pbmdNYXRlcmlhbCxcbiAgQmFja3VwU2lnbmluZ01hdGVyaWFsLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFNoYXJlS2V5UG9zaXRpb24gfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge1xuICBlbmNyeXB0QW5kU2lnblRleHQsXG4gIHJlYWRTaWduZWRNZXNzYWdlLFxuICBTaWduYXR1cmVTaGFyZVJlY29yZCxcbiAgU2lnbmF0dXJlU2hhcmVUeXBlLFxuICBSZXF1ZXN0VHlwZSxcbiAgQ29tbWl0bWVudFNoYXJlUmVjb3JkLFxuICBDb21taXRtZW50VHlwZSxcbn0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgQmFzZVRyYW5zYWN0aW9uIH0gZnJvbSAnLi4vLi4vLi4vYWNjb3VudC1saWInO1xuaW1wb3J0IHsgRWQyNTUxOUJpcDMySGRUcmVlIH0gZnJvbSAnQGJpdGdvL3Nkay1saWItbXBjJztcbmltcG9ydCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5pbXBvcnQgeyBjb21tb25WZXJpZnlXYWxsZXRTaWduYXR1cmUsIGdldFR4UmVxdWVzdCwgc2VuZFNpZ25hdHVyZVNoYXJlIH0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IElSZXF1ZXN0VHJhY2VyIH0gZnJvbSAnLi4vLi4vLi4vYXBpJztcblxuZXhwb3J0IHsgZ2V0VHhSZXF1ZXN0LCBzZW5kU2lnbmF0dXJlU2hhcmUgfTtcblxuLyoqXG4gKiBDb21iaW5lcyBZU2hhcmVzIHRvIGNvbWJpbmUgdGhlIGZpbmFsIFRTUyBrZXlcbiAqIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCB0byBjcmVhdGUgdGhlIFVzZXIgb3IgQmFja3VwIGtleSBzaW5jZSBpdCByZXF1aXJlcyB0aGUgY29tbW9uIGtleWNoYWluIGZyb20gQml0R28gZmlyc3RcbiAqXG4gKiBAcGFyYW0gcGFyYW1zLmtleVNoYXJlIC0gVFNTIGtleSBzaGFyZVxuICogQHBhcmFtIHBhcmFtcy5lbmNyeXB0ZWRZU2hhcmVzIC0gZW5jcnlwdGVkIFlTaGFyZXMgd2l0aCBpbmZvcm1hdGlvbiBvbiBob3cgdG8gZGVjcnlwdFxuICogQHBhcmFtIHBhcmFtcy5jb21tb25LZXljaGFpbiAtIGV4cGVjdGVkIGNvbW1vbiBrZXljaGFpbiBvZiB0aGUgY29tYmluZWQga2V5XG4gKiBAcmV0dXJucyB7Q29tYmluZWRLZXl9IGNvbWJpbmVkIFRTUyBrZXlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbWJpbmVkS2V5KHBhcmFtczoge1xuICBrZXlTaGFyZTogS2V5U2hhcmU7XG4gIGVuY3J5cHRlZFlTaGFyZXM6IERlY3J5cHRhYmxlWVNoYXJlW107XG4gIGNvbW1vbktleWNoYWluOiBzdHJpbmc7XG59KTogUHJvbWlzZTxDb21iaW5lZEtleT4ge1xuICBhd2FpdCBFZGRzYS5pbml0aWFsaXplKCk7XG4gIGNvbnN0IE1QQyA9IG5ldyBFZGRzYSgpO1xuXG4gIGNvbnN0IHsga2V5U2hhcmUsIGVuY3J5cHRlZFlTaGFyZXMsIGNvbW1vbktleWNoYWluIH0gPSBwYXJhbXM7XG4gIGNvbnN0IHlTaGFyZXM6IFlTaGFyZVtdID0gW107XG5cbiAgbGV0IGJpdGdvWVNoYXJlOiBZU2hhcmUgfCB1bmRlZmluZWQ7XG4gIGxldCB1c2VyWVNoYXJlOiBZU2hhcmUgfCB1bmRlZmluZWQ7XG4gIGxldCBiYWNrdXBZU2hhcmU6IFlTaGFyZSB8IHVuZGVmaW5lZDtcblxuICBmb3IgKGNvbnN0IGVuY3J5cHRlZFlTaGFyZSBvZiBlbmNyeXB0ZWRZU2hhcmVzKSB7XG4gICAgY29uc3QgcHJpdmF0ZVNoYXJlID0gYXdhaXQgcmVhZFNpZ25lZE1lc3NhZ2UoXG4gICAgICBlbmNyeXB0ZWRZU2hhcmUueVNoYXJlLmVuY3J5cHRlZFByaXZhdGVTaGFyZSxcbiAgICAgIGVuY3J5cHRlZFlTaGFyZS5zZW5kZXJQdWJsaWNBcm1vcixcbiAgICAgIGVuY3J5cHRlZFlTaGFyZS5yZWNpcGllbnRQcml2YXRlQXJtb3JcbiAgICApO1xuXG4gICAgY29uc3QgeVNoYXJlOiBZU2hhcmUgPSB7XG4gICAgICBpOiBlbmNyeXB0ZWRZU2hhcmUueVNoYXJlLmksXG4gICAgICBqOiBlbmNyeXB0ZWRZU2hhcmUueVNoYXJlLmosXG4gICAgICB5OiBlbmNyeXB0ZWRZU2hhcmUueVNoYXJlLnB1YmxpY1NoYXJlLnNsaWNlKDAsIDY0KSxcbiAgICAgIHY6IGVuY3J5cHRlZFlTaGFyZS55U2hhcmUucHVibGljU2hhcmUuc2xpY2UoNjQsIDEyOCksXG4gICAgICB1OiBwcml2YXRlU2hhcmUuc2xpY2UoMCwgNjQpLFxuICAgICAgY2hhaW5jb2RlOiBwcml2YXRlU2hhcmUuc2xpY2UoNjQpLFxuICAgIH07XG5cbiAgICBzd2l0Y2ggKGVuY3J5cHRlZFlTaGFyZS55U2hhcmUuaikge1xuICAgICAgY2FzZSAxOlxuICAgICAgICB1c2VyWVNoYXJlID0geVNoYXJlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgYmFja3VwWVNoYXJlID0geVNoYXJlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgYml0Z29ZU2hhcmUgPSB5U2hhcmU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFlTaGFyZSBpbmRleCcpO1xuICAgIH1cblxuICAgIHlTaGFyZXMucHVzaCh5U2hhcmUpO1xuICB9XG5cbiAgY29uc3QgY29tYmluZWRLZXkgPSBNUEMua2V5Q29tYmluZShrZXlTaGFyZS51U2hhcmUsIHlTaGFyZXMpO1xuICBpZiAoY29tYmluZWRLZXkucFNoYXJlLnkgKyBjb21iaW5lZEtleS5wU2hhcmUuY2hhaW5jb2RlICE9PSBjb21tb25LZXljaGFpbikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29tbW9uIGtleWNoYWlucyBkbyBub3QgbWF0Y2gnKTtcbiAgfVxuICBpZiAoIWJpdGdvWVNoYXJlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIEJpdEdvIFkgU2hhcmUnKTtcbiAgfVxuXG4gIGNvbnN0IHNpZ25pbmdNYXRlcmlhbDogU2lnbmluZ01hdGVyaWFsID0ge1xuICAgIHVTaGFyZToga2V5U2hhcmUudVNoYXJlLFxuICAgIGJpdGdvWVNoYXJlLFxuICAgIGJhY2t1cFlTaGFyZSxcbiAgICB1c2VyWVNoYXJlLFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgc2lnbmluZ01hdGVyaWFsLFxuICAgIGNvbW1vbktleWNoYWluLFxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgdGhlIFVzZXIgU2lnbiBTaGFyZSBjb250YWluaW5nIHRoZSBVc2VyIFhTaGFyZSAsIHRoZSBVc2VyIHRvIEJpdGdvIFJTaGFyZSBhbmQgVXNlciB0byBCaXRnbyBjb21taXRtZW50XG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hYmxlUGF5bG9hZCAtIHRoZSBzaWduYWJsZVBheWxvYWQgYXMgYSBidWZmZXJcbiAqIEBwYXJhbSB7UFNoYXJlfSBwU2hhcmUgLSBVc2VyJ3Mgc2lnbmluZyBtYXRlcmlhbFxuICogQHJldHVybnMge1Byb21pc2U8U2lnblNoYXJlPn0gLSBVc2VyIFNpZ24gU2hhcmVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVVzZXJTaWduU2hhcmUoc2lnbmFibGVQYXlsb2FkOiBCdWZmZXIsIHBTaGFyZTogUFNoYXJlKTogUHJvbWlzZTxTaWduU2hhcmU+IHtcbiAgY29uc3QgTVBDID0gYXdhaXQgRWRkc2EuaW5pdGlhbGl6ZSgpO1xuXG4gIGlmIChwU2hhcmUuaSAhPT0gU2hhcmVLZXlQb3NpdGlvbi5VU0VSKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBTaGFyZSwgUFNoYXJlIGRvZXNudCBiZWxvbmcgdG8gdGhlIFVzZXInKTtcbiAgfVxuICBjb25zdCBqU2hhcmU6IEpTaGFyZSA9IHsgaTogU2hhcmVLZXlQb3NpdGlvbi5CSVRHTywgajogU2hhcmVLZXlQb3NpdGlvbi5VU0VSIH07XG4gIHJldHVybiBNUEMuc2lnblNoYXJlKHNpZ25hYmxlUGF5bG9hZCwgcFNoYXJlLCBbalNoYXJlXSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgVXNlciB0byBCaXRnbyBHU2hhcmVcbiAqXG4gKiBAcGFyYW0ge1NpZ25TaGFyZX0gdXNlclNpZ25TaGFyZSAtIHRoZSBVc2VyIFNpZ24gU2hhcmVcbiAqIEBwYXJhbSB7U2lnbmF0dXJlU2hhcmVSZWNvcmR9IGJpdGdvVG9Vc2VyUlNoYXJlIC0gdGhlIEJpdGdvIHRvIFVzZXIgUlNoYXJlXG4gKiBAcGFyYW0ge1lTaGFyZX0gYmFja3VwVG9Vc2VyWVNoYXJlIC0gdGhlIGJhY2t1cCBrZXkgWSBzaGFyZSByZWNlaXZlZCBkdXJpbmcgd2FsbGV0IGNyZWF0aW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmFibGVQYXlsb2FkIC0gdGhlIHNpZ25hYmxlIHBheWxvYWQgZnJvbSBhIHR4XG4gKiBAcGFyYW0ge0NvbW1pdG1lbnRTaGFyZVJlY29yZH0gW2JpdGdvVG9Vc2VyQ29tbWl0bWVudF0gLSB0aGUgQml0Z28gdG8gVXNlciBDb21taXRtZW50XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHU2hhcmU+fSAtIHRoZSBVc2VyIHRvIEJpdGdvIEdTaGFyZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVXNlclRvQml0R29HU2hhcmUoXG4gIHVzZXJTaWduU2hhcmU6IFNpZ25TaGFyZSxcbiAgYml0Z29Ub1VzZXJSU2hhcmU6IFNpZ25hdHVyZVNoYXJlUmVjb3JkLFxuICBiYWNrdXBUb1VzZXJZU2hhcmU6IFlTaGFyZSxcbiAgYml0Z29Ub1VzZXJZU2hhcmU6IFlTaGFyZSxcbiAgc2lnbmFibGVQYXlsb2FkOiBCdWZmZXIsXG4gIGJpdGdvVG9Vc2VyQ29tbWl0bWVudD86IENvbW1pdG1lbnRTaGFyZVJlY29yZFxuKTogUHJvbWlzZTxHU2hhcmU+IHtcbiAgaWYgKHVzZXJTaWduU2hhcmUueFNoYXJlLmkgIT09IFNoYXJlS2V5UG9zaXRpb24uVVNFUikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBYU2hhcmUsIGRvZXNudCBiZWxvbmcgdG8gdGhlIFVzZXInKTtcbiAgfVxuICBpZiAoYml0Z29Ub1VzZXJSU2hhcmUuZnJvbSAhPT0gU2lnbmF0dXJlU2hhcmVUeXBlLkJJVEdPIHx8IGJpdGdvVG9Vc2VyUlNoYXJlLnRvICE9PSBTaWduYXR1cmVTaGFyZVR5cGUuVVNFUikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSU2hhcmUsIGlzIG5vdCBmcm9tIEJpdGdvIHRvIFVzZXInKTtcbiAgfVxuICBpZiAoYmFja3VwVG9Vc2VyWVNoYXJlLmkgIT09IFNoYXJlS2V5UG9zaXRpb24uVVNFUikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBZU2hhcmUsIGRvZXNudCBiZWxvbmcgdG8gdGhlIFVzZXInKTtcbiAgfVxuICBpZiAoYmFja3VwVG9Vc2VyWVNoYXJlLmogIT09IFNoYXJlS2V5UG9zaXRpb24uQkFDS1VQKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFlTaGFyZSwgaXMgbm90IGJhY2t1cCBrZXknKTtcbiAgfVxuXG4gIGxldCB2LCByLCBSO1xuICBpZiAoYml0Z29Ub1VzZXJSU2hhcmUuc2hhcmUubGVuZ3RoID4gMTI4KSB7XG4gICAgdiA9IGJpdGdvVG9Vc2VyUlNoYXJlLnNoYXJlLnN1YnN0cmluZygwLCA2NCk7XG4gICAgciA9IGJpdGdvVG9Vc2VyUlNoYXJlLnNoYXJlLnN1YnN0cmluZyg2NCwgMTI4KTtcbiAgICBSID0gYml0Z29Ub1VzZXJSU2hhcmUuc2hhcmUuc3Vic3RyaW5nKDEyOCwgMTkyKTtcbiAgfSBlbHNlIHtcbiAgICByID0gYml0Z29Ub1VzZXJSU2hhcmUuc2hhcmUuc3Vic3RyaW5nKDAsIDY0KTtcbiAgICBSID0gYml0Z29Ub1VzZXJSU2hhcmUuc2hhcmUuc3Vic3RyaW5nKDY0LCAxMjgpO1xuICB9XG5cbiAgY29uc3QgdXBkYXRlZEJpdGdvVG9Vc2VyUlNoYXJlOiBSU2hhcmUgPSB7XG4gICAgaTogU2hhcmVLZXlQb3NpdGlvbi5VU0VSLFxuICAgIGo6IFNoYXJlS2V5UG9zaXRpb24uQklUR08sXG4gICAgdTogYml0Z29Ub1VzZXJZU2hhcmUudSxcbiAgICB2LFxuICAgIHIsXG4gICAgUixcbiAgfTtcblxuICBjb25zdCBNUEMgPSBhd2FpdCBFZGRzYS5pbml0aWFsaXplKCk7XG5cbiAgaWYgKGJpdGdvVG9Vc2VyQ29tbWl0bWVudCkge1xuICAgIGlmIChcbiAgICAgIGJpdGdvVG9Vc2VyQ29tbWl0bWVudC5mcm9tICE9PSBTaWduYXR1cmVTaGFyZVR5cGUuQklUR08gfHxcbiAgICAgIGJpdGdvVG9Vc2VyQ29tbWl0bWVudC50byAhPT0gU2lnbmF0dXJlU2hhcmVUeXBlLlVTRVJcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBDb21taXRtZW50LCBpcyBub3QgZnJvbSBCaXRnbyB0byBVc2VyJyk7XG4gICAgfVxuICAgIGlmIChiaXRnb1RvVXNlckNvbW1pdG1lbnQudHlwZSAhPT0gQ29tbWl0bWVudFR5cGUuQ09NTUlUTUVOVCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENvbW1pdG1lbnQgdHlwZSwgZ290OiAnICsgYml0Z29Ub1VzZXJDb21taXRtZW50LnR5cGUgKyAnIGV4cGVjdGVkOiBjb21taXRtZW50Jyk7XG4gICAgfVxuICAgIHVwZGF0ZWRCaXRnb1RvVXNlclJTaGFyZS5jb21taXRtZW50ID0gYml0Z29Ub1VzZXJDb21taXRtZW50LnNoYXJlO1xuICB9XG5cbiAgcmV0dXJuIE1QQy5zaWduKHNpZ25hYmxlUGF5bG9hZCwgdXNlclNpZ25TaGFyZS54U2hhcmUsIFt1cGRhdGVkQml0Z29Ub1VzZXJSU2hhcmVdLCBbYmFja3VwVG9Vc2VyWVNoYXJlXSk7XG59XG5cbi8qKlxuICogU2VuZHMgdGhlIFVzZXIgdG8gQml0Z28gUlNoYXJlIHRvIEJpdGdvXG4gKiBAcGFyYW0ge0JpdEdvQmFzZX0gYml0Z28gLSB0aGUgYml0Z28gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSB3YWxsZXRJZCAtIHRoZSB3YWxsZXQgaWRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eFJlcXVlc3RJZCAtIHRoZSB0eFJlcXVlc3QgSWRcbiAqIEBwYXJhbSB7U2lnblNoYXJlfSB1c2VyU2lnblNoYXJlIC0gdGhlIHVzZXIgU2lnbiBTaGFyZVxuICogQHBhcmFtIHtTdHJpbmd9IGVuY3J5cHRlZFNpZ25lclNoYXJlIC0gc2lnbmVyIHNoYXJlIGVuY3J5cHRlZCB0byBiaXRnbyBrZXlcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICogQHBhcmFtIHtJUmVxdWVzdFRyYWNlcn0gcmVxSWQgLSB0aGUgcmVxdWVzdCB0cmFjZXIgcmVxdWVzdCBpZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gb2ZmZXJVc2VyVG9CaXRnb1JTaGFyZShcbiAgYml0Z286IEJpdEdvQmFzZSxcbiAgd2FsbGV0SWQ6IHN0cmluZyxcbiAgdHhSZXF1ZXN0SWQ6IHN0cmluZyxcbiAgdXNlclNpZ25TaGFyZTogU2lnblNoYXJlLFxuICBlbmNyeXB0ZWRTaWduZXJTaGFyZTogc3RyaW5nLFxuICBhcGlNb2RlOiAnZnVsbCcgfCAnbGl0ZScgPSAnbGl0ZScsXG4gIHZzc1Byb29mPzogc3RyaW5nLFxuICBwcml2YXRlU2hhcmVQcm9vZj86IHN0cmluZyxcbiAgdXNlclB1YmxpY0dwZ0tleT86IHN0cmluZyxcbiAgcHVibGljU2hhcmU/OiBzdHJpbmcsXG4gIHJlcUlkPzogSVJlcXVlc3RUcmFjZXJcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCByU2hhcmU6IFJTaGFyZSA9IHVzZXJTaWduU2hhcmUuclNoYXJlc1tTaGFyZUtleVBvc2l0aW9uLkJJVEdPXTtcbiAgaWYgKF8uaXNOaWwoclNoYXJlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlclRvQml0Z28gUlNoYXJlIG5vdCBmb3VuZCcpO1xuICB9XG4gIGlmIChyU2hhcmUuaSAhPT0gU2hhcmVLZXlQb3NpdGlvbi5CSVRHTyB8fCByU2hhcmUuaiAhPT0gU2hhcmVLZXlQb3NpdGlvbi5VU0VSKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFJTaGFyZSwgaXMgbm90IGZyb20gVXNlciB0byBCaXRnbycpO1xuICB9XG4gIGNvbnN0IHNpZ25hdHVyZVNoYXJlOiBTaWduYXR1cmVTaGFyZVJlY29yZCA9IHtcbiAgICBmcm9tOiBTaWduYXR1cmVTaGFyZVR5cGUuVVNFUixcbiAgICB0bzogU2lnbmF0dXJlU2hhcmVUeXBlLkJJVEdPLFxuICAgIHNoYXJlOiByU2hhcmUuciArIHJTaGFyZS5SLFxuICAgIHZzc1Byb29mLFxuICAgIHByaXZhdGVTaGFyZVByb29mLFxuICAgIHB1YmxpY1NoYXJlLFxuICB9O1xuXG4gIC8vIFRPRE8gKEJHLTU3OTQ0KTogaW1wbGVtZW50IG1lc3NhZ2Ugc2lnbmluZyBmb3IgRUREU0FcbiAgYXdhaXQgc2VuZFNpZ25hdHVyZVNoYXJlKFxuICAgIGJpdGdvLFxuICAgIHdhbGxldElkLFxuICAgIHR4UmVxdWVzdElkLFxuICAgIHNpZ25hdHVyZVNoYXJlLFxuICAgIFJlcXVlc3RUeXBlLnR4LFxuICAgIGVuY3J5cHRlZFNpZ25lclNoYXJlLFxuICAgICdlZGRzYScsXG4gICAgYXBpTW9kZSxcbiAgICB1c2VyUHVibGljR3BnS2V5LFxuICAgIHJlcUlkXG4gICk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgQml0Z28gdG8gVXNlciBSU2hhcmUgZnJvbSBCaXRnb1xuICpcbiAqIEBwYXJhbSB7Qml0R29CYXNlfSBiaXRnbyAtIHRoZSBiaXRnbyBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IHdhbGxldElkIC0gdGhlIHdhbGxldCBpZFxuICogQHBhcmFtIHtTdHJpbmd9IHR4UmVxdWVzdElkIC0gdGhlIHR4UmVxdWVzdCBJZFxuICogQHBhcmFtIHtJUmVxdWVzdFRyYWNlcn0gcmVxSWQgLSB0aGUgcmVxdWVzdCB0cmFjZXIgcmVxdWVzdCBpZFxuICogQHJldHVybnMge1Byb21pc2U8U2lnbmF0dXJlU2hhcmVSZWNvcmQ+fSAtIGEgU2lnbmF0dXJlIFNoYXJlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCaXRnb1RvVXNlclJTaGFyZShcbiAgYml0Z286IEJpdEdvQmFzZSxcbiAgd2FsbGV0SWQ6IHN0cmluZyxcbiAgdHhSZXF1ZXN0SWQ6IHN0cmluZyxcbiAgcmVxSWQ/OiBJUmVxdWVzdFRyYWNlclxuKTogUHJvbWlzZTxTaWduYXR1cmVTaGFyZVJlY29yZD4ge1xuICBjb25zdCB0eFJlcXVlc3QgPSBhd2FpdCBnZXRUeFJlcXVlc3QoYml0Z28sIHdhbGxldElkLCB0eFJlcXVlc3RJZCwgcmVxSWQpO1xuICBsZXQgc2lnbmF0dXJlU2hhcmVzO1xuICBpZiAodHhSZXF1ZXN0LmFwaVZlcnNpb24gPT09ICdmdWxsJykge1xuICAgIGFzc2VydCh0eFJlcXVlc3QudHJhbnNhY3Rpb25zLCAndHJhbnNhY3Rpb25zIHJlcXVpcmVkIGFzIHBhcnQgb2YgdHhSZXF1ZXN0Jyk7XG4gICAgc2lnbmF0dXJlU2hhcmVzID0gdHhSZXF1ZXN0LnRyYW5zYWN0aW9uc1swXS5zaWduYXR1cmVTaGFyZXM7XG4gIH0gZWxzZSB7XG4gICAgc2lnbmF0dXJlU2hhcmVzID0gdHhSZXF1ZXN0LnNpZ25hdHVyZVNoYXJlcztcbiAgfVxuICBpZiAoXy5pc05pbChzaWduYXR1cmVTaGFyZXMpIHx8IF8uaXNFbXB0eShzaWduYXR1cmVTaGFyZXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBzaWduYXR1cmVzIHNoYXJlcyBmb3VuZCBmb3IgaWQ6ICR7dHhSZXF1ZXN0SWR9YCk7XG4gIH1cbiAgLy8gYXQgdGhpcyBwb2ludCB3ZSBleHBlY3QgdGhlIG9ubHkgc2hhcmUgdG8gYmUgdGhlIFJTaGFyZVxuICBjb25zdCBiaXRnb1RvVXNlclJTaGFyZSA9IHNpZ25hdHVyZVNoYXJlcy5maW5kKFxuICAgIChzaWdTaGFyZSkgPT4gc2lnU2hhcmUuZnJvbSA9PT0gU2lnbmF0dXJlU2hhcmVUeXBlLkJJVEdPICYmIHNpZ1NoYXJlLnRvID09PSBTaWduYXR1cmVTaGFyZVR5cGUuVVNFUlxuICApO1xuICBpZiAoXy5pc05pbChiaXRnb1RvVXNlclJTaGFyZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEJpdGdvIHRvIFVzZXIgUlNoYXJlIG5vdCBmb3VuZCBmb3IgaWQ6ICR7dHhSZXF1ZXN0SWR9YCk7XG4gIH1cbiAgcmV0dXJuIGJpdGdvVG9Vc2VyUlNoYXJlO1xufVxuXG4vKipcbiAqIFNlbmRzIHRoZSBVc2VyIHRvIEJpdGdvIEdTaGFyZSB0byBCaXRnb1xuICpcbiAqIEBwYXJhbSB7Qml0R29CYXNlfSBiaXRnbyAtIHRoZSBiaXRnbyBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IHdhbGxldElkIC0gdGhlIHdhbGxldCBpZFxuICogQHBhcmFtIHtTdHJpbmd9IHR4UmVxdWVzdElkIC0gdGhlIHR4UmVxdWVzdCBJZFxuICogQHBhcmFtIHtHU2hhcmV9IHVzZXJUb0JpdGdvR1NoYXJlIC0gdGhlIFVzZXIgdG8gQml0Z28gR1NoYXJlXG4gKiBAcGFyYW0ge0lSZXF1ZXN0VHJhY2VyfSByZXFJZCAtIHRoZSByZXF1ZXN0IHRyYWNlciByZXF1ZXN0IGlkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRVc2VyVG9CaXRnb0dTaGFyZShcbiAgYml0Z286IEJpdEdvQmFzZSxcbiAgd2FsbGV0SWQ6IHN0cmluZyxcbiAgdHhSZXF1ZXN0SWQ6IHN0cmluZyxcbiAgdXNlclRvQml0Z29HU2hhcmU6IEdTaGFyZSxcbiAgYXBpTW9kZTogJ2Z1bGwnIHwgJ2xpdGUnID0gJ2xpdGUnLFxuICByZXFJZD86IElSZXF1ZXN0VHJhY2VyXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgaWYgKHVzZXJUb0JpdGdvR1NoYXJlLmkgIT09IFNoYXJlS2V5UG9zaXRpb24uVVNFUikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHU2hhcmUsIGRvZXNudCBiZWxvbmcgdG8gdGhlIFVzZXInKTtcbiAgfVxuICBjb25zdCBzaWduYXR1cmVTaGFyZTogU2lnbmF0dXJlU2hhcmVSZWNvcmQgPSB7XG4gICAgZnJvbTogU2lnbmF0dXJlU2hhcmVUeXBlLlVTRVIsXG4gICAgdG86IFNpZ25hdHVyZVNoYXJlVHlwZS5CSVRHTyxcbiAgICBzaGFyZTogdXNlclRvQml0Z29HU2hhcmUuUiArIHVzZXJUb0JpdGdvR1NoYXJlLmdhbW1hLFxuICB9O1xuXG4gIC8vIFRPRE8gKEJHLTU3OTQ0KTogaW1wbGVtZW50IG1lc3NhZ2Ugc2lnbmluZyBmb3IgRUREU0FcbiAgYXdhaXQgc2VuZFNpZ25hdHVyZVNoYXJlKFxuICAgIGJpdGdvLFxuICAgIHdhbGxldElkLFxuICAgIHR4UmVxdWVzdElkLFxuICAgIHNpZ25hdHVyZVNoYXJlLFxuICAgIFJlcXVlc3RUeXBlLnR4LFxuICAgIHVuZGVmaW5lZCxcbiAgICAnZWRkc2EnLFxuICAgIGFwaU1vZGUsXG4gICAgdW5kZWZpbmVkLFxuICAgIHJlcUlkXG4gICk7XG59XG5cbi8qKlxuICogUHJlcGFyZXMgYSBZU2hhcmUgdG8gYmUgZXhjaGFuZ2VkIHdpdGggb3RoZXIga2V5IGhvbGRlcnMuXG4gKiBPdXRwdXQgaXMgaW4gYSBmb3JtYXQgdGhhdCBpcyB1c2FibGUgd2l0aGluIEJpdEdvJ3MgZWNvc3lzdGVtLlxuICpcbiAqIEBwYXJhbSBwYXJhbXMua2V5U2hhcmUgLSBUU1Mga2V5IHNoYXJlIG9mIHRoZSBwYXJ0eSBwcmVwYXJpbmcgZXhjaGFuZ2UgbWF0ZXJpYWxzXG4gKiBAcGFyYW0gcGFyYW1zLnJlY2lwaWVudEluZGV4IC0gaW5kZXggb2YgdGhlIHJlY2lwaWVudCAoMSwgMiwgb3IgMylcbiAqIEBwYXJhbSBwYXJhbXMucmVjaXBpZW50R3BnUHVibGljQXJtb3IgLSByZWNpcGllbnQncyBwdWJsaWMgZ3BnIGtleSBpbiBhcm1vciBmb3JtYXRcbiAqIEBwYXJhbSBwYXJhbXMuc2VuZGVyR3BnUHJpdmF0ZUFybW9yIC0gc2VuZGVyJ3MgcHJpdmF0ZSBncGcga2V5IGluIGFybW9yIGZvcm1hdFxuICogQHJldHVybnMgeyBFbmNyeXB0ZWRZU2hhcmUgfSBlbmNyeXB0ZWQgWSBTaGFyZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdFlTaGFyZShwYXJhbXM6IHtcbiAga2V5U2hhcmU6IEtleVNoYXJlO1xuICByZWNpcGllbnRJbmRleDogbnVtYmVyO1xuICByZWNpcGllbnRHcGdQdWJsaWNBcm1vcjogc3RyaW5nO1xuICBzZW5kZXJHcGdQcml2YXRlQXJtb3I6IHN0cmluZztcbn0pOiBQcm9taXNlPEVuY3J5cHRlZFlTaGFyZT4ge1xuICBjb25zdCB7IGtleVNoYXJlLCByZWNpcGllbnRJbmRleCwgcmVjaXBpZW50R3BnUHVibGljQXJtb3IsIHNlbmRlckdwZ1ByaXZhdGVBcm1vciB9ID0gcGFyYW1zO1xuXG4gIGNvbnN0IHlTaGFyZSA9IGtleVNoYXJlLnlTaGFyZXNbcmVjaXBpZW50SW5kZXhdO1xuICBpZiAoIXlTaGFyZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWNpcGllbnQnKTtcbiAgfVxuXG4gIGNvbnN0IHB1YmxpY1NoYXJlID0gQnVmZmVyLmNvbmNhdChbXG4gICAgQnVmZmVyLmZyb20oa2V5U2hhcmUudVNoYXJlLnksICdoZXgnKSxcbiAgICBCdWZmZXIuZnJvbSh5U2hhcmUudiEsICdoZXgnKSxcbiAgICBCdWZmZXIuZnJvbShrZXlTaGFyZS51U2hhcmUuY2hhaW5jb2RlLCAnaGV4JyksXG4gIF0pLnRvU3RyaW5nKCdoZXgnKTtcblxuICBjb25zdCBwcml2YXRlU2hhcmUgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbSh5U2hhcmUudSwgJ2hleCcpLCBCdWZmZXIuZnJvbSh5U2hhcmUuY2hhaW5jb2RlLCAnaGV4JyldKS50b1N0cmluZyhcbiAgICAnaGV4J1xuICApO1xuXG4gIGNvbnN0IGVuY3J5cHRlZFByaXZhdGVTaGFyZSA9IGF3YWl0IGVuY3J5cHRBbmRTaWduVGV4dChwcml2YXRlU2hhcmUsIHJlY2lwaWVudEdwZ1B1YmxpY0FybW9yLCBzZW5kZXJHcGdQcml2YXRlQXJtb3IpO1xuXG4gIHJldHVybiB7XG4gICAgaTogeVNoYXJlLmksXG4gICAgajogeVNoYXJlLmosXG4gICAgcHVibGljU2hhcmUsXG4gICAgZW5jcnlwdGVkUHJpdmF0ZVNoYXJlLFxuICB9O1xufVxuXG4vKipcbiAqXG4gKiBJbml0aWFsaXplcyBFZGRzYSBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPEVkZHNhPn0gdGhlIEVkZHNhIGluc3RhbmNlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRJbml0aWFsaXplZE1wY0luc3RhbmNlKCkge1xuICBjb25zdCBoZFRyZWUgPSBhd2FpdCBFZDI1NTE5QmlwMzJIZFRyZWUuaW5pdGlhbGl6ZSgpO1xuICByZXR1cm4gYXdhaXQgRWRkc2EuaW5pdGlhbGl6ZShoZFRyZWUpO1xufVxuXG4vKipcbiAqXG4gKiBHZW5lcmF0ZXMgYSBUU1Mgc2lnbmF0dXJlIHVzaW5nIHRoZSB1c2VyIGFuZCBiYWNrdXAga2V5XG4gKlxuICogQHBhcmFtIHtVc2VyU2lnbmluZ01hdGVyaWFsfSB1c2VyU2lnbmluZ01hdGVyaWFsIGRlY3J5cHRlZCB1c2VyIFRTUyBrZXlcbiAqIEBwYXJhbSB7QmFja3VwU2lnbmluZ01hdGVyaWFsfSBiYWNrdXBTaWduaW5nTWF0ZXJpYWwgZGVjcnlwdGVkIGJhY2t1cCBUU1Mga2V5XG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBiaXAzMiBkZXJpdmF0aW9uIHBhdGhcbiAqIEBwYXJhbSB7QmFzZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiB0aGUgdHJhbnNhY3Rpb24gdG8gc2lnblxuICogQHJldHVybnMge0J1ZmZlcn0gdGhlIHNpZ25hdHVyZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VFNTU2lnbmF0dXJlKFxuICB1c2VyU2lnbmluZ01hdGVyaWFsOiBVc2VyU2lnbmluZ01hdGVyaWFsLFxuICBiYWNrdXBTaWduaW5nTWF0ZXJpYWw6IEJhY2t1cFNpZ25pbmdNYXRlcmlhbCxcbiAgcGF0aCA9ICdtLzAnLFxuICB0cmFuc2FjdGlvbjogQmFzZVRyYW5zYWN0aW9uXG4pOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICBjb25zdCBNUEMgPSBhd2FpdCBnZXRJbml0aWFsaXplZE1wY0luc3RhbmNlKCk7XG5cbiAgY29uc3QgdXNlckNvbWJpbmUgPSBNUEMua2V5Q29tYmluZSh1c2VyU2lnbmluZ01hdGVyaWFsLnVTaGFyZSwgW1xuICAgIHVzZXJTaWduaW5nTWF0ZXJpYWwuYml0Z29ZU2hhcmUsXG4gICAgdXNlclNpZ25pbmdNYXRlcmlhbC5iYWNrdXBZU2hhcmUsXG4gIF0pO1xuICBjb25zdCBiYWNrdXBDb21iaW5lID0gTVBDLmtleUNvbWJpbmUoYmFja3VwU2lnbmluZ01hdGVyaWFsLnVTaGFyZSwgW1xuICAgIGJhY2t1cFNpZ25pbmdNYXRlcmlhbC5iaXRnb1lTaGFyZSxcbiAgICBiYWNrdXBTaWduaW5nTWF0ZXJpYWwudXNlcllTaGFyZSxcbiAgXSk7XG5cbiAgY29uc3QgdXNlclN1YmtleSA9IE1QQy5rZXlEZXJpdmUoXG4gICAgdXNlclNpZ25pbmdNYXRlcmlhbC51U2hhcmUsXG4gICAgW3VzZXJTaWduaW5nTWF0ZXJpYWwuYml0Z29ZU2hhcmUsIHVzZXJTaWduaW5nTWF0ZXJpYWwuYmFja3VwWVNoYXJlXSxcbiAgICBwYXRoXG4gICk7XG5cbiAgY29uc3QgYmFja3VwU3Via2V5ID0gTVBDLmtleUNvbWJpbmUoYmFja3VwU2lnbmluZ01hdGVyaWFsLnVTaGFyZSwgW1xuICAgIHVzZXJTdWJrZXkueVNoYXJlc1syXSxcbiAgICBiYWNrdXBTaWduaW5nTWF0ZXJpYWwuYml0Z29ZU2hhcmUsXG4gIF0pO1xuXG4gIGNvbnN0IG1lc3NhZ2VCdWZmZXIgPSB0cmFuc2FjdGlvbi5zaWduYWJsZVBheWxvYWQ7XG4gIGNvbnN0IHVzZXJTaWduU2hhcmUgPSBNUEMuc2lnblNoYXJlKG1lc3NhZ2VCdWZmZXIsIHVzZXJTdWJrZXkucFNoYXJlLCBbdXNlckNvbWJpbmUualNoYXJlc1syXV0pO1xuICBjb25zdCBiYWNrdXBTaWduU2hhcmUgPSBNUEMuc2lnblNoYXJlKG1lc3NhZ2VCdWZmZXIsIGJhY2t1cFN1YmtleS5wU2hhcmUsIFtiYWNrdXBDb21iaW5lLmpTaGFyZXNbMV1dKTtcbiAgY29uc3QgdXNlclNpZ24gPSBNUEMuc2lnbihcbiAgICBtZXNzYWdlQnVmZmVyLFxuICAgIHVzZXJTaWduU2hhcmUueFNoYXJlLFxuICAgIFtiYWNrdXBTaWduU2hhcmUuclNoYXJlc1sxXV0sXG4gICAgW3VzZXJTaWduaW5nTWF0ZXJpYWwuYml0Z29ZU2hhcmVdXG4gICk7XG4gIGNvbnN0IGJhY2t1cFNpZ24gPSBNUEMuc2lnbihcbiAgICBtZXNzYWdlQnVmZmVyLFxuICAgIGJhY2t1cFNpZ25TaGFyZS54U2hhcmUsXG4gICAgW3VzZXJTaWduU2hhcmUuclNoYXJlc1syXV0sXG4gICAgW2JhY2t1cFNpZ25pbmdNYXRlcmlhbC5iaXRnb1lTaGFyZV1cbiAgKTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gTVBDLnNpZ25Db21iaW5lKFt1c2VyU2lnbiwgYmFja3VwU2lnbl0pO1xuICBjb25zdCByZXN1bHQgPSBNUEMudmVyaWZ5KG1lc3NhZ2VCdWZmZXIsIHNpZ25hdHVyZSk7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZScpO1xuICB9XG4gIGNvbnN0IHJhd1NpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKHNpZ25hdHVyZS5SLCAnaGV4JyksIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZS5zaWdtYSwgJ2hleCcpXSk7XG4gIHJldHVybiByYXdTaWduYXR1cmU7XG59XG5cbi8qKlxuICogVmVyaWZpZXMgdGhhdCBhIFRTUyB3YWxsZXQgc2lnbmF0dXJlIHdhcyBwcm9kdWNlZCB3aXRoIHRoZSBleHBlY3RlZCBrZXkgYW5kIHRoYXQgdGhlIHNpZ25lZCBkYXRhIGNvbnRhaW5zIHRoZVxuICogZXhwZWN0ZWQgY29tbW9uIGtleWNoYWluLCB0aGUgZXhwZWN0ZWQgdXNlciBhbmQgYmFja3VwIGtleSBpZHMgYXMgd2VsbCBhcyB0aGUgcHVibGljIHNoYXJlIHRoYXQgaXMgZ2VuZXJhdGVkIGZyb20gdGhlXG4gKiBwcml2YXRlIHNoYXJlIHRoYXQgd2FzIHBhc3NlZCBpbi5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeVdhbGxldFNpZ25hdHVyZShwYXJhbXM6IHtcbiAgd2FsbGV0U2lnbmF0dXJlOiBvcGVucGdwLktleTtcbiAgYml0Z29QdWI6IG9wZW5wZ3AuS2V5O1xuICBjb21tb25LZXljaGFpbjogc3RyaW5nO1xuICB1c2VyS2V5SWQ6IHN0cmluZztcbiAgYmFja3VwS2V5SWQ6IHN0cmluZztcbiAgZGVjcnlwdGVkU2hhcmU6IHN0cmluZztcbiAgdmVyaWZpZXJJbmRleDogMSB8IDI7IC8vIHRoZSBpbmRleCBvZiB0aGUgdmVyaWZpZXIsIDEgbWVhbnMgdXNlciwgMiBtZWFucyBiYWNrdXBcbn0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgcmF3Tm90YXRpb25zID0gYXdhaXQgY29tbW9uVmVyaWZ5V2FsbGV0U2lnbmF0dXJlKHBhcmFtcyk7XG5cbiAgY29uc3QgeyBkZWNyeXB0ZWRTaGFyZSwgdmVyaWZpZXJJbmRleCB9ID0gcGFyYW1zO1xuXG4gIGNvbnN0IHB1YmxpY1NoYXJlID1cbiAgICBCdWZmZXIuZnJvbShcbiAgICAgIGF3YWl0IHNvZGl1bS5jcnlwdG9fc2NhbGFybXVsdF9lZDI1NTE5X2Jhc2Vfbm9jbGFtcChCdWZmZXIuZnJvbShkZWNyeXB0ZWRTaGFyZS5zbGljZSgwLCA2NCksICdoZXgnKSlcbiAgICApLnRvU3RyaW5nKCdoZXgnKSArIGRlY3J5cHRlZFNoYXJlLnNsaWNlKDY0KTtcbiAgY29uc3QgcHVibGljU2hhcmVSYXdOb3RhdGlvbkluZGV4ID0gMiArIHZlcmlmaWVySW5kZXg7XG5cbiAgYXNzZXJ0KFxuICAgIHB1YmxpY1NoYXJlID09PSBCdWZmZXIuZnJvbShyYXdOb3RhdGlvbnNbcHVibGljU2hhcmVSYXdOb3RhdGlvbkluZGV4XS52YWx1ZSkudG9TdHJpbmcoKSxcbiAgICAnYml0Z28gc2hhcmUgbWlzbWF0Y2gnXG4gICk7XG59XG4iXX0=