/// <reference types="node" />
import openpgp from 'openpgp';
import Eddsa, { GShare, KeyShare, PShare, SignShare, YShare } from './../../../account-lib/mpc/tss';
import { BitGoBase } from '../../bitgoBase';
import { DecryptableYShare, CombinedKey, EncryptedYShare, UserSigningMaterial, BackupSigningMaterial } from './types';
import { SignatureShareRecord, CommitmentShareRecord } from '../../utils';
import { BaseTransaction } from '../../../account-lib';
import { getTxRequest, sendSignatureShare } from '../common';
import { IRequestTracer } from '../../../api';
export { getTxRequest, sendSignatureShare };
/**
 * Combines YShares to combine the final TSS key
 * This can only be used to create the User or Backup key since it requires the common keychain from BitGo first
 *
 * @param params.keyShare - TSS key share
 * @param params.encryptedYShares - encrypted YShares with information on how to decrypt
 * @param params.commonKeychain - expected common keychain of the combined key
 * @returns {CombinedKey} combined TSS key
 */
export declare function createCombinedKey(params: {
    keyShare: KeyShare;
    encryptedYShares: DecryptableYShare[];
    commonKeychain: string;
}): Promise<CombinedKey>;
/**
 * Creates the User Sign Share containing the User XShare , the User to Bitgo RShare and User to Bitgo commitment
 *
 * @param {Buffer} signablePayload - the signablePayload as a buffer
 * @param {PShare} pShare - User's signing material
 * @returns {Promise<SignShare>} - User Sign Share
 */
export declare function createUserSignShare(signablePayload: Buffer, pShare: PShare): Promise<SignShare>;
/**
 * Creates the User to Bitgo GShare
 *
 * @param {SignShare} userSignShare - the User Sign Share
 * @param {SignatureShareRecord} bitgoToUserRShare - the Bitgo to User RShare
 * @param {YShare} backupToUserYShare - the backup key Y share received during wallet creation
 * @param {Buffer} signablePayload - the signable payload from a tx
 * @param {CommitmentShareRecord} [bitgoToUserCommitment] - the Bitgo to User Commitment
 * @returns {Promise<GShare>} - the User to Bitgo GShare
 */
export declare function createUserToBitGoGShare(userSignShare: SignShare, bitgoToUserRShare: SignatureShareRecord, backupToUserYShare: YShare, bitgoToUserYShare: YShare, signablePayload: Buffer, bitgoToUserCommitment?: CommitmentShareRecord): Promise<GShare>;
/**
 * Sends the User to Bitgo RShare to Bitgo
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id
 * @param {String} txRequestId - the txRequest Id
 * @param {SignShare} userSignShare - the user Sign Share
 * @param {String} encryptedSignerShare - signer share encrypted to bitgo key
 * @returns {Promise<void>}
 * @param {IRequestTracer} reqId - the request tracer request id
 */
export declare function offerUserToBitgoRShare(bitgo: BitGoBase, walletId: string, txRequestId: string, userSignShare: SignShare, encryptedSignerShare: string, apiMode?: 'full' | 'lite', vssProof?: string, privateShareProof?: string, userPublicGpgKey?: string, publicShare?: string, reqId?: IRequestTracer): Promise<void>;
/**
 * Gets the Bitgo to User RShare from Bitgo
 *
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id
 * @param {String} txRequestId - the txRequest Id
 * @param {IRequestTracer} reqId - the request tracer request id
 * @returns {Promise<SignatureShareRecord>} - a Signature Share
 */
export declare function getBitgoToUserRShare(bitgo: BitGoBase, walletId: string, txRequestId: string, reqId?: IRequestTracer): Promise<SignatureShareRecord>;
/**
 * Sends the User to Bitgo GShare to Bitgo
 *
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id
 * @param {String} txRequestId - the txRequest Id
 * @param {GShare} userToBitgoGShare - the User to Bitgo GShare
 * @param {IRequestTracer} reqId - the request tracer request id
 * @returns {Promise<void>}
 */
export declare function sendUserToBitgoGShare(bitgo: BitGoBase, walletId: string, txRequestId: string, userToBitgoGShare: GShare, apiMode?: 'full' | 'lite', reqId?: IRequestTracer): Promise<void>;
/**
 * Prepares a YShare to be exchanged with other key holders.
 * Output is in a format that is usable within BitGo's ecosystem.
 *
 * @param params.keyShare - TSS key share of the party preparing exchange materials
 * @param params.recipientIndex - index of the recipient (1, 2, or 3)
 * @param params.recipientGpgPublicArmor - recipient's public gpg key in armor format
 * @param params.senderGpgPrivateArmor - sender's private gpg key in armor format
 * @returns { EncryptedYShare } encrypted Y Share
 */
export declare function encryptYShare(params: {
    keyShare: KeyShare;
    recipientIndex: number;
    recipientGpgPublicArmor: string;
    senderGpgPrivateArmor: string;
}): Promise<EncryptedYShare>;
/**
 *
 * Initializes Eddsa instance
 *
 * @returns {Promise<Eddsa>} the Eddsa instance
 */
export declare function getInitializedMpcInstance(): Promise<Eddsa>;
/**
 *
 * Generates a TSS signature using the user and backup key
 *
 * @param {UserSigningMaterial} userSigningMaterial decrypted user TSS key
 * @param {BackupSigningMaterial} backupSigningMaterial decrypted backup TSS key
 * @param {string} path bip32 derivation path
 * @param {BaseTransaction} transaction the transaction to sign
 * @returns {Buffer} the signature
 */
export declare function getTSSSignature(userSigningMaterial: UserSigningMaterial, backupSigningMaterial: BackupSigningMaterial, path: string | undefined, transaction: BaseTransaction): Promise<Buffer>;
/**
 * Verifies that a TSS wallet signature was produced with the expected key and that the signed data contains the
 * expected common keychain, the expected user and backup key ids as well as the public share that is generated from the
 * private share that was passed in.
 */
export declare function verifyWalletSignature(params: {
    walletSignature: openpgp.Key;
    bitgoPub: openpgp.Key;
    commonKeychain: string;
    userKeyId: string;
    backupKeyId: string;
    decryptedShare: string;
    verifierIndex: 1 | 2;
}): Promise<void>;
//# sourceMappingURL=eddsa.d.ts.map