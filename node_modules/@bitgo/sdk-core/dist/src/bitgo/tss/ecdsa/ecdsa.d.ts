/// <reference types="node" />
/// <reference types="node" />
import { AShare, BShare, CombinedKey, CreateUserOmicronAndDeltaShareRT, DecryptableNShare, DShare, EncryptedNShare, GShare, KeyShare, NShare, OShare, ReceivedShareType, SendShareToBitgoRT, SendShareType, Signature, SignatureShare, SignShare, WShare, XShareWithChallenges, YShareWithChallenges } from './types';
import { RequestType, SignatureShareRecord, SignatureShareType } from '../../utils';
import { ShareKeyPosition } from '../types';
import { BitGoBase } from '../../bitgoBase';
import { KShare, MUShare, SignConvertStep2Response, SShare } from '../../../account-lib/mpc/tss/ecdsa/types';
import * as pgp from 'openpgp';
import { ApiKeyShare } from '../../keychain';
import { Hash } from 'crypto';
import { IRequestTracer } from '../../../api';
/**
 * Combines NShares to combine the final TSS key
 * This can only be used to create the User or Backup key since it requires the common keychain from BitGo first
 *
 * @param keyShare - TSS key share
 * @param encryptedNShares - encrypted NShares with information on how to decrypt
 * @param commonKeychain - expected common keychain of the combined key
 * @returns {CombinedKey} combined TSS key
 */
export declare function createCombinedKey(keyShare: KeyShare, encryptedNShares: DecryptableNShare[], commonKeychain: string): Promise<CombinedKey>;
/**
 * Creates the SignShare with User XShare and YShare Corresponding to BitGo
 * @param {XShare} xShare User secret xShare
 * @param {YShare} yShare YShare from Bitgo
 * @returns {Promise<SignShare>}
 */
export declare function createUserSignShare(xShare: XShareWithChallenges, yShare: YShareWithChallenges): Promise<SignShare>;
/**
 * Creates the Gamma Share and MuShare with User WShare and AShare From BitGo
 * @param {WShare} wShare User WShare
 * @param {AShare} aShare AShare from Bitgo
 * @returns {Promise<SignConvertStep2Response>}
 */
export declare function createUserGammaAndMuShare(wShare: WShare, aShare: AShare): Promise<SignConvertStep2Response>;
/**
 * Creates the Omicron Share and Delta share with user GShare
 * @param {GShare} gShare User GShare
 * @returns {Promise<CreateUserOmicronAndDeltaShareRT>}
 */
export declare function createUserOmicronAndDeltaShare(gShare: GShare): Promise<CreateUserOmicronAndDeltaShareRT>;
/**
 * Creates the Signature Share with User OShare and DShare From BitGo
 * @param {OShare} oShare User OShare
 * @param {DShare} dShare DShare from bitgo
 * @param {Buffer} message message to perform sign
 * @returns {Promise<createUserSignShareRT>}
 */
export declare function createUserSignatureShare(oShare: OShare, dShare: DShare, message: Buffer, hash?: Hash): Promise<SignatureShare>;
export declare type MuDShare = {
    muShare: MUShare;
    dShare: DShare;
    i: ShareKeyPosition;
};
/**
 * Sends Share To Bitgo
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id  *
 * @param {String} txRequestId - the txRequest Id
 * @param requestType - the type of request being submitted (either tx or message for signing)
 * @param shareType
 * @param share
 * @param signerShare
 * @param vssProof - the v value of the share
 * @param privateShareProof - the uSig of the share
 * @param publicShare - the y value of the share
 * @param userPublicGpgKey - the public key of the gpg key used for creating the privateShareProof
 * @param reqId - request tracer request id
 * @returns {Promise<SignatureShareRecord>} - a Signature Share
 */
export declare function sendShareToBitgo(bitgo: BitGoBase, walletId: string, txRequestId: string, requestType: RequestType, shareType: SendShareType, share: SShare | MuDShare | KShare, signerShare?: string, vssProof?: string, privateShareProof?: string, publicShare?: string, userPublicGpgKey?: string, reqId?: IRequestTracer): Promise<SendShareToBitgoRT>;
/**
 * Gets the latest user's share from bitgo needed to continue signing flow
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id  *
 * @param {String} txRequestId - the txRequest Id
 * @param {ReceivedShareType} shareType - the excpected share type
 * @param {IRequestTracer} reqId - request tracer request id
 * @returns {Promise<SendShareToBitgoRT>} - share from bitgo to user
 */
export declare function getBitgoToUserLatestShare(bitgo: BitGoBase, walletId: string, txRequestId: string, shareType: ReceivedShareType, requestType: RequestType, reqId?: IRequestTracer): Promise<SendShareToBitgoRT>;
/**
 * Prepares a NShare to be exchanged with other key holders.
 * Output is in a format that is usable within BitGo's ecosystem.
 *
 * @param keyShare - TSS key share of the party preparing exchange materials
 * @param recipientIndex - index of the recipient (1, 2, or 3)
 * @param recipientGpgPublicArmor - recipient's public gpg key in armor format
 * @param senderGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between user and server
 * @param isbs58Encoded - is bs58 encoded or not
 * @returns encrypted N Share
 */
export declare function encryptNShare(keyShare: KeyShare, recipientIndex: number, recipientGpgPublicArmor: string, senderGpgKey: pgp.SerializedKeyPair<string>, isbs58Encoded?: boolean): Promise<EncryptedNShare>;
/**
 * Prepares a NShare to be exchanged with other key holders.
 * An API key share received from a third party should already be encrypted
 *
 * @param keyShare - TSS key share of the party preparing exchange materials
 * @returns encrypted N Share
 */
export declare function buildNShareFromAPIKeyShare(keyShare: ApiKeyShare): Promise<EncryptedNShare>;
/**
 * Decrypts encrypted n share
 * @param encryptedNShare - decryptable n share with recipient private gpg key armor and sender public gpg key
 * @param isbs58Encoded
 * @returns N share
 */
export declare function decryptNShare(encryptedNShare: DecryptableNShare, isbs58Encoded?: boolean): Promise<NShare>;
/**
 * Gets public key from common keychain
 * @param commonKeyChain - common keychain of ecdsa tss
 * @returns public key
 */
export declare function getPublicKey(commonKeyChain: string): string;
export declare const delimeter = ":";
export declare const secondaryDelimeter = "-";
/**
 * parses K share from signature share record
 * @param share - signature share record
 * @returns K Share
 */
export declare function parseKShare(share: SignatureShareRecord): KShare;
/**
 * convert K share to signature share record
 * @param share - K share
 * @returns signature share record
 */
export declare function convertKShare(share: KShare): SignatureShareRecord;
/**
 * parses A share from signature share record
 * @param share - signature share record
 * @returns A Share
 */
export declare function parseAShare(share: SignatureShareRecord): AShare;
/**
 * convert A share to signature share record
 * @param share - A share
 * @returns signature share record
 */
export declare function convertAShare(share: AShare): SignatureShareRecord;
/**
 * parses Mu share from signature share record
 * @param share - signature share record
 * @returns Mu Share
 */
export declare function parseMuShare(share: SignatureShareRecord): MUShare;
/**
 * convert Mu share to signature share record
 * @param share - Mu share
 * @returns signature share record
 */
export declare function convertMuShare(share: MUShare): SignatureShareRecord;
/**
 * parses D share from signature share record
 * @param share - signature share record
 * @returns D Share
 */
export declare function parseDShare(share: SignatureShareRecord): DShare;
/**
 * convert D share to signature share record
 * @param share - D share
 * @returns signature share record
 */
export declare function convertDShare(share: DShare): SignatureShareRecord;
/**
 * parses S and D share from signature share record
 * @param share - signature share record
 * @returns Object containing S and D Share
 */
export declare function parseSDShare(share: SignatureShareRecord): {
    sShare: SignatureShare;
    dShare: DShare;
};
/**
 * convert S and D share to signature share record
 * @param share - S and D share in a object
 * @returns signature share record
 */
export declare function convertSDShare(share: {
    sShare: SShare;
    dShare: DShare;
}): SignatureShareRecord;
/**
 * parses signature share from signature share record
 * @param share - signature share record
 * @returns Signature Share
 */
export declare function parseSignatureShare(share: SignatureShareRecord): SignatureShare;
/**
 * convets combined signature to signature share record
 * @param signature - combined signature share
 * @param userIndex - user index, either 1 (user) or 2 (backup)
 * @returns signature share record
 */
export declare function convertCombinedSignature(signature: Signature, userIndex: number): SignatureShareRecord;
export declare function parseCombinedSignature(share: SignatureShareRecord): Signature;
/**
 * convert signature share to signature share record
 * @param share - Signature share
 * @param senderIndex
 * @param recipientIndex
 * @returns signature share record
 */
export declare function convertSignatureShare(share: SignatureShare, senderIndex: number, recipientIndex: number): SignatureShareRecord;
/**
 * converts B share to signature share record
 * @param share - B share
 * @returns signature share record
 */
export declare function convertBShare(share: BShare): SignatureShareRecord;
/**
 * parses B share from signature share record
 * @param share B share record
 * @returns B Share
 */
export declare function parseBShare(share: SignatureShareRecord): BShare;
/**
 * converts O share to signature share record
 * @param share O share
 * @returns signature share record
 */
export declare function convertOShare(share: OShare): SignatureShareRecord;
/**
 * parses O share from signature share record
 * @param share O share record
 * @returns O Share
 */
export declare function parseOShare(share: SignatureShareRecord): OShare;
/**
 * gets participant index
 * @param participant - participants (user, backup, or bitgo)
 * @returns index (1, 2, 0r 3)
 */
export declare function getParticipantIndex(participant: 'user' | 'backup' | 'bitgo'): number;
/**
 * gets participant name by index
 * @param index participant index
 * @returns participant name
 */
export declare function getParticipantFromIndex(index: number): SignatureShareType;
/**
 * Helper function to verify u-value wallet signatures for the bitgo-user and bitgo-backup shares.
 * @param params
 */
export declare function verifyWalletSignature(params: {
    walletSignature: pgp.Key;
    bitgoPub: pgp.Key;
    commonKeychain: string;
    userKeyId: string;
    backupKeyId: string;
    decryptedShare: string;
    verifierIndex: 1 | 2;
}): Promise<void>;
//# sourceMappingURL=ecdsa.d.ts.map