import { IBaseCoin } from '../baseCoin';
import { BitGoBase } from '../bitgoBase';
import { ApproveOptions, IPendingApproval, OwnerType, PendingApprovalData, PendingApprovalInfo, State, Type } from '../pendingApproval';
import { IWallet } from '../wallet';
import { IRequestTracer } from '../../api';
export declare class PendingApproval implements IPendingApproval {
    private readonly bitgo;
    private readonly baseCoin;
    private tssUtils?;
    private wallet?;
    private _pendingApproval;
    constructor(bitgo: BitGoBase, baseCoin: IBaseCoin, pendingApprovalData: PendingApprovalData, wallet?: IWallet);
    /**
     * Get the id for this PendingApproval
     */
    id(): string;
    toJSON(): PendingApprovalData;
    /**
     * Get the owner type (wallet or enterprise)
     * Pending approvals can be approved or modified by different scopes (depending on how they were created)
     * If a pending approval is owned by a wallet, then it can be approved by administrators of the wallet
     * If a pending approval is owned by an enterprise, then it can be approved by administrators of the enterprise
     */
    ownerType(): OwnerType;
    /**
     * Get the id of the wallet which is associated with this PendingApproval
     */
    walletId(): string | undefined;
    /**
     * Get the enterprise ID that is associated with this PendingApproval
     */
    enterpriseId(): string | undefined;
    /**
     * Get the state of this PendingApproval
     */
    state(): State;
    /**
     * Get the id of the user that performed the action resulting in this PendingApproval
     */
    creator(): string;
    /**
     * Get the type of the pending approval (what it approves)
     */
    type(): Type;
    /**
     * Get information about this PendingApproval
     */
    info(): PendingApprovalInfo;
    /**
     * Get the number of approvals that are required for this PendingApproval to be approved.
     * Defaults to 1 if approvalsRequired doesn't exist on the object
     */
    approvalsRequired(): number;
    /**
     * Generate a url for this PendingApproval for making requests to the server.
     * @param extra
     */
    url(extra?: string): string;
    /**
     * Refetches this PendingApproval from the server and returns it.
     *
     * Note that this mutates the PendingApproval object in place.
     * @param params
     */
    get(params?: Record<string, never>): Promise<PendingApproval>;
    /**
     * Sets this PendingApproval to an approved state
     */
    approve(params?: ApproveOptions): Promise<any>;
    /**
     * Sets this PendingApproval to a rejected state
     * @param params
     */
    reject(params?: Record<string, never>): Promise<any>;
    /**
     * Alias for PendingApproval.reject()
     *
     * @deprecated
     * @param params
     */
    cancel(params?: Record<string, never>): Promise<any>;
    /**
     * Recreate and sign TSS transaction
     * @param {ApproveOptions} params needed to get txs and use the walletPassphrase to tss sign
     * @param {RequestTracer} reqId id tracer.
     */
    recreateAndSignTSSTransaction(params: ApproveOptions, reqId: IRequestTracer): Promise<{
        txHex: string;
    }>;
    /**
     * Recreate a transaction for a pending approval to respond to updated network conditions
     * @param params
     */
    recreateAndSignTransaction(params?: any): Promise<any>;
    private canRecreateTransaction;
    private preApprove;
    /**
     * Internal helper function to perform any post-approval actions.
     * If type is 'transactionRequestFull', this will sign the txRequestFull if possible
     * @param params
     * @param reqId
     * @private
     */
    private postApprove;
    /**
     * Helper function to ensure that self.wallet is set
     */
    private populateWallet;
}
//# sourceMappingURL=pendingApproval.d.ts.map