"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PendingApproval = void 0;
/**
 * @prettier
 */
const _ = __importStar(require("lodash"));
const utxolib = __importStar(require("@bitgo/utxo-lib"));
const pendingApproval_1 = require("../pendingApproval");
const utils_1 = require("../utils");
const BuildParams_1 = require("../wallet/BuildParams");
const eddsa_1 = __importDefault(require("../utils/tss/eddsa"));
const ecdsa_1 = require("../utils/tss/ecdsa");
class PendingApproval {
    constructor(bitgo, baseCoin, pendingApprovalData, wallet) {
        var _a;
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
        this.wallet = wallet;
        if (this.baseCoin.supportsTss()) {
            if (this.baseCoin.getMPCAlgorithm() === 'ecdsa') {
                if (((_a = this.wallet) === null || _a === void 0 ? void 0 : _a.multisigTypeVersion()) === 'MPCv2') {
                    this.tssUtils = new ecdsa_1.EcdsaMPCv2Utils(this.bitgo, this.baseCoin, wallet);
                }
                else {
                    this.tssUtils = new ecdsa_1.EcdsaUtils(this.bitgo, this.baseCoin, wallet);
                }
            }
            else {
                this.tssUtils = new eddsa_1.default(this.bitgo, this.baseCoin, wallet);
            }
        }
        this._pendingApproval = pendingApprovalData;
    }
    /**
     * Get the id for this PendingApproval
     */
    id() {
        return this._pendingApproval.id;
    }
    toJSON() {
        return this._pendingApproval;
    }
    /**
     * Get the owner type (wallet or enterprise)
     * Pending approvals can be approved or modified by different scopes (depending on how they were created)
     * If a pending approval is owned by a wallet, then it can be approved by administrators of the wallet
     * If a pending approval is owned by an enterprise, then it can be approved by administrators of the enterprise
     */
    ownerType() {
        if (this._pendingApproval.wallet) {
            return pendingApproval_1.OwnerType.WALLET;
        }
        else if (this._pendingApproval.enterprise) {
            return pendingApproval_1.OwnerType.ENTERPRISE;
        }
        else {
            throw new Error('unexpected pending approval owner: neither wallet nor enterprise was present');
        }
    }
    /**
     * Get the id of the wallet which is associated with this PendingApproval
     */
    walletId() {
        return this._pendingApproval.wallet;
    }
    /**
     * Get the enterprise ID that is associated with this PendingApproval
     */
    enterpriseId() {
        return this._pendingApproval.enterprise;
    }
    /**
     * Get the state of this PendingApproval
     */
    state() {
        return this._pendingApproval.state;
    }
    /**
     * Get the id of the user that performed the action resulting in this PendingApproval
     */
    creator() {
        return this._pendingApproval.creator;
    }
    /**
     * Get the type of the pending approval (what it approves)
     */
    type() {
        if (!this._pendingApproval.info) {
            throw new Error('pending approval info is not available');
        }
        return this._pendingApproval.info.type;
    }
    /**
     * Get information about this PendingApproval
     */
    info() {
        return this._pendingApproval.info;
    }
    /**
     * Get the number of approvals that are required for this PendingApproval to be approved.
     * Defaults to 1 if approvalsRequired doesn't exist on the object
     */
    approvalsRequired() {
        return this._pendingApproval.approvalsRequired || 1;
    }
    /**
     * Generate a url for this PendingApproval for making requests to the server.
     * @param extra
     */
    url(extra = '') {
        return this.baseCoin.url('/pendingapprovals/' + this.id() + extra);
    }
    /**
     * Refetches this PendingApproval from the server and returns it.
     *
     * Note that this mutates the PendingApproval object in place.
     * @param params
     */
    async get(params = {}) {
        this._pendingApproval = await this.bitgo.get(this.url()).result();
        return this;
    }
    /**
     * Sets this PendingApproval to an approved state
     */
    async approve(params = {}) {
        params.previewPendingTxs = true;
        params.pendingApprovalId = this.id();
        const canRecreateTransaction = this.canRecreateTransaction(params);
        const reqId = new utils_1.RequestTracer();
        this.bitgo.setRequestTracer(reqId);
        await this.populateWallet();
        try {
            const transaction = await this.preApprove(params, reqId);
            const approvalParams = { state: 'approved', otp: params.otp };
            if (transaction) {
                // if the transaction already has a half signed property, we take that directly
                approvalParams.halfSigned = transaction.halfSigned || transaction;
            }
            const response = await this.bitgo.put(this.url()).send(approvalParams).result();
            // if the response comes with an error, means that the transaction triggered another condition
            if (response.hasOwnProperty('error') && response.hasOwnProperty('pendingApproval')) {
                return response;
            }
            this._pendingApproval = response;
            await this.postApprove(params, reqId);
            return this._pendingApproval;
        }
        catch (e) {
            if (!canRecreateTransaction &&
                (e.message.indexOf('could not find unspent output for input') !== -1 ||
                    e.message.indexOf('transaction conflicts with an existing transaction in the send queue') !== -1)) {
                throw new Error('unspents expired, wallet passphrase or xprv required to recreate transaction');
            }
            throw e;
        }
    }
    /**
     * Sets this PendingApproval to a rejected state
     * @param params
     */
    async reject(params = {}) {
        return await this.bitgo.put(this.url()).send({ state: 'rejected' }).result();
    }
    /**
     * Alias for PendingApproval.reject()
     *
     * @deprecated
     * @param params
     */
    async cancel(params = {}) {
        return await this.reject(params);
    }
    /**
     * Recreate and sign TSS transaction
     * @param {ApproveOptions} params needed to get txs and use the walletPassphrase to tss sign
     * @param {RequestTracer} reqId id tracer.
     */
    async recreateAndSignTSSTransaction(params, reqId) {
        const { walletPassphrase } = params;
        const txRequestId = this._pendingApproval.txRequestId;
        if (!this.wallet) {
            throw new Error('Wallet not found');
        }
        if (!walletPassphrase) {
            throw new Error('walletPassphrase not found');
        }
        if (!txRequestId) {
            throw new Error('txRequestId not found');
        }
        const decryptedPrv = await this.wallet.getPrv({ walletPassphrase });
        const txRequest = await this.tssUtils.recreateTxRequest(txRequestId, decryptedPrv, reqId);
        if (txRequest.apiVersion === 'lite') {
            if (!txRequest.unsignedTxs || txRequest.unsignedTxs.length === 0) {
                throw new Error('Unexpected error, no transactions found in txRequest.');
            }
            return {
                txHex: txRequest.unsignedTxs[0].serializedTxHex,
            };
        }
        else {
            if (!txRequest.transactions || txRequest.transactions.length === 0) {
                throw new Error('Unexpected error, no transactions found in txRequest.');
            }
            return {
                txHex: txRequest.transactions[0].unsignedTx.serializedTxHex,
            };
        }
    }
    /**
     * Recreate a transaction for a pending approval to respond to updated network conditions
     * @param params
     */
    async recreateAndSignTransaction(params = {}) {
        // this method only makes sense with existing transaction requests
        const transactionRequest = this.info().transactionRequest;
        if (_.isUndefined(transactionRequest)) {
            throw new Error('cannot recreate transaction without transaction request');
        }
        if (_.isUndefined(this.wallet)) {
            throw new Error('cannot recreate transaction without wallet');
        }
        const originalPrebuild = transactionRequest.coinSpecific[this.baseCoin.type];
        const recipients = transactionRequest.recipients;
        const prebuildParams = _.extend({}, params, { recipients: recipients }, transactionRequest.buildParams);
        if (!_.isUndefined(originalPrebuild.hopTransaction)) {
            prebuildParams.hop = true;
        }
        if (transactionRequest.buildParams && transactionRequest.buildParams.type === 'consolidate') {
            // consolidate tag is in the build params - this is a consolidation transaction, so
            // it needs to be rebuilt using the special consolidation build route
            prebuildParams.prebuildTx = await this.bitgo
                .post(this.wallet.url(`/consolidateUnspents`))
                .send(BuildParams_1.BuildParams.encode(prebuildParams))
                .result();
            delete prebuildParams.recipients;
        }
        const signedTransaction = await this.wallet.prebuildAndSignTransaction(prebuildParams);
        // compare PAYGo fees
        const originalParsedTransaction = (await this.baseCoin.parseTransaction({
            txParams: prebuildParams,
            wallet: this.wallet,
            txPrebuild: originalPrebuild,
        }));
        const recreatedParsedTransaction = (await this.baseCoin.parseTransaction({
            txParams: prebuildParams,
            wallet: this.wallet,
            txPrebuild: signedTransaction,
        }));
        if (_.isUndefined(recreatedParsedTransaction.implicitExternalSpendAmount)) {
            return signedTransaction;
        }
        if (typeof recreatedParsedTransaction.implicitExternalSpendAmount !== 'bigint' &&
            !_.isFinite(recreatedParsedTransaction.implicitExternalSpendAmount)) {
            throw new Error('implicit external spend amount could not be determined');
        }
        if (!_.isUndefined(originalParsedTransaction.implicitExternalSpendAmount) &&
            recreatedParsedTransaction.implicitExternalSpendAmount > originalParsedTransaction.implicitExternalSpendAmount) {
            throw new Error('recreated transaction is using a higher pay-as-you-go-fee');
        }
        return signedTransaction;
    }
    /*
     * Cold wallets cannot recreate transactions if the only thing provided is the wallet passphrase
     *
     * The transaction can be recreated if either
     * – there is an xprv
     * – there is a walletPassphrase and the wallet is not cold (because if it's cold, the passphrase is of little use)
     *
     * Therefore, if neither of these is true, the transaction cannot be recreated, which is reflected in the if
     * statement below.
     */
    canRecreateTransaction(params) {
        var _a, _b, _c, _d, _e, _f;
        const isColdWallet = !!_.get(this.wallet, '_wallet.isCold');
        const isOFCWallet = this.baseCoin.getFamily() === 'ofc'; // Off-chain transactions don't need to be rebuilt
        if (!params.xprv && !(params.walletPassphrase && !isColdWallet && !isOFCWallet)) {
            return false;
        }
        // If there are no recipients, then the transaction cannot be recreated
        const recipients = ((_c = (_b = (_a = this.info()) === null || _a === void 0 ? void 0 : _a.transactionRequest) === null || _b === void 0 ? void 0 : _b.buildParams) === null || _c === void 0 ? void 0 : _c.recipients) || [];
        const type = (_f = (_e = (_d = this.info()) === null || _d === void 0 ? void 0 : _d.transactionRequest) === null || _e === void 0 ? void 0 : _e.buildParams) === null || _f === void 0 ? void 0 : _f.type;
        // We only want to not recreate transactions with no recipients if it is a UTXO coin.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return !(utxolib.isValidNetwork(this.baseCoin.network) &&
            recipients.length === 0 &&
            type !== 'consolidate');
    }
    /*
     * Internal helper function to get the serialized transaction which is being approved.
     * If this PA is of type 'transactionRequest' this function will try to rebuild and resign the transaction
     * @param {ApproveOptions} params
     * @param {boolean} canRecreateTransaction -
     * @param {RequestTracer} reqId id tracer
     */
    async preApprove(params = {}, reqId) {
        // TransactionRequestLite or Multisig tx's must sign before pending approval is approved
        // Re-signed tx is provided to the pending approval api
        if (this.type() === pendingApproval_1.Type.TRANSACTION_REQUEST) {
            /*
             * If this is a request for approving a transaction, depending on whether this user has a private key to the wallet
             * (some admins may not have the spend permission), the transaction could either be rebroadcast as is, or it could
             * be reconstructed. It is preferable to reconstruct a tx in order to adhere to the latest network conditions
             * such as newer unspents, different fees, or a higher sequence id
             */
            if (params.tx) {
                // the approval tx was reconstructed and explicitly specified - pass it through
                return {
                    txHex: params.tx,
                };
            }
            // this user may not have spending privileges or a passphrase may not have been passed in
            if (!this.canRecreateTransaction(params)) {
                // If this is a TransactionRequest, then the txRequest already has the unsigned transaction
                if (this._pendingApproval.txRequestId) {
                    return undefined;
                }
                // If this is a MultiSig, then we need to fetch the half signed tx to propagate to the approval API
                const transaction = _.get(this.info(), `transactionRequest.coinSpecific.${this.baseCoin.type}`);
                if (!_.isObject(transaction)) {
                    throw new Error('there is neither an original transaction object nor can a new one be recreated');
                }
                return transaction;
            }
            if (this._pendingApproval.txRequestId) {
                return await this.recreateAndSignTSSTransaction(params, reqId);
            }
            return await this.recreateAndSignTransaction(params);
        }
    }
    /**
     * Internal helper function to perform any post-approval actions.
     * If type is 'transactionRequestFull', this will sign the txRequestFull if possible
     * @param params
     * @param reqId
     * @private
     */
    async postApprove(params = {}, reqId) {
        switch (this.type()) {
            case pendingApproval_1.Type.TRANSACTION_REQUEST_FULL:
                // TransactionRequestFull for SMH or SMC wallets can only be signed after pending approval is approved
                if (this._pendingApproval.state === pendingApproval_1.State.APPROVED &&
                    this.canRecreateTransaction(params) &&
                    this.baseCoin.supportsTss()) {
                    await this.recreateAndSignTSSTransaction(params, reqId);
                }
        }
    }
    /**
     * Helper function to ensure that self.wallet is set
     */
    async populateWallet() {
        if (this.wallet) {
            return;
        }
        // TODO(WP-1341): consolidate/simplify this logic
        switch (this.type()) {
            case pendingApproval_1.Type.TRANSACTION_REQUEST:
                const transactionRequest = this.info().transactionRequest;
                if (_.isUndefined(transactionRequest)) {
                    throw new Error('missing required object property transactionRequest');
                }
                const updatedWallet = await this.baseCoin.wallets().get({ id: transactionRequest.sourceWallet });
                if (_.isUndefined(updatedWallet)) {
                    throw new Error('unexpected - unable to get wallet using sourcewallet');
                }
                this.wallet = updatedWallet;
                if (this.wallet.id() !== transactionRequest.sourceWallet) {
                    throw new Error('unexpected source wallet for pending approval');
                }
                break;
            case pendingApproval_1.Type.TRANSACTION_REQUEST_FULL:
                const walletId = this.walletId();
                if (!walletId) {
                    throw new Error('Unexpected error, pendingApproval.wallet is expected to be defined!');
                }
                this.wallet = await this.baseCoin.wallets().get({ id: this.walletId() });
                if (!this.wallet) {
                    throw new Error('unexpected - unable to get wallet using pendingApproval.wallet');
                }
                break;
        }
        return;
    }
}
exports.PendingApproval = PendingApproval;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVuZGluZ0FwcHJvdmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2JpdGdvL3BlbmRpbmdBcHByb3ZhbC9wZW5kaW5nQXBwcm92YWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILDBDQUE0QjtBQUM1Qix5REFBMkM7QUFHM0Msd0RBUTRCO0FBQzVCLG9DQUF5QztBQUV6Qyx1REFBb0Q7QUFHcEQsK0RBQTRDO0FBQzVDLDhDQUFpRTtBQWVqRSxNQUFhLGVBQWU7SUFPMUIsWUFBWSxLQUFnQixFQUFFLFFBQW1CLEVBQUUsbUJBQXdDLEVBQUUsTUFBZ0I7O1FBQzNHLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBRXJCLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsRUFBRTtZQUMvQixJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxFQUFFLEtBQUssT0FBTyxFQUFFO2dCQUMvQyxJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsTUFBTSwwQ0FBRSxtQkFBbUIsRUFBRSxNQUFLLE9BQU8sRUFBRTtvQkFDbEQsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLHVCQUFlLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2lCQUN4RTtxQkFBTTtvQkFDTCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksa0JBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7aUJBQ25FO2FBQ0Y7aUJBQU07Z0JBQ0wsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGVBQVUsQ0FBQyxJQUFJ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YXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgdXR4b2xpYiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0IHsgSUJhc2VDb2luIH0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgQml0R29CYXNlIH0gZnJvbSAnLi4vYml0Z29CYXNlJztcbmltcG9ydCB7XG4gIEFwcHJvdmVPcHRpb25zLFxuICBJUGVuZGluZ0FwcHJvdmFsLFxuICBPd25lclR5cGUsXG4gIFBlbmRpbmdBcHByb3ZhbERhdGEsXG4gIFBlbmRpbmdBcHByb3ZhbEluZm8sXG4gIFN0YXRlLFxuICBUeXBlLFxufSBmcm9tICcuLi9wZW5kaW5nQXBwcm92YWwnO1xuaW1wb3J0IHsgUmVxdWVzdFRyYWNlciB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IElXYWxsZXQgfSBmcm9tICcuLi93YWxsZXQnO1xuaW1wb3J0IHsgQnVpbGRQYXJhbXMgfSBmcm9tICcuLi93YWxsZXQvQnVpbGRQYXJhbXMnO1xuaW1wb3J0IHsgSVJlcXVlc3RUcmFjZXIgfSBmcm9tICcuLi8uLi9hcGknO1xuaW1wb3J0IEJhc2VUc3NVdGlscyBmcm9tICcuLi91dGlscy90c3MvYmFzZVRTU1V0aWxzJztcbmltcG9ydCBFZGRzYVV0aWxzIGZyb20gJy4uL3V0aWxzL3Rzcy9lZGRzYSc7XG5pbXBvcnQgeyBFY2RzYU1QQ3YyVXRpbHMsIEVjZHNhVXRpbHMgfSBmcm9tICcuLi91dGlscy90c3MvZWNkc2EnO1xuaW1wb3J0IHsgS2V5U2hhcmUgYXMgRWNkc2FLZXlTaGFyZSB9IGZyb20gJy4uL3V0aWxzL3Rzcy9lY2RzYS90eXBlcyc7XG5pbXBvcnQgeyBLZXlTaGFyZSBhcyBFZGRzYUtleVNoYXJlIH0gZnJvbSAnLi4vdXRpbHMvdHNzL2VkZHNhL3R5cGVzJztcblxudHlwZSBQcmVBcHByb3ZlUmVzdWx0ID0ge1xuICB0eEhleDogc3RyaW5nO1xuICBoYWxmU2lnbmVkPzogc3RyaW5nO1xufTtcblxudHlwZSBBcHByb3ZlUGVuZGluZ0FwcHJvdmFsUmVxdWVzdEJvZHkgPSB7XG4gIHN0YXRlOiAnYXBwcm92ZWQnO1xuICBvdHA6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgaGFsZlNpZ25lZD86IHN0cmluZyB8IE9taXQ8UHJlQXBwcm92ZVJlc3VsdCwgJ2hhbGZTaWduZWQnPjtcbn07XG5cbmV4cG9ydCBjbGFzcyBQZW5kaW5nQXBwcm92YWwgaW1wbGVtZW50cyBJUGVuZGluZ0FwcHJvdmFsIHtcbiAgcHJpdmF0ZSByZWFkb25seSBiaXRnbzogQml0R29CYXNlO1xuICBwcml2YXRlIHJlYWRvbmx5IGJhc2VDb2luOiBJQmFzZUNvaW47XG4gIHByaXZhdGUgdHNzVXRpbHM/OiBCYXNlVHNzVXRpbHM8RWNkc2FLZXlTaGFyZSB8IEVkZHNhS2V5U2hhcmU+O1xuICBwcml2YXRlIHdhbGxldD86IElXYWxsZXQ7XG4gIHByaXZhdGUgX3BlbmRpbmdBcHByb3ZhbDogUGVuZGluZ0FwcHJvdmFsRGF0YTtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlLCBiYXNlQ29pbjogSUJhc2VDb2luLCBwZW5kaW5nQXBwcm92YWxEYXRhOiBQZW5kaW5nQXBwcm92YWxEYXRhLCB3YWxsZXQ/OiBJV2FsbGV0KSB7XG4gICAgdGhpcy5iaXRnbyA9IGJpdGdvO1xuICAgIHRoaXMuYmFzZUNvaW4gPSBiYXNlQ29pbjtcbiAgICB0aGlzLndhbGxldCA9IHdhbGxldDtcblxuICAgIGlmICh0aGlzLmJhc2VDb2luLnN1cHBvcnRzVHNzKCkpIHtcbiAgICAgIGlmICh0aGlzLmJhc2VDb2luLmdldE1QQ0FsZ29yaXRobSgpID09PSAnZWNkc2EnKSB7XG4gICAgICAgIGlmICh0aGlzLndhbGxldD8ubXVsdGlzaWdUeXBlVmVyc2lvbigpID09PSAnTVBDdjInKSB7XG4gICAgICAgICAgdGhpcy50c3NVdGlscyA9IG5ldyBFY2RzYU1QQ3YyVXRpbHModGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbiwgd2FsbGV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRzc1V0aWxzID0gbmV3IEVjZHNhVXRpbHModGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbiwgd2FsbGV0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50c3NVdGlscyA9IG5ldyBFZGRzYVV0aWxzKHRoaXMuYml0Z28sIHRoaXMuYmFzZUNvaW4sIHdhbGxldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcGVuZGluZ0FwcHJvdmFsID0gcGVuZGluZ0FwcHJvdmFsRGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGlkIGZvciB0aGlzIFBlbmRpbmdBcHByb3ZhbFxuICAgKi9cbiAgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLmlkO1xuICB9XG5cbiAgdG9KU09OKCk6IFBlbmRpbmdBcHByb3ZhbERhdGEge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvd25lciB0eXBlICh3YWxsZXQgb3IgZW50ZXJwcmlzZSlcbiAgICogUGVuZGluZyBhcHByb3ZhbHMgY2FuIGJlIGFwcHJvdmVkIG9yIG1vZGlmaWVkIGJ5IGRpZmZlcmVudCBzY29wZXMgKGRlcGVuZGluZyBvbiBob3cgdGhleSB3ZXJlIGNyZWF0ZWQpXG4gICAqIElmIGEgcGVuZGluZyBhcHByb3ZhbCBpcyBvd25lZCBieSBhIHdhbGxldCwgdGhlbiBpdCBjYW4gYmUgYXBwcm92ZWQgYnkgYWRtaW5pc3RyYXRvcnMgb2YgdGhlIHdhbGxldFxuICAgKiBJZiBhIHBlbmRpbmcgYXBwcm92YWwgaXMgb3duZWQgYnkgYW4gZW50ZXJwcmlzZSwgdGhlbiBpdCBjYW4gYmUgYXBwcm92ZWQgYnkgYWRtaW5pc3RyYXRvcnMgb2YgdGhlIGVudGVycHJpc2VcbiAgICovXG4gIG93bmVyVHlwZSgpOiBPd25lclR5cGUge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nQXBwcm92YWwud2FsbGV0KSB7XG4gICAgICByZXR1cm4gT3duZXJUeXBlLldBTExFVDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BlbmRpbmdBcHByb3ZhbC5lbnRlcnByaXNlKSB7XG4gICAgICByZXR1cm4gT3duZXJUeXBlLkVOVEVSUFJJU0U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBwZW5kaW5nIGFwcHJvdmFsIG93bmVyOiBuZWl0aGVyIHdhbGxldCBub3IgZW50ZXJwcmlzZSB3YXMgcHJlc2VudCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGlkIG9mIHRoZSB3YWxsZXQgd2hpY2ggaXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgUGVuZGluZ0FwcHJvdmFsXG4gICAqL1xuICB3YWxsZXRJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwud2FsbGV0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZW50ZXJwcmlzZSBJRCB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFBlbmRpbmdBcHByb3ZhbFxuICAgKi9cbiAgZW50ZXJwcmlzZUlkKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbC5lbnRlcnByaXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhdGUgb2YgdGhpcyBQZW5kaW5nQXBwcm92YWxcbiAgICovXG4gIHN0YXRlKCk6IFN0YXRlIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLnN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaWQgb2YgdGhlIHVzZXIgdGhhdCBwZXJmb3JtZWQgdGhlIGFjdGlvbiByZXN1bHRpbmcgaW4gdGhpcyBQZW5kaW5nQXBwcm92YWxcbiAgICovXG4gIGNyZWF0b3IoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLmNyZWF0b3I7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0eXBlIG9mIHRoZSBwZW5kaW5nIGFwcHJvdmFsICh3aGF0IGl0IGFwcHJvdmVzKVxuICAgKi9cbiAgdHlwZSgpOiBUeXBlIHtcbiAgICBpZiAoIXRoaXMuX3BlbmRpbmdBcHByb3ZhbC5pbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BlbmRpbmcgYXBwcm92YWwgaW5mbyBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbC5pbmZvLnR5cGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IHRoaXMgUGVuZGluZ0FwcHJvdmFsXG4gICAqL1xuICBpbmZvKCk6IFBlbmRpbmdBcHByb3ZhbEluZm8ge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwuaW5mbztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiBhcHByb3ZhbHMgdGhhdCBhcmUgcmVxdWlyZWQgZm9yIHRoaXMgUGVuZGluZ0FwcHJvdmFsIHRvIGJlIGFwcHJvdmVkLlxuICAgKiBEZWZhdWx0cyB0byAxIGlmIGFwcHJvdmFsc1JlcXVpcmVkIGRvZXNuJ3QgZXhpc3Qgb24gdGhlIG9iamVjdFxuICAgKi9cbiAgYXBwcm92YWxzUmVxdWlyZWQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLmFwcHJvdmFsc1JlcXVpcmVkIHx8IDE7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB1cmwgZm9yIHRoaXMgUGVuZGluZ0FwcHJvdmFsIGZvciBtYWtpbmcgcmVxdWVzdHMgdG8gdGhlIHNlcnZlci5cbiAgICogQHBhcmFtIGV4dHJhXG4gICAqL1xuICB1cmwoZXh0cmEgPSAnJyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZUNvaW4udXJsKCcvcGVuZGluZ2FwcHJvdmFscy8nICsgdGhpcy5pZCgpICsgZXh0cmEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZmV0Y2hlcyB0aGlzIFBlbmRpbmdBcHByb3ZhbCBmcm9tIHRoZSBzZXJ2ZXIgYW5kIHJldHVybnMgaXQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG11dGF0ZXMgdGhlIFBlbmRpbmdBcHByb3ZhbCBvYmplY3QgaW4gcGxhY2UuXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIGdldChwYXJhbXM6IFJlY29yZDxzdHJpbmcsIG5ldmVyPiA9IHt9KTogUHJvbWlzZTxQZW5kaW5nQXBwcm92YWw+IHtcbiAgICB0aGlzLl9wZW5kaW5nQXBwcm92YWwgPSBhd2FpdCB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgpKS5yZXN1bHQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgUGVuZGluZ0FwcHJvdmFsIHRvIGFuIGFwcHJvdmVkIHN0YXRlXG4gICAqL1xuICBhc3luYyBhcHByb3ZlKHBhcmFtczogQXBwcm92ZU9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgcGFyYW1zLnByZXZpZXdQZW5kaW5nVHhzID0gdHJ1ZTtcbiAgICBwYXJhbXMucGVuZGluZ0FwcHJvdmFsSWQgPSB0aGlzLmlkKCk7XG4gICAgY29uc3QgY2FuUmVjcmVhdGVUcmFuc2FjdGlvbiA9IHRoaXMuY2FuUmVjcmVhdGVUcmFuc2FjdGlvbihwYXJhbXMpO1xuICAgIGNvbnN0IHJlcUlkID0gbmV3IFJlcXVlc3RUcmFjZXIoKTtcbiAgICB0aGlzLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuICAgIGF3YWl0IHRoaXMucG9wdWxhdGVXYWxsZXQoKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMucHJlQXBwcm92ZShwYXJhbXMsIHJlcUlkKTtcblxuICAgICAgY29uc3QgYXBwcm92YWxQYXJhbXM6IEFwcHJvdmVQZW5kaW5nQXBwcm92YWxSZXF1ZXN0Qm9keSA9IHsgc3RhdGU6ICdhcHByb3ZlZCcsIG90cDogcGFyYW1zLm90cCB9O1xuICAgICAgaWYgKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIC8vIGlmIHRoZSB0cmFuc2FjdGlvbiBhbHJlYWR5IGhhcyBhIGhhbGYgc2lnbmVkIHByb3BlcnR5LCB3ZSB0YWtlIHRoYXQgZGlyZWN0bHlcbiAgICAgICAgYXBwcm92YWxQYXJhbXMuaGFsZlNpZ25lZCA9IHRyYW5zYWN0aW9uLmhhbGZTaWduZWQgfHwgdHJhbnNhY3Rpb247XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYml0Z28ucHV0KHRoaXMudXJsKCkpLnNlbmQoYXBwcm92YWxQYXJhbXMpLnJlc3VsdCgpO1xuXG4gICAgICAvLyBpZiB0aGUgcmVzcG9uc2UgY29tZXMgd2l0aCBhbiBlcnJvciwgbWVhbnMgdGhhdCB0aGUgdHJhbnNhY3Rpb24gdHJpZ2dlcmVkIGFub3RoZXIgY29uZGl0aW9uXG4gICAgICBpZiAocmVzcG9uc2UuaGFzT3duUHJvcGVydHkoJ2Vycm9yJykgJiYgcmVzcG9uc2UuaGFzT3duUHJvcGVydHkoJ3BlbmRpbmdBcHByb3ZhbCcpKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGVuZGluZ0FwcHJvdmFsID0gcmVzcG9uc2U7XG4gICAgICBhd2FpdCB0aGlzLnBvc3RBcHByb3ZlKHBhcmFtcywgcmVxSWQpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIWNhblJlY3JlYXRlVHJhbnNhY3Rpb24gJiZcbiAgICAgICAgKGUubWVzc2FnZS5pbmRleE9mKCdjb3VsZCBub3QgZmluZCB1bnNwZW50IG91dHB1dCBmb3IgaW5wdXQnKSAhPT0gLTEgfHxcbiAgICAgICAgICBlLm1lc3NhZ2UuaW5kZXhPZigndHJhbnNhY3Rpb24gY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgdHJhbnNhY3Rpb24gaW4gdGhlIHNlbmQgcXVldWUnKSAhPT0gLTEpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNwZW50cyBleHBpcmVkLCB3YWxsZXQgcGFzc3BocmFzZSBvciB4cHJ2IHJlcXVpcmVkIHRvIHJlY3JlYXRlIHRyYW5zYWN0aW9uJyk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgUGVuZGluZ0FwcHJvdmFsIHRvIGEgcmVqZWN0ZWQgc3RhdGVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgcmVqZWN0KHBhcmFtczogUmVjb3JkPHN0cmluZywgbmV2ZXI+ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvLnB1dCh0aGlzLnVybCgpKS5zZW5kKHsgc3RhdGU6ICdyZWplY3RlZCcgfSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogQWxpYXMgZm9yIFBlbmRpbmdBcHByb3ZhbC5yZWplY3QoKVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBjYW5jZWwocGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBuZXZlcj4gPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVqZWN0KHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVjcmVhdGUgYW5kIHNpZ24gVFNTIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7QXBwcm92ZU9wdGlvbnN9IHBhcmFtcyBuZWVkZWQgdG8gZ2V0IHR4cyBhbmQgdXNlIHRoZSB3YWxsZXRQYXNzcGhyYXNlIHRvIHRzcyBzaWduXG4gICAqIEBwYXJhbSB7UmVxdWVzdFRyYWNlcn0gcmVxSWQgaWQgdHJhY2VyLlxuICAgKi9cbiAgYXN5bmMgcmVjcmVhdGVBbmRTaWduVFNTVHJhbnNhY3Rpb24ocGFyYW1zOiBBcHByb3ZlT3B0aW9ucywgcmVxSWQ6IElSZXF1ZXN0VHJhY2VyKTogUHJvbWlzZTx7IHR4SGV4OiBzdHJpbmcgfT4ge1xuICAgIGNvbnN0IHsgd2FsbGV0UGFzc3BocmFzZSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR4UmVxdWVzdElkID0gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLnR4UmVxdWVzdElkO1xuXG4gICAgaWYgKCF0aGlzLndhbGxldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgaWYgKCF3YWxsZXRQYXNzcGhyYXNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhbGxldFBhc3NwaHJhc2Ugbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0eFJlcXVlc3RJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eFJlcXVlc3RJZCBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWNyeXB0ZWRQcnYgPSBhd2FpdCB0aGlzLndhbGxldC5nZXRQcnYoeyB3YWxsZXRQYXNzcGhyYXNlIH0pO1xuICAgIGNvbnN0IHR4UmVxdWVzdCA9IGF3YWl0IHRoaXMudHNzVXRpbHMhLnJlY3JlYXRlVHhSZXF1ZXN0KHR4UmVxdWVzdElkLCBkZWNyeXB0ZWRQcnYsIHJlcUlkKTtcbiAgICBpZiAodHhSZXF1ZXN0LmFwaVZlcnNpb24gPT09ICdsaXRlJykge1xuICAgICAgaWYgKCF0eFJlcXVlc3QudW5zaWduZWRUeHMgfHwgdHhSZXF1ZXN0LnVuc2lnbmVkVHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IsIG5vIHRyYW5zYWN0aW9ucyBmb3VuZCBpbiB0eFJlcXVlc3QuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eEhleDogdHhSZXF1ZXN0LnVuc2lnbmVkVHhzWzBdLnNlcmlhbGl6ZWRUeEhleCxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdHhSZXF1ZXN0LnRyYW5zYWN0aW9ucyB8fCB0eFJlcXVlc3QudHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IsIG5vIHRyYW5zYWN0aW9ucyBmb3VuZCBpbiB0eFJlcXVlc3QuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eEhleDogdHhSZXF1ZXN0LnRyYW5zYWN0aW9uc1swXS51bnNpZ25lZFR4LnNlcmlhbGl6ZWRUeEhleCxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY3JlYXRlIGEgdHJhbnNhY3Rpb24gZm9yIGEgcGVuZGluZyBhcHByb3ZhbCB0byByZXNwb25kIHRvIHVwZGF0ZWQgbmV0d29yayBjb25kaXRpb25zXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIHJlY3JlYXRlQW5kU2lnblRyYW5zYWN0aW9uKHBhcmFtczogYW55ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIC8vIHRoaXMgbWV0aG9kIG9ubHkgbWFrZXMgc2Vuc2Ugd2l0aCBleGlzdGluZyB0cmFuc2FjdGlvbiByZXF1ZXN0c1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uUmVxdWVzdCA9IHRoaXMuaW5mbygpLnRyYW5zYWN0aW9uUmVxdWVzdDtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh0cmFuc2FjdGlvblJlcXVlc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZWNyZWF0ZSB0cmFuc2FjdGlvbiB3aXRob3V0IHRyYW5zYWN0aW9uIHJlcXVlc3QnKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh0aGlzLndhbGxldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHJlY3JlYXRlIHRyYW5zYWN0aW9uIHdpdGhvdXQgd2FsbGV0Jyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3JpZ2luYWxQcmVidWlsZCA9IHRyYW5zYWN0aW9uUmVxdWVzdC5jb2luU3BlY2lmaWNbdGhpcy5iYXNlQ29pbi50eXBlXTtcblxuICAgIGNvbnN0IHJlY2lwaWVudHMgPSB0cmFuc2FjdGlvblJlcXVlc3QucmVjaXBpZW50cztcbiAgICBjb25zdCBwcmVidWlsZFBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBwYXJhbXMsIHsgcmVjaXBpZW50czogcmVjaXBpZW50cyB9LCB0cmFuc2FjdGlvblJlcXVlc3QuYnVpbGRQYXJhbXMpO1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKG9yaWdpbmFsUHJlYnVpbGQuaG9wVHJhbnNhY3Rpb24pKSB7XG4gICAgICBwcmVidWlsZFBhcmFtcy5ob3AgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0cmFuc2FjdGlvblJlcXVlc3QuYnVpbGRQYXJhbXMgJiYgdHJhbnNhY3Rpb25SZXF1ZXN0LmJ1aWxkUGFyYW1zLnR5cGUgPT09ICdjb25zb2xpZGF0ZScpIHtcbiAgICAgIC8vIGNvbnNvbGlkYXRlIHRhZyBpcyBpbiB0aGUgYnVpbGQgcGFyYW1zIC0gdGhpcyBpcyBhIGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb24sIHNvXG4gICAgICAvLyBpdCBuZWVkcyB0byBiZSByZWJ1aWx0IHVzaW5nIHRoZSBzcGVjaWFsIGNvbnNvbGlkYXRpb24gYnVpbGQgcm91dGVcbiAgICAgIHByZWJ1aWxkUGFyYW1zLnByZWJ1aWxkVHggPSBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAgIC5wb3N0KHRoaXMud2FsbGV0LnVybChgL2NvbnNvbGlkYXRlVW5zcGVudHNgKSlcbiAgICAgICAgLnNlbmQoQnVpbGRQYXJhbXMuZW5jb2RlKHByZWJ1aWxkUGFyYW1zKSlcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgICAgZGVsZXRlIHByZWJ1aWxkUGFyYW1zLnJlY2lwaWVudHM7XG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLndhbGxldC5wcmVidWlsZEFuZFNpZ25UcmFuc2FjdGlvbihwcmVidWlsZFBhcmFtcyk7XG4gICAgLy8gY29tcGFyZSBQQVlHbyBmZWVzXG4gICAgY29uc3Qgb3JpZ2luYWxQYXJzZWRUcmFuc2FjdGlvbiA9IChhd2FpdCB0aGlzLmJhc2VDb2luLnBhcnNlVHJhbnNhY3Rpb24oe1xuICAgICAgdHhQYXJhbXM6IHByZWJ1aWxkUGFyYW1zLFxuICAgICAgd2FsbGV0OiB0aGlzLndhbGxldCxcbiAgICAgIHR4UHJlYnVpbGQ6IG9yaWdpbmFsUHJlYnVpbGQsXG4gICAgfSkpIGFzIGFueTtcbiAgICBjb25zdCByZWNyZWF0ZWRQYXJzZWRUcmFuc2FjdGlvbiA9IChhd2FpdCB0aGlzLmJhc2VDb2luLnBhcnNlVHJhbnNhY3Rpb24oe1xuICAgICAgdHhQYXJhbXM6IHByZWJ1aWxkUGFyYW1zLFxuICAgICAgd2FsbGV0OiB0aGlzLndhbGxldCxcbiAgICAgIHR4UHJlYnVpbGQ6IHNpZ25lZFRyYW5zYWN0aW9uLFxuICAgIH0pKSBhcyBhbnk7XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChyZWNyZWF0ZWRQYXJzZWRUcmFuc2FjdGlvbi5pbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQpKSB7XG4gICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb247XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHJlY3JlYXRlZFBhcnNlZFRyYW5zYWN0aW9uLmltcGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudCAhPT0gJ2JpZ2ludCcgJiZcbiAgICAgICFfLmlzRmluaXRlKHJlY3JlYXRlZFBhcnNlZFRyYW5zYWN0aW9uLmltcGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW1wbGljaXQgZXh0ZXJuYWwgc3BlbmQgYW1vdW50IGNvdWxkIG5vdCBiZSBkZXRlcm1pbmVkJyk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICFfLmlzVW5kZWZpbmVkKG9yaWdpbmFsUGFyc2VkVHJhbnNhY3Rpb24uaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50KSAmJlxuICAgICAgcmVjcmVhdGVkUGFyc2VkVHJhbnNhY3Rpb24uaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50ID4gb3JpZ2luYWxQYXJzZWRUcmFuc2FjdGlvbi5pbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVjcmVhdGVkIHRyYW5zYWN0aW9uIGlzIHVzaW5nIGEgaGlnaGVyIHBheS1hcy15b3UtZ28tZmVlJyk7XG4gICAgfVxuICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qXG4gICAqIENvbGQgd2FsbGV0cyBjYW5ub3QgcmVjcmVhdGUgdHJhbnNhY3Rpb25zIGlmIHRoZSBvbmx5IHRoaW5nIHByb3ZpZGVkIGlzIHRoZSB3YWxsZXQgcGFzc3BocmFzZVxuICAgKlxuICAgKiBUaGUgdHJhbnNhY3Rpb24gY2FuIGJlIHJlY3JlYXRlZCBpZiBlaXRoZXJcbiAgICog4oCTIHRoZXJlIGlzIGFuIHhwcnZcbiAgICog4oCTIHRoZXJlIGlzIGEgd2FsbGV0UGFzc3BocmFzZSBhbmQgdGhlIHdhbGxldCBpcyBub3QgY29sZCAoYmVjYXVzZSBpZiBpdCdzIGNvbGQsIHRoZSBwYXNzcGhyYXNlIGlzIG9mIGxpdHRsZSB1c2UpXG4gICAqXG4gICAqIFRoZXJlZm9yZSwgaWYgbmVpdGhlciBvZiB0aGVzZSBpcyB0cnVlLCB0aGUgdHJhbnNhY3Rpb24gY2Fubm90IGJlIHJlY3JlYXRlZCwgd2hpY2ggaXMgcmVmbGVjdGVkIGluIHRoZSBpZlxuICAgKiBzdGF0ZW1lbnQgYmVsb3cuXG4gICAqL1xuICBwcml2YXRlIGNhblJlY3JlYXRlVHJhbnNhY3Rpb24ocGFyYW1zOiBBcHByb3ZlT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGlzQ29sZFdhbGxldCA9ICEhXy5nZXQodGhpcy53YWxsZXQsICdfd2FsbGV0LmlzQ29sZCcpO1xuICAgIGNvbnN0IGlzT0ZDV2FsbGV0ID0gdGhpcy5iYXNlQ29pbi5nZXRGYW1pbHkoKSA9PT0gJ29mYyc7IC8vIE9mZi1jaGFpbiB0cmFuc2FjdGlvbnMgZG9uJ3QgbmVlZCB0byBiZSByZWJ1aWx0XG4gICAgaWYgKCFwYXJhbXMueHBydiAmJiAhKHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlICYmICFpc0NvbGRXYWxsZXQgJiYgIWlzT0ZDV2FsbGV0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGFyZSBubyByZWNpcGllbnRzLCB0aGVuIHRoZSB0cmFuc2FjdGlvbiBjYW5ub3QgYmUgcmVjcmVhdGVkXG4gICAgY29uc3QgcmVjaXBpZW50cyA9IHRoaXMuaW5mbygpPy50cmFuc2FjdGlvblJlcXVlc3Q/LmJ1aWxkUGFyYW1zPy5yZWNpcGllbnRzIHx8IFtdO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmluZm8oKT8udHJhbnNhY3Rpb25SZXF1ZXN0Py5idWlsZFBhcmFtcz8udHlwZTtcblxuICAgIC8vIFdlIG9ubHkgd2FudCB0byBub3QgcmVjcmVhdGUgdHJhbnNhY3Rpb25zIHdpdGggbm8gcmVjaXBpZW50cyBpZiBpdCBpcyBhIFVUWE8gY29pbi5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiAhKFxuICAgICAgdXR4b2xpYi5pc1ZhbGlkTmV0d29yaygodGhpcy5iYXNlQ29pbiBhcyBhbnkpLm5ldHdvcmspICYmXG4gICAgICByZWNpcGllbnRzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgdHlwZSAhPT0gJ2NvbnNvbGlkYXRlJ1xuICAgICk7XG4gIH1cblxuICAvKlxuICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIHdoaWNoIGlzIGJlaW5nIGFwcHJvdmVkLlxuICAgKiBJZiB0aGlzIFBBIGlzIG9mIHR5cGUgJ3RyYW5zYWN0aW9uUmVxdWVzdCcgdGhpcyBmdW5jdGlvbiB3aWxsIHRyeSB0byByZWJ1aWxkIGFuZCByZXNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7QXBwcm92ZU9wdGlvbnN9IHBhcmFtc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhblJlY3JlYXRlVHJhbnNhY3Rpb24gLVxuICAgKiBAcGFyYW0ge1JlcXVlc3RUcmFjZXJ9IHJlcUlkIGlkIHRyYWNlclxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBwcmVBcHByb3ZlKHBhcmFtczogQXBwcm92ZU9wdGlvbnMgPSB7fSwgcmVxSWQ6IElSZXF1ZXN0VHJhY2VyKTogUHJvbWlzZTxQcmVBcHByb3ZlUmVzdWx0IHwgdW5kZWZpbmVkPiB7XG4gICAgLy8gVHJhbnNhY3Rpb25SZXF1ZXN0TGl0ZSBvciBNdWx0aXNpZyB0eCdzIG11c3Qgc2lnbiBiZWZvcmUgcGVuZGluZyBhcHByb3ZhbCBpcyBhcHByb3ZlZFxuICAgIC8vIFJlLXNpZ25lZCB0eCBpcyBwcm92aWRlZCB0byB0aGUgcGVuZGluZyBhcHByb3ZhbCBhcGlcbiAgICBpZiAodGhpcy50eXBlKCkgPT09IFR5cGUuVFJBTlNBQ1RJT05fUkVRVUVTVCkge1xuICAgICAgLypcbiAgICAgICAqIElmIHRoaXMgaXMgYSByZXF1ZXN0IGZvciBhcHByb3ZpbmcgYSB0cmFuc2FjdGlvbiwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhpcyB1c2VyIGhhcyBhIHByaXZhdGUga2V5IHRvIHRoZSB3YWxsZXRcbiAgICAgICAqIChzb21lIGFkbWlucyBtYXkgbm90IGhhdmUgdGhlIHNwZW5kIHBlcm1pc3Npb24pLCB0aGUgdHJhbnNhY3Rpb24gY291bGQgZWl0aGVyIGJlIHJlYnJvYWRjYXN0IGFzIGlzLCBvciBpdCBjb3VsZFxuICAgICAgICogYmUgcmVjb25zdHJ1Y3RlZC4gSXQgaXMgcHJlZmVyYWJsZSB0byByZWNvbnN0cnVjdCBhIHR4IGluIG9yZGVyIHRvIGFkaGVyZSB0byB0aGUgbGF0ZXN0IG5ldHdvcmsgY29uZGl0aW9uc1xuICAgICAgICogc3VjaCBhcyBuZXdlciB1bnNwZW50cywgZGlmZmVyZW50IGZlZXMsIG9yIGEgaGlnaGVyIHNlcXVlbmNlIGlkXG4gICAgICAgKi9cbiAgICAgIGlmIChwYXJhbXMudHgpIHtcbiAgICAgICAgLy8gdGhlIGFwcHJvdmFsIHR4IHdhcyByZWNvbnN0cnVjdGVkIGFuZCBleHBsaWNpdGx5IHNwZWNpZmllZCAtIHBhc3MgaXQgdGhyb3VnaFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR4SGV4OiBwYXJhbXMudHgsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIHRoaXMgdXNlciBtYXkgbm90IGhhdmUgc3BlbmRpbmcgcHJpdmlsZWdlcyBvciBhIHBhc3NwaHJhc2UgbWF5IG5vdCBoYXZlIGJlZW4gcGFzc2VkIGluXG4gICAgICBpZiAoIXRoaXMuY2FuUmVjcmVhdGVUcmFuc2FjdGlvbihwYXJhbXMpKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBUcmFuc2FjdGlvblJlcXVlc3QsIHRoZW4gdGhlIHR4UmVxdWVzdCBhbHJlYWR5IGhhcyB0aGUgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdBcHByb3ZhbC50eFJlcXVlc3RJZCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIE11bHRpU2lnLCB0aGVuIHdlIG5lZWQgdG8gZmV0Y2ggdGhlIGhhbGYgc2lnbmVkIHR4IHRvIHByb3BhZ2F0ZSB0byB0aGUgYXBwcm92YWwgQVBJXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gXy5nZXQoXG4gICAgICAgICAgdGhpcy5pbmZvKCksXG4gICAgICAgICAgYHRyYW5zYWN0aW9uUmVxdWVzdC5jb2luU3BlY2lmaWMuJHt0aGlzLmJhc2VDb2luLnR5cGV9YFxuICAgICAgICApIGFzIFByZUFwcHJvdmVSZXN1bHQ7XG4gICAgICAgIGlmICghXy5pc09iamVjdCh0cmFuc2FjdGlvbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZXJlIGlzIG5laXRoZXIgYW4gb3JpZ2luYWwgdHJhbnNhY3Rpb24gb2JqZWN0IG5vciBjYW4gYSBuZXcgb25lIGJlIHJlY3JlYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdBcHByb3ZhbC50eFJlcXVlc3RJZCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZWNyZWF0ZUFuZFNpZ25UU1NUcmFuc2FjdGlvbihwYXJhbXMsIHJlcUlkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlY3JlYXRlQW5kU2lnblRyYW5zYWN0aW9uKHBhcmFtcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBwZXJmb3JtIGFueSBwb3N0LWFwcHJvdmFsIGFjdGlvbnMuXG4gICAqIElmIHR5cGUgaXMgJ3RyYW5zYWN0aW9uUmVxdWVzdEZ1bGwnLCB0aGlzIHdpbGwgc2lnbiB0aGUgdHhSZXF1ZXN0RnVsbCBpZiBwb3NzaWJsZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSByZXFJZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBwb3N0QXBwcm92ZShwYXJhbXM6IEFwcHJvdmVPcHRpb25zID0ge30sIHJlcUlkOiBJUmVxdWVzdFRyYWNlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKCkpIHtcbiAgICAgIGNhc2UgVHlwZS5UUkFOU0FDVElPTl9SRVFVRVNUX0ZVTEw6XG4gICAgICAgIC8vIFRyYW5zYWN0aW9uUmVxdWVzdEZ1bGwgZm9yIFNNSCBvciBTTUMgd2FsbGV0cyBjYW4gb25seSBiZSBzaWduZWQgYWZ0ZXIgcGVuZGluZyBhcHByb3ZhbCBpcyBhcHByb3ZlZFxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5fcGVuZGluZ0FwcHJvdmFsLnN0YXRlID09PSBTdGF0ZS5BUFBST1ZFRCAmJlxuICAgICAgICAgIHRoaXMuY2FuUmVjcmVhdGVUcmFuc2FjdGlvbihwYXJhbXMpICYmXG4gICAgICAgICAgdGhpcy5iYXNlQ29pbi5zdXBwb3J0c1RzcygpXG4gICAgICAgICkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucmVjcmVhdGVBbmRTaWduVFNTVHJhbnNhY3Rpb24ocGFyYW1zLCByZXFJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGVuc3VyZSB0aGF0IHNlbGYud2FsbGV0IGlzIHNldFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBwb3B1bGF0ZVdhbGxldCgpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICAgIGlmICh0aGlzLndhbGxldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBUT0RPKFdQLTEzNDEpOiBjb25zb2xpZGF0ZS9zaW1wbGlmeSB0aGlzIGxvZ2ljXG4gICAgc3dpdGNoICh0aGlzLnR5cGUoKSkge1xuICAgICAgY2FzZSBUeXBlLlRSQU5TQUNUSU9OX1JFUVVFU1Q6XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uUmVxdWVzdCA9IHRoaXMuaW5mbygpLnRyYW5zYWN0aW9uUmVxdWVzdDtcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQodHJhbnNhY3Rpb25SZXF1ZXN0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBvYmplY3QgcHJvcGVydHkgdHJhbnNhY3Rpb25SZXF1ZXN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cGRhdGVkV2FsbGV0OiBJV2FsbGV0ID0gYXdhaXQgdGhpcy5iYXNlQ29pbi53YWxsZXRzKCkuZ2V0KHsgaWQ6IHRyYW5zYWN0aW9uUmVxdWVzdC5zb3VyY2VXYWxsZXQgfSk7XG5cbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQodXBkYXRlZFdhbGxldCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgLSB1bmFibGUgdG8gZ2V0IHdhbGxldCB1c2luZyBzb3VyY2V3YWxsZXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMud2FsbGV0ID0gdXBkYXRlZFdhbGxldDtcblxuICAgICAgICBpZiAodGhpcy53YWxsZXQuaWQoKSAhPT0gdHJhbnNhY3Rpb25SZXF1ZXN0LnNvdXJjZVdhbGxldCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBzb3VyY2Ugd2FsbGV0IGZvciBwZW5kaW5nIGFwcHJvdmFsJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFR5cGUuVFJBTlNBQ1RJT05fUkVRVUVTVF9GVUxMOlxuICAgICAgICBjb25zdCB3YWxsZXRJZCA9IHRoaXMud2FsbGV0SWQoKTtcbiAgICAgICAgaWYgKCF3YWxsZXRJZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlcnJvciwgcGVuZGluZ0FwcHJvdmFsLndhbGxldCBpcyBleHBlY3RlZCB0byBiZSBkZWZpbmVkIScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FsbGV0ID0gYXdhaXQgdGhpcy5iYXNlQ29pbi53YWxsZXRzKCkuZ2V0KHsgaWQ6IHRoaXMud2FsbGV0SWQoKSB9KTtcbiAgICAgICAgaWYgKCF0aGlzLndhbGxldCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCAtIHVuYWJsZSB0byBnZXQgd2FsbGV0IHVzaW5nIHBlbmRpbmdBcHByb3ZhbC53YWxsZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG59XG4iXX0=