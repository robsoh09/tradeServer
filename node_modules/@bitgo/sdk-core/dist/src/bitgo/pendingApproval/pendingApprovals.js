"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PendingApprovals = void 0;
/**
 * @prettier
 */
const _ = __importStar(require("lodash"));
const common = __importStar(require("../../common"));
const pendingApproval_1 = require("../pendingApproval");
const debug = require('debug')('bitgo:v2:pendingApprovals');
class PendingApprovals {
    constructor(bitgo, baseCoin) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
    }
    /**
     * List the pending approvals available to the user
     * @param params
     */
    async list(params = {}) {
        common.validateParams(params, [], ['walletId', 'enterpriseId']);
        const queryParams = {};
        if (_.isString(params.walletId)) {
            queryParams.walletId = params.walletId;
        }
        if (_.isString(params.enterpriseId)) {
            queryParams.enterprise = params.enterpriseId;
        }
        if (Object.keys(queryParams).length !== 1) {
            throw new Error('must provide exactly 1 of walletId or enterpriseId to get pending approvals on');
        }
        const body = (await this.bitgo.get(this.baseCoin.url('/pendingapprovals')).query(queryParams).result());
        body.pendingApprovals = body.pendingApprovals.map((currentApproval) => new pendingApproval_1.PendingApproval(this.bitgo, this.baseCoin, currentApproval));
        return body;
    }
    /**
     * Fetch an existing pending approval
     * @param params
     */
    async get(params = {}) {
        common.validateParams(params, ['id'], []);
        const approvalData = (await this.bitgo.get(this.baseCoin.url('/pendingapprovals/' + params.id)).result());
        let approvalWallet;
        if (approvalData.wallet) {
            try {
                approvalWallet = await this.baseCoin.wallets().get({ id: approvalData.wallet });
            }
            catch (e) {
                // nothing to be done here, although it's probably noteworthy that a non-existent wallet is referenced
                debug('failed to get wallet %s, referenced by pending approval %s', approvalData.wallet, params.id);
            }
        }
        return new pendingApproval_1.PendingApproval(this.bitgo, this.baseCoin, approvalData, approvalWallet);
    }
}
exports.PendingApprovals = PendingApprovals;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVuZGluZ0FwcHJvdmFscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9iaXRnby9wZW5kaW5nQXBwcm92YWwvcGVuZGluZ0FwcHJvdmFscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0gsMENBQTRCO0FBQzVCLHFEQUF1QztBQUd2Qyx3REFNNEI7QUFFNUIsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLDJCQUEyQixDQUFDLENBQUM7QUFFNUQsTUFBYSxnQkFBZ0I7SUFJM0IsWUFBWSxLQUFnQixFQUFFLFFBQW1CO1FBQy9DLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0lBQzNCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQXNDLEVBQUU7UUFDakQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLENBQUMsVUFBVSxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUM7UUFDaEUsTUFBTSxXQUFXLEdBQVEsRUFBRSxDQUFDO1FBQzVCLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDL0IsV0FBVyxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDO1NBQ3hDO1FBQ0QsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsRUFBRTtZQUNuQyxXQUFXLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUM7U0FDOUM7UUFFRCxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN6QyxNQUFNLElBQUksS0FBSyxDQUFDLGdGQUFnRixDQUFDLENBQUM7U0FDbkc7UUFFRCxNQUFNLElBQUksR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBUSxDQUFDO1FBQy9HLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUMvQyxDQUFDLGVBQWUsRUFBRSxFQUFFLENBQUMsSUFBSSxpQ0FBZSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxlQUFlLENBQUMsQ0FDckYsQ0FBQztRQUNGLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxHQUFHLENBQUMsU0FBb0MsRUFBRTtRQUM5QyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRTFDLE1BQU0sWUFBWSxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsR0FBRyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBUSxDQUFDO1FBQ2pILElBQUksY0FBYyxDQUFDO1FBQ25CLElBQUksWUFBWSxDQUFDLE1BQU0sRUFBRTtZQUN2QixJQUFJO2dCQUNGLGNBQWMsR0FBRyxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO2FBQ2pGO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1Ysc0dBQXNHO2dCQUN0RyxLQUFLLENBQUMsNERBQTRELEVBQUUsWUFBWSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDckc7U0FDRjtRQUNELE9BQU8sSUFBSSxpQ0FBZSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxZQUFZLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFDdEYsQ0FBQztDQUNGO0FBckRELDRDQXFEQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIGNvbW1vbiBmcm9tICcuLi8uLi9jb21tb24nO1xuaW1wb3J0IHsgSUJhc2VDb2luIH0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgQml0R29CYXNlIH0gZnJvbSAnLi4vYml0Z29CYXNlJztcbmltcG9ydCB7XG4gIEdldFBlbmRpbmdBcHByb3ZhbE9wdGlvbnMsXG4gIElQZW5kaW5nQXBwcm92YWxzLFxuICBMaXN0UGVuZGluZ0FwcHJvdmFsc09wdGlvbnMsXG4gIExpc3RQZW5kaW5nQXBwcm92YWxzUmVzdWx0LFxuICBQZW5kaW5nQXBwcm92YWwsXG59IGZyb20gJy4uL3BlbmRpbmdBcHByb3ZhbCc7XG5cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnYml0Z286djI6cGVuZGluZ0FwcHJvdmFscycpO1xuXG5leHBvcnQgY2xhc3MgUGVuZGluZ0FwcHJvdmFscyBpbXBsZW1lbnRzIElQZW5kaW5nQXBwcm92YWxzIHtcbiAgcHJpdmF0ZSByZWFkb25seSBiaXRnbzogQml0R29CYXNlO1xuICBwcml2YXRlIHJlYWRvbmx5IGJhc2VDb2luOiBJQmFzZUNvaW47XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSwgYmFzZUNvaW46IElCYXNlQ29pbikge1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgICB0aGlzLmJhc2VDb2luID0gYmFzZUNvaW47XG4gIH1cblxuICAvKipcbiAgICogTGlzdCB0aGUgcGVuZGluZyBhcHByb3ZhbHMgYXZhaWxhYmxlIHRvIHRoZSB1c2VyXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIGxpc3QocGFyYW1zOiBMaXN0UGVuZGluZ0FwcHJvdmFsc09wdGlvbnMgPSB7fSk6IFByb21pc2U8TGlzdFBlbmRpbmdBcHByb3ZhbHNSZXN1bHQ+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWyd3YWxsZXRJZCcsICdlbnRlcnByaXNlSWQnXSk7XG4gICAgY29uc3QgcXVlcnlQYXJhbXM6IGFueSA9IHt9O1xuICAgIGlmIChfLmlzU3RyaW5nKHBhcmFtcy53YWxsZXRJZCkpIHtcbiAgICAgIHF1ZXJ5UGFyYW1zLndhbGxldElkID0gcGFyYW1zLndhbGxldElkO1xuICAgIH1cbiAgICBpZiAoXy5pc1N0cmluZyhwYXJhbXMuZW50ZXJwcmlzZUlkKSkge1xuICAgICAgcXVlcnlQYXJhbXMuZW50ZXJwcmlzZSA9IHBhcmFtcy5lbnRlcnByaXNlSWQ7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHF1ZXJ5UGFyYW1zKS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBwcm92aWRlIGV4YWN0bHkgMSBvZiB3YWxsZXRJZCBvciBlbnRlcnByaXNlSWQgdG8gZ2V0IHBlbmRpbmcgYXBwcm92YWxzIG9uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keSA9IChhd2FpdCB0aGlzLmJpdGdvLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL3BlbmRpbmdhcHByb3ZhbHMnKSkucXVlcnkocXVlcnlQYXJhbXMpLnJlc3VsdCgpKSBhcyBhbnk7XG4gICAgYm9keS5wZW5kaW5nQXBwcm92YWxzID0gYm9keS5wZW5kaW5nQXBwcm92YWxzLm1hcChcbiAgICAgIChjdXJyZW50QXBwcm92YWwpID0+IG5ldyBQZW5kaW5nQXBwcm92YWwodGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbiwgY3VycmVudEFwcHJvdmFsKVxuICAgICk7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYW4gZXhpc3RpbmcgcGVuZGluZyBhcHByb3ZhbFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBnZXQocGFyYW1zOiBHZXRQZW5kaW5nQXBwcm92YWxPcHRpb25zID0ge30pOiBQcm9taXNlPFBlbmRpbmdBcHByb3ZhbD4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaWQnXSwgW10pO1xuXG4gICAgY29uc3QgYXBwcm92YWxEYXRhID0gKGF3YWl0IHRoaXMuYml0Z28uZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvcGVuZGluZ2FwcHJvdmFscy8nICsgcGFyYW1zLmlkKSkucmVzdWx0KCkpIGFzIGFueTtcbiAgICBsZXQgYXBwcm92YWxXYWxsZXQ7XG4gICAgaWYgKGFwcHJvdmFsRGF0YS53YWxsZXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFwcHJvdmFsV2FsbGV0ID0gYXdhaXQgdGhpcy5iYXNlQ29pbi53YWxsZXRzKCkuZ2V0KHsgaWQ6IGFwcHJvdmFsRGF0YS53YWxsZXQgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgdG8gYmUgZG9uZSBoZXJlLCBhbHRob3VnaCBpdCdzIHByb2JhYmx5IG5vdGV3b3J0aHkgdGhhdCBhIG5vbi1leGlzdGVudCB3YWxsZXQgaXMgcmVmZXJlbmNlZFxuICAgICAgICBkZWJ1ZygnZmFpbGVkIHRvIGdldCB3YWxsZXQgJXMsIHJlZmVyZW5jZWQgYnkgcGVuZGluZyBhcHByb3ZhbCAlcycsIGFwcHJvdmFsRGF0YS53YWxsZXQsIHBhcmFtcy5pZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUGVuZGluZ0FwcHJvdmFsKHRoaXMuYml0Z28sIHRoaXMuYmFzZUNvaW4sIGFwcHJvdmFsRGF0YSwgYXBwcm92YWxXYWxsZXQpO1xuICB9XG59XG4iXX0=