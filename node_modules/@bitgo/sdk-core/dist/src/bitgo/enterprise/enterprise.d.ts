/// <reference types="node" />
import { IBaseCoin } from '../baseCoin';
import { BitGoBase } from '../bitgoBase';
import { EnterpriseData, EnterpriseFeatureFlag, IEnterprise } from '../enterprise';
import { Wallet } from '../wallet';
import { BitGoProofSignatures, SerializedNtildeWithVerifiers } from '../utils/tss/ecdsa';
import { EcdsaTypes } from '@bitgo/sdk-lib-mpc';
import { Buffer } from 'buffer';
import { EcdhDerivedKeypair } from '../keychain';
export declare class Enterprise implements IEnterprise {
    private readonly bitgo;
    private readonly baseCoin;
    readonly id: string;
    readonly name: string;
    readonly _enterprise: EnterpriseData;
    constructor(bitgo: BitGoBase, baseCoin: IBaseCoin, enterpriseData: EnterpriseData);
    /**
     * Enterprise URL for v1 methods, such as getting users
     * @param query
     */
    url(query?: string): string;
    /**
     * Enterprise URL for v2 methods, such as getting fee address balances
     * @param query
     */
    coinUrl(query?: string): string;
    /**
     * Get the wallets associated with this Enterprise
     * @param params
     */
    coinWallets(params?: Record<string, never>): Promise<Wallet[]>;
    /**
     * Get the users associated with this Enterprise
     * @param params
     */
    users(params?: Record<string, never>): Promise<any>;
    /**
     * Get the fee address balance for this Enterprise
     * @param params
     */
    getFeeAddressBalance(params?: Record<string, never>): Promise<any>;
    /**
     * Add a user to this Enterprise
     * @param params
     */
    addUser(params?: any): Promise<any>;
    /**
     * Remove a user from this Enterprise
     * @param params
     */
    removeUser(params?: any): Promise<any>;
    /**
     * Get the first pending transaction for this Enterprise
     * @param params
     */
    getFirstPendingTransaction(params?: Record<string, never>): Promise<any>;
    /**
     * Verifies and signs bitgo proofs for the enterprise
     * @param userPassword - enterprise admin's login password
     */
    verifyEcdsaBitGoChallengeProofs(userPassword: string): Promise<BitGoProofSignatures>;
    /**
     * Manages all the challenges and signatures and uploads them to enable
     * ECDSA signing on enterprise. Also generates a client side Ntilde challenge
     * if not provided, but note that can take approx. a minute.
     * @param userPassword
     * @param bitgoInstChallengeProofSignature
     * @param bitgoNitroChallengeProofSignature
     * @param challenge
     */
    uploadAndEnableTssEcdsaSigning(userPassword: string, bitgoInstChallengeProofSignature: Buffer, bitgoNitroChallengeProofSignature: Buffer, challenge?: EcdsaTypes.DeserializedNtildeWithProofs): Promise<void>;
    /**
     * Fetches the existing TSS ECDSA enterprise challenge if one exists.
     * Can be used with uploadAndEnableTssEcdsaSigning to re-sign the
     * enterprise challenge with new signatures.
     */
    getExistingTssEcdsaChallenge(): Promise<EcdsaTypes.DeserializedNtildeWithProofs>;
    /**
     * Resigns the enterprise and bitgo challenges with a new ECDH keychain.
     * Verifies that the old keychain signed the challenges previously.
     * @param oldEcdhKeypair - the old keychain that signed the challenges
     * @param newEcdhKeypair - the new keychain that will sign the challenges
     * @param entChallenge - existing signed enterprise challenge
     * @param bitgoInstChallenge - existing signed bitgo institutional challenge
     * @param bitgoNitroChallenge - existing signed bitgo nitro challenge
     */
    resignEnterpriseChallenges(oldEcdhKeypair: EcdhDerivedKeypair, newEcdhKeypair: EcdhDerivedKeypair, entChallenge: SerializedNtildeWithVerifiers, bitgoInstChallenge: SerializedNtildeWithVerifiers, bitgoNitroChallenge: SerializedNtildeWithVerifiers): Promise<void>;
    /**
     *  Check if the enterprise has a set of featureFlags
     * @param flags
     */
    hasFeatureFlags(flags: EnterpriseFeatureFlag[]): boolean;
}
//# sourceMappingURL=enterprise.d.ts.map