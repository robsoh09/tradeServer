"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntentScope = exports.IntentVersion = exports.AppId = exports.Utils = exports.isImmOrOwnedObj = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const constants_1 = require("./constants");
const sui_bcs_1 = require("./mystenlab/types/sui-bcs");
const bcs_1 = require("@mysten/bcs");
const iface_1 = require("./iface");
const buffer_1 = require("buffer");
const types_1 = require("./mystenlab/types");
const builder_1 = require("./mystenlab/builder");
const keyPair_1 = require("./keyPair");
const blake2b_1 = __importDefault(require("@bitgo/blake2b"));
const TransactionDataBlock_1 = require("./mystenlab/builder/TransactionDataBlock");
function isImmOrOwnedObj(obj) {
    return 'ImmOrOwned' in obj;
}
exports.isImmOrOwnedObj = isImmOrOwnedObj;
class Utils {
    /** @inheritdoc */
    isValidBlockId(hash) {
        throw new Error('Method not implemented.');
    }
    /** @inheritdoc */
    isValidPrivateKey(key) {
        throw new Error('Method not implemented.');
    }
    /** @inheritdoc */
    isValidPublicKey(key) {
        return (0, sdk_core_1.isValidEd25519PublicKey)(key);
    }
    /** @inheritdoc */
    isValidSignature(signature) {
        throw new Error('Method not implemented.');
    }
    /** @inheritdoc */
    isValidTransactionId(txId) {
        throw new Error('Method not implemented.');
    }
    /**
     * Checks if raw transaction can be deserialized
     *
     * @param {string} rawTransaction - transaction in base64 string format
     * @returns {boolean} - the validation result
     */
    isValidRawTransaction(rawTransaction) {
        try {
            const data = (0, bcs_1.fromB64)(rawTransaction);
            const deserialized = builder_1.builder.de('TransactionData', data);
            builder_1.builder.ser('TransactionData', deserialized, { maxSize: TransactionDataBlock_1.TRANSACTION_DATA_MAX_SIZE });
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Check the raw transaction has a valid format in the blockchain context, throw otherwise.
     *
     * @param {string} rawTransaction - Transaction in base64 string  format
     */
    validateRawTransaction(rawTransaction) {
        if (!rawTransaction) {
            throw new sdk_core_1.ParseTransactionError('Invalid raw transaction: Undefined');
        }
        if (!this.isValidRawTransaction(rawTransaction)) {
            throw new sdk_core_1.ParseTransactionError('Invalid raw transaction');
        }
    }
    /**
     * Validates addresses to check if all exist and are valid Sui public keys
     *
     * @param {string} addresses The address to be validated
     * @param {string} fieldName Name of the field to validate, its needed to return which field is failing on case of error.
     */
    validateAddresses(addresses, fieldName) {
        for (const address of addresses) {
            this.validateAddress(address, fieldName);
        }
    }
    /**
     * Validates address to check if it exists and is a valid Sui public key
     *
     * @param {string} address The address to be validated
     * @param {string} fieldName Name of the field to validate, its needed to return which field is failing on case of error.
     */
    validateAddress(address, fieldName) {
        if (!address || !(0, types_1.isValidSuiAddress)((0, types_1.normalizeSuiAddress)(address))) {
            throw new sdk_core_1.BuildTransactionError(`Invalid or missing ${fieldName}, got: ${address}`);
        }
    }
    /** @inheritdoc */
    isValidAddress(address) {
        return this.isHex(address) && this.getHexByteLength(address) === constants_1.SUI_ADDRESS_LENGTH;
    }
    isHex(value) {
        return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;
    }
    getHexByteLength(value) {
        // return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
        return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
    }
    /**
     * Returns whether or not the string is a valid amount
     *
     * @param {number[]} amounts - the amounts to validate
     * @returns {boolean} - the validation result
     */
    isValidAmounts(amounts) {
        for (const amount of amounts) {
            if (!this.isValidAmount(amount)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns whether or not the string is a valid amount
     *
     * @param {number} amounts - the amount to validate
     * @returns {boolean} - the validation result
     */
    isValidAmount(amount) {
        const bigNumberAmount = new bignumber_js_1.default(Number(amount));
        if (!bigNumberAmount.isInteger() || bigNumberAmount.isLessThanOrEqualTo(0)) {
            return false;
        }
        return true;
    }
    /**
     * Normalizes hex ids (addresses, object ids) to always contain the '0x' prefix.
     *
     * @param {string} id
     * @return {string}
     **/
    normalizeHexId(id) {
        return id.startsWith('0x') ? id : '0x'.concat(id);
    }
    /**
     * Get transaction type by function name
     *
     * @param {MethodNames} fctName
     * @return {TransactionType}
     */
    getTransactionType(suiTransactionType) {
        switch (suiTransactionType) {
            case iface_1.SuiTransactionType.Transfer:
                return sdk_core_1.TransactionType.Send;
            case iface_1.SuiTransactionType.AddStake:
                return sdk_core_1.TransactionType.StakingAdd;
            case iface_1.SuiTransactionType.WithdrawStake:
                return sdk_core_1.TransactionType.StakingWithdraw;
            case iface_1.SuiTransactionType.CustomTx:
                return sdk_core_1.TransactionType.CustomTx;
        }
    }
    /**
     * Get SUI transaction type
     *
     * @param {MethodNames} fctName
     * @return {TransactionType}
     */
    getSuiTransactionType(command) {
        switch (command.kind) {
            case 'SplitCoins':
            case 'TransferObjects':
            case 'MergeCoins':
                return iface_1.SuiTransactionType.Transfer;
            case 'MoveCall':
                if (command.target.endsWith(iface_1.MethodNames.RequestAddStake)) {
                    return iface_1.SuiTransactionType.AddStake;
                }
                else if (command.target.endsWith(iface_1.MethodNames.RequestWithdrawStake)) {
                    return iface_1.SuiTransactionType.WithdrawStake;
                }
                else if (command.target.endsWith(iface_1.MethodNames.StakingPoolSplit) ||
                    command.target.endsWith(iface_1.MethodNames.PublicTransfer)) {
                    return iface_1.SuiTransactionType.CustomTx;
                }
                else {
                    throw new sdk_core_1.InvalidTransactionError(`unsupported target method ${command.target}`);
                }
            default:
                throw new sdk_core_1.InvalidTransactionError(`unsupported transaction kind ${command.kind}`);
        }
    }
    getRecipients(tx) {
        const receipts = [];
        const splitResults = [];
        tx.tx.transactions.forEach((transaction) => {
            if (transaction.kind === 'SplitCoins') {
                const index = transaction.amounts[0].index;
                const input = tx.tx.inputs[index];
                splitResults.push(this.getAmount(input));
            }
            if (transaction.kind === 'MoveCall' && transaction.target.endsWith(iface_1.MethodNames.StakingPoolSplit)) {
                const index = transaction.arguments[1].index;
                const input = tx.tx.inputs[index];
                splitResults.push(this.getAmount(input));
            }
        });
        const destinations = [];
        tx.tx.transactions.forEach((transaction) => {
            if (transaction.kind === 'TransferObjects') {
                const index = transaction.address.index;
                const input = tx.tx.inputs[index];
                destinations.push(this.getAddress(input));
            }
        });
        destinations.map((address, i) => {
            receipts.push({
                address: address,
                amount: splitResults[i].toString(),
            });
        });
        tx.tx.transactions.forEach((transaction) => {
            if (transaction.kind === 'MoveCall' && transaction.target.endsWith(iface_1.MethodNames.PublicTransfer)) {
                const destinationArg = transaction.arguments[1];
                const destinationInput = tx.tx.inputs[destinationArg.index];
                const destination = this.getAddress(destinationInput);
                const movingObject = transaction.arguments[0];
                if (movingObject.kind === 'Input') {
                    receipts.push({
                        address: destination,
                        amount: '0',
                        data: 'unknown amount',
                    });
                }
                else if (movingObject.kind === 'Result') {
                    receipts.push({
                        address: destination,
                        amount: splitResults[movingObject.index].toString(),
                    });
                }
            }
        });
        return receipts;
    }
    /**
     * Get add staking requests
     *
     * @param {StakingProgrammableTransaction} tx: staking transaction object
     * @return {RequestAddStake[]}  add staking requests
     */
    getStakeRequests(tx) {
        const amounts = [];
        const addresses = [];
        tx.transactions.forEach((transaction, i) => {
            if (transaction.kind === 'SplitCoins') {
                const amountInputIdx = transaction.amounts[0].index;
                amounts.push(utils.getAmount(tx.inputs[amountInputIdx]));
            }
            if (transaction.kind === 'MoveCall') {
                const validatorAddressInputIdx = transaction.arguments[2]
                    .index;
                const validatorAddress = utils.getAddress(tx.inputs[validatorAddressInputIdx]);
                addresses.push(validatorAddress);
            }
        });
        return addresses.map((address, index) => {
            return {
                validatorAddress: address,
                amount: amounts[index],
            };
        });
    }
    getAmount(input) {
        return (0, sui_bcs_1.isPureArg)(input)
            ? builder_1.builder.de(bcs_1.BCS.U64, buffer_1.Buffer.from(new Uint16Array(input.Pure)).toString('base64'), 'base64')
            : input.value;
    }
    getAddress(input) {
        var _a;
        if (input.hasOwnProperty('value')) {
            return (0, sui_bcs_1.isPureArg)(input.value)
                ? (0, types_1.normalizeSuiAddress)(builder_1.builder.de(bcs_1.BCS.ADDRESS, buffer_1.Buffer.from(new Uint16Array((_a = input.value) === null || _a === void 0 ? void 0 : _a.Pure)).toString('base64'), 'base64'))
                : input.value;
        }
        else {
            return (0, sui_bcs_1.isPureArg)(input)
                ? (0, types_1.normalizeSuiAddress)(builder_1.builder.de(bcs_1.BCS.ADDRESS, buffer_1.Buffer.from(new Uint16Array(input.Pure)).toString('base64'), 'base64'))
                : input.value;
        }
    }
    normalizeCoins(coins) {
        return coins.map((coin) => {
            return utils.normalizeSuiObjectRef(coin);
        });
    }
    normalizeSuiObjectRef(obj) {
        return {
            objectId: (0, types_1.normalizeSuiObjectId)(obj.objectId),
            version: Number(obj.version),
            digest: obj.digest,
        };
    }
    transactionInput(type, index = 0, value) {
        return {
            kind: 'Input',
            value: typeof value === 'bigint' ? String(value) : value,
            index,
            type,
        };
    }
    getAddressFromPublicKey(publicKey) {
        const PUBLIC_KEY_SIZE = 32;
        const tmp = new Uint8Array(PUBLIC_KEY_SIZE + 1);
        const pubBuf = buffer_1.Buffer.from(publicKey, 'hex');
        tmp.set([keyPair_1.SIGNATURE_SCHEME_TO_FLAG['ED25519']]); // ED25519: 0x00,
        tmp.set(pubBuf, 1);
        return (0, types_1.normalizeSuiAddress)((0, blake2b_1.default)(PUBLIC_KEY_SIZE)
            .update(tmp)
            .digest('hex')
            .slice(0, constants_1.SUI_ADDRESS_LENGTH * 2));
    }
}
exports.Utils = Utils;
const utils = new Utils();
exports.default = utils;
var AppId;
(function (AppId) {
    AppId[AppId["Sui"] = 0] = "Sui";
})(AppId = exports.AppId || (exports.AppId = {}));
var IntentVersion;
(function (IntentVersion) {
    IntentVersion[IntentVersion["V0"] = 0] = "V0";
})(IntentVersion = exports.IntentVersion || (exports.IntentVersion = {}));
var IntentScope;
(function (IntentScope) {
    IntentScope[IntentScope["TransactionData"] = 0] = "TransactionData";
    IntentScope[IntentScope["TransactionEffects"] = 1] = "TransactionEffects";
    IntentScope[IntentScope["CheckpointSummary"] = 2] = "CheckpointSummary";
    IntentScope[IntentScope["PersonalMessage"] = 3] = "PersonalMessage";
})(IntentScope = exports.IntentScope || (exports.IntentScope = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDhDQVF5QjtBQUN6QixnRUFBcUM7QUFDckMsMkNBQWlEO0FBQ2pELHVEQUFzRDtBQUN0RCxxQ0FBMkM7QUFDM0MsbUNBU2lCO0FBQ2pCLG1DQUFnQztBQUNoQyw2Q0FNMkI7QUFDM0IsaURBTzZCO0FBQzdCLHVDQUFxRDtBQUNyRCw2REFBcUM7QUFDckMsbUZBQXFGO0FBRXJGLFNBQWdCLGVBQWUsQ0FBQyxHQUE0QjtJQUMxRCxPQUFPLFlBQVksSUFBSSxHQUFHLENBQUM7QUFDN0IsQ0FBQztBQUZELDBDQUVDO0FBRUQsTUFBYSxLQUFLO0lBQ2hCLGtCQUFrQjtJQUNsQixjQUFjLENBQUMsSUFBWTtRQUN6QixNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVELGtCQUFrQjtJQUNsQixpQkFBaUIsQ0FBQyxHQUFXO1FBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLGdCQUFnQixDQUFDLEdBQVc7UUFDMUIsT0FBTyxJQUFBLGtDQUF1QixFQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsZ0JBQWdCLENBQUMsU0FBaUI7UUFDaEMsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsb0JBQW9CLENBQUMsSUFBWTtRQUMvQixNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gscUJBQXFCLENBQUMsY0FBc0I7UUFDMUMsSUFBSTtZQUNGLE1BQU0sSUFBSSxHQUFHLElBQUEsYUFBTyxFQUFDLGNBQWMs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TFcsV0FBVyxHQUFYLG1CQUFXLEtBQVgsbUJBQVcsUUFLdEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBCYXNlVXRpbHMsXG4gIEJ1aWxkVHJhbnNhY3Rpb25FcnJvcixcbiAgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IsXG4gIGlzVmFsaWRFZDI1NTE5UHVibGljS2V5LFxuICBQYXJzZVRyYW5zYWN0aW9uRXJyb3IsXG4gIFJlY2lwaWVudCxcbiAgVHJhbnNhY3Rpb25UeXBlLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgU1VJX0FERFJFU1NfTEVOR1RIIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgaXNQdXJlQXJnIH0gZnJvbSAnLi9teXN0ZW5sYWIvdHlwZXMvc3VpLWJjcyc7XG5pbXBvcnQgeyBCQ1MsIGZyb21CNjQgfSBmcm9tICdAbXlzdGVuL2Jjcyc7XG5pbXBvcnQge1xuICBDdXN0b21Qcm9ncmFtbWFibGVUcmFuc2FjdGlvbixcbiAgTWV0aG9kTmFtZXMsXG4gIFJlcXVlc3RBZGRTdGFrZSxcbiAgU3Rha2luZ1Byb2dyYW1tYWJsZVRyYW5zYWN0aW9uLFxuICBTdWlUcmFuc2FjdGlvbixcbiAgU3VpVHJhbnNhY3Rpb25UeXBlLFxuICBUcmFuc2ZlclByb2dyYW1tYWJsZVRyYW5zYWN0aW9uLFxuICBVbnN0YWtpbmdQcm9ncmFtbWFibGVUcmFuc2FjdGlvbixcbn0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuaW1wb3J0IHtcbiAgaXNWYWxpZFN1aUFkZHJlc3MsXG4gIG5vcm1hbGl6ZVN1aUFkZHJlc3MsXG4gIG5vcm1hbGl6ZVN1aU9iamVjdElkLFxuICBTdWlKc29uVmFsdWUsXG4gIFN1aU9iamVjdFJlZixcbn0gZnJvbSAnLi9teXN0ZW5sYWIvdHlwZXMnO1xuaW1wb3J0IHtcbiAgYnVpbGRlcixcbiAgTW92ZUNhbGxUcmFuc2FjdGlvbixcbiAgT2JqZWN0Q2FsbEFyZyxcbiAgU3BsaXRDb2luc1RyYW5zYWN0aW9uLFxuICBUcmFuc2FjdGlvbkJsb2NrSW5wdXQsXG4gIFRyYW5zYWN0aW9uVHlwZSBhcyBUcmFuc2FjdGlvbkNvbW1hbmRUeXBlLFxufSBmcm9tICcuL215c3RlbmxhYi9idWlsZGVyJztcbmltcG9ydCB7IFNJR05BVFVSRV9TQ0hFTUVfVE9fRkxBRyB9IGZyb20gJy4va2V5UGFpcic7XG5pbXBvcnQgYmxha2UyYiBmcm9tICdAYml0Z28vYmxha2UyYic7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9EQVRBX01BWF9TSVpFIH0gZnJvbSAnLi9teXN0ZW5sYWIvYnVpbGRlci9UcmFuc2FjdGlvbkRhdGFCbG9jayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ltbU9yT3duZWRPYmoob2JqOiBPYmplY3RDYWxsQXJnWydPYmplY3QnXSk6IG9iaiBpcyB7IEltbU9yT3duZWQ6IFN1aU9iamVjdFJlZiB9IHtcbiAgcmV0dXJuICdJbW1Pck93bmVkJyBpbiBvYmo7XG59XG5cbmV4cG9ydCBjbGFzcyBVdGlscyBpbXBsZW1lbnRzIEJhc2VVdGlscyB7XG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkQmxvY2tJZChoYXNoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZFByaXZhdGVLZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZFB1YmxpY0tleShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc1ZhbGlkRWQyNTUxOVB1YmxpY0tleShrZXkpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRTaWduYXR1cmUoc2lnbmF0dXJlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZFRyYW5zYWN0aW9uSWQodHhJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiByYXcgdHJhbnNhY3Rpb24gY2FuIGJlIGRlc2VyaWFsaXplZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmF3VHJhbnNhY3Rpb24gLSB0cmFuc2FjdGlvbiBpbiBiYXNlNjQgc3RyaW5nIGZvcm1hdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAgICovXG4gIGlzVmFsaWRSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBmcm9tQjY0KHJhd1RyYW5zYWN0aW9uKTtcbiAgICAgIGNvbnN0IGRlc2VyaWFsaXplZCA9IGJ1aWxkZXIuZGUoJ1RyYW5zYWN0aW9uRGF0YScsIGRhdGEpO1xuICAgICAgYnVpbGRlci5zZXIoJ1RyYW5zYWN0aW9uRGF0YScsIGRlc2VyaWFsaXplZCwgeyBtYXhTaXplOiBUUkFOU0FDVElPTl9EQVRBX01BWF9TSVpFIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgcmF3IHRyYW5zYWN0aW9uIGhhcyBhIHZhbGlkIGZvcm1hdCBpbiB0aGUgYmxvY2tjaGFpbiBjb250ZXh0LCB0aHJvdyBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByYXdUcmFuc2FjdGlvbiAtIFRyYW5zYWN0aW9uIGluIGJhc2U2NCBzdHJpbmcgIGZvcm1hdFxuICAgKi9cbiAgdmFsaWRhdGVSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbjogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFyYXdUcmFuc2FjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCByYXcgdHJhbnNhY3Rpb246IFVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNWYWxpZFJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCByYXcgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIGFkZHJlc3NlcyB0byBjaGVjayBpZiBhbGwgZXhpc3QgYW5kIGFyZSB2YWxpZCBTdWkgcHVibGljIGtleXNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NlcyBUaGUgYWRkcmVzcyB0byBiZSB2YWxpZGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTmFtZSBOYW1lIG9mIHRoZSBmaWVsZCB0byB2YWxpZGF0ZSwgaXRzIG5lZWRlZCB0byByZXR1cm4gd2hpY2ggZmllbGQgaXMgZmFpbGluZyBvbiBjYXNlIG9mIGVycm9yLlxuICAgKi9cbiAgdmFsaWRhdGVBZGRyZXNzZXMoYWRkcmVzc2VzOiBzdHJpbmdbXSwgZmllbGROYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgYWRkcmVzc2VzKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzLCBmaWVsZE5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYWRkcmVzcyB0byBjaGVjayBpZiBpdCBleGlzdHMgYW5kIGlzIGEgdmFsaWQgU3VpIHB1YmxpYyBrZXlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgVGhlIGFkZHJlc3MgdG8gYmUgdmFsaWRhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE5hbWUgTmFtZSBvZiB0aGUgZmllbGQgdG8gdmFsaWRhdGUsIGl0cyBuZWVkZWQgdG8gcmV0dXJuIHdoaWNoIGZpZWxkIGlzIGZhaWxpbmcgb24gY2FzZSBvZiBlcnJvci5cbiAgICovXG4gIHZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcsIGZpZWxkTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFhZGRyZXNzIHx8ICFpc1ZhbGlkU3VpQWRkcmVzcyhub3JtYWxpemVTdWlBZGRyZXNzKGFkZHJlc3MpKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBvciBtaXNzaW5nICR7ZmllbGROYW1lfSwgZ290OiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzSGV4KGFkZHJlc3MpICYmIHRoaXMuZ2V0SGV4Qnl0ZUxlbmd0aChhZGRyZXNzKSA9PT0gU1VJX0FERFJFU1NfTEVOR1RIO1xuICB9XG5cbiAgaXNIZXgodmFsdWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAvXigweHwwWCk/W2EtZkEtRjAtOV0rJC8udGVzdCh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoICUgMiA9PT0gMDtcbiAgfVxuXG4gIGdldEhleEJ5dGVMZW5ndGgodmFsdWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgLy8gcmV0dXJuIC9eKDB4fDBYKS8udGVzdCh2YWx1ZSkgPyAodmFsdWUubGVuZ3RoIC0gMikgLyAyIDogdmFsdWUubGVuZ3RoIC8gMjtcbiAgICByZXR1cm4gL14oMHh8MFgpLy50ZXN0KHZhbHVlKSA/ICh2YWx1ZS5sZW5ndGggLSAyKSAvIDIgOiB2YWx1ZS5sZW5ndGggLyAyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIGFtb3VudFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcltdfSBhbW91bnRzIC0gdGhlIGFtb3VudHMgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gICAqL1xuICBpc1ZhbGlkQW1vdW50cyhhbW91bnRzOiBudW1iZXJbXSk6IGJvb2xlYW4ge1xuICAgIGZvciAoY29uc3QgYW1vdW50IG9mIGFtb3VudHMpIHtcbiAgICAgIGlmICghdGhpcy5pc1ZhbGlkQW1vdW50KGFtb3VudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBhbW91bnRcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudHMgLSB0aGUgYW1vdW50IHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgaXNWYWxpZEFtb3VudChhbW91bnQ6IHN0cmluZyB8IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGJpZ051bWJlckFtb3VudCA9IG5ldyBCaWdOdW1iZXIoTnVtYmVyKGFtb3VudCkpO1xuICAgIGlmICghYmlnTnVtYmVyQW1vdW50LmlzSW50ZWdlcigpIHx8IGJpZ051bWJlckFtb3VudC5pc0xlc3NUaGFuT3JFcXVhbFRvKDApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgaGV4IGlkcyAoYWRkcmVzc2VzLCBvYmplY3QgaWRzKSB0byBhbHdheXMgY29udGFpbiB0aGUgJzB4JyBwcmVmaXguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqKi9cbiAgbm9ybWFsaXplSGV4SWQoaWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoJzB4JykgPyBpZCA6ICcweCcuY29uY2F0KGlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdHJhbnNhY3Rpb24gdHlwZSBieSBmdW5jdGlvbiBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7TWV0aG9kTmFtZXN9IGZjdE5hbWVcbiAgICogQHJldHVybiB7VHJhbnNhY3Rpb25UeXBlfVxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25UeXBlKHN1aVRyYW5zYWN0aW9uVHlwZTogU3VpVHJhbnNhY3Rpb25UeXBlKTogVHJhbnNhY3Rpb25UeXBlIHtcbiAgICBzd2l0Y2ggKHN1aVRyYW5zYWN0aW9uVHlwZSkge1xuICAgICAgY2FzZSBTdWlUcmFuc2FjdGlvblR5cGUuVHJhbnNmZXI6XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU2VuZDtcbiAgICAgIGNhc2UgU3VpVHJhbnNhY3Rpb25UeXBlLkFkZFN0YWtlOlxuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdBZGQ7XG4gICAgICBjYXNlIFN1aVRyYW5zYWN0aW9uVHlwZS5XaXRoZHJhd1N0YWtlOlxuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdXaXRoZHJhdztcbiAgICAgIGNhc2UgU3VpVHJhbnNhY3Rpb25UeXBlLkN1c3RvbVR4OlxuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLkN1c3RvbVR4O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgU1VJIHRyYW5zYWN0aW9uIHR5cGVcbiAgICpcbiAgICogQHBhcmFtIHtNZXRob2ROYW1lc30gZmN0TmFtZVxuICAgKiBAcmV0dXJuIHtUcmFuc2FjdGlvblR5cGV9XG4gICAqL1xuICBnZXRTdWlUcmFuc2FjdGlvblR5cGUoY29tbWFuZDogVHJhbnNhY3Rpb25Db21tYW5kVHlwZSk6IFN1aVRyYW5zYWN0aW9uVHlwZSB7XG4gICAgc3dpdGNoIChjb21tYW5kLmtpbmQpIHtcbiAgICAgIGNhc2UgJ1NwbGl0Q29pbnMnOlxuICAgICAgY2FzZSAnVHJhbnNmZXJPYmplY3RzJzpcbiAgICAgIGNhc2UgJ01lcmdlQ29pbnMnOlxuICAgICAgICByZXR1cm4gU3VpVHJhbnNhY3Rpb25UeXBlLlRyYW5zZmVyO1xuICAgICAgY2FzZSAnTW92ZUNhbGwnOlxuICAgICAgICBpZiAoY29tbWFuZC50YXJnZXQuZW5kc1dpdGgoTWV0aG9kTmFtZXMuUmVxdWVzdEFkZFN0YWtlKSkge1xuICAgICAgICAgIHJldHVybiBTdWlUcmFuc2FjdGlvblR5cGUuQWRkU3Rha2U7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZC50YXJnZXQuZW5kc1dpdGgoTWV0aG9kTmFtZXMuUmVxdWVzdFdpdGhkcmF3U3Rha2UpKSB7XG4gICAgICAgICAgcmV0dXJuIFN1aVRyYW5zYWN0aW9uVHlwZS5XaXRoZHJhd1N0YWtlO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGNvbW1hbmQudGFyZ2V0LmVuZHNXaXRoKE1ldGhvZE5hbWVzLlN0YWtpbmdQb29sU3BsaXQpIHx8XG4gICAgICAgICAgY29tbWFuZC50YXJnZXQuZW5kc1dpdGgoTWV0aG9kTmFtZXMuUHVibGljVHJhbnNmZXIpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBTdWlUcmFuc2FjdGlvblR5cGUuQ3VzdG9tVHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKGB1bnN1cHBvcnRlZCB0YXJnZXQgbWV0aG9kICR7Y29tbWFuZC50YXJnZXR9YCk7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihgdW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24ga2luZCAke2NvbW1hbmQua2luZH1gKTtcbiAgICB9XG4gIH1cblxuICBnZXRSZWNpcGllbnRzKFxuICAgIHR4OiBTdWlUcmFuc2FjdGlvbjxcbiAgICAgIHwgVHJhbnNmZXJQcm9ncmFtbWFibGVUcmFuc2FjdGlvblxuICAgICAgfCBTdGFraW5nUHJvZ3JhbW1hYmxlVHJhbnNhY3Rpb25cbiAgICAgIHwgVW5zdGFraW5nUHJvZ3JhbW1hYmxlVHJhbnNhY3Rpb25cbiAgICAgIHwgQ3VzdG9tUHJvZ3JhbW1hYmxlVHJhbnNhY3Rpb25cbiAgICA+XG4gICk6IFJlY2lwaWVudFtdIHtcbiAgICBjb25zdCByZWNlaXB0czogUmVjaXBpZW50W10gPSBbXTtcbiAgICBjb25zdCBzcGxpdFJlc3VsdHM6IG51bWJlcltdID0gW107XG4gICAgdHgudHgudHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICBpZiAodHJhbnNhY3Rpb24ua2luZCA9PT0gJ1NwbGl0Q29pbnMnKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdHJhbnNhY3Rpb24uYW1vdW50c1swXS5pbmRleDtcbiAgICAgICAgY29uc3QgaW5wdXQgPSB0eC50eC5pbnB1dHNbaW5kZXhdIGFzIGFueTtcbiAgICAgICAgc3BsaXRSZXN1bHRzLnB1c2godGhpcy5nZXRBbW91bnQoaW5wdXQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zYWN0aW9uLmtpbmQgPT09ICdNb3ZlQ2FsbCcgJiYgdHJhbnNhY3Rpb24udGFyZ2V0LmVuZHNXaXRoKE1ldGhvZE5hbWVzLlN0YWtpbmdQb29sU3BsaXQpKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdHJhbnNhY3Rpb24uYXJndW1lbnRzWzFdLmluZGV4O1xuICAgICAgICBjb25zdCBpbnB1dCA9IHR4LnR4LmlucHV0c1tpbmRleF0gYXMgYW55O1xuICAgICAgICBzcGxpdFJlc3VsdHMucHVzaCh0aGlzLmdldEFtb3VudChpbnB1dCkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgZGVzdGluYXRpb25zOiBzdHJpbmdbXSA9IFtdO1xuICAgIHR4LnR4LnRyYW5zYWN0aW9ucy5mb3JFYWNoKCh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgaWYgKHRyYW5zYWN0aW9uLmtpbmQgPT09ICdUcmFuc2Zlck9iamVjdHMnKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdHJhbnNhY3Rpb24uYWRkcmVzcy5pbmRleDtcbiAgICAgICAgY29uc3QgaW5wdXQgPSB0eC50eC5pbnB1dHNbaW5kZXhdIGFzIGFueTtcbiAgICAgICAgZGVzdGluYXRpb25zLnB1c2godGhpcy5nZXRBZGRyZXNzKGlucHV0KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVzdGluYXRpb25zLm1hcCgoYWRkcmVzcywgaSkgPT4ge1xuICAgICAgcmVjZWlwdHMucHVzaCh7XG4gICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgIGFtb3VudDogc3BsaXRSZXN1bHRzW2ldLnRvU3RyaW5nKCksXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHR4LnR4LnRyYW5zYWN0aW9ucy5mb3JFYWNoKCh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgaWYgKHRyYW5zYWN0aW9uLmtpbmQgPT09ICdNb3ZlQ2FsbCcgJiYgdHJhbnNhY3Rpb24udGFyZ2V0LmVuZHNXaXRoKE1ldGhvZE5hbWVzLlB1YmxpY1RyYW5zZmVyKSkge1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkFyZyA9IHRyYW5zYWN0aW9uLmFyZ3VtZW50c1sxXTtcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb25JbnB1dCA9IHR4LnR4LmlucHV0c1tkZXN0aW5hdGlvbkFyZy5pbmRleF0gYXMgYW55O1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHRoaXMuZ2V0QWRkcmVzcyhkZXN0aW5hdGlvbklucHV0KTtcblxuICAgICAgICBjb25zdCBtb3ZpbmdPYmplY3QgPSB0cmFuc2FjdGlvbi5hcmd1bWVudHNbMF07XG4gICAgICAgIGlmIChtb3ZpbmdPYmplY3Qua2luZCA9PT0gJ0lucHV0Jykge1xuICAgICAgICAgIHJlY2VpcHRzLnB1c2goe1xuICAgICAgICAgICAgYWRkcmVzczogZGVzdGluYXRpb24sXG4gICAgICAgICAgICBhbW91bnQ6ICcwJywgLy8gc2V0IDAsIG5vdCBhYmxlIHRvIGdldCBhbW91bnQgbWVyZWx5IGZyb20gcGFyc2luZ1xuICAgICAgICAgICAgZGF0YTogJ3Vua25vd24gYW1vdW50JyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChtb3ZpbmdPYmplY3Qua2luZCA9PT0gJ1Jlc3VsdCcpIHtcbiAgICAgICAgICByZWNlaXB0cy5wdXNoKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgYW1vdW50OiBzcGxpdFJlc3VsdHNbbW92aW5nT2JqZWN0LmluZGV4XS50b1N0cmluZygpLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVjZWlwdHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFkZCBzdGFraW5nIHJlcXVlc3RzXG4gICAqXG4gICAqIEBwYXJhbSB7U3Rha2luZ1Byb2dyYW1tYWJsZVRyYW5zYWN0aW9ufSB0eDogc3Rha2luZyB0cmFuc2FjdGlvbiBvYmplY3RcbiAgICogQHJldHVybiB7UmVxdWVzdEFkZFN0YWtlW119ICBhZGQgc3Rha2luZyByZXF1ZXN0c1xuICAgKi9cbiAgZ2V0U3Rha2VSZXF1ZXN0cyh0eDogU3Rha2luZ1Byb2dyYW1tYWJsZVRyYW5zYWN0aW9uKTogUmVxdWVzdEFkZFN0YWtlW10ge1xuICAgIGNvbnN0IGFtb3VudHM6IG51bWJlcltdID0gW107XG4gICAgY29uc3QgYWRkcmVzc2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgIHR4LnRyYW5zYWN0aW9ucy5mb3JFYWNoKCh0cmFuc2FjdGlvbiwgaSkgPT4ge1xuICAgICAgaWYgKHRyYW5zYWN0aW9uLmtpbmQgPT09ICdTcGxpdENvaW5zJykge1xuICAgICAgICBjb25zdCBhbW91bnRJbnB1dElkeCA9ICgodHJhbnNhY3Rpb24gYXMgU3BsaXRDb2luc1RyYW5zYWN0aW9uKS5hbW91bnRzWzBdIGFzIFRyYW5zYWN0aW9uQmxvY2tJbnB1dCkuaW5kZXg7XG4gICAgICAgIGFtb3VudHMucHVzaCh1dGlscy5nZXRBbW91bnQodHguaW5wdXRzW2Ftb3VudElucHV0SWR4XSBhcyBUcmFuc2FjdGlvbkJsb2NrSW5wdXQpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2FjdGlvbi5raW5kID09PSAnTW92ZUNhbGwnKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvckFkZHJlc3NJbnB1dElkeCA9ICgodHJhbnNhY3Rpb24gYXMgTW92ZUNhbGxUcmFuc2FjdGlvbikuYXJndW1lbnRzWzJdIGFzIFRyYW5zYWN0aW9uQmxvY2tJbnB1dClcbiAgICAgICAgICAuaW5kZXg7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvckFkZHJlc3MgPSB1dGlscy5nZXRBZGRyZXNzKHR4LmlucHV0c1t2YWxpZGF0b3JBZGRyZXNzSW5wdXRJZHhdIGFzIFRyYW5zYWN0aW9uQmxvY2tJbnB1dCk7XG4gICAgICAgIGFkZHJlc3Nlcy5wdXNoKHZhbGlkYXRvckFkZHJlc3MpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhZGRyZXNzZXMubWFwKChhZGRyZXNzLCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWRhdG9yQWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBhbW91bnRzW2luZGV4XSxcbiAgICAgIH0gYXMgUmVxdWVzdEFkZFN0YWtlO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0QW1vdW50KGlucHV0OiBTdWlKc29uVmFsdWUgfCBUcmFuc2FjdGlvbkJsb2NrSW5wdXQpOiBudW1iZXIge1xuICAgIHJldHVybiBpc1B1cmVBcmcoaW5wdXQpXG4gICAgICA/IGJ1aWxkZXIuZGUoQkNTLlU2NCwgQnVmZmVyLmZyb20obmV3IFVpbnQxNkFycmF5KGlucHV0LlB1cmUpKS50b1N0cmluZygnYmFzZTY0JyksICdiYXNlNjQnKVxuICAgICAgOiAoaW5wdXQgYXMgVHJhbnNhY3Rpb25CbG9ja0lucHV0KS52YWx1ZTtcbiAgfVxuXG4gIGdldEFkZHJlc3MoaW5wdXQ6IFRyYW5zYWN0aW9uQmxvY2tJbnB1dCk6IHN0cmluZyB7XG4gICAgaWYgKGlucHV0Lmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG4gICAgICByZXR1cm4gaXNQdXJlQXJnKGlucHV0LnZhbHVlKVxuICAgICAgICA/IG5vcm1hbGl6ZVN1aUFkZHJlc3MoXG4gICAgICAgICAgICBidWlsZGVyLmRlKEJDUy5BRERSRVNTLCBCdWZmZXIuZnJvbShuZXcgVWludDE2QXJyYXkoaW5wdXQudmFsdWU/LlB1cmUpKS50b1N0cmluZygnYmFzZTY0JyksICdiYXNlNjQnKVxuICAgICAgICAgIClcbiAgICAgICAgOiAoaW5wdXQgYXMgVHJhbnNhY3Rpb25CbG9ja0lucHV0KS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGlzUHVyZUFyZyhpbnB1dClcbiAgICAgICAgPyBub3JtYWxpemVTdWlBZGRyZXNzKFxuICAgICAgICAgICAgYnVpbGRlci5kZShCQ1MuQUREUkVTUywgQnVmZmVyLmZyb20obmV3IFVpbnQxNkFycmF5KGlucHV0LlB1cmUpKS50b1N0cmluZygnYmFzZTY0JyksICdiYXNlNjQnKVxuICAgICAgICAgIClcbiAgICAgICAgOiAoaW5wdXQgYXMgVHJhbnNhY3Rpb25CbG9ja0lucHV0KS52YWx1ZTtcbiAgICB9XG4gIH1cblxuICBub3JtYWxpemVDb2lucyhjb2luczogYW55W10pOiBTdWlPYmplY3RSZWZbXSB7XG4gICAgcmV0dXJuIGNvaW5zLm1hcCgoY29pbikgPT4ge1xuICAgICAgcmV0dXJuIHV0aWxzLm5vcm1hbGl6ZVN1aU9iamVjdFJlZihjb2luKTtcbiAgICB9KTtcbiAgfVxuXG4gIG5vcm1hbGl6ZVN1aU9iamVjdFJlZihvYmo6IFN1aU9iamVjdFJlZik6IFN1aU9iamVjdFJlZiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9iamVjdElkOiBub3JtYWxpemVTdWlPYmplY3RJZChvYmoub2JqZWN0SWQpLFxuICAgICAgdmVyc2lvbjogTnVtYmVyKG9iai52ZXJzaW9uKSxcbiAgICAgIGRpZ2VzdDogb2JqLmRpZ2VzdCxcbiAgICB9O1xuICB9XG5cbiAgdHJhbnNhY3Rpb25JbnB1dCh0eXBlOiAnb2JqZWN0JyB8ICdwdXJlJywgaW5kZXggPSAwLCB2YWx1ZT86IHVua25vd24pOiBUcmFuc2FjdGlvbkJsb2NrSW5wdXQge1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiAnSW5wdXQnLFxuICAgICAgdmFsdWU6IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgPyBTdHJpbmcodmFsdWUpIDogdmFsdWUsXG4gICAgICBpbmRleCxcbiAgICAgIHR5cGUsXG4gICAgfTtcbiAgfVxuXG4gIGdldEFkZHJlc3NGcm9tUHVibGljS2V5KHB1YmxpY0tleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBQVUJMSUNfS0VZX1NJWkUgPSAzMjtcbiAgICBjb25zdCB0bXAgPSBuZXcgVWludDhBcnJheShQVUJMSUNfS0VZX1NJWkUgKyAxKTtcbiAgICBjb25zdCBwdWJCdWYgPSBCdWZmZXIuZnJvbShwdWJsaWNLZXksICdoZXgnKTtcbiAgICB0bXAuc2V0KFtTSUdOQVRVUkVfU0NIRU1FX1RPX0ZMQUdbJ0VEMjU1MTknXV0pOyAvLyBFRDI1NTE5OiAweDAwLFxuICAgIHRtcC5zZXQocHViQnVmLCAxKTtcbiAgICByZXR1cm4gbm9ybWFsaXplU3VpQWRkcmVzcyhcbiAgICAgIGJsYWtlMmIoUFVCTElDX0tFWV9TSVpFKVxuICAgICAgICAudXBkYXRlKHRtcClcbiAgICAgICAgLmRpZ2VzdCgnaGV4JylcbiAgICAgICAgLnNsaWNlKDAsIFNVSV9BRERSRVNTX0xFTkdUSCAqIDIpXG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCB1dGlscyA9IG5ldyBVdGlscygpO1xuZXhwb3J0IGRlZmF1bHQgdXRpbHM7XG5cbmV4cG9ydCBlbnVtIEFwcElkIHtcbiAgU3VpID0gMCxcbn1cblxuZXhwb3J0IGVudW0gSW50ZW50VmVyc2lvbiB7XG4gIFYwID0gMCxcbn1cblxuZXhwb3J0IGVudW0gSW50ZW50U2NvcGUge1xuICBUcmFuc2FjdGlvbkRhdGEgPSAwLFxuICBUcmFuc2FjdGlvbkVmZmVjdHMgPSAxLFxuICBDaGVja3BvaW50U3VtbWFyeSA9IDIsXG4gIFBlcnNvbmFsTWVzc2FnZSA9IDMsXG59XG5cbmV4cG9ydCB0eXBlIEludGVudCA9IFtJbnRlbnRTY29wZSwgSW50ZW50VmVyc2lvbiwgQXBwSWRdO1xuIl19