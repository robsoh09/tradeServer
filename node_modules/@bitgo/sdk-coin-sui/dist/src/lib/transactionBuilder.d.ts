/// <reference types="node" />
import { BaseAddress, BaseKey, BaseTransactionBuilder, PublicKey as BasePublicKey, Recipient, Signature, TransactionType } from '@bitgo/sdk-core';
import { Transaction } from './transaction';
import BigNumber from 'bignumber.js';
import { BaseCoin as CoinConfig } from '@bitgo/statics';
import { StakingProgrammableTransaction, SuiTransactionType, TransferProgrammableTransaction, TxData } from './iface';
import { KeyPair } from './keyPair';
import { GasData, SuiObjectRef } from './mystenlab/types';
export declare abstract class TransactionBuilder<T = TransferProgrammableTransaction | StakingProgrammableTransaction> extends BaseTransactionBuilder {
    protected _transaction: Transaction<T>;
    protected _signatures: Signature[];
    protected _signer: KeyPair;
    protected _type: SuiTransactionType;
    protected _sender: string;
    protected _gasData: GasData;
    protected constructor(_coinConfig: Readonly<CoinConfig>);
    /**
     * The transaction type.
     */
    protected abstract get transactionType(): TransactionType;
    /** @inheritdoc */
    protected get transaction(): Transaction<T>;
    /** @inheritdoc */
    protected set transaction(transaction: Transaction<T>);
    /** @inheritdoc */
    protected signImplementation(key: BaseKey): Transaction<T>;
    /** @inheritDoc */
    addSignature(publicKey: BasePublicKey, signature: Buffer): void;
    /**
     * Sets the sender of this transaction.
     * This account will be responsible for paying transaction fees.
     *
     * @param {string} senderAddress the account that is sending this transaction
     * @returns {TransactionBuilder} This transaction builder
     */
    sender(senderAddress: string): this;
    type(type: SuiTransactionType): this;
    gasData(gasData: GasData): this;
    /**
     * Initialize the transaction builder fields using the decoded transaction data
     *
     * @param {Transaction} tx the transaction data
     */
    abstract initBuilder(tx: Transaction<T>): void;
    /** @inheritdoc */
    validateAddress(address: BaseAddress, addressFormat?: string): void;
    validateRecipients(recipients: Recipient[]): void;
    validateGasData(gasData: GasData): void;
    validateGasBudget(gasBudget: number): void;
    validateGasPrice(gasPrice: number): void;
    validateGasPayment(payments: SuiObjectRef[]): void;
    validateSuiObjectRef(suiObjectRef: SuiObjectRef, field: string): void;
    /** @inheritdoc */
    validateKey(key: BaseKey): void;
    /** @inheritdoc */
    validateRawTransaction(rawTransaction: string): void;
    /** @inheritdoc */
    validateValue(value: BigNumber): void;
    /**
     * When building transactions with > 255 input gas payment objects, we first use MergeCoins Tranasactions to merge the
     * additional inputs into the gas coin & slice them from the payment in gasData. When initializing the builder using
     * decoded tx data, we need to get these inputs from MergeCoins & add them back to the gas payment to be able to
     * rebuild from a raw transaction.
     */
    protected getInputGasPaymentObjectsFromTxData(txData: TxData): SuiObjectRef[];
}
//# sourceMappingURL=transactionBuilder.d.ts.map