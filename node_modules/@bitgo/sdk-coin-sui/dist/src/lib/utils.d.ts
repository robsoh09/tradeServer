import { BaseUtils, Recipient, TransactionType } from '@bitgo/sdk-core';
import { CustomProgrammableTransaction, RequestAddStake, StakingProgrammableTransaction, SuiTransaction, SuiTransactionType, TransferProgrammableTransaction, UnstakingProgrammableTransaction } from './iface';
import { SuiJsonValue, SuiObjectRef } from './mystenlab/types';
import { ObjectCallArg, TransactionBlockInput, TransactionType as TransactionCommandType } from './mystenlab/builder';
export declare function isImmOrOwnedObj(obj: ObjectCallArg['Object']): obj is {
    ImmOrOwned: SuiObjectRef;
};
export declare class Utils implements BaseUtils {
    /** @inheritdoc */
    isValidBlockId(hash: string): boolean;
    /** @inheritdoc */
    isValidPrivateKey(key: string): boolean;
    /** @inheritdoc */
    isValidPublicKey(key: string): boolean;
    /** @inheritdoc */
    isValidSignature(signature: string): boolean;
    /** @inheritdoc */
    isValidTransactionId(txId: string): boolean;
    /**
     * Checks if raw transaction can be deserialized
     *
     * @param {string} rawTransaction - transaction in base64 string format
     * @returns {boolean} - the validation result
     */
    isValidRawTransaction(rawTransaction: string): boolean;
    /**
     * Check the raw transaction has a valid format in the blockchain context, throw otherwise.
     *
     * @param {string} rawTransaction - Transaction in base64 string  format
     */
    validateRawTransaction(rawTransaction: string): void;
    /**
     * Validates addresses to check if all exist and are valid Sui public keys
     *
     * @param {string} addresses The address to be validated
     * @param {string} fieldName Name of the field to validate, its needed to return which field is failing on case of error.
     */
    validateAddresses(addresses: string[], fieldName: string): void;
    /**
     * Validates address to check if it exists and is a valid Sui public key
     *
     * @param {string} address The address to be validated
     * @param {string} fieldName Name of the field to validate, its needed to return which field is failing on case of error.
     */
    validateAddress(address: string, fieldName: string): void;
    /** @inheritdoc */
    isValidAddress(address: string): boolean;
    isHex(value: string): boolean;
    getHexByteLength(value: string): number;
    /**
     * Returns whether or not the string is a valid amount
     *
     * @param {number[]} amounts - the amounts to validate
     * @returns {boolean} - the validation result
     */
    isValidAmounts(amounts: number[]): boolean;
    /**
     * Returns whether or not the string is a valid amount
     *
     * @param {number} amounts - the amount to validate
     * @returns {boolean} - the validation result
     */
    isValidAmount(amount: string | number): boolean;
    /**
     * Normalizes hex ids (addresses, object ids) to always contain the '0x' prefix.
     *
     * @param {string} id
     * @return {string}
     **/
    normalizeHexId(id: string): string;
    /**
     * Get transaction type by function name
     *
     * @param {MethodNames} fctName
     * @return {TransactionType}
     */
    getTransactionType(suiTransactionType: SuiTransactionType): TransactionType;
    /**
     * Get SUI transaction type
     *
     * @param {MethodNames} fctName
     * @return {TransactionType}
     */
    getSuiTransactionType(command: TransactionCommandType): SuiTransactionType;
    getRecipients(tx: SuiTransaction<TransferProgrammableTransaction | StakingProgrammableTransaction | UnstakingProgrammableTransaction | CustomProgrammableTransaction>): Recipient[];
    /**
     * Get add staking requests
     *
     * @param {StakingProgrammableTransaction} tx: staking transaction object
     * @return {RequestAddStake[]}  add staking requests
     */
    getStakeRequests(tx: StakingProgrammableTransaction): RequestAddStake[];
    getAmount(input: SuiJsonValue | TransactionBlockInput): number;
    getAddress(input: TransactionBlockInput): string;
    normalizeCoins(coins: any[]): SuiObjectRef[];
    normalizeSuiObjectRef(obj: SuiObjectRef): SuiObjectRef;
    transactionInput(type: 'object' | 'pure', index?: number, value?: unknown): TransactionBlockInput;
    getAddressFromPublicKey(publicKey: string): string;
}
declare const utils: Utils;
export default utils;
export declare enum AppId {
    Sui = 0
}
export declare enum IntentVersion {
    V0 = 0
}
export declare enum IntentScope {
    TransactionData = 0,
    TransactionEffects = 1,
    CheckpointSummary = 2,
    PersonalMessage = 3
}
export declare type Intent = [IntentScope, IntentVersion, AppId];
//# sourceMappingURL=utils.d.ts.map