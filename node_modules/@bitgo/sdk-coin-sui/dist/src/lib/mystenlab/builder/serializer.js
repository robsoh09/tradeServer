"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPureSerializationType = exports.isTxContext = void 0;
const types_1 = require("../types");
const STD_ASCII_MODULE_NAME = 'ascii';
const STD_ASCII_STRUCT_NAME = 'String';
const STD_UTF8_MODULE_NAME = 'string';
const STD_UTF8_STRUCT_NAME = 'String';
const STD_OPTION_MODULE_NAME = 'option';
const STD_OPTION_STRUCT_NAME = 'Option';
const RESOLVED_SUI_ID = {
    address: types_1.SUI_FRAMEWORK_ADDRESS,
    module: types_1.OBJECT_MODULE_NAME,
    name: types_1.ID_STRUCT_NAME,
};
const RESOLVED_ASCII_STR = {
    address: types_1.MOVE_STDLIB_ADDRESS,
    module: STD_ASCII_MODULE_NAME,
    name: STD_ASCII_STRUCT_NAME,
};
const RESOLVED_UTF8_STR = {
    address: types_1.MOVE_STDLIB_ADDRESS,
    module: STD_UTF8_MODULE_NAME,
    name: STD_UTF8_STRUCT_NAME,
};
const RESOLVED_STD_OPTION = {
    address: types_1.MOVE_STDLIB_ADDRESS,
    module: STD_OPTION_MODULE_NAME,
    name: STD_OPTION_STRUCT_NAME,
};
const isSameStruct = (a, b) => a.address === b.address && a.module === b.module && a.name === b.name;
function isTxContext(param) {
    var _a;
    const struct = (_a = (0, types_1.extractStructTag)(param)) === null || _a === void 0 ? void 0 : _a.Struct;
    return (struct === null || struct === void 0 ? void 0 : struct.address) === '0x2' && (struct === null || struct === void 0 ? void 0 : struct.module) === 'tx_context' && (struct === null || struct === void 0 ? void 0 : struct.name) === 'TxContext';
}
exports.isTxContext = isTxContext;
function expectType(typeName, argVal) {
    if (typeof argVal === 'undefined') {
        return;
    }
    if (typeof argVal !== typeName) {
        throw new Error(`Expect ${argVal} to be ${typeName}, received ${typeof argVal}`);
    }
}
const allowedTypes = ['Address', 'Bool', 'U8', 'U16', 'U32', 'U64', 'U128', 'U256'];
function getPureSerializationType(normalizedType, argVal) {
    if (typeof normalizedType === 'string' && allowedTypes.includes(normalizedType)) {
        if (normalizedType in ['U8', 'U16', 'U32', 'U64', 'U128', 'U256']) {
            expectType('number', argVal);
        }
        else if (normalizedType === 'Bool') {
            expectType('boolean', argVal);
        }
        else if (normalizedType === 'Address') {
            expectType('string', argVal);
            if (argVal && !(0, types_1.isValidSuiAddress)(argVal)) {
                throw new Error('Invalid Sui Address');
            }
        }
        return normalizedType.toLowerCase();
    }
    else if (typeof normalizedType === 'string') {
        throw new Error(`Unknown pure normalized type ${JSON.stringify(normalizedType, null, 2)}`);
    }
    if ('Vector' in normalizedType) {
        if ((argVal === undefined || typeof argVal === 'string') && normalizedType.Vector === 'U8') {
            return 'string';
        }
        if (argVal !== undefined && !Array.isArray(argVal)) {
            throw new Error(`Expect ${argVal} to be a array, received ${typeof argVal}`);
        }
        const innerType = getPureSerializationType(normalizedType.Vector, 
        // undefined when argVal is empty
        argVal ? argVal[0] : undefined);
        if (innerType === undefined) {
            return;
        }
        return `vector<${innerType}>`;
    }
    if ('Struct' in normalizedType) {
        if (isSameStruct(normalizedType.Struct, RESOLVED_ASCII_STR)) {
            return 'string';
        }
        else if (isSameStruct(normalizedType.Struct, RESOLVED_UTF8_STR)) {
            return 'utf8string';
        }
        else if (isSameStruct(normalizedType.Struct, RESOLVED_SUI_ID)) {
            return 'address';
        }
        else if (isSameStruct(normalizedType.Struct, RESOLVED_STD_OPTION)) {
            const optionToVec = {
                Vector: normalizedType.Struct.typeArguments[0],
            };
            return getPureSerializationType(optionToVec, argVal);
        }
    }
    return undefined;
}
exports.getPureSerializationType = getPureSerializationType;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VyaWFsaXplci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvbXlzdGVubGFiL2J1aWxkZXIvc2VyaWFsaXplci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxvQ0FTa0I7QUFFbEIsTUFBTSxxQkFBcUIsR0FBRyxPQUFPLENBQUM7QUFDdEMsTUFBTSxxQkFBcUIsR0FBRyxRQUFRLENBQUM7QUFFdkMsTUFBTSxvQkFBb0IsR0FBRyxRQUFRLENBQUM7QUFDdEMsTUFBTSxvQkFBb0IsR0FBRyxRQUFRLENBQUM7QUFFdEMsTUFBTSxzQkFBc0IsR0FBRyxRQUFRLENBQUM7QUFDeEMsTUFBTSxzQkFBc0IsR0FBRyxRQUFRLENBQUM7QUFFeEMsTUFBTSxlQUFlLEdBQUc7SUFDdEIsT0FBTyxFQUFFLDZCQUFxQjtJQUM5QixNQUFNLEVBQUUsMEJBQWtCO0lBQzFCLElBQUksRUFBRSxzQkFBYztDQUNyQixDQUFDO0FBQ0YsTUFBTSxrQkFBa0IsR0FBRztJQUN6QixPQUFPLEVBQUUsMkJBQW1CO0lBQzVCLE1BQU0sRUFBRSxxQkFBcUI7SUFDN0IsSUFBSSxFQUFFLHFCQUFxQjtDQUM1QixDQUFDO0FBQ0YsTUFBTSxpQkFBaUIsR0FBRztJQUN4QixPQUFPLEVBQUUsMkJBQW1CO0lBQzVCLE1BQU0sRUFBRSxvQkFBb0I7SUFDNUIsSUFBSSxFQUFFLG9CQUFvQjtDQUMzQixDQUFDO0FBRUYsTUFBTSxtQkFBbUIsR0FBRztJQUMxQixPQUFPLEVBQUUsMkJBQW1CO0lBQzVCLE1BQU0sRUFBRSxzQkFBc0I7SUFDOUIsSUFBSSxFQUFFLHNCQUFzQjtDQUM3QixDQUFDO0FBRUYsTUFBTSxZQUFZLEdBQUcsQ0FBQyxDQUFNLEVBQUUsQ0FBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxLQUFLLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsTUFBTSxJQUFJLENB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SSxTQUFTLEtBQUssU0FBUyxFQUFFO1lBQzNCLE9BQU87U0FDUjtRQUVELE9BQU8sVUFBVSxTQUFTLEdBQUcsQ0FBQztLQUMvQjtJQUVELElBQUksUUFBUSxJQUFJLGNBQWMsRUFBRTtRQUM5QixJQUFJLFlBQVksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLGtCQUFrQixDQUFDLEVBQUU7WUFDM0QsT0FBTyxRQUFRLENBQUM7U0FDakI7YUFBTSxJQUFJLFlBQVksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLGlCQUFpQixDQUFDLEVBQUU7WUFDakUsT0FBTyxZQUFZLENBQUM7U0FDckI7YUFBTSxJQUFJLFlBQVksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLGVBQWUsQ0FBQyxFQUFFO1lBQy9ELE9BQU8sU0FBUyxDQUFDO1NBQ2xCO2FBQU0sSUFBSSxZQUFZLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxFQUFFO1lBQ25FLE1BQU0sV0FBVyxHQUEwQjtnQkFDekMsTUFBTSxFQUFFLGNBQWMsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQzthQUMvQyxDQUFDO1lBQ0YsT0FBTyx3QkFBd0IsQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDdEQ7S0FDRjtJQUVELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUExREQsNERBMERDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgZXh0cmFjdFN0cnVjdFRhZyxcbiAgSURfU1RSVUNUX05BTUUsXG4gIGlzVmFsaWRTdWlBZGRyZXNzLFxuICBNT1ZFX1NURExJQl9BRERSRVNTLFxuICBPQkpFQ1RfTU9EVUxFX05BTUUsXG4gIFN1aUpzb25WYWx1ZSxcbiAgU3VpTW92ZU5vcm1hbGl6ZWRUeXBlLFxuICBTVUlfRlJBTUVXT1JLX0FERFJFU1MsXG59IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgU1REX0FTQ0lJX01PRFVMRV9OQU1FID0gJ2FzY2lpJztcbmNvbnN0IFNURF9BU0NJSV9TVFJVQ1RfTkFNRSA9ICdTdHJpbmcnO1xuXG5jb25zdCBTVERfVVRGOF9NT0RVTEVfTkFNRSA9ICdzdHJpbmcnO1xuY29uc3QgU1REX1VURjhfU1RSVUNUX05BTUUgPSAnU3RyaW5nJztcblxuY29uc3QgU1REX09QVElPTl9NT0RVTEVfTkFNRSA9ICdvcHRpb24nO1xuY29uc3QgU1REX09QVElPTl9TVFJVQ1RfTkFNRSA9ICdPcHRpb24nO1xuXG5jb25zdCBSRVNPTFZFRF9TVUlfSUQgPSB7XG4gIGFkZHJlc3M6IFNVSV9GUkFNRVdPUktfQUREUkVTUyxcbiAgbW9kdWxlOiBPQkpFQ1RfTU9EVUxFX05BTUUsXG4gIG5hbWU6IElEX1NUUlVDVF9OQU1FLFxufTtcbmNvbnN0IFJFU09MVkVEX0FTQ0lJX1NUUiA9IHtcbiAgYWRkcmVzczogTU9WRV9TVERMSUJfQUREUkVTUyxcbiAgbW9kdWxlOiBTVERfQVNDSUlfTU9EVUxFX05BTUUsXG4gIG5hbWU6IFNURF9BU0NJSV9TVFJVQ1RfTkFNRSxcbn07XG5jb25zdCBSRVNPTFZFRF9VVEY4X1NUUiA9IHtcbiAgYWRkcmVzczogTU9WRV9TVERMSUJfQUREUkVTUyxcbiAgbW9kdWxlOiBTVERfVVRGOF9NT0RVTEVfTkFNRSxcbiAgbmFtZTogU1REX1VURjhfU1RSVUNUX05BTUUsXG59O1xuXG5jb25zdCBSRVNPTFZFRF9TVERfT1BUSU9OID0ge1xuICBhZGRyZXNzOiBNT1ZFX1NURExJQl9BRERSRVNTLFxuICBtb2R1bGU6IFNURF9PUFRJT05fTU9EVUxFX05BTUUsXG4gIG5hbWU6IFNURF9PUFRJT05fU1RSVUNUX05BTUUsXG59O1xuXG5jb25zdCBpc1NhbWVTdHJ1Y3QgPSAoYTogYW55LCBiOiBhbnkpID0+IGEuYWRkcmVzcyA9PT0gYi5hZGRyZXNzICYmIGEubW9kdWxlID09PSBiLm1vZHVsZSAmJiBhLm5hbWUgPT09IGIubmFtZTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVHhDb250ZXh0KHBhcmFtOiBTdWlNb3ZlTm9ybWFsaXplZFR5cGUpOiBib29sZWFuIHtcbiAgY29uc3Qgc3RydWN0ID0gZXh0cmFjdFN0cnVjdFRhZyhwYXJhbSk/LlN0cnVjdDtcbiAgcmV0dXJuIHN0cnVjdD8uYWRkcmVzcyA9PT0gJzB4MicgJiYgc3RydWN0Py5tb2R1bGUgPT09ICd0eF9jb250ZXh0JyAmJiBzdHJ1Y3Q/Lm5hbWUgPT09ICdUeENvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBleHBlY3RUeXBlKHR5cGVOYW1lOiBzdHJpbmcsIGFyZ1ZhbD86IFN1aUpzb25WYWx1ZSkge1xuICBpZiAodHlwZW9mIGFyZ1ZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBhcmdWYWwgIT09IHR5cGVOYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3QgJHthcmdWYWx9IHRvIGJlICR7dHlwZU5hbWV9LCByZWNlaXZlZCAke3R5cGVvZiBhcmdWYWx9YCk7XG4gIH1cbn1cblxuY29uc3QgYWxsb3dlZFR5cGVzID0gWydBZGRyZXNzJywgJ0Jvb2wnLCAnVTgnLCAnVTE2JywgJ1UzMicsICdVNjQnLCAnVTEyOCcsICdVMjU2J107XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQdXJlU2VyaWFsaXphdGlvblR5cGUoXG4gIG5vcm1hbGl6ZWRUeXBlOiBTdWlNb3ZlTm9ybWFsaXplZFR5cGUsXG4gIGFyZ1ZhbDogU3VpSnNvblZhbHVlIHwgdW5kZWZpbmVkXG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAodHlwZW9mIG5vcm1hbGl6ZWRUeXBlID09PSAnc3RyaW5nJyAmJiBhbGxvd2VkVHlwZXMuaW5jbHVkZXMobm9ybWFsaXplZFR5cGUpKSB7XG4gICAgaWYgKG5vcm1hbGl6ZWRUeXBlIGluIFsnVTgnLCAnVTE2JywgJ1UzMicsICdVNjQnLCAnVTEyOCcsICdVMjU2J10pIHtcbiAgICAgIGV4cGVjdFR5cGUoJ251bWJlcicsIGFyZ1ZhbCk7XG4gICAgfSBlbHNlIGlmIChub3JtYWxpemVkVHlwZSA9PT0gJ0Jvb2wnKSB7XG4gICAgICBleHBlY3RUeXBlKCdib29sZWFuJywgYXJnVmFsKTtcbiAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRUeXBlID09PSAnQWRkcmVzcycpIHtcbiAgICAgIGV4cGVjdFR5cGUoJ3N0cmluZycsIGFyZ1ZhbCk7XG4gICAgICBpZiAoYXJnVmFsICYmICFpc1ZhbGlkU3VpQWRkcmVzcyhhcmdWYWwgYXMgc3RyaW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgU3VpIEFkZHJlc3MnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vcm1hbGl6ZWRUeXBlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwdXJlIG5vcm1hbGl6ZWQgdHlwZSAke0pTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRUeXBlLCBudWxsLCAyKX1gKTtcbiAgfVxuXG4gIGlmICgnVmVjdG9yJyBpbiBub3JtYWxpemVkVHlwZSkge1xuICAgIGlmICgoYXJnVmFsID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGFyZ1ZhbCA9PT0gJ3N0cmluZycpICYmIG5vcm1hbGl6ZWRUeXBlLlZlY3RvciA9PT0gJ1U4Jykge1xuICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIH1cblxuICAgIGlmIChhcmdWYWwgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShhcmdWYWwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdCAke2FyZ1ZhbH0gdG8gYmUgYSBhcnJheSwgcmVjZWl2ZWQgJHt0eXBlb2YgYXJnVmFsfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGlubmVyVHlwZSA9IGdldFB1cmVTZXJpYWxpemF0aW9uVHlwZShcbiAgICAgIG5vcm1hbGl6ZWRUeXBlLlZlY3RvcixcbiAgICAgIC8vIHVuZGVmaW5lZCB3aGVuIGFyZ1ZhbCBpcyBlbXB0eVxuICAgICAgYXJnVmFsID8gYXJnVmFsWzBdIDogdW5kZWZpbmVkXG4gICAgKTtcblxuICAgIGlmIChpbm5lclR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBgdmVjdG9yPCR7aW5uZXJUeXBlfT5gO1xuICB9XG5cbiAgaWYgKCdTdHJ1Y3QnIGluIG5vcm1hbGl6ZWRUeXBlKSB7XG4gICAgaWYgKGlzU2FtZVN0cnVjdChub3JtYWxpemVkVHlwZS5TdHJ1Y3QsIFJFU09MVkVEX0FTQ0lJX1NUUikpIHtcbiAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICB9IGVsc2UgaWYgKGlzU2FtZVN0cnVjdChub3JtYWxpemVkVHlwZS5TdHJ1Y3QsIFJFU09MVkVEX1VURjhfU1RSKSkge1xuICAgICAgcmV0dXJuICd1dGY4c3RyaW5nJztcbiAgICB9IGVsc2UgaWYgKGlzU2FtZVN0cnVjdChub3JtYWxpemVkVHlwZS5TdHJ1Y3QsIFJFU09MVkVEX1NVSV9JRCkpIHtcbiAgICAgIHJldHVybiAnYWRkcmVzcyc7XG4gICAgfSBlbHNlIGlmIChpc1NhbWVTdHJ1Y3Qobm9ybWFsaXplZFR5cGUuU3RydWN0LCBSRVNPTFZFRF9TVERfT1BUSU9OKSkge1xuICAgICAgY29uc3Qgb3B0aW9uVG9WZWM6IFN1aU1vdmVOb3JtYWxpemVkVHlwZSA9IHtcbiAgICAgICAgVmVjdG9yOiBub3JtYWxpemVkVHlwZS5TdHJ1Y3QudHlwZUFyZ3VtZW50c1swXSxcbiAgICAgIH07XG4gICAgICByZXR1cm4gZ2V0UHVyZVNlcmlhbGl6YXRpb25UeXBlKG9wdGlvblRvVmVjLCBhcmdWYWwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iXX0=