"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBlockDataBuilder = exports.TRANSACTION_DATA_MAX_SIZE = exports.SerializedTransactionDataBuilder = exports.TransactionExpiration = void 0;
const bcs_1 = require("@mysten/bcs");
const superstruct_1 = require("superstruct");
const hash_1 = require("../cryptography/hash");
const types_1 = require("../types");
const bcs_2 = require("./bcs");
const Transactions_1 = require("./Transactions");
const Inputs_1 = require("./Inputs");
const utils_1 = require("./utils");
exports.TransactionExpiration = (0, superstruct_1.optional)((0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.object)({ Epoch: (0, superstruct_1.integer)() }), (0, superstruct_1.object)({ None: (0, superstruct_1.union)([(0, superstruct_1.literal)(true), (0, superstruct_1.literal)(null)]) })])));
const SuiAddress = (0, superstruct_1.string)();
const StringEncodedBigint = (0, superstruct_1.define)('StringEncodedBigint', (val) => {
    if (!['string', 'number', 'bigint'].includes(typeof val))
        return false;
    try {
        BigInt(val);
        return true;
    }
    catch {
        return false;
    }
});
const GasConfig = (0, superstruct_1.object)({
    budget: (0, superstruct_1.optional)(StringEncodedBigint),
    price: (0, superstruct_1.optional)(StringEncodedBigint),
    payment: (0, superstruct_1.optional)((0, superstruct_1.array)(types_1.SuiObjectRef)),
    owner: (0, superstruct_1.optional)(SuiAddress),
});
exports.SerializedTransactionDataBuilder = (0, superstruct_1.object)({
    version: (0, superstruct_1.literal)(1),
    sender: (0, superstruct_1.optional)(SuiAddress),
    expiration: exports.TransactionExpiration,
    gasConfig: GasConfig,
    inputs: (0, superstruct_1.array)(Transactions_1.TransactionBlockInput),
    transactions: (0, superstruct_1.array)(Transactions_1.TransactionType),
});
function prepareSuiAddress(address) {
    return (0, types_1.normalizeSuiAddress)(address).replace('0x', '');
}
// NOTE: This value should be kept in sync with the corresponding value in
// crates/sui-protocol-config/src/lib.rs
exports.TRANSACTION_DATA_MAX_SIZE = 128 * 1024;
class TransactionBlockDataBuilder {
    constructor(clone) {
        var _a, _b, _c;
        this.version = 1;
        this.sender = clone === null || clone === void 0 ? void 0 : clone.sender;
        this.expiration = clone === null || clone === void 0 ? void 0 : clone.expiration;
        this.gasConfig = (_a = clone === null || clone === void 0 ? void 0 : clone.gasConfig) !== null && _a !== void 0 ? _a : {};
        this.inputs = (_b = clone === null || clone === void 0 ? void 0 : clone.inputs) !== null && _b !== void 0 ? _b : [];
        this.transactions = (_c = clone === null || clone === void 0 ? void 0 : clone.transactions) !== null && _c !== void 0 ? _c : [];
    }
    static fromKindBytes(bytes) {
        const kind = bcs_2.builder.de('TransactionKind', bytes);
        const programmableTx = kind === null || kind === void 0 ? void 0 : kind.ProgrammableTransaction;
        if (!programmableTx) {
            throw new Error('Unable to deserialize from bytes.');
        }
        const serialized = (0, utils_1.create)({
            version: 1,
            gasConfig: {},
            inputs: programmableTx.inputs.map((value, index) => (0, utils_1.create)({
                kind: 'Input',
                value,
                index,
                type: (0, superstruct_1.is)(value, Inputs_1.PureCallArg) ? 'pure' : 'object',
            }, Transactions_1.TransactionBlockInput)),
            transactions: programmableTx.transactions,
        }, exports.SerializedTransactionDataBuilder);
        return TransactionBlockDataBuilder.restore(serialized);
    }
    static fromBytes(bytes) {
        var _a;
        const rawData = bcs_2.builder.de('TransactionData', bytes);
        const data = rawData === null || rawData === void 0 ? void 0 : rawData.V1;
        const programmableTx = (_a = data === null || data === void 0 ? void 0 : data.kind) === null || _a === void 0 ? void 0 : _a.ProgrammableTransaction;
        if (!data || !programmableTx) {
            throw new Error('Unable to deserialize from bytes.');
        }
        const serialized = (0, utils_1.create)({
            version: 1,
            sender: data.sender,
            expiration: data.expiration,
            gasConfig: data.gasData,
            inputs: programmableTx.inputs.map((value, index) => (0, utils_1.create)({
                kind: 'Input',
                value,
                index,
                type: (0, superstruct_1.is)(value, Inputs_1.PureCallArg) ? 'pure' : 'object',
            }, Transactions_1.TransactionBlockInput)),
            transactions: programmableTx.transactions,
        }, exports.SerializedTransactionDataBuilder);
        return TransactionBlockDataBuilder.restore(serialized);
    }
    static restore(data) {
        (0, superstruct_1.assert)(data, exports.SerializedTransactionDataBuilder);
        const transactionData = new TransactionBlockDataBuilder();
        Object.assign(transactionData, data);
        return transactionData;
    }
    /**
     * Generate transaction digest.
     *
     * @param bytes BCS serialized transaction data
     * @returns transaction digest.
     */
    static getDigestFromBytes(bytes) {
        const hash = (0, hash_1.hashTypedData)('TransactionData', bytes);
        return (0, bcs_1.toB58)(hash);
    }
    build({ overrides, onlyTransactionKind, } = {}) {
        var _a, _b, _c;
        // Resolve inputs down to values:
        const inputs = this.inputs.map((input) => {
            (0, superstruct_1.assert)(input.value, Inputs_1.BuilderCallArg);
            return input.value;
        });
        const kind = {
            ProgrammableTransaction: {
                inputs,
                transactions: this.transactions,
            },
        };
        if (onlyTransactionKind) {
            return bcs_2.builder.ser('TransactionKind', kind, { maxSize: exports.TRANSACTION_DATA_MAX_SIZE }).toBytes();
        }
        const expiration = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.expiration) !== null && _a !== void 0 ? _a : this.expiration;
        const sender = (_b = overrides === null || overrides === void 0 ? void 0 : overrides.sender) !== null && _b !== void 0 ? _b : this.sender;
        const gasConfig = { ...this.gasConfig, ...overrides === null || overrides === void 0 ? void 0 : overrides.gasConfig };
        if (!sender) {
            throw new Error('Missing transaction sender');
        }
        if (!gasConfig.budget) {
            throw new Error('Missing gas budget');
        }
        if (!gasConfig.payment) {
            throw new Error('Missing gas payment');
        }
        if (!gasConfig.price) {
            throw new Error('Missing gas price');
        }
        const transactionData = {
            sender: prepareSuiAddress(sender),
            expiration: expiration ? expiration : { None: true },
            gasData: {
                payment: gasConfig.payment,
                owner: prepareSuiAddress((_c = this.gasConfig.owner) !== null && _c !== void 0 ? _c : sender),
                price: BigInt(gasConfig.price),
                budget: BigInt(gasConfig.budget),
            },
            kind: {
                ProgrammableTransaction: {
                    inputs,
                    transactions: this.transactions,
                },
            },
        };
        return bcs_2.builder.ser('TransactionData', { V1: transactionData }, { maxSize: exports.TRANSACTION_DATA_MAX_SIZE }).toBytes();
    }
    getDigest() {
        const bytes = this.build({ onlyTransactionKind: false });
        return TransactionBlockDataBuilder.getDigestFromBytes(bytes);
    }
    snapshot() {
        return (0, utils_1.create)(this, exports.SerializedTransactionDataBuilder);
    }
}
exports.TransactionBlockDataBuilder = TransactionBlockDataBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHJhbnNhY3Rpb25EYXRhQmxvY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL215c3RlbmxhYi9idWlsZGVyL1RyYW5zYWN0aW9uRGF0YUJsb2NrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHFDQUFvQztBQUNwQyw2Q0FhcUI7QUFDckIsK0NBQXFEO0FBQ3JELG9DQUE2RDtBQUM3RCwrQkFBZ0M7QUFDaEMsaURBQXdFO0FBQ3hFLHFDQUF1RDtBQUN2RCxtQ0FBaUM7QUFFcEIsUUFBQSxxQkFBcUIsR0FBRyxJQUFBLHNCQUFRLEVBQzNDLElBQUEsc0JBQVEsRUFBQyxJQUFBLG1CQUFLLEVBQUMsQ0FBQyxJQUFBLG9CQUFNLEVBQUMsRUFBRSxLQUFLLEVBQUUsSUFBQSxxQkFBTyxHQUFFLEVBQUUsQ0FBQyxFQUFFLElBQUEsb0JBQU0sRUFBQyxFQUFFLElBQUksRUFBRSxJQUFBLG1CQUFLLEVBQUMsQ0FBQyxJQUFBLHFCQUFPLEVBQUMsSUFBSSxDQUFDLEVBQUUsSUFBQSxxQkFBTyxFQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ3pHLENBQUM7QUFHRixNQUFNLFVBQVUsR0FBRyxJQUFBLG9CQUFNLEdBQUUsQ0FBQztBQUU1QixNQUFNLG1CQUFtQixHQUFHLElBQUEsb0JBQU0sRUFBUyxxQkFBcUIsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFO0lBQ3hFLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sR0FBRyxDQUFDO1FBQUUsT0FBTyxLQUFLLENBQUM7SUFFdkUsSUFBSTtRQUNGLE1BQU0sQ0FBQyxHQUFhLENBQUMsQ0FBQztRQUN0QixPQUFPLElBQUksQ0FBQztLQUNiO0lBQUMsTUFBTTtRQUNOLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7QUFDSCxDQUFDLENBQUMsQ0FBQztB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LENBQUM7YUFDakM7WUFDRCxJQUFJLEVBQUU7Z0JBQ0osdUJBQXVCLEVBQUU7b0JBQ3ZCLE1BQU07b0JBQ04sWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZO2lCQUNoQzthQUNGO1NBQ0YsQ0FBQztRQUVGLE9BQU8sYUFBTyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLEVBQUUsRUFBRSxlQUFlLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxpQ0FBeUIsRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDbkgsQ0FBQztJQUVELFNBQVM7UUFDUCxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsbUJBQW1CLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUN6RCxPQUFPLDJCQUEyQixDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQy9ELENBQUM7SUFFRCxRQUFRO1FBQ04sT0FBTyxJQUFBLGNBQU0sRUFBQyxJQUFJLEVBQUUsd0NBQWdDLENBQUMsQ0FBQztJQUN4RCxDQUFDO0NBQ0Y7QUF6S0Qsa0VBeUtDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9CNTggfSBmcm9tICdAbXlzdGVuL2Jjcyc7XG5pbXBvcnQge1xuICBhcnJheSxcbiAgYXNzZXJ0LFxuICBkZWZpbmUsXG4gIEluZmVyLFxuICBpbnRlZ2VyLFxuICBpcyxcbiAgbGl0ZXJhbCxcbiAgbnVsbGFibGUsXG4gIG9iamVjdCxcbiAgb3B0aW9uYWwsXG4gIHN0cmluZyxcbiAgdW5pb24sXG59IGZyb20gJ3N1cGVyc3RydWN0JztcbmltcG9ydCB7IGhhc2hUeXBlZERhdGEgfSBmcm9tICcuLi9jcnlwdG9ncmFwaHkvaGFzaCc7XG5pbXBvcnQgeyBub3JtYWxpemVTdWlBZGRyZXNzLCBTdWlPYmplY3RSZWYgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBidWlsZGVyIH0gZnJvbSAnLi9iY3MnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25UeXBlLCBUcmFuc2FjdGlvbkJsb2NrSW5wdXQgfSBmcm9tICcuL1RyYW5zYWN0aW9ucyc7XG5pbXBvcnQgeyBCdWlsZGVyQ2FsbEFyZywgUHVyZUNhbGxBcmcgfSBmcm9tICcuL0lucHV0cyc7XG5pbXBvcnQgeyBjcmVhdGUgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IFRyYW5zYWN0aW9uRXhwaXJhdGlvbiA9IG9wdGlvbmFsKFxuICBudWxsYWJsZSh1bmlvbihbb2JqZWN0KHsgRXBvY2g6IGludGVnZXIoKSB9KSwgb2JqZWN0KHsgTm9uZTogdW5pb24oW2xpdGVyYWwodHJ1ZSksIGxpdGVyYWwobnVsbCldKSB9KV0pKVxuKTtcbmV4cG9ydCB0eXBlIFRyYW5zYWN0aW9uRXhwaXJhdGlvbiA9IEluZmVyPHR5cGVvZiBUcmFuc2FjdGlvbkV4cGlyYXRpb24+O1xuXG5jb25zdCBTdWlBZGRyZXNzID0gc3RyaW5nKCk7XG5cbmNvbnN0IFN0cmluZ0VuY29kZWRCaWdpbnQgPSBkZWZpbmU8c3RyaW5nPignU3RyaW5nRW5jb2RlZEJpZ2ludCcsICh2YWwpID0+IHtcbiAgaWYgKCFbJ3N0cmluZycsICdudW1iZXInLCAnYmlnaW50J10uaW5jbHVkZXModHlwZW9mIHZhbCkpIHJldHVybiBmYWxzZTtcblxuICB0cnkge1xuICAgIEJpZ0ludCh2YWwgYXMgc3RyaW5nKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KTtcblxuY29uc3QgR2FzQ29uZmlnID0gb2JqZWN0KHtcbiAgYnVkZ2V0OiBvcHRpb25hbChTdHJpbmdFbmNvZGVkQmlnaW50KSxcbiAgcHJpY2U6IG9wdGlvbmFsKFN0cmluZ0VuY29kZWRCaWdpbnQpLFxuICBwYXltZW50OiBvcHRpb25hbChhcnJheShTdWlPYmplY3RSZWYpKSxcbiAgb3duZXI6IG9wdGlvbmFsKFN1aUFkZHJlc3MpLFxufSk7XG50eXBlIEdhc0NvbmZpZyA9IEluZmVyPHR5cGVvZiBHYXNDb25maWc+O1xuXG5leHBvcnQgY29uc3QgU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YUJ1aWxkZXIgPSBvYmplY3Qoe1xuICB2ZXJzaW9uOiBsaXRlcmFsKDEpLFxuICBzZW5kZXI6IG9wdGlvbmFsKFN1aUFkZHJlc3MpLFxuICBleHBpcmF0aW9uOiBUcmFuc2FjdGlvbkV4cGlyYXRpb24sXG4gIGdhc0NvbmZpZzogR2FzQ29uZmlnLFxuICBpbnB1dHM6IGFycmF5KFRyYW5zYWN0aW9uQmxvY2tJbnB1dCksXG4gIHRyYW5zYWN0aW9uczogYXJyYXkoVHJhbnNhY3Rpb25UeXBlKSxcbn0pO1xuZXhwb3J0IHR5cGUgU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YUJ1aWxkZXIgPSBJbmZlcjx0eXBlb2YgU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YUJ1aWxkZXI+O1xuXG5mdW5jdGlvbiBwcmVwYXJlU3VpQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpIHtcbiAgcmV0dXJuIG5vcm1hbGl6ZVN1aUFkZHJlc3MoYWRkcmVzcykucmVwbGFjZSgnMHgnLCAnJyk7XG59XG5cbi8vIE5PVEU6IFRoaXMgdmFsdWUgc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGluXG4vLyBjcmF0ZXMvc3VpLXByb3RvY29sLWNvbmZpZy9zcmMvbGliLnJzXG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT05fREFUQV9NQVhfU0laRSA9IDEyOCAqIDEwMjQ7XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkJsb2NrRGF0YUJ1aWxkZXIge1xuICBzdGF0aWMgZnJvbUtpbmRCeXRlcyhieXRlczogVWludDhBcnJheSkge1xuICAgIGNvbnN0IGtpbmQgPSBidWlsZGVyLmRlKCdUcmFuc2FjdGlvbktpbmQnLCBieXRlcyk7XG4gICAgY29uc3QgcHJvZ3JhbW1hYmxlVHggPSBraW5kPy5Qcm9ncmFtbWFibGVUcmFuc2FjdGlvbjtcbiAgICBpZiAoIXByb2dyYW1tYWJsZVR4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZXNlcmlhbGl6ZSBmcm9tIGJ5dGVzLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBjcmVhdGUoXG4gICAgICB7XG4gICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgIGdhc0NvbmZpZzoge30sXG4gICAgICAgIGlucHV0czogcHJvZ3JhbW1hYmxlVHguaW5wdXRzLm1hcCgodmFsdWU6IHVua25vd24sIGluZGV4OiBudW1iZXIpID0+XG4gICAgICAgICAgY3JlYXRlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBraW5kOiAnSW5wdXQnLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgIHR5cGU6IGlzKHZhbHVlLCBQdXJlQ2FsbEFyZykgPyAncHVyZScgOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBUcmFuc2FjdGlvbkJsb2NrSW5wdXRcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIHRyYW5zYWN0aW9uczogcHJvZ3JhbW1hYmxlVHgudHJhbnNhY3Rpb25zLFxuICAgICAgfSxcbiAgICAgIFNlcmlhbGl6ZWRUcmFuc2FjdGlvbkRhdGFCdWlsZGVyXG4gICAgKTtcblxuICAgIHJldHVybiBUcmFuc2FjdGlvbkJsb2NrRGF0YUJ1aWxkZXIucmVzdG9yZShzZXJpYWxpemVkKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXM6IFVpbnQ4QXJyYXkpIHtcbiAgICBjb25zdCByYXdEYXRhID0gYnVpbGRlci5kZSgnVHJhbnNhY3Rpb25EYXRhJywgYnl0ZXMpO1xuICAgIGNvbnN0IGRhdGEgPSByYXdEYXRhPy5WMTtcbiAgICBjb25zdCBwcm9ncmFtbWFibGVUeCA9IGRhdGE/LmtpbmQ/LlByb2dyYW1tYWJsZVRyYW5zYWN0aW9uO1xuICAgIGlmICghZGF0YSB8fCAhcHJvZ3JhbW1hYmxlVHgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRlc2VyaWFsaXplIGZyb20gYnl0ZXMuJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IGNyZWF0ZShcbiAgICAgIHtcbiAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgc2VuZGVyOiBkYXRhLnNlbmRlcixcbiAgICAgICAgZXhwaXJhdGlvbjogZGF0YS5leHBpcmF0aW9uLFxuICAgICAgICBnYXNDb25maWc6IGRhdGEuZ2FzRGF0YSxcbiAgICAgICAgaW5wdXRzOiBwcm9ncmFtbWFibGVUeC5pbnB1dHMubWFwKCh2YWx1ZTogdW5rbm93biwgaW5kZXg6IG51bWJlcikgPT5cbiAgICAgICAgICBjcmVhdGUoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGtpbmQ6ICdJbnB1dCcsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgdHlwZTogaXModmFsdWUsIFB1cmVDYWxsQXJnKSA/ICdwdXJlJyA6ICdvYmplY3QnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFRyYW5zYWN0aW9uQmxvY2tJbnB1dFxuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBwcm9ncmFtbWFibGVUeC50cmFuc2FjdGlvbnMsXG4gICAgICB9LFxuICAgICAgU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YUJ1aWxkZXJcbiAgICApO1xuXG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uQmxvY2tEYXRhQnVpbGRlci5yZXN0b3JlKHNlcmlhbGl6ZWQpO1xuICB9XG5cbiAgc3RhdGljIHJlc3RvcmUoZGF0YTogU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YUJ1aWxkZXIpIHtcbiAgICBhc3NlcnQoZGF0YSwgU2VyaWFsaXplZFRyYW5zYWN0aW9uRGF0YUJ1aWxkZXIpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IG5ldyBUcmFuc2FjdGlvbkJsb2NrRGF0YUJ1aWxkZXIoKTtcbiAgICBPYmplY3QuYXNzaWduKHRyYW5zYWN0aW9uRGF0YSwgZGF0YSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uRGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSB0cmFuc2FjdGlvbiBkaWdlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBieXRlcyBCQ1Mgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBkYXRhXG4gICAqIEByZXR1cm5zIHRyYW5zYWN0aW9uIGRpZ2VzdC5cbiAgICovXG4gIHN0YXRpYyBnZXREaWdlc3RGcm9tQnl0ZXMoYnl0ZXM6IFVpbnQ4QXJyYXkpIHtcbiAgICBjb25zdCBoYXNoID0gaGFzaFR5cGVkRGF0YSgnVHJhbnNhY3Rpb25EYXRhJywgYnl0ZXMpO1xuICAgIHJldHVybiB0b0I1OChoYXNoKTtcbiAgfVxuXG4gIHZlcnNpb24gPSAxIGFzIGNvbnN0O1xuICBzZW5kZXI/OiBzdHJpbmc7XG4gIGV4cGlyYXRpb24/OiBUcmFuc2FjdGlvbkV4cGlyYXRpb247XG4gIGdhc0NvbmZpZzogR2FzQ29uZmlnO1xuICBpbnB1dHM6IFRyYW5zYWN0aW9uQmxvY2tJbnB1dFtdO1xuICB0cmFuc2FjdGlvbnM6IFRyYW5zYWN0aW9uVHlwZVtdO1xuXG4gIGNvbnN0cnVjdG9yKGNsb25lPzogVHJhbnNhY3Rpb25CbG9ja0RhdGFCdWlsZGVyKSB7XG4gICAgdGhpcy5zZW5kZXIgPSBjbG9uZT8uc2VuZGVyO1xuICAgIHRoaXMuZXhwaXJhdGlvbiA9IGNsb25lPy5leHBpcmF0aW9uO1xuICAgIHRoaXMuZ2FzQ29uZmlnID0gY2xvbmU/Lmdhc0NvbmZpZyA/PyB7fTtcbiAgICB0aGlzLmlucHV0cyA9IGNsb25lPy5pbnB1dHMgPz8gW107XG4gICAgdGhpcy50cmFuc2FjdGlvbnMgPSBjbG9uZT8udHJhbnNhY3Rpb25zID8/IFtdO1xuICB9XG5cbiAgYnVpbGQoe1xuICAgIG92ZXJyaWRlcyxcbiAgICBvbmx5VHJhbnNhY3Rpb25LaW5kLFxuICB9OiB7XG4gICAgb3ZlcnJpZGVzPzogUGljazxQYXJ0aWFsPFRyYW5zYWN0aW9uQmxvY2tEYXRhQnVpbGRlcj4sICdzZW5kZXInIHwgJ2dhc0NvbmZpZycgfCAnZXhwaXJhdGlvbic+O1xuICAgIG9ubHlUcmFuc2FjdGlvbktpbmQ/OiBib29sZWFuO1xuICB9ID0ge30pIHtcbiAgICAvLyBSZXNvbHZlIGlucHV0cyBkb3duIHRvIHZhbHVlczpcbiAgICBjb25zdCBpbnB1dHMgPSB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiB7XG4gICAgICBhc3NlcnQoaW5wdXQudmFsdWUsIEJ1aWxkZXJDYWxsQXJnKTtcbiAgICAgIHJldHVybiBpbnB1dC52YWx1ZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGtpbmQgPSB7XG4gICAgICBQcm9ncmFtbWFibGVUcmFuc2FjdGlvbjoge1xuICAgICAgICBpbnB1dHMsXG4gICAgICAgIHRyYW5zYWN0aW9uczogdGhpcy50cmFuc2FjdGlvbnMsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBpZiAob25seVRyYW5zYWN0aW9uS2luZCkge1xuICAgICAgcmV0dXJuIGJ1aWxkZXIuc2VyKCdUcmFuc2FjdGlvbktpbmQnLCBraW5kLCB7IG1heFNpemU6IFRSQU5TQUNUSU9OX0RBVEFfTUFYX1NJWkUgfSkudG9CeXRlcygpO1xuICAgIH1cblxuICAgIGNvbnN0IGV4cGlyYXRpb24gPSBvdmVycmlkZXM/LmV4cGlyYXRpb24gPz8gdGhpcy5leHBpcmF0aW9uO1xuICAgIGNvbnN0IHNlbmRlciA9IG92ZXJyaWRlcz8uc2VuZGVyID8/IHRoaXMuc2VuZGVyO1xuICAgIGNvbnN0IGdhc0NvbmZpZyA9IHsgLi4udGhpcy5nYXNDb25maWcsIC4uLm92ZXJyaWRlcz8uZ2FzQ29uZmlnIH07XG5cbiAgICBpZiAoIXNlbmRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHRyYW5zYWN0aW9uIHNlbmRlcicpO1xuICAgIH1cblxuICAgIGlmICghZ2FzQ29uZmlnLmJ1ZGdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGdhcyBidWRnZXQnKTtcbiAgICB9XG5cbiAgICBpZiAoIWdhc0NvbmZpZy5wYXltZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZ2FzIHBheW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoIWdhc0NvbmZpZy5wcmljZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGdhcyBwcmljZScpO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHtcbiAgICAgIHNlbmRlcjogcHJlcGFyZVN1aUFkZHJlc3Moc2VuZGVyKSxcbiAgICAgIGV4cGlyYXRpb246IGV4cGlyYXRpb24gPyBleHBpcmF0aW9uIDogeyBOb25lOiB0cnVlIH0sXG4gICAgICBnYXNEYXRhOiB7XG4gICAgICAgIHBheW1lbnQ6IGdhc0NvbmZpZy5wYXltZW50LFxuICAgICAgICBvd25lcjogcHJlcGFyZVN1aUFkZHJlc3ModGhpcy5nYXNDb25maWcub3duZXIgPz8gc2VuZGVyKSxcbiAgICAgICAgcHJpY2U6IEJpZ0ludChnYXNDb25maWcucHJpY2UpLFxuICAgICAgICBidWRnZXQ6IEJpZ0ludChnYXNDb25maWcuYnVkZ2V0KSxcbiAgICAgIH0sXG4gICAgICBraW5kOiB7XG4gICAgICAgIFByb2dyYW1tYWJsZVRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgaW5wdXRzLFxuICAgICAgICAgIHRyYW5zYWN0aW9uczogdGhpcy50cmFuc2FjdGlvbnMsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG5cbiAgICByZXR1cm4gYnVpbGRlci5zZXIoJ1RyYW5zYWN0aW9uRGF0YScsIHsgVjE6IHRyYW5zYWN0aW9uRGF0YSB9LCB7IG1heFNpemU6IFRSQU5TQUNUSU9OX0RBVEFfTUFYX1NJWkUgfSkudG9CeXRlcygpO1xuICB9XG5cbiAgZ2V0RGlnZXN0KCkge1xuICAgIGNvbnN0IGJ5dGVzID0gdGhpcy5idWlsZCh7IG9ubHlUcmFuc2FjdGlvbktpbmQ6IGZhbHNlIH0pO1xuICAgIHJldHVybiBUcmFuc2FjdGlvbkJsb2NrRGF0YUJ1aWxkZXIuZ2V0RGlnZXN0RnJvbUJ5dGVzKGJ5dGVzKTtcbiAgfVxuXG4gIHNuYXBzaG90KCk6IFNlcmlhbGl6ZWRUcmFuc2FjdGlvbkRhdGFCdWlsZGVyIHtcbiAgICByZXR1cm4gY3JlYXRlKHRoaXMsIFNlcmlhbGl6ZWRUcmFuc2FjdGlvbkRhdGFCdWlsZGVyKTtcbiAgfVxufVxuIl19