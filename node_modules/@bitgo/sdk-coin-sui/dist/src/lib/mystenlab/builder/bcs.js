"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.builder = exports.PROGRAMMABLE_CALL = exports.ARGUMENT = exports.TRANSACTION = exports.ENUM_KIND = exports.TRANSACTION_INNER = exports.PROGRAMMABLE_CALL_INNER = exports.PROGRAMMABLE_TX_BLOCK = exports.OBJECT_ARG = exports.TYPE_TAG = exports.CALL_ARG = exports.OPTION = exports.VECTOR = exports.ARGUMENT_INNER = void 0;
const bcs_1 = require("@mysten/bcs");
const sui_bcs_1 = require("../types/sui-bcs");
const common_1 = require("../types/common");
const type_tag_serializer_1 = require("../txn-data-serializers/type-tag-serializer");
exports.ARGUMENT_INNER = 'Argument';
exports.VECTOR = 'vector';
exports.OPTION = 'Option';
exports.CALL_ARG = 'CallArg';
exports.TYPE_TAG = 'TypeTag';
exports.OBJECT_ARG = 'ObjectArg';
exports.PROGRAMMABLE_TX_BLOCK = 'ProgrammableTransaction';
exports.PROGRAMMABLE_CALL_INNER = 'ProgrammableMoveCall';
exports.TRANSACTION_INNER = 'Transaction';
exports.ENUM_KIND = 'EnumKind';
/** Wrapper around transaction Enum to support `kind` matching in TS */
exports.TRANSACTION = [exports.ENUM_KIND, exports.TRANSACTION_INNER];
/** Wrapper around Argument Enum to support `kind` matching in TS */
exports.ARGUMENT = [exports.ENUM_KIND, exports.ARGUMENT_INNER];
/** Custom serializer for decoding package, module, function easier */
exports.PROGRAMMABLE_CALL = 'SimpleProgrammableMoveCall';
exports.builder = new bcs_1.BCS(sui_bcs_1.bcs)
    .registerStructType(exports.PROGRAMMABLE_TX_BLOCK, {
    inputs: [exports.VECTOR, exports.CALL_ARG],
    transactions: [exports.VECTOR, exports.TRANSACTION],
})
    .registerEnumType(exports.ARGUMENT_INNER, {
    GasCoin: null,
    Input: { index: bcs_1.BCS.U16 },
    Result: { index: bcs_1.BCS.U16 },
    NestedResult: { index: bcs_1.BCS.U16, resultIndex: bcs_1.BCS.U16 },
})
    .registerStructType(exports.PROGRAMMABLE_CALL_INNER, {
    package: bcs_1.BCS.ADDRESS,
    module: bcs_1.BCS.STRING,
    function: bcs_1.BCS.STRING,
    type_arguments: [exports.VECTOR, exports.TYPE_TAG],
    arguments: [exports.VECTOR, exports.ARGUMENT],
})
    .registerEnumType(exports.TRANSACTION_INNER, {
    /**
     * A Move Call - any public Move function can be called via
     * this transaction. The results can be used that instant to pass
     * into the next transaction.
     */
    MoveCall: exports.PROGRAMMABLE_CALL,
    /**
     * Transfer vector of objects to a receiver.
     */
    TransferObjects: {
        objects: [exports.VECTOR, exports.ARGUMENT],
        address: exports.ARGUMENT,
    },
    /**
     * Split `amount` from a `coin`.
     */
    SplitCoins: { coin: exports.ARGUMENT, amounts: [exports.VECTOR, exports.ARGUMENT] },
    /**
     * Merge Vector of Coins (`sources`) into a `destination`.
     */
    MergeCoins: { destination: exports.ARGUMENT, sources: [exports.VECTOR, exports.ARGUMENT] },
    /**
     * Publish a Move module.
     */
    Publish: {
        modules: [exports.VECTOR, [exports.VECTOR, bcs_1.BCS.U8]],
        dependencies: [exports.VECTOR, bcs_1.BCS.ADDRESS],
    },
    /**
     * Build a vector of objects using the input arguments.
     * It is impossible to construct a `vector<T: key>` otherwise,
     * so this call serves a utility function.
     */
    MakeMoveVec: {
        type: [exports.OPTION, exports.TYPE_TAG],
        objects: [exports.VECTOR, exports.ARGUMENT],
    },
});
/**
 * Wrapper around Enum, which transforms any `T` into an object with `kind` property:
 * @example
 * ```
 * let bcsEnum = { TransferObjects: { objects: [], address: ... } }
 * // becomes
 * let translatedEnum = { kind: 'TransferObjects', objects: [], address: ... };
 * ```
 */
exports.builder.registerType([exports.ENUM_KIND, 'T'], function encode(writer, data, typeParams, typeMap) {
    const kind = data.kind;
    const invariant = { [kind]: data };
    const [enumType] = typeParams;
    return this.getTypeInterface(enumType)._encodeRaw.call(this, writer, invariant, typeParams, typeMap);
}, function decode(reader, typeParams, typeMap) {
    const [enumType] = typeParams;
    const data = this.getTypeInterface(enumType)._decodeRaw.call(this, reader, typeParams, typeMap);
    // enum invariant can only have one `key` field
    const kind = Object.keys(data)[0];
    return { kind, ...data[kind] };
}, (data) => {
    if (typeof data !== 'object' && !('kind' in data)) {
        throw new Error(`EnumKind: Missing property "kind" in the input ${JSON.stringify(data)}`);
    }
    return true;
});
/**
 * Custom deserializer for the ProgrammableCall.
 *
 * Hides the inner structure and gives a simpler, more convenient
 * interface to encode and decode this struct as a part of `TransactionData`.
 *
 * - `(package)::(module)::(function)` are now `target` property.
 * - `TypeTag[]` array is now passed as strings, not as a struct.
 */
exports.builder.registerType(exports.PROGRAMMABLE_CALL, function encodeProgrammableTx(writer, data, typeParams, typeMap) {
    const [pkg, module, fun] = data.target.split('::');
    const type_arguments = data.typeArguments.map((tag) => type_tag_serializer_1.TypeTagSerializer.parseFromStr(tag, true));
    return this.getTypeInterface(exports.PROGRAMMABLE_CALL_INNER)._encodeRaw.call(this, writer, {
        package: (0, common_1.normalizeSuiAddress)(pkg),
        module,
        function: fun,
        type_arguments,
        arguments: data.arguments,
    }, typeParams, typeMap);
}, function decodeProgrammableTx(reader, typeParams, typeMap) {
    let data = exports.builder
        .getTypeInterface(exports.PROGRAMMABLE_CALL_INNER)
        ._decodeRaw.call(this, reader, typeParams, typeMap);
    return {
        target: [data.package, data.module, data.function].join('::'),
        arguments: data.arguments,
        typeArguments: data.type_arguments.map(type_tag_serializer_1.TypeTagSerializer.tagToString),
    };
}, 
// Validation callback to error out if the data format is invalid.
// TODO: make sure TypeTag can be parsed.
(data) => {
    return data.target.split('::').length === 3;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmNzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9teXN0ZW5sYWIvYnVpbGRlci9iY3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEscUNBQTRDO0FBQzVDLDhDQUFnRDtBQUNoRCw0Q0FBc0Q7QUFDdEQscUZBQWdGO0FBR25FLFFBQUEsY0FBYyxHQUFHLFVBQVUsQ0FBQztBQUM1QixRQUFBLE1BQU0sR0FBRyxRQUFRLENBQUM7QUFDbEIsUUFBQSxNQUFNLEdBQUcsUUFBUSxDQUFDO0FBQ2xCLFFBQUEsUUFBUSxHQUFHLFNBQVMsQ0FBQztBQUNyQixRQUFBLFFBQVEsR0FBRyxTQUFTLENBQUM7QUFDckIsUUFBQSxVQUFVLEdBQUcsV0FBVyxDQUFDO0FBQ3pCLFFBQUEscUJBQXFCLEdBQUcseUJBQXlCLENBQUM7QUFDbEQsUUFBQSx1QkFBdUIsR0FBRyxzQkFBc0IsQ0FBQztBQUNqRCxRQUFBLGlCQUFpQixHQUFHLGFBQWEsQ0FBQztBQUVsQyxRQUFBLFNBQVMsR0FBRyxVQUFVLENBQUM7QUFFcEMsdUVBQXVFO0FBQzFELFFBQUEsV0FBVyxHQUFhLENBQUMsaUJBQVMsRUFBRSx5QkFBaUIsQ0FBQyxDQUFDO0FBQ3BFLG9FQUFvRTtBQUN2RCxRQUFBLFFBQVEsR0FBYSxDQUFDLGlCQUFTLEVBQUUsc0JBQWMsQ0FBQyxDQUFDO0FBRTlELHNFQUFzRTtBQUN6RCxRQUFBLGlCQUFpQixHQUFHLDRCQUE0QixDQUFDO0FBTWpELFFBQUEsT0FBTyxHQUFHLElBQUksU0FBRyxDQUFDLGFBQUcsQ0FBQztLQUNoQyxrQkFBa0IsQ0FBQyw2QkFBcUIsRUFBRTtJQUN6QyxNQUFNLEVBQUUsQ0FBQyxjQUFNLEVBQUUsZ0JBQVEsQ0FBQztJQUMxQixZQUFZLEVBQUUsQ0FBQyxjQUFNLEVBQUUsbUJBQVcsQ0FBQztDQUNwQyxDQUFDO0tBQ0QsZ0JBQWdCLENBQUMsc0JBQWMsRUFBRTtJQUNoQyxPQUFPLEVBQUUs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dEMsZ0JBQWdCLENBQUMsK0JBQXVCLENBQUM7U0FDekMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUV0RCxPQUFPO1FBQ0wsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQzdELFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUztRQUN6QixhQUFhLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsdUNBQWlCLENBQUMsV0FBVyxDQUFDO0tBQ3RFLENBQUM7QUFDSixDQUFDO0FBQ0Qsa0VBQWtFO0FBQ2xFLHlDQUF5QztBQUN6QyxDQUFDLElBQXlCLEVBQUUsRUFBRTtJQUM1QixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7QUFDOUMsQ0FBQyxDQUNGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCQ1MsIFR5cGVOYW1lIH0gZnJvbSAnQG15c3Rlbi9iY3MnO1xuaW1wb3J0IHsgYmNzLCBUeXBlVGFnIH0gZnJvbSAnLi4vdHlwZXMvc3VpLWJjcyc7XG5pbXBvcnQgeyBub3JtYWxpemVTdWlBZGRyZXNzIH0gZnJvbSAnLi4vdHlwZXMvY29tbW9uJztcbmltcG9ydCB7IFR5cGVUYWdTZXJpYWxpemVyIH0gZnJvbSAnLi4vdHhuLWRhdGEtc2VyaWFsaXplcnMvdHlwZS10YWctc2VyaWFsaXplcic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbkFyZ3VtZW50LCBNb3ZlQ2FsbFRyYW5zYWN0aW9uIH0gZnJvbSAnLi9UcmFuc2FjdGlvbnMnO1xuXG5leHBvcnQgY29uc3QgQVJHVU1FTlRfSU5ORVIgPSAnQXJndW1lbnQnO1xuZXhwb3J0IGNvbnN0IFZFQ1RPUiA9ICd2ZWN0b3InO1xuZXhwb3J0IGNvbnN0IE9QVElPTiA9ICdPcHRpb24nO1xuZXhwb3J0IGNvbnN0IENBTExfQVJHID0gJ0NhbGxBcmcnO1xuZXhwb3J0IGNvbnN0IFRZUEVfVEFHID0gJ1R5cGVUYWcnO1xuZXhwb3J0IGNvbnN0IE9CSkVDVF9BUkcgPSAnT2JqZWN0QXJnJztcbmV4cG9ydCBjb25zdCBQUk9HUkFNTUFCTEVfVFhfQkxPQ0sgPSAnUHJvZ3JhbW1hYmxlVHJhbnNhY3Rpb24nO1xuZXhwb3J0IGNvbnN0IFBST0dSQU1NQUJMRV9DQUxMX0lOTkVSID0gJ1Byb2dyYW1tYWJsZU1vdmVDYWxsJztcbmV4cG9ydCBjb25zdCBUUkFOU0FDVElPTl9JTk5FUiA9ICdUcmFuc2FjdGlvbic7XG5cbmV4cG9ydCBjb25zdCBFTlVNX0tJTkQgPSAnRW51bUtpbmQnO1xuXG4vKiogV3JhcHBlciBhcm91bmQgdHJhbnNhY3Rpb24gRW51bSB0byBzdXBwb3J0IGBraW5kYCBtYXRjaGluZyBpbiBUUyAqL1xuZXhwb3J0IGNvbnN0IFRSQU5TQUNUSU9OOiBUeXBlTmFtZSA9IFtFTlVNX0tJTkQsIFRSQU5TQUNUSU9OX0lOTkVSXTtcbi8qKiBXcmFwcGVyIGFyb3VuZCBBcmd1bWVudCBFbnVtIHRvIHN1cHBvcnQgYGtpbmRgIG1hdGNoaW5nIGluIFRTICovXG5leHBvcnQgY29uc3QgQVJHVU1FTlQ6IFR5cGVOYW1lID0gW0VOVU1fS0lORCwgQVJHVU1FTlRfSU5ORVJdO1xuXG4vKiogQ3VzdG9tIHNlcmlhbGl6ZXIgZm9yIGRlY29kaW5nIHBhY2thZ2UsIG1vZHVsZSwgZnVuY3Rpb24gZWFzaWVyICovXG5leHBvcnQgY29uc3QgUFJPR1JBTU1BQkxFX0NBTEwgPSAnU2ltcGxlUHJvZ3JhbW1hYmxlTW92ZUNhbGwnO1xuXG4vKiogVHJhbnNhY3Rpb24gdHlwZXMgKi9cblxuZXhwb3J0IHR5cGUgT3B0aW9uPFQ+ID0geyBzb21lOiBUIH0gfCB7IG5vbmU6IHRydWUgfTtcblxuZXhwb3J0IGNvbnN0IGJ1aWxkZXIgPSBuZXcgQkNTKGJjcylcbiAgLnJlZ2lzdGVyU3RydWN0VHlwZShQUk9HUkFNTUFCTEVfVFhfQkxPQ0ssIHtcbiAgICBpbnB1dHM6IFtWRUNUT1IsIENBTExfQVJHXSxcbiAgICB0cmFuc2FjdGlvbnM6IFtWRUNUT1IsIFRSQU5TQUNUSU9OXSxcbiAgfSlcbiAgLnJlZ2lzdGVyRW51bVR5cGUoQVJHVU1FTlRfSU5ORVIsIHtcbiAgICBHYXNDb2luOiBudWxsLFxuICAgIElucHV0OiB7IGluZGV4OiBCQ1MuVTE2IH0sXG4gICAgUmVzdWx0OiB7IGluZGV4OiBCQ1MuVTE2IH0sXG4gICAgTmVzdGVkUmVzdWx0OiB7IGluZGV4OiBCQ1MuVTE2LCByZXN1bHRJbmRleDogQkNTLlUxNiB9LFxuICB9KVxuICAucmVnaXN0ZXJTdHJ1Y3RUeXBlKFBST0dSQU1NQUJMRV9DQUxMX0lOTkVSLCB7XG4gICAgcGFja2FnZTogQkNTLkFERFJFU1MsXG4gICAgbW9kdWxlOiBCQ1MuU1RSSU5HLFxuICAgIGZ1bmN0aW9uOiBCQ1MuU1RSSU5HLFxuICAgIHR5cGVfYXJndW1lbnRzOiBbVkVDVE9SLCBUWVBFX1RBR10sXG4gICAgYXJndW1lbnRzOiBbVkVDVE9SLCBBUkdVTUVOVF0sXG4gIH0pXG4gIC5yZWdpc3RlckVudW1UeXBlKFRSQU5TQUNUSU9OX0lOTkVSLCB7XG4gICAgLyoqXG4gICAgICogQSBNb3ZlIENhbGwgLSBhbnkgcHVibGljIE1vdmUgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCB2aWFcbiAgICAgKiB0aGlzIHRyYW5zYWN0aW9uLiBUaGUgcmVzdWx0cyBjYW4gYmUgdXNlZCB0aGF0IGluc3RhbnQgdG8gcGFzc1xuICAgICAqIGludG8gdGhlIG5leHQgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgTW92ZUNhbGw6IFBST0dSQU1NQUJMRV9DQUxMLFxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVyIHZlY3RvciBvZiBvYmplY3RzIHRvIGEgcmVjZWl2ZXIuXG4gICAgICovXG4gICAgVHJhbnNmZXJPYmplY3RzOiB7XG4gICAgICBvYmplY3RzOiBbVkVDVE9SLCBBUkdVTUVOVF0sXG4gICAgICBhZGRyZXNzOiBBUkdVTUVOVCxcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNwbGl0IGBhbW91bnRgIGZyb20gYSBgY29pbmAuXG4gICAgICovXG4gICAgU3BsaXRDb2luczogeyBjb2luOiBBUkdVTUVOVCwgYW1vdW50czogW1ZFQ1RPUiwgQVJHVU1FTlRdIH0sXG4gICAgLyoqXG4gICAgICogTWVyZ2UgVmVjdG9yIG9mIENvaW5zIChgc291cmNlc2ApIGludG8gYSBgZGVzdGluYXRpb25gLlxuICAgICAqL1xuICAgIE1lcmdlQ29pbnM6IHsgZGVzdGluYXRpb246IEFSR1VNRU5ULCBzb3VyY2VzOiBbVkVDVE9SLCBBUkdVTUVOVF0gfSxcbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIGEgTW92ZSBtb2R1bGUuXG4gICAgICovXG4gICAgUHVibGlzaDoge1xuICAgICAgbW9kdWxlczogW1ZFQ1RPUiwgW1ZFQ1RPUiwgQkNTLlU4XV0sXG4gICAgICBkZXBlbmRlbmNpZXM6IFtWRUNUT1IsIEJDUy5BRERSRVNTXSxcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEJ1aWxkIGEgdmVjdG9yIG9mIG9iamVjdHMgdXNpbmcgdGhlIGlucHV0IGFyZ3VtZW50cy5cbiAgICAgKiBJdCBpcyBpbXBvc3NpYmxlIHRvIGNvbnN0cnVjdCBhIGB2ZWN0b3I8VDoga2V5PmAgb3RoZXJ3aXNlLFxuICAgICAqIHNvIHRoaXMgY2FsbCBzZXJ2ZXMgYSB1dGlsaXR5IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIE1ha2VNb3ZlVmVjOiB7XG4gICAgICB0eXBlOiBbT1BUSU9OLCBUWVBFX1RBR10sXG4gICAgICBvYmplY3RzOiBbVkVDVE9SLCBBUkdVTUVOVF0sXG4gICAgfSxcbiAgfSk7XG5cbi8qKlxuICogVXRpbGl0aWVzIGZvciBiZXR0ZXIgZGVjb2RpbmcuXG4gKi9cblxudHlwZSBQcm9ncmFtbWFibGVDYWxsSW5uZXIgPSB7XG4gIHBhY2thZ2U6IHN0cmluZztcbiAgbW9kdWxlOiBzdHJpbmc7XG4gIGZ1bmN0aW9uOiBzdHJpbmc7XG4gIHR5cGVfYXJndW1lbnRzOiBUeXBlVGFnW107XG4gIGFyZ3VtZW50czogVHJhbnNhY3Rpb25Bcmd1bWVudFtdO1xufTtcblxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCBFbnVtLCB3aGljaCB0cmFuc2Zvcm1zIGFueSBgVGAgaW50byBhbiBvYmplY3Qgd2l0aCBga2luZGAgcHJvcGVydHk6XG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBsZXQgYmNzRW51bSA9IHsgVHJhbnNmZXJPYmplY3RzOiB7IG9iamVjdHM6IFtdLCBhZGRyZXNzOiAuLi4gfSB9XG4gKiAvLyBiZWNvbWVzXG4gKiBsZXQgdHJhbnNsYXRlZEVudW0gPSB7IGtpbmQ6ICdUcmFuc2Zlck9iamVjdHMnLCBvYmplY3RzOiBbXSwgYWRkcmVzczogLi4uIH07XG4gKiBgYGBcbiAqL1xuYnVpbGRlci5yZWdpc3RlclR5cGUoXG4gIFtFTlVNX0tJTkQsICdUJ10sXG4gIGZ1bmN0aW9uIGVuY29kZSh0aGlzOiBCQ1MsIHdyaXRlciwgZGF0YTogeyBraW5kOiBzdHJpbmcgfSwgdHlwZVBhcmFtcywgdHlwZU1hcCkge1xuICAgIGNvbnN0IGtpbmQgPSBkYXRhLmtpbmQ7XG4gICAgY29uc3QgaW52YXJpYW50ID0geyBba2luZF06IGRhdGEgfTtcbiAgICBjb25zdCBbZW51bVR5cGVdID0gdHlwZVBhcmFtcztcblxuICAgIHJldHVybiB0aGlzLmdldFR5cGVJbnRlcmZhY2UoZW51bVR5cGUgYXMgc3RyaW5nKS5fZW5jb2RlUmF3LmNhbGwodGhpcywgd3JpdGVyLCBpbnZhcmlhbnQsIHR5cGVQYXJhbXMsIHR5cGVNYXApO1xuICB9LFxuICBmdW5jdGlvbiBkZWNvZGUodGhpczogQkNTLCByZWFkZXIsIHR5cGVQYXJhbXMsIHR5cGVNYXApIHtcbiAgICBjb25zdCBbZW51bVR5cGVdID0gdHlwZVBhcmFtcztcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRUeXBlSW50ZXJmYWNlKGVudW1UeXBlIGFzIHN0cmluZykuX2RlY29kZVJhdy5jYWxsKHRoaXMsIHJlYWRlciwgdHlwZVBhcmFtcywgdHlwZU1hcCk7XG5cbiAgICAvLyBlbnVtIGludmFyaWFudCBjYW4gb25seSBoYXZlIG9uZSBga2V5YCBmaWVsZFxuICAgIGNvbnN0IGtpbmQgPSBPYmplY3Qua2V5cyhkYXRhKVswXTtcbiAgICByZXR1cm4geyBraW5kLCAuLi5kYXRhW2tpbmRdIH07XG4gIH0sXG4gIChkYXRhOiB7IGtpbmQ6IHN0cmluZyB9KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyAmJiAhKCdraW5kJyBpbiBkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbnVtS2luZDogTWlzc2luZyBwcm9wZXJ0eSBcImtpbmRcIiBpbiB0aGUgaW5wdXQgJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuKTtcblxuLyoqXG4gKiBDdXN0b20gZGVzZXJpYWxpemVyIGZvciB0aGUgUHJvZ3JhbW1hYmxlQ2FsbC5cbiAqXG4gKiBIaWRlcyB0aGUgaW5uZXIgc3RydWN0dXJlIGFuZCBnaXZlcyBhIHNpbXBsZXIsIG1vcmUgY29udmVuaWVudFxuICogaW50ZXJmYWNlIHRvIGVuY29kZSBhbmQgZGVjb2RlIHRoaXMgc3RydWN0IGFzIGEgcGFydCBvZiBgVHJhbnNhY3Rpb25EYXRhYC5cbiAqXG4gKiAtIGAocGFja2FnZSk6Oihtb2R1bGUpOjooZnVuY3Rpb24pYCBhcmUgbm93IGB0YXJnZXRgIHByb3BlcnR5LlxuICogLSBgVHlwZVRhZ1tdYCBhcnJheSBpcyBub3cgcGFzc2VkIGFzIHN0cmluZ3MsIG5vdCBhcyBhIHN0cnVjdC5cbiAqL1xuYnVpbGRlci5yZWdpc3RlclR5cGUoXG4gIFBST0dSQU1NQUJMRV9DQUxMLFxuICBmdW5jdGlvbiBlbmNvZGVQcm9ncmFtbWFibGVUeCh0aGlzOiBCQ1MsIHdyaXRlciwgZGF0YTogTW92ZUNhbGxUcmFuc2FjdGlvbiwgdHlwZVBhcmFtcywgdHlwZU1hcCkge1xuICAgIGNvbnN0IFtwa2csIG1vZHVsZSwgZnVuXSA9IGRhdGEudGFyZ2V0LnNwbGl0KCc6OicpO1xuICAgIGNvbnN0IHR5cGVfYXJndW1lbnRzID0gZGF0YS50eXBlQXJndW1lbnRzLm1hcCgodGFnKSA9PiBUeXBlVGFnU2VyaWFsaXplci5wYXJzZUZyb21TdHIodGFnLCB0cnVlKSk7XG5cbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlSW50ZXJmYWNlKFBST0dSQU1NQUJMRV9DQUxMX0lOTkVSKS5fZW5jb2RlUmF3LmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgd3JpdGVyLFxuICAgICAge1xuICAgICAgICBwYWNrYWdlOiBub3JtYWxpemVTdWlBZGRyZXNzKHBrZyksXG4gICAgICAgIG1vZHVsZSxcbiAgICAgICAgZnVuY3Rpb246IGZ1bixcbiAgICAgICAgdHlwZV9hcmd1bWVudHMsXG4gICAgICAgIGFyZ3VtZW50czogZGF0YS5hcmd1bWVudHMsXG4gICAgICB9IGFzIFByb2dyYW1tYWJsZUNhbGxJbm5lcixcbiAgICAgIHR5cGVQYXJhbXMsXG4gICAgICB0eXBlTWFwXG4gICAgKTtcbiAgfSxcbiAgZnVuY3Rpb24gZGVjb2RlUHJvZ3JhbW1hYmxlVHgodGhpczogQkNTLCByZWFkZXIsIHR5cGVQYXJhbXMsIHR5cGVNYXApIHtcbiAgICBsZXQgZGF0YTogUHJvZ3JhbW1hYmxlQ2FsbElubmVyID0gYnVpbGRlclxuICAgICAgLmdldFR5cGVJbnRlcmZhY2UoUFJPR1JBTU1BQkxFX0NBTExfSU5ORVIpXG4gICAgICAuX2RlY29kZVJhdy5jYWxsKHRoaXMsIHJlYWRlciwgdHlwZVBhcmFtcywgdHlwZU1hcCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGFyZ2V0OiBbZGF0YS5wYWNrYWdlLCBkYXRhLm1vZHVsZSwgZGF0YS5mdW5jdGlvbl0uam9pbignOjonKSxcbiAgICAgIGFyZ3VtZW50czogZGF0YS5hcmd1bWVudHMsXG4gICAgICB0eXBlQXJndW1lbnRzOiBkYXRhLnR5cGVfYXJndW1lbnRzLm1hcChUeXBlVGFnU2VyaWFsaXplci50YWdUb1N0cmluZyksXG4gICAgfTtcbiAgfSxcbiAgLy8gVmFsaWRhdGlvbiBjYWxsYmFjayB0byBlcnJvciBvdXQgaWYgdGhlIGRhdGEgZm9ybWF0IGlzIGludmFsaWQuXG4gIC8vIFRPRE86IG1ha2Ugc3VyZSBUeXBlVGFnIGNhbiBiZSBwYXJzZWQuXG4gIChkYXRhOiBNb3ZlQ2FsbFRyYW5zYWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIGRhdGEudGFyZ2V0LnNwbGl0KCc6OicpLmxlbmd0aCA9PT0gMztcbiAgfVxuKTtcbiJdfQ==