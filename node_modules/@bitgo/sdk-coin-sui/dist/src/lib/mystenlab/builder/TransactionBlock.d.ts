import { ObjectId, SuiObjectRef } from '../types';
import { Transactions, TransactionArgument, TransactionType } from './Transactions';
import { ObjectCallArg } from './Inputs';
import { TransactionExpiration } from './TransactionDataBlock';
declare type TransactionResult = TransactionArgument & TransactionArgument[];
declare const TRANSACTION_BRAND: unique symbol;
interface BuildOptions {
    onlyTransactionKind?: boolean;
}
/**
 * Transaction Builder
 */
export declare class TransactionBlock {
    #private;
    /** Returns `true` if the object is an instance of the Transaction builder class. */
    static is(obj: unknown): obj is TransactionBlock;
    /**
     * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
     * Supports either a byte array, or base64-encoded bytes.
     */
    static fromKind(serialized: string | Uint8Array): TransactionBlock;
    /**
     * Converts from a serialized transaction format to a `Transaction` class.
     * There are two supported serialized formats:
     * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
     * - A byte array (or base64-encoded bytes) containing BCS transaction data.
     */
    static from(serialized: string | Uint8Array): TransactionBlock;
    /** A helper to retrieve the Transaction builder `Transactions` */
    static get Transactions(): {
        MoveCall(input: Omit<{
            arguments: ({
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            })[];
            kind: "MoveCall";
            typeArguments: string[];
            target: `${string}::${string}::${string}`;
        }, "arguments" | "kind" | "typeArguments"> & {
            arguments?: ({
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            })[] | undefined;
            typeArguments?: string[] | undefined;
        }): {
            arguments: ({
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            })[];
            kind: "MoveCall";
            typeArguments: string[];
            target: `${string}::${string}::${string}`;
        };
        TransferObjects(objects: ({
            index: number;
            kind: "Input";
            type?: "object" | "pure" | undefined;
            value?: any;
        } | {
            kind: "GasCoin";
        } | {
            index: number;
            kind: "Result";
        } | {
            index: number;
            kind: "NestedResult";
            resultIndex: number;
        })[], address: {
            index: number;
            kind: "Input";
            type?: "object" | "pure" | undefined;
            value?: any;
        } | {
            kind: "GasCoin";
        } | {
            index: number;
            kind: "Result";
        } | {
            index: number;
            kind: "NestedResult";
            resultIndex: number;
        }): {
            address: {
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            };
            objects: ({
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            })[];
            kind: "TransferObjects";
        };
        SplitCoins(coin: {
            index: number;
            kind: "Input";
            type?: "object" | "pure" | undefined;
            value?: any;
        } | {
            kind: "GasCoin";
        } | {
            index: number;
            kind: "Result";
        } | {
            index: number;
            kind: "NestedResult";
            resultIndex: number;
        }, amounts: ({
            index: number;
            kind: "Input";
            type?: "object" | "pure" | undefined;
            value?: any;
        } | {
            kind: "GasCoin";
        } | {
            index: number;
            kind: "Result";
        } | {
            index: number;
            kind: "NestedResult";
            resultIndex: number;
        })[]): {
            coin: {
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            };
            kind: "SplitCoins";
            amounts: ({
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            })[];
        };
        MergeCoins(destination: {
            index: number;
            kind: "Input";
            type?: "object" | "pure" | undefined;
            value?: any;
        } | {
            kind: "GasCoin";
        } | {
            index: number;
            kind: "Result";
        } | {
            index: number;
            kind: "NestedResult";
            resultIndex: number;
        }, sources: ({
            index: number;
            kind: "Input";
            type?: "object" | "pure" | undefined;
            value?: any;
        } | {
            kind: "GasCoin";
        } | {
            index: number;
            kind: "Result";
        } | {
            index: number;
            kind: "NestedResult";
            resultIndex: number;
        })[]): {
            kind: "MergeCoins";
            destination: {
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            };
            sources: ({
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            })[];
        };
        Publish(modules: number[][], dependencies: string[]): {
            kind: "Publish";
            dependencies: string[];
            modules: number[][];
        };
        MakeMoveVec({ type, objects, }: Omit<{
            objects: ({
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            })[];
            kind: "MakeMoveVec";
            type?: {
                None: null;
            } | {
                Some: string;
            } | undefined;
        }, "type" | "kind"> & {
            type?: string | undefined;
        }): {
            objects: ({
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            })[];
            kind: "MakeMoveVec";
            type?: {
                None: null;
            } | {
                Some: string;
            } | undefined;
        };
    };
    /** A helper to retrieve the Transaction builder `Inputs` */
    static get Inputs(): {
        Pure(data: unknown, type?: string | undefined): {
            Pure: number[];
        };
        ObjectRef(ref: {
            version: string | number;
            objectId: string;
            digest: string;
        }): {
            Object: {
                ImmOrOwned: {
                    version: string | number;
                    objectId: string;
                    digest: string;
                };
            } | {
                Shared: {
                    objectId: string;
                    initialSharedVersion: string | number;
                    mutable: boolean;
                };
            };
        };
        SharedObjectRef(ref: import("../types").SharedObjectRef): {
            Object: {
                ImmOrOwned: {
                    version: string | number;
                    objectId: string;
                    digest: string;
                };
            } | {
                Shared: {
                    objectId: string;
                    initialSharedVersion: string | number;
                    mutable: boolean;
                };
            };
        };
    };
    setSender(sender: string): void;
    /**
     * Sets the sender only if it has not already been set.
     * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
     */
    setSenderIfNotSet(sender: string): void;
    setExpiration(expiration?: TransactionExpiration): void;
    setGasPrice(price: number | bigint): void;
    setGasBudget(budget: number | bigint): void;
    setGasOwner(owner: string): void;
    setGasPayment(payments: SuiObjectRef[]): void;
    /** Get a snapshot of the transaction data, in JSON form: */
    get blockData(): {
        version: 1;
        transactions: ({
            arguments: ({
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            })[];
            kind: "MoveCall";
            typeArguments: string[];
            target: `${string}::${string}::${string}`;
        } | {
            address: {
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            };
            objects: ({
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            })[];
            kind: "TransferObjects";
        } | {
            coin: {
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            };
            kind: "SplitCoins";
            amounts: ({
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            })[];
        } | {
            kind: "MergeCoins";
            destination: {
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            };
            sources: ({
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            })[];
        } | {
            objects: ({
                index: number;
                kind: "Input";
                type?: "object" | "pure" | undefined;
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                kind: "NestedResult";
                resultIndex: number;
            })[];
            kind: "MakeMoveVec";
            type?: {
                None: null;
            } | {
                Some: string;
            } | undefined;
        } | {
            kind: "Publish";
            dependencies: string[];
            modules: number[][];
        })[];
        inputs: {
            index: number;
            kind: "Input";
            type?: "object" | "pure" | undefined;
            value?: any;
        }[];
        gasConfig: {
            owner?: string | undefined;
            payment?: {
                version: string | number;
                objectId: string;
                digest: string;
            }[] | undefined;
            price?: string | undefined;
            budget?: string | undefined;
        };
        sender?: string | undefined;
        expiration?: {
            Epoch: number;
        } | {
            None: true | null;
        } | null | undefined;
    };
    get [TRANSACTION_BRAND](): boolean;
    constructor(transaction?: TransactionBlock);
    /** Returns an argument for the gas coin, to be used in a transaction. */
    get gas(): TransactionArgument;
    /**
     * Dynamically create a new input, which is separate from the `input`. This is important
     * for generated clients to be able to define unique inputs that are non-overlapping with the
     * defined inputs.
     *
     * For `Uint8Array` type automatically convert the input into a `Pure` CallArg, since this
     * is the format required for custom serialization.
     *
     */
    input(type: 'object' | 'pure', value?: unknown): {
        index: number;
        kind: "Input";
        type?: "object" | "pure" | undefined;
        value?: any;
    };
    /**
     * Add a new object input to the transaction.
     */
    object(value: ObjectId | ObjectCallArg): {
        index: number;
        kind: "Input";
        type?: "object" | "pure" | undefined;
        value?: any;
    };
    /**
     * Add a new non-object input to the transaction.
     */
    pure(
    /**
     * The pure value that will be used as the input value. If this is a Uint8Array, then the value
     * is assumed to be raw bytes, and will be used directly.
     */
    value: unknown, 
    /**
     * The BCS type to serialize the value into. If not provided, the type will automatically be determined
     * based on how the input is used.
     */
    type?: string): {
        index: number;
        kind: "Input";
        type?: "object" | "pure" | undefined;
        value?: any;
    };
    /** Add a transaction to the transaction block. */
    add(transaction: TransactionType): TransactionResult;
    splitCoins(...args: Parameters<(typeof Transactions)['SplitCoins']>): TransactionResult;
    mergeCoins(...args: Parameters<(typeof Transactions)['MergeCoins']>): TransactionResult;
    publish(...args: Parameters<(typeof Transactions)['Publish']>): TransactionResult;
    moveCall(...args: Parameters<(typeof Transactions)['MoveCall']>): TransactionResult;
    transferObjects(...args: Parameters<(typeof Transactions)['TransferObjects']>): TransactionResult;
    makeMoveVec(...args: Parameters<(typeof Transactions)['MakeMoveVec']>): TransactionResult;
    /**
     * Serialize the transaction to a string so that it can be sent to a separate context.
     * This is different from `build` in that it does not serialize to BCS bytes, and instead
     * uses a separate format that is unique to the transaction builder. This allows
     * us to serialize partially-complete transactions, that can then be completed and
     * built in a separate context.
     *
     * For example, a dapp can construct a transaction, but not provide gas objects
     * or a gas budget. The transaction then can be sent to the wallet, where this
     * information is automatically filled in (e.g. by querying for coin objects
     * and performing a dry run).
     */
    serialize(): string;
    /** Build the transaction to BCS bytes. */
    build({ onlyTransactionKind }?: BuildOptions): Promise<Uint8Array>;
    /** Derive transaction digest */
    getDigest(): Promise<string>;
}
export {};
//# sourceMappingURL=TransactionBlock.d.ts.map