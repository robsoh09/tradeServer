"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _TransactionBlock_blockData;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBlock = void 0;
const bcs_1 = require("@mysten/bcs");
const superstruct_1 = require("superstruct");
const types_1 = require("../types");
const Transactions_1 = require("./Transactions");
const Inputs_1 = require("./Inputs");
const TransactionDataBlock_1 = require("./TransactionDataBlock");
const utils_1 = require("./utils");
function createTransactionResult(index) {
    const baseResult = { kind: 'Result', index };
    const nestedResults = [];
    const nestedResultFor = (resultIndex) => {
        var _a;
        return ((_a = nestedResults[resultIndex]) !== null && _a !== void 0 ? _a : (nestedResults[resultIndex] = {
            kind: 'NestedResult',
            index,
            resultIndex,
        }));
    };
    return new Proxy(baseResult, {
        set() {
            throw new Error('The transaction result is a proxy, and does not support setting properties directly');
        },
        // TODO: Instead of making this return a concrete argument, we should ideally
        // make it reference-based (so that this gets resolved at build-time), which
        // allows re-ordering transactions.
        get(target, property) {
            // This allows this transaction argument to be used in the singular form:
            if (property in target) {
                return Reflect.get(target, property);
            }
            // Support destructuring:
            if (property === Symbol.iterator) {
                return function* () {
                    let i = 0;
                    while (true) {
                        yield nestedResultFor(i);
                        i++;
                    }
                };
            }
            if (typeof property === 'symbol')
                return;
            const resultIndex = parseInt(property, 10);
            if (Number.isNaN(resultIndex) || resultIndex < 0)
                return;
            return nestedResultFor(resultIndex);
        },
    });
}
const TRANSACTION_BRAND = Symbol.for('@mysten/transaction');
// The maximum number of gas objects that can be selected for one transaction.
const MAX_GAS_OBJECTS = 256;
// The maximum gas that is allowed.
const MAX_GAS = 1000000000;
// A guess about how much overhead each coin provides for gas calculations.
// @ts-ignore
const GAS_OVERHEAD_PER_COIN = 10n;
/**
 * Transaction Builder
 */
class TransactionBlock {
    constructor(transaction) {
        _TransactionBlock_blockData.set(this, void 0);
        __classPrivateFieldSet(this, _TransactionBlock_blockData, new TransactionDataBlock_1.TransactionBlockDataBuilder(transaction ? __classPrivateFieldGet(transaction, _TransactionBlock_blockData, "f") : undefined), "f");
    }
    /** Returns `true` if the object is an instance of the Transaction builder class. */
    static is(obj) {
        return !!obj && typeof obj === 'object' && obj[TRANSACTION_BRAND] === true;
    }
    /**
     * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
     * Supports either a byte array, or base64-encoded bytes.
     */
    static fromKind(serialized) {
        const tx = new TransactionBlock();
        __classPrivateFieldSet(tx, _TransactionBlock_blockData, TransactionDataBlock_1.TransactionBlockDataBuilder.fromKindBytes(typeof serialized === 'string' ? (0, bcs_1.fromB64)(serialized) : serialized), "f");
        return tx;
    }
    /**
     * Converts from a serialized transaction format to a `Transaction` class.
     * There are two supported serialized formats:
     * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
     * - A byte array (or base64-encoded bytes) containing BCS transaction data.
     */
    static from(serialized) {
        const tx = new TransactionBlock();
        // Check for bytes:
        if (typeof serialized !== 'string' || !serialized.startsWith('{')) {
            __classPrivateFieldSet(tx, _TransactionBlock_blockData, TransactionDataBlock_1.TransactionBlockDataBuilder.fromBytes(typeof serialized === 'string' ? (0, bcs_1.fromB64)(serialized) : serialized), "f");
        }
        else {
            __classPrivateFieldSet(tx, _TransactionBlock_blockData, TransactionDataBlock_1.TransactionBlockDataBuilder.restore(JSON.parse(serialized)), "f");
        }
        return tx;
    }
    /** A helper to retrieve the Transaction builder `Transactions` */
    static get Transactions() {
        return Transactions_1.Transactions;
    }
    /** A helper to retrieve the Transaction builder `Inputs` */
    static get Inputs() {
        return Inputs_1.Inputs;
    }
    setSender(sender) {
        __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").sender = sender;
    }
    /**
     * Sets the sender only if it has not already been set.
     * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
     */
    setSenderIfNotSet(sender) {
        if (!__classPrivateFieldGet(this, _TransactionBlock_blockData, "f").sender) {
            __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").sender = sender;
        }
    }
    setExpiration(expiration) {
        __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").expiration = expiration;
    }
    setGasPrice(price) {
        __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").gasConfig.price = String(price);
    }
    setGasBudget(budget) {
        __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").gasConfig.budget = String(budget);
    }
    setGasOwner(owner) {
        __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").gasConfig.owner = owner;
    }
    setGasPayment(payments) {
        if (payments.length >= MAX_GAS_OBJECTS) {
            throw new Error(`Payment objects exceed maximum amount ${MAX_GAS_OBJECTS}`);
        }
        __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").gasConfig.payment = payments.map((payment) => (0, superstruct_1.mask)(payment, types_1.SuiObjectRef));
    }
    /** Get a snapshot of the transaction data, in JSON form: */
    get blockData() {
        return __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").snapshot();
    }
    // Used to brand transaction classes so that they can be identified, even between multiple copies
    // of the builder.
    get [(_TransactionBlock_blockData = new WeakMap(), TRANSACTION_BRAND)]() {
        return true;
    }
    /** Returns an argument for the gas coin, to be used in a transaction. */
    get gas() {
        return { kind: 'GasCoin' };
    }
    /**
     * Dynamically create a new input, which is separate from the `input`. This is important
     * for generated clients to be able to define unique inputs that are non-overlapping with the
     * defined inputs.
     *
     * For `Uint8Array` type automatically convert the input into a `Pure` CallArg, since this
     * is the format required for custom serialization.
     *
     */
    input(type, value) {
        const index = __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").inputs.length;
        const input = (0, utils_1.create)({
            kind: 'Input',
            // bigints can't be serialized to JSON, so just string-convert them here:
            value: typeof value === 'bigint' ? String(value) : value,
            index,
            type,
        }, Transactions_1.TransactionBlockInput);
        __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").inputs.push(input);
        return input;
    }
    /**
     * Add a new object input to the transaction.
     */
    object(value) {
        const id = (0, Inputs_1.getIdFromCallArg)(value);
        // deduplicate
        const inserted = __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").inputs.find((i) => i.type === 'object' && id === (0, Inputs_1.getIdFromCallArg)(i.value));
        return inserted !== null && inserted !== void 0 ? inserted : this.input('object', value);
    }
    /**
     * Add a new non-object input to the transaction.
     */
    pure(
    /**
     * The pure value that will be used as the input value. If this is a Uint8Array, then the value
     * is assumed to be raw bytes, and will be used directly.
     */
    value, 
    /**
     * The BCS type to serialize the value into. If not provided, the type will automatically be determined
     * based on how the input is used.
     */
    type) {
        // TODO: we can also do some deduplication here
        return this.input('pure', value instanceof Uint8Array ? Inputs_1.Inputs.Pure(value) : type ? Inputs_1.Inputs.Pure(value, type) : value);
    }
    /** Add a transaction to the transaction block. */
    add(transaction) {
        const index = __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").transactions.push(transaction);
        return createTransactionResult(index - 1);
    }
    // Method shorthands:
    splitCoins(...args) {
        return this.add(Transactions_1.Transactions.SplitCoins(...args));
    }
    mergeCoins(...args) {
        return this.add(Transactions_1.Transactions.MergeCoins(...args));
    }
    publish(...args) {
        return this.add(Transactions_1.Transactions.Publish(...args));
    }
    moveCall(...args) {
        return this.add(Transactions_1.Transactions.MoveCall(...args));
    }
    transferObjects(...args) {
        return this.add(Transactions_1.Transactions.TransferObjects(...args));
    }
    makeMoveVec(...args) {
        return this.add(Transactions_1.Transactions.MakeMoveVec(...args));
    }
    /**
     * Serialize the transaction to a string so that it can be sent to a separate context.
     * This is different from `build` in that it does not serialize to BCS bytes, and instead
     * uses a separate format that is unique to the transaction builder. This allows
     * us to serialize partially-complete transactions, that can then be completed and
     * built in a separate context.
     *
     * For example, a dapp can construct a transaction, but not provide gas objects
     * or a gas budget. The transaction then can be sent to the wallet, where this
     * information is automatically filled in (e.g. by querying for coin objects
     * and performing a dry run).
     */
    serialize() {
        return JSON.stringify(__classPrivateFieldGet(this, _TransactionBlock_blockData, "f").snapshot());
    }
    /** Build the transaction to BCS bytes. */
    async build({ onlyTransactionKind } = {}) {
        return __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").build({ onlyTransactionKind });
    }
    /** Derive transaction digest */
    async getDigest() {
        return __classPrivateFieldGet(this, _TransactionBlock_blockData, "f").getDigest();
    }
}
exports.TransactionBlock = TransactionBlock;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHJhbnNhY3Rpb25CbG9jay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvbXlzdGVubGFiL2J1aWxkZXIvVHJhbnNhY3Rpb25CbG9jay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxxQ0FBc0M7QUFDdEMsNkNBQXVDO0FBQ3ZDLG9DQUFrRDtBQUNsRCxpREFBMkc7QUFDM0cscUNBQW1GO0FBQ25GLGlFQUE0RjtBQUM1RixtQ0FBaUM7QUFJakMsU0FBUyx1QkFBdUIsQ0FBQyxLQUFhO0lBQzVDLE1BQU0sVUFBVSxHQUF3QixFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLENBQUM7SUFFbEUsTUFBTSxhQUFhLEdBQTBCLEVBQUUsQ0FBQztJQUNoRCxNQUFNLGVBQWUsR0FBRyxDQUFDLFdBQW1CLEVBQXVCLEVBQUU7O1FBQ25FLE9BQUEsT0FBQyxhQUFhLENBQUMsV0FBVyxxQ0FBekIsYUFBYSxDQUFDLFdBQVcsSUFBTTtZQUM5QixJQUFJLEVBQUUsY0FBYztZQUNwQixLQUFLO1lBQ0wsV0FBVztTQUNaLEVBQUMsQ0FBQTtLQUFBLENBQUM7SUFFTCxPQUFPLElBQUksS0FBSyxDQUFDLFVBQVUsRUFBRTtRQUMzQixHQUFHO1lBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxxRkFBcUYsQ0FBQyxDQUFDO1FBQ3pHLENBQUM7UUFDRCw2RUFBNkU7UUFDN0UsNEVBQTRFO1FBQzVFLG1DQUFtQztRQUNuQyxHQUFHLENBQUMsTUFBTSxFQUFFLFFBQVE7WUFDbEIseUVBQXlFO1lBQ3pFLElBQUksUUFBUSxJQUFJLE1BQU0sRUFBRTtnQkFDdEIsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQzthQUN0QztZQUVELHlCQUF5QjtZQUN6QixJQUFJLFFBQVEsS0FBSyxNQUFNLENBQUMsUUFBUSxFQUFFO2dCQUNoQyxPQUFPLFFBQVEsQ0FB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QUcsSUFBbUQ7UUFDN0QsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLDJCQUFZLENBQUMsUUFBUSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBQ0QsZUFBZSxDQUFDLEdBQUcsSUFBMEQ7UUFDM0UsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLDJCQUFZLENBQUMsZUFBZSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBQ0QsV0FBVyxDQUFDLEdBQUcsSUFBc0Q7UUFDbkUsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLDJCQUFZLENBQUMsV0FBVyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSCxTQUFTO1FBQ1AsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLHVCQUFBLElBQUksbUNBQVcsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRCwwQ0FBMEM7SUFDMUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLG1CQUFtQixLQUFtQixFQUFFO1FBQ3BELE9BQU8sdUJBQUEsSUFBSSxtQ0FBVyxDQUFDLEtBQUssQ0FBQyxFQUFFLG1CQUFtQixFQUFFLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRUQsZ0NBQWdDO0lBQ2hDLEtBQUssQ0FBQyxTQUFTO1FBQ2IsT0FBTyx1QkFBQSxJQUFJLG1DQUFXLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDckMsQ0FBQztDQUNGO0FBcE5ELDRDQW9OQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZyb21CNjQgfSBmcm9tICdAbXlzdGVuL2Jjcyc7XG5pbXBvcnQgeyBpcywgbWFzayB9IGZyb20gJ3N1cGVyc3RydWN0JztcbmltcG9ydCB7IE9iamVjdElkLCBTdWlPYmplY3RSZWYgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbnMsIFRyYW5zYWN0aW9uQXJndW1lbnQsIFRyYW5zYWN0aW9uVHlwZSwgVHJhbnNhY3Rpb25CbG9ja0lucHV0IH0gZnJvbSAnLi9UcmFuc2FjdGlvbnMnO1xuaW1wb3J0IHsgQnVpbGRlckNhbGxBcmcsIGdldElkRnJvbUNhbGxBcmcsIElucHV0cywgT2JqZWN0Q2FsbEFyZyB9IGZyb20gJy4vSW5wdXRzJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uQmxvY2tEYXRhQnVpbGRlciwgVHJhbnNhY3Rpb25FeHBpcmF0aW9uIH0gZnJvbSAnLi9UcmFuc2FjdGlvbkRhdGFCbG9jayc7XG5pbXBvcnQgeyBjcmVhdGUgfSBmcm9tICcuL3V0aWxzJztcblxudHlwZSBUcmFuc2FjdGlvblJlc3VsdCA9IFRyYW5zYWN0aW9uQXJndW1lbnQgJiBUcmFuc2FjdGlvbkFyZ3VtZW50W107XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uUmVzdWx0KGluZGV4OiBudW1iZXIpOiBUcmFuc2FjdGlvblJlc3VsdCB7XG4gIGNvbnN0IGJhc2VSZXN1bHQ6IFRyYW5zYWN0aW9uQXJndW1lbnQgPSB7IGtpbmQ6ICdSZXN1bHQnLCBpbmRleCB9O1xuXG4gIGNvbnN0IG5lc3RlZFJlc3VsdHM6IFRyYW5zYWN0aW9uQXJndW1lbnRbXSA9IFtdO1xuICBjb25zdCBuZXN0ZWRSZXN1bHRGb3IgPSAocmVzdWx0SW5kZXg6IG51bWJlcik6IFRyYW5zYWN0aW9uQXJndW1lbnQgPT5cbiAgICAobmVzdGVkUmVzdWx0c1tyZXN1bHRJbmRleF0gPz89IHtcbiAgICAgIGtpbmQ6ICdOZXN0ZWRSZXN1bHQnLFxuICAgICAgaW5kZXgsXG4gICAgICByZXN1bHRJbmRleCxcbiAgICB9KTtcblxuICByZXR1cm4gbmV3IFByb3h5KGJhc2VSZXN1bHQsIHtcbiAgICBzZXQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0cmFuc2FjdGlvbiByZXN1bHQgaXMgYSBwcm94eSwgYW5kIGRvZXMgbm90IHN1cHBvcnQgc2V0dGluZyBwcm9wZXJ0aWVzIGRpcmVjdGx5Jyk7XG4gICAgfSxcbiAgICAvLyBUT0RPOiBJbnN0ZWFkIG9mIG1ha2luZyB0aGlzIHJldHVybiBhIGNvbmNyZXRlIGFyZ3VtZW50LCB3ZSBzaG91bGQgaWRlYWxseVxuICAgIC8vIG1ha2UgaXQgcmVmZXJlbmNlLWJhc2VkIChzbyB0aGF0IHRoaXMgZ2V0cyByZXNvbHZlZCBhdCBidWlsZC10aW1lKSwgd2hpY2hcbiAgICAvLyBhbGxvd3MgcmUtb3JkZXJpbmcgdHJhbnNhY3Rpb25zLlxuICAgIGdldCh0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgICAvLyBUaGlzIGFsbG93cyB0aGlzIHRyYW5zYWN0aW9uIGFyZ3VtZW50IHRvIGJlIHVzZWQgaW4gdGhlIHNpbmd1bGFyIGZvcm06XG4gICAgICBpZiAocHJvcGVydHkgaW4gdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgLy8gU3VwcG9ydCBkZXN0cnVjdHVyaW5nOlxuICAgICAgaWYgKHByb3BlcnR5ID09PSBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB5aWVsZCBuZXN0ZWRSZXN1bHRGb3IoaSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnc3ltYm9sJykgcmV0dXJuO1xuXG4gICAgICBjb25zdCByZXN1bHRJbmRleCA9IHBhcnNlSW50KHByb3BlcnR5LCAxMCk7XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKHJlc3VsdEluZGV4KSB8fCByZXN1bHRJbmRleCA8IDApIHJldHVybjtcbiAgICAgIHJldHVybiBuZXN0ZWRSZXN1bHRGb3IocmVzdWx0SW5kZXgpO1xuICAgIH0sXG4gIH0pIGFzIFRyYW5zYWN0aW9uUmVzdWx0O1xufVxuXG5jb25zdCBUUkFOU0FDVElPTl9CUkFORCA9IFN5bWJvbC5mb3IoJ0BteXN0ZW4vdHJhbnNhY3Rpb24nKTtcblxuLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIGdhcyBvYmplY3RzIHRoYXQgY2FuIGJlIHNlbGVjdGVkIGZvciBvbmUgdHJhbnNhY3Rpb24uXG5jb25zdCBNQVhfR0FTX09CSkVDVFMgPSAyNTY7XG5cbi8vIFRoZSBtYXhpbXVtIGdhcyB0aGF0IGlzIGFsbG93ZWQuXG5jb25zdCBNQVhfR0FTID0gMTAwMDAwMDAwMDtcblxuLy8gQSBndWVzcyBhYm91dCBob3cgbXVjaCBvdmVyaGVhZCBlYWNoIGNvaW4gcHJvdmlkZXMgZm9yIGdhcyBjYWxjdWxhdGlvbnMuXG4vLyBAdHMtaWdub3JlXG5jb25zdCBHQVNfT1ZFUkhFQURfUEVSX0NPSU4gPSAxMG47XG5cbmludGVyZmFjZSBCdWlsZE9wdGlvbnMge1xuICBvbmx5VHJhbnNhY3Rpb25LaW5kPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBCdWlsZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkJsb2NrIHtcbiAgLyoqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIFRyYW5zYWN0aW9uIGJ1aWxkZXIgY2xhc3MuICovXG4gIHN0YXRpYyBpcyhvYmo6IHVua25vd24pOiBvYmogaXMgVHJhbnNhY3Rpb25CbG9jayB7XG4gICAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIChvYmogYXMgYW55KVtUUkFOU0FDVElPTl9CUkFORF0gPT09IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgZnJvbSBhIHNlcmlhbGl6ZSB0cmFuc2FjdGlvbiBraW5kIChidWlsdCB3aXRoIGBidWlsZCh7IG9ubHlUcmFuc2FjdGlvbktpbmQ6IHRydWUgfSlgKSB0byBhIGBUcmFuc2FjdGlvbmAgY2xhc3MuXG4gICAqIFN1cHBvcnRzIGVpdGhlciBhIGJ5dGUgYXJyYXksIG9yIGJhc2U2NC1lbmNvZGVkIGJ5dGVzLlxuICAgKi9cbiAgc3RhdGljIGZyb21LaW5kKHNlcmlhbGl6ZWQ6IHN0cmluZyB8IFVpbnQ4QXJyYXkpIHtcbiAgICBjb25zdCB0eCA9IG5ldyBUcmFuc2FjdGlvbkJsb2NrKCk7XG5cbiAgICB0eC4jYmxvY2tEYXRhID0gVHJhbnNhY3Rpb25CbG9ja0RhdGFCdWlsZGVyLmZyb21LaW5kQnl0ZXMoXG4gICAgICB0eXBlb2Ygc2VyaWFsaXplZCA9PT0gJ3N0cmluZycgPyBmcm9tQjY0KHNlcmlhbGl6ZWQpIDogc2VyaWFsaXplZFxuICAgICk7XG5cbiAgICByZXR1cm4gdHg7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgZnJvbSBhIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gZm9ybWF0IHRvIGEgYFRyYW5zYWN0aW9uYCBjbGFzcy5cbiAgICogVGhlcmUgYXJlIHR3byBzdXBwb3J0ZWQgc2VyaWFsaXplZCBmb3JtYXRzOlxuICAgKiAtIEEgc3RyaW5nIHJldHVybmVkIGZyb20gYFRyYW5zYWN0aW9uI3NlcmlhbGl6ZWAuIFRoZSBzZXJpYWxpemVkIGZvcm1hdCBtdXN0IGJlIGNvbXBhdGlibGUsIG9yIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAqIC0gQSBieXRlIGFycmF5IChvciBiYXNlNjQtZW5jb2RlZCBieXRlcykgY29udGFpbmluZyBCQ1MgdHJhbnNhY3Rpb24gZGF0YS5cbiAgICovXG4gIHN0YXRpYyBmcm9tKHNlcmlhbGl6ZWQ6IHN0cmluZyB8IFVpbnQ4QXJyYXkpIHtcbiAgICBjb25zdCB0eCA9IG5ldyBUcmFuc2FjdGlvbkJsb2NrKCk7XG5cbiAgICAvLyBDaGVjayBmb3IgYnl0ZXM6XG4gICAgaWYgKHR5cGVvZiBzZXJpYWxpemVkICE9PSAnc3RyaW5nJyB8fCAhc2VyaWFsaXplZC5zdGFydHNXaXRoKCd7JykpIHtcbiAgICAgIHR4LiNibG9ja0RhdGEgPSBUcmFuc2FjdGlvbkJsb2NrRGF0YUJ1aWxkZXIuZnJvbUJ5dGVzKFxuICAgICAgICB0eXBlb2Ygc2VyaWFsaXplZCA9PT0gJ3N0cmluZycgPyBmcm9tQjY0KHNlcmlhbGl6ZWQpIDogc2VyaWFsaXplZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHguI2Jsb2NrRGF0YSA9IFRyYW5zYWN0aW9uQmxvY2tEYXRhQnVpbGRlci5yZXN0b3JlKEpTT04ucGFyc2Uoc2VyaWFsaXplZCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0eDtcbiAgfVxuXG4gIC8qKiBBIGhlbHBlciB0byByZXRyaWV2ZSB0aGUgVHJhbnNhY3Rpb24gYnVpbGRlciBgVHJhbnNhY3Rpb25zYCAqL1xuICBzdGF0aWMgZ2V0IFRyYW5zYWN0aW9ucygpIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25zO1xuICB9XG5cbiAgLyoqIEEgaGVscGVyIHRvIHJldHJpZXZlIHRoZSBUcmFuc2FjdGlvbiBidWlsZGVyIGBJbnB1dHNgICovXG4gIHN0YXRpYyBnZXQgSW5wdXRzKCkge1xuICAgIHJldHVybiBJbnB1dHM7XG4gIH1cblxuICBzZXRTZW5kZXIoc2VuZGVyOiBzdHJpbmcpIHtcbiAgICB0aGlzLiNibG9ja0RhdGEuc2VuZGVyID0gc2VuZGVyO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZW5kZXIgb25seSBpZiBpdCBoYXMgbm90IGFscmVhZHkgYmVlbiBzZXQuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciBzcG9uc29yZWQgdHJhbnNhY3Rpb24gZmxvd3Mgd2hlcmUgdGhlIHNlbmRlciBtYXkgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSBzaWduZXIgYWRkcmVzcy5cbiAgICovXG4gIHNldFNlbmRlcklmTm90U2V0KHNlbmRlcjogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLiNibG9ja0RhdGEuc2VuZGVyKSB7XG4gICAgICB0aGlzLiNibG9ja0RhdGEuc2VuZGVyID0gc2VuZGVyO1xuICAgIH1cbiAgfVxuICBzZXRFeHBpcmF0aW9uKGV4cGlyYXRpb24/OiBUcmFuc2FjdGlvbkV4cGlyYXRpb24pIHtcbiAgICB0aGlzLiNibG9ja0RhdGEuZXhwaXJhdGlvbiA9IGV4cGlyYXRpb247XG4gIH1cbiAgc2V0R2FzUHJpY2UocHJpY2U6IG51bWJlciB8IGJpZ2ludCkge1xuICAgIHRoaXMuI2Jsb2NrRGF0YS5nYXNDb25maWcucHJpY2UgPSBTdHJpbmcocHJpY2UpO1xuICB9XG4gIHNldEdhc0J1ZGdldChidWRnZXQ6IG51bWJlciB8IGJpZ2ludCkge1xuICAgIHRoaXMuI2Jsb2NrRGF0YS5nYXNDb25maWcuYnVkZ2V0ID0gU3RyaW5nKGJ1ZGdldCk7XG4gIH1cbiAgc2V0R2FzT3duZXIob3duZXI6IHN0cmluZykge1xuICAgIHRoaXMuI2Jsb2NrRGF0YS5nYXNDb25maWcub3duZXIgPSBvd25lcjtcbiAgfVxuICBzZXRHYXNQYXltZW50KHBheW1lbnRzOiBTdWlPYmplY3RSZWZbXSkge1xuICAgIGlmIChwYXltZW50cy5sZW5ndGggPj0gTUFYX0dBU19PQkpFQ1RTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBheW1lbnQgb2JqZWN0cyBleGNlZWQgbWF4aW11bSBhbW91bnQgJHtNQVhfR0FTX09CSkVDVFN9YCk7XG4gICAgfVxuICAgIHRoaXMuI2Jsb2NrRGF0YS5nYXNDb25maWcucGF5bWVudCA9IHBheW1lbnRzLm1hcCgocGF5bWVudCkgPT4gbWFzayhwYXltZW50LCBTdWlPYmplY3RSZWYpKTtcbiAgfVxuXG4gICNibG9ja0RhdGE6IFRyYW5zYWN0aW9uQmxvY2tEYXRhQnVpbGRlcjtcbiAgLyoqIEdldCBhIHNuYXBzaG90IG9mIHRoZSB0cmFuc2FjdGlvbiBkYXRhLCBpbiBKU09OIGZvcm06ICovXG4gIGdldCBibG9ja0RhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Jsb2NrRGF0YS5zbmFwc2hvdCgpO1xuICB9XG5cbiAgLy8gVXNlZCB0byBicmFuZCB0cmFuc2FjdGlvbiBjbGFzc2VzIHNvIHRoYXQgdGhleSBjYW4gYmUgaWRlbnRpZmllZCwgZXZlbiBiZXR3ZWVuIG11bHRpcGxlIGNvcGllc1xuICAvLyBvZiB0aGUgYnVpbGRlci5cbiAgZ2V0IFtUUkFOU0FDVElPTl9CUkFORF0oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih0cmFuc2FjdGlvbj86IFRyYW5zYWN0aW9uQmxvY2spIHtcbiAgICB0aGlzLiNibG9ja0RhdGEgPSBuZXcgVHJhbnNhY3Rpb25CbG9ja0RhdGFCdWlsZGVyKHRyYW5zYWN0aW9uID8gdHJhbnNhY3Rpb24uI2Jsb2NrRGF0YSA6IHVuZGVmaW5lZCk7XG4gIH1cblxuICAvKiogUmV0dXJucyBhbiBhcmd1bWVudCBmb3IgdGhlIGdhcyBjb2luLCB0byBiZSB1c2VkIGluIGEgdHJhbnNhY3Rpb24uICovXG4gIGdldCBnYXMoKTogVHJhbnNhY3Rpb25Bcmd1bWVudCB7XG4gICAgcmV0dXJuIHsga2luZDogJ0dhc0NvaW4nIH07XG4gIH1cblxuICAvKipcbiAgICogRHluYW1pY2FsbHkgY3JlYXRlIGEgbmV3IGlucHV0LCB3aGljaCBpcyBzZXBhcmF0ZSBmcm9tIHRoZSBgaW5wdXRgLiBUaGlzIGlzIGltcG9ydGFudFxuICAgKiBmb3IgZ2VuZXJhdGVkIGNsaWVudHMgdG8gYmUgYWJsZSB0byBkZWZpbmUgdW5pcXVlIGlucHV0cyB0aGF0IGFyZSBub24tb3ZlcmxhcHBpbmcgd2l0aCB0aGVcbiAgICogZGVmaW5lZCBpbnB1dHMuXG4gICAqXG4gICAqIEZvciBgVWludDhBcnJheWAgdHlwZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgdGhlIGlucHV0IGludG8gYSBgUHVyZWAgQ2FsbEFyZywgc2luY2UgdGhpc1xuICAgKiBpcyB0aGUgZm9ybWF0IHJlcXVpcmVkIGZvciBjdXN0b20gc2VyaWFsaXphdGlvbi5cbiAgICpcbiAgICovXG4gIGlucHV0KHR5cGU6ICdvYmplY3QnIHwgJ3B1cmUnLCB2YWx1ZT86IHVua25vd24pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuI2Jsb2NrRGF0YS5pbnB1dHMubGVuZ3RoO1xuICAgIGNvbnN0IGlucHV0ID0gY3JlYXRlKFxuICAgICAge1xuICAgICAgICBraW5kOiAnSW5wdXQnLFxuICAgICAgICAvLyBiaWdpbnRzIGNhbid0IGJlIHNlcmlhbGl6ZWQgdG8gSlNPTiwgc28ganVzdCBzdHJpbmctY29udmVydCB0aGVtIGhlcmU6XG4gICAgICAgIHZhbHVlOiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnID8gU3RyaW5nKHZhbHVlKSA6IHZhbHVlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgdHlwZSxcbiAgICAgIH0sXG4gICAgICBUcmFuc2FjdGlvbkJsb2NrSW5wdXRcbiAgICApO1xuICAgIHRoaXMuI2Jsb2NrRGF0YS5pbnB1dHMucHVzaChpbnB1dCk7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBvYmplY3QgaW5wdXQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgb2JqZWN0KHZhbHVlOiBPYmplY3RJZCB8IE9iamVjdENhbGxBcmcpIHtcbiAgICBjb25zdCBpZCA9IGdldElkRnJvbUNhbGxBcmcodmFsdWUpO1xuICAgIC8vIGRlZHVwbGljYXRlXG4gICAgY29uc3QgaW5zZXJ0ZWQgPSB0aGlzLiNibG9ja0RhdGEuaW5wdXRzLmZpbmQoKGkpID0+IGkudHlwZSA9PT0gJ29iamVjdCcgJiYgaWQgPT09IGdldElkRnJvbUNhbGxBcmcoaS52YWx1ZSkpO1xuICAgIHJldHVybiBpbnNlcnRlZCA/PyB0aGlzLmlucHV0KCdvYmplY3QnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IG5vbi1vYmplY3QgaW5wdXQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgcHVyZShcbiAgICAvKipcbiAgICAgKiBUaGUgcHVyZSB2YWx1ZSB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5wdXQgdmFsdWUuIElmIHRoaXMgaXMgYSBVaW50OEFycmF5LCB0aGVuIHRoZSB2YWx1ZVxuICAgICAqIGlzIGFzc3VtZWQgdG8gYmUgcmF3IGJ5dGVzLCBhbmQgd2lsbCBiZSB1c2VkIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIHZhbHVlOiB1bmtub3duLFxuICAgIC8qKlxuICAgICAqIFRoZSBCQ1MgdHlwZSB0byBzZXJpYWxpemUgdGhlIHZhbHVlIGludG8uIElmIG5vdCBwcm92aWRlZCwgdGhlIHR5cGUgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGRldGVybWluZWRcbiAgICAgKiBiYXNlZCBvbiBob3cgdGhlIGlucHV0IGlzIHVzZWQuXG4gICAgICovXG4gICAgdHlwZT86IHN0cmluZ1xuICApIHtcbiAgICAvLyBUT0RPOiB3ZSBjYW4gYWxzbyBkbyBzb21lIGRlZHVwbGljYXRpb24gaGVyZVxuICAgIHJldHVybiB0aGlzLmlucHV0KFxuICAgICAgJ3B1cmUnLFxuICAgICAgdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gSW5wdXRzLlB1cmUodmFsdWUpIDogdHlwZSA/IElucHV0cy5QdXJlKHZhbHVlLCB0eXBlKSA6IHZhbHVlXG4gICAgKTtcbiAgfVxuXG4gIC8qKiBBZGQgYSB0cmFuc2FjdGlvbiB0byB0aGUgdHJhbnNhY3Rpb24gYmxvY2suICovXG4gIGFkZCh0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25UeXBlKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNibG9ja0RhdGEudHJhbnNhY3Rpb25zLnB1c2godHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiBjcmVhdGVUcmFuc2FjdGlvblJlc3VsdChpbmRleCAtIDEpO1xuICB9XG5cbiAgLy8gTWV0aG9kIHNob3J0aGFuZHM6XG5cbiAgc3BsaXRDb2lucyguLi5hcmdzOiBQYXJhbWV0ZXJzPCh0eXBlb2YgVHJhbnNhY3Rpb25zKVsnU3BsaXRDb2lucyddPikge1xuICAgIHJldHVybiB0aGlzLmFkZChUcmFuc2FjdGlvbnMuU3BsaXRDb2lucyguLi5hcmdzKSk7XG4gIH1cbiAgbWVyZ2VDb2lucyguLi5hcmdzOiBQYXJhbWV0ZXJzPCh0eXBlb2YgVHJhbnNhY3Rpb25zKVsnTWVyZ2VDb2lucyddPikge1xuICAgIHJldHVybiB0aGlzLmFkZChUcmFuc2FjdGlvbnMuTWVyZ2VDb2lucyguLi5hcmdzKSk7XG4gIH1cbiAgcHVibGlzaCguLi5hcmdzOiBQYXJhbWV0ZXJzPCh0eXBlb2YgVHJhbnNhY3Rpb25zKVsnUHVibGlzaCddPikge1xuICAgIHJldHVybiB0aGlzLmFkZChUcmFuc2FjdGlvbnMuUHVibGlzaCguLi5hcmdzKSk7XG4gIH1cbiAgbW92ZUNhbGwoLi4uYXJnczogUGFyYW1ldGVyczwodHlwZW9mIFRyYW5zYWN0aW9ucylbJ01vdmVDYWxsJ10+KSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkKFRyYW5zYWN0aW9ucy5Nb3ZlQ2FsbCguLi5hcmdzKSk7XG4gIH1cbiAgdHJhbnNmZXJPYmplY3RzKC4uLmFyZ3M6IFBhcmFtZXRlcnM8KHR5cGVvZiBUcmFuc2FjdGlvbnMpWydUcmFuc2Zlck9iamVjdHMnXT4pIHtcbiAgICByZXR1cm4gdGhpcy5hZGQoVHJhbnNhY3Rpb25zLlRyYW5zZmVyT2JqZWN0cyguLi5hcmdzKSk7XG4gIH1cbiAgbWFrZU1vdmVWZWMoLi4uYXJnczogUGFyYW1ldGVyczwodHlwZW9mIFRyYW5zYWN0aW9ucylbJ01ha2VNb3ZlVmVjJ10+KSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkKFRyYW5zYWN0aW9ucy5NYWtlTW92ZVZlYyguLi5hcmdzKSk7XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSB0cmFuc2FjdGlvbiB0byBhIHN0cmluZyBzbyB0aGF0IGl0IGNhbiBiZSBzZW50IHRvIGEgc2VwYXJhdGUgY29udGV4dC5cbiAgICogVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBgYnVpbGRgIGluIHRoYXQgaXQgZG9lcyBub3Qgc2VyaWFsaXplIHRvIEJDUyBieXRlcywgYW5kIGluc3RlYWRcbiAgICogdXNlcyBhIHNlcGFyYXRlIGZvcm1hdCB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdHJhbnNhY3Rpb24gYnVpbGRlci4gVGhpcyBhbGxvd3NcbiAgICogdXMgdG8gc2VyaWFsaXplIHBhcnRpYWxseS1jb21wbGV0ZSB0cmFuc2FjdGlvbnMsIHRoYXQgY2FuIHRoZW4gYmUgY29tcGxldGVkIGFuZFxuICAgKiBidWlsdCBpbiBhIHNlcGFyYXRlIGNvbnRleHQuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBhIGRhcHAgY2FuIGNvbnN0cnVjdCBhIHRyYW5zYWN0aW9uLCBidXQgbm90IHByb3ZpZGUgZ2FzIG9iamVjdHNcbiAgICogb3IgYSBnYXMgYnVkZ2V0LiBUaGUgdHJhbnNhY3Rpb24gdGhlbiBjYW4gYmUgc2VudCB0byB0aGUgd2FsbGV0LCB3aGVyZSB0aGlzXG4gICAqIGluZm9ybWF0aW9uIGlzIGF1dG9tYXRpY2FsbHkgZmlsbGVkIGluIChlLmcuIGJ5IHF1ZXJ5aW5nIGZvciBjb2luIG9iamVjdHNcbiAgICogYW5kIHBlcmZvcm1pbmcgYSBkcnkgcnVuKS5cbiAgICovXG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy4jYmxvY2tEYXRhLnNuYXBzaG90KCkpO1xuICB9XG5cbiAgLyoqIEJ1aWxkIHRoZSB0cmFuc2FjdGlvbiB0byBCQ1MgYnl0ZXMuICovXG4gIGFzeW5jIGJ1aWxkKHsgb25seVRyYW5zYWN0aW9uS2luZCB9OiBCdWlsZE9wdGlvbnMgPSB7fSk6IFByb21pc2U8VWludDhBcnJheT4ge1xuICAgIHJldHVybiB0aGlzLiNibG9ja0RhdGEuYnVpbGQoeyBvbmx5VHJhbnNhY3Rpb25LaW5kIH0pO1xuICB9XG5cbiAgLyoqIERlcml2ZSB0cmFuc2FjdGlvbiBkaWdlc3QgKi9cbiAgYXN5bmMgZ2V0RGlnZXN0KCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuI2Jsb2NrRGF0YS5nZXREaWdlc3QoKTtcbiAgfVxufVxuIl19