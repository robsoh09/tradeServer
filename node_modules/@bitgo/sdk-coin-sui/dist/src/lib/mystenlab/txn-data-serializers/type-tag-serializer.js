"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeTagSerializer = void 0;
const types_1 = require("../types");
const VECTOR_REGEX = /^vector<(.+)>$/;
const STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
class TypeTagSerializer {
    static parseFromStr(str, normalizeAddress = false) {
        if (str === 'address') {
            return { address: null };
        }
        else if (str === 'bool') {
            return { bool: null };
        }
        else if (str === 'u8') {
            return { u8: null };
        }
        else if (str === 'u16') {
            return { u16: null };
        }
        else if (str === 'u32') {
            return { u32: null };
        }
        else if (str === 'u64') {
            return { u64: null };
        }
        else if (str === 'u128') {
            return { u128: null };
        }
        else if (str === 'u256') {
            return { u256: null };
        }
        else if (str === 'signer') {
            return { signer: null };
        }
        const vectorMatch = str.match(VECTOR_REGEX);
        if (vectorMatch) {
            return {
                vector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),
            };
        }
        const structMatch = str.match(STRUCT_REGEX);
        if (structMatch) {
            const address = normalizeAddress ? (0, types_1.normalizeSuiAddress)(structMatch[1]) : structMatch[1];
            return {
                struct: {
                    address,
                    module: structMatch[2],
                    name: structMatch[3],
                    typeParams: structMatch[5] === undefined ? [] : TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress),
                },
            };
        }
        throw new Error(`Encountered unexpected token when parsing type args for ${str}`);
    }
    static parseStructTypeArgs(str, normalizeAddress = false) {
        // split `str` by all `,` outside angle brackets
        const tok = [];
        let word = '';
        let nestedAngleBrackets = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str[i];
            if (char === '<') {
                nestedAngleBrackets++;
            }
            if (char === '>') {
                nestedAngleBrackets--;
            }
            if (nestedAngleBrackets === 0 && char === ',') {
                tok.push(word.trim());
                word = '';
                continue;
            }
            word += char;
        }
        tok.push(word.trim());
        return tok.map((tok) => TypeTagSerializer.parseFromStr(tok, normalizeAddress));
    }
    static tagToString(tag) {
        if ('bool' in tag) {
            return 'bool';
        }
        if ('u8' in tag) {
            return 'u8';
        }
        if ('u16' in tag) {
            return 'u16';
        }
        if ('u32' in tag) {
            return 'u32';
        }
        if ('u64' in tag) {
            return 'u64';
        }
        if ('u128' in tag) {
            return 'u128';
        }
        if ('u256' in tag) {
            return 'u256';
        }
        if ('address' in tag) {
            return 'address';
        }
        if ('signer' in tag) {
            return 'signer';
        }
        if ('vector' in tag) {
            return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;
        }
        if ('struct' in tag) {
            const struct = tag.struct;
            const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');
            return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ''}`;
        }
        throw new Error('Invalid TypeTag');
    }
}
exports.TypeTagSerializer = TypeTagSerializer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS10YWctc2VyaWFsaXplci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvbXlzdGVubGFiL3R4bi1kYXRhLXNlcmlhbGl6ZXJzL3R5cGUtdGFnLXNlcmlhbGl6ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsb0NBQXdEO0FBRXhELE1BQU0sWUFBWSxHQUFHLGdCQUFnQixDQUFDO0FBQ3RDLE1BQU0sWUFBWSxHQUFHLHFDQUFxQyxDQUFDO0FBRTNELE1BQWEsaUJBQWlCO0lBQzVCLE1BQU0sQ0FBQyxZQUFZLENBQUMsR0FBVyxFQUFFLGdCQUFnQixHQUFHLEtBQUs7UUFDdkQsSUFBSSxHQUFHLEtBQUssU0FBUyxFQUFFO1lBQ3JCLE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUM7U0FDMUI7YUFBTSxJQUFJLEdBQUcsS0FBSyxNQUFNLEVBQUU7WUFDekIsT0FBTyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQztTQUN2QjthQUFNLElBQUksR0FBRyxLQUFLLElBQUksRUFBRTtZQUN2QixPQUFPLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxDQUFDO1NBQ3JCO2FBQU0sSUFBSSxHQUFHLEtBQUssS0FBSyxFQUFFO1lBQ3hCLE9BQU8sRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLENBQUM7U0FDdEI7YUFBTSxJQUFJLEdBQUcsS0FBSyxLQUFLLEVBQUU7WUFDeEIsT0FBTyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztTQUN0QjthQUFNLElBQUksR0FBRyxLQUFLLEtBQUssRUFBRTtZQUN4QixPQUFPLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxDQUFDO1NBQ3RCO2FBQU0sSUFBSSxHQUFHLEtBQUssTUFBTSxFQUFFO1lBQ3pCLE9BQU8sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUM7U0FDdkI7YUFBTSxJQUFJLEdBQUcsS0FBSyxNQUFNLEVBQUU7WUFD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bSAnLi4vdHlwZXMnO1xuXG5jb25zdCBWRUNUT1JfUkVHRVggPSAvXnZlY3RvcjwoLispPiQvO1xuY29uc3QgU1RSVUNUX1JFR0VYID0gL14oW146XSspOjooW146XSspOjooW148XSspKDwoLispPik/LztcblxuZXhwb3J0IGNsYXNzIFR5cGVUYWdTZXJpYWxpemVyIHtcbiAgc3RhdGljIHBhcnNlRnJvbVN0cihzdHI6IHN0cmluZywgbm9ybWFsaXplQWRkcmVzcyA9IGZhbHNlKTogVHlwZVRhZyB7XG4gICAgaWYgKHN0ciA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICByZXR1cm4geyBhZGRyZXNzOiBudWxsIH07XG4gICAgfSBlbHNlIGlmIChzdHIgPT09ICdib29sJykge1xuICAgICAgcmV0dXJuIHsgYm9vbDogbnVsbCB9O1xuICAgIH0gZWxzZSBpZiAoc3RyID09PSAndTgnKSB7XG4gICAgICByZXR1cm4geyB1ODogbnVsbCB9O1xuICAgIH0gZWxzZSBpZiAoc3RyID09PSAndTE2Jykge1xuICAgICAgcmV0dXJuIHsgdTE2OiBudWxsIH07XG4gICAgfSBlbHNlIGlmIChzdHIgPT09ICd1MzInKSB7XG4gICAgICByZXR1cm4geyB1MzI6IG51bGwgfTtcbiAgICB9IGVsc2UgaWYgKHN0ciA9PT0gJ3U2NCcpIHtcbiAgICAgIHJldHVybiB7IHU2NDogbnVsbCB9O1xuICAgIH0gZWxzZSBpZiAoc3RyID09PSAndTEyOCcpIHtcbiAgICAgIHJldHVybiB7IHUxMjg6IG51bGwgfTtcbiAgICB9IGVsc2UgaWYgKHN0ciA9PT0gJ3UyNTYnKSB7XG4gICAgICByZXR1cm4geyB1MjU2OiBudWxsIH07XG4gICAgfSBlbHNlIGlmIChzdHIgPT09ICdzaWduZXInKSB7XG4gICAgICByZXR1cm4geyBzaWduZXI6IG51bGwgfTtcbiAgICB9XG4gICAgY29uc3QgdmVjdG9yTWF0Y2ggPSBzdHIubWF0Y2goVkVDVE9SX1JFR0VYKTtcbiAgICBpZiAodmVjdG9yTWF0Y2gpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlY3RvcjogVHlwZVRhZ1NlcmlhbGl6ZXIucGFyc2VGcm9tU3RyKHZlY3Rvck1hdGNoWzFdLCBub3JtYWxpemVBZGRyZXNzKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3Qgc3RydWN0TWF0Y2ggPSBzdHIubWF0Y2goU1RSVUNUX1JFR0VYKTtcbiAgICBpZiAoc3RydWN0TWF0Y2gpIHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBub3JtYWxpemVBZGRyZXNzID8gbm9ybWFsaXplU3VpQWRkcmVzcyhzdHJ1Y3RNYXRjaFsxXSkgOiBzdHJ1Y3RNYXRjaFsxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cnVjdDoge1xuICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgbW9kdWxlOiBzdHJ1Y3RNYXRjaFsyXSxcbiAgICAgICAgICBuYW1lOiBzdHJ1Y3RNYXRjaFszXSxcbiAgICAgICAgICB0eXBlUGFyYW1zOlxuICAgICAgICAgICAgc3RydWN0TWF0Y2hbNV0gPT09IHVuZGVmaW5lZCA/IFtdIDogVHlwZVRhZ1NlcmlhbGl6ZXIucGFyc2VTdHJ1Y3RUeXBlQXJncyhzdHJ1Y3RNYXRjaFs1XSwgbm9ybWFsaXplQWRkcmVzcyksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihgRW5jb3VudGVyZWQgdW5leHBlY3RlZCB0b2tlbiB3aGVuIHBhcnNpbmcgdHlwZSBhcmdzIGZvciAke3N0cn1gKTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZVN0cnVjdFR5cGVBcmdzKHN0cjogc3RyaW5nLCBub3JtYWxpemVBZGRyZXNzID0gZmFsc2UpOiBUeXBlVGFnW10ge1xuICAgIC8vIHNwbGl0IGBzdHJgIGJ5IGFsbCBgLGAgb3V0c2lkZSBhbmdsZSBicmFja2V0c1xuICAgIGNvbnN0IHRvazogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgIGxldCB3b3JkID0gJyc7XG4gICAgbGV0IG5lc3RlZEFuZ2xlQnJhY2tldHMgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gc3RyW2ldO1xuICAgICAgaWYgKGNoYXIgPT09ICc8Jykge1xuICAgICAgICBuZXN0ZWRBbmdsZUJyYWNrZXRzKys7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJz4nKSB7XG4gICAgICAgIG5lc3RlZEFuZ2xlQnJhY2tldHMtLTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXN0ZWRBbmdsZUJyYWNrZXRzID09PSAwICYmIGNoYXIgPT09ICcsJykge1xuICAgICAgICB0b2sucHVzaCh3b3JkLnRyaW0oKSk7XG4gICAgICAgIHdvcmQgPSAnJztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB3b3JkICs9IGNoYXI7XG4gICAgfVxuXG4gICAgdG9rLnB1c2god29yZC50cmltKCkpO1xuXG4gICAgcmV0dXJuIHRvay5tYXAoKHRvaykgPT4gVHlwZVRhZ1NlcmlhbGl6ZXIucGFyc2VGcm9tU3RyKHRvaywgbm9ybWFsaXplQWRkcmVzcykpO1xuICB9XG5cbiAgc3RhdGljIHRhZ1RvU3RyaW5nKHRhZzogVHlwZVRhZyk6IHN0cmluZyB7XG4gICAgaWYgKCdib29sJyBpbiB0YWcpIHtcbiAgICAgIHJldHVybiAnYm9vbCc7XG4gICAgfVxuICAgIGlmICgndTgnIGluIHRhZykge1xuICAgICAgcmV0dXJuICd1OCc7XG4gICAgfVxuICAgIGlmICgndTE2JyBpbiB0YWcpIHtcbiAgICAgIHJldHVybiAndTE2JztcbiAgICB9XG4gICAgaWYgKCd1MzInIGluIHRhZykge1xuICAgICAgcmV0dXJuICd1MzInO1xuICAgIH1cbiAgICBpZiAoJ3U2NCcgaW4gdGFnKSB7XG4gICAgICByZXR1cm4gJ3U2NCc7XG4gICAgfVxuICAgIGlmICgndTEyOCcgaW4gdGFnKSB7XG4gICAgICByZXR1cm4gJ3UxMjgnO1xuICAgIH1cbiAgICBpZiAoJ3UyNTYnIGluIHRhZykge1xuICAgICAgcmV0dXJuICd1MjU2JztcbiAgICB9XG4gICAgaWYgKCdhZGRyZXNzJyBpbiB0YWcpIHtcbiAgICAgIHJldHVybiAnYWRkcmVzcyc7XG4gICAgfVxuICAgIGlmICgnc2lnbmVyJyBpbiB0YWcpIHtcbiAgICAgIHJldHVybiAnc2lnbmVyJztcbiAgICB9XG4gICAgaWYgKCd2ZWN0b3InIGluIHRhZykge1xuICAgICAgcmV0dXJuIGB2ZWN0b3I8JHtUeXBlVGFnU2VyaWFsaXplci50YWdUb1N0cmluZyh0YWcudmVjdG9yKX0+YDtcbiAgICB9XG4gICAgaWYgKCdzdHJ1Y3QnIGluIHRhZykge1xuICAgICAgY29uc3Qgc3RydWN0ID0gdGFnLnN0cnVjdDtcbiAgICAgIGNvbnN0IHR5cGVQYXJhbXMgPSBzdHJ1Y3QudHlwZVBhcmFtcy5tYXAoVHlwZVRhZ1NlcmlhbGl6ZXIudGFnVG9TdHJpbmcpLmpvaW4oJywgJyk7XG4gICAgICByZXR1cm4gYCR7c3RydWN0LmFkZHJlc3N9Ojoke3N0cnVjdC5tb2R1bGV9Ojoke3N0cnVjdC5uYW1lfSR7dHlwZVBhcmFtcyA/IGA8JHt0eXBlUGFyYW1zfT5gIDogJyd9YDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFR5cGVUYWcnKTtcbiAgfVxufVxuIl19