"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AvaxP = void 0;
const statics_1 = require("@bitgo/statics");
const sdk_core_1 = require("@bitgo/sdk-core");
const AvaxpLib = __importStar(require("./lib"));
const utils_1 = __importDefault(require("./lib/utils"));
const lodash_1 = __importDefault(require("lodash"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ethereumjs_util_1 = require("ethereumjs-util");
class AvaxP extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new AvaxP(bitgo, staticsCoin);
    }
    getChain() {
        return this._staticsCoin.name;
    }
    getFamily() {
        return this._staticsCoin.family;
    }
    getFullName() {
        return this._staticsCoin.fullName;
    }
    getBaseFactor() {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    }
    /**
     * Check if staking txn is valid, based on expected tx params.
     *
     * @param {AvaxpTransactionStakingOptions} stakingOptions expected staking params to check against
     * @param {AvaxpLib.TransactionExplanation} explainedTx explained staking transaction
     */
    validateStakingTx(stakingOptions, explainedTx) {
        const filteredRecipients = [{ address: stakingOptions.nodeID, amount: stakingOptions.amount }];
        const filteredOutputs = explainedTx.outputs.map((output) => lodash_1.default.pick(output, ['address', 'amount']));
        if (!lodash_1.default.isEqual(filteredOutputs, filteredRecipients)) {
            throw new Error('Tx outputs does not match with expected txParams');
        }
        if ((stakingOptions === null || stakingOptions === void 0 ? void 0 : stakingOptions.amount) !== explainedTx.outputAmount) {
            throw new Error('Tx total amount does not match with expected total amount field');
        }
    }
    /**
     * Check if export txn is valid, based on expected tx params.
     *
     * @param {ITransactionRecipient[]} recipients expected recipients and info
     * @param {AvaxpLib.TransactionExplanation} explainedTx explained export transaction
     */
    validateExportTx(recipients, explainedTx) {
        if (recipients.length !== 1 || explainedTx.outputs.length !== 1) {
            throw new Error('Export Tx requires one recipient');
        }
        const maxImportFee = this._staticsCoin.network.maxImportFee;
        const recipientAmount = new bignumber_js_1.default(recipients[0].amount);
        if (recipientAmount.isGreaterThan(explainedTx.outputAmount) ||
            recipientAmount.plus(maxImportFee).isLessThan(explainedTx.outputAmount)) {
            throw new Error(`Tx total amount ${explainedTx.outputAmount} does not match with expected total amount field ${recipientAmount} and max import fee ${maxImportFee}`);
        }
        if (explainedTx.outputs && !utils_1.default.isValidAddress(explainedTx.outputs[0].address)) {
            throw new Error(`Invalid P-chain address ${explainedTx.outputs[0].address}`);
        }
    }
    /**
     * Check if import txn into P is valid, based on expected tx params.
     *
     * @param {AvaxpLib.AvaxpEntry[]} explainedTxInputs tx inputs (unspents to be imported)
     * @param {AvaxpTransactionParams} txParams expected tx info to check against
     */
    validateImportTx(explainedTxInputs, txParams) {
        if (txParams.unspents) {
            if (explainedTxInputs.length !== txParams.unspents.length) {
                throw new Error(`Expected ${txParams.unspents.length} UTXOs, transaction had ${explainedTxInputs.length}`);
            }
            const unspents = new Set(txParams.unspents);
            for (const unspent of explainedTxInputs) {
                if (!unspents.has(unspent.id)) {
                    throw new Error(`Transaction should not contain the UTXO: ${unspent.id}`);
                }
            }
        }
    }
    async verifyTransaction(params) {
        var _a;
        const txHex = params.txPrebuild && params.txPrebuild.txHex;
        if (!txHex) {
            throw new Error('missing required tx prebuild property txHex');
        }
        let tx;
        try {
            const txBuilder = this.getBuilder().from(txHex);
            tx = await txBuilder.build();
        }
        catch (error) {
            throw new Error('Invalid transaction');
        }
        const explainedTx = tx.explainTransaction();
        const { type, stakingOptions } = params.txParams;
        // TODO(BG-62112): change ImportToC type to Import
        if (!type || (type !== 'ImportToC' && explainedTx.type !== sdk_core_1.TransactionType[type])) {
            throw new Error('Tx type does not match with expected txParams type');
        }
        switch (explainedTx.type) {
            // @deprecated
            case sdk_core_1.TransactionType.AddDelegator:
            case sdk_core_1.TransactionType.AddValidator:
            case sdk_core_1.TransactionType.AddPermissionlessDelegator:
            case sdk_core_1.TransactionType.AddPermissionlessValidator:
                this.validateStakingTx(stakingOptions, explainedTx);
                break;
            case sdk_core_1.TransactionType.Export:
                if (!params.txParams.recipients || ((_a = params.txParams.recipients) === null || _a === void 0 ? void 0 : _a.length) !== 1) {
                    throw new Error('Export Tx requires a recipient');
                }
                else {
                    this.validateExportTx(params.txParams.recipients, explainedTx);
                }
                break;
            case sdk_core_1.TransactionType.Import:
                if (tx.isTransactionForCChain) {
                    // Import to C-chain
                    if (explainedTx.outputs.length !== 1) {
                        throw new Error('Expected 1 output in import transaction');
                    }
                    if (!params.txParams.recipients || params.txParams.recipients.length !== 1) {
                        throw new Error('Expected 1 recipient in import transaction');
                    }
                }
                else {
                    // Import to P-chain
                    if (explainedTx.outputs.length !== 1) {
                        throw new Error('Expected 1 output in import transaction');
                    }
                    this.validateImportTx(explainedTx.inputs, params.txParams);
                }
                break;
            default:
                throw new Error('Tx type is not supported yet');
        }
        return true;
    }
    /**
     * Check if address is valid, then make sure it matches the root address.
     *
     * @param params.address address to validate
     * @param params.keychains public keys to generate the wallet
     */
    async isWalletAddress(params) {
        const { address, keychains } = params;
        if (!this.isValidAddress(address)) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        if (!keychains || keychains.length !== 3) {
            throw new Error('Invalid keychains');
        }
        // multisig addresses are separated by ~
        const splitAddresses = address.split('~');
        // derive addresses from keychain
        const unlockAddresses = keychains.map((keychain) => new AvaxpLib.KeyPair({ pub: keychain.pub }).getAddress(this._staticsCoin.network.type));
        if (splitAddresses.length !== unlockAddresses.length) {
            throw new sdk_core_1.UnexpectedAddressError(`address validation failure: multisig address length does not match`);
        }
        if (!this.adressesArraysMatch(splitAddresses, unlockAddresses)) {
            throw new sdk_core_1.UnexpectedAddressError(`address validation failure: ${address} is not of this wallet`);
        }
        return true;
    }
    /**
     * Validate that two multisig address arrays have the same elements, order doesnt matter
     * @param addressArray1
     * @param addressArray2
     * @returns true if address arrays have the same addresses
     * @private
     */
    adressesArraysMatch(addressArray1, addressArray2) {
        return JSON.stringify(addressArray1.sort()) === JSON.stringify(addressArray2.sort());
    }
    /**
     * Generate Avaxp key pair
     *
     * @param {Buffer} seed - Seed from which the new keypair should be generated, otherwise a random seed is used
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed) {
        const keyPair = seed ? new AvaxpLib.KeyPair({ seed }) : new AvaxpLib.KeyPair();
        const keys = keyPair.getKeys();
        if (!keys.prv) {
            throw new Error('Missing prv in key generation.');
        }
        return {
            pub: keys.pub,
            prv: keys.prv,
        };
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {string} pub the prv to be checked
     * @returns is it valid?
     */
    isValidPub(pub) {
        try {
            new AvaxpLib.KeyPair({ pub });
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param {string} prv the prv to be checked
     * @returns is it valid?
     */
    isValidPrv(prv) {
        try {
            new AvaxpLib.KeyPair({ prv });
            return true;
        }
        catch (e) {
            return false;
        }
    }
    isValidAddress(address) {
        if (address === undefined) {
            return false;
        }
        // validate eth address for cross-chain txs to c-chain
        if (typeof address === 'string' && (0, ethereumjs_util_1.isValidAddress)(address)) {
            return true;
        }
        return AvaxpLib.Utils.isValidAddress(address);
    }
    /**
     * Signs Avaxp transaction
     */
    async signTransaction(params) {
        // deserialize raw transaction (note: fromAddress has onchain order)
        const txBuilder = this.getBuilder().from(params.txPrebuild.txHex);
        const key = params.prv;
        // push the keypair to signer array
        txBuilder.sign({ key });
        // build the transaction
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new sdk_core_1.InvalidTransactionError('Error while trying to build transaction');
        }
        return transaction.signature.length >= 2
            ? { txHex: transaction.toBroadcastFormat() }
            : { halfSigned: { txHex: transaction.toBroadcastFormat() } };
    }
    async feeEstimate(params) {
        // staking transactions are fee-less
        return { fee: '0' };
    }
    async parseTransaction(params) {
        return {};
    }
    /**
     * Explain a Avaxp transaction from txHex
     * @param params
     * @param callback
     */
    async explainTransaction(params) {
        var _a, _b;
        const txHex = (_a = params.txHex) !== null && _a !== void 0 ? _a : (_b = params === null || params === void 0 ? void 0 : params.halfSigned) === null || _b === void 0 ? void 0 : _b.txHex;
        if (!txHex) {
            throw new Error('missing transaction hex');
        }
        try {
            const txBuilder = this.getBuilder().from(txHex);
            const tx = await txBuilder.build();
            return tx.explainTransaction();
        }
        catch (e) {
            throw new Error(`Invalid transaction: ${e.message}`);
        }
    }
    recoverySignature(message, signature) {
        return AvaxpLib.Utils.recoverySignature(this._staticsCoin.network, message, signature);
    }
    async signMessage(key, message) {
        const prv = new AvaxpLib.KeyPair(key).getPrivateKey();
        if (!prv) {
            throw new sdk_core_1.SigningError('Invalid key pair options');
        }
        if (typeof message === 'string') {
            message = Buffer.from(message, 'hex');
        }
        return AvaxpLib.Utils.createSignature(this._staticsCoin.network, message, prv);
    }
    getBuilder() {
        return new AvaxpLib.TransactionBuilderFactory(statics_1.coins.get(this.getChain()));
    }
}
exports.AvaxP = AvaxP;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZheHAuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYXZheHAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw0Q0FBa0c7QUFDbEcsOENBZ0J5QjtBQUN6QixnREFBa0M7QUFTbEMsd0RBQWdDO0FBQ2hDLG9EQUF1QjtBQUN2QixnRUFBcUM7QUFDckMscURBQXNFO0FBRXRFLE1BQWEsS0FBTSxTQUFRLG1CQUFRO0lBR2pDLFlBQVksS0FBZ0IsRUFBRSxXQUF1QztRQUNuRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFYixJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztTQUN2RTtRQUVELElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO0lBQ2xDLENBQUM7SUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLEtBQWdCLEVBQUUsV0FBdUM7UUFDN0UsT0FBTyxJQUFJLEtBQUssQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVELFFBQVE7UUFDTixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDO0lBQ2hDLENBQUM7SUFDRCxTQUFTO1FBQ1AsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQztJQUNsQyxDQUFDO0lBQ0QsV0FBVztRQUNULE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUM7SUFDcEMsQ0FBQztJQUNELGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsaUJBQWlCLENBQ2YsY0FBOEMsRUFDOUMsV0FBNEM7UUFFNUMsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLEVBQUUsT0FBTyxF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QyxDQUFDO1NBQ3ZDO1FBQ0QsT0FBTyxRQUFRLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQTJCLEVBQUUsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3JHLENBQUM7SUFFTyxVQUFVO1FBQ2hCLE9BQU8sSUFBSSxRQUFRLENBQUMseUJBQXlCLENBQUMsZUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzVFLENBQUM7Q0FDRjtBQTlVRCxzQkE4VUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBdmFsYW5jaGVOZXR3b3JrLCBCYXNlQ29pbiBhcyBTdGF0aWNzQmFzZUNvaW4sIENvaW5GYW1pbHksIGNvaW5zIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHtcbiAgQmFzZUNvaW4sXG4gIEJpdEdvQmFzZSxcbiAgS2V5UGFpcixcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgQmFzZVRyYW5zYWN0aW9uLFxuICBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcixcbiAgRmVlRXN0aW1hdGVPcHRpb25zLFxuICBTaWduaW5nRXJyb3IsXG4gIFRyYW5zYWN0aW9uVHlwZSxcbiAgSW52YWxpZEFkZHJlc3NFcnJvcixcbiAgVW5leHBlY3RlZEFkZHJlc3NFcnJvcixcbiAgSVRyYW5zYWN0aW9uUmVjaXBpZW50LFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCAqIGFzIEF2YXhwTGliIGZyb20gJy4vbGliJztcbmltcG9ydCB7XG4gIEF2YXhwU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25GZWUsXG4gIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMsXG4gIEF2YXhwVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBBdmF4cFRyYW5zYWN0aW9uU3Rha2luZ09wdGlvbnMsXG4gIEF2YXhwVHJhbnNhY3Rpb25QYXJhbXMsXG59IGZyb20gJy4vaWZhY2UnO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4vbGliL3V0aWxzJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBpc1ZhbGlkQWRkcmVzcyBhcyBpc1ZhbGlkRXRoQWRkcmVzcyB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5cbmV4cG9ydCBjbGFzcyBBdmF4UCBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9zdGF0aWNzQ29pbjogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPjtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pIHtcbiAgICBzdXBlcihiaXRnbyk7XG5cbiAgICBpZiAoIXN0YXRpY3NDb2luKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgY29uc3RydWN0b3IgcGFyYW1ldGVyIHN0YXRpY3NDb2luJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGljc0NvaW4gPSBzdGF0aWNzQ29pbjtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R29CYXNlLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBBdmF4UChiaXRnbywgc3RhdGljc0NvaW4pO1xuICB9XG5cbiAgZ2V0Q2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4ubmFtZTtcbiAgfVxuICBnZXRGYW1pbHkoKTogQ29pbkZhbWlseSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZhbWlseTtcbiAgfVxuICBnZXRGdWxsTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5mdWxsTmFtZTtcbiAgfVxuICBnZXRCYXNlRmFjdG9yKCk6IHN0cmluZyB8IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGF0aWNzQ29pbi5kZWNpbWFsUGxhY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBzdGFraW5nIHR4biBpcyB2YWxpZCwgYmFzZWQgb24gZXhwZWN0ZWQgdHggcGFyYW1zLlxuICAgKlxuICAgKiBAcGFyYW0ge0F2YXhwVHJhbnNhY3Rpb25TdGFraW5nT3B0aW9uc30gc3Rha2luZ09wdGlvbnMgZXhwZWN0ZWQgc3Rha2luZyBwYXJhbXMgdG8gY2hlY2sgYWdhaW5zdFxuICAgKiBAcGFyYW0ge0F2YXhwTGliLlRyYW5zYWN0aW9uRXhwbGFuYXRpb259IGV4cGxhaW5lZFR4IGV4cGxhaW5lZCBzdGFraW5nIHRyYW5zYWN0aW9uXG4gICAqL1xuICB2YWxpZGF0ZVN0YWtpbmdUeChcbiAgICBzdGFraW5nT3B0aW9uczogQXZheHBUcmFuc2FjdGlvblN0YWtpbmdPcHRpb25zLFxuICAgIGV4cGxhaW5lZFR4OiBBdmF4cExpYi5UcmFuc2FjdGlvbkV4cGxhbmF0aW9uXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGZpbHRlcmVkUmVjaXBpZW50cyA9IFt7IGFkZHJlc3M6IHN0YWtpbmdPcHRpb25zLm5vZGVJRCwgYW1vdW50OiBzdGFraW5nT3B0aW9ucy5hbW91bnQgfV07XG4gICAgY29uc3QgZmlsdGVyZWRPdXRwdXRzID0gZXhwbGFpbmVkVHgub3V0cHV0cy5tYXAoKG91dHB1dCkgPT4gXy5waWNrKG91dHB1dCwgWydhZGRyZXNzJywgJ2Ftb3VudCddKSk7XG5cbiAgICBpZiAoIV8uaXNFcXVhbChmaWx0ZXJlZE91dHB1dHMsIGZpbHRlcmVkUmVjaXBpZW50cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHggb3V0cHV0cyBkb2VzIG5vdCBtYXRjaCB3aXRoIGV4cGVjdGVkIHR4UGFyYW1zJyk7XG4gICAgfVxuICAgIGlmIChzdGFraW5nT3B0aW9ucz8uYW1vdW50ICE9PSBleHBsYWluZWRUeC5vdXRwdXRBbW91bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHggdG90YWwgYW1vdW50IGRvZXMgbm90IG1hdGNoIHdpdGggZXhwZWN0ZWQgdG90YWwgYW1vdW50IGZpZWxkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGV4cG9ydCB0eG4gaXMgdmFsaWQsIGJhc2VkIG9uIGV4cGVjdGVkIHR4IHBhcmFtcy5cbiAgICpcbiAgICogQHBhcmFtIHtJVHJhbnNhY3Rpb25SZWNpcGllbnRbXX0gcmVjaXBpZW50cyBleHBlY3RlZCByZWNpcGllbnRzIGFuZCBpbmZvXG4gICAqIEBwYXJhbSB7QXZheHBMaWIuVHJhbnNhY3Rpb25FeHBsYW5hdGlvbn0gZXhwbGFpbmVkVHggZXhwbGFpbmVkIGV4cG9ydCB0cmFuc2FjdGlvblxuICAgKi9cbiAgdmFsaWRhdGVFeHBvcnRUeChyZWNpcGllbnRzOiBJVHJhbnNhY3Rpb25SZWNpcGllbnRbXSwgZXhwbGFpbmVkVHg6IEF2YXhwTGliLlRyYW5zYWN0aW9uRXhwbGFuYXRpb24pOiB2b2lkIHtcbiAgICBpZiAocmVjaXBpZW50cy5sZW5ndGggIT09IDEgfHwgZXhwbGFpbmVkVHgub3V0cHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwb3J0IFR4IHJlcXVpcmVzIG9uZSByZWNpcGllbnQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXhJbXBvcnRGZWUgPSAodGhpcy5fc3RhdGljc0NvaW4ubmV0d29yayBhcyBBdmFsYW5jaGVOZXR3b3JrKS5tYXhJbXBvcnRGZWU7XG4gICAgY29uc3QgcmVjaXBpZW50QW1vdW50ID0gbmV3IEJpZ051bWJlcihyZWNpcGllbnRzWzBdLmFtb3VudCk7XG4gICAgaWYgKFxuICAgICAgcmVjaXBpZW50QW1vdW50LmlzR3JlYXRlclRoYW4oZXhwbGFpbmVkVHgub3V0cHV0QW1vdW50KSB8fFxuICAgICAgcmVjaXBpZW50QW1vdW50LnBsdXMobWF4SW1wb3J0RmVlKS5pc0xlc3NUaGFuKGV4cGxhaW5lZFR4Lm91dHB1dEFtb3VudClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFR4IHRvdGFsIGFtb3VudCAke2V4cGxhaW5lZFR4Lm91dHB1dEFtb3VudH0gZG9lcyBub3QgbWF0Y2ggd2l0aCBleHBlY3RlZCB0b3RhbCBhbW91bnQgZmllbGQgJHtyZWNpcGllbnRBbW91bnR9IGFuZCBtYXggaW1wb3J0IGZlZSAke21heEltcG9ydEZlZX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChleHBsYWluZWRUeC5vdXRwdXRzICYmICF1dGlscy5pc1ZhbGlkQWRkcmVzcyhleHBsYWluZWRUeC5vdXRwdXRzWzBdLmFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgUC1jaGFpbiBhZGRyZXNzICR7ZXhwbGFpbmVkVHgub3V0cHV0c1swXS5hZGRyZXNzfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBpbXBvcnQgdHhuIGludG8gUCBpcyB2YWxpZCwgYmFzZWQgb24gZXhwZWN0ZWQgdHggcGFyYW1zLlxuICAgKlxuICAgKiBAcGFyYW0ge0F2YXhwTGliLkF2YXhwRW50cnlbXX0gZXhwbGFpbmVkVHhJbnB1dHMgdHggaW5wdXRzICh1bnNwZW50cyB0byBiZSBpbXBvcnRlZClcbiAgICogQHBhcmFtIHtBdmF4cFRyYW5zYWN0aW9uUGFyYW1zfSB0eFBhcmFtcyBleHBlY3RlZCB0eCBpbmZvIHRvIGNoZWNrIGFnYWluc3RcbiAgICovXG4gIHZhbGlkYXRlSW1wb3J0VHgoZXhwbGFpbmVkVHhJbnB1dHM6IEF2YXhwTGliLkF2YXhwRW50cnlbXSwgdHhQYXJhbXM6IEF2YXhwVHJhbnNhY3Rpb25QYXJhbXMpOiB2b2lkIHtcbiAgICBpZiAodHhQYXJhbXMudW5zcGVudHMpIHtcbiAgICAgIGlmIChleHBsYWluZWRUeElucHV0cy5sZW5ndGggIT09IHR4UGFyYW1zLnVuc3BlbnRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7dHhQYXJhbXMudW5zcGVudHMubGVuZ3RofSBVVFhPcywgdHJhbnNhY3Rpb24gaGFkICR7ZXhwbGFpbmVkVHhJbnB1dHMubGVuZ3RofWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1bnNwZW50cyA9IG5ldyBTZXQodHhQYXJhbXMudW5zcGVudHMpO1xuXG4gICAgICBmb3IgKGNvbnN0IHVuc3BlbnQgb2YgZXhwbGFpbmVkVHhJbnB1dHMpIHtcbiAgICAgICAgaWYgKCF1bnNwZW50cy5oYXModW5zcGVudC5pZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIHNob3VsZCBub3QgY29udGFpbiB0aGUgVVRYTzogJHt1bnNwZW50LmlkfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBBdmF4cFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHR4SGV4ID0gcGFyYW1zLnR4UHJlYnVpbGQgJiYgcGFyYW1zLnR4UHJlYnVpbGQudHhIZXg7XG4gICAgaWYgKCF0eEhleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR4IHByZWJ1aWxkIHByb3BlcnR5IHR4SGV4Jyk7XG4gICAgfVxuICAgIGxldCB0eDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdHhCdWlsZGVyID0gdGhpcy5nZXRCdWlsZGVyKCkuZnJvbSh0eEhleCk7XG4gICAgICB0eCA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3QgZXhwbGFpbmVkVHggPSB0eC5leHBsYWluVHJhbnNhY3Rpb24oKTtcblxuICAgIGNvbnN0IHsgdHlwZSwgc3Rha2luZ09wdGlvbnMgfSA9IHBhcmFtcy50eFBhcmFtcztcbiAgICAvLyBUT0RPKEJHLTYyMTEyKTogY2hhbmdlIEltcG9ydFRvQyB0eXBlIHRvIEltcG9ydFxuICAgIGlmICghdHlwZSB8fCAodHlwZSAhPT0gJ0ltcG9ydFRvQycgJiYgZXhwbGFpbmVkVHgudHlwZSAhPT0gVHJhbnNhY3Rpb25UeXBlW3R5cGVdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCB0eXBlIGRvZXMgbm90IG1hdGNoIHdpdGggZXhwZWN0ZWQgdHhQYXJhbXMgdHlwZScpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZXhwbGFpbmVkVHgudHlwZSkge1xuICAgICAgLy8gQGRlcHJlY2F0ZWRcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkFkZERlbGVnYXRvcjpcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkFkZFZhbGlkYXRvcjpcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkFkZFBlcm1pc3Npb25sZXNzRGVsZWdhdG9yOlxuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuQWRkUGVybWlzc2lvbmxlc3NWYWxpZGF0b3I6XG4gICAgICAgIHRoaXMudmFsaWRhdGVTdGFraW5nVHgoc3Rha2luZ09wdGlvbnMsIGV4cGxhaW5lZFR4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5FeHBvcnQ6XG4gICAgICAgIGlmICghcGFyYW1zLnR4UGFyYW1zLnJlY2lwaWVudHMgfHwgcGFyYW1zLnR4UGFyYW1zLnJlY2lwaWVudHM/Lmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwb3J0IFR4IHJlcXVpcmVzIGEgcmVjaXBpZW50Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy52YWxpZGF0ZUV4cG9ydFR4KHBhcmFtcy50eFBhcmFtcy5yZWNpcGllbnRzLCBleHBsYWluZWRUeCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5JbXBvcnQ6XG4gICAgICAgIGlmICh0eC5pc1RyYW5zYWN0aW9uRm9yQ0NoYWluKSB7XG4gICAgICAgICAgLy8gSW1wb3J0IHRvIEMtY2hhaW5cbiAgICAgICAgICBpZiAoZXhwbGFpbmVkVHgub3V0cHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgMSBvdXRwdXQgaW4gaW1wb3J0IHRyYW5zYWN0aW9uJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcGFyYW1zLnR4UGFyYW1zLnJlY2lwaWVudHMgfHwgcGFyYW1zLnR4UGFyYW1zLnJlY2lwaWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIDEgcmVjaXBpZW50IGluIGltcG9ydCB0cmFuc2FjdGlvbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJbXBvcnQgdG8gUC1jaGFpblxuICAgICAgICAgIGlmIChleHBsYWluZWRUeC5vdXRwdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCAxIG91dHB1dCBpbiBpbXBvcnQgdHJhbnNhY3Rpb24nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy52YWxpZGF0ZUltcG9ydFR4KGV4cGxhaW5lZFR4LmlucHV0cywgcGFyYW1zLnR4UGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHggdHlwZSBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhZGRyZXNzIGlzIHZhbGlkLCB0aGVuIG1ha2Ugc3VyZSBpdCBtYXRjaGVzIHRoZSByb290IGFkZHJlc3MuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMuYWRkcmVzcyBhZGRyZXNzIHRvIHZhbGlkYXRlXG4gICAqIEBwYXJhbSBwYXJhbXMua2V5Y2hhaW5zIHB1YmxpYyBrZXlzIHRvIGdlbmVyYXRlIHRoZSB3YWxsZXRcbiAgICovXG4gIGFzeW5jIGlzV2FsbGV0QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBrZXljaGFpbnMgfSA9IHBhcmFtcztcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cbiAgICBpZiAoIWtleWNoYWlucyB8fCBrZXljaGFpbnMubGVuZ3RoICE9PSAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5Y2hhaW5zJyk7XG4gICAgfVxuXG4gICAgLy8gbXVsdGlzaWcgYWRkcmVzc2VzIGFyZSBzZXBhcmF0ZWQgYnkgflxuICAgIGNvbnN0IHNwbGl0QWRkcmVzc2VzID0gYWRkcmVzcy5zcGxpdCgnficpO1xuXG4gICAgLy8gZGVyaXZlIGFkZHJlc3NlcyBmcm9tIGtleWNoYWluXG4gICAgY29uc3QgdW5sb2NrQWRkcmVzc2VzID0ga2V5Y2hhaW5zLm1hcCgoa2V5Y2hhaW4pID0+XG4gICAgICBuZXcgQXZheHBMaWIuS2V5UGFpcih7IHB1Yjoga2V5Y2hhaW4ucHViIH0pLmdldEFkZHJlc3ModGhpcy5fc3RhdGljc0NvaW4ubmV0d29yay50eXBlKVxuICAgICk7XG5cbiAgICBpZiAoc3BsaXRBZGRyZXNzZXMubGVuZ3RoICE9PSB1bmxvY2tBZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZEFkZHJlc3NFcnJvcihgYWRkcmVzcyB2YWxpZGF0aW9uIGZhaWx1cmU6IG11bHRpc2lnIGFkZHJlc3MgbGVuZ3RoIGRvZXMgbm90IG1hdGNoYCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmFkcmVzc2VzQXJyYXlzTWF0Y2goc3BsaXRBZGRyZXNzZXMsIHVubG9ja0FkZHJlc3NlcykpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yKGBhZGRyZXNzIHZhbGlkYXRpb24gZmFpbHVyZTogJHthZGRyZXNzfSBpcyBub3Qgb2YgdGhpcyB3YWxsZXRgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGF0IHR3byBtdWx0aXNpZyBhZGRyZXNzIGFycmF5cyBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzLCBvcmRlciBkb2VzbnQgbWF0dGVyXG4gICAqIEBwYXJhbSBhZGRyZXNzQXJyYXkxXG4gICAqIEBwYXJhbSBhZGRyZXNzQXJyYXkyXG4gICAqIEByZXR1cm5zIHRydWUgaWYgYWRkcmVzcyBhcnJheXMgaGF2ZSB0aGUgc2FtZSBhZGRyZXNzZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgYWRyZXNzZXNBcnJheXNNYXRjaChhZGRyZXNzQXJyYXkxOiBzdHJpbmdbXSwgYWRkcmVzc0FycmF5Mjogc3RyaW5nW10pIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYWRkcmVzc0FycmF5MS5zb3J0KCkpID09PSBKU09OLnN0cmluZ2lmeShhZGRyZXNzQXJyYXkyLnNvcnQoKSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgQXZheHAga2V5IHBhaXJcbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IHNlZWQgLSBTZWVkIGZyb20gd2hpY2ggdGhlIG5ldyBrZXlwYWlyIHNob3VsZCBiZSBnZW5lcmF0ZWQsIG90aGVyd2lzZSBhIHJhbmRvbSBzZWVkIGlzIHVzZWRcbiAgICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IHdpdGggZ2VuZXJhdGVkIHB1YiBhbmQgcHJ2XG4gICAqL1xuICBnZW5lcmF0ZUtleVBhaXIoc2VlZD86IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIGNvbnN0IGtleVBhaXIgPSBzZWVkID8gbmV3IEF2YXhwTGliLktleVBhaXIoeyBzZWVkIH0pIDogbmV3IEF2YXhwTGliLktleVBhaXIoKTtcbiAgICBjb25zdCBrZXlzID0ga2V5UGFpci5nZXRLZXlzKCk7XG5cbiAgICBpZiAoIWtleXMucHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJ2IGluIGtleSBnZW5lcmF0aW9uLicpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwdWI6IGtleXMucHViLFxuICAgICAgcHJ2OiBrZXlzLnBydixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHViIHRoZSBwcnYgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEF2YXhwTGliLktleVBhaXIoeyBwdWIgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwcml2YXRlIGtleSBmb3IgdGhlIGNvaW5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBydiB0aGUgcHJ2IHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMgaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHJ2KHBydjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBBdmF4cExpYi5LZXlQYWlyKHsgcHJ2IH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyB8IHN0cmluZ1tdKTogYm9vbGVhbiB7XG4gICAgaWYgKGFkZHJlc3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIGV0aCBhZGRyZXNzIGZvciBjcm9zcy1jaGFpbiB0eHMgdG8gYy1jaGFpblxuICAgIGlmICh0eXBlb2YgYWRkcmVzcyA9PT0gJ3N0cmluZycgJiYgaXNWYWxpZEV0aEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBBdmF4cExpYi5VdGlscy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyBBdmF4cCB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogQXZheHBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIC8vIGRlc2VyaWFsaXplIHJhdyB0cmFuc2FjdGlvbiAobm90ZTogZnJvbUFkZHJlc3MgaGFzIG9uY2hhaW4gb3JkZXIpXG4gICAgY29uc3QgdHhCdWlsZGVyID0gdGhpcy5nZXRCdWlsZGVyKCkuZnJvbShwYXJhbXMudHhQcmVidWlsZC50eEhleCk7XG4gICAgY29uc3Qga2V5ID0gcGFyYW1zLnBydjtcblxuICAgIC8vIHB1c2ggdGhlIGtleXBhaXIgdG8gc2lnbmVyIGFycmF5XG4gICAgdHhCdWlsZGVyLnNpZ24oeyBrZXkgfSk7XG5cbiAgICAvLyBidWlsZCB0aGUgdHJhbnNhY3Rpb25cbiAgICBjb25zdCB0cmFuc2FjdGlvbjogQmFzZVRyYW5zYWN0aW9uID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgaWYgKCF0cmFuc2FjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdFcnJvciB3aGlsZSB0cnlpbmcgdG8gYnVpbGQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLnNpZ25hdHVyZS5sZW5ndGggPj0gMlxuICAgICAgPyB7IHR4SGV4OiB0cmFuc2FjdGlvbi50b0Jyb2FkY2FzdEZvcm1hdCgpIH1cbiAgICAgIDogeyBoYWxmU2lnbmVkOiB7IHR4SGV4OiB0cmFuc2FjdGlvbi50b0Jyb2FkY2FzdEZvcm1hdCgpIH0gfTtcbiAgfVxuXG4gIGFzeW5jIGZlZUVzdGltYXRlKHBhcmFtczogRmVlRXN0aW1hdGVPcHRpb25zKTogUHJvbWlzZTxUcmFuc2FjdGlvbkZlZT4ge1xuICAgIC8vIHN0YWtpbmcgdHJhbnNhY3Rpb25zIGFyZSBmZWUtbGVzc1xuICAgIHJldHVybiB7IGZlZTogJzAnIH07XG4gIH1cblxuICBhc3luYyBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGxhaW4gYSBBdmF4cCB0cmFuc2FjdGlvbiBmcm9tIHR4SGV4XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBhc3luYyBleHBsYWluVHJhbnNhY3Rpb24ocGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxBdmF4cExpYi5UcmFuc2FjdGlvbkV4cGxhbmF0aW9uPiB7XG4gICAgY29uc3QgdHhIZXggPSBwYXJhbXMudHhIZXggPz8gcGFyYW1zPy5oYWxmU2lnbmVkPy50eEhleDtcbiAgICBpZiAoIXR4SGV4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdHJhbnNhY3Rpb24gaGV4Jyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0eEJ1aWxkZXIgPSB0aGlzLmdldEJ1aWxkZXIoKS5mcm9tKHR4SGV4KTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgICByZXR1cm4gdHguZXhwbGFpblRyYW5zYWN0aW9uKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRyYW5zYWN0aW9uOiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICByZWNvdmVyeVNpZ25hdHVyZShtZXNzYWdlOiBCdWZmZXIsIHNpZ25hdHVyZTogQnVmZmVyKTogQnVmZmVyIHtcbiAgICByZXR1cm4gQXZheHBMaWIuVXRpbHMucmVjb3ZlcnlTaWduYXR1cmUodGhpcy5fc3RhdGljc0NvaW4ubmV0d29yayBhcyBBdmFsYW5jaGVOZXR3b3JrLCBtZXNzYWdlLCBzaWduYXR1cmUpO1xuICB9XG5cbiAgYXN5bmMgc2lnbk1lc3NhZ2Uoa2V5OiBLZXlQYWlyLCBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGNvbnN0IHBydiA9IG5ldyBBdmF4cExpYi5LZXlQYWlyKGtleSkuZ2V0UHJpdmF0ZUtleSgpO1xuICAgIGlmICghcHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdJbnZhbGlkIGtleSBwYWlyIG9wdGlvbnMnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgbWVzc2FnZSA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UsICdoZXgnKTtcbiAgICB9XG4gICAgcmV0dXJuIEF2YXhwTGliLlV0aWxzLmNyZWF0ZVNpZ25hdHVyZSh0aGlzLl9zdGF0aWNzQ29pbi5uZXR3b3JrIGFzIEF2YWxhbmNoZU5ldHdvcmssIG1lc3NhZ2UsIHBydik7XG4gIH1cblxuICBwcml2YXRlIGdldEJ1aWxkZXIoKTogQXZheHBMaWIuVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeSB7XG4gICAgcmV0dXJuIG5ldyBBdmF4cExpYi5UcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5KGNvaW5zLmdldCh0aGlzLmdldENoYWluKCkpKTtcbiAgfVxufVxuIl19