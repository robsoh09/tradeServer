/// <reference types="node" />
import { BaseCoin as StaticsBaseCoin, CoinFamily } from '@bitgo/statics';
import { BaseCoin, BitGoBase, KeyPair, VerifyAddressOptions, SignedTransaction, ParseTransactionOptions, FeeEstimateOptions, ITransactionRecipient, ParsedTransaction } from '@bitgo/sdk-core';
import * as AvaxpLib from './lib';
import { AvaxpSignTransactionOptions, TransactionFee, ExplainTransactionOptions, AvaxpVerifyTransactionOptions, AvaxpTransactionStakingOptions, AvaxpTransactionParams } from './iface';
export declare class AvaxP extends BaseCoin {
    protected readonly _staticsCoin: Readonly<StaticsBaseCoin>;
    constructor(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>);
    static createInstance(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>): BaseCoin;
    getChain(): string;
    getFamily(): CoinFamily;
    getFullName(): string;
    getBaseFactor(): string | number;
    /**
     * Check if staking txn is valid, based on expected tx params.
     *
     * @param {AvaxpTransactionStakingOptions} stakingOptions expected staking params to check against
     * @param {AvaxpLib.TransactionExplanation} explainedTx explained staking transaction
     */
    validateStakingTx(stakingOptions: AvaxpTransactionStakingOptions, explainedTx: AvaxpLib.TransactionExplanation): void;
    /**
     * Check if export txn is valid, based on expected tx params.
     *
     * @param {ITransactionRecipient[]} recipients expected recipients and info
     * @param {AvaxpLib.TransactionExplanation} explainedTx explained export transaction
     */
    validateExportTx(recipients: ITransactionRecipient[], explainedTx: AvaxpLib.TransactionExplanation): void;
    /**
     * Check if import txn into P is valid, based on expected tx params.
     *
     * @param {AvaxpLib.AvaxpEntry[]} explainedTxInputs tx inputs (unspents to be imported)
     * @param {AvaxpTransactionParams} txParams expected tx info to check against
     */
    validateImportTx(explainedTxInputs: AvaxpLib.AvaxpEntry[], txParams: AvaxpTransactionParams): void;
    verifyTransaction(params: AvaxpVerifyTransactionOptions): Promise<boolean>;
    /**
     * Check if address is valid, then make sure it matches the root address.
     *
     * @param params.address address to validate
     * @param params.keychains public keys to generate the wallet
     */
    isWalletAddress(params: VerifyAddressOptions): Promise<boolean>;
    /**
     * Validate that two multisig address arrays have the same elements, order doesnt matter
     * @param addressArray1
     * @param addressArray2
     * @returns true if address arrays have the same addresses
     * @private
     */
    private adressesArraysMatch;
    /**
     * Generate Avaxp key pair
     *
     * @param {Buffer} seed - Seed from which the new keypair should be generated, otherwise a random seed is used
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed?: Buffer): KeyPair;
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {string} pub the prv to be checked
     * @returns is it valid?
     */
    isValidPub(pub: string): boolean;
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param {string} prv the prv to be checked
     * @returns is it valid?
     */
    isValidPrv(prv: string): boolean;
    isValidAddress(address: string | string[]): boolean;
    /**
     * Signs Avaxp transaction
     */
    signTransaction(params: AvaxpSignTransactionOptions): Promise<SignedTransaction>;
    feeEstimate(params: FeeEstimateOptions): Promise<TransactionFee>;
    parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
    /**
     * Explain a Avaxp transaction from txHex
     * @param params
     * @param callback
     */
    explainTransaction(params: ExplainTransactionOptions): Promise<AvaxpLib.TransactionExplanation>;
    recoverySignature(message: Buffer, signature: Buffer): Buffer;
    signMessage(key: KeyPair, message: string | Buffer): Promise<Buffer>;
    private getBuilder;
}
//# sourceMappingURL=avaxp.d.ts.map