/// <reference types="node" />
import { avaxSerial, Credential } from '@bitgo-forks/avalanchejs';
import { BaseKey, BaseTransaction, Entry, TransactionFee, TransactionType } from '@bitgo/sdk-core';
import { AvalancheNetwork, BaseCoin as CoinConfig } from '@bitgo/statics';
import { Buffer as BufferAvax } from 'avalanche';
import { Buffer } from 'buffer';
import { DecodedUtxoObj, TransactionExplanation, Tx, TxData } from './iface';
import { KeyPair } from './keyPair';
export declare class Transaction extends BaseTransaction {
    protected _avaxTransaction: Tx;
    _type: TransactionType;
    _network: AvalancheNetwork;
    _networkID: number;
    _assetId: string;
    _blockchainID: string;
    _nodeID: string;
    _startTime: bigint;
    _endTime: bigint;
    _stakeAmount: bigint;
    _threshold: number;
    _locktime: bigint;
    _fromAddresses: Uint8Array[];
    _rewardAddresses: BufferAvax[];
    _utxos: DecodedUtxoObj[];
    _to: BufferAvax[];
    _fee: Partial<TransactionFee>;
    _blsPublicKey: string;
    _blsSignature: string;
    constructor(coinConfig: Readonly<CoinConfig>);
    get avaxPTransaction(): avaxSerial.BaseTx;
    get signature(): string[];
    get credentials(): Credential[];
    get hasCredentials(): boolean;
    /** @inheritdoc */
    canSign({ key }: BaseKey): boolean;
    /**
     * Sign an avaxp transaction and update the transaction hex
     * @param {KeyPair} keyPair
     */
    sign(keyPair: KeyPair): Promise<void>;
    toHexString(byteArray: Uint8Array): string;
    /** @inheritdoc */
    /**
     * should be of signedTx doing this with baseTx
     */
    toBroadcastFormat(): string;
    toJson(): TxData;
    setTransaction(tx: Tx): void;
    /**
     * Set the transaction type
     *
     * @param {TransactionType} transactionType The transaction type to be set
     */
    setTransactionType(transactionType: TransactionType): void;
    /**
     * Returns the portion of the transaction that needs to be signed in Buffer format.
     * Only needed for coins that support adding signatures directly (e.g. TSS).
     */
    get signablePayload(): Buffer;
    get id(): string;
    get fromAddresses(): string[];
    get rewardAddresses(): string[];
    /**
     * Get the list of outputs. Amounts are expressed in absolute value.
     */
    get outputs(): Entry[];
    get fee(): TransactionFee;
    get changeOutputs(): Entry[];
    get inputs(): Entry[];
    /**
     * Avax wrapper to create signature and return it for credentials
     * @param prv
     * @return hexstring
     */
    createSignature(prv: Buffer): string;
    /** @inheritdoc */
    explainTransaction(): TransactionExplanation;
}
//# sourceMappingURL=transaction.d.ts.map