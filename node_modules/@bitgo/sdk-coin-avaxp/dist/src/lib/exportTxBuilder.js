"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExportTxBuilder = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const atomicTransactionBuilder_1 = require("./atomicTransactionBuilder");
const platformvm_1 = require("avalanche/dist/apis/platformvm");
const avalanche_1 = require("avalanche");
const utils_1 = __importDefault(require("./utils"));
const utxoEngine_1 = require("./utxoEngine");
class ExportTxBuilder extends atomicTransactionBuilder_1.AtomicTransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
        this._externalChainId = utils_1.default.cb58Decode(this.transaction._network.cChainBlockchainID);
    }
    get transactionType() {
        return sdk_core_1.TransactionType.Export;
    }
    /**
     * Amount is a long that specifies the quantity of the asset that this output owns. Must be positive.
     *
     * @param {BN | string} amount The withdrawal amount
     */
    amount(value) {
        const valueBN = avalanche_1.BN.isBN(value) ? value : new avalanche_1.BN(value);
        this.validateAmount(valueBN);
        this._amount = valueBN;
        return this;
    }
    /** @inheritdoc */
    initBuilder(tx) {
        super.initBuilder(tx);
        const baseTx = tx.getUnsignedTx().getTransaction();
        if (!this.verifyTxType(baseTx)) {
            throw new sdk_core_1.NotSupported('Transaction cannot be parsed or has an unsupported transaction type');
        }
        // The ExportOutputs is a {@link exportedOutputs} result.
        // It's expected to have only one outputs with the addresses of the sender.
        const outputs = baseTx.getExportOutputs();
        if (outputs.length != 1) {
            throw new sdk_core_1.BuildTransactionError('Transaction can have one external output');
        }
        const output = outputs[0];
        if (!output.getAssetID().equals(this.transaction._assetId)) {
            throw new Error('The Asset ID of the output does not match the transaction');
        }
        const secpOut = output.getOutput();
        this.transaction._locktime = secpOut.getLocktime();
        this.transaction._threshold = secpOut.getThreshold();
        // output addresses are the sender addresses
        this.transaction._fromAddresses = secpOut.getAddresses();
        this._externalChainId = baseTx.getDestinationChain();
        this._amount = secpOut.getAmount();
        this.transaction._utxos = (0, utxoEngine_1.deprecatedRecoverUtxos)(baseTx.getIns());
        return this;
    }
    static verifyTxType(baseTx) {
        return baseTx.getTypeID() === platformvm_1.PlatformVMConstants.EXPORTTX;
    }
    verifyTxType(baseTx) {
        return ExportTxBuilder.verifyTxType(baseTx);
    }
    /**
     * Create the internal avalanche transaction.
     * @protected
     */
    buildAvaxTransaction() {
        // if tx has credentials, tx shouldn't change
        if (this.transaction.hasCredentials)
            return;
        const { inputs, outputs, credentials } = this.createInputOutput(this._amount.add(new avalanche_1.BN(this.transaction.fee.fee)));
        this.transaction.setTransaction(new platformvm_1.Tx(new platformvm_1.UnsignedTx(new platformvm_1.ExportTx(this.transaction._networkID, this.transaction._blockchainID, outputs, inputs, undefined, this._externalChainId, this.exportedOutputs())), credentials));
    }
    /**
     * Create the ExportedOut where the recipient address are the sender.
     * Later a importTx should complete the operations signing with the same keys.
     * @protected
     */
    exportedOutputs() {
        return [
            new platformvm_1.TransferableOutput(this.transaction._assetId, new platformvm_1.SECPTransferOutput(this._amount, this.transaction._fromAddresses, this.transaction._locktime, this.transaction._threshold)),
        ];
    }
}
exports.ExportTxBuilder = ExportTxBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwb3J0VHhCdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9leHBvcnRUeEJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsOENBQXVGO0FBQ3ZGLHlFQUFzRTtBQUN0RSwrREFPd0M7QUFDeEMseUNBQStCO0FBRS9CLG9EQUE0QjtBQUM1Qiw2Q0FBc0Q7QUFHdEQsTUFBYSxlQUFnQixTQUFRLG1EQUF3QjtJQUczRCxZQUFZLFdBQWlDO1FBQzNDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNuQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsZUFBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3pGLENBQUM7SUFFRCxJQUFjLGVBQWU7UUFDM0IsT0FBTywwQkFBZSxDQUFDLE1BQU0sQ0FBQztJQUNoQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxLQUFrQjtRQUN2QixNQUFNLE9BQU8sR0FBRyxjQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksY0FBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3ZELElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDN0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDdkIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLFdBQVcsQ0FBQyxFQUFnQjtRQUMxQixLQUFLLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3RCLE1BQU0sTUFBTSxHQUFxQixFQUFFLENBQUMsYUFBYSxFQUFFLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDckUsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDOUIsTUFBTSxJQUFJLHVCQUFZLENBQUMscUVBQXFFLENBQUMsQ0FBQztTQUMvRjtRQUNELHlEQUF5RDtRQUN6RCwyRUFBMkU7UUFDM0UsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDMUMsSUFBSSxPQUFPLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtZQUN2QixNQUFNLElBQUksZ0NBQXFCLENBQUMsMENBQTBDLENBQUMsQ0FBQztTQUM3RTtRQUNELE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxQixJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzFELE1BQU0sSUFBSSxLQUFLLENBQUMsMkRBQTJELENBQUMsQ0FBQztTQUM5RTtRQUNELE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNuQyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDbkQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3JELDRDQUE0QztRQUM1QyxJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsR0FBRyxPQUFPLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDekQsSUFBSSxDQUFDLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1FBQ3JELElBQUksQ0FBQyxPQUFPLEdBQUksT0FBd0IsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNyRCxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sR0FBRyxJQUFBLG1DQUFzQixFQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBQ2xFLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELE1BQU0sQ0FBQyxZQUFZLENBQUMsTUFBd0I7UUFDMUMsT0FBTyxNQUFNLENBQUMsU0FBUyxFQUFFLEtBQUssZ0NBQW1CLENBQUMsUUFBUSxDQUFDO0lBQzdELENBQUM7SUFFRCxZQUFZLENBQUMsTUFBd0I7UUFDbkMsT0FBTyxlQUFlLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFFRDs7O09BR0c7SUFDTyxvQkFBb0I7UUFDNUIsNkNBQTZDO1FBQzdDLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxjQUFjO1lBQUUsT0FBTztRQUM1QyxNQUFNLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxjQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BILElBQUksQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUM3QixJQUFJLGVBQUssQ0FDUCxJQUFJLHVCQUFVLENBQ1osSUFBSSxxQkFBUSxDQUNWLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUMzQixJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFDOUIsT0FBTyxFQUNQLE1BQU0sRUFDTixTQUFTLEVBQ1QsSUFBSSxDQUFDLGdCQUFnQixFQUNyQixJQUFJLENBQUMsZUFBZSxFQUFFLENBQ3ZCLENBQ0YsRUFDRCxXQUFXLENBQ1osQ0FDRixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7O09BSUc7SUFDTyxlQUFlO1FBQ3ZCLE9BQU87WUFDTCxJQUFJLCtCQUFrQixDQUNwQixJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFDekIsSUFBSSwrQkFBa0IsQ0FDcEIsSUFBSSxDQUFDLE9BQU8sRUFDWixJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsRUFDL0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQzFCLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUM1QixDQUNGO1NBQ0YsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQXhHRCwwQ0F3R0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ29pbiBhcyBDb2luQ29uZmlnIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHsgQnVpbGRUcmFuc2FjdGlvbkVycm9yLCBOb3RTdXBwb3J0ZWQsIFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBBdG9taWNUcmFuc2FjdGlvbkJ1aWxkZXIgfSBmcm9tICcuL2F0b21pY1RyYW5zYWN0aW9uQnVpbGRlcic7XG5pbXBvcnQge1xuICBFeHBvcnRUeCxcbiAgUGxhdGZvcm1WTUNvbnN0YW50cyxcbiAgU0VDUFRyYW5zZmVyT3V0cHV0LFxuICBUcmFuc2ZlcmFibGVPdXRwdXQsXG4gIFR4IGFzIFBWTVR4LFxuICBVbnNpZ25lZFR4LFxufSBmcm9tICdhdmFsYW5jaGUvZGlzdC9hcGlzL3BsYXRmb3Jtdm0nO1xuaW1wb3J0IHsgQk4gfSBmcm9tICdhdmFsYW5jaGUnO1xuaW1wb3J0IHsgQW1vdW50T3V0cHV0IH0gZnJvbSAnYXZhbGFuY2hlL2Rpc3QvYXBpcy9ldm0vb3V0cHV0cyc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBkZXByZWNhdGVkUmVjb3ZlclV0eG9zIH0gZnJvbSAnLi91dHhvRW5naW5lJztcbmltcG9ydCB7IERlcHJlY2F0ZWRUeCwgRGVwcmVjYXRlZEJhc2VUeCB9IGZyb20gJy4vaWZhY2UnO1xuXG5leHBvcnQgY2xhc3MgRXhwb3J0VHhCdWlsZGVyIGV4dGVuZHMgQXRvbWljVHJhbnNhY3Rpb25CdWlsZGVyIHtcbiAgcHJpdmF0ZSBfYW1vdW50OiBCTjtcblxuICBjb25zdHJ1Y3RvcihfY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihfY29pbkNvbmZpZyk7XG4gICAgdGhpcy5fZXh0ZXJuYWxDaGFpbklkID0gdXRpbHMuY2I1OERlY29kZSh0aGlzLnRyYW5zYWN0aW9uLl9uZXR3b3JrLmNDaGFpbkJsb2NrY2hhaW5JRCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0IHRyYW5zYWN0aW9uVHlwZSgpOiBUcmFuc2FjdGlvblR5cGUge1xuICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuRXhwb3J0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFtb3VudCBpcyBhIGxvbmcgdGhhdCBzcGVjaWZpZXMgdGhlIHF1YW50aXR5IG9mIHRoZSBhc3NldCB0aGF0IHRoaXMgb3V0cHV0IG93bnMuIE11c3QgYmUgcG9zaXRpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7Qk4gfCBzdHJpbmd9IGFtb3VudCBUaGUgd2l0aGRyYXdhbCBhbW91bnRcbiAgICovXG4gIGFtb3VudCh2YWx1ZTogQk4gfCBzdHJpbmcpOiB0aGlzIHtcbiAgICBjb25zdCB2YWx1ZUJOID0gQk4uaXNCTih2YWx1ZSkgPyB2YWx1ZSA6IG5ldyBCTih2YWx1ZSk7XG4gICAgdGhpcy52YWxpZGF0ZUFtb3VudCh2YWx1ZUJOKTtcbiAgICB0aGlzLl9hbW91bnQgPSB2YWx1ZUJOO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGluaXRCdWlsZGVyKHR4OiBEZXByZWNhdGVkVHgpOiB0aGlzIHtcbiAgICBzdXBlci5pbml0QnVpbGRlcih0eCk7XG4gICAgY29uc3QgYmFzZVR4OiBEZXByZWNhdGVkQmFzZVR4ID0gdHguZ2V0VW5zaWduZWRUeCgpLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgaWYgKCF0aGlzLnZlcmlmeVR4VHlwZShiYXNlVHgpKSB7XG4gICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkKCdUcmFuc2FjdGlvbiBjYW5ub3QgYmUgcGFyc2VkIG9yIGhhcyBhbiB1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlJyk7XG4gICAgfVxuICAgIC8vIFRoZSBFeHBvcnRPdXRwdXRzIGlzIGEge0BsaW5rIGV4cG9ydGVkT3V0cHV0c30gcmVzdWx0LlxuICAgIC8vIEl0J3MgZXhwZWN0ZWQgdG8gaGF2ZSBvbmx5IG9uZSBvdXRwdXRzIHdpdGggdGhlIGFkZHJlc3NlcyBvZiB0aGUgc2VuZGVyLlxuICAgIGNvbnN0IG91dHB1dHMgPSBiYXNlVHguZ2V0RXhwb3J0T3V0cHV0cygpO1xuICAgIGlmIChvdXRwdXRzLmxlbmd0aCAhPSAxKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBjYW4gaGF2ZSBvbmUgZXh0ZXJuYWwgb3V0cHV0Jyk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dHNbMF07XG4gICAgaWYgKCFvdXRwdXQuZ2V0QXNzZXRJRCgpLmVxdWFscyh0aGlzLnRyYW5zYWN0aW9uLl9hc3NldElkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgQXNzZXQgSUQgb2YgdGhlIG91dHB1dCBkb2VzIG5vdCBtYXRjaCB0aGUgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3Qgc2VjcE91dCA9IG91dHB1dC5nZXRPdXRwdXQoKTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLl9sb2NrdGltZSA9IHNlY3BPdXQuZ2V0TG9ja3RpbWUoKTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLl90aHJlc2hvbGQgPSBzZWNwT3V0LmdldFRocmVzaG9sZCgpO1xuICAgIC8vIG91dHB1dCBhZGRyZXNzZXMgYXJlIHRoZSBzZW5kZXIgYWRkcmVzc2VzXG4gICAgdGhpcy50cmFuc2FjdGlvbi5fZnJvbUFkZHJlc3NlcyA9IHNlY3BPdXQuZ2V0QWRkcmVzc2VzKCk7XG4gICAgdGhpcy5fZXh0ZXJuYWxDaGFpbklkID0gYmFzZVR4LmdldERlc3RpbmF0aW9uQ2hhaW4oKTtcbiAgICB0aGlzLl9hbW91bnQgPSAoc2VjcE91dCBhcyBBbW91bnRPdXRwdXQpLmdldEFtb3VudCgpO1xuICAgIHRoaXMudHJhbnNhY3Rpb24uX3V0eG9zID0gZGVwcmVjYXRlZFJlY292ZXJVdHhvcyhiYXNlVHguZ2V0SW5zKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RhdGljIHZlcmlmeVR4VHlwZShiYXNlVHg6IERlcHJlY2F0ZWRCYXNlVHgpOiBiYXNlVHggaXMgRXhwb3J0VHgge1xuICAgIHJldHVybiBiYXNlVHguZ2V0VHlwZUlEKCkgPT09IFBsYXRmb3JtVk1Db25zdGFudHMuRVhQT1JUVFg7XG4gIH1cblxuICB2ZXJpZnlUeFR5cGUoYmFzZVR4OiBEZXByZWNhdGVkQmFzZVR4KTogYmFzZVR4IGlzIEV4cG9ydFR4IHtcbiAgICByZXR1cm4gRXhwb3J0VHhCdWlsZGVyLnZlcmlmeVR4VHlwZShiYXNlVHgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgaW50ZXJuYWwgYXZhbGFuY2hlIHRyYW5zYWN0aW9uLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90ZWN0ZWQgYnVpbGRBdmF4VHJhbnNhY3Rpb24oKTogdm9pZCB7XG4gICAgLy8gaWYgdHggaGFzIGNyZWRlbnRpYWxzLCB0eCBzaG91bGRuJ3QgY2hhbmdlXG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaGFzQ3JlZGVudGlhbHMpIHJldHVybjtcbiAgICBjb25zdCB7IGlucHV0cywgb3V0cHV0cywgY3JlZGVudGlhbHMgfSA9IHRoaXMuY3JlYXRlSW5wdXRPdXRwdXQodGhpcy5fYW1vdW50LmFkZChuZXcgQk4odGhpcy50cmFuc2FjdGlvbi5mZWUuZmVlKSkpO1xuICAgIHRoaXMudHJhbnNhY3Rpb24uc2V0VHJhbnNhY3Rpb24oXG4gICAgICBuZXcgUFZNVHgoXG4gICAgICAgIG5ldyBVbnNpZ25lZFR4KFxuICAgICAgICAgIG5ldyBFeHBvcnRUeChcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb24uX25ldHdvcmtJRCxcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb24uX2Jsb2NrY2hhaW5JRCxcbiAgICAgICAgICAgIG91dHB1dHMsXG4gICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aGlzLl9leHRlcm5hbENoYWluSWQsXG4gICAgICAgICAgICB0aGlzLmV4cG9ydGVkT3V0cHV0cygpXG4gICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgICBjcmVkZW50aWFsc1xuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBFeHBvcnRlZE91dCB3aGVyZSB0aGUgcmVjaXBpZW50IGFkZHJlc3MgYXJlIHRoZSBzZW5kZXIuXG4gICAqIExhdGVyIGEgaW1wb3J0VHggc2hvdWxkIGNvbXBsZXRlIHRoZSBvcGVyYXRpb25zIHNpZ25pbmcgd2l0aCB0aGUgc2FtZSBrZXlzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90ZWN0ZWQgZXhwb3J0ZWRPdXRwdXRzKCk6IFRyYW5zZmVyYWJsZU91dHB1dFtdIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFRyYW5zZmVyYWJsZU91dHB1dChcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5fYXNzZXRJZCxcbiAgICAgICAgbmV3IFNFQ1BUcmFuc2Zlck91dHB1dChcbiAgICAgICAgICB0aGlzLl9hbW91bnQsXG4gICAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5fZnJvbUFkZHJlc3NlcyxcbiAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLl9sb2NrdGltZSxcbiAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLl90aHJlc2hvbGRcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICBdO1xuICB9XG59XG4iXX0=