"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
const avalanchejs_1 = require("@bitgo-forks/avalanchejs");
const sdk_core_1 = require("@bitgo/sdk-core");
const avalanche_1 = require("avalanche");
const platformvm_1 = require("avalanche/dist/apis/platformvm");
const keychain_1 = require("avalanche/dist/apis/platformvm/keychain");
const common_1 = require("avalanche/dist/common");
const utils_1 = require("avalanche/dist/utils");
const createHash = __importStar(require("create-hash"));
const elliptic_1 = require("elliptic");
const iface_1 = require("./iface");
class Utils {
    constructor() {
        this.binTools = avalanche_1.BinTools.getInstance();
        this.cb58Decode = this.binTools.cb58Decode;
        this.cb58Encode = this.binTools.cb58Encode;
        this.stringToBuffer = this.binTools.stringToBuffer;
        this.bufferToString = this.binTools.bufferToString;
        this.NodeIDStringToBuffer = utils_1.NodeIDStringToBuffer;
        this.addressToString = this.binTools.addressToString;
        this.parseAddress = (pub) => this.binTools.stringToAddress(pub);
    }
    includeIn(walletAddresses, otxoOutputAddresses) {
        return walletAddresses.map((a) => otxoOutputAddresses.includes(a)).reduce((a, b) => a && b, true);
    }
    /**
     * Checks if it is a valid address no illegal characters
     *
     * @param {string} address - address to be validated
     * @returns {boolean} - the validation result
     */
    /** @inheritdoc */
    isValidAddress(address) {
        const addressArr = Array.isArray(address) ? address : address.split('~');
        for (const address of addressArr) {
            if (!this.isValidAddressRegex(address)) {
                return false;
            }
        }
        return true;
    }
    isValidAddressRegex(address) {
        return /^(^P||NodeID)-[a-zA-Z0-9]+$/.test(address);
    }
    /**
     * Checks if it is a valid blockId with length 66 including 0x
     *
     * @param {string} hash - blockId to be validated
     * @returns {boolean} - the validation result
     */
    /** @inheritdoc */
    isValidBlockId(hash) {
        return this.binTools.isCB58(hash) && this.binTools.b58ToBuffer(hash).length === 36;
    }
    /**
     * Checks if the string is a valid protocol public key or
     * extended public key.
     *
     * @param {string} pub - the  public key to be validated
     * @returns {boolean} - the validation result
     */
    isValidPublicKey(pub) {
        if ((0, sdk_core_1.isValidXpub)(pub))
            return true;
        let pubBuf;
        if (pub.length === 50) {
            try {
                pubBuf = utils.cb58Decode(pub);
            }
            catch {
                return false;
            }
        }
        else {
            if (pub.length !== 66 && pub.length !== 130)
                return false;
            const firstByte = pub.slice(0, 2);
            // uncompressed public key
            if (pub.length === 130 && firstByte !== '04')
                return false;
            // compressed public key
            if (pub.length === 66 && firstByte !== '02' && firstByte !== '03')
                return false;
            if (!this.allHexChars(pub))
                return false;
            pubBuf = avalanche_1.Buffer.from(pub, 'hex');
        }
        // validate the public key
        const secp256k1 = new elliptic_1.ec('secp256k1');
        try {
            const keyPair = secp256k1.keyFromPublic(pubBuf);
            const { result } = keyPair.validate();
            return result;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Returns whether or not the string is a valid protocol private key, or extended
     * private key.
     *
     * The protocol key format is described in the @stacks/transactions npm package, in the
     * createStacksPrivateKey function:
     * https://github.com/blockstack/stacks.js/blob/master/packages/transactions/src/keys.ts#L125
     *
     * @param {string} prv - the private key (or extended private key) to be validated
     * @returns {boolean} - the validation result
     */
    isValidPrivateKey(prv) {
        if ((0, sdk_core_1.isValidXprv)(prv))
            return true;
        if (prv.length !== 64 && prv.length !== 66)
            return false;
        if (prv.length === 66 && prv.slice(64) !== '01')
            return false;
        return this.allHexChars(prv);
    }
    /**
     * Returns whether or not the string is a composed of hex chars only
     *
     * @param {string} maybe - the  string to be validated
     * @returns {boolean} - the validation result
     */
    allHexChars(maybe) {
        return /^(0x){0,1}([0-9a-f])+$/i.test(maybe);
    }
    /** @inheritdoc */
    isValidSignature(signature) {
        throw new sdk_core_1.NotImplementedError('isValidSignature not implemented');
    }
    /** @inheritdoc */
    isValidTransactionId(txId) {
        throw new sdk_core_1.NotImplementedError('isValidTransactionId not implemented');
    }
    getCredentials(tx) {
        return tx.getIns().map((ins) => (0, platformvm_1.SelectCredentialClass)(ins.getInput().getCredentialID()));
    }
    /**
     * Avaxp wrapper to create signature and return it for credentials using Avalanche's buffer
     * @param network
     * @param message
     * @param prv
     * @return signature
     */
    createSignatureAvaxBuffer(network, message, prv) {
        const ky = new keychain_1.KeyPair(network.hrp, network.networkID.toString());
        ky.importKey(prv);
        return ky.sign(message);
    }
    /**
     * Avaxp wrapper to create signature and return it for credentials
     * @param network
     * @param message
     * @param prv
     * @return signature
     */
    createSignature(network, message, prv) {
        return Buffer.from(this.createSignatureAvaxBuffer(network, avalanche_1.Buffer.from(message), avalanche_1.Buffer.from(prv)));
    }
    /**
     * Avaxp wrapper to verify signature using Avalanche's buffer
     * @param network
     * @param message
     * @param signature
     * @param prv
     * @return true if it's verify successful
     */
    verifySignatureAvaxBuffer(network, message, signature, prv) {
        const ky = new keychain_1.KeyPair(network.hrp, network.networkID.toString());
        ky.importKey(prv);
        return ky.verify(message, signature);
    }
    /**
     * Avaxp wrapper to verify signature
     * @param network
     * @param message
     * @param signature
     * @param prv
     * @return true if it's verify successful
     */
    verifySignature(network, message, signature, prv) {
        return this.verifySignatureAvaxBuffer(network, avalanche_1.Buffer.from(message), avalanche_1.Buffer.from(signature), avalanche_1.Buffer.from(prv));
    }
    createSig(sigHex) {
        const sig = new common_1.Signature();
        sig.fromBuffer(avalanche_1.Buffer.from(sigHex.padStart(130, '0'), 'hex'));
        return sig;
    }
    createNewSig(sigHex) {
        const buffer = avalanche_1.Buffer.from(sigHex.padStart(130, '0'), 'hex');
        return new avalanchejs_1.Signature(buffer);
    }
    /**
     * Avaxp wrapper to recovery signature using Avalanche's buffer
     * @param network
     * @param message
     * @param signature
     * @return
     */
    recoverySignatureAvaxBuffer(network, message, signature) {
        const ky = new keychain_1.KeyPair(network.hrp, network.networkID.toString());
        return ky.recover(message, signature);
    }
    /**
     * Avaxp wrapper to verify signature
     * @param network
     * @param message
     * @param signature
     * @return true if it's verify successful
     */
    recoverySignature(network, message, signature) {
        return Buffer.from(this.recoverySignatureAvaxBuffer(network, avalanche_1.Buffer.from(message), avalanche_1.Buffer.from(signature)));
    }
    sha256(buf) {
        return createHash.default('sha256').update(buf).digest();
    }
    /**
     * Check the raw transaction has a valid format in the blockchain context, throw otherwise.
     * It's to reuse in TransactionBuilder and TransactionBuilderFactory
     *
     * @param rawTransaction Transaction as hex string
     */
    validateRawTransaction(rawTransaction) {
        if (!rawTransaction) {
            throw new sdk_core_1.InvalidTransactionError('Raw transaction is empty');
        }
        if (!utils.allHexChars(rawTransaction)) {
            throw new sdk_core_1.ParseTransactionError('Raw transaction is not hex string');
        }
    }
    /**
     * Check if tx is for the blockchainId
     *
     * @param {DeprecatedTx} tx
     * @param {string} blockchainId
     * @returns true if tx is for blockchainId
     */
    isTransactionOf(tx, blockchainId) {
        return utils.cb58Encode(tx.getUnsignedTx().getTransaction().getBlockchainID()) === blockchainId;
    }
    /**
     * Check if Output is from PVM.
     * Output could be EVM or PVM output.
     * @param {DeprecatedOutput} output
     * @returns {boolean} output is DeprecatedTransferableOutput
     */
    deprecatedIsTransferableOutput(output) {
        return 'getOutput' in output;
    }
    /**
     * Check if Output is from PVM.
     * Output could be EVM or PVM output.
     * @param {Output} output
     * @returns {boolean} output is TransferableOutput
     */
    isTransferableOutput(output) {
        return (output === null || output === void 0 ? void 0 : output._type) === avalanchejs_1.TypeSymbols.TransferableOutput;
    }
    /**
     * Return a mapper function to that network address representation.
     * @param network required to stringify addresses
     * @return mapper function
     */
    deprecatedMapOutputToEntry(network) {
        return (output) => {
            if (this.deprecatedIsTransferableOutput(output)) {
                const amountOutput = output.getOutput();
                const address = amountOutput
                    .getAddresses()
                    .map((a) => this.addressToString(network.hrp, network.alias, a))
                    .sort()
                    .join(iface_1.ADDRESS_SEPARATOR);
                return {
                    value: amountOutput.getAmount().toString(),
                    address,
                };
            }
            else {
                const evmOutput = output;
                return {
                    // it should be evmOuput.getAmount(), but it returns a 0.
                    value: new avalanche_1.BN(evmOutput.amount).toString(),
                    // C-Chain address.
                    address: '0x' + evmOutput.getAddressString(),
                };
            }
        };
    }
    /**
     * Return a mapper function to that network address representation.
     * @param network required to stringify addresses
     * @return mapper function
     */
    mapOutputToEntry(network) {
        return (output) => {
            if (this.isTransferableOutput(output)) {
                const outputAmount = output.amount();
                const address = output.output
                    .getOwners()
                    .map((a) => this.addressToString(network.hrp, network.alias, avalanche_1.Buffer.from(a)))
                    .sort()
                    .join(iface_1.ADDRESS_SEPARATOR);
                return {
                    value: outputAmount.toString(),
                    address,
                };
            }
            else {
                throw new Error('Invalid output type');
            }
        };
    }
    /**
     * remove hex prefix (0x)
     * @param hex string
     * @returns hex without 0x
     */
    removeHexPrefix(hex) {
        if (hex.startsWith('0x')) {
            return hex.substring(2);
        }
        return hex;
    }
    /**
     * Outputidx convert from number (as string) to buffer.
     * @param {string} outputidx number
     * @return {BufferAvax} buffer of size 4 with that number value
     */
    outputidxNumberToBuffer(outputidx) {
        return avalanche_1.Buffer.from(Number(outputidx).toString(16).padStart(8, '0'), 'hex');
    }
    /**
     * Outputidx buffer to number (as string)
     * @param {BufferAvax} outputidx
     * @return {string} outputidx number
     */
    outputidxBufferToNumber(outputidx) {
        return parseInt(outputidx.toString('hex'), 16).toString();
    }
}
exports.Utils = Utils;
const utils = new Utils();
exports.default = utils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMERBQXVIO0FBQ3ZILDhDQVF5QjtBQUV6Qix5Q0FBK0Q7QUFFL0QsK0RBS3dDO0FBQ3hDLHNFQUFpRjtBQUNqRixrREFBa0Q7QUFFbEQsZ0RBQTREO0FBQzVELHdEQUEwQztBQUMxQyx1Q0FBOEI7QUFDOUIsbUNBQW9GO0FBRXBGLE1BQWEsS0FBSztJQUFsQjtRQUNVLGFBQVEsR0FBRyxvQkFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ25DLGVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQztRQUN0QyxlQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUM7UUFDdEMsbUJBQWMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQztRQUM5QyxtQkFBYyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDO1FBQzlDLHlCQUFvQixHQUFHLDRCQUFvQixDQUFDO1FBQzVDLG9CQUFlLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUM7UUFtRmhELGlCQUFZLEdBQUcsQ0FBQyxHQUFXLEVBQWMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBa1J4RixDQUFDO0lBbldRLFNBQVMsQ0FBQyxlQUF5QixFQUFFLG1CQUE2QjtRQUN2RSxPQUFPLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLENB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QUFDO1NBQ3pCO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILHVCQUF1QixDQUFDLFNBQWlCO1FBQ3ZDLE9BQU8sa0JBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ2pGLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsdUJBQXVCLENBQUMsU0FBcUI7UUFDM0MsT0FBTyxRQUFRLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUM1RCxDQUFDO0NBQ0Y7QUE1V0Qsc0JBNFdDO0FBRUQsTUFBTSxLQUFLLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztBQUUxQixrQkFBZSxLQUFLLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTaWduYXR1cmUgYXMgQXZheFNpZ25hdHVyZSwgVHJhbnNmZXJhYmxlT3V0cHV0LCBUcmFuc2Zlck91dHB1dCwgVHlwZVN5bWJvbHMgfSBmcm9tICdAYml0Z28tZm9ya3MvYXZhbGFuY2hlanMnO1xuaW1wb3J0IHtcbiAgQmFzZVV0aWxzLFxuICBFbnRyeSxcbiAgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IsXG4gIGlzVmFsaWRYcHJ2LFxuICBpc1ZhbGlkWHB1YixcbiAgTm90SW1wbGVtZW50ZWRFcnJvcixcbiAgUGFyc2VUcmFuc2FjdGlvbkVycm9yLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgQXZhbGFuY2hlTmV0d29yayB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IEJpblRvb2xzLCBCTiwgQnVmZmVyIGFzIEJ1ZmZlckF2YXggfSBmcm9tICdhdmFsYW5jaGUnO1xuaW1wb3J0IHsgRVZNT3V0cHV0IH0gZnJvbSAnYXZhbGFuY2hlL2Rpc3QvYXBpcy9ldm0nO1xuaW1wb3J0IHtcbiAgQW1vdW50T3V0cHV0LFxuICBCYXNlVHgsXG4gIFRyYW5zZmVyYWJsZU91dHB1dCBhcyBEZXByZWNhdGVkVHJhbnNmZXJhYmxlT3V0cHV0LFxuICBTZWxlY3RDcmVkZW50aWFsQ2xhc3MsXG59IGZyb20gJ2F2YWxhbmNoZS9kaXN0L2FwaXMvcGxhdGZvcm12bSc7XG5pbXBvcnQgeyBLZXlQYWlyIGFzIEtleVBhaXJBdmF4IH0gZnJvbSAnYXZhbGFuY2hlL2Rpc3QvYXBpcy9wbGF0Zm9ybXZtL2tleWNoYWluJztcbmltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ2F2YWxhbmNoZS9kaXN0L2NvbW1vbic7XG5pbXBvcnQgeyBDcmVkZW50aWFsIH0gZnJvbSAnYXZhbGFuY2hlL2Rpc3QvY29tbW9uL2NyZWRlbnRpYWxzJztcbmltcG9ydCB7IE5vZGVJRFN0cmluZ1RvQnVmZmVyIH0gZnJvbSAnYXZhbGFuY2hlL2Rpc3QvdXRpbHMnO1xuaW1wb3J0ICogYXMgY3JlYXRlSGFzaCBmcm9tICdjcmVhdGUtaGFzaCc7XG5pbXBvcnQgeyBlYyB9IGZyb20gJ2VsbGlwdGljJztcbmltcG9ydCB7IEFERFJFU1NfU0VQQVJBVE9SLCBEZXByZWNhdGVkT3V0cHV0LCBEZXByZWNhdGVkVHgsIE91dHB1dCB9IGZyb20gJy4vaWZhY2UnO1xuXG5leHBvcnQgY2xhc3MgVXRpbHMgaW1wbGVtZW50cyBCYXNlVXRpbHMge1xuICBwcml2YXRlIGJpblRvb2xzID0gQmluVG9vbHMuZ2V0SW5zdGFuY2UoKTtcbiAgcHVibGljIGNiNThEZWNvZGUgPSB0aGlzLmJpblRvb2xzLmNiNThEZWNvZGU7XG4gIHB1YmxpYyBjYjU4RW5jb2RlID0gdGhpcy5iaW5Ub29scy5jYjU4RW5jb2RlO1xuICBwdWJsaWMgc3RyaW5nVG9CdWZmZXIgPSB0aGlzLmJpblRvb2xzLnN0cmluZ1RvQnVmZmVyO1xuICBwdWJsaWMgYnVmZmVyVG9TdHJpbmcgPSB0aGlzLmJpblRvb2xzLmJ1ZmZlclRvU3RyaW5nO1xuICBwdWJsaWMgTm9kZUlEU3RyaW5nVG9CdWZmZXIgPSBOb2RlSURTdHJpbmdUb0J1ZmZlcjtcbiAgcHVibGljIGFkZHJlc3NUb1N0cmluZyA9IHRoaXMuYmluVG9vbHMuYWRkcmVzc1RvU3RyaW5nO1xuXG4gIHB1YmxpYyBpbmNsdWRlSW4od2FsbGV0QWRkcmVzc2VzOiBzdHJpbmdbXSwgb3R4b091dHB1dEFkZHJlc3Nlczogc3RyaW5nW10pOiBib29sZWFuIHtcbiAgICByZXR1cm4gd2FsbGV0QWRkcmVzc2VzLm1hcCgoYSkgPT4gb3R4b091dHB1dEFkZHJlc3Nlcy5pbmNsdWRlcyhhKSkucmVkdWNlKChhLCBiKSA9PiBhICYmIGIsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBpdCBpcyBhIHZhbGlkIGFkZHJlc3Mgbm8gaWxsZWdhbCBjaGFyYWN0ZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gYWRkcmVzcyB0byBiZSB2YWxpZGF0ZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gICAqL1xuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nIHwgc3RyaW5nW10pOiBib29sZWFuIHtcbiAgICBjb25zdCBhZGRyZXNzQXJyOiBzdHJpbmdbXSA9IEFycmF5LmlzQXJyYXkoYWRkcmVzcykgPyBhZGRyZXNzIDogYWRkcmVzcy5zcGxpdCgnficpO1xuXG4gICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIGFkZHJlc3NBcnIpIHtcbiAgICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzc1JlZ2V4KGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgaXNWYWxpZEFkZHJlc3NSZWdleChhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gL14oXlB8fE5vZGVJRCktW2EtekEtWjAtOV0rJC8udGVzdChhZGRyZXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgaXQgaXMgYSB2YWxpZCBibG9ja0lkIHdpdGggbGVuZ3RoIDY2IGluY2x1ZGluZyAweFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFzaCAtIGJsb2NrSWQgdG8gYmUgdmFsaWRhdGVkXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRCbG9ja0lkKGhhc2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmJpblRvb2xzLmlzQ0I1OChoYXNoKSAmJiB0aGlzLmJpblRvb2xzLmI1OFRvQnVmZmVyKGhhc2gpLmxlbmd0aCA9PT0gMzY7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBwcm90b2NvbCBwdWJsaWMga2V5IG9yXG4gICAqIGV4dGVuZGVkIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwdWIgLSB0aGUgIHB1YmxpYyBrZXkgdG8gYmUgdmFsaWRhdGVkXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgaXNWYWxpZFB1YmxpY0tleShwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmIChpc1ZhbGlkWHB1YihwdWIpKSByZXR1cm4gdHJ1ZTtcblxuICAgIGxldCBwdWJCdWY7XG4gICAgaWYgKHB1Yi5sZW5ndGggPT09IDUwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwdWJCdWYgPSB1dGlscy5jYjU4RGVjb2RlKHB1Yik7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHViLmxlbmd0aCAhPT0gNjYgJiYgcHViLmxlbmd0aCAhPT0gMTMwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IHB1Yi5zbGljZSgwLCAyKTtcblxuICAgICAgLy8gdW5jb21wcmVzc2VkIHB1YmxpYyBrZXlcbiAgICAgIGlmIChwdWIubGVuZ3RoID09PSAxMzAgJiYgZmlyc3RCeXRlICE9PSAnMDQnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIGNvbXByZXNzZWQgcHVibGljIGtleVxuICAgICAgaWYgKHB1Yi5sZW5ndGggPT09IDY2ICYmIGZpcnN0Qnl0ZSAhPT0gJzAyJyAmJiBmaXJzdEJ5dGUgIT09ICcwMycpIHJldHVybiBmYWxzZTtcblxuICAgICAgaWYgKCF0aGlzLmFsbEhleENoYXJzKHB1YikpIHJldHVybiBmYWxzZTtcblxuICAgICAgcHViQnVmID0gQnVmZmVyQXZheC5mcm9tKHB1YiwgJ2hleCcpO1xuICAgIH1cbiAgICAvLyB2YWxpZGF0ZSB0aGUgcHVibGljIGtleVxuICAgIGNvbnN0IHNlY3AyNTZrMSA9IG5ldyBlYygnc2VjcDI1NmsxJyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleVBhaXIgPSBzZWNwMjU2azEua2V5RnJvbVB1YmxpYyhwdWJCdWYpO1xuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGtleVBhaXIudmFsaWRhdGUoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBwYXJzZUFkZHJlc3MgPSAocHViOiBzdHJpbmcpOiBCdWZmZXJBdmF4ID0+IHRoaXMuYmluVG9vbHMuc3RyaW5nVG9BZGRyZXNzKHB1Yik7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIHByb3RvY29sIHByaXZhdGUga2V5LCBvciBleHRlbmRlZFxuICAgKiBwcml2YXRlIGtleS5cbiAgICpcbiAgICogVGhlIHByb3RvY29sIGtleSBmb3JtYXQgaXMgZGVzY3JpYmVkIGluIHRoZSBAc3RhY2tzL3RyYW5zYWN0aW9ucyBucG0gcGFja2FnZSwgaW4gdGhlXG4gICAqIGNyZWF0ZVN0YWNrc1ByaXZhdGVLZXkgZnVuY3Rpb246XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibG9ja3N0YWNrL3N0YWNrcy5qcy9ibG9iL21hc3Rlci9wYWNrYWdlcy90cmFuc2FjdGlvbnMvc3JjL2tleXMudHMjTDEyNVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJ2IC0gdGhlIHByaXZhdGUga2V5IChvciBleHRlbmRlZCBwcml2YXRlIGtleSkgdG8gYmUgdmFsaWRhdGVkXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgaXNWYWxpZFByaXZhdGVLZXkocHJ2OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoaXNWYWxpZFhwcnYocHJ2KSkgcmV0dXJuIHRydWU7XG5cbiAgICBpZiAocHJ2Lmxlbmd0aCAhPT0gNjQgJiYgcHJ2Lmxlbmd0aCAhPT0gNjYpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwcnYubGVuZ3RoID09PSA2NiAmJiBwcnYuc2xpY2UoNjQpICE9PSAnMDEnKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gdGhpcy5hbGxIZXhDaGFycyhwcnYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIGNvbXBvc2VkIG9mIGhleCBjaGFycyBvbmx5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXliZSAtIHRoZSAgc3RyaW5nIHRvIGJlIHZhbGlkYXRlZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAgICovXG4gIGFsbEhleENoYXJzKG1heWJlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gL14oMHgpezAsMX0oWzAtOWEtZl0pKyQvaS50ZXN0KG1heWJlKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkU2lnbmF0dXJlKHNpZ25hdHVyZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ2lzVmFsaWRTaWduYXR1cmUgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZFRyYW5zYWN0aW9uSWQodHhJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ2lzVmFsaWRUcmFuc2FjdGlvbklkIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgZ2V0Q3JlZGVudGlhbHModHg6IEJhc2VUeCk6IENyZWRlbnRpYWxbXSB7XG4gICAgcmV0dXJuIHR4LmdldElucygpLm1hcCgoaW5zKSA9PiBTZWxlY3RDcmVkZW50aWFsQ2xhc3MoaW5zLmdldElucHV0KCkuZ2V0Q3JlZGVudGlhbElEKCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdmF4cCB3cmFwcGVyIHRvIGNyZWF0ZSBzaWduYXR1cmUgYW5kIHJldHVybiBpdCBmb3IgY3JlZGVudGlhbHMgdXNpbmcgQXZhbGFuY2hlJ3MgYnVmZmVyXG4gICAqIEBwYXJhbSBuZXR3b3JrXG4gICAqIEBwYXJhbSBtZXNzYWdlXG4gICAqIEBwYXJhbSBwcnZcbiAgICogQHJldHVybiBzaWduYXR1cmVcbiAgICovXG4gIGNyZWF0ZVNpZ25hdHVyZUF2YXhCdWZmZXIobmV0d29yazogQXZhbGFuY2hlTmV0d29yaywgbWVzc2FnZTogQnVmZmVyQXZheCwgcHJ2OiBCdWZmZXJBdmF4KTogQnVmZmVyQXZheCB7XG4gICAgY29uc3Qga3kgPSBuZXcgS2V5UGFpckF2YXgobmV0d29yay5ocnAsIG5ldHdvcmsubmV0d29ya0lELnRvU3RyaW5nKCkpO1xuICAgIGt5LmltcG9ydEtleShwcnYpO1xuICAgIHJldHVybiBreS5zaWduKG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF2YXhwIHdyYXBwZXIgdG8gY3JlYXRlIHNpZ25hdHVyZSBhbmQgcmV0dXJuIGl0IGZvciBjcmVkZW50aWFsc1xuICAgKiBAcGFyYW0gbmV0d29ya1xuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKiBAcGFyYW0gcHJ2XG4gICAqIEByZXR1cm4gc2lnbmF0dXJlXG4gICAqL1xuICBjcmVhdGVTaWduYXR1cmUobmV0d29yazogQXZhbGFuY2hlTmV0d29yaywgbWVzc2FnZTogQnVmZmVyLCBwcnY6IEJ1ZmZlcik6IEJ1ZmZlciB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuY3JlYXRlU2lnbmF0dXJlQXZheEJ1ZmZlcihuZXR3b3JrLCBCdWZmZXJBdmF4LmZyb20obWVzc2FnZSksIEJ1ZmZlckF2YXguZnJvbShwcnYpKSk7XG4gIH1cblxuICAvKipcbiAgICogQXZheHAgd3JhcHBlciB0byB2ZXJpZnkgc2lnbmF0dXJlIHVzaW5nIEF2YWxhbmNoZSdzIGJ1ZmZlclxuICAgKiBAcGFyYW0gbmV0d29ya1xuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKiBAcGFyYW0gc2lnbmF0dXJlXG4gICAqIEBwYXJhbSBwcnZcbiAgICogQHJldHVybiB0cnVlIGlmIGl0J3MgdmVyaWZ5IHN1Y2Nlc3NmdWxcbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZUF2YXhCdWZmZXIoXG4gICAgbmV0d29yazogQXZhbGFuY2hlTmV0d29yayxcbiAgICBtZXNzYWdlOiBCdWZmZXJBdmF4LFxuICAgIHNpZ25hdHVyZTogQnVmZmVyQXZheCxcbiAgICBwcnY6IEJ1ZmZlckF2YXhcbiAgKTogYm9vbGVhbiB7XG4gICAgY29uc3Qga3kgPSBuZXcgS2V5UGFpckF2YXgobmV0d29yay5ocnAsIG5ldHdvcmsubmV0d29ya0lELnRvU3RyaW5nKCkpO1xuICAgIGt5LmltcG9ydEtleShwcnYpO1xuICAgIHJldHVybiBreS52ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdmF4cCB3cmFwcGVyIHRvIHZlcmlmeSBzaWduYXR1cmVcbiAgICogQHBhcmFtIG5ldHdvcmtcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICogQHBhcmFtIHNpZ25hdHVyZVxuICAgKiBAcGFyYW0gcHJ2XG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBpdCdzIHZlcmlmeSBzdWNjZXNzZnVsXG4gICAqL1xuICB2ZXJpZnlTaWduYXR1cmUobmV0d29yazogQXZhbGFuY2hlTmV0d29yaywgbWVzc2FnZTogQnVmZmVyLCBzaWduYXR1cmU6IEJ1ZmZlciwgcHJ2OiBCdWZmZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy52ZXJpZnlTaWduYXR1cmVBdmF4QnVmZmVyKFxuICAgICAgbmV0d29yayxcbiAgICAgIEJ1ZmZlckF2YXguZnJvbShtZXNzYWdlKSxcbiAgICAgIEJ1ZmZlckF2YXguZnJvbShzaWduYXR1cmUpLFxuICAgICAgQnVmZmVyQXZheC5mcm9tKHBydilcbiAgICApO1xuICB9XG5cbiAgY3JlYXRlU2lnKHNpZ0hleDogc3RyaW5nKTogU2lnbmF0dXJlIHtcbiAgICBjb25zdCBzaWcgPSBuZXcgU2lnbmF0dXJlKCk7XG4gICAgc2lnLmZyb21CdWZmZXIoQnVmZmVyQXZheC5mcm9tKHNpZ0hleC5wYWRTdGFydCgxMzAsICcwJyksICdoZXgnKSk7XG4gICAgcmV0dXJuIHNpZztcbiAgfVxuXG4gIGNyZWF0ZU5ld1NpZyhzaWdIZXg6IHN0cmluZyk6IEF2YXhTaWduYXR1cmUge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlckF2YXguZnJvbShzaWdIZXgucGFkU3RhcnQoMTMwLCAnMCcpLCAnaGV4Jyk7XG4gICAgcmV0dXJuIG5ldyBBdmF4U2lnbmF0dXJlKGJ1ZmZlcik7XG4gIH1cblxuICAvKipcbiAgICogQXZheHAgd3JhcHBlciB0byByZWNvdmVyeSBzaWduYXR1cmUgdXNpbmcgQXZhbGFuY2hlJ3MgYnVmZmVyXG4gICAqIEBwYXJhbSBuZXR3b3JrXG4gICAqIEBwYXJhbSBtZXNzYWdlXG4gICAqIEBwYXJhbSBzaWduYXR1cmVcbiAgICogQHJldHVyblxuICAgKi9cbiAgcmVjb3ZlcnlTaWduYXR1cmVBdmF4QnVmZmVyKG5ldHdvcms6IEF2YWxhbmNoZU5ldHdvcmssIG1lc3NhZ2U6IEJ1ZmZlckF2YXgsIHNpZ25hdHVyZTogQnVmZmVyQXZheCk6IEJ1ZmZlckF2YXgge1xuICAgIGNvbnN0IGt5ID0gbmV3IEtleVBhaXJBdmF4KG5ldHdvcmsuaHJwLCBuZXR3b3JrLm5ldHdvcmtJRC50b1N0cmluZygpKTtcbiAgICByZXR1cm4ga3kucmVjb3ZlcihtZXNzYWdlLCBzaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF2YXhwIHdyYXBwZXIgdG8gdmVyaWZ5IHNpZ25hdHVyZVxuICAgKiBAcGFyYW0gbmV0d29ya1xuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKiBAcGFyYW0gc2lnbmF0dXJlXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBpdCdzIHZlcmlmeSBzdWNjZXNzZnVsXG4gICAqL1xuICByZWNvdmVyeVNpZ25hdHVyZShuZXR3b3JrOiBBdmFsYW5jaGVOZXR3b3JrLCBtZXNzYWdlOiBCdWZmZXIsIHNpZ25hdHVyZTogQnVmZmVyKTogQnVmZmVyIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5yZWNvdmVyeVNpZ25hdHVyZUF2YXhCdWZmZXIobmV0d29yaywgQnVmZmVyQXZheC5mcm9tKG1lc3NhZ2UpLCBCdWZmZXJBdmF4LmZyb20oc2lnbmF0dXJlKSkpO1xuICB9XG5cbiAgc2hhMjU2KGJ1ZjogVWludDhBcnJheSk6IEJ1ZmZlciB7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2guZGVmYXVsdCgnc2hhMjU2JykudXBkYXRlKGJ1ZikuZGlnZXN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhlIHJhdyB0cmFuc2FjdGlvbiBoYXMgYSB2YWxpZCBmb3JtYXQgaW4gdGhlIGJsb2NrY2hhaW4gY29udGV4dCwgdGhyb3cgb3RoZXJ3aXNlLlxuICAgKiBJdCdzIHRvIHJldXNlIGluIFRyYW5zYWN0aW9uQnVpbGRlciBhbmQgVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeVxuICAgKlxuICAgKiBAcGFyYW0gcmF3VHJhbnNhY3Rpb24gVHJhbnNhY3Rpb24gYXMgaGV4IHN0cmluZ1xuICAgKi9cbiAgdmFsaWRhdGVSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbjogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFyYXdUcmFuc2FjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdSYXcgdHJhbnNhY3Rpb24gaXMgZW1wdHknKTtcbiAgICB9XG4gICAgaWYgKCF1dGlscy5hbGxIZXhDaGFycyhyYXdUcmFuc2FjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZVRyYW5zYWN0aW9uRXJyb3IoJ1JhdyB0cmFuc2FjdGlvbiBpcyBub3QgaGV4IHN0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0eCBpcyBmb3IgdGhlIGJsb2NrY2hhaW5JZFxuICAgKlxuICAgKiBAcGFyYW0ge0RlcHJlY2F0ZWRUeH0gdHhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJsb2NrY2hhaW5JZFxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHR4IGlzIGZvciBibG9ja2NoYWluSWRcbiAgICovXG4gIGlzVHJhbnNhY3Rpb25PZih0eDogRGVwcmVjYXRlZFR4LCBibG9ja2NoYWluSWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB1dGlscy5jYjU4RW5jb2RlKCh0eCBhcyBEZXByZWNhdGVkVHgpLmdldFVuc2lnbmVkVHgoKS5nZXRUcmFuc2FjdGlvbigpLmdldEJsb2NrY2hhaW5JRCgpKSA9PT0gYmxvY2tjaGFpbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIE91dHB1dCBpcyBmcm9tIFBWTS5cbiAgICogT3V0cHV0IGNvdWxkIGJlIEVWTSBvciBQVk0gb3V0cHV0LlxuICAgKiBAcGFyYW0ge0RlcHJlY2F0ZWRPdXRwdXR9IG91dHB1dFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gb3V0cHV0IGlzIERlcHJlY2F0ZWRUcmFuc2ZlcmFibGVPdXRwdXRcbiAgICovXG4gIGRlcHJlY2F0ZWRJc1RyYW5zZmVyYWJsZU91dHB1dChvdXRwdXQ6IERlcHJlY2F0ZWRPdXRwdXQpOiBvdXRwdXQgaXMgRGVwcmVjYXRlZFRyYW5zZmVyYWJsZU91dHB1dCB7XG4gICAgcmV0dXJuICdnZXRPdXRwdXQnIGluIG91dHB1dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBPdXRwdXQgaXMgZnJvbSBQVk0uXG4gICAqIE91dHB1dCBjb3VsZCBiZSBFVk0gb3IgUFZNIG91dHB1dC5cbiAgICogQHBhcmFtIHtPdXRwdXR9IG91dHB1dFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gb3V0cHV0IGlzIFRyYW5zZmVyYWJsZU91dHB1dFxuICAgKi9cbiAgaXNUcmFuc2ZlcmFibGVPdXRwdXQob3V0cHV0OiBPdXRwdXQpOiBvdXRwdXQgaXMgVHJhbnNmZXJhYmxlT3V0cHV0IHtcbiAgICByZXR1cm4gb3V0cHV0Py5fdHlwZSA9PT0gVHlwZVN5bWJvbHMuVHJhbnNmZXJhYmxlT3V0cHV0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG1hcHBlciBmdW5jdGlvbiB0byB0aGF0IG5ldHdvcmsgYWRkcmVzcyByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIG5ldHdvcmsgcmVxdWlyZWQgdG8gc3RyaW5naWZ5IGFkZHJlc3Nlc1xuICAgKiBAcmV0dXJuIG1hcHBlciBmdW5jdGlvblxuICAgKi9cbiAgZGVwcmVjYXRlZE1hcE91dHB1dFRvRW50cnkobmV0d29yazogQXZhbGFuY2hlTmV0d29yayk6IChEZXByZWNhdGVkT3V0cHV0KSA9PiBFbnRyeSB7XG4gICAgcmV0dXJuIChvdXRwdXQ6IERlcHJlY2F0ZWRPdXRwdXQpID0+IHtcbiAgICAgIGlmICh0aGlzLmRlcHJlY2F0ZWRJc1RyYW5zZmVyYWJsZU91dHB1dChvdXRwdXQpKSB7XG4gICAgICAgIGNvbnN0IGFtb3VudE91dHB1dCA9IG91dHB1dC5nZXRPdXRwdXQoKSBhcyBBbW91bnRPdXRwdXQ7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhbW91bnRPdXRwdXRcbiAgICAgICAgICAuZ2V0QWRkcmVzc2VzKClcbiAgICAgICAgICAubWFwKChhKSA9PiB0aGlzLmFkZHJlc3NUb1N0cmluZyhuZXR3b3JrLmhycCwgbmV0d29yay5hbGlhcywgYSkpXG4gICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgIC5qb2luKEFERFJFU1NfU0VQQVJBVE9SKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogYW1vdW50T3V0cHV0LmdldEFtb3VudCgpLnRvU3RyaW5nKCksXG4gICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGV2bU91dHB1dCA9IG91dHB1dCBhcyBFVk1PdXRwdXQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLy8gaXQgc2hvdWxkIGJlIGV2bU91cHV0LmdldEFtb3VudCgpLCBidXQgaXQgcmV0dXJucyBhIDAuXG4gICAgICAgICAgdmFsdWU6IG5ldyBCTigoZXZtT3V0cHV0IGFzIGFueSkuYW1vdW50KS50b1N0cmluZygpLFxuICAgICAgICAgIC8vIEMtQ2hhaW4gYWRkcmVzcy5cbiAgICAgICAgICBhZGRyZXNzOiAnMHgnICsgZXZtT3V0cHV0LmdldEFkZHJlc3NTdHJpbmcoKSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG1hcHBlciBmdW5jdGlvbiB0byB0aGF0IG5ldHdvcmsgYWRkcmVzcyByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIG5ldHdvcmsgcmVxdWlyZWQgdG8gc3RyaW5naWZ5IGFkZHJlc3Nlc1xuICAgKiBAcmV0dXJuIG1hcHBlciBmdW5jdGlvblxuICAgKi9cbiAgbWFwT3V0cHV0VG9FbnRyeShuZXR3b3JrOiBBdmFsYW5jaGVOZXR3b3JrKTogKE91dHB1dCkgPT4gRW50cnkge1xuICAgIHJldHVybiAob3V0cHV0OiBPdXRwdXQpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVHJhbnNmZXJhYmxlT3V0cHV0KG91dHB1dCkpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0QW1vdW50ID0gb3V0cHV0LmFtb3VudCgpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKG91dHB1dC5vdXRwdXQgYXMgVHJhbnNmZXJPdXRwdXQpXG4gICAgICAgICAgLmdldE93bmVycygpXG4gICAgICAgICAgLm1hcCgoYSkgPT4gdGhpcy5hZGRyZXNzVG9TdHJpbmcobmV0d29yay5ocnAsIG5ldHdvcmsuYWxpYXMsIEJ1ZmZlckF2YXguZnJvbShhKSkpXG4gICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgIC5qb2luKEFERFJFU1NfU0VQQVJBVE9SKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogb3V0cHV0QW1vdW50LnRvU3RyaW5nKCksXG4gICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvdXRwdXQgdHlwZScpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlIGhleCBwcmVmaXggKDB4KVxuICAgKiBAcGFyYW0gaGV4IHN0cmluZ1xuICAgKiBAcmV0dXJucyBoZXggd2l0aG91dCAweFxuICAgKi9cbiAgcmVtb3ZlSGV4UHJlZml4KGhleDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoaGV4LnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgIHJldHVybiBoZXguc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIE91dHB1dGlkeCBjb252ZXJ0IGZyb20gbnVtYmVyIChhcyBzdHJpbmcpIHRvIGJ1ZmZlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG91dHB1dGlkeCBudW1iZXJcbiAgICogQHJldHVybiB7QnVmZmVyQXZheH0gYnVmZmVyIG9mIHNpemUgNCB3aXRoIHRoYXQgbnVtYmVyIHZhbHVlXG4gICAqL1xuICBvdXRwdXRpZHhOdW1iZXJUb0J1ZmZlcihvdXRwdXRpZHg6IHN0cmluZyk6IEJ1ZmZlckF2YXgge1xuICAgIHJldHVybiBCdWZmZXJBdmF4LmZyb20oTnVtYmVyKG91dHB1dGlkeCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsICcwJyksICdoZXgnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdXRwdXRpZHggYnVmZmVyIHRvIG51bWJlciAoYXMgc3RyaW5nKVxuICAgKiBAcGFyYW0ge0J1ZmZlckF2YXh9IG91dHB1dGlkeFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IG91dHB1dGlkeCBudW1iZXJcbiAgICovXG4gIG91dHB1dGlkeEJ1ZmZlclRvTnVtYmVyKG91dHB1dGlkeDogQnVmZmVyQXZheCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHBhcnNlSW50KG91dHB1dGlkeC50b1N0cmluZygnaGV4JyksIDE2KS50b1N0cmluZygpO1xuICB9XG59XG5cbmNvbnN0IHV0aWxzID0gbmV3IFV0aWxzKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHV0aWxzO1xuIl19