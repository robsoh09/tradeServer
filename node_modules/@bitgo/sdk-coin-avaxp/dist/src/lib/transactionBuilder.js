"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilder = void 0;
const avalanchejs_1 = require("@bitgo-forks/avalanchejs");
const sdk_core_1 = require("@bitgo/sdk-core");
const transaction_1 = require("./transaction");
const utils_1 = __importDefault(require("./utils"));
class TransactionBuilder extends sdk_core_1.BaseTransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
        this.recoverSigner = false;
        this._signer = [];
        this._transaction = new transaction_1.Transaction(_coinConfig);
    }
    /**
     * Initialize the transaction builder fields using the decoded transaction data
     *
     * @param {Transaction} tx the transaction data
     * @returns itself
     */
    initBuilder(tx) {
        const baseTx = tx.tx.baseTx;
        if (baseTx.NetworkId.value() !== this._transaction._networkID ||
            baseTx.BlockchainId.value() !== this._transaction._blockchainID) {
            throw new Error('Network or blockchain is not equals');
        }
        this._transaction.setTransaction(tx);
        return this;
    }
    // region Validators
    /**
     * Validates the threshold
     * @param threshold
     */
    validateThreshold(threshold) {
        if (!threshold || threshold !== 2) {
            throw new sdk_core_1.BuildTransactionError('Invalid transaction: threshold must be set to 2');
        }
    }
    /**
     * Check the UTXO has expected fields.
     * @param UTXO
     */
    validateUtxo(value) {
        ['outputID', 'amount', 'txid', 'outputidx'].forEach((field) => {
            if (!value.hasOwnProperty(field))
                throw new sdk_core_1.BuildTransactionError(`Utxos required ${field}`);
        });
    }
    /**
     * Check the list of UTXOS is empty and check each UTXO.
     * @param values
     */
    validateUtxos(values) {
        if (values.length === 0) {
            throw new sdk_core_1.BuildTransactionError("Utxos can't be empty array");
        }
        values.forEach(this.validateUtxo);
    }
    /**
     * Validates locktime
     * @param locktime
     */
    validateLocktime(locktime) {
        if (!locktime || locktime < BigInt(0)) {
            throw new sdk_core_1.BuildTransactionError('Invalid transaction: locktime must be 0 or higher');
        }
    }
    // endregion
    /**
     * Threshold is an int that names the number of unique signatures required to spend the output.
     * Must be less than or equal to the length of Addresses.
     * @param {number} value
     */
    threshold(value) {
        this.validateThreshold(value);
        this._transaction._threshold = value;
        return this;
    }
    /**
     * Locktime is a long that contains the unix timestamp that this output can be spent after.
     * The unix timestamp is specific to the second.
     * @param value
     */
    locktime(value) {
        this.validateLocktime(BigInt(value));
        this._transaction._locktime = BigInt(value);
        return this;
    }
    /**
     * When using recovery key must be set here
     * TODO: STLX-17317 recovery key signing
     * @param {boolean}[recoverSigner=true] whether it's recovery signer
     */
    recoverMode(recoverSigner = true) {
        this.recoverSigner = recoverSigner;
        return this;
    }
    /**
     * fromPubKey is a list of unique addresses that correspond to the private keys that can be used to spend this output
     * @param {string | string[]} senderPubKey
     */
    fromPubKey(senderPubKey) {
        const pubKeys = senderPubKey instanceof Array ? senderPubKey : [senderPubKey];
        this._transaction._fromAddresses = pubKeys.map(utils_1.default.parseAddress);
        return this;
    }
    /**
     * List of UTXO required as inputs.
     * A UTXO is a standalone representation of a transaction output.
     *
     * @param {DecodedUtxoObj[]} list of UTXOS
     */
    utxos(value) {
        this.validateUtxos(value);
        this._transaction._utxos = value;
        return this;
    }
    // TODO(CR-1073):
    // Implement:
    //  buildImplementation
    //  signImplementation
    //  get transaction
    //  set transaction
    //  validateRawTransaction
    /** @inheritdoc */
    fromImplementation(rawTransaction) {
        const [tx] = avalanchejs_1.pvmSerial.AddPermissionlessValidatorTx.fromBytes(Buffer.from(rawTransaction, 'hex'), avalanchejs_1.avmSerial.getAVMManager().getDefaultCodec());
        // TODO(CR-1073): check if initBuilder can only use UnsignedTx and pvmSerial.BaseTx is not required
        this.initBuilder(tx);
        return this._transaction;
    }
}
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi90cmFuc2FjdGlvbkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsMERBQTRFO0FBQzVFLDhDQUFnRjtBQUloRiwrQ0FBNEM7QUFDNUMsb0RBQTRCO0FBRTVCLE1BQXNCLGtCQUFtQixTQUFRLGlDQUFzQjtJQUtyRSxZQUFZLFdBQWlDO1FBQzNDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUpYLGtCQUFhLEdBQUcsS0FBSyxDQUFDO1FBQ3pCLFlBQU8sR0FBYyxFQUFFLENBQUM7UUFJN0IsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLHlCQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsV0FBVyxDQUFDLEVBQU07UUFDaEIsTUFBTSxNQUFNLEdBQUssRUFBaUIsQ0FBQyxFQUE2QyxDQUFDLE1BQU0sQ0FBQztRQUN4RixJQUNFLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVO1lBQ3pELE1BQU0sQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLEtBQUssSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLEVBQy9EO1lBQ0EsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO1NBQ3hEO1FBQ0QsSUFBSSxDQUFDLFlBQVksQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDckMsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsb0JBQW9CO0lBQ3BCOzs7T0FHRztJQUNILGlCQUFpQixDQUFDLFNBQWlCO1FBQ2pDLElBQUksQ0FBQyxTQUFTLElBQUksU0FBUyxLQUFLLENBQUMsRUFBRTtZQUNqQyxNQUFNLElBQUksZ0NBQXFCLENBQUMsaURBQWlELENBQUMsQ0FBQztTQUNwRjtJQUNI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LFlBQVksQ0FBQztJQUMzQixDQUFDO0NBQ0Y7QUEvSUQsZ0RBK0lDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXZtU2VyaWFsLCBwdm1TZXJpYWwsIFVuc2lnbmVkVHggfSBmcm9tICdAYml0Z28tZm9ya3MvYXZhbGFuY2hlanMnO1xuaW1wb3J0IHsgQmFzZVRyYW5zYWN0aW9uQnVpbGRlciwgQnVpbGRUcmFuc2FjdGlvbkVycm9yIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBEZWNvZGVkVXR4b09iaiwgVHggfSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IEtleVBhaXIgfSBmcm9tICcuL2tleVBhaXInO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuL3RyYW5zYWN0aW9uJztcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRyYW5zYWN0aW9uQnVpbGRlciBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXIge1xuICBwcm90ZWN0ZWQgX3RyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbjtcbiAgcHJvdGVjdGVkIHJlY292ZXJTaWduZXIgPSBmYWxzZTtcbiAgcHVibGljIF9zaWduZXI6IEtleVBhaXJbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKF9jb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xuICAgIHN1cGVyKF9jb2luQ29uZmlnKTtcbiAgICB0aGlzLl90cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbihfY29pbkNvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgdHJhbnNhY3Rpb24gYnVpbGRlciBmaWVsZHMgdXNpbmcgdGhlIGRlY29kZWQgdHJhbnNhY3Rpb24gZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0eCB0aGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgKiBAcmV0dXJucyBpdHNlbGZcbiAgICovXG4gIGluaXRCdWlsZGVyKHR4OiBUeCk6IHRoaXMge1xuICAgIGNvbnN0IGJhc2VUeCA9ICgodHggYXMgVW5zaWduZWRUeCkudHggYXMgcHZtU2VyaWFsLkFkZFBlcm1pc3Npb25sZXNzVmFsaWRhdG9yVHgpLmJhc2VUeDtcbiAgICBpZiAoXG4gICAgICBiYXNlVHguTmV0d29ya0lkLnZhbHVlKCkgIT09IHRoaXMuX3RyYW5zYWN0aW9uLl9uZXR3b3JrSUQgfHxcbiAgICAgIGJhc2VUeC5CbG9ja2NoYWluSWQudmFsdWUoKSAhPT0gdGhpcy5fdHJhbnNhY3Rpb24uX2Jsb2NrY2hhaW5JRFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIG9yIGJsb2NrY2hhaW4gaXMgbm90IGVxdWFscycpO1xuICAgIH1cbiAgICB0aGlzLl90cmFuc2FjdGlvbi5zZXRUcmFuc2FjdGlvbih0eCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZWdpb24gVmFsaWRhdG9yc1xuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSB0aHJlc2hvbGRcbiAgICogQHBhcmFtIHRocmVzaG9sZFxuICAgKi9cbiAgdmFsaWRhdGVUaHJlc2hvbGQodGhyZXNob2xkOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRocmVzaG9sZCB8fCB0aHJlc2hvbGQgIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb246IHRocmVzaG9sZCBtdXN0IGJlIHNldCB0byAyJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBVVFhPIGhhcyBleHBlY3RlZCBmaWVsZHMuXG4gICAqIEBwYXJhbSBVVFhPXG4gICAqL1xuICB2YWxpZGF0ZVV0eG8odmFsdWU6IERlY29kZWRVdHhvT2JqKTogdm9pZCB7XG4gICAgWydvdXRwdXRJRCcsICdhbW91bnQnLCAndHhpZCcsICdvdXRwdXRpZHgnXS5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgaWYgKCF2YWx1ZS5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYFV0eG9zIHJlcXVpcmVkICR7ZmllbGR9YCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhlIGxpc3Qgb2YgVVRYT1MgaXMgZW1wdHkgYW5kIGNoZWNrIGVhY2ggVVRYTy5cbiAgICogQHBhcmFtIHZhbHVlc1xuICAgKi9cbiAgdmFsaWRhdGVVdHhvcyh2YWx1ZXM6IERlY29kZWRVdHhvT2JqW10pOiB2b2lkIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihcIlV0eG9zIGNhbid0IGJlIGVtcHR5IGFycmF5XCIpO1xuICAgIH1cbiAgICB2YWx1ZXMuZm9yRWFjaCh0aGlzLnZhbGlkYXRlVXR4byk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIGxvY2t0aW1lXG4gICAqIEBwYXJhbSBsb2NrdGltZVxuICAgKi9cbiAgdmFsaWRhdGVMb2NrdGltZShsb2NrdGltZTogYmlnaW50KTogdm9pZCB7XG4gICAgaWYgKCFsb2NrdGltZSB8fCBsb2NrdGltZSA8IEJpZ0ludCgwKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbjogbG9ja3RpbWUgbXVzdCBiZSAwIG9yIGhpZ2hlcicpO1xuICAgIH1cbiAgfVxuICAvLyBlbmRyZWdpb25cblxuICAvKipcbiAgICogVGhyZXNob2xkIGlzIGFuIGludCB0aGF0IG5hbWVzIHRoZSBudW1iZXIgb2YgdW5pcXVlIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIG91dHB1dC5cbiAgICogTXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiBBZGRyZXNzZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgdGhyZXNob2xkKHZhbHVlOiBudW1iZXIpOiB0aGlzIHtcbiAgICB0aGlzLnZhbGlkYXRlVGhyZXNob2xkKHZhbHVlKTtcbiAgICB0aGlzLl90cmFuc2FjdGlvbi5fdGhyZXNob2xkID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTG9ja3RpbWUgaXMgYSBsb25nIHRoYXQgY29udGFpbnMgdGhlIHVuaXggdGltZXN0YW1wIHRoYXQgdGhpcyBvdXRwdXQgY2FuIGJlIHNwZW50IGFmdGVyLlxuICAgKiBUaGUgdW5peCB0aW1lc3RhbXAgaXMgc3BlY2lmaWMgdG8gdGhlIHNlY29uZC5cbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBsb2NrdGltZSh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogdGhpcyB7XG4gICAgdGhpcy52YWxpZGF0ZUxvY2t0aW1lKEJpZ0ludCh2YWx1ZSkpO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uLl9sb2NrdGltZSA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB1c2luZyByZWNvdmVyeSBrZXkgbXVzdCBiZSBzZXQgaGVyZVxuICAgKiBUT0RPOiBTVExYLTE3MzE3IHJlY292ZXJ5IGtleSBzaWduaW5nXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn1bcmVjb3ZlclNpZ25lcj10cnVlXSB3aGV0aGVyIGl0J3MgcmVjb3Zlcnkgc2lnbmVyXG4gICAqL1xuICByZWNvdmVyTW9kZShyZWNvdmVyU2lnbmVyID0gdHJ1ZSk6IHRoaXMge1xuICAgIHRoaXMucmVjb3ZlclNpZ25lciA9IHJlY292ZXJTaWduZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogZnJvbVB1YktleSBpcyBhIGxpc3Qgb2YgdW5pcXVlIGFkZHJlc3NlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIHByaXZhdGUga2V5cyB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZW5kIHRoaXMgb3V0cHV0XG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IHNlbmRlclB1YktleVxuICAgKi9cbiAgZnJvbVB1YktleShzZW5kZXJQdWJLZXk6IHN0cmluZyB8IHN0cmluZ1tdKTogdGhpcyB7XG4gICAgY29uc3QgcHViS2V5cyA9IHNlbmRlclB1YktleSBpbnN0YW5jZW9mIEFycmF5ID8gc2VuZGVyUHViS2V5IDogW3NlbmRlclB1YktleV07XG4gICAgdGhpcy5fdHJhbnNhY3Rpb24uX2Zyb21BZGRyZXNzZXMgPSBwdWJLZXlzLm1hcCh1dGlscy5wYXJzZUFkZHJlc3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgVVRYTyByZXF1aXJlZCBhcyBpbnB1dHMuXG4gICAqIEEgVVRYTyBpcyBhIHN0YW5kYWxvbmUgcmVwcmVzZW50YXRpb24gb2YgYSB0cmFuc2FjdGlvbiBvdXRwdXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RGVjb2RlZFV0eG9PYmpbXX0gbGlzdCBvZiBVVFhPU1xuICAgKi9cbiAgdXR4b3ModmFsdWU6IERlY29kZWRVdHhvT2JqW10pOiB0aGlzIHtcbiAgICB0aGlzLnZhbGlkYXRlVXR4b3ModmFsdWUpO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uLl91dHhvcyA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gVE9ETyhDUi0xMDczKTpcbiAgLy8gSW1wbGVtZW50OlxuICAvLyAgYnVpbGRJbXBsZW1lbnRhdGlvblxuICAvLyAgc2lnbkltcGxlbWVudGF0aW9uXG4gIC8vICBnZXQgdHJhbnNhY3Rpb25cbiAgLy8gIHNldCB0cmFuc2FjdGlvblxuICAvLyAgdmFsaWRhdGVSYXdUcmFuc2FjdGlvblxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgZnJvbUltcGxlbWVudGF0aW9uKHJhd1RyYW5zYWN0aW9uOiBzdHJpbmcpOiBUcmFuc2FjdGlvbiB7XG4gICAgY29uc3QgW3R4XSA9IHB2bVNlcmlhbC5BZGRQZXJtaXNzaW9ubGVzc1ZhbGlkYXRvclR4LmZyb21CeXRlcyhcbiAgICAgIEJ1ZmZlci5mcm9tKHJhd1RyYW5zYWN0aW9uLCAnaGV4JyksXG4gICAgICBhdm1TZXJpYWwuZ2V0QVZNTWFuYWdlcigpLmdldERlZmF1bHRDb2RlYygpXG4gICAgKTtcbiAgICAvLyBUT0RPKENSLTEwNzMpOiBjaGVjayBpZiBpbml0QnVpbGRlciBjYW4gb25seSB1c2UgVW5zaWduZWRUeCBhbmQgcHZtU2VyaWFsLkJhc2VUeCBpcyBub3QgcmVxdWlyZWRcbiAgICB0aGlzLmluaXRCdWlsZGVyKHR4KTtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb247XG4gIH1cbn1cbiJdfQ==