import { avaxSerial, Credential, pvmSerial, TypeSymbols, Utxo } from '@bitgo-forks/avalanchejs';
import { BaseAddress, BaseKey, TransactionType } from '@bitgo/sdk-core';
import { BaseCoin as CoinConfig } from '@bitgo/statics';
import BigNumber from 'bignumber.js';
import { DecodedUtxoObj, Tx } from './iface';
import { KeyPair } from './keyPair';
import { Transaction } from './transaction';
import { TransactionBuilder } from './transactionBuilder';
export declare class PermissionlessValidatorTxBuilder extends TransactionBuilder {
    _signer: KeyPair[];
    protected _nodeID: string;
    protected _blsPublicKey: string;
    protected _blsSignature: string;
    protected _startTime: bigint;
    protected _endTime: bigint;
    protected _stakeAmount: bigint;
    protected recoverSigner: boolean;
    protected _delegationFeeRate: number;
    /**
     *
     * @param coinConfig
     */
    constructor(coinConfig: Readonly<CoinConfig>);
    /**
     * get transaction type
     * @protected
     */
    protected get transactionType(): TransactionType;
    /**
     * Validates locktime
     * @param locktime
     */
    validateLocktime(locktime: bigint): void;
    /**
     * Validate that the delegation fee is at least the minDelegationFee
     * @param delegationFeeRate number
     */
    validateDelegationFeeRate(delegationFeeRate: number): void;
    /**
     * Check the UTXO has expected fields.
     * @param UTXO
     */
    validateUtxo(value: DecodedUtxoObj): void;
    /**
     * Addresses where reward should be deposit
     * @param {string | string[]} address - single address or array of addresses to receive rewards
     */
    rewardAddresses(address: string | string[]): this;
    /** @inheritdoc */
    protected fromImplementation(rawTransaction: string): Transaction;
    /** @inheritdoc */
    protected buildImplementation(): Promise<Transaction>;
    /**
     *
     * @param nodeID
     */
    nodeID(nodeID: string): this;
    /**
     *
     * @param blsPublicKey
     */
    blsPublicKey(blsPublicKey: string): this;
    /**
     *
     * @param blsSignature
     */
    blsSignature(blsSignature: string): this;
    /**
     * Locktime is a long that contains the unix timestamp that this output can be spent after.
     * The unix timestamp is specific to the second.
     * @param value
     */
    locktime(value: string | number): this;
    /**
     * set the delegationFeeRate
     * @param value number
     */
    delegationFeeRate(value: number): this;
    /**
     * start time of staking period
     * @param value
     */
    startTime(value: string | number): this;
    /**
     * end time of staking period
     * @param value
     */
    endTime(value: string | number): this;
    /**
     *
     * @param value
     */
    stakeAmount(value: bigint | string): this;
    /**
     * validates a correct NodeID is used
     * @param nodeID
     */
    validateNodeID(nodeID: string): void;
    /**
     * Validate stake duration
     * @param startTime
     * @param endTime
     */
    validateStakeDuration(startTime: bigint, endTime: bigint): void;
    /**
     * Validate stake amount
     * @param amount
     */
    validateStakeAmount(amount: bigint): void;
    /** @inheritdoc */
    initBuilder(tx: Tx): this;
    static verifyTxType(type: TypeSymbols): boolean;
    verifyTxType(tx: Tx): tx is pvmSerial.AddPermissionlessValidatorTx;
    /**
     * Since addresses in outputs get reordered, we need to make sure signatures
     * are added in the correct position
     * To find the position, we use the output's addresses to create the
     * signatureIdx in the order needed (i.e. [user, bitgo, backup])
     * @protected
     */
    protected calculateUtxos(): {
        inputs: avaxSerial.TransferableInput[];
        stakeOutputs: avaxSerial.TransferableOutput[];
        changeOutputs: avaxSerial.TransferableOutput[];
        utxos: Utxo[];
        credentials: Credential[];
    };
    /**
     * Build the add validator transaction
     * @protected
     */
    protected buildAvaxTransaction(): void;
    /** @inheritdoc */
    protected signImplementation({ key }: BaseKey): Transaction;
    /** @inheritdoc */
    validateAddress(address: BaseAddress, addressFormat?: string): void;
    /** @inheritdoc */
    protected get transaction(): Transaction;
    protected set transaction(transaction: Transaction);
    hasSigner(): boolean;
    /** @inheritdoc */
    validateKey({ key }: BaseKey): void;
    /**
     * Check the raw transaction has a valid format in the blockchain context, throw otherwise.
     *
     * @param rawTransaction Transaction in any format
     */
    validateRawTransaction(rawTransaction: string): void;
    /** @inheritdoc */
    validateTransaction(transaction?: Transaction): void;
    /** @inheritdoc */
    validateValue(value: BigNumber): void;
}
//# sourceMappingURL=permissionlessValidatorTxBuilder.d.ts.map