"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeprecatedTransaction = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const iface_1 = require("./iface");
const avalanche_1 = require("avalanche");
const utils_1 = __importDefault(require("./utils"));
function isEmptySignature(s) {
    return !!s && s.startsWith(''.padStart(90, '0'));
}
/**
 * Signatures are prestore as empty buffer for hsm and address of signar for first signature.
 * When sign is required, this method return the function that identify a signature to be replaced.
 * @param signatures any signatures as samples to identify which signature required replace.
 */
function generateSelectorSignature(signatures) {
    if (signatures.length > 1 && signatures.every((sig) => isEmptySignature(sig.bytes))) {
        // Look for address.
        return function (sig, address) {
            try {
                if (!isEmptySignature(sig.bytes)) {
                    return false;
                }
                const pub = sig.bytes.substring(90);
                return pub === address;
            }
            catch (e) {
                return false;
            }
        };
    }
    else {
        // Look for empty string
        return function (sig, address) {
            if (isEmptySignature(sig.bytes))
                return true;
            return false;
        };
    }
}
// end region utils for sign
class DeprecatedTransaction extends sdk_core_1.BaseTransaction {
    constructor(coinConfig) {
        super(coinConfig);
        this._threshold = 2;
        this._locktime = new avalanche_1.BN(0);
        this._fromAddresses = [];
        this._utxos = [];
        this._fee = {};
        this._network = coinConfig.network;
        this._assetId = utils_1.default.cb58Decode(this._network.avaxAssetID);
        this._blockchainID = utils_1.default.cb58Decode(this._network.blockchainID);
        this._networkID = this._network.networkID;
    }
    get avaxPTransaction() {
        return this._avaxTransaction.getUnsignedTx().getTransaction();
    }
    get signature() {
        if (this.credentials.length === 0) {
            return [];
        }
        const obj = this.credentials[0].serialize();
        return obj.sigArray.map((s) => s.bytes).filter((s) => !isEmptySignature(s));
    }
    get credentials() {
        var _a;
        return (_a = this._avaxTransaction) === null || _a === void 0 ? void 0 : _a.credentials;
    }
    get hasCredentials() {
        return this.credentials !== undefined && this.credentials.length > 0;
    }
    /** @inheritdoc */
    canSign({ key }) {
        // TODO(BG-56700):  Improve canSign by check in addresses in empty credentials match signer
        return true;
    }
    /**
     * Sign a avaxp transaction and update the transaction hex
     * validator, delegator, import, exports extend baseTx
     * unsignedTx: UnsignedTx = new UnsignedTx(baseTx)  (baseTx = addValidatorTx)
     * const tx: Tx = unsignedTx.sign(keychain) (tx is type standard signed tx)
     * get baseTx then create new unsignedTx then sign
     *
     * @param {KeyPair} keyPair
     */
    sign(keyPair) {
        const prv = keyPair.getPrivateKey();
        const addressHex = keyPair.getAddressBuffer().toString('hex');
        if (!prv) {
            throw new sdk_core_1.SigningError('Missing private key');
        }
        if (!this.avaxPTransaction) {
            throw new sdk_core_1.InvalidTransactionError('empty transaction to sign');
        }
        if (!this.hasCredentials) {
            throw new sdk_core_1.InvalidTransactionError('empty credentials to sign');
        }
        const signature = this.createSignature(prv);
        let checkSign = undefined;
        this.credentials.forEach((c, index) => {
            const cs = c.serialize();
            if (checkSign === undefined) {
                checkSign = generateSelectorSignature(cs.sigArray);
            }
            let find = false;
            cs.sigArray.forEach((sig) => {
                if (checkSign && checkSign(sig, addressHex)) {
                    sig.bytes = signature;
                    find = true;
                }
            });
            if (!find)
                throw new sdk_core_1.SigningError('Private key cannot sign the transaction');
            c.deserialize(cs);
        });
    }
    /** @inheritdoc */
    /**
     * should be of signedTx doing this with baseTx
     */
    toBroadcastFormat() {
        if (!this.avaxPTransaction) {
            throw new sdk_core_1.InvalidTransactionError('Empty transaction data');
        }
        return this._avaxTransaction.toStringHex();
    }
    // types - stakingTransaction, import, export
    toJson() {
        if (!this.avaxPTransaction) {
            throw new sdk_core_1.InvalidTransactionError('Empty transaction data');
        }
        return {
            id: this.id,
            inputs: this.inputs,
            fromAddresses: this.fromAddresses,
            threshold: this._threshold,
            locktime: this._locktime.toString(),
            type: this.type,
            signatures: this.signature,
            outputs: this.outputs,
            changeOutputs: this.changeOutputs,
            sourceChain: this.sourceChain,
            destinationChain: this.destinationChain,
        };
    }
    setTransaction(tx) {
        this._avaxTransaction = tx;
    }
    /**
     * Set the transaction type
     *
     * @param {TransactionType} transactionType The transaction type to be set
     */
    setTransactionType(transactionType) {
        this._type = transactionType;
    }
    /**
     * Returns the portion of the transaction that needs to be signed in Buffer format.
     * Only needed for coins that support adding signatures directly (e.g. TSS).
     */
    get signablePayload() {
        return utils_1.default.sha256(this._avaxTransaction.getUnsignedTx().toBuffer());
    }
    get id() {
        return utils_1.default.cb58Encode(avalanche_1.Buffer.from(utils_1.default.sha256(this._avaxTransaction.toBuffer())));
    }
    get fromAddresses() {
        return this._fromAddresses.map((a) => utils_1.default.addressToString(this._network.hrp, this._network.alias, a));
    }
    get rewardAddresses() {
        return this._rewardAddresses.map((a) => utils_1.default.addressToString(this._network.hrp, this._network.alias, a));
    }
    /**
     * Get the list of outputs. Amounts are expressed in absolute value.
     */
    get outputs() {
        switch (this.type) {
            case sdk_core_1.TransactionType.Import:
                return this.avaxPTransaction
                    .getOuts()
                    .map(utils_1.default.deprecatedMapOutputToEntry(this._network));
            case sdk_core_1.TransactionType.Export:
                if (utils_1.default.isTransactionOf(this._avaxTransaction, this._network.cChainBlockchainID)) {
                    return this.avaxPTransaction
                        .getExportedOutputs()
                        .map(utils_1.default.deprecatedMapOutputToEntry(this._network));
                }
                else {
                    return this.avaxPTransaction
                        .getExportOutputs()
                        .map(utils_1.default.deprecatedMapOutputToEntry(this._network));
                }
            case sdk_core_1.TransactionType.AddDelegator:
            case sdk_core_1.TransactionType.AddValidator:
                // Get staked outputs
                const addValidatorTx = this.avaxPTransaction;
                return [
                    {
                        address: addValidatorTx.getNodeIDString(),
                        value: addValidatorTx.getStakeAmount().toString(),
                    },
                ];
            default:
                return [];
        }
    }
    /**
     * Get a Transasction Fee.
     */
    get fee() {
        return { fee: '0', ...this._fee };
    }
    get changeOutputs() {
        // C-chain tx adn Import Txs don't have change outputs
        if (this.type === sdk_core_1.TransactionType.Import ||
            utils_1.default.isTransactionOf(this._avaxTransaction, this._network.cChainBlockchainID)) {
            return [];
        }
        // general support any transaction type, but it's scoped yet
        return this.avaxPTransaction.getOuts().map(utils_1.default.deprecatedMapOutputToEntry(this._network));
    }
    get inputs() {
        let inputs;
        switch (this.type) {
            case sdk_core_1.TransactionType.Import:
                inputs = this.avaxPTransaction.getImportInputs();
                break;
            case sdk_core_1.TransactionType.Export:
                if (utils_1.default.isTransactionOf(this._avaxTransaction, this._network.cChainBlockchainID)) {
                    return this.avaxPTransaction.getInputs().map((evmInput) => ({
                        address: '0x' + evmInput.getAddressString(),
                        value: new avalanche_1.BN(evmInput.amount).toString(),
                        nonce: evmInput.getNonce().toNumber(),
                    }));
                }
                inputs = this.avaxPTransaction.getIns();
                break;
            default:
                inputs = this.avaxPTransaction.getIns();
        }
        return inputs.map((input) => {
            const amountInput = input.getInput();
            return {
                id: utils_1.default.cb58Encode(input.getTxID()) + iface_1.INPUT_SEPARATOR + utils_1.default.outputidxBufferToNumber(input.getOutputIdx()),
                address: this.fromAddresses.sort().join(iface_1.ADDRESS_SEPARATOR),
                value: amountInput.getAmount().toString(),
            };
        });
    }
    /**
     * Avax wrapper to create signature and return it for credentials
     * @param prv
     * @return hexstring
     */
    createSignature(prv) {
        const signval = utils_1.default.createSignatureAvaxBuffer(this._network, avalanche_1.Buffer.from(this.signablePayload), avalanche_1.Buffer.from(prv));
        return signval.toString('hex');
    }
    /** @inheritdoc */
    explainTransaction() {
        const txJson = this.toJson();
        const displayOrder = ['id', 'inputs', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee', 'type'];
        const outputAmount = txJson.outputs.reduce((p, n) => p.add(new avalanche_1.BN(n.value)), new avalanche_1.BN(0)).toString();
        const changeAmount = txJson.changeOutputs.reduce((p, n) => p.add(new avalanche_1.BN(n.value)), new avalanche_1.BN(0)).toString();
        let rewardAddresses;
        if ([sdk_core_1.TransactionType.AddValidator, sdk_core_1.TransactionType.AddDelegator].includes(txJson.type)) {
            rewardAddresses = this.rewardAddresses;
            displayOrder.splice(6, 0, 'rewardAddresses');
        }
        return {
            displayOrder,
            id: txJson.id,
            inputs: txJson.inputs,
            outputs: txJson.outputs.map((o) => ({ address: o.address, amount: o.value })),
            outputAmount,
            changeOutputs: txJson.changeOutputs.map((o) => ({ address: o.address, amount: o.value })),
            changeAmount,
            rewardAddresses,
            fee: this.fee,
            type: txJson.type,
        };
    }
    /**
     * Check if this transaction is a P chain
     */
    get isTransactionForCChain() {
        return utils_1.default.isTransactionOf(this._avaxTransaction, this._network.cChainBlockchainID);
    }
    /**
     * get the source chain id or undefined if it's a cross chain transfer.
     */
    get sourceChain() {
        let blockchainID;
        switch (this.type) {
            case sdk_core_1.TransactionType.Import:
                blockchainID = this.avaxPTransaction.getSourceChain();
                break;
            case sdk_core_1.TransactionType.Export:
                blockchainID = this.avaxPTransaction.getBlockchainID();
                break;
            default:
                return undefined;
        }
        return this.blockchainIDtoAlias(blockchainID);
    }
    /**
     * get the destinationChain or undefined if it's a cross chain transfer.
     */
    get destinationChain() {
        let blockchainID;
        switch (this.type) {
            case sdk_core_1.TransactionType.Import:
                blockchainID = this.avaxPTransaction.getBlockchainID();
                break;
            case sdk_core_1.TransactionType.Export:
                blockchainID = this.avaxPTransaction.getDestinationChain();
                break;
            default:
                return undefined;
        }
        return this.blockchainIDtoAlias(blockchainID);
    }
    /**
     * Convert a blockchainId buffer to string and return P or C alias if match of any of that chains.
     * @param {BufferAvax} blockchainIDBuffer
     * @return {string} blocchainID or alias if exists.
     * @private
     */
    blockchainIDtoAlias(blockchainIDBuffer) {
        const blockchainId = utils_1.default.cb58Encode(blockchainIDBuffer);
        switch (blockchainId) {
            case this._network.cChainBlockchainID:
                return 'C';
            case this._network.blockchainID:
                return 'P';
            default:
                return blockchainId;
        }
    }
}
exports.DeprecatedTransaction = DeprecatedTransaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwcmVjYXRlZFRyYW5zYWN0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9kZXByZWNhdGVkVHJhbnNhY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsOENBUXlCO0FBRXpCLG1DQVFpQjtBQUdqQix5Q0FBcUQ7QUFDckQsb0RBQTRCO0FBWTVCLFNBQVMsZ0JBQWdCLENBQUMsQ0FBUztJQUNqQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ25ELENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyx5QkFBeUIsQ0FBQyxVQUFpQztJQUNsRSxJQUFJLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO1FBQ25GLG9CQUFvQjtRQUNwQixPQUFPLFVBQVUsR0FBRyxFQUFFLE9BQU87WUFDM0IsSUFBSTtnQkFDRixJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFO29CQUNoQyxPQUFPLEtBQUssQ0FBQztpQkFDZDtnQkFDRCxNQUFNLEdBQUcsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDcEMsT0FBTyxHQUFHLEtBQUssT0FBTyxDQUFDO2FBQ3hCO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1YsT0FBTyxLQUFLLENBQUM7YUFDZDtRQUNILENBQUMsQ0FBQztLQUNIO1NBQU07UUFDTCx3QkFBd0I7UUFDeEIsT0FBTyxVQUFVLEdBQUcsRUFBRSxPQUFPO1lBQzNCLElBQUksZ0JBQWdCLENBQUMsR0FBRyxDQUFDLEtBQUss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QyxnQkFBMkMsQ0FBQyxlQUFlLEVBQUUsQ0FBQztnQkFDbkYsTUFBTTtZQUNSO2dCQUNFLE9BQU8sU0FBUyxDQUFDO1NBQ3BCO1FBQ0QsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBSSxnQkFBZ0I7UUFDbEIsSUFBSSxZQUFZLENBQUM7UUFDakIsUUFBUSxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2pCLEtBQUssMEJBQWUsQ0FBQyxNQUFNO2dCQUN6QixZQUFZLEdBQUksSUFBSSxDQUFDLGdCQUEyQyxDQUFDLGVBQWUsRUFBRSxDQUFDO2dCQUNuRixNQUFNO1lBQ1IsS0FBSywwQkFBZSxDQUFDLE1BQU07Z0JBQ3pCLFlBQVksR0FBSSxJQUFJLENBQUMsZ0JBQTJDLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztnQkFDdkYsTUFBTTtZQUNSO2dCQUNFLE9BQU8sU0FBUyxDQUFDO1NBQ3BCO1FBQ0QsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ssbUJBQW1CLENBQUMsa0JBQThCO1FBQ3hELE1BQU0sWUFBWSxHQUFHLGVBQUssQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUMxRCxRQUFRLFlBQVksRUFBRTtZQUNwQixLQUFLLElBQUksQ0FBQyxRQUFRLENBQUMsa0JBQWtCO2dCQUNuQyxPQUFPLEdBQUcsQ0FBQztZQUNiLEtBQUssSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZO2dCQUM3QixPQUFPLEdBQUcsQ0FBQztZQUNiO2dCQUNFLE9BQU8sWUFBWSxDQUFDO1NBQ3ZCO0lBQ0gsQ0FBQztDQUNGO0FBalZELHNEQWlWQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEF2YWxhbmNoZU5ldHdvcmssIEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQge1xuICBCYXNlS2V5LFxuICBCYXNlVHJhbnNhY3Rpb24sXG4gIEVudHJ5LFxuICBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcixcbiAgU2lnbmluZ0Vycm9yLFxuICBUcmFuc2FjdGlvbkZlZSxcbiAgVHJhbnNhY3Rpb25UeXBlLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgS2V5UGFpciB9IGZyb20gJy4va2V5UGFpcic7XG5pbXBvcnQge1xuICBEZXByZWNhdGVkQmFzZVR4LFxuICBEZWNvZGVkVXR4b09iaixcbiAgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbixcbiAgRGVwcmVjYXRlZFR4LFxuICBUeERhdGEsXG4gIElOUFVUX1NFUEFSQVRPUixcbiAgQUREUkVTU19TRVBBUkFUT1IsXG59IGZyb20gJy4vaWZhY2UnO1xuaW1wb3J0IHsgQWRkRGVsZWdhdG9yVHgsIEFtb3VudElucHV0LCBCYXNlVHggYXMgUFZNQmFzZVR4LCBFeHBvcnRUeCwgSW1wb3J0VHggfSBmcm9tICdhdmFsYW5jaGUvZGlzdC9hcGlzL3BsYXRmb3Jtdm0nO1xuaW1wb3J0IHsgRXhwb3J0VHggYXMgRVZNRXhwb3J0VHgsIEltcG9ydFR4IGFzIEVWTUltcG9ydFR4IH0gZnJvbSAnYXZhbGFuY2hlL2Rpc3QvYXBpcy9ldm0nO1xuaW1wb3J0IHsgQk4sIEJ1ZmZlciBhcyBCdWZmZXJBdmF4IH0gZnJvbSAnYXZhbGFuY2hlJztcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IENyZWRlbnRpYWwgfSBmcm9tICdhdmFsYW5jaGUvZGlzdC9jb21tb24nO1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcblxuLy8gcmVnaW9uIHV0aWxzIHRvIHNpZ25cbmludGVyZmFjZSBzaWduYXR1cmVTZXJpYWxpemVkIHtcbiAgYnl0ZXM6IHN0cmluZztcbn1cbmludGVyZmFjZSBDaGVja1NpZ25hdHVyZSB7XG4gIChzaWdhdHVyZTogc2lnbmF0dXJlU2VyaWFsaXplZCwgYWRkcmVzc0hleDogc3RyaW5nKTogYm9vbGVhbjtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eVNpZ25hdHVyZShzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhcyAmJiBzLnN0YXJ0c1dpdGgoJycucGFkU3RhcnQoOTAsICcwJykpO1xufVxuXG4vKipcbiAqIFNpZ25hdHVyZXMgYXJlIHByZXN0b3JlIGFzIGVtcHR5IGJ1ZmZlciBmb3IgaHNtIGFuZCBhZGRyZXNzIG9mIHNpZ25hciBmb3IgZmlyc3Qgc2lnbmF0dXJlLlxuICogV2hlbiBzaWduIGlzIHJlcXVpcmVkLCB0aGlzIG1ldGhvZCByZXR1cm4gdGhlIGZ1bmN0aW9uIHRoYXQgaWRlbnRpZnkgYSBzaWduYXR1cmUgdG8gYmUgcmVwbGFjZWQuXG4gKiBAcGFyYW0gc2lnbmF0dXJlcyBhbnkgc2lnbmF0dXJlcyBhcyBzYW1wbGVzIHRvIGlkZW50aWZ5IHdoaWNoIHNpZ25hdHVyZSByZXF1aXJlZCByZXBsYWNlLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVNlbGVjdG9yU2lnbmF0dXJlKHNpZ25hdHVyZXM6IHNpZ25hdHVyZVNlcmlhbGl6ZWRbXSk6IENoZWNrU2lnbmF0dXJlIHtcbiAgaWYgKHNpZ25hdHVyZXMubGVuZ3RoID4gMSAmJiBzaWduYXR1cmVzLmV2ZXJ5KChzaWcpID0+IGlzRW1wdHlTaWduYXR1cmUoc2lnLmJ5dGVzKSkpIHtcbiAgICAvLyBMb29rIGZvciBhZGRyZXNzLlxuICAgIHJldHVybiBmdW5jdGlvbiAoc2lnLCBhZGRyZXNzKTogYm9vbGVhbiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWlzRW1wdHlTaWduYXR1cmUoc2lnLmJ5dGVzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdWIgPSBzaWcuYnl0ZXMuc3Vic3RyaW5nKDkwKTtcbiAgICAgICAgcmV0dXJuIHB1YiA9PT0gYWRkcmVzcztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gTG9vayBmb3IgZW1wdHkgc3RyaW5nXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzaWcsIGFkZHJlc3MpOiBib29sZWFuIHtcbiAgICAgIGlmIChpc0VtcHR5U2lnbmF0dXJlKHNpZy5ieXRlcykpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cbn1cbi8vIGVuZCByZWdpb24gdXRpbHMgZm9yIHNpZ25cblxuZXhwb3J0IGNsYXNzIERlcHJlY2F0ZWRUcmFuc2FjdGlvbiBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbiB7XG4gIHByb3RlY3RlZCBfYXZheFRyYW5zYWN0aW9uOiBEZXByZWNhdGVkVHg7XG4gIHB1YmxpYyBfdHlwZTogVHJhbnNhY3Rpb25UeXBlO1xuICBwdWJsaWMgX25ldHdvcms6IEF2YWxhbmNoZU5ldHdvcms7XG4gIHB1YmxpYyBfbmV0d29ya0lEOiBudW1iZXI7XG4gIHB1YmxpYyBfYXNzZXRJZDogQnVmZmVyQXZheDtcbiAgcHVibGljIF9ibG9ja2NoYWluSUQ6IEJ1ZmZlckF2YXg7XG4gIHB1YmxpYyBfdGhyZXNob2xkID0gMjtcbiAgcHVibGljIF9sb2NrdGltZTogQk4gPSBuZXcgQk4oMCk7XG4gIHB1YmxpYyBfZnJvbUFkZHJlc3NlczogQnVmZmVyQXZheFtdID0gW107XG4gIHB1YmxpYyBfcmV3YXJkQWRkcmVzc2VzOiBCdWZmZXJBdmF4W107XG4gIHB1YmxpYyBfdXR4b3M6IERlY29kZWRVdHhvT2JqW10gPSBbXTtcbiAgcHVibGljIF90bzogQnVmZmVyQXZheFtdO1xuICBwdWJsaWMgX2ZlZTogUGFydGlhbDxUcmFuc2FjdGlvbkZlZT4gPSB7fTtcblxuICBjb25zdHJ1Y3Rvcihjb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xuICAgIHN1cGVyKGNvaW5Db25maWcpO1xuICAgIHRoaXMuX25ldHdvcmsgPSBjb2luQ29uZmlnLm5ldHdvcmsgYXMgQXZhbGFuY2hlTmV0d29yaztcbiAgICB0aGlzLl9hc3NldElkID0gdXRpbHMuY2I1OERlY29kZSh0aGlzLl9uZXR3b3JrLmF2YXhBc3NldElEKTtcbiAgICB0aGlzLl9ibG9ja2NoYWluSUQgPSB1dGlscy5jYjU4RGVjb2RlKHRoaXMuX25ldHdvcmsuYmxvY2tjaGFpbklEKTtcbiAgICB0aGlzLl9uZXR3b3JrSUQgPSB0aGlzLl9uZXR3b3JrLm5ldHdvcmtJRDtcbiAgfVxuXG4gIGdldCBhdmF4UFRyYW5zYWN0aW9uKCk6IERlcHJlY2F0ZWRCYXNlVHgge1xuICAgIHJldHVybiB0aGlzLl9hdmF4VHJhbnNhY3Rpb24uZ2V0VW5zaWduZWRUeCgpLmdldFRyYW5zYWN0aW9uKCk7XG4gIH1cblxuICBnZXQgc2lnbmF0dXJlKCk6IHN0cmluZ1tdIHtcbiAgICBpZiAodGhpcy5jcmVkZW50aWFscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3Qgb2JqOiBhbnkgPSB0aGlzLmNyZWRlbnRpYWxzWzBdLnNlcmlhbGl6ZSgpO1xuICAgIHJldHVybiBvYmouc2lnQXJyYXkubWFwKChzKSA9PiBzLmJ5dGVzKS5maWx0ZXIoKHMpID0+ICFpc0VtcHR5U2lnbmF0dXJlKHMpKTtcbiAgfVxuXG4gIGdldCBjcmVkZW50aWFscygpOiBDcmVkZW50aWFsW10ge1xuICAgIHJldHVybiAodGhpcy5fYXZheFRyYW5zYWN0aW9uIGFzIGFueSk/LmNyZWRlbnRpYWxzO1xuICB9XG5cbiAgZ2V0IGhhc0NyZWRlbnRpYWxzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jcmVkZW50aWFscy5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGNhblNpZ24oeyBrZXkgfTogQmFzZUtleSk6IGJvb2xlYW4ge1xuICAgIC8vIFRPRE8oQkctNTY3MDApOiAgSW1wcm92ZSBjYW5TaWduIGJ5IGNoZWNrIGluIGFkZHJlc3NlcyBpbiBlbXB0eSBjcmVkZW50aWFscyBtYXRjaCBzaWduZXJcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIGEgYXZheHAgdHJhbnNhY3Rpb24gYW5kIHVwZGF0ZSB0aGUgdHJhbnNhY3Rpb24gaGV4XG4gICAqIHZhbGlkYXRvciwgZGVsZWdhdG9yLCBpbXBvcnQsIGV4cG9ydHMgZXh0ZW5kIGJhc2VUeFxuICAgKiB1bnNpZ25lZFR4OiBVbnNpZ25lZFR4ID0gbmV3IFVuc2lnbmVkVHgoYmFzZVR4KSAgKGJhc2VUeCA9IGFkZFZhbGlkYXRvclR4KVxuICAgKiBjb25zdCB0eDogVHggPSB1bnNpZ25lZFR4LnNpZ24oa2V5Y2hhaW4pICh0eCBpcyB0eXBlIHN0YW5kYXJkIHNpZ25lZCB0eClcbiAgICogZ2V0IGJhc2VUeCB0aGVuIGNyZWF0ZSBuZXcgdW5zaWduZWRUeCB0aGVuIHNpZ25cbiAgICpcbiAgICogQHBhcmFtIHtLZXlQYWlyfSBrZXlQYWlyXG4gICAqL1xuICBzaWduKGtleVBhaXI6IEtleVBhaXIpOiB2b2lkIHtcbiAgICBjb25zdCBwcnYgPSBrZXlQYWlyLmdldFByaXZhdGVLZXkoKTtcbiAgICBjb25zdCBhZGRyZXNzSGV4ID0ga2V5UGFpci5nZXRBZGRyZXNzQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGlmICghcHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdNaXNzaW5nIHByaXZhdGUga2V5Jyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5hdmF4UFRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ2VtcHR5IHRyYW5zYWN0aW9uIHRvIHNpZ24nKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhhc0NyZWRlbnRpYWxzKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ2VtcHR5IGNyZWRlbnRpYWxzIHRvIHNpZ24nKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gdGhpcy5jcmVhdGVTaWduYXR1cmUocHJ2KTtcbiAgICBsZXQgY2hlY2tTaWduOiBDaGVja1NpZ25hdHVyZSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNyZWRlbnRpYWxzLmZvckVhY2goKGMsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjczogYW55ID0gYy5zZXJpYWxpemUoKTtcbiAgICAgIGlmIChjaGVja1NpZ24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjaGVja1NpZ24gPSBnZW5lcmF0ZVNlbGVjdG9yU2lnbmF0dXJlKGNzLnNpZ0FycmF5KTtcbiAgICAgIH1cbiAgICAgIGxldCBmaW5kID0gZmFsc2U7XG4gICAgICBjcy5zaWdBcnJheS5mb3JFYWNoKChzaWcpID0+IHtcbiAgICAgICAgaWYgKGNoZWNrU2lnbiAmJiBjaGVja1NpZ24oc2lnLCBhZGRyZXNzSGV4KSkge1xuICAgICAgICAgIHNpZy5ieXRlcyA9IHNpZ25hdHVyZTtcbiAgICAgICAgICBmaW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIWZpbmQpIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ1ByaXZhdGUga2V5IGNhbm5vdCBzaWduIHRoZSB0cmFuc2FjdGlvbicpO1xuICAgICAgYy5kZXNlcmlhbGl6ZShjcyk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgLyoqXG4gICAqIHNob3VsZCBiZSBvZiBzaWduZWRUeCBkb2luZyB0aGlzIHdpdGggYmFzZVR4XG4gICAqL1xuICB0b0Jyb2FkY2FzdEZvcm1hdCgpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5hdmF4UFRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ0VtcHR5IHRyYW5zYWN0aW9uIGRhdGEnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2F2YXhUcmFuc2FjdGlvbi50b1N0cmluZ0hleCgpO1xuICB9XG5cbiAgLy8gdHlwZXMgLSBzdGFraW5nVHJhbnNhY3Rpb24sIGltcG9ydCwgZXhwb3J0XG4gIHRvSnNvbigpOiBUeERhdGEge1xuICAgIGlmICghdGhpcy5hdmF4UFRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ0VtcHR5IHRyYW5zYWN0aW9uIGRhdGEnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cyxcbiAgICAgIGZyb21BZGRyZXNzZXM6IHRoaXMuZnJvbUFkZHJlc3NlcyxcbiAgICAgIHRocmVzaG9sZDogdGhpcy5fdGhyZXNob2xkLFxuICAgICAgbG9ja3RpbWU6IHRoaXMuX2xvY2t0aW1lLnRvU3RyaW5nKCksXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICBzaWduYXR1cmVzOiB0aGlzLnNpZ25hdHVyZSxcbiAgICAgIG91dHB1dHM6IHRoaXMub3V0cHV0cyxcbiAgICAgIGNoYW5nZU91dHB1dHM6IHRoaXMuY2hhbmdlT3V0cHV0cyxcbiAgICAgIHNvdXJjZUNoYWluOiB0aGlzLnNvdXJjZUNoYWluLFxuICAgICAgZGVzdGluYXRpb25DaGFpbjogdGhpcy5kZXN0aW5hdGlvbkNoYWluLFxuICAgIH07XG4gIH1cblxuICBzZXRUcmFuc2FjdGlvbih0eDogRGVwcmVjYXRlZFR4KTogdm9pZCB7XG4gICAgdGhpcy5fYXZheFRyYW5zYWN0aW9uID0gdHg7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0cmFuc2FjdGlvbiB0eXBlXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25UeXBlfSB0cmFuc2FjdGlvblR5cGUgVGhlIHRyYW5zYWN0aW9uIHR5cGUgdG8gYmUgc2V0XG4gICAqL1xuICBzZXRUcmFuc2FjdGlvblR5cGUodHJhbnNhY3Rpb25UeXBlOiBUcmFuc2FjdGlvblR5cGUpOiB2b2lkIHtcbiAgICB0aGlzLl90eXBlID0gdHJhbnNhY3Rpb25UeXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBvcnRpb24gb2YgdGhlIHRyYW5zYWN0aW9uIHRoYXQgbmVlZHMgdG8gYmUgc2lnbmVkIGluIEJ1ZmZlciBmb3JtYXQuXG4gICAqIE9ubHkgbmVlZGVkIGZvciBjb2lucyB0aGF0IHN1cHBvcnQgYWRkaW5nIHNpZ25hdHVyZXMgZGlyZWN0bHkgKGUuZy4gVFNTKS5cbiAgICovXG4gIGdldCBzaWduYWJsZVBheWxvYWQoKTogQnVmZmVyIHtcbiAgICByZXR1cm4gdXRpbHMuc2hhMjU2KHRoaXMuX2F2YXhUcmFuc2FjdGlvbi5nZXRVbnNpZ25lZFR4KCkudG9CdWZmZXIoKSk7XG4gIH1cblxuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdXRpbHMuY2I1OEVuY29kZShCdWZmZXJBdmF4LmZyb20odXRpbHMuc2hhMjU2KHRoaXMuX2F2YXhUcmFuc2FjdGlvbi50b0J1ZmZlcigpKSkpO1xuICB9XG5cbiAgZ2V0IGZyb21BZGRyZXNzZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLl9mcm9tQWRkcmVzc2VzLm1hcCgoYSkgPT4gdXRpbHMuYWRkcmVzc1RvU3RyaW5nKHRoaXMuX25ldHdvcmsuaHJwLCB0aGlzLl9uZXR3b3JrLmFsaWFzLCBhKSk7XG4gIH1cblxuICBnZXQgcmV3YXJkQWRkcmVzc2VzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5fcmV3YXJkQWRkcmVzc2VzLm1hcCgoYSkgPT4gdXRpbHMuYWRkcmVzc1RvU3RyaW5nKHRoaXMuX25ldHdvcmsuaHJwLCB0aGlzLl9uZXR3b3JrLmFsaWFzLCBhKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0IG9mIG91dHB1dHMuIEFtb3VudHMgYXJlIGV4cHJlc3NlZCBpbiBhYnNvbHV0ZSB2YWx1ZS5cbiAgICovXG4gIGdldCBvdXRwdXRzKCk6IEVudHJ5W10ge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5JbXBvcnQ6XG4gICAgICAgIHJldHVybiAodGhpcy5hdmF4UFRyYW5zYWN0aW9uIGFzIEltcG9ydFR4IHwgRVZNSW1wb3J0VHgpXG4gICAgICAgICAgLmdldE91dHMoKVxuICAgICAgICAgIC5tYXAodXRpbHMuZGVwcmVjYXRlZE1hcE91dHB1dFRvRW50cnkodGhpcy5fbmV0d29yaykpO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuRXhwb3J0OlxuICAgICAgICBpZiAodXRpbHMuaXNUcmFuc2FjdGlvbk9mKHRoaXMuX2F2YXhUcmFuc2FjdGlvbiwgdGhpcy5fbmV0d29yay5jQ2hhaW5CbG9ja2NoYWluSUQpKSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLmF2YXhQVHJhbnNhY3Rpb24gYXMgRVZNRXhwb3J0VHgpXG4gICAgICAgICAgICAuZ2V0RXhwb3J0ZWRPdXRwdXRzKClcbiAgICAgICAgICAgIC5tYXAodXRpbHMuZGVwcmVjYXRlZE1hcE91dHB1dFRvRW50cnkodGhpcy5fbmV0d29yaykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAodGhpcy5hdmF4UFRyYW5zYWN0aW9uIGFzIEV4cG9ydFR4KVxuICAgICAgICAgICAgLmdldEV4cG9ydE91dHB1dHMoKVxuICAgICAgICAgICAgLm1hcCh1dGlscy5kZXByZWNhdGVkTWFwT3V0cHV0VG9FbnRyeSh0aGlzLl9uZXR3b3JrKSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkFkZERlbGVnYXRvcjpcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkFkZFZhbGlkYXRvcjpcbiAgICAgICAgLy8gR2V0IHN0YWtlZCBvdXRwdXRzXG4gICAgICAgIGNvbnN0IGFkZFZhbGlkYXRvclR4ID0gdGhpcy5hdmF4UFRyYW5zYWN0aW9uIGFzIEFkZERlbGVnYXRvclR4O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZFZhbGlkYXRvclR4LmdldE5vZGVJRFN0cmluZygpLFxuICAgICAgICAgICAgdmFsdWU6IGFkZFZhbGlkYXRvclR4LmdldFN0YWtlQW1vdW50KCkudG9TdHJpbmcoKSxcbiAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBUcmFuc2FzY3Rpb24gRmVlLlxuICAgKi9cbiAgZ2V0IGZlZSgpOiBUcmFuc2FjdGlvbkZlZSB7XG4gICAgcmV0dXJuIHsgZmVlOiAnMCcsIC4uLnRoaXMuX2ZlZSB9O1xuICB9XG5cbiAgZ2V0IGNoYW5nZU91dHB1dHMoKTogRW50cnlbXSB7XG4gICAgLy8gQy1jaGFpbiB0eCBhZG4gSW1wb3J0IFR4cyBkb24ndCBoYXZlIGNoYW5nZSBvdXRwdXRzXG4gICAgaWYgKFxuICAgICAgdGhpcy50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuSW1wb3J0IHx8XG4gICAgICB1dGlscy5pc1RyYW5zYWN0aW9uT2YodGhpcy5fYXZheFRyYW5zYWN0aW9uLCB0aGlzLl9uZXR3b3JrLmNDaGFpbkJsb2NrY2hhaW5JRClcbiAgICApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLy8gZ2VuZXJhbCBzdXBwb3J0IGFueSB0cmFuc2FjdGlvbiB0eXBlLCBidXQgaXQncyBzY29wZWQgeWV0XG4gICAgcmV0dXJuICh0aGlzLmF2YXhQVHJhbnNhY3Rpb24gYXMgUFZNQmFzZVR4KS5nZXRPdXRzKCkubWFwKHV0aWxzLmRlcHJlY2F0ZWRNYXBPdXRwdXRUb0VudHJ5KHRoaXMuX25ldHdvcmspKTtcbiAgfVxuXG4gIGdldCBpbnB1dHMoKTogRW50cnlbXSB7XG4gICAgbGV0IGlucHV0cztcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuSW1wb3J0OlxuICAgICAgICBpbnB1dHMgPSAodGhpcy5hdmF4UFRyYW5zYWN0aW9uIGFzIEltcG9ydFR4IHwgRVZNSW1wb3J0VHgpLmdldEltcG9ydElucHV0cygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkV4cG9ydDpcbiAgICAgICAgaWYgKHV0aWxzLmlzVHJhbnNhY3Rpb25PZih0aGlzLl9hdmF4VHJhbnNhY3Rpb24sIHRoaXMuX25ldHdvcmsuY0NoYWluQmxvY2tjaGFpbklEKSkge1xuICAgICAgICAgIHJldHVybiAodGhpcy5hdmF4UFRyYW5zYWN0aW9uIGFzIEVWTUV4cG9ydFR4KS5nZXRJbnB1dHMoKS5tYXAoKGV2bUlucHV0KSA9PiAoe1xuICAgICAgICAgICAgYWRkcmVzczogJzB4JyArIGV2bUlucHV0LmdldEFkZHJlc3NTdHJpbmcoKSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgQk4oKGV2bUlucHV0IGFzIGFueSkuYW1vdW50KS50b1N0cmluZygpLFxuICAgICAgICAgICAgbm9uY2U6IGV2bUlucHV0LmdldE5vbmNlKCkudG9OdW1iZXIoKSxcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRzID0gKHRoaXMuYXZheFBUcmFuc2FjdGlvbiBhcyBQVk1CYXNlVHgpLmdldElucygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlucHV0cyA9ICh0aGlzLmF2YXhQVHJhbnNhY3Rpb24gYXMgUFZNQmFzZVR4KS5nZXRJbnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0cy5tYXAoKGlucHV0KSA9PiB7XG4gICAgICBjb25zdCBhbW91bnRJbnB1dCA9IGlucHV0LmdldElucHV0KCkgYXMgYW55IGFzIEFtb3VudElucHV0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHV0aWxzLmNiNThFbmNvZGUoaW5wdXQuZ2V0VHhJRCgpKSArIElOUFVUX1NFUEFSQVRPUiArIHV0aWxzLm91dHB1dGlkeEJ1ZmZlclRvTnVtYmVyKGlucHV0LmdldE91dHB1dElkeCgpKSxcbiAgICAgICAgYWRkcmVzczogdGhpcy5mcm9tQWRkcmVzc2VzLnNvcnQoKS5qb2luKEFERFJFU1NfU0VQQVJBVE9SKSxcbiAgICAgICAgdmFsdWU6IGFtb3VudElucHV0LmdldEFtb3VudCgpLnRvU3RyaW5nKCksXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEF2YXggd3JhcHBlciB0byBjcmVhdGUgc2lnbmF0dXJlIGFuZCByZXR1cm4gaXQgZm9yIGNyZWRlbnRpYWxzXG4gICAqIEBwYXJhbSBwcnZcbiAgICogQHJldHVybiBoZXhzdHJpbmdcbiAgICovXG4gIGNyZWF0ZVNpZ25hdHVyZShwcnY6IEJ1ZmZlcik6IHN0cmluZyB7XG4gICAgY29uc3Qgc2lnbnZhbCA9IHV0aWxzLmNyZWF0ZVNpZ25hdHVyZUF2YXhCdWZmZXIoXG4gICAgICB0aGlzLl9uZXR3b3JrLFxuICAgICAgQnVmZmVyQXZheC5mcm9tKHRoaXMuc2lnbmFibGVQYXlsb2FkKSxcbiAgICAgIEJ1ZmZlckF2YXguZnJvbShwcnYpXG4gICAgKTtcbiAgICByZXR1cm4gc2lnbnZhbC50b1N0cmluZygnaGV4Jyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgZXhwbGFpblRyYW5zYWN0aW9uKCk6IFRyYW5zYWN0aW9uRXhwbGFuYXRpb24ge1xuICAgIGNvbnN0IHR4SnNvbiA9IHRoaXMudG9Kc29uKCk7XG4gICAgY29uc3QgZGlzcGxheU9yZGVyID0gWydpZCcsICdpbnB1dHMnLCAnb3V0cHV0QW1vdW50JywgJ2NoYW5nZUFtb3VudCcsICdvdXRwdXRzJywgJ2NoYW5nZU91dHB1dHMnLCAnZmVlJywgJ3R5cGUnXTtcblxuICAgIGNvbnN0IG91dHB1dEFtb3VudCA9IHR4SnNvbi5vdXRwdXRzLnJlZHVjZSgocCwgbikgPT4gcC5hZGQobmV3IEJOKG4udmFsdWUpKSwgbmV3IEJOKDApKS50b1N0cmluZygpO1xuICAgIGNvbnN0IGNoYW5nZUFtb3VudCA9IHR4SnNvbi5jaGFuZ2VPdXRwdXRzLnJlZHVjZSgocCwgbikgPT4gcC5hZGQobmV3IEJOKG4udmFsdWUpKSwgbmV3IEJOKDApKS50b1N0cmluZygpO1xuXG4gICAgbGV0IHJld2FyZEFkZHJlc3NlcztcbiAgICBpZiAoW1RyYW5zYWN0aW9uVHlwZS5BZGRWYWxpZGF0b3IsIFRyYW5zYWN0aW9uVHlwZS5BZGREZWxlZ2F0b3JdLmluY2x1ZGVzKHR4SnNvbi50eXBlKSkge1xuICAgICAgcmV3YXJkQWRkcmVzc2VzID0gdGhpcy5yZXdhcmRBZGRyZXNzZXM7XG4gICAgICBkaXNwbGF5T3JkZXIuc3BsaWNlKDYsIDAsICdyZXdhcmRBZGRyZXNzZXMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlzcGxheU9yZGVyLFxuICAgICAgaWQ6IHR4SnNvbi5pZCxcbiAgICAgIGlucHV0czogdHhKc29uLmlucHV0cyxcbiAgICAgIG91dHB1dHM6IHR4SnNvbi5vdXRwdXRzLm1hcCgobykgPT4gKHsgYWRkcmVzczogby5hZGRyZXNzLCBhbW91bnQ6IG8udmFsdWUgfSkpLFxuICAgICAgb3V0cHV0QW1vdW50LFxuICAgICAgY2hhbmdlT3V0cHV0czogdHhKc29uLmNoYW5nZU91dHB1dHMubWFwKChvKSA9PiAoeyBhZGRyZXNzOiBvLmFkZHJlc3MsIGFtb3VudDogby52YWx1ZSB9KSksXG4gICAgICBjaGFuZ2VBbW91bnQsXG4gICAgICByZXdhcmRBZGRyZXNzZXMsXG4gICAgICBmZWU6IHRoaXMuZmVlLFxuICAgICAgdHlwZTogdHhKc29uLnR5cGUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGEgUCBjaGFpblxuICAgKi9cbiAgZ2V0IGlzVHJhbnNhY3Rpb25Gb3JDQ2hhaW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHV0aWxzLmlzVHJhbnNhY3Rpb25PZih0aGlzLl9hdmF4VHJhbnNhY3Rpb24sIHRoaXMuX25ldHdvcmsuY0NoYWluQmxvY2tjaGFpbklEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHNvdXJjZSBjaGFpbiBpZCBvciB1bmRlZmluZWQgaWYgaXQncyBhIGNyb3NzIGNoYWluIHRyYW5zZmVyLlxuICAgKi9cbiAgZ2V0IHNvdXJjZUNoYWluKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgbGV0IGJsb2NrY2hhaW5JRDtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuSW1wb3J0OlxuICAgICAgICBibG9ja2NoYWluSUQgPSAodGhpcy5hdmF4UFRyYW5zYWN0aW9uIGFzIEltcG9ydFR4IHwgRVZNSW1wb3J0VHgpLmdldFNvdXJjZUNoYWluKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuRXhwb3J0OlxuICAgICAgICBibG9ja2NoYWluSUQgPSAodGhpcy5hdmF4UFRyYW5zYWN0aW9uIGFzIEV4cG9ydFR4IHwgRVZNRXhwb3J0VHgpLmdldEJsb2NrY2hhaW5JRCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJsb2NrY2hhaW5JRHRvQWxpYXMoYmxvY2tjaGFpbklEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGRlc3RpbmF0aW9uQ2hhaW4gb3IgdW5kZWZpbmVkIGlmIGl0J3MgYSBjcm9zcyBjaGFpbiB0cmFuc2Zlci5cbiAgICovXG4gIGdldCBkZXN0aW5hdGlvbkNoYWluKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgbGV0IGJsb2NrY2hhaW5JRDtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuSW1wb3J0OlxuICAgICAgICBibG9ja2NoYWluSUQgPSAodGhpcy5hdmF4UFRyYW5zYWN0aW9uIGFzIEltcG9ydFR4IHwgRVZNSW1wb3J0VHgpLmdldEJsb2NrY2hhaW5JRCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkV4cG9ydDpcbiAgICAgICAgYmxvY2tjaGFpbklEID0gKHRoaXMuYXZheFBUcmFuc2FjdGlvbiBhcyBFeHBvcnRUeCB8IEVWTUV4cG9ydFR4KS5nZXREZXN0aW5hdGlvbkNoYWluKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tjaGFpbklEdG9BbGlhcyhibG9ja2NoYWluSUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBibG9ja2NoYWluSWQgYnVmZmVyIHRvIHN0cmluZyBhbmQgcmV0dXJuIFAgb3IgQyBhbGlhcyBpZiBtYXRjaCBvZiBhbnkgb2YgdGhhdCBjaGFpbnMuXG4gICAqIEBwYXJhbSB7QnVmZmVyQXZheH0gYmxvY2tjaGFpbklEQnVmZmVyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gYmxvY2NoYWluSUQgb3IgYWxpYXMgaWYgZXhpc3RzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBibG9ja2NoYWluSUR0b0FsaWFzKGJsb2NrY2hhaW5JREJ1ZmZlcjogQnVmZmVyQXZheCk6IHN0cmluZyB7XG4gICAgY29uc3QgYmxvY2tjaGFpbklkID0gdXRpbHMuY2I1OEVuY29kZShibG9ja2NoYWluSURCdWZmZXIpO1xuICAgIHN3aXRjaCAoYmxvY2tjaGFpbklkKSB7XG4gICAgICBjYXNlIHRoaXMuX25ldHdvcmsuY0NoYWluQmxvY2tjaGFpbklEOlxuICAgICAgICByZXR1cm4gJ0MnO1xuICAgICAgY2FzZSB0aGlzLl9uZXR3b3JrLmJsb2NrY2hhaW5JRDpcbiAgICAgICAgcmV0dXJuICdQJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBibG9ja2NoYWluSWQ7XG4gICAgfVxuICB9XG59XG4iXX0=