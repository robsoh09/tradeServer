"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilderFactory = void 0;
const avalanchejs_1 = require("@bitgo-forks/avalanchejs");
const sdk_core_1 = require("@bitgo/sdk-core");
const avalanche_1 = require("avalanche");
const evm_1 = require("avalanche/dist/apis/evm");
const platformvm_1 = require("avalanche/dist/apis/platformvm");
const exportInCTxBuilder_1 = require("./exportInCTxBuilder");
const exportTxBuilder_1 = require("./exportTxBuilder");
const importInCTxBuilder_1 = require("./importInCTxBuilder");
const importTxBuilder_1 = require("./importTxBuilder");
const permissionlessValidatorTxBuilder_1 = require("./permissionlessValidatorTxBuilder");
const utils_1 = __importDefault(require("./utils"));
const validatorTxBuilder_1 = require("./validatorTxBuilder");
class TransactionBuilderFactory extends sdk_core_1.BaseTransactionBuilderFactory {
    constructor(_coinConfig) {
        super(_coinConfig);
        this.recoverSigner = false;
    }
    /** @inheritdoc */
    from(raw) {
        var _a;
        utils_1.default.validateRawTransaction(raw);
        let txSource = 'PVM';
        let transactionBuilder = undefined;
        let tx;
        const rawNoHex = utils_1.default.removeHexPrefix(raw);
        try {
            tx = new platformvm_1.Tx();
            // could throw an error if a txType doesn't match.
            tx.fromBuffer(avalanche_1.Buffer.from(rawNoHex, 'hex'));
            if (!utils_1.default.isTransactionOf(tx, this._coinConfig.network.blockchainID)) {
                throw new Error('It is not a transaction of this platformvm old flow');
            }
        }
        catch (e) {
            try {
                txSource = 'EVM';
                tx = new evm_1.Tx();
                tx.fromBuffer(avalanche_1.Buffer.from(rawNoHex, 'hex'));
                if (!utils_1.default.isTransactionOf(tx, this._coinConfig.network.cChainBlockchainID)) {
                    throw new Error('It is not a transaction of this network or C chain EVM');
                }
            }
            catch (e) {
                try {
                    txSource = 'PVM';
                    // this should be the last because other PVM functions are still being detected in the new SDK
                    const manager = avalanchejs_1.utils.getManagerForVM('PVM');
                    const [codec, txBytes] = manager.getCodecFromBuffer(avalanchejs_1.utils.hexToBuffer(raw));
                    const unpackedTx = codec.UnpackPrefix(txBytes);
                    // A signed transaction includes 4 bytes for the number of credentials as an Int type that is not known by the codec
                    // We'll skip those 4 bytes, instead we'll loop until we've parsed all credentials
                    // @see https://docs.avax.network/reference/avalanchego/p-chain/txn-format#signed-transaction-example
                    const credentials = [];
                    let credentialBytes = unpackedTx[1].slice(4);
                    let moreCredentials = true;
                    do {
                        try {
                            const [credential, rest] = codec.UnpackPrefix(credentialBytes);
                            credentials.push(credential);
                            credentialBytes = rest;
                        }
                        catch (e) {
                            moreCredentials = false;
                        }
                    } while (credentialBytes.length > 0 && moreCredentials);
                    const unpacked = codec.UnpackPrefix(txBytes);
                    const permissionlessValidatorTx = unpacked[0];
                    const outputs = permissionlessValidatorTx.baseTx.outputs;
                    const output = outputs[0].output;
                    if (outputs[0].getAssetId() !== this._coinConfig.network.avaxAssetID) {
                        throw new Error('The Asset ID of the output does not match the transaction');
                    }
                    const fromAddresses = output.outputOwners.addrs.map((a) => avalanchejs_1.utils.hexToBuffer(a.toHex()));
                    const addressMaps = fromAddresses.map((a) => new avalanchejs_1.utils.AddressMap([[new avalanchejs_1.Address(a), 0]]));
                    tx = new avalanchejs_1.UnsignedTx(unpacked[0], [], new avalanchejs_1.utils.AddressMaps(addressMaps), credentials);
                }
                catch (e) {
                    throw new Error(`The transaction type is not recognized as an old PVM or old EVM transaction. Additionally, parsing of the new PVM AddPermissionlessValidatorTx type failed: ${e.message}`);
                }
            }
        }
        if (txSource === 'PVM') {
            if (((_a = tx === null || tx === void 0 ? void 0 : tx.tx) === null || _a === void 0 ? void 0 : _a._type) && permissionlessValidatorTxBuilder_1.PermissionlessValidatorTxBuilder.verifyTxType(tx.tx._type)) {
                transactionBuilder = this.getPermissionlessValidatorTxBuilder();
                transactionBuilder.initBuilder(tx);
            }
            else if (validatorTxBuilder_1.ValidatorTxBuilder.verifyTxType(tx.getUnsignedTx().getTransaction())) {
                transactionBuilder = this.getValidatorBuilder();
                transactionBuilder.initBuilder(tx);
            }
            else if (exportTxBuilder_1.ExportTxBuilder.verifyTxType(tx.getUnsignedTx().getTransaction())) {
                transactionBuilder = this.getExportBuilder();
                transactionBuilder.initBuilder(tx);
            }
            else if (importTxBuilder_1.ImportTxBuilder.verifyTxType(tx.getUnsignedTx().getTransaction())) {
                transactionBuilder = this.getImportBuilder();
                transactionBuilder.initBuilder(tx);
            }
        }
        else if (txSource === 'EVM') {
            if (importInCTxBuilder_1.ImportInCTxBuilder.verifyTxType(tx.getUnsignedTx().getTransaction())) {
                transactionBuilder = this.getImportInCBuilder();
                transactionBuilder.initBuilder(tx);
            }
            else if (exportInCTxBuilder_1.ExportInCTxBuilder.verifyTxType(tx.getUnsignedTx().getTransaction())) {
                transactionBuilder = this.getExportInCBuilder();
                transactionBuilder.initBuilder(tx);
            }
        }
        if (transactionBuilder === undefined) {
            throw new sdk_core_1.NotSupported('Transaction cannot be parsed or has an unsupported transaction type');
        }
        return transactionBuilder;
    }
    /** @inheritdoc */
    getTransferBuilder() {
        throw new sdk_core_1.NotSupported('Transfer is not supported in P Chain');
    }
    /**
     * Initialize Validator builder
     *
     * @returns {ValidatorTxBuilder} the builder initialized
     */
    getValidatorBuilder() {
        return new validatorTxBuilder_1.ValidatorTxBuilder(this._coinConfig);
    }
    /**
     * Initialize Permissionless Validator builder
     *
     * @returns {PermissionlessValidatorTxBuilder} the builder initialized
     */
    getPermissionlessValidatorTxBuilder() {
        return new permissionlessValidatorTxBuilder_1.PermissionlessValidatorTxBuilder(this._coinConfig);
    }
    /**
     * Export Cross chain transfer
     *
     * @returns {ExportTxBuilder} the builder initialized
     */
    getExportBuilder() {
        return new exportTxBuilder_1.ExportTxBuilder(this._coinConfig);
    }
    /**
     * Import Cross chain transfer
     *
     * @returns {ImportTxBuilder} the builder initialized
     */
    getImportBuilder() {
        return new importTxBuilder_1.ImportTxBuilder(this._coinConfig);
    }
    /**
     * Import in C chain Cross chain transfer
     *
     * @returns {ImportInCTxBuilder} the builder initialized
     */
    getImportInCBuilder() {
        return new importInCTxBuilder_1.ImportInCTxBuilder(this._coinConfig);
    }
    /**
     * Export in C chain Cross chain transfer
     *
     * @returns {ExportInCTxBuilder} the builder initialized
     */
    getExportInCBuilder() {
        return new exportInCTxBuilder_1.ExportInCTxBuilder(this._coinConfig);
    }
    /** @inheritdoc */
    getWalletInitializationBuilder() {
        throw new sdk_core_1.NotSupported('Wallet initialization is not needed');
    }
}
exports.TransactionBuilderFactory = TransactionBuilderFactory;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwwREFPa0M7QUFDbEMsOENBQThFO0FBRTlFLHlDQUFpRDtBQUNqRCxpREFBc0Q7QUFDdEQsK0RBQTZEO0FBRTdELDZEQUEwRDtBQUMxRCx1REFBb0Q7QUFDcEQsNkRBQTBEO0FBQzFELHVEQUFvRDtBQUNwRCx5RkFBc0Y7QUFFdEYsb0RBQTRCO0FBQzVCLDZEQUEwRDtBQUUxRCxNQUFhLHlCQUEwQixTQUFRLHdDQUE2QjtJQUUxRSxZQUFZLFdBQWlDO1FBQzNDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUZYLGtCQUFhLEdBQUcsS0FBSyxDQUFDO0lBR2hDLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsSUFBSSxDQUFDLEdBQVc7O1FBQ2QsZUFBSyxDQUFDLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2xDLElBQUksUUFBUSxHQUFrQixLQUFLLENBQUM7UUFDcEMsSUFBSSxrQkFBa0IsR0FBa0UsU0FBUyxDQUFDO1FBQ2xHLElBQUksRUFBOEIsQ0FBQztRQUNuQyxNQUFNLFFBQVEsR0FBRyxlQUFLLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzVDLElBQUk7WUFDRixFQUFFLEdBQUcsSUFBSSxlQUFLLEVBQUUsQ0FBQztZQUNqQixrREFBa0Q7WUFDbEQsRUFBRSxDQUFDLFVBQVUsQ0FBQyxrQkFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUVoRCxJQUFJLENBQUMsZUFBSyxDQUFDLGVBQWUsQ0FBQyxFQUFFLEVBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUE0QixDQUFDLFlBQVksQ0FBQyxFQUFFO2dCQUMzRixNQUFNLElBQUksS0FBSyxDQUFD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LENBQUMsV0FBVyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxnQkFBZ0I7UUFDZCxPQUFPLElBQUksaUNBQWUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxtQkFBbUI7UUFDakIsT0FBTyxJQUFJLHVDQUFrQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILG1CQUFtQjtRQUNqQixPQUFPLElBQUksdUNBQWtCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsOEJBQThCO1FBQzVCLE1BQU0sSUFBSSx1QkFBWSxDQUFDLHFDQUFxQyxDQUFDLENBQUM7SUFDaEUsQ0FBQztDQUNGO0FBbktELDhEQW1LQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFkZHJlc3MsXG4gIHV0aWxzIGFzIEF2YXhVdGlscyxcbiAgQ3JlZGVudGlhbCxcbiAgcHZtU2VyaWFsLFxuICBUcmFuc2Zlck91dHB1dCxcbiAgVW5zaWduZWRUeCxcbn0gZnJvbSAnQGJpdGdvLWZvcmtzL2F2YWxhbmNoZWpzJztcbmltcG9ydCB7IEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5LCBOb3RTdXBwb3J0ZWQgfSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgQXZhbGFuY2hlTmV0d29yaywgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IEJ1ZmZlciBhcyBCdWZmZXJBdmF4IH0gZnJvbSAnYXZhbGFuY2hlJztcbmltcG9ydCB7IFR4IGFzIEVWTVR4IH0gZnJvbSAnYXZhbGFuY2hlL2Rpc3QvYXBpcy9ldm0nO1xuaW1wb3J0IHsgVHggYXMgUFZNVHggfSBmcm9tICdhdmFsYW5jaGUvZGlzdC9hcGlzL3BsYXRmb3Jtdm0nO1xuaW1wb3J0IHsgRGVwcmVjYXRlZFRyYW5zYWN0aW9uQnVpbGRlciB9IGZyb20gJy4vZGVwcmVjYXRlZFRyYW5zYWN0aW9uQnVpbGRlcic7XG5pbXBvcnQgeyBFeHBvcnRJbkNUeEJ1aWxkZXIgfSBmcm9tICcuL2V4cG9ydEluQ1R4QnVpbGRlcic7XG5pbXBvcnQgeyBFeHBvcnRUeEJ1aWxkZXIgfSBmcm9tICcuL2V4cG9ydFR4QnVpbGRlcic7XG5pbXBvcnQgeyBJbXBvcnRJbkNUeEJ1aWxkZXIgfSBmcm9tICcuL2ltcG9ydEluQ1R4QnVpbGRlcic7XG5pbXBvcnQgeyBJbXBvcnRUeEJ1aWxkZXIgfSBmcm9tICcuL2ltcG9ydFR4QnVpbGRlcic7XG5pbXBvcnQgeyBQZXJtaXNzaW9ubGVzc1ZhbGlkYXRvclR4QnVpbGRlciB9IGZyb20gJy4vcGVybWlzc2lvbmxlc3NWYWxpZGF0b3JUeEJ1aWxkZXInO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25CdWlsZGVyIH0gZnJvbSAnLi90cmFuc2FjdGlvbkJ1aWxkZXInO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgVmFsaWRhdG9yVHhCdWlsZGVyIH0gZnJvbSAnLi92YWxpZGF0b3JUeEJ1aWxkZXInO1xuXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeSBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5IHtcbiAgcHJvdGVjdGVkIHJlY292ZXJTaWduZXIgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IoX2NvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+KSB7XG4gICAgc3VwZXIoX2NvaW5Db25maWcpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGZyb20ocmF3OiBzdHJpbmcpOiBUcmFuc2FjdGlvbkJ1aWxkZXIgfCBEZXByZWNhdGVkVHJhbnNhY3Rpb25CdWlsZGVyIHtcbiAgICB1dGlscy52YWxpZGF0ZVJhd1RyYW5zYWN0aW9uKHJhdyk7XG4gICAgbGV0IHR4U291cmNlOiAnRVZNJyB8ICdQVk0nID0gJ1BWTSc7XG4gICAgbGV0IHRyYW5zYWN0aW9uQnVpbGRlcjogVHJhbnNhY3Rpb25CdWlsZGVyIHwgRGVwcmVjYXRlZFRyYW5zYWN0aW9uQnVpbGRlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgdHg6IFBWTVR4IHwgRVZNVHggfCBVbnNpZ25lZFR4O1xuICAgIGNvbnN0IHJhd05vSGV4ID0gdXRpbHMucmVtb3ZlSGV4UHJlZml4KHJhdyk7XG4gICAgdHJ5IHtcbiAgICAgIHR4ID0gbmV3IFBWTVR4KCk7XG4gICAgICAvLyBjb3VsZCB0aHJvdyBhbiBlcnJvciBpZiBhIHR4VHlwZSBkb2Vzbid0IG1hdGNoLlxuICAgICAgdHguZnJvbUJ1ZmZlcihCdWZmZXJBdmF4LmZyb20ocmF3Tm9IZXgsICdoZXgnKSk7XG5cbiAgICAgIGlmICghdXRpbHMuaXNUcmFuc2FjdGlvbk9mKHR4LCAodGhpcy5fY29pbkNvbmZpZy5uZXR3b3JrIGFzIEF2YWxhbmNoZU5ldHdvcmspLmJsb2NrY2hhaW5JRCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdCBpcyBub3QgYSB0cmFuc2FjdGlvbiBvZiB0aGlzIHBsYXRmb3Jtdm0gb2xkIGZsb3cnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0eFNvdXJjZSA9ICdFVk0nO1xuICAgICAgICB0eCA9IG5ldyBFVk1UeCgpO1xuICAgICAgICB0eC5mcm9tQnVmZmVyKEJ1ZmZlckF2YXguZnJvbShyYXdOb0hleCwgJ2hleCcpKTtcblxuICAgICAgICBpZiAoIXV0aWxzLmlzVHJhbnNhY3Rpb25PZih0eCwgKHRoaXMuX2NvaW5Db25maWcubmV0d29yayBhcyBBdmFsYW5jaGVOZXR3b3JrKS5jQ2hhaW5CbG9ja2NoYWluSUQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdCBpcyBub3QgYSB0cmFuc2FjdGlvbiBvZiB0aGlzIG5ldHdvcmsgb3IgQyBjaGFpbiBFVk0nKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHR4U291cmNlID0gJ1BWTSc7XG4gICAgICAgICAgLy8gdGhpcyBzaG91bGQgYmUgdGhlIGxhc3QgYmVjYXVzZSBvdGhlciBQVk0gZnVuY3Rpb25zIGFyZSBzdGlsbCBiZWluZyBkZXRlY3RlZCBpbiB0aGUgbmV3IFNES1xuICAgICAgICAgIGNvbnN0IG1hbmFnZXIgPSBBdmF4VXRpbHMuZ2V0TWFuYWdlckZvclZNKCdQVk0nKTtcbiAgICAgICAgICBjb25zdCBbY29kZWMsIHR4Qnl0ZXNdID0gbWFuYWdlci5nZXRDb2RlY0Zyb21CdWZmZXIoQXZheFV0aWxzLmhleFRvQnVmZmVyKHJhdykpO1xuICAgICAgICAgIGNvbnN0IHVucGFja2VkVHggPSBjb2RlYy5VbnBhY2tQcmVmaXg8cHZtU2VyaWFsLkFkZFBlcm1pc3Npb25sZXNzVmFsaWRhdG9yVHg+KHR4Qnl0ZXMpO1xuICAgICAgICAgIC8vIEEgc2lnbmVkIHRyYW5zYWN0aW9uIGluY2x1ZGVzIDQgYnl0ZXMgZm9yIHRoZSBudW1iZXIgb2YgY3JlZGVudGlhbHMgYXMgYW4gSW50IHR5cGUgdGhhdCBpcyBub3Qga25vd24gYnkgdGhlIGNvZGVjXG4gICAgICAgICAgLy8gV2UnbGwgc2tpcCB0aG9zZSA0IGJ5dGVzLCBpbnN0ZWFkIHdlJ2xsIGxvb3AgdW50aWwgd2UndmUgcGFyc2VkIGFsbCBjcmVkZW50aWFsc1xuICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9kb2NzLmF2YXgubmV0d29yay9yZWZlcmVuY2UvYXZhbGFuY2hlZ28vcC1jaGFpbi90eG4tZm9ybWF0I3NpZ25lZC10cmFuc2FjdGlvbi1leGFtcGxlXG4gICAgICAgICAgY29uc3QgY3JlZGVudGlhbHM6IENyZWRlbnRpYWxbXSA9IFtdO1xuICAgICAgICAgIGxldCBjcmVkZW50aWFsQnl0ZXMgPSB1bnBhY2tlZFR4WzFdLnNsaWNlKDQpO1xuICAgICAgICAgIGxldCBtb3JlQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IFtjcmVkZW50aWFsLCByZXN0XSA9IGNvZGVjLlVucGFja1ByZWZpeDxDcmVkZW50aWFsPihjcmVkZW50aWFsQnl0ZXMpO1xuICAgICAgICAgICAgICBjcmVkZW50aWFscy5wdXNoKGNyZWRlbnRpYWwpO1xuICAgICAgICAgICAgICBjcmVkZW50aWFsQnl0ZXMgPSByZXN0O1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBtb3JlQ3JlZGVudGlhbHMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChjcmVkZW50aWFsQnl0ZXMubGVuZ3RoID4gMCAmJiBtb3JlQ3JlZGVudGlhbHMpO1xuXG4gICAgICAgICAgY29uc3QgdW5wYWNrZWQgPSBjb2RlYy5VbnBhY2tQcmVmaXg8cHZtU2VyaWFsLkFkZFBlcm1pc3Npb25sZXNzVmFsaWRhdG9yVHg+KHR4Qnl0ZXMpO1xuICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb25sZXNzVmFsaWRhdG9yVHggPSB1bnBhY2tlZFswXSBhcyBwdm1TZXJpYWwuQWRkUGVybWlzc2lvbmxlc3NWYWxpZGF0b3JUeDtcbiAgICAgICAgICBjb25zdCBvdXRwdXRzID0gcGVybWlzc2lvbmxlc3NWYWxpZGF0b3JUeC5iYXNlVHgub3V0cHV0cztcbiAgICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRzWzBdLm91dHB1dCBhcyBUcmFuc2Zlck91dHB1dDtcbiAgICAgICAgICBpZiAob3V0cHV0c1swXS5nZXRBc3NldElkKCkgIT09ICh0aGlzLl9jb2luQ29uZmlnLm5ldHdvcmsgYXMgQXZhbGFuY2hlTmV0d29yaykuYXZheEFzc2V0SUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIEFzc2V0IElEIG9mIHRoZSBvdXRwdXQgZG9lcyBub3QgbWF0Y2ggdGhlIHRyYW5zYWN0aW9uJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZyb21BZGRyZXNzZXMgPSBvdXRwdXQub3V0cHV0T3duZXJzLmFkZHJzLm1hcCgoYSkgPT4gQXZheFV0aWxzLmhleFRvQnVmZmVyKGEudG9IZXgoKSkpO1xuICAgICAgICAgIGNvbnN0IGFkZHJlc3NNYXBzID0gZnJvbUFkZHJlc3Nlcy5tYXAoKGEpID0+IG5ldyBBdmF4VXRpbHMuQWRkcmVzc01hcChbW25ldyBBZGRyZXNzKGEpLCAwXV0pKTtcbiAgICAgICAgICB0eCA9IG5ldyBVbnNpZ25lZFR4KHVucGFja2VkWzBdLCBbXSwgbmV3IEF2YXhVdGlscy5BZGRyZXNzTWFwcyhhZGRyZXNzTWFwcyksIGNyZWRlbnRpYWxzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBUaGUgdHJhbnNhY3Rpb24gdHlwZSBpcyBub3QgcmVjb2duaXplZCBhcyBhbiBvbGQgUFZNIG9yIG9sZCBFVk0gdHJhbnNhY3Rpb24uIEFkZGl0aW9uYWxseSwgcGFyc2luZyBvZiB0aGUgbmV3IFBWTSBBZGRQZXJtaXNzaW9ubGVzc1ZhbGlkYXRvclR4IHR5cGUgZmFpbGVkOiAke2UubWVzc2FnZX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eFNvdXJjZSA9PT0gJ1BWTScpIHtcbiAgICAgIGlmICgodHggYXMgVW5zaWduZWRUeCk/LnR4Py5fdHlwZSAmJiBQZXJtaXNzaW9ubGVzc1ZhbGlkYXRvclR4QnVpbGRlci52ZXJpZnlUeFR5cGUoKHR4IGFzIFVuc2lnbmVkVHgpLnR4Ll90eXBlKSkge1xuICAgICAgICB0cmFuc2FjdGlvbkJ1aWxkZXIgPSB0aGlzLmdldFBlcm1pc3Npb25sZXNzVmFsaWRhdG9yVHhCdWlsZGVyKCk7XG4gICAgICAgIHRyYW5zYWN0aW9uQnVpbGRlci5pbml0QnVpbGRlcih0eCk7XG4gICAgICB9IGVsc2UgaWYgKFZhbGlkYXRvclR4QnVpbGRlci52ZXJpZnlUeFR5cGUoKHR4IGFzIFBWTVR4KS5nZXRVbnNpZ25lZFR4KCkuZ2V0VHJhbnNhY3Rpb24oKSkpIHtcbiAgICAgICAgdHJhbnNhY3Rpb25CdWlsZGVyID0gdGhpcy5nZXRWYWxpZGF0b3JCdWlsZGVyKCk7XG4gICAgICAgIHRyYW5zYWN0aW9uQnVpbGRlci5pbml0QnVpbGRlcih0eCBhcyBQVk1UeCk7XG4gICAgICB9IGVsc2UgaWYgKEV4cG9ydFR4QnVpbGRlci52ZXJpZnlUeFR5cGUoKHR4IGFzIFBWTVR4KS5nZXRVbnNpZ25lZFR4KCkuZ2V0VHJhbnNhY3Rpb24oKSkpIHtcbiAgICAgICAgdHJhbnNhY3Rpb25CdWlsZGVyID0gdGhpcy5nZXRFeHBvcnRCdWlsZGVyKCk7XG4gICAgICAgIHRyYW5zYWN0aW9uQnVpbGRlci5pbml0QnVpbGRlcih0eCBhcyBQVk1UeCk7XG4gICAgICB9IGVsc2UgaWYgKEltcG9ydFR4QnVpbGRlci52ZXJpZnlUeFR5cGUoKHR4IGFzIFBWTVR4KS5nZXRVbnNpZ25lZFR4KCkuZ2V0VHJhbnNhY3Rpb24oKSkpIHtcbiAgICAgICAgdHJhbnNhY3Rpb25CdWlsZGVyID0gdGhpcy5nZXRJbXBvcnRCdWlsZGVyKCk7XG4gICAgICAgIHRyYW5zYWN0aW9uQnVpbGRlci5pbml0QnVpbGRlcih0eCBhcyBQVk1UeCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eFNvdXJjZSA9PT0gJ0VWTScpIHtcbiAgICAgIGlmIChJbXBvcnRJbkNUeEJ1aWxkZXIudmVyaWZ5VHhUeXBlKCh0eCBhcyBFVk1UeCkuZ2V0VW5zaWduZWRUeCgpLmdldFRyYW5zYWN0aW9uKCkpKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uQnVpbGRlciA9IHRoaXMuZ2V0SW1wb3J0SW5DQnVpbGRlcigpO1xuICAgICAgICB0cmFuc2FjdGlvbkJ1aWxkZXIuaW5pdEJ1aWxkZXIodHggYXMgRVZNVHgpO1xuICAgICAgfSBlbHNlIGlmIChFeHBvcnRJbkNUeEJ1aWxkZXIudmVyaWZ5VHhUeXBlKCh0eCBhcyBFVk1UeCkuZ2V0VW5zaWduZWRUeCgpLmdldFRyYW5zYWN0aW9uKCkpKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uQnVpbGRlciA9IHRoaXMuZ2V0RXhwb3J0SW5DQnVpbGRlcigpO1xuICAgICAgICB0cmFuc2FjdGlvbkJ1aWxkZXIuaW5pdEJ1aWxkZXIodHggYXMgRVZNVHgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb25CdWlsZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQoJ1RyYW5zYWN0aW9uIGNhbm5vdCBiZSBwYXJzZWQgb3IgaGFzIGFuIHVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uQnVpbGRlcjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBnZXRUcmFuc2ZlckJ1aWxkZXIoKTogRGVwcmVjYXRlZFRyYW5zYWN0aW9uQnVpbGRlciB7XG4gICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCgnVHJhbnNmZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBQIENoYWluJyk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBWYWxpZGF0b3IgYnVpbGRlclxuICAgKlxuICAgKiBAcmV0dXJucyB7VmFsaWRhdG9yVHhCdWlsZGVyfSB0aGUgYnVpbGRlciBpbml0aWFsaXplZFxuICAgKi9cbiAgZ2V0VmFsaWRhdG9yQnVpbGRlcigpOiBWYWxpZGF0b3JUeEJ1aWxkZXIge1xuICAgIHJldHVybiBuZXcgVmFsaWRhdG9yVHhCdWlsZGVyKHRoaXMuX2NvaW5Db25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgUGVybWlzc2lvbmxlc3MgVmFsaWRhdG9yIGJ1aWxkZXJcbiAgICpcbiAgICogQHJldHVybnMge1Blcm1pc3Npb25sZXNzVmFsaWRhdG9yVHhCdWlsZGVyfSB0aGUgYnVpbGRlciBpbml0aWFsaXplZFxuICAgKi9cbiAgZ2V0UGVybWlzc2lvbmxlc3NWYWxpZGF0b3JUeEJ1aWxkZXIoKTogUGVybWlzc2lvbmxlc3NWYWxpZGF0b3JUeEJ1aWxkZXIge1xuICAgIHJldHVybiBuZXcgUGVybWlzc2lvbmxlc3NWYWxpZGF0b3JUeEJ1aWxkZXIodGhpcy5fY29pbkNvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogRXhwb3J0IENyb3NzIGNoYWluIHRyYW5zZmVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtFeHBvcnRUeEJ1aWxkZXJ9IHRoZSBidWlsZGVyIGluaXRpYWxpemVkXG4gICAqL1xuICBnZXRFeHBvcnRCdWlsZGVyKCk6IEV4cG9ydFR4QnVpbGRlciB7XG4gICAgcmV0dXJuIG5ldyBFeHBvcnRUeEJ1aWxkZXIodGhpcy5fY29pbkNvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogSW1wb3J0IENyb3NzIGNoYWluIHRyYW5zZmVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtJbXBvcnRUeEJ1aWxkZXJ9IHRoZSBidWlsZGVyIGluaXRpYWxpemVkXG4gICAqL1xuICBnZXRJbXBvcnRCdWlsZGVyKCk6IEltcG9ydFR4QnVpbGRlciB7XG4gICAgcmV0dXJuIG5ldyBJbXBvcnRUeEJ1aWxkZXIodGhpcy5fY29pbkNvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogSW1wb3J0IGluIEMgY2hhaW4gQ3Jvc3MgY2hhaW4gdHJhbnNmZXJcbiAgICpcbiAgICogQHJldHVybnMge0ltcG9ydEluQ1R4QnVpbGRlcn0gdGhlIGJ1aWxkZXIgaW5pdGlhbGl6ZWRcbiAgICovXG4gIGdldEltcG9ydEluQ0J1aWxkZXIoKTogSW1wb3J0SW5DVHhCdWlsZGVyIHtcbiAgICByZXR1cm4gbmV3IEltcG9ydEluQ1R4QnVpbGRlcih0aGlzLl9jb2luQ29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnQgaW4gQyBjaGFpbiBDcm9zcyBjaGFpbiB0cmFuc2ZlclxuICAgKlxuICAgKiBAcmV0dXJucyB7RXhwb3J0SW5DVHhCdWlsZGVyfSB0aGUgYnVpbGRlciBpbml0aWFsaXplZFxuICAgKi9cbiAgZ2V0RXhwb3J0SW5DQnVpbGRlcigpOiBFeHBvcnRJbkNUeEJ1aWxkZXIge1xuICAgIHJldHVybiBuZXcgRXhwb3J0SW5DVHhCdWlsZGVyKHRoaXMuX2NvaW5Db25maWcpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGdldFdhbGxldEluaXRpYWxpemF0aW9uQnVpbGRlcigpOiBEZXByZWNhdGVkVHJhbnNhY3Rpb25CdWlsZGVyIHtcbiAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkKCdXYWxsZXQgaW5pdGlhbGl6YXRpb24gaXMgbm90IG5lZWRlZCcpO1xuICB9XG59XG4iXX0=