"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.utxoToInput = exports.recoverUtxos = exports.deprecatedRecoverUtxos = void 0;
const iface_1 = require("./iface");
const avalanche_1 = require("avalanche");
const utils_1 = __importDefault(require("./utils"));
const sdk_core_1 = require("@bitgo/sdk-core");
/**
 * Inputs can be controlled but outputs get reordered in transactions
 * In order to make sure that the mapping is always correct we create an addressIndex which matches to the appropriate
 * signatureIdx
 * @param {StandardTransferableInput[]} utxos as transaction ins.
 * @returns the list of UTXOs
 */
function deprecatedRecoverUtxos(utxos) {
    return utxos.map((utxo) => {
        const secpInput = utxo.getInput();
        // use the same addressesIndex as existing ones in the inputs
        const addressesIndex = secpInput.getSigIdxs().map((s) => s.toBuffer().readUInt32BE(0));
        return {
            outputID: iface_1.SECP256K1_Transfer_Output,
            outputidx: utils_1.default.outputidxBufferToNumber(utxo.getOutputIdx()),
            txid: utils_1.default.cb58Encode(utxo.getTxID()),
            amount: secpInput.getAmount().toString(),
            threshold: addressesIndex.length,
            addresses: [],
            addressesIndex,
        };
    });
}
exports.deprecatedRecoverUtxos = deprecatedRecoverUtxos;
/**
 * Inputs can be controlled but outputs get reordered in transactions
 * In order to make sure that the mapping is always correct we create an addressIndex which matches to the appropriate
 * signatureIdx
 * @param {avaxSerial.TransferableInput[]} utxos as transaction ins.
 * @returns the list of UTXOs
 */
function recoverUtxos(utxos) {
    return utxos.map((utxo) => {
        const input = utxo.input;
        // use the same addressesIndex as existing ones in the inputs
        const addressesIndex = utxo.sigIndicies();
        return {
            outputID: iface_1.SECP256K1_Transfer_Output,
            outputidx: utxo.utxoID.outputIdx.value().toString(),
            txid: utxo.utxoID.txID.value(),
            amount: input.amount().toString(),
            threshold: addressesIndex.length,
            addresses: [],
            addressesIndex,
        };
    });
}
exports.recoverUtxos = recoverUtxos;
/**
 * Convert Utxos into inputs data. Input Objects changes regarding chains. This method return a plain object to be mapped late in chain input.
 * Sender is a list of owners address and utxo address must contains all of them.
 * Signers is a list of sender cut it in threshold size. Firsts senders are the signers.
 *
 * Output always get reordered we want to make sure we can always add signatures in the correct location.
 * Signatures array store signers address of the expected signature. Tx sign replace the address for the signature.
 * So the location of the signatures is guaranteed.
 *
 * To find the correct location for the signature, we use the output's addresses to create the signatureIdx in the order that we desire
 * 0: user key, 1: hsm key, 2: recovery key
 *
 * @param utxos
 * @param sender array of addresses
 * @param threshold number of signatures required
 * @return {
 *   inputs: InputData[];
 *   amount: BN;
 * } as total amount and inputs with signatures as signers address to be replaced.
 */
function utxoToInput(utxos, sender, threshold = 2) {
    // amount spent so far
    let currentTotal = new avalanche_1.BN(0);
    const inputs = utxos
        .filter((utxo) => utxo && utxo.outputID === iface_1.SECP256K1_Transfer_Output)
        .map((utxo) => {
        // validate the utxos
        const utxoAddresses = utxo.addresses.map((a) => utils_1.default.parseAddress(a));
        const addressesIndex = sender.map((a) => utxoAddresses.findIndex((u) => a.equals(u)));
        // addressesIndex should never have a mismatch
        if (addressesIndex.includes(-1)) {
            throw new sdk_core_1.BuildTransactionError('Addresses are inconsistent: ' + utxo.txid);
        }
        if (utxo.threshold !== threshold) {
            throw new sdk_core_1.BuildTransactionError('Threshold is inconsistent');
        }
        const txidBuf = utils_1.default.cb58Decode(utxo.txid);
        const amount = new avalanche_1.BN(utxo.amount);
        const outputIdx = utils_1.default.outputidxNumberToBuffer(utxo.outputidx);
        currentTotal = currentTotal.add(amount);
        const signers = addressesIndex
            .slice(0, threshold)
            .map((utxoIndex, senderIndex) => ({ utxoIndex, senderIndex }))
            .sort((a, b) => a.utxoIndex - b.utxoIndex);
        const signatures = signers.map(({ senderIndex }) => 
        // TODO(BG-56700):  Improve canSign by check in addresses in empty credentials match signer
        // HSM require empty signature.
        utils_1.default.createSig(senderIndex == 1 ? '' : sender[senderIndex].toString('hex')));
        const signaturesIdx = signers.map(({ utxoIndex }) => utxoIndex);
        return { amount, txidBuf, outputIdx, signaturesIdx, signatures };
    });
    return { inputs, amount: currentTotal };
}
exports.utxoToInput = utxoToInput;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXR4b0VuZ2luZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXR4b0VuZ2luZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxtQ0FBb0U7QUFDcEUseUNBQXFEO0FBRXJELG9EQUE0QjtBQUM1Qiw4Q0FBd0Q7QUFZeEQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0Isc0JBQXNCLENBQUMsS0FBa0M7SUFDdkUsT0FBTyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7UUFDeEIsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBeUIsQ0FBQztRQUV6RCw2REFBNkQ7UUFDN0QsTUFBTSxjQUFjLEdBQWEsU0FBUyxDQUFDLFVBQVUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRWpHLE9BQU87WUFDTCxRQUFRLEVBQUUsaUNBQXlCO1lBQ25DLFNBQVMsRUFBRSxlQUFLLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQzdELElBQUksRUFBRSxlQUFLLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUN0QyxNQUFNLEVBQUUsU0FBUyxDQUFDLFNBQVMsRUFBRSxDQUFDLFFBQVEsRUFBRTtZQUN4QyxTQUFTLEVBQUUsY0FBYyxDQUFDLE1BQU07WUFDaEMsU0FBUyxFQUFFLEVBQUU7WUFDYixjQUFjO1NBQ2YsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQWpCRCx3REFpQkM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixZQUFZLENBQUMsS0FBcUM7SUFDaEUsT0FBTyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7UUFDeEIsTUFBTSxLQUFL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QzNGLCtCQUErQjtRQUMvQixlQUFLLENBQUMsU0FBUyxDQUFDLFdBQVcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUM3RSxDQUFDO1FBQ0YsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsU0FBUyxFQUFFLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRWhFLE9BQU8sRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxhQUFhLEVBQUUsVUFBVSxFQUFFLENBQUM7SUFDbkUsQ0FBQyxDQUFDLENBQUM7SUFFTCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsQ0FBQztBQUMxQyxDQUFDO0FBOUNELGtDQThDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERlY29kZWRVdHhvT2JqLCBTRUNQMjU2SzFfVHJhbnNmZXJfT3V0cHV0IH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBCTiwgQnVmZmVyIGFzIEJ1ZmZlckF2YXggfSBmcm9tICdhdmFsYW5jaGUnO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnYXZhbGFuY2hlL2Rpc3QvY29tbW9uJztcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IEJ1aWxkVHJhbnNhY3Rpb25FcnJvciB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBTdGFuZGFyZEFtb3VudElucHV0LCBTdGFuZGFyZFRyYW5zZmVyYWJsZUlucHV0IH0gZnJvbSAnYXZhbGFuY2hlL2Rpc3QvY29tbW9uL2lucHV0JztcbmltcG9ydCB7IGF2YXhTZXJpYWwgfSBmcm9tICdAYml0Z28tZm9ya3MvYXZhbGFuY2hlanMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElucHV0RGF0YSB7XG4gIGFtb3VudDogQk47XG4gIHR4aWRCdWY6IEJ1ZmZlckF2YXg7XG4gIG91dHB1dElkeDogQnVmZmVyQXZheDtcbiAgc2lnbmF0dXJlc0lkeDogbnVtYmVyW107XG4gIHNpZ25hdHVyZXM6IFNpZ25hdHVyZVtdO1xufVxuXG4vKipcbiAqIElucHV0cyBjYW4gYmUgY29udHJvbGxlZCBidXQgb3V0cHV0cyBnZXQgcmVvcmRlcmVkIGluIHRyYW5zYWN0aW9uc1xuICogSW4gb3JkZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIG1hcHBpbmcgaXMgYWx3YXlzIGNvcnJlY3Qgd2UgY3JlYXRlIGFuIGFkZHJlc3NJbmRleCB3aGljaCBtYXRjaGVzIHRvIHRoZSBhcHByb3ByaWF0ZVxuICogc2lnbmF0dXJlSWR4XG4gKiBAcGFyYW0ge1N0YW5kYXJkVHJhbnNmZXJhYmxlSW5wdXRbXX0gdXR4b3MgYXMgdHJhbnNhY3Rpb24gaW5zLlxuICogQHJldHVybnMgdGhlIGxpc3Qgb2YgVVRYT3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZWRSZWNvdmVyVXR4b3ModXR4b3M6IFN0YW5kYXJkVHJhbnNmZXJhYmxlSW5wdXRbXSk6IERlY29kZWRVdHhvT2JqW10ge1xuICByZXR1cm4gdXR4b3MubWFwKCh1dHhvKSA9PiB7XG4gICAgY29uc3Qgc2VjcElucHV0ID0gdXR4by5nZXRJbnB1dCgpIGFzIFN0YW5kYXJkQW1vdW50SW5wdXQ7XG5cbiAgICAvLyB1c2UgdGhlIHNhbWUgYWRkcmVzc2VzSW5kZXggYXMgZXhpc3Rpbmcgb25lcyBpbiB0aGUgaW5wdXRzXG4gICAgY29uc3QgYWRkcmVzc2VzSW5kZXg6IG51bWJlcltdID0gc2VjcElucHV0LmdldFNpZ0lkeHMoKS5tYXAoKHMpID0+IHMudG9CdWZmZXIoKS5yZWFkVUludDMyQkUoMCkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dElEOiBTRUNQMjU2SzFfVHJhbnNmZXJfT3V0cHV0LFxuICAgICAgb3V0cHV0aWR4OiB1dGlscy5vdXRwdXRpZHhCdWZmZXJUb051bWJlcih1dHhvLmdldE91dHB1dElkeCgpKSxcbiAgICAgIHR4aWQ6IHV0aWxzLmNiNThFbmNvZGUodXR4by5nZXRUeElEKCkpLFxuICAgICAgYW1vdW50OiBzZWNwSW5wdXQuZ2V0QW1vdW50KCkudG9TdHJpbmcoKSxcbiAgICAgIHRocmVzaG9sZDogYWRkcmVzc2VzSW5kZXgubGVuZ3RoLFxuICAgICAgYWRkcmVzc2VzOiBbXSwgLy8gdGhpcyBpcyBlbXB0eSBzaW5jZSB0aGUgaW5wdXRzIGZyb20gZGVzZXJpYWxpemVkIHRyYW5zYWN0aW9uIGRvbid0IGNvbnRhaW4gYWRkcmVzc2VzXG4gICAgICBhZGRyZXNzZXNJbmRleCxcbiAgICB9O1xuICB9KTtcbn1cblxuLyoqXG4gKiBJbnB1dHMgY2FuIGJlIGNvbnRyb2xsZWQgYnV0IG91dHB1dHMgZ2V0IHJlb3JkZXJlZCBpbiB0cmFuc2FjdGlvbnNcbiAqIEluIG9yZGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBtYXBwaW5nIGlzIGFsd2F5cyBjb3JyZWN0IHdlIGNyZWF0ZSBhbiBhZGRyZXNzSW5kZXggd2hpY2ggbWF0Y2hlcyB0byB0aGUgYXBwcm9wcmlhdGVcbiAqIHNpZ25hdHVyZUlkeFxuICogQHBhcmFtIHthdmF4U2VyaWFsLlRyYW5zZmVyYWJsZUlucHV0W119IHV0eG9zIGFzIHRyYW5zYWN0aW9uIGlucy5cbiAqIEByZXR1cm5zIHRoZSBsaXN0IG9mIFVUWE9zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWNvdmVyVXR4b3ModXR4b3M6IGF2YXhTZXJpYWwuVHJhbnNmZXJhYmxlSW5wdXRbXSk6IERlY29kZWRVdHhvT2JqW10ge1xuICByZXR1cm4gdXR4b3MubWFwKCh1dHhvKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSB1dHhvLmlucHV0O1xuXG4gICAgLy8gdXNlIHRoZSBzYW1lIGFkZHJlc3Nlc0luZGV4IGFzIGV4aXN0aW5nIG9uZXMgaW4gdGhlIGlucHV0c1xuICAgIGNvbnN0IGFkZHJlc3Nlc0luZGV4OiBudW1iZXJbXSA9IHV0eG8uc2lnSW5kaWNpZXMoKTtcblxuICAgIHJldHVybiB7XG4gICAgICBvdXRwdXRJRDogU0VDUDI1NksxX1RyYW5zZmVyX091dHB1dCxcbiAgICAgIG91dHB1dGlkeDogdXR4by51dHhvSUQub3V0cHV0SWR4LnZhbHVlKCkudG9TdHJpbmcoKSxcbiAgICAgIHR4aWQ6IHV0eG8udXR4b0lELnR4SUQudmFsdWUoKSxcbiAgICAgIGFtb3VudDogaW5wdXQuYW1vdW50KCkudG9TdHJpbmcoKSxcbiAgICAgIHRocmVzaG9sZDogYWRkcmVzc2VzSW5kZXgubGVuZ3RoLFxuICAgICAgYWRkcmVzc2VzOiBbXSwgLy8gdGhpcyBpcyBlbXB0eSBzaW5jZSB0aGUgaW5wdXRzIGZyb20gZGVzZXJpYWxpemVkIHRyYW5zYWN0aW9uIGRvbid0IGNvbnRhaW4gYWRkcmVzc2VzXG4gICAgICBhZGRyZXNzZXNJbmRleCxcbiAgICB9O1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IFV0eG9zIGludG8gaW5wdXRzIGRhdGEuIElucHV0IE9iamVjdHMgY2hhbmdlcyByZWdhcmRpbmcgY2hhaW5zLiBUaGlzIG1ldGhvZCByZXR1cm4gYSBwbGFpbiBvYmplY3QgdG8gYmUgbWFwcGVkIGxhdGUgaW4gY2hhaW4gaW5wdXQuXG4gKiBTZW5kZXIgaXMgYSBsaXN0IG9mIG93bmVycyBhZGRyZXNzIGFuZCB1dHhvIGFkZHJlc3MgbXVzdCBjb250YWlucyBhbGwgb2YgdGhlbS5cbiAqIFNpZ25lcnMgaXMgYSBsaXN0IG9mIHNlbmRlciBjdXQgaXQgaW4gdGhyZXNob2xkIHNpemUuIEZpcnN0cyBzZW5kZXJzIGFyZSB0aGUgc2lnbmVycy5cbiAqXG4gKiBPdXRwdXQgYWx3YXlzIGdldCByZW9yZGVyZWQgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgY2FuIGFsd2F5cyBhZGQgc2lnbmF0dXJlcyBpbiB0aGUgY29ycmVjdCBsb2NhdGlvbi5cbiAqIFNpZ25hdHVyZXMgYXJyYXkgc3RvcmUgc2lnbmVycyBhZGRyZXNzIG9mIHRoZSBleHBlY3RlZCBzaWduYXR1cmUuIFR4IHNpZ24gcmVwbGFjZSB0aGUgYWRkcmVzcyBmb3IgdGhlIHNpZ25hdHVyZS5cbiAqIFNvIHRoZSBsb2NhdGlvbiBvZiB0aGUgc2lnbmF0dXJlcyBpcyBndWFyYW50ZWVkLlxuICpcbiAqIFRvIGZpbmQgdGhlIGNvcnJlY3QgbG9jYXRpb24gZm9yIHRoZSBzaWduYXR1cmUsIHdlIHVzZSB0aGUgb3V0cHV0J3MgYWRkcmVzc2VzIHRvIGNyZWF0ZSB0aGUgc2lnbmF0dXJlSWR4IGluIHRoZSBvcmRlciB0aGF0IHdlIGRlc2lyZVxuICogMDogdXNlciBrZXksIDE6IGhzbSBrZXksIDI6IHJlY292ZXJ5IGtleVxuICpcbiAqIEBwYXJhbSB1dHhvc1xuICogQHBhcmFtIHNlbmRlciBhcnJheSBvZiBhZGRyZXNzZXNcbiAqIEBwYXJhbSB0aHJlc2hvbGQgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWRcbiAqIEByZXR1cm4ge1xuICogICBpbnB1dHM6IElucHV0RGF0YVtdO1xuICogICBhbW91bnQ6IEJOO1xuICogfSBhcyB0b3RhbCBhbW91bnQgYW5kIGlucHV0cyB3aXRoIHNpZ25hdHVyZXMgYXMgc2lnbmVycyBhZGRyZXNzIHRvIGJlIHJlcGxhY2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXR4b1RvSW5wdXQoXG4gIHV0eG9zOiBEZWNvZGVkVXR4b09ialtdLFxuICBzZW5kZXI6IEJ1ZmZlckF2YXhbXSxcbiAgdGhyZXNob2xkID0gMlxuKToge1xuICBpbnB1dHM6IElucHV0RGF0YVtdO1xuICBhbW91bnQ6IEJOO1xufSB7XG4gIC8vIGFtb3VudCBzcGVudCBzbyBmYXJcbiAgbGV0IGN1cnJlbnRUb3RhbDogQk4gPSBuZXcgQk4oMCk7XG5cbiAgY29uc3QgaW5wdXRzID0gdXR4b3NcbiAgICAuZmlsdGVyKCh1dHhvKSA9PiB1dHhvICYmIHV0eG8ub3V0cHV0SUQgPT09IFNFQ1AyNTZLMV9UcmFuc2Zlcl9PdXRwdXQpXG4gICAgLm1hcCgodXR4bykgPT4ge1xuICAgICAgLy8gdmFsaWRhdGUgdGhlIHV0eG9zXG4gICAgICBjb25zdCB1dHhvQWRkcmVzc2VzOiBCdWZmZXJBdmF4W10gPSB1dHhvLmFkZHJlc3Nlcy5tYXAoKGEpID0+IHV0aWxzLnBhcnNlQWRkcmVzcyhhKSk7XG4gICAgICBjb25zdCBhZGRyZXNzZXNJbmRleCA9IHNlbmRlci5tYXAoKGEpID0+IHV0eG9BZGRyZXNzZXMuZmluZEluZGV4KCh1KSA9PiBhLmVxdWFscyh1KSkpO1xuICAgICAgLy8gYWRkcmVzc2VzSW5kZXggc2hvdWxkIG5ldmVyIGhhdmUgYSBtaXNtYXRjaFxuICAgICAgaWYgKGFkZHJlc3Nlc0luZGV4LmluY2x1ZGVzKC0xKSkge1xuICAgICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdBZGRyZXNzZXMgYXJlIGluY29uc2lzdGVudDogJyArIHV0eG8udHhpZCk7XG4gICAgICB9XG4gICAgICBpZiAodXR4by50aHJlc2hvbGQgIT09IHRocmVzaG9sZCkge1xuICAgICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdUaHJlc2hvbGQgaXMgaW5jb25zaXN0ZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR4aWRCdWY6IEJ1ZmZlckF2YXggPSB1dGlscy5jYjU4RGVjb2RlKHV0eG8udHhpZCk7XG4gICAgICBjb25zdCBhbW91bnQ6IEJOID0gbmV3IEJOKHV0eG8uYW1vdW50KTtcbiAgICAgIGNvbnN0IG91dHB1dElkeDogQnVmZmVyQXZheCA9IHV0aWxzLm91dHB1dGlkeE51bWJlclRvQnVmZmVyKHV0eG8ub3V0cHV0aWR4KTtcblxuICAgICAgY3VycmVudFRvdGFsID0gY3VycmVudFRvdGFsLmFkZChhbW91bnQpO1xuXG4gICAgICBjb25zdCBzaWduZXJzID0gYWRkcmVzc2VzSW5kZXhcbiAgICAgICAgLnNsaWNlKDAsIHRocmVzaG9sZClcbiAgICAgICAgLm1hcCgodXR4b0luZGV4LCBzZW5kZXJJbmRleCkgPT4gKHsgdXR4b0luZGV4LCBzZW5kZXJJbmRleCB9KSlcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEudXR4b0luZGV4IC0gYi51dHhvSW5kZXgpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IHNpZ25lcnMubWFwKCh7IHNlbmRlckluZGV4IH0pID0+XG4gICAgICAgIC8vIFRPRE8oQkctNTY3MDApOiAgSW1wcm92ZSBjYW5TaWduIGJ5IGNoZWNrIGluIGFkZHJlc3NlcyBpbiBlbXB0eSBjcmVkZW50aWFscyBtYXRjaCBzaWduZXJcbiAgICAgICAgLy8gSFNNIHJlcXVpcmUgZW1wdHkgc2lnbmF0dXJlLlxuICAgICAgICB1dGlscy5jcmVhdGVTaWcoc2VuZGVySW5kZXggPT0gMSA/ICcnIDogc2VuZGVyW3NlbmRlckluZGV4XS50b1N0cmluZygnaGV4JykpXG4gICAgICApO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlc0lkeCA9IHNpZ25lcnMubWFwKCh7IHV0eG9JbmRleCB9KSA9PiB1dHhvSW5kZXgpO1xuXG4gICAgICByZXR1cm4geyBhbW91bnQsIHR4aWRCdWYsIG91dHB1dElkeCwgc2lnbmF0dXJlc0lkeCwgc2lnbmF0dXJlcyB9O1xuICAgIH0pO1xuXG4gIHJldHVybiB7IGlucHV0cywgYW1vdW50OiBjdXJyZW50VG90YWwgfTtcbn1cbiJdfQ==