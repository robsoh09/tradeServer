"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyPair = exports.addressFormat = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const create_hash_1 = __importDefault(require("create-hash"));
const safe_buffer_1 = require("safe-buffer");
const avalanche_1 = require("avalanche");
const common_1 = require("avalanche/dist/common");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const crypto_1 = require("crypto");
const utils_1 = __importDefault(require("./utils"));
const DEFAULT_SEED_SIZE_BYTES = 16;
var addressFormat;
(function (addressFormat) {
    addressFormat["testnet"] = "fuji";
    addressFormat["mainnet"] = "avax";
})(addressFormat = exports.addressFormat || (exports.addressFormat = {}));
class KeyPair extends sdk_core_1.Secp256k1ExtendedKeyPair {
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param { KeyPairOptions } source Either a master seed, a private key, or a public key
     */
    constructor(source) {
        super(source);
        if (!source) {
            const seed = (0, crypto_1.randomBytes)(DEFAULT_SEED_SIZE_BYTES);
            this.hdNode = utxo_lib_1.bip32.fromSeed(seed);
        }
        else if ((0, sdk_core_1.isSeed)(source)) {
            this.hdNode = utxo_lib_1.bip32.fromSeed(source.seed);
        }
        else if ((0, sdk_core_1.isPrivateKey)(source)) {
            this.recordKeysFromPrivateKey(source.prv);
        }
        else if ((0, sdk_core_1.isPublicKey)(source)) {
            this.recordKeysFromPublicKey(source.pub);
        }
        else {
            throw new Error('Invalid key pair options');
        }
        if (this.hdNode) {
            this.keyPair = sdk_core_1.Secp256k1ExtendedKeyPair.toKeyPair(this.hdNode);
        }
    }
    /**
     * Build a keypair from a protocol private key or extended private key.
     *
     * @param {string} prv A raw private key
     */
    recordKeysFromPrivateKey(prv) {
        if (prv.startsWith('PrivateKey-')) {
            this.keyPair = utxo_lib_1.ECPair.fromPrivateKey(Buffer.from(utils_1.default.cb58Decode(prv.split('-')[1])));
            return;
        }
        if (!utils_1.default.isValidPrivateKey(prv)) {
            throw new Error('Unsupported private key');
        }
        if ((0, sdk_core_1.isValidXprv)(prv)) {
            this.hdNode = utxo_lib_1.bip32.fromBase58(prv);
        }
        else {
            this.keyPair = utxo_lib_1.ECPair.fromPrivateKey(Buffer.from(prv.slice(0, 64), 'hex'));
        }
    }
    /**
     * Build an ECPair from a protocol public key or extended public key.
     *
     * @param {string} pub A raw public key
     */
    recordKeysFromPublicKey(pub) {
        try {
            if ((0, sdk_core_1.isValidXpub)(pub)) {
                this.hdNode = utxo_lib_1.bip32.fromBase58(pub);
            }
            else {
                this.keyPair = utxo_lib_1.ECPair.fromPublicKey(Buffer.from(pub, 'hex'));
            }
            return;
        }
        catch (e) {
            try {
                this.keyPair = utxo_lib_1.ECPair.fromPublicKey(Buffer.from(utils_1.default.cb58Decode(pub)));
                return;
            }
            catch (e) {
                throw new Error('Unsupported public key');
            }
        }
    }
    /**
     * Default keys format is a pair of Uint8Array keys
     *
     * @returns { DefaultKeys } The keys in the defined format
     */
    getKeys() {
        var _a;
        return {
            pub: this.getPublicKey({ compressed: true }).toString('hex'),
            prv: (_a = this.getPrivateKey()) === null || _a === void 0 ? void 0 : _a.toString('hex'),
        };
    }
    /**
     * Get an Avalanche P-Chain public mainnet address
     *
     * @param {string} format - avalanche hrp - select Mainnet(avax) or Testnet(fuji) for the address
     * @returns {string} The mainnet address derived from the public key
     */
    getAddress(format = 'mainnet') {
        return this.getAvaxPAddress(addressFormat[format]);
    }
    /**
     * Get a public address of public key.
     *
     * @param {string} hrp - select Mainnet(avax) or Testnet(fuji) for the address
     * @returns {string} The address derived from the public key and hrp
     */
    getAvaxPAddress(hrp) {
        const addressBuffer = avalanche_1.Buffer.from(this.getAddressBuffer());
        return utils_1.default.addressToString(hrp, 'P', addressBuffer);
    }
    /**
     * Get an Avalanche P-Chain public mainnet address
     *
     * @returns {Buffer} The address buffer derived from the public key
     */
    getAddressBuffer() {
        const publicKey = avalanche_1.Buffer.from(this.keyPair.publicKey);
        try {
            return Buffer.from(common_1.SECP256k1KeyPair.addressFromPublicKey(publicKey));
        }
        catch (error) {
            return this.getAddressSafeBuffer();
        }
    }
    /**
     * Use the safe Buffer instead of the regular buffer to derive the address buffer. Used in the OVC.
     *
     * @returns {Buffer}
     */
    getAddressSafeBuffer() {
        const publicKeySafe = safe_buffer_1.Buffer.from(this.keyPair.publicKey);
        const sha256 = safe_buffer_1.Buffer.from((0, create_hash_1.default)('sha256').update(publicKeySafe).digest());
        return Buffer.from((0, create_hash_1.default)('ripemd160').update(sha256).digest());
    }
}
exports.KeyPair = KeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIva2V5UGFpci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSw4Q0FTeUI7QUFDekIsOERBQXFDO0FBQ3JDLDZDQUFtRDtBQUNuRCx5Q0FBaUQ7QUFDakQsa0RBQXlEO0FBQ3pELDhDQUFnRDtBQUNoRCxtQ0FBcUM7QUFDckMsb0RBQTRCO0FBRTVCLE1BQU0sdUJBQXVCLEdBQUcsRUFBRSxDQUFDO0FBQ25DLElBQVksYUFHWDtBQUhELFdBQVksYUFBYTtJQUN2QixpQ0FBZ0IsQ0FBQTtJQUNoQixpQ0FBZ0IsQ0FBQTtBQUNsQixDQUFDLEVBSFcsYUFBYSxHQUFiLHFCQUFhLEtBQWIscUJBQWEsUUFHeEI7QUFFRCxNQUFhLE9BQVEsU0FBUSxtQ0FBd0I7SUFDbkQ7Ozs7T0FJRztJQUNILFlBQVksTUFBdUI7UUFDakMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2QsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLE1BQU0sSUFBSSxHQUFHLElBQUEsb0JBQVcsRUFBQyx1QkFBdUIsQ0FBQyxDQUFDO1lBQ2xELElBQUksQ0FBQyxNQUFNLEdBQUcsZ0JBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDcEM7YUFBTSxJQUFJLElBQUEsaUJBQU0sRUFBQyxNQUFNLENBQUMsRUFBRTtZQUN6QixJQUFJLENBQUMsTUFBTSxHQUFHLGdCQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUMzQzthQUFNLElBQUksSUFBQSx1QkFBWSxFQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQy9CLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDM0M7YUFBTSxJQUFJLElBQUEsc0JBQVcsRUFBQyxNQUFNLENBQUMsRUFBRTtZQUM5QixJQUFJLENBQUMsdUJBQXVCLENBQUMsTUFBTSxD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RyxFQUFFLEdBQUcsRUFBRSxhQUFhLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILGdCQUFnQjtRQUNkLE1BQU0sU0FBUyxHQUFHLGtCQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDMUQsSUFBSTtZQUNGLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyx5QkFBZ0IsQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1NBQ3RFO1FBQUMsT0FBTyxLQUFLLEVBQUU7WUFDZCxPQUFPLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1NBQ3BDO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxvQkFBb0I7UUFDbEIsTUFBTSxhQUFhLEdBQUcsb0JBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUM5RCxNQUFNLE1BQU0sR0FBRyxvQkFBVSxDQUFDLElBQUksQ0FBQyxJQUFBLHFCQUFVLEVBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFDcEYsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUEscUJBQVUsRUFBQyxXQUFXLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUN0RSxDQUFDO0NBQ0Y7QUE3SEQsMEJBNkhDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRGVmYXVsdEtleXMsXG4gIGlzUHJpdmF0ZUtleSxcbiAgaXNQdWJsaWNLZXksXG4gIGlzU2VlZCxcbiAgaXNWYWxpZFhwcnYsXG4gIGlzVmFsaWRYcHViLFxuICBLZXlQYWlyT3B0aW9ucyxcbiAgU2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IGNyZWF0ZUhhc2ggZnJvbSAnY3JlYXRlLWhhc2gnO1xuaW1wb3J0IHsgQnVmZmVyIGFzIFNhZmVCdWZmZXIgfSBmcm9tICdzYWZlLWJ1ZmZlcic7XG5pbXBvcnQgeyBCdWZmZXIgYXMgQnVmZmVyQXZheCB9IGZyb20gJ2F2YWxhbmNoZSc7XG5pbXBvcnQgeyBTRUNQMjU2azFLZXlQYWlyIH0gZnJvbSAnYXZhbGFuY2hlL2Rpc3QvY29tbW9uJztcbmltcG9ydCB7IGJpcDMyLCBFQ1BhaXIgfSBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBERUZBVUxUX1NFRURfU0laRV9CWVRFUyA9IDE2O1xuZXhwb3J0IGVudW0gYWRkcmVzc0Zvcm1hdCB7XG4gIHRlc3RuZXQgPSAnZnVqaScsXG4gIG1haW5uZXQgPSAnYXZheCcsXG59XG5cbmV4cG9ydCBjbGFzcyBLZXlQYWlyIGV4dGVuZHMgU2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyIHtcbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci4gQnkgZGVmYXVsdCwgY3JlYXRlcyBhIGtleSBwYWlyIHdpdGggYSByYW5kb20gbWFzdGVyIHNlZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7IEtleVBhaXJPcHRpb25zIH0gc291cmNlIEVpdGhlciBhIG1hc3RlciBzZWVkLCBhIHByaXZhdGUga2V5LCBvciBhIHB1YmxpYyBrZXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZT86IEtleVBhaXJPcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlKTtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgY29uc3Qgc2VlZCA9IHJhbmRvbUJ5dGVzKERFRkFVTFRfU0VFRF9TSVpFX0JZVEVTKTtcbiAgICAgIHRoaXMuaGROb2RlID0gYmlwMzIuZnJvbVNlZWQoc2VlZCk7XG4gICAgfSBlbHNlIGlmIChpc1NlZWQoc291cmNlKSkge1xuICAgICAgdGhpcy5oZE5vZGUgPSBiaXAzMi5mcm9tU2VlZChzb3VyY2Uuc2VlZCk7XG4gICAgfSBlbHNlIGlmIChpc1ByaXZhdGVLZXkoc291cmNlKSkge1xuICAgICAgdGhpcy5yZWNvcmRLZXlzRnJvbVByaXZhdGVLZXkoc291cmNlLnBydik7XG4gICAgfSBlbHNlIGlmIChpc1B1YmxpY0tleShzb3VyY2UpKSB7XG4gICAgICB0aGlzLnJlY29yZEtleXNGcm9tUHVibGljS2V5KHNvdXJjZS5wdWIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IHBhaXIgb3B0aW9ucycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhkTm9kZSkge1xuICAgICAgdGhpcy5rZXlQYWlyID0gU2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyLnRvS2V5UGFpcih0aGlzLmhkTm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEga2V5cGFpciBmcm9tIGEgcHJvdG9jb2wgcHJpdmF0ZSBrZXkgb3IgZXh0ZW5kZWQgcHJpdmF0ZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcnYgQSByYXcgcHJpdmF0ZSBrZXlcbiAgICovXG4gIHJlY29yZEtleXNGcm9tUHJpdmF0ZUtleShwcnY6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmIChwcnYuc3RhcnRzV2l0aCgnUHJpdmF0ZUtleS0nKSkge1xuICAgICAgdGhpcy5rZXlQYWlyID0gRUNQYWlyLmZyb21Qcml2YXRlS2V5KEJ1ZmZlci5mcm9tKHV0aWxzLmNiNThEZWNvZGUocHJ2LnNwbGl0KCctJylbMV0pKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdXRpbHMuaXNWYWxpZFByaXZhdGVLZXkocHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwcml2YXRlIGtleScpO1xuICAgIH1cbiAgICBpZiAoaXNWYWxpZFhwcnYocHJ2KSkge1xuICAgICAgdGhpcy5oZE5vZGUgPSBiaXAzMi5mcm9tQmFzZTU4KHBydik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMua2V5UGFpciA9IEVDUGFpci5mcm9tUHJpdmF0ZUtleShCdWZmZXIuZnJvbShwcnYuc2xpY2UoMCwgNjQpLCAnaGV4JykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhbiBFQ1BhaXIgZnJvbSBhIHByb3RvY29sIHB1YmxpYyBrZXkgb3IgZXh0ZW5kZWQgcHVibGljIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHB1YiBBIHJhdyBwdWJsaWMga2V5XG4gICAqL1xuICByZWNvcmRLZXlzRnJvbVB1YmxpY0tleShwdWI6IHN0cmluZyk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBpZiAoaXNWYWxpZFhwdWIocHViKSkge1xuICAgICAgICB0aGlzLmhkTm9kZSA9IGJpcDMyLmZyb21CYXNlNTgocHViKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMua2V5UGFpciA9IEVDUGFpci5mcm9tUHVibGljS2V5KEJ1ZmZlci5mcm9tKHB1YiwgJ2hleCcpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmtleVBhaXIgPSBFQ1BhaXIuZnJvbVB1YmxpY0tleShCdWZmZXIuZnJvbSh1dGlscy5jYjU4RGVjb2RlKHB1YikpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHB1YmxpYyBrZXknKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBrZXlzIGZvcm1hdCBpcyBhIHBhaXIgb2YgVWludDhBcnJheSBrZXlzXG4gICAqXG4gICAqIEByZXR1cm5zIHsgRGVmYXVsdEtleXMgfSBUaGUga2V5cyBpbiB0aGUgZGVmaW5lZCBmb3JtYXRcbiAgICovXG4gIGdldEtleXMoKTogRGVmYXVsdEtleXMge1xuICAgIHJldHVybiB7XG4gICAgICBwdWI6IHRoaXMuZ2V0UHVibGljS2V5KHsgY29tcHJlc3NlZDogdHJ1ZSB9KS50b1N0cmluZygnaGV4JyksXG4gICAgICBwcnY6IHRoaXMuZ2V0UHJpdmF0ZUtleSgpPy50b1N0cmluZygnaGV4JyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gQXZhbGFuY2hlIFAtQ2hhaW4gcHVibGljIG1haW5uZXQgYWRkcmVzc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IC0gYXZhbGFuY2hlIGhycCAtIHNlbGVjdCBNYWlubmV0KGF2YXgpIG9yIFRlc3RuZXQoZnVqaSkgZm9yIHRoZSBhZGRyZXNzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBtYWlubmV0IGFkZHJlc3MgZGVyaXZlZCBmcm9tIHRoZSBwdWJsaWMga2V5XG4gICAqL1xuICBnZXRBZGRyZXNzKGZvcm1hdCA9ICdtYWlubmV0Jyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXZheFBBZGRyZXNzKGFkZHJlc3NGb3JtYXRbZm9ybWF0XSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHB1YmxpYyBhZGRyZXNzIG9mIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBocnAgLSBzZWxlY3QgTWFpbm5ldChhdmF4KSBvciBUZXN0bmV0KGZ1amkpIGZvciB0aGUgYWRkcmVzc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYWRkcmVzcyBkZXJpdmVkIGZyb20gdGhlIHB1YmxpYyBrZXkgYW5kIGhycFxuICAgKi9cbiAgZ2V0QXZheFBBZGRyZXNzKGhycDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBhZGRyZXNzQnVmZmVyOiBCdWZmZXJBdmF4ID0gQnVmZmVyQXZheC5mcm9tKHRoaXMuZ2V0QWRkcmVzc0J1ZmZlcigpKTtcbiAgICByZXR1cm4gdXRpbHMuYWRkcmVzc1RvU3RyaW5nKGhycCwgJ1AnLCBhZGRyZXNzQnVmZmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gQXZhbGFuY2hlIFAtQ2hhaW4gcHVibGljIG1haW5uZXQgYWRkcmVzc1xuICAgKlxuICAgKiBAcmV0dXJucyB7QnVmZmVyfSBUaGUgYWRkcmVzcyBidWZmZXIgZGVyaXZlZCBmcm9tIHRoZSBwdWJsaWMga2V5XG4gICAqL1xuICBnZXRBZGRyZXNzQnVmZmVyKCk6IEJ1ZmZlciB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gQnVmZmVyQXZheC5mcm9tKHRoaXMua2V5UGFpci5wdWJsaWNLZXkpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oU0VDUDI1NmsxS2V5UGFpci5hZGRyZXNzRnJvbVB1YmxpY0tleShwdWJsaWNLZXkpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QWRkcmVzc1NhZmVCdWZmZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoZSBzYWZlIEJ1ZmZlciBpbnN0ZWFkIG9mIHRoZSByZWd1bGFyIGJ1ZmZlciB0byBkZXJpdmUgdGhlIGFkZHJlc3MgYnVmZmVyLiBVc2VkIGluIHRoZSBPVkMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gICAqL1xuICBnZXRBZGRyZXNzU2FmZUJ1ZmZlcigpOiBCdWZmZXIge1xuICAgIGNvbnN0IHB1YmxpY0tleVNhZmUgPSBTYWZlQnVmZmVyLmZyb20odGhpcy5rZXlQYWlyLnB1YmxpY0tleSk7XG4gICAgY29uc3Qgc2hhMjU2ID0gU2FmZUJ1ZmZlci5mcm9tKGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShwdWJsaWNLZXlTYWZlKS5kaWdlc3QoKSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNyZWF0ZUhhc2goJ3JpcGVtZDE2MCcpLnVwZGF0ZShzaGEyNTYpLmRpZ2VzdCgpKTtcbiAgfVxufVxuIl19