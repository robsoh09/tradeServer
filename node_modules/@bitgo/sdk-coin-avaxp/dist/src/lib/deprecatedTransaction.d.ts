/// <reference types="bn.js" />
/// <reference types="node" />
import { AvalancheNetwork, BaseCoin as CoinConfig } from '@bitgo/statics';
import { BaseKey, BaseTransaction, Entry, TransactionFee, TransactionType } from '@bitgo/sdk-core';
import { KeyPair } from './keyPair';
import { DeprecatedBaseTx, DecodedUtxoObj, TransactionExplanation, DeprecatedTx, TxData } from './iface';
import { BN, Buffer as BufferAvax } from 'avalanche';
import { Credential } from 'avalanche/dist/common';
import { Buffer } from 'buffer';
export declare class DeprecatedTransaction extends BaseTransaction {
    protected _avaxTransaction: DeprecatedTx;
    _type: TransactionType;
    _network: AvalancheNetwork;
    _networkID: number;
    _assetId: BufferAvax;
    _blockchainID: BufferAvax;
    _threshold: number;
    _locktime: BN;
    _fromAddresses: BufferAvax[];
    _rewardAddresses: BufferAvax[];
    _utxos: DecodedUtxoObj[];
    _to: BufferAvax[];
    _fee: Partial<TransactionFee>;
    constructor(coinConfig: Readonly<CoinConfig>);
    get avaxPTransaction(): DeprecatedBaseTx;
    get signature(): string[];
    get credentials(): Credential[];
    get hasCredentials(): boolean;
    /** @inheritdoc */
    canSign({ key }: BaseKey): boolean;
    /**
     * Sign a avaxp transaction and update the transaction hex
     * validator, delegator, import, exports extend baseTx
     * unsignedTx: UnsignedTx = new UnsignedTx(baseTx)  (baseTx = addValidatorTx)
     * const tx: Tx = unsignedTx.sign(keychain) (tx is type standard signed tx)
     * get baseTx then create new unsignedTx then sign
     *
     * @param {KeyPair} keyPair
     */
    sign(keyPair: KeyPair): void;
    /** @inheritdoc */
    /**
     * should be of signedTx doing this with baseTx
     */
    toBroadcastFormat(): string;
    toJson(): TxData;
    setTransaction(tx: DeprecatedTx): void;
    /**
     * Set the transaction type
     *
     * @param {TransactionType} transactionType The transaction type to be set
     */
    setTransactionType(transactionType: TransactionType): void;
    /**
     * Returns the portion of the transaction that needs to be signed in Buffer format.
     * Only needed for coins that support adding signatures directly (e.g. TSS).
     */
    get signablePayload(): Buffer;
    get id(): string;
    get fromAddresses(): string[];
    get rewardAddresses(): string[];
    /**
     * Get the list of outputs. Amounts are expressed in absolute value.
     */
    get outputs(): Entry[];
    /**
     * Get a Transasction Fee.
     */
    get fee(): TransactionFee;
    get changeOutputs(): Entry[];
    get inputs(): Entry[];
    /**
     * Avax wrapper to create signature and return it for credentials
     * @param prv
     * @return hexstring
     */
    createSignature(prv: Buffer): string;
    /** @inheritdoc */
    explainTransaction(): TransactionExplanation;
    /**
     * Check if this transaction is a P chain
     */
    get isTransactionForCChain(): boolean;
    /**
     * get the source chain id or undefined if it's a cross chain transfer.
     */
    get sourceChain(): string | undefined;
    /**
     * get the destinationChain or undefined if it's a cross chain transfer.
     */
    get destinationChain(): string | undefined;
    /**
     * Convert a blockchainId buffer to string and return P or C alias if match of any of that chains.
     * @param {BufferAvax} blockchainIDBuffer
     * @return {string} blocchainID or alias if exists.
     * @private
     */
    private blockchainIDtoAlias;
}
//# sourceMappingURL=deprecatedTransaction.d.ts.map