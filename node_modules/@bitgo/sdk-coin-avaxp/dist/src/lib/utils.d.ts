/// <reference types="node" />
import { Signature as AvaxSignature, TransferableOutput } from '@bitgo-forks/avalanchejs';
import { BaseUtils, Entry } from '@bitgo/sdk-core';
import { AvalancheNetwork } from '@bitgo/statics';
import { Buffer as BufferAvax } from 'avalanche';
import { BaseTx, TransferableOutput as DeprecatedTransferableOutput } from 'avalanche/dist/apis/platformvm';
import { Signature } from 'avalanche/dist/common';
import { Credential } from 'avalanche/dist/common/credentials';
import { NodeIDStringToBuffer } from 'avalanche/dist/utils';
import { DeprecatedOutput, DeprecatedTx, Output } from './iface';
export declare class Utils implements BaseUtils {
    private binTools;
    cb58Decode: (bytes: string | BufferAvax) => BufferAvax;
    cb58Encode: (bytes: BufferAvax) => string;
    stringToBuffer: (str: string) => BufferAvax;
    bufferToString: (buff: BufferAvax) => string;
    NodeIDStringToBuffer: typeof NodeIDStringToBuffer;
    addressToString: (hrp: string, chainid: string, bytes: BufferAvax) => string;
    includeIn(walletAddresses: string[], otxoOutputAddresses: string[]): boolean;
    /**
     * Checks if it is a valid address no illegal characters
     *
     * @param {string} address - address to be validated
     * @returns {boolean} - the validation result
     */
    /** @inheritdoc */
    isValidAddress(address: string | string[]): boolean;
    private isValidAddressRegex;
    /**
     * Checks if it is a valid blockId with length 66 including 0x
     *
     * @param {string} hash - blockId to be validated
     * @returns {boolean} - the validation result
     */
    /** @inheritdoc */
    isValidBlockId(hash: string): boolean;
    /**
     * Checks if the string is a valid protocol public key or
     * extended public key.
     *
     * @param {string} pub - the  public key to be validated
     * @returns {boolean} - the validation result
     */
    isValidPublicKey(pub: string): boolean;
    parseAddress: (pub: string) => BufferAvax;
    /**
     * Returns whether or not the string is a valid protocol private key, or extended
     * private key.
     *
     * The protocol key format is described in the @stacks/transactions npm package, in the
     * createStacksPrivateKey function:
     * https://github.com/blockstack/stacks.js/blob/master/packages/transactions/src/keys.ts#L125
     *
     * @param {string} prv - the private key (or extended private key) to be validated
     * @returns {boolean} - the validation result
     */
    isValidPrivateKey(prv: string): boolean;
    /**
     * Returns whether or not the string is a composed of hex chars only
     *
     * @param {string} maybe - the  string to be validated
     * @returns {boolean} - the validation result
     */
    allHexChars(maybe: string): boolean;
    /** @inheritdoc */
    isValidSignature(signature: string): boolean;
    /** @inheritdoc */
    isValidTransactionId(txId: string): boolean;
    getCredentials(tx: BaseTx): Credential[];
    /**
     * Avaxp wrapper to create signature and return it for credentials using Avalanche's buffer
     * @param network
     * @param message
     * @param prv
     * @return signature
     */
    createSignatureAvaxBuffer(network: AvalancheNetwork, message: BufferAvax, prv: BufferAvax): BufferAvax;
    /**
     * Avaxp wrapper to create signature and return it for credentials
     * @param network
     * @param message
     * @param prv
     * @return signature
     */
    createSignature(network: AvalancheNetwork, message: Buffer, prv: Buffer): Buffer;
    /**
     * Avaxp wrapper to verify signature using Avalanche's buffer
     * @param network
     * @param message
     * @param signature
     * @param prv
     * @return true if it's verify successful
     */
    verifySignatureAvaxBuffer(network: AvalancheNetwork, message: BufferAvax, signature: BufferAvax, prv: BufferAvax): boolean;
    /**
     * Avaxp wrapper to verify signature
     * @param network
     * @param message
     * @param signature
     * @param prv
     * @return true if it's verify successful
     */
    verifySignature(network: AvalancheNetwork, message: Buffer, signature: Buffer, prv: Buffer): boolean;
    createSig(sigHex: string): Signature;
    createNewSig(sigHex: string): AvaxSignature;
    /**
     * Avaxp wrapper to recovery signature using Avalanche's buffer
     * @param network
     * @param message
     * @param signature
     * @return
     */
    recoverySignatureAvaxBuffer(network: AvalancheNetwork, message: BufferAvax, signature: BufferAvax): BufferAvax;
    /**
     * Avaxp wrapper to verify signature
     * @param network
     * @param message
     * @param signature
     * @return true if it's verify successful
     */
    recoverySignature(network: AvalancheNetwork, message: Buffer, signature: Buffer): Buffer;
    sha256(buf: Uint8Array): Buffer;
    /**
     * Check the raw transaction has a valid format in the blockchain context, throw otherwise.
     * It's to reuse in TransactionBuilder and TransactionBuilderFactory
     *
     * @param rawTransaction Transaction as hex string
     */
    validateRawTransaction(rawTransaction: string): void;
    /**
     * Check if tx is for the blockchainId
     *
     * @param {DeprecatedTx} tx
     * @param {string} blockchainId
     * @returns true if tx is for blockchainId
     */
    isTransactionOf(tx: DeprecatedTx, blockchainId: string): boolean;
    /**
     * Check if Output is from PVM.
     * Output could be EVM or PVM output.
     * @param {DeprecatedOutput} output
     * @returns {boolean} output is DeprecatedTransferableOutput
     */
    deprecatedIsTransferableOutput(output: DeprecatedOutput): output is DeprecatedTransferableOutput;
    /**
     * Check if Output is from PVM.
     * Output could be EVM or PVM output.
     * @param {Output} output
     * @returns {boolean} output is TransferableOutput
     */
    isTransferableOutput(output: Output): output is TransferableOutput;
    /**
     * Return a mapper function to that network address representation.
     * @param network required to stringify addresses
     * @return mapper function
     */
    deprecatedMapOutputToEntry(network: AvalancheNetwork): (DeprecatedOutput: any) => Entry;
    /**
     * Return a mapper function to that network address representation.
     * @param network required to stringify addresses
     * @return mapper function
     */
    mapOutputToEntry(network: AvalancheNetwork): (Output: any) => Entry;
    /**
     * remove hex prefix (0x)
     * @param hex string
     * @returns hex without 0x
     */
    removeHexPrefix(hex: string): string;
    /**
     * Outputidx convert from number (as string) to buffer.
     * @param {string} outputidx number
     * @return {BufferAvax} buffer of size 4 with that number value
     */
    outputidxNumberToBuffer(outputidx: string): BufferAvax;
    /**
     * Outputidx buffer to number (as string)
     * @param {BufferAvax} outputidx
     * @return {string} outputidx number
     */
    outputidxBufferToNumber(outputidx: BufferAvax): string;
}
declare const utils: Utils;
export default utils;
//# sourceMappingURL=utils.d.ts.map