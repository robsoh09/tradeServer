"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Shamir = void 0;
const crypto_1 = __importDefault(require("crypto"));
const util_1 = require("../util");
class Shamir {
    constructor(curve) {
        this.curve = curve;
    }
    /**
     * Perform Shamir sharing on the secret `secret` to the degree `threshold - 1` split `numShares`
     * ways. The split secret requires `threshold` shares to be reconstructed.
     *
     * @param secret secret to split
     * @param threshold share threshold required to reconstruct secret
     * @param numShares total number of shares to split secret into
     * @param indices optional indices which can be used while generating the shares
     * @param salt optional salt which could be used while generating the shares
     * @returns Dictionary containing `shares`, a dictionary where each key is an int
     * in the range 1<=x<=numShares representing that share's free term, and `v`, an
     * array of proofs to be shared with all participants.
     */
    split(secret, threshold, numShares, indices, salt = BigInt(0)) {
        let bigIndices;
        if (indices) {
            bigIndices = indices.map((i) => {
                if (i < 1) {
                    throw new Error('Invalid value supplied for indices');
                }
                return BigInt(i);
            });
        }
        else {
            // make range(1, n + 1)
            bigIndices = Array(numShares)
                .fill(null)
                .map((_, i) => BigInt(i + 1));
        }
        if (threshold < 2) {
            throw new Error('Threshold cannot be less than two');
        }
        if (threshold > numShares) {
            throw new Error('Threshold cannot be greater than the total number of shares');
        }
        const coefs = [];
        const v = [];
        for (let ind = 0; ind < threshold - 1; ind++) {
            const coeff = (0, util_1.clamp)((0, util_1.bigIntFromBufferLE)(crypto_1.default.createHmac('sha256', ind.toString(10)).update((0, util_1.bigIntToBufferLE)(secret, 32)).digest()));
            coefs.push(coeff);
            v.unshift(this.curve.basePointMult(coeff));
        }
        coefs.push(secret);
        const shares = {};
        for (let ind = 0; ind < bigIndices.length; ind++) {
            const x = bigIndices[ind];
            let partial = coefs[0];
            for (let other = 1; other < coefs.length; other++) {
                partial = this.curve.scalarAdd(coefs[other], this.curve.scalarMult(partial, x));
            }
            shares[parseInt(x.toString(), 10)] = partial;
        }
        return { shares, v };
    }
    /**
     * Verify a VSS share.
     *
     * @param u Secret share received from other party.
     * @param v Verification values received from other party.
     * @param index Verifier's index.
     * @returns True on success; otherwise throws Error.
     */
    verify(u, v, index) {
        if (v.length < 2) {
            throw new Error('Threshold cannot be less than two');
        }
        if (index < 1) {
            throw new Error('Invalid value supplied for index');
        }
        const i = BigInt(index);
        let x = v[0];
        let t = BigInt(1);
        for (const vsj of v.slice(1)) {
            t = this.curve.scalarMult(t, i);
            const vjt = this.curve.pointMultiply(vsj, t);
            x = this.curve.pointAdd(x, vjt);
        }
        const sigmaG = this.curve.basePointMult(u);
        if (x !== sigmaG) {
            throw new Error('Could not verify share');
        }
        return true;
    }
    /**
     * Reconstitute a secret from a dictionary of shares. The number of shares must
     * be equal to `t` to reconstitute the original secret.
     *
     * @param shares dictionary of shares. each key is the free term of the share
     * @returns secret
     */
    combine(shares) {
        try {
            let s = BigInt(0);
            for (const i in shares) {
                const yi = shares[i];
                const xi = BigInt(i);
                let num = BigInt(1);
                let denum = BigInt(1);
                for (const j in shares) {
                    const xj = BigInt(j);
                    if (xi !== xj) {
                        num = this.curve.scalarMult(num, xj);
                    }
                }
                for (const j in shares) {
                    const xj = BigInt(j);
                    if (xi !== xj) {
                        denum = this.curve.scalarMult(denum, this.curve.scalarSub(xj, xi));
                    }
                }
                const inverted = this.curve.scalarInvert(denum);
                const innerMultiplied = this.curve.scalarMult(num, inverted);
                const multiplied = this.curve.scalarMult(innerMultiplied, yi);
                s = this.curve.scalarAdd(multiplied, s);
            }
            return s;
        }
        catch (error) {
            throw new Error('Failed to combine Shamir shares , ' + error);
        }
    }
}
exports.Shamir = Shamir;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhbWlyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3NoYW1pci9zaGFtaXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsb0RBQTRCO0FBRzVCLGtDQUFzRTtBQUV0RSxNQUFhLE1BQU07SUFHakIsWUFBWSxLQUFnQjtRQUMxQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNyQixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7OztPQVlHO0lBQ0gsS0FBSyxDQUFDLE1BQWMsRUFBRSxTQUFpQixFQUFFLFNBQWlCLEVBQUUsT0FBdUIsRUFBRSxJQUFJLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUNuRyxJQUFJLFVBQXlCLENBQUM7UUFDOUIsSUFBSSxPQUFPLEVBQUU7WUFDWCxVQUFVLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO2dCQUM3QixJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQ1QsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO2lCQUN2RDtnQkFDRCxPQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNuQixDQUFDLENBQUMsQ0FBQztTQUNKO2FBQU07WUFDTCx1QkFBdUI7WUFDdkIsVUFBVSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUM7aUJBQzFCLElBQUksQ0FBQyxJQUFJLENBQUM7aUJBQ1YsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2pDO1FBQ0QsSUFBSSxTQUFTLEdBQUcsQ0FBQyxFQUFFO1lBQ2pCLE1BQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQztTQUN0RDtRQUVELElBQUksU0FBUyxHQUFHLFNBQVMsRUFBRTtZQUN6QixNQUFNLElBQUksS0FBSyxDQUFDLDZEQUE2RCxDQUFD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QUssQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ2hELE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFDN0QsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsZUFBZSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUM5RCxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQ3pDO1lBQ0QsT0FBTyxDQUFDLENBQUM7U0FDVjtRQUFDLE9BQU8sS0FBSyxFQUFFO1lBQ2QsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsR0FBRyxLQUFLLENBQUMsQ0FBQztTQUMvRDtJQUNILENBQUM7Q0FDRjtBQXRJRCx3QkFzSUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBCYXNlQ3VydmUgfSBmcm9tICcuLi9jdXJ2ZXMnO1xuaW1wb3J0IHsgU3BsaXRTZWNyZXQgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGJpZ0ludEZyb21CdWZmZXJMRSwgYmlnSW50VG9CdWZmZXJMRSwgY2xhbXAgfSBmcm9tICcuLi91dGlsJztcblxuZXhwb3J0IGNsYXNzIFNoYW1pciB7XG4gIGN1cnZlOiBCYXNlQ3VydmU7XG5cbiAgY29uc3RydWN0b3IoY3VydmU6IEJhc2VDdXJ2ZSkge1xuICAgIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIFNoYW1pciBzaGFyaW5nIG9uIHRoZSBzZWNyZXQgYHNlY3JldGAgdG8gdGhlIGRlZ3JlZSBgdGhyZXNob2xkIC0gMWAgc3BsaXQgYG51bVNoYXJlc2BcbiAgICogd2F5cy4gVGhlIHNwbGl0IHNlY3JldCByZXF1aXJlcyBgdGhyZXNob2xkYCBzaGFyZXMgdG8gYmUgcmVjb25zdHJ1Y3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHNlY3JldCBzZWNyZXQgdG8gc3BsaXRcbiAgICogQHBhcmFtIHRocmVzaG9sZCBzaGFyZSB0aHJlc2hvbGQgcmVxdWlyZWQgdG8gcmVjb25zdHJ1Y3Qgc2VjcmV0XG4gICAqIEBwYXJhbSBudW1TaGFyZXMgdG90YWwgbnVtYmVyIG9mIHNoYXJlcyB0byBzcGxpdCBzZWNyZXQgaW50b1xuICAgKiBAcGFyYW0gaW5kaWNlcyBvcHRpb25hbCBpbmRpY2VzIHdoaWNoIGNhbiBiZSB1c2VkIHdoaWxlIGdlbmVyYXRpbmcgdGhlIHNoYXJlc1xuICAgKiBAcGFyYW0gc2FsdCBvcHRpb25hbCBzYWx0IHdoaWNoIGNvdWxkIGJlIHVzZWQgd2hpbGUgZ2VuZXJhdGluZyB0aGUgc2hhcmVzXG4gICAqIEByZXR1cm5zIERpY3Rpb25hcnkgY29udGFpbmluZyBgc2hhcmVzYCwgYSBkaWN0aW9uYXJ5IHdoZXJlIGVhY2gga2V5IGlzIGFuIGludFxuICAgKiBpbiB0aGUgcmFuZ2UgMTw9eDw9bnVtU2hhcmVzIHJlcHJlc2VudGluZyB0aGF0IHNoYXJlJ3MgZnJlZSB0ZXJtLCBhbmQgYHZgLCBhblxuICAgKiBhcnJheSBvZiBwcm9vZnMgdG8gYmUgc2hhcmVkIHdpdGggYWxsIHBhcnRpY2lwYW50cy5cbiAgICovXG4gIHNwbGl0KHNlY3JldDogYmlnaW50LCB0aHJlc2hvbGQ6IG51bWJlciwgbnVtU2hhcmVzOiBudW1iZXIsIGluZGljZXM/OiBBcnJheTxudW1iZXI+LCBzYWx0ID0gQmlnSW50KDApKTogU3BsaXRTZWNyZXQge1xuICAgIGxldCBiaWdJbmRpY2VzOiBBcnJheTxiaWdpbnQ+O1xuICAgIGlmIChpbmRpY2VzKSB7XG4gICAgICBiaWdJbmRpY2VzID0gaW5kaWNlcy5tYXAoKGkpID0+IHtcbiAgICAgICAgaWYgKGkgPCAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIHN1cHBsaWVkIGZvciBpbmRpY2VzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ0ludChpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtYWtlIHJhbmdlKDEsIG4gKyAxKVxuICAgICAgYmlnSW5kaWNlcyA9IEFycmF5KG51bVNoYXJlcylcbiAgICAgICAgLmZpbGwobnVsbClcbiAgICAgICAgLm1hcCgoXywgaSkgPT4gQmlnSW50KGkgKyAxKSk7XG4gICAgfVxuICAgIGlmICh0aHJlc2hvbGQgPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RocmVzaG9sZCBjYW5ub3QgYmUgbGVzcyB0aGFuIHR3bycpO1xuICAgIH1cblxuICAgIGlmICh0aHJlc2hvbGQgPiBudW1TaGFyZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhyZXNob2xkIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIHRvdGFsIG51bWJlciBvZiBzaGFyZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb2VmczogYmlnaW50W10gPSBbXTtcbiAgICBjb25zdCB2OiBBcnJheTxiaWdpbnQ+ID0gW107XG4gICAgZm9yIChsZXQgaW5kID0gMDsgaW5kIDwgdGhyZXNob2xkIC0gMTsgaW5kKyspIHtcbiAgICAgIGNvbnN0IGNvZWZmID0gY2xhbXAoXG4gICAgICAgIGJpZ0ludEZyb21CdWZmZXJMRShjcnlwdG8uY3JlYXRlSG1hYygnc2hhMjU2JywgaW5kLnRvU3RyaW5nKDEwKSkudXBkYXRlKGJpZ0ludFRvQnVmZmVyTEUoc2VjcmV0LCAzMikpLmRpZ2VzdCgpKVxuICAgICAgKTtcbiAgICAgIGNvZWZzLnB1c2goY29lZmYpO1xuICAgICAgdi51bnNoaWZ0KHRoaXMuY3VydmUuYmFzZVBvaW50TXVsdChjb2VmZikpO1xuICAgIH1cbiAgICBjb2Vmcy5wdXNoKHNlY3JldCk7XG5cbiAgICBjb25zdCBzaGFyZXM6IFJlY29yZDxudW1iZXIsIGJpZ2ludD4gPSB7fTtcbiAgICBmb3IgKGxldCBpbmQgPSAwOyBpbmQgPCBiaWdJbmRpY2VzLmxlbmd0aDsgaW5kKyspIHtcbiAgICAgIGNvbnN0IHggPSBiaWdJbmRpY2VzW2luZF07XG4gICAgICBsZXQgcGFydGlhbCA9IGNvZWZzWzBdO1xuICAgICAgZm9yIChsZXQgb3RoZXIgPSAxOyBvdGhlciA8IGNvZWZzLmxlbmd0aDsgb3RoZXIrKykge1xuICAgICAgICBwYXJ0aWFsID0gdGhpcy5jdXJ2ZS5zY2FsYXJBZGQoY29lZnNbb3RoZXJdLCB0aGlzLmN1cnZlLnNjYWxhck11bHQocGFydGlhbCwgeCkpO1xuICAgICAgfVxuICAgICAgc2hhcmVzW3BhcnNlSW50KHgudG9TdHJpbmcoKSwgMTApXSA9IHBhcnRpYWw7XG4gICAgfVxuICAgIHJldHVybiB7IHNoYXJlcywgdiB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBhIFZTUyBzaGFyZS5cbiAgICpcbiAgICogQHBhcmFtIHUgU2VjcmV0IHNoYXJlIHJlY2VpdmVkIGZyb20gb3RoZXIgcGFydHkuXG4gICAqIEBwYXJhbSB2IFZlcmlmaWNhdGlvbiB2YWx1ZXMgcmVjZWl2ZWQgZnJvbSBvdGhlciBwYXJ0eS5cbiAgICogQHBhcmFtIGluZGV4IFZlcmlmaWVyJ3MgaW5kZXguXG4gICAqIEByZXR1cm5zIFRydWUgb24gc3VjY2Vzczsgb3RoZXJ3aXNlIHRocm93cyBFcnJvci5cbiAgICovXG4gIHZlcmlmeSh1OiBiaWdpbnQsIHY6IEFycmF5PGJpZ2ludD4sIGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAodi5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RocmVzaG9sZCBjYW5ub3QgYmUgbGVzcyB0aGFuIHR3bycpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgc3VwcGxpZWQgZm9yIGluZGV4Jyk7XG4gICAgfVxuICAgIGNvbnN0IGkgPSBCaWdJbnQoaW5kZXgpO1xuICAgIGxldCB4ID0gdlswXTtcbiAgICBsZXQgdCA9IEJpZ0ludCgxKTtcbiAgICBmb3IgKGNvbnN0IHZzaiBvZiB2LnNsaWNlKDEpKSB7XG4gICAgICB0ID0gdGhpcy5jdXJ2ZS5zY2FsYXJNdWx0KHQsIGkpO1xuICAgICAgY29uc3Qgdmp0ID0gdGhpcy5jdXJ2ZS5wb2ludE11bHRpcGx5KHZzaiwgdCk7XG4gICAgICB4ID0gdGhpcy5jdXJ2ZS5wb2ludEFkZCh4LCB2anQpO1xuICAgIH1cbiAgICBjb25zdCBzaWdtYUcgPSB0aGlzLmN1cnZlLmJhc2VQb2ludE11bHQodSk7XG4gICAgaWYgKHggIT09IHNpZ21hRykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgdmVyaWZ5IHNoYXJlJyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY29uc3RpdHV0ZSBhIHNlY3JldCBmcm9tIGEgZGljdGlvbmFyeSBvZiBzaGFyZXMuIFRoZSBudW1iZXIgb2Ygc2hhcmVzIG11c3RcbiAgICogYmUgZXF1YWwgdG8gYHRgIHRvIHJlY29uc3RpdHV0ZSB0aGUgb3JpZ2luYWwgc2VjcmV0LlxuICAgKlxuICAgKiBAcGFyYW0gc2hhcmVzIGRpY3Rpb25hcnkgb2Ygc2hhcmVzLiBlYWNoIGtleSBpcyB0aGUgZnJlZSB0ZXJtIG9mIHRoZSBzaGFyZVxuICAgKiBAcmV0dXJucyBzZWNyZXRcbiAgICovXG4gIGNvbWJpbmUoc2hhcmVzOiBSZWNvcmQ8bnVtYmVyLCBiaWdpbnQ+KTogYmlnaW50IHtcbiAgICB0cnkge1xuICAgICAgbGV0IHMgPSBCaWdJbnQoMCk7XG4gICAgICBmb3IgKGNvbnN0IGkgaW4gc2hhcmVzKSB7XG4gICAgICAgIGNvbnN0IHlpID0gc2hhcmVzW2ldO1xuICAgICAgICBjb25zdCB4aSA9IEJpZ0ludChpKTtcbiAgICAgICAgbGV0IG51bSA9IEJpZ0ludCgxKTtcbiAgICAgICAgbGV0IGRlbnVtID0gQmlnSW50KDEpO1xuXG4gICAgICAgIGZvciAoY29uc3QgaiBpbiBzaGFyZXMpIHtcbiAgICAgICAgICBjb25zdCB4aiA9IEJpZ0ludChqKTtcbiAgICAgICAgICBpZiAoeGkgIT09IHhqKSB7XG4gICAgICAgICAgICBudW0gPSB0aGlzLmN1cnZlLnNjYWxhck11bHQobnVtLCB4aik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaiBpbiBzaGFyZXMpIHtcbiAgICAgICAgICBjb25zdCB4aiA9IEJpZ0ludChqKTtcbiAgICAgICAgICBpZiAoeGkgIT09IHhqKSB7XG4gICAgICAgICAgICBkZW51bSA9IHRoaXMuY3VydmUuc2NhbGFyTXVsdChkZW51bSwgdGhpcy5jdXJ2ZS5zY2FsYXJTdWIoeGosIHhpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludmVydGVkID0gdGhpcy5jdXJ2ZS5zY2FsYXJJbnZlcnQoZGVudW0pO1xuICAgICAgICBjb25zdCBpbm5lck11bHRpcGxpZWQgPSB0aGlzLmN1cnZlLnNjYWxhck11bHQobnVtLCBpbnZlcnRlZCk7XG4gICAgICAgIGNvbnN0IG11bHRpcGxpZWQgPSB0aGlzLmN1cnZlLnNjYWxhck11bHQoaW5uZXJNdWx0aXBsaWVkLCB5aSk7XG4gICAgICAgIHMgPSB0aGlzLmN1cnZlLnNjYWxhckFkZChtdWx0aXBsaWVkLCBzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb21iaW5lIFNoYW1pciBzaGFyZXMgLCAnICsgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuIl19