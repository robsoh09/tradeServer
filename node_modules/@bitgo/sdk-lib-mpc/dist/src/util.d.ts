/// <reference types="node" />
import { PublicKey } from 'paillier-bigint';
/**
 * Returns a bigint array from a hex string array
 * @param values
 */
export declare function convertHexArrToBigIntArr(values: string[]): bigint[];
/**
 * Returns a hex string array from a bigint array
 * @param values
 * @param hexLength - length to pad each big int number too
 */
export declare function convertBigIntArrToHexArr(values: bigint[], hexLength?: number): string[];
export declare function hexToBigInt(hex: string): bigint;
/**
 * Returns an hex string of the given bigint
 *
 * @param {bigint} bigint - the bigint to be converted to hex
 * @param hexLength
 * @returns {string} - the hex value
 */
export declare function bigIntToHex(bigint: bigint, hexLength?: number): string;
export declare function bigIntToBufferLE(n: bigint, minBytes?: number): Buffer;
export declare function bigIntFromBufferLE(buf: Buffer): bigint;
export declare function bigIntToBufferBE(n: bigint, minBytes?: number): Buffer;
export declare function bigIntFromBufferBE(buf: Buffer): bigint;
export declare function bigIntFromU8ABE(buf: Uint8Array): bigint;
export declare function clamp(u: bigint): bigint;
/**
 * Function get paillier public key simple varient
 * @param {bigint} n
 * @returns {bigint}
 */
export declare function getPaillierPublicKey(n: bigint): PublicKey;
/**
 * Generate a random positive integer co-prime to x
 * @param x
 * @returns {Promise<bigint>}
 */
export declare function randomPositiveCoPrimeTo(x: bigint): Promise<bigint>;
/**
 * Generate a random positive integer coprime less than x with the same bit depth.
 * @param x
 * @returns {Promise<bigint>}
 */
export declare function randomPositiveCoPrimeLessThan(x: bigint): Promise<bigint>;
/**
 * Generate a random number of a given bitlength
 * @param bitlength
 * @returns {Promise<bigint>}
 */
export declare function randomBigInt(bitlength: number): Promise<bigint>;
/**
 * @param seed - used to construct derivation path deterministically
 * @param isMaster - if set, path starts with prefix `m/`
 * @return path `(m/)/999999/a/b` where `a` and `b` are 7-byte pseudorandom numbers based on seed
 */
export declare function getDerivationPath(seed: string, isMaster?: boolean): string;
//# sourceMappingURL=util.d.ts.map