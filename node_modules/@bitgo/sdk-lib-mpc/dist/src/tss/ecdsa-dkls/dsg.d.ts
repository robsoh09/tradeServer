/// <reference types="node" />
import { SignSession } from '@silencelaboratories/dkls-wasm-ll-node';
import { DeserializedBroadcastMessage, DeserializedDklsSignature, DeserializedMessages, DsgState } from './types';
export declare class Dsg {
    protected dsgSession: SignSession | undefined;
    protected dsgSessionBytes: Uint8Array;
    private _signature;
    protected keyShareBytes: Buffer;
    protected messageHash: Buffer;
    protected derivationPath: string;
    protected partyIdx: number;
    protected dsgState: DsgState;
    constructor(keyShare: Buffer, partyIdx: number, derivationPath: string, messageHash: Buffer);
    private _restoreSession;
    private _deserializeState;
    init(): Promise<DeserializedBroadcastMessage>;
    get signature(): DeserializedDklsSignature;
    /**
     * Ends the DSG session by freeing any heap allocations from wasm. Note that the session is freed if a signature is produced.
     */
    endSession(): void;
    /**
     * Proccesses incoming messages to this party in the DKLs DSG protocol and
     * produces messages from this party to other parties for the next round.
     * @param messagesForIthRound - messages to process the current round
     * @returns {DeserializedMessages} - messages to send to other parties for the next round
     */
    handleIncomingMessages(messagesForIthRound: DeserializedMessages): DeserializedMessages;
}
//# sourceMappingURL=dsg.d.ts.map