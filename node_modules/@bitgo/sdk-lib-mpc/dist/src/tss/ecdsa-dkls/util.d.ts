/// <reference types="node" />
/// <reference types="node" />
import { DeserializedDklsSignature, DeserializedMessages, RetrofitData } from './types';
import { Hash } from 'crypto';
import { Dsg } from './dsg';
import { Dkg } from './dkg';
/**
 * Combines partial signatures from parties participating in DSG.
 * @param round4MessagePayloads - round 4 message payloads from participating parties
 * @param rHex - hex representation of the r value in the signature
 * @returns {DeserializedMessages} - messages to send to other parties for the next round
 */
export declare function combinePartialSignatures(round4MessagePayloads: Uint8Array[], rHex: string): DeserializedDklsSignature;
/**
 * Verify a DKLs Signature and serialize it to recid:r:s:publickey format.
 * @param message - message that was signed.
 * @param dklsSignature - R and S values of the ECDSA signature.
 * @param commonKeychain - public key appended to chaincode in hex.
 * @param derivationPath - optional derivation path to derive on the commonkeychain before verification.
 * @param hash - optional hash function to apply on message before verifying. Default is sha256.
 * @param shouldHash - flag to determine whether message should be hashed before verifying.
 * @returns {string} - serialized signature in `recid:r:s:publickey` format
 */
export declare function verifyAndConvertDklsSignature(message: Buffer, dklsSignature: DeserializedDklsSignature, commonKeychain: string, derivationPath?: string, hash?: Hash, shouldHash?: boolean): string;
export declare function executeTillRound(round: number, party1Dsg: Dsg, party2Dsg: Dsg): Promise<DeserializedMessages[] | DeserializedDklsSignature>;
export declare function generateDKGKeyShares(retrofitDataA?: RetrofitData, retrofitDataB?: RetrofitData, retrofitDataC?: RetrofitData): Promise<[Dkg, Dkg, Dkg]>;
export declare function generate2of2KeyShares(retrofitDataA?: RetrofitData, retrofitDataB?: RetrofitData): Promise<[Dkg, Dkg]>;
//# sourceMappingURL=util.d.ts.map