"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encryptAndAuthOutgoingMessages = exports.decryptAndVerifyIncomingMessages = exports.verifySignedData = exports.decryptAndVerifySignedData = exports.encryptAndDetachSignData = exports.detachSignData = void 0;
const pgp = __importStar(require("openpgp"));
/**
 * Detach signs a binary and encodes it in base64
 * @param data binary to encode in base64 and sign
 * @param privateArmor private key to sign with
 */
async function detachSignData(data, privateArmor) {
    const message = await pgp.createMessage({ binary: data });
    const privateKey = await pgp.readPrivateKey({ armoredKey: privateArmor });
    const signature = await pgp.sign({
        message,
        signingKeys: privateKey,
        format: 'armored',
        detached: true,
        config: {
            rejectCurves: new Set(),
            showVersion: false,
            showComment: false,
        },
    });
    return {
        message: data.toString('base64'),
        signature: signature,
    };
}
exports.detachSignData = detachSignData;
/**
 * Encrypts and detach signs a binary
 * @param data binary to encrypt and sign
 * @param publicArmor public key to encrypt with
 * @param privateArmor private key to sign with
 */
async function encryptAndDetachSignData(data, publicArmor, privateArmor) {
    const message = await pgp.createMessage({ binary: data });
    const publicKey = await pgp.readKey({ armoredKey: publicArmor });
    const privateKey = await pgp.readPrivateKey({ armoredKey: privateArmor });
    const encryptedMessage = await pgp.encrypt({
        message,
        encryptionKeys: publicKey,
        format: 'armored',
        config: {
            rejectCurves: new Set(),
            showVersion: false,
            showComment: false,
        },
    });
    const signature = await pgp.sign({
        message,
        signingKeys: privateKey,
        format: 'armored',
        detached: true,
        config: {
            rejectCurves: new Set(),
            showVersion: false,
            showComment: false,
        },
    });
    return {
        encryptedMessage: encryptedMessage,
        signature: signature,
    };
}
exports.encryptAndDetachSignData = encryptAndDetachSignData;
/**
 * Decrypts and verifies signature on a binary
 * @param encryptedAndSignedMessage message to decrypt and verify
 * @param publicArmor public key to verify signature with
 * @param privateArmor private key to decrypt with
 */
async function decryptAndVerifySignedData(encryptedAndSignedMessage, publicArmor, privateArmor) {
    const publicKey = await pgp.readKey({ armoredKey: publicArmor });
    const privateKey = await pgp.readPrivateKey({ armoredKey: privateArmor });
    const decryptedMessage = await pgp.decrypt({
        message: await pgp.readMessage({ armoredMessage: encryptedAndSignedMessage.encryptedMessage }),
        decryptionKeys: [privateKey],
        config: {
            rejectCurves: new Set(),
            showVersion: false,
            showComment: false,
        },
        format: 'binary',
    });
    const verificationResult = await pgp.verify({
        message: await pgp.createMessage({ binary: decryptedMessage.data }),
        signature: await pgp.readSignature({ armoredSignature: encryptedAndSignedMessage.signature }),
        verificationKeys: publicKey,
    });
    await verificationResult.signatures[0].verified;
    return Buffer.from(decryptedMessage.data).toString('base64');
}
exports.decryptAndVerifySignedData = decryptAndVerifySignedData;
/**
 * Verifies signature on a binary (message passed should be encoded in base64).
 * @param signedMessage message to verify
 * @param publicArmor public key to verify signature with
 */
async function verifySignedData(signedMessage, publicArmor) {
    const publicKey = await pgp.readKey({ armoredKey: publicArmor });
    const verificationResult = await pgp.verify({
        message: await pgp.createMessage({ binary: Buffer.from(signedMessage.message, 'base64') }),
        signature: await pgp.readSignature({ armoredSignature: signedMessage.signature }),
        verificationKeys: publicKey,
    });
    try {
        await verificationResult.signatures[0].verified;
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.verifySignedData = verifySignedData;
/**
 * Decrypts and verifies p2p messages + verifies broadcast messages
 * @param messages message to decrypt and verify
 * @param pubVerificationGpgKeys public keys to verify signatures with
 * @param prvDecryptionGpgKeys private keys to decrypt with
 */
async function decryptAndVerifyIncomingMessages(messages, pubVerificationGpgKeys, prvDecryptionGpgKeys) {
    return {
        p2pMessages: await Promise.all(messages.p2pMessages.map(async (m) => {
            const pubGpgKey = pubVerificationGpgKeys.find((k) => k.partyId === m.from);
            const prvGpgKey = prvDecryptionGpgKeys.find((k) => k.partyId === m.to);
            if (!pubGpgKey) {
                throw Error(`No public key provided for sender with ID: ${m.from}`);
            }
            if (!prvGpgKey) {
                throw Error(`No private key provided for recepient with ID: ${m.to}`);
            }
            return {
                to: m.to,
                from: m.from,
                payload: await decryptAndVerifySignedData(m.payload, pubGpgKey.gpgKey, prvGpgKey.gpgKey),
                commitment: m.commitment,
            };
        })),
        broadcastMessages: await Promise.all(messages.broadcastMessages.map(async (m) => {
            const pubGpgKey = pubVerificationGpgKeys.find((k) => k.partyId === m.from);
            if (!pubGpgKey) {
                throw Error(`No public key provided for sender with ID: ${m.from}`);
            }
            if (!(await verifySignedData(m.payload, pubGpgKey.gpgKey))) {
                throw Error(`Failed to authenticate broadcast message from party: ${m.from}`);
            }
            return {
                from: m.from,
                payload: m.payload.message,
            };
        })),
    };
}
exports.decryptAndVerifyIncomingMessages = decryptAndVerifyIncomingMessages;
/**
 * Encrypts and signs p2p messages + signs broadcast messages
 * @param messages messages to encrypt and sign
 * @param pubEncryptionGpgKey public keys to encrypt data to
 * @param prvAuthenticationGpgKey private keys to sign with
 */
async function encryptAndAuthOutgoingMessages(messages, pubEncryptionGpgKeys, prvAuthenticationGpgKeys) {
    return {
        p2pMessages: await Promise.all(messages.p2pMessages.map(async (m) => {
            const pubGpgKey = pubEncryptionGpgKeys.find((k) => k.partyId === m.to);
            const prvGpgKey = prvAuthenticationGpgKeys.find((k) => k.partyId === m.from);
            if (!pubGpgKey) {
                throw Error(`No public key provided for recipient with ID: ${m.to}`);
            }
            if (!prvGpgKey) {
                throw Error(`No private key provided for sender with ID: ${m.from}`);
            }
            return {
                to: m.to,
                from: m.from,
                payload: await encryptAndDetachSignData(Buffer.from(m.payload, 'base64'), pubGpgKey.gpgKey, prvGpgKey.gpgKey),
                commitment: m.commitment,
            };
        })),
        broadcastMessages: await Promise.all(messages.broadcastMessages.map(async (m) => {
            const prvGpgKey = prvAuthenticationGpgKeys.find((k) => k.partyId === m.from);
            if (!prvGpgKey) {
                throw Error(`No private key provided for sender with ID: ${m.from}`);
            }
            return {
                from: m.from,
                payload: await detachSignData(Buffer.from(m.payload, 'base64'), prvGpgKey.gpgKey),
                signatureR: m.signatureR
                    ? {
                        message: m.signatureR,
                        signature: '',
                    }
                    : undefined,
            };
        })),
    };
}
exports.encryptAndAuthOutgoingMessages = encryptAndAuthOutgoingMessages;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbXNMYXllci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy90c3MvZWNkc2EtZGtscy9jb21tc0xheWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsNkNBQStCO0FBRS9COzs7O0dBSUc7QUFDSSxLQUFLLFVBQVUsY0FBYyxDQUFDLElBQVksRUFBRSxZQUFvQjtJQUNyRSxNQUFNLE9BQU8sR0FBRyxNQUFNLEdBQUcsQ0FBQyxhQUFhLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUMxRCxNQUFNLFVBQVUsR0FBRyxNQUFNLEdBQUcsQ0FBQyxjQUFjLENBQUMsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLENBQUMsQ0FBQztJQUMxRSxNQUFNLFNBQVMsR0FBRyxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUM7UUFDL0IsT0FBTztRQUNQLFdBQVcsRUFBRSxVQUFVO1FBQ3ZCLE1BQU0sRUFBRSxTQUFTO1FBQ2pCLFFBQVEsRUFBRSxJQUFJO1FBQ2QsTUFBTSxFQUFFO1lBQ04sWUFBWSxFQUFFLElBQUksR0FBRyxFQUFFO1lBQ3ZCLFdBQVcsRUFBRSxLQUFLO1lBQ2xCLFdBQVcsRUFBRSxLQUFLO1NBQ25CO0tBQ0YsQ0FBQyxDQUFDO0lBQ0gsT0FBTztRQUNMLE9BQU8sRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQztRQUNoQyxTQUFTLEVBQUUsU0FBUztLQUNyQixDQUFDO0FBQ0osQ0FBQztBQWxCRCx3Q0FrQkM7QUFFRDs7Ozs7R0FLRztBQUNJLEtBQUssVUFBVSx3QkFBd0IsQ0FDNUMsSUFBWSxFQUNaLFdBQW1CLEVBQ25CLFlBQW9CO0lBRXBCLE1BQU0sT0FBTyxHQUFHLE1BQU0sR0FBRyxDQUFDLGFBQWEsQ0FBQyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQzFELE1BQU0sU0FBUyxHQUFHLE1B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UUFBUSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDekMsTUFBTSxTQUFTLEdBQUcsd0JBQXdCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM3RSxJQUFJLENBQUMsU0FBUyxFQUFFO2dCQUNkLE1BQU0sS0FBSyxDQUFDLCtDQUErQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQzthQUN0RTtZQUNELE9BQU87Z0JBQ0wsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJO2dCQUNaLE9BQU8sRUFBRSxNQUFNLGNBQWMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQztnQkFDakYsVUFBVSxFQUFFLENBQUMsQ0FBQyxVQUFVO29CQUN0QixDQUFDLENBQUM7d0JBQ0UsT0FBTyxFQUFFLENBQUMsQ0FBQyxVQUFVO3dCQUNyQixTQUFTLEVBQUUsRUFBRTtxQkFDZDtvQkFDSCxDQUFDLENBQUMsU0FBUzthQUNkLENBQUM7UUFDSixDQUFDLENBQUMsQ0FDSDtLQUNGLENBQUM7QUFDSixDQUFDO0FBM0NELHdFQTJDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNlcmlhbGl6ZWRNZXNzYWdlcywgQXV0aEVuY01lc3NhZ2UsIEF1dGhFbmNNZXNzYWdlcywgUGFydHlHcGdLZXksIEF1dGhNZXNzYWdlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgKiBhcyBwZ3AgZnJvbSAnb3BlbnBncCc7XG5cbi8qKlxuICogRGV0YWNoIHNpZ25zIGEgYmluYXJ5IGFuZCBlbmNvZGVzIGl0IGluIGJhc2U2NFxuICogQHBhcmFtIGRhdGEgYmluYXJ5IHRvIGVuY29kZSBpbiBiYXNlNjQgYW5kIHNpZ25cbiAqIEBwYXJhbSBwcml2YXRlQXJtb3IgcHJpdmF0ZSBrZXkgdG8gc2lnbiB3aXRoXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXRhY2hTaWduRGF0YShkYXRhOiBCdWZmZXIsIHByaXZhdGVBcm1vcjogc3RyaW5nKTogUHJvbWlzZTxBdXRoTWVzc2FnZT4ge1xuICBjb25zdCBtZXNzYWdlID0gYXdhaXQgcGdwLmNyZWF0ZU1lc3NhZ2UoeyBiaW5hcnk6IGRhdGEgfSk7XG4gIGNvbnN0IHByaXZhdGVLZXkgPSBhd2FpdCBwZ3AucmVhZFByaXZhdGVLZXkoeyBhcm1vcmVkS2V5OiBwcml2YXRlQXJtb3IgfSk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHBncC5zaWduKHtcbiAgICBtZXNzYWdlLFxuICAgIHNpZ25pbmdLZXlzOiBwcml2YXRlS2V5LFxuICAgIGZvcm1hdDogJ2FybW9yZWQnLFxuICAgIGRldGFjaGVkOiB0cnVlLFxuICAgIGNvbmZpZzoge1xuICAgICAgcmVqZWN0Q3VydmVzOiBuZXcgU2V0KCksXG4gICAgICBzaG93VmVyc2lvbjogZmFsc2UsXG4gICAgICBzaG93Q29tbWVudDogZmFsc2UsXG4gICAgfSxcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogZGF0YS50b1N0cmluZygnYmFzZTY0JyksXG4gICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gIH07XG59XG5cbi8qKlxuICogRW5jcnlwdHMgYW5kIGRldGFjaCBzaWducyBhIGJpbmFyeVxuICogQHBhcmFtIGRhdGEgYmluYXJ5IHRvIGVuY3J5cHQgYW5kIHNpZ25cbiAqIEBwYXJhbSBwdWJsaWNBcm1vciBwdWJsaWMga2V5IHRvIGVuY3J5cHQgd2l0aFxuICogQHBhcmFtIHByaXZhdGVBcm1vciBwcml2YXRlIGtleSB0byBzaWduIHdpdGhcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRBbmREZXRhY2hTaWduRGF0YShcbiAgZGF0YTogQnVmZmVyLFxuICBwdWJsaWNBcm1vcjogc3RyaW5nLFxuICBwcml2YXRlQXJtb3I6IHN0cmluZ1xuKTogUHJvbWlzZTxBdXRoRW5jTWVzc2FnZT4ge1xuICBjb25zdCBtZXNzYWdlID0gYXdhaXQgcGdwLmNyZWF0ZU1lc3NhZ2UoeyBiaW5hcnk6IGRhdGEgfSk7XG4gIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IHBncC5yZWFkS2V5KHsgYXJtb3JlZEtleTogcHVibGljQXJtb3IgfSk7XG4gIGNvbnN0IHByaXZhdGVLZXkgPSBhd2FpdCBwZ3AucmVhZFByaXZhdGVLZXkoeyBhcm1vcmVkS2V5OiBwcml2YXRlQXJtb3IgfSk7XG4gIGNvbnN0IGVuY3J5cHRlZE1lc3NhZ2UgPSBhd2FpdCBwZ3AuZW5jcnlwdCh7XG4gICAgbWVzc2FnZSxcbiAgICBlbmNyeXB0aW9uS2V5czogcHVibGljS2V5LFxuICAgIGZvcm1hdDogJ2FybW9yZWQnLFxuICAgIGNvbmZpZzoge1xuICAgICAgcmVqZWN0Q3VydmVzOiBuZXcgU2V0KCksXG4gICAgICBzaG93VmVyc2lvbjogZmFsc2UsXG4gICAgICBzaG93Q29tbWVudDogZmFsc2UsXG4gICAgfSxcbiAgfSk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHBncC5zaWduKHtcbiAgICBtZXNzYWdlLFxuICAgIHNpZ25pbmdLZXlzOiBwcml2YXRlS2V5LFxuICAgIGZvcm1hdDogJ2FybW9yZWQnLFxuICAgIGRldGFjaGVkOiB0cnVlLFxuICAgIGNvbmZpZzoge1xuICAgICAgcmVqZWN0Q3VydmVzOiBuZXcgU2V0KCksXG4gICAgICBzaG93VmVyc2lvbjogZmFsc2UsXG4gICAgICBzaG93Q29tbWVudDogZmFsc2UsXG4gICAgfSxcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZW5jcnlwdGVkTWVzc2FnZTogZW5jcnlwdGVkTWVzc2FnZSxcbiAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWNyeXB0cyBhbmQgdmVyaWZpZXMgc2lnbmF0dXJlIG9uIGEgYmluYXJ5XG4gKiBAcGFyYW0gZW5jcnlwdGVkQW5kU2lnbmVkTWVzc2FnZSBtZXNzYWdlIHRvIGRlY3J5cHQgYW5kIHZlcmlmeVxuICogQHBhcmFtIHB1YmxpY0FybW9yIHB1YmxpYyBrZXkgdG8gdmVyaWZ5IHNpZ25hdHVyZSB3aXRoXG4gKiBAcGFyYW0gcHJpdmF0ZUFybW9yIHByaXZhdGUga2V5IHRvIGRlY3J5cHQgd2l0aFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVjcnlwdEFuZFZlcmlmeVNpZ25lZERhdGEoXG4gIGVuY3J5cHRlZEFuZFNpZ25lZE1lc3NhZ2U6IEF1dGhFbmNNZXNzYWdlLFxuICBwdWJsaWNBcm1vcjogc3RyaW5nLFxuICBwcml2YXRlQXJtb3I6IHN0cmluZ1xuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgcGdwLnJlYWRLZXkoeyBhcm1vcmVkS2V5OiBwdWJsaWNBcm1vciB9KTtcbiAgY29uc3QgcHJpdmF0ZUtleSA9IGF3YWl0IHBncC5yZWFkUHJpdmF0ZUtleSh7IGFybW9yZWRLZXk6IHByaXZhdGVBcm1vciB9KTtcbiAgY29uc3QgZGVjcnlwdGVkTWVzc2FnZSA9IGF3YWl0IHBncC5kZWNyeXB0KHtcbiAgICBtZXNzYWdlOiBhd2FpdCBwZ3AucmVhZE1lc3NhZ2UoeyBhcm1vcmVkTWVzc2FnZTogZW5jcnlwdGVkQW5kU2lnbmVkTWVzc2FnZS5lbmNyeXB0ZWRNZXNzYWdlIH0pLFxuICAgIGRlY3J5cHRpb25LZXlzOiBbcHJpdmF0ZUtleV0sXG4gICAgY29uZmlnOiB7XG4gICAgICByZWplY3RDdXJ2ZXM6IG5ldyBTZXQoKSxcbiAgICAgIHNob3dWZXJzaW9uOiBmYWxzZSxcbiAgICAgIHNob3dDb21tZW50OiBmYWxzZSxcbiAgICB9LFxuICAgIGZvcm1hdDogJ2JpbmFyeScsXG4gIH0pO1xuICBjb25zdCB2ZXJpZmljYXRpb25SZXN1bHQgPSBhd2FpdCBwZ3AudmVyaWZ5KHtcbiAgICBtZXNzYWdlOiBhd2FpdCBwZ3AuY3JlYXRlTWVzc2FnZSh7IGJpbmFyeTogZGVjcnlwdGVkTWVzc2FnZS5kYXRhIH0pLFxuICAgIHNpZ25hdHVyZTogYXdhaXQgcGdwLnJlYWRTaWduYXR1cmUoeyBhcm1vcmVkU2lnbmF0dXJlOiBlbmNyeXB0ZWRBbmRTaWduZWRNZXNzYWdlLnNpZ25hdHVyZSB9KSxcbiAgICB2ZXJpZmljYXRpb25LZXlzOiBwdWJsaWNLZXksXG4gIH0pO1xuICBhd2FpdCB2ZXJpZmljYXRpb25SZXN1bHQuc2lnbmF0dXJlc1swXS52ZXJpZmllZDtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRlY3J5cHRlZE1lc3NhZ2UuZGF0YSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHNpZ25hdHVyZSBvbiBhIGJpbmFyeSAobWVzc2FnZSBwYXNzZWQgc2hvdWxkIGJlIGVuY29kZWQgaW4gYmFzZTY0KS5cbiAqIEBwYXJhbSBzaWduZWRNZXNzYWdlIG1lc3NhZ2UgdG8gdmVyaWZ5XG4gKiBAcGFyYW0gcHVibGljQXJtb3IgcHVibGljIGtleSB0byB2ZXJpZnkgc2lnbmF0dXJlIHdpdGhcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeVNpZ25lZERhdGEoc2lnbmVkTWVzc2FnZTogQXV0aE1lc3NhZ2UsIHB1YmxpY0FybW9yOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgcGdwLnJlYWRLZXkoeyBhcm1vcmVkS2V5OiBwdWJsaWNBcm1vciB9KTtcbiAgY29uc3QgdmVyaWZpY2F0aW9uUmVzdWx0ID0gYXdhaXQgcGdwLnZlcmlmeSh7XG4gICAgbWVzc2FnZTogYXdhaXQgcGdwLmNyZWF0ZU1lc3NhZ2UoeyBiaW5hcnk6IEJ1ZmZlci5mcm9tKHNpZ25lZE1lc3NhZ2UubWVzc2FnZSwgJ2Jhc2U2NCcpIH0pLFxuICAgIHNpZ25hdHVyZTogYXdhaXQgcGdwLnJlYWRTaWduYXR1cmUoeyBhcm1vcmVkU2lnbmF0dXJlOiBzaWduZWRNZXNzYWdlLnNpZ25hdHVyZSB9KSxcbiAgICB2ZXJpZmljYXRpb25LZXlzOiBwdWJsaWNLZXksXG4gIH0pO1xuICB0cnkge1xuICAgIGF3YWl0IHZlcmlmaWNhdGlvblJlc3VsdC5zaWduYXR1cmVzWzBdLnZlcmlmaWVkO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRGVjcnlwdHMgYW5kIHZlcmlmaWVzIHAycCBtZXNzYWdlcyArIHZlcmlmaWVzIGJyb2FkY2FzdCBtZXNzYWdlc1xuICogQHBhcmFtIG1lc3NhZ2VzIG1lc3NhZ2UgdG8gZGVjcnlwdCBhbmQgdmVyaWZ5XG4gKiBAcGFyYW0gcHViVmVyaWZpY2F0aW9uR3BnS2V5cyBwdWJsaWMga2V5cyB0byB2ZXJpZnkgc2lnbmF0dXJlcyB3aXRoXG4gKiBAcGFyYW0gcHJ2RGVjcnlwdGlvbkdwZ0tleXMgcHJpdmF0ZSBrZXlzIHRvIGRlY3J5cHQgd2l0aFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVjcnlwdEFuZFZlcmlmeUluY29taW5nTWVzc2FnZXMoXG4gIG1lc3NhZ2VzOiBBdXRoRW5jTWVzc2FnZXMsXG4gIHB1YlZlcmlmaWNhdGlvbkdwZ0tleXM6IFBhcnR5R3BnS2V5W10sXG4gIHBydkRlY3J5cHRpb25HcGdLZXlzOiBQYXJ0eUdwZ0tleVtdXG4pOiBQcm9taXNlPFNlcmlhbGl6ZWRNZXNzYWdlcz4ge1xuICByZXR1cm4ge1xuICAgIHAycE1lc3NhZ2VzOiBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIG1lc3NhZ2VzLnAycE1lc3NhZ2VzLm1hcChhc3luYyAobSkgPT4ge1xuICAgICAgICBjb25zdCBwdWJHcGdLZXkgPSBwdWJWZXJpZmljYXRpb25HcGdLZXlzLmZpbmQoKGspID0+IGsucGFydHlJZCA9PT0gbS5mcm9tKTtcbiAgICAgICAgY29uc3QgcHJ2R3BnS2V5ID0gcHJ2RGVjcnlwdGlvbkdwZ0tleXMuZmluZCgoaykgPT4gay5wYXJ0eUlkID09PSBtLnRvKTtcbiAgICAgICAgaWYgKCFwdWJHcGdLZXkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgTm8gcHVibGljIGtleSBwcm92aWRlZCBmb3Igc2VuZGVyIHdpdGggSUQ6ICR7bS5mcm9tfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJ2R3BnS2V5KSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYE5vIHByaXZhdGUga2V5IHByb3ZpZGVkIGZvciByZWNlcGllbnQgd2l0aCBJRDogJHttLnRvfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG86IG0udG8sXG4gICAgICAgICAgZnJvbTogbS5mcm9tLFxuICAgICAgICAgIHBheWxvYWQ6IGF3YWl0IGRlY3J5cHRBbmRWZXJpZnlTaWduZWREYXRhKG0ucGF5bG9hZCwgcHViR3BnS2V5LmdwZ0tleSwgcHJ2R3BnS2V5LmdwZ0tleSksXG4gICAgICAgICAgY29tbWl0bWVudDogbS5jb21taXRtZW50LFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApLFxuICAgIGJyb2FkY2FzdE1lc3NhZ2VzOiBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIG1lc3NhZ2VzLmJyb2FkY2FzdE1lc3NhZ2VzLm1hcChhc3luYyAobSkgPT4ge1xuICAgICAgICBjb25zdCBwdWJHcGdLZXkgPSBwdWJWZXJpZmljYXRpb25HcGdLZXlzLmZpbmQoKGspID0+IGsucGFydHlJZCA9PT0gbS5mcm9tKTtcbiAgICAgICAgaWYgKCFwdWJHcGdLZXkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgTm8gcHVibGljIGtleSBwcm92aWRlZCBmb3Igc2VuZGVyIHdpdGggSUQ6ICR7bS5mcm9tfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGF3YWl0IHZlcmlmeVNpZ25lZERhdGEobS5wYXlsb2FkLCBwdWJHcGdLZXkuZ3BnS2V5KSkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRmFpbGVkIHRvIGF1dGhlbnRpY2F0ZSBicm9hZGNhc3QgbWVzc2FnZSBmcm9tIHBhcnR5OiAke20uZnJvbX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZyb206IG0uZnJvbSxcbiAgICAgICAgICBwYXlsb2FkOiBtLnBheWxvYWQubWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgKSxcbiAgfTtcbn1cblxuLyoqXG4gKiBFbmNyeXB0cyBhbmQgc2lnbnMgcDJwIG1lc3NhZ2VzICsgc2lnbnMgYnJvYWRjYXN0IG1lc3NhZ2VzXG4gKiBAcGFyYW0gbWVzc2FnZXMgbWVzc2FnZXMgdG8gZW5jcnlwdCBhbmQgc2lnblxuICogQHBhcmFtIHB1YkVuY3J5cHRpb25HcGdLZXkgcHVibGljIGtleXMgdG8gZW5jcnlwdCBkYXRhIHRvXG4gKiBAcGFyYW0gcHJ2QXV0aGVudGljYXRpb25HcGdLZXkgcHJpdmF0ZSBrZXlzIHRvIHNpZ24gd2l0aFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdEFuZEF1dGhPdXRnb2luZ01lc3NhZ2VzKFxuICBtZXNzYWdlczogU2VyaWFsaXplZE1lc3NhZ2VzLFxuICBwdWJFbmNyeXB0aW9uR3BnS2V5czogUGFydHlHcGdLZXlbXSxcbiAgcHJ2QXV0aGVudGljYXRpb25HcGdLZXlzOiBQYXJ0eUdwZ0tleVtdXG4pOiBQcm9taXNlPEF1dGhFbmNNZXNzYWdlcz4ge1xuICByZXR1cm4ge1xuICAgIHAycE1lc3NhZ2VzOiBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIG1lc3NhZ2VzLnAycE1lc3NhZ2VzLm1hcChhc3luYyAobSkgPT4ge1xuICAgICAgICBjb25zdCBwdWJHcGdLZXkgPSBwdWJFbmNyeXB0aW9uR3BnS2V5cy5maW5kKChrKSA9PiBrLnBhcnR5SWQgPT09IG0udG8pO1xuICAgICAgICBjb25zdCBwcnZHcGdLZXkgPSBwcnZBdXRoZW50aWNhdGlvbkdwZ0tleXMuZmluZCgoaykgPT4gay5wYXJ0eUlkID09PSBtLmZyb20pO1xuICAgICAgICBpZiAoIXB1YkdwZ0tleSkge1xuICAgICAgICAgIHRocm93IEVycm9yKGBObyBwdWJsaWMga2V5IHByb3ZpZGVkIGZvciByZWNpcGllbnQgd2l0aCBJRDogJHttLnRvfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJ2R3BnS2V5KSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYE5vIHByaXZhdGUga2V5IHByb3ZpZGVkIGZvciBzZW5kZXIgd2l0aCBJRDogJHttLmZyb219YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0bzogbS50byxcbiAgICAgICAgICBmcm9tOiBtLmZyb20sXG4gICAgICAgICAgcGF5bG9hZDogYXdhaXQgZW5jcnlwdEFuZERldGFjaFNpZ25EYXRhKEJ1ZmZlci5mcm9tKG0ucGF5bG9hZCwgJ2Jhc2U2NCcpLCBwdWJHcGdLZXkuZ3BnS2V5LCBwcnZHcGdLZXkuZ3BnS2V5KSxcbiAgICAgICAgICBjb21taXRtZW50OiBtLmNvbW1pdG1lbnQsXG4gICAgICAgIH07XG4gICAgICB9KVxuICAgICksXG4gICAgYnJvYWRjYXN0TWVzc2FnZXM6IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgbWVzc2FnZXMuYnJvYWRjYXN0TWVzc2FnZXMubWFwKGFzeW5jIChtKSA9PiB7XG4gICAgICAgIGNvbnN0IHBydkdwZ0tleSA9IHBydkF1dGhlbnRpY2F0aW9uR3BnS2V5cy5maW5kKChrKSA9PiBrLnBhcnR5SWQgPT09IG0uZnJvbSk7XG4gICAgICAgIGlmICghcHJ2R3BnS2V5KSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYE5vIHByaXZhdGUga2V5IHByb3ZpZGVkIGZvciBzZW5kZXIgd2l0aCBJRDogJHttLmZyb219YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmcm9tOiBtLmZyb20sXG4gICAgICAgICAgcGF5bG9hZDogYXdhaXQgZGV0YWNoU2lnbkRhdGEoQnVmZmVyLmZyb20obS5wYXlsb2FkLCAnYmFzZTY0JyksIHBydkdwZ0tleS5ncGdLZXkpLFxuICAgICAgICAgIHNpZ25hdHVyZVI6IG0uc2lnbmF0dXJlUlxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbS5zaWduYXR1cmVSLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJycsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApLFxuICB9O1xufVxuIl19