import { BaseCurve } from '../../curves';
import { PublicKey } from 'paillier-bigint';
import { DeserializedNtilde, DeserializedNtildeProof, RangeProof, RangeProofWithCheck, DeserializedNtildeWithProofs } from './types';
/**
 * Generate "challenge" values for range proofs.
 * @param {number} bitlength The bit length of the modulus to generate. This should
 * be the same as the bit length of the paillier public keys used for MtA.
 * @returns {DeserializedNtilde} The generated Ntilde values.
 */
export declare function generateNtilde(bitlength?: number): Promise<DeserializedNtildeWithProofs>;
/**
 * Generate iterations of Ntilde, h1, h2 discrete log proofs.
 * @param {DeserializedNtilde} ntilde Ntilde, h1, h2 to generate the proofs for.
 * @param {bigint} x Either alpha or beta depending on whether it is a discrete log proof of
 * h1 w.r.t h2 or h2 w.r.t h1.
 * @param {bigint} q1 The Sophie Germain prime associated with the first safe prime p1 used to generate Ntilde.
 * @param {bigint} q2 The Sophie Germain prime associated with the second safe prime p2 used to generate Ntilde.
 * @returns {NtildeProof} The generated Ntilde Proofs.
 */
export declare function generateNtildeProof(ntilde: DeserializedNtilde, x: bigint, q1: bigint, q2: bigint): Promise<DeserializedNtildeProof>;
/**
 * Verify discrete log proofs of h1 and h2 mod Ntilde.
 * @param {DeserializedNtilde} ntilde Ntilde, h1, h2 to generate the proofs for.
 * @param {DeserializedNtildeProof} ntildeProof Ntilde Proofs
 * @returns {boolean} true if proof is verified, false otherwise.
 */
export declare function verifyNtildeProof(ntilde: DeserializedNtilde, ntildeProof: DeserializedNtildeProof): Promise<boolean>;
/**
 * Generate a zero-knowledge range proof that an encrypted value is "small".
 * @param {BaseCurve} curve An elliptic curve to use for group operations.
 * @param {number} modulusBits The bit count of the prover's public key.
 * @param {PublicKey} pk The prover's public key.
 * @param {DeserializedNtilde} ntilde The verifier's Ntilde values.
 * @param {bigint} c The ciphertext.
 * @param {bigint} m The plaintext.
 * @param {bigint} r The obfuscation value used to encrypt m.
 * @returns {RangeProof} The generated proof.
 */
export declare function prove(curve: BaseCurve, modulusBits: number, pk: PublicKey, ntilde: DeserializedNtilde, c: bigint, m: bigint, r: bigint): Promise<RangeProof>;
/**
 * Verify a zero-knowledge range proof that an encrypted value is "small".
 * @param {BaseCurve} curve An elliptic curve to use for group operations.
 * @param {number} modulusBits The bit count of the prover's public key.
 * @param {PublicKey} pk The prover's public key.
 * @param {DeserializedNtilde} ntilde The verifier's Ntilde values.
 * @param {RangeProof} proof The range proof.
 * @param {bigint} c The ciphertext.
 * @returns {boolean} True if verification succeeds.
 */
export declare function verify(curve: BaseCurve, modulusBits: number, pk: PublicKey, ntilde: DeserializedNtilde, proof: RangeProof, c: bigint): boolean;
/**
 * Generate a zero-knowledge range proof that a homomorphically manipulated value is "small".
 * @param {BaseCurve} curve An elliptic curve to use for group operations.
 * @param {number} modulusBits The bit count of the prover's public key.
 * @param {PublicKey} pk The prover's public key.
 * @param {DeserializedNtilde} ntilde The verifier's Ntilde values.
 * @param {bigint} c1 The original ciphertext.
 * @param {bigint} c2 The manipulated ciphertext.
 * @param {bigint} x The plaintext value multiplied by the original plaintext.
 * @param {bigint} y The plaintext value that is added to x.
 * @param {bigint} r The obfuscation value used to encrypt x.
 * @param {bigint} X The curve's base point raised to x.
 * @returns {RangeProofWithCheck} The generated proof.
 */
export declare function proveWithCheck(curve: BaseCurve, modulusBits: number, pk: PublicKey, ntilde: DeserializedNtilde, c1: bigint, c2: bigint, x: bigint, y: bigint, r: bigint, X: bigint): Promise<RangeProofWithCheck>;
/**
 * Verify a zero-knowledge range proof that a homomorphically manipulated value is "small".
 * @param {BaseCurve} curve An elliptic curve to use for group operations.
 * @param {number} modulusBits The bit count of the prover's public key.
 * @param {PublicKey} pk The prover's public key.
 * @param {DeserializedNtilde} ntilde The verifier's Ntilde values.
 * @param {RangeProofWithCheck} proof The range proof.
 * @param {bigint} c1 The original ciphertext.
 * @param {bigint} c2 The manipulated ciphertext.
 * @param {bigint} X The curve's base point raised to x.
 * @returns {boolean} True if verification succeeds.
 */
export declare function verifyWithCheck(curve: BaseCurve, modulusBits: number, pk: PublicKey, ntilde: DeserializedNtilde, proof: RangeProofWithCheck, c1: bigint, c2: bigint, X: bigint): boolean;
//# sourceMappingURL=rangeproof.d.ts.map