"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyWithCheck = exports.proveWithCheck = exports.verify = exports.prove = exports.verifyNtildeProof = exports.generateNtildeProof = exports.generateNtilde = void 0;
/**
 * Zero Knowledge Range Proofs as described in (Two-party generation of DSA signatures)[1].
 * [1]: https://reitermk.github.io/papers/2004/IJIS.pdf
 */
const crypto_1 = require("crypto");
const bigint_crypto_utils_1 = require("bigint-crypto-utils");
const bigint_mod_arith_1 = require("bigint-mod-arith");
const util_1 = require("../../util");
const index_1 = require("./index");
const safePrime_1 = require("../../safePrime");
// 128 as recommend by https://blog.verichains.io/p/vsa-2022-120-multichain-key-extraction.
const ITERATIONS = 128;
async function generateModulus(bitlength = index_1.minModulusBitLength, retry = 10) {
    if (bitlength < index_1.minModulusBitLength) {
        // https://www.keylength.com/en/6/
        // eslint-disable-next-line no-console
        console.warn('Generating a modulus with less than 3072 is not recommended!');
    }
    const bitlengthP = Math.floor(bitlength / 2);
    const bitlengthQ = bitlength - bitlengthP;
    for (let i = 0; i < retry; i++) {
        const [p, q] = await (0, safePrime_1.generateSafePrimes)([bitlengthP, bitlengthQ]);
        const n = p * q;
        // For large bit lengths, the probability of generating a modulus with the wrong bit length is very low.
        if ((0, bigint_crypto_utils_1.bitLength)(n) !== bitlength) {
            continue;
        }
        return { n, q1: (p - BigInt(1)) / BigInt(2), q2: (q - BigInt(1)) / BigInt(2) };
    }
    throw new Error(`Unable to generate modulus with bit length of ${bitlength} after ${retry} tries. Please try again or reach out to support@bitgo.com`);
}
/**
 * Generate "challenge" values for range proofs.
 * @param {number} bitlength The bit length of the modulus to generate. This should
 * be the same as the bit length of the paillier public keys used for MtA.
 * @returns {DeserializedNtilde} The generated Ntilde values.
 */
async function generateNtilde(bitlength = index_1.minModulusBitLength) {
    const { n: ntilde, q1, q2 } = await generateModulus(bitlength);
    const [f1, f2] = await Promise.all([(0, util_1.randomPositiveCoPrimeTo)(ntilde), (0, util_1.randomPositiveCoPrimeTo)(ntilde)]);
    const h1 = (0, bigint_mod_arith_1.modPow)(f1, BigInt(2), ntilde);
    const h2 = (0, bigint_mod_arith_1.modPow)(h1, f2, ntilde);
    const beta = (0, bigint_mod_arith_1.modInv)(f2, q1 * q2);
    const [h1wrtH2Proofs, h2wrtH1Proofs] = await Promise.all([
        generateNtildeProof({
            h1: h1,
            h2: h2,
            ntilde: ntilde,
        }, f2, q1, q2),
        generateNtildeProof({
            h1: h2,
            h2: h1,
            ntilde: ntilde,
        }, beta, q1, q2),
    ]);
    return {
        ntilde,
        h1,
        h2,
        ntildeProof: {
            h1WrtH2: {
                alpha: h1wrtH2Proofs.alpha,
                t: h1wrtH2Proofs.t,
            },
            h2WrtH1: {
                alpha: h2wrtH1Proofs.alpha,
                t: h2wrtH1Proofs.t,
            },
        },
    };
}
exports.generateNtilde = generateNtilde;
/**
 * Generate iterations of Ntilde, h1, h2 discrete log proofs.
 * @param {DeserializedNtilde} ntilde Ntilde, h1, h2 to generate the proofs for.
 * @param {bigint} x Either alpha or beta depending on whether it is a discrete log proof of
 * h1 w.r.t h2 or h2 w.r.t h1.
 * @param {bigint} q1 The Sophie Germain prime associated with the first safe prime p1 used to generate Ntilde.
 * @param {bigint} q2 The Sophie Germain prime associated with the second safe prime p2 used to generate Ntilde.
 * @returns {NtildeProof} The generated Ntilde Proofs.
 */
async function generateNtildeProof(ntilde, x, q1, q2) {
    const q1MulQ2 = q1 * q2;
    const a = [];
    const alpha = [];
    let msgToHash = Buffer.concat([
        (0, util_1.bigIntToBufferBE)(ntilde.h1),
        (0, util_1.bigIntToBufferBE)(ntilde.h2),
        (0, util_1.bigIntToBufferBE)(ntilde.ntilde),
    ]);
    for (let i = 0; i < ITERATIONS; i++) {
        a.push((0, bigint_crypto_utils_1.randBetween)(q1MulQ2));
        alpha.push((0, bigint_mod_arith_1.modPow)(ntilde.h1, a[i], ntilde.ntilde));
        msgToHash = Buffer.concat([msgToHash, (0, util_1.bigIntToBufferBE)(alpha[i], Math.ceil((0, bigint_crypto_utils_1.bitLength)(ntilde.ntilde) / 8))]);
    }
    const simulatedResponse = (0, crypto_1.createHash)('sha256').update(msgToHash).digest();
    const t = [];
    for (let i = 0; i < ITERATIONS; i++) {
        // Get the ith bit from a buffer of bytes.
        const ithBit = (simulatedResponse[Math.floor(i / 8)] >> (7 - (i % 8))) & 1;
        t.push((a[i] + ((BigInt(ithBit) * x) % q1MulQ2)) % q1MulQ2);
    }
    return { alpha, t };
}
exports.generateNtildeProof = generateNtildeProof;
/**
 * Verify discrete log proofs of h1 and h2 mod Ntilde.
 * @param {DeserializedNtilde} ntilde Ntilde, h1, h2 to generate the proofs for.
 * @param {DeserializedNtildeProof} ntildeProof Ntilde Proofs
 * @returns {boolean} true if proof is verified, false otherwise.
 */
async function verifyNtildeProof(ntilde, ntildeProof) {
    const h1ModNtilde = ntilde.h1 % ntilde.ntilde;
    const h2ModNtilde = ntilde.h2 % ntilde.ntilde;
    if (h1ModNtilde === BigInt(0) || h2ModNtilde === BigInt(0)) {
        return false;
    }
    if (h1ModNtilde === BigInt(1) || h2ModNtilde === BigInt(1)) {
        return false;
    }
    if (h1ModNtilde === h2ModNtilde) {
        return false;
    }
    if (ntildeProof.alpha.length > 256 ||
        ntildeProof.alpha.length !== ITERATIONS ||
        ntildeProof.t.length !== ITERATIONS) {
        return false;
    }
    let msgToHash = Buffer.concat([
        (0, util_1.bigIntToBufferBE)(ntilde.h1),
        (0, util_1.bigIntToBufferBE)(ntilde.h2),
        (0, util_1.bigIntToBufferBE)(ntilde.ntilde),
    ]);
    for (let i = 0; i < ntildeProof.alpha.length; i++) {
        msgToHash = Buffer.concat([
            msgToHash,
            (0, util_1.bigIntToBufferBE)(ntildeProof.alpha[i], Math.ceil((0, bigint_crypto_utils_1.bitLength)(ntilde.ntilde) / 8)),
        ]);
    }
    const simulatedResponse = (0, crypto_1.createHash)('sha256').update(msgToHash).digest();
    for (let i = 0; i < ntildeProof.alpha.length; i++) {
        // Get the ith bit from a buffer of bytes.
        const ithBit = (simulatedResponse[Math.floor(i / 8)] >> (7 - (i % 8))) & 1;
        const h1PowTi = (0, bigint_mod_arith_1.modPow)(ntilde.h1, ntildeProof.t[i], ntilde.ntilde);
        const h2PowCi = (0, bigint_mod_arith_1.modPow)(ntilde.h2, BigInt(ithBit), ntilde.ntilde);
        const alphaMulh2PowCi = (ntildeProof.alpha[i] * h2PowCi) % ntilde.ntilde;
        if (h1PowTi !== alphaMulh2PowCi) {
            return false;
        }
    }
    return true;
}
exports.verifyNtildeProof = verifyNtildeProof;
/**
 * Generate a zero-knowledge range proof that an encrypted value is "small".
 * @param {BaseCurve} curve An elliptic curve to use for group operations.
 * @param {number} modulusBits The bit count of the prover's public key.
 * @param {PublicKey} pk The prover's public key.
 * @param {DeserializedNtilde} ntilde The verifier's Ntilde values.
 * @param {bigint} c The ciphertext.
 * @param {bigint} m The plaintext.
 * @param {bigint} r The obfuscation value used to encrypt m.
 * @returns {RangeProof} The generated proof.
 */
async function prove(curve, modulusBits, pk, ntilde, c, m, r) {
    const modulusBytes = Math.floor((modulusBits + 7) / 8);
    const q = curve.order();
    const q3 = q ** BigInt(3);
    const qntilde = q * ntilde.ntilde;
    const q3ntilde = q3 * ntilde.ntilde;
    const alpha = (0, bigint_crypto_utils_1.randBetween)(q3);
    const beta = await (0, util_1.randomPositiveCoPrimeTo)(pk.n);
    const gamma = (0, bigint_crypto_utils_1.randBetween)(q3ntilde);
    const rho = (0, bigint_crypto_utils_1.randBetween)(qntilde);
    const z = ((0, bigint_mod_arith_1.modPow)(ntilde.h1, m, ntilde.ntilde) * (0, bigint_mod_arith_1.modPow)(ntilde.h2, rho, ntilde.ntilde)) % ntilde.ntilde;
    const u = ((0, bigint_mod_arith_1.modPow)(pk.g, alpha, pk._n2) * (0, bigint_mod_arith_1.modPow)(beta, pk.n, pk._n2)) % pk._n2;
    const w = ((0, bigint_mod_arith_1.modPow)(ntilde.h1, alpha, ntilde.ntilde) * (0, bigint_mod_arith_1.modPow)(ntilde.h2, gamma, ntilde.ntilde)) % ntilde.ntilde;
    const hash = (0, crypto_1.createHash)('sha256');
    hash.update('\x06\x00\x00\x00\x00\x00\x00\x00');
    hash.update((0, util_1.bigIntToBufferBE)(pk.n, modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(pk.g, modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(c, 2 * modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(z, modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(u, 2 * modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(w, modulusBytes));
    hash.update('$');
    const e = (0, util_1.bigIntFromBufferBE)(hash.digest()) % q;
    const s = ((0, bigint_mod_arith_1.modPow)(r, e, pk.n) * beta) % pk.n;
    const s1 = e * m + alpha;
    const s2 = e * rho + gamma;
    return { z, u, w, s, s1, s2 };
}
exports.prove = prove;
/**
 * Verify a zero-knowledge range proof that an encrypted value is "small".
 * @param {BaseCurve} curve An elliptic curve to use for group operations.
 * @param {number} modulusBits The bit count of the prover's public key.
 * @param {PublicKey} pk The prover's public key.
 * @param {DeserializedNtilde} ntilde The verifier's Ntilde values.
 * @param {RangeProof} proof The range proof.
 * @param {bigint} c The ciphertext.
 * @returns {boolean} True if verification succeeds.
 */
function verify(curve, modulusBits, pk, ntilde, proof, c) {
    if (proof.u === BigInt(0) || proof.s === BigInt(0)) {
        return false;
    }
    const modulusBytes = Math.floor((modulusBits + 7) / 8);
    const q = curve.order();
    const q3 = q ** BigInt(3);
    if (proof.s1 > q3) {
        return false;
    }
    const hash = (0, crypto_1.createHash)('sha256');
    hash.update('\x06\x00\x00\x00\x00\x00\x00\x00');
    hash.update((0, util_1.bigIntToBufferBE)(pk.n, modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(pk.g, modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(c, 2 * modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(proof.z, modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(proof.u, 2 * modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(proof.w, modulusBytes));
    hash.update('$');
    const e = (0, util_1.bigIntFromBufferBE)(hash.digest()) % q;
    let products;
    products = ((0, bigint_mod_arith_1.modPow)(pk.g, proof.s1, pk._n2) * (0, bigint_mod_arith_1.modPow)(proof.s, pk.n, pk._n2) * (0, bigint_mod_arith_1.modPow)(c, -e, pk._n2)) % pk._n2;
    if (proof.u !== products) {
        return false;
    }
    products =
        ((((0, bigint_mod_arith_1.modPow)(ntilde.h1, proof.s1, ntilde.ntilde) * (0, bigint_mod_arith_1.modPow)(ntilde.h2, proof.s2, ntilde.ntilde)) % ntilde.ntilde) *
            (0, bigint_mod_arith_1.modPow)(proof.z, -e, ntilde.ntilde)) %
            ntilde.ntilde;
    return proof.w === products;
}
exports.verify = verify;
/**
 * Generate a zero-knowledge range proof that a homomorphically manipulated value is "small".
 * @param {BaseCurve} curve An elliptic curve to use for group operations.
 * @param {number} modulusBits The bit count of the prover's public key.
 * @param {PublicKey} pk The prover's public key.
 * @param {DeserializedNtilde} ntilde The verifier's Ntilde values.
 * @param {bigint} c1 The original ciphertext.
 * @param {bigint} c2 The manipulated ciphertext.
 * @param {bigint} x The plaintext value multiplied by the original plaintext.
 * @param {bigint} y The plaintext value that is added to x.
 * @param {bigint} r The obfuscation value used to encrypt x.
 * @param {bigint} X The curve's base point raised to x.
 * @returns {RangeProofWithCheck} The generated proof.
 */
async function proveWithCheck(curve, modulusBits, pk, ntilde, c1, c2, x, y, r, X) {
    const modulusBytes = Math.floor((modulusBits + 7) / 8);
    const q = curve.order();
    const q3 = q ** BigInt(3);
    const q7 = q ** BigInt(7);
    const qntilde = q * ntilde.ntilde;
    const q3ntilde = q3 * ntilde.ntilde;
    const alpha = (0, bigint_crypto_utils_1.randBetween)(q3);
    const rho = (0, bigint_crypto_utils_1.randBetween)(qntilde);
    const sigma = (0, bigint_crypto_utils_1.randBetween)(qntilde);
    const tau = (0, bigint_crypto_utils_1.randBetween)(q3ntilde);
    const rhoprm = (0, bigint_crypto_utils_1.randBetween)(q3ntilde);
    const beta = await (0, util_1.randomPositiveCoPrimeTo)(pk.n);
    const gamma = (0, bigint_crypto_utils_1.randBetween)(q7);
    const u = curve.basePointMult(curve.scalarReduce(alpha));
    const z = ((0, bigint_mod_arith_1.modPow)(ntilde.h1, x, ntilde.ntilde) * (0, bigint_mod_arith_1.modPow)(ntilde.h2, rho, ntilde.ntilde)) % ntilde.ntilde;
    const zprm = ((0, bigint_mod_arith_1.modPow)(ntilde.h1, alpha, ntilde.ntilde) * (0, bigint_mod_arith_1.modPow)(ntilde.h2, rhoprm, ntilde.ntilde)) % ntilde.ntilde;
    const t = ((0, bigint_mod_arith_1.modPow)(ntilde.h1, y, ntilde.ntilde) * (0, bigint_mod_arith_1.modPow)(ntilde.h2, sigma, ntilde.ntilde)) % ntilde.ntilde;
    const v = ((((0, bigint_mod_arith_1.modPow)(c1, alpha, pk._n2) * (0, bigint_mod_arith_1.modPow)(pk.g, gamma, pk._n2)) % pk._n2) * (0, bigint_mod_arith_1.modPow)(beta, pk.n, pk._n2)) % pk._n2;
    const w = ((0, bigint_mod_arith_1.modPow)(ntilde.h1, gamma, ntilde.ntilde) * (0, bigint_mod_arith_1.modPow)(ntilde.h2, tau, ntilde.ntilde)) % ntilde.ntilde;
    const hash = (0, crypto_1.createHash)('sha256');
    hash.update('\x0d\x00\x00\x00\x00\x00\x00\x00');
    hash.update((0, util_1.bigIntToBufferBE)(pk.n, modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(pk.g, modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(X, 33));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(c1, 2 * modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(c2, 2 * modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(u, 33));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(z, modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(zprm, modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(t, modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(v, 2 * modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(w, modulusBytes));
    hash.update('$');
    const e = (0, util_1.bigIntFromBufferBE)(hash.digest()) % q;
    const s = ((0, bigint_mod_arith_1.modPow)(r, e, pk.n) * beta) % pk.n;
    const s1 = e * x + alpha;
    const s2 = e * rho + rhoprm;
    const t1 = e * y + gamma;
    const t2 = e * sigma + tau;
    return { z, zprm, t, v, w, s, s1, s2, t1, t2, u };
}
exports.proveWithCheck = proveWithCheck;
/**
 * Verify a zero-knowledge range proof that a homomorphically manipulated value is "small".
 * @param {BaseCurve} curve An elliptic curve to use for group operations.
 * @param {number} modulusBits The bit count of the prover's public key.
 * @param {PublicKey} pk The prover's public key.
 * @param {DeserializedNtilde} ntilde The verifier's Ntilde values.
 * @param {RangeProofWithCheck} proof The range proof.
 * @param {bigint} c1 The original ciphertext.
 * @param {bigint} c2 The manipulated ciphertext.
 * @param {bigint} X The curve's base point raised to x.
 * @returns {boolean} True if verification succeeds.
 */
function verifyWithCheck(curve, modulusBits, pk, ntilde, proof, c1, c2, X) {
    const modulusBytes = Math.floor((modulusBits + 7) / 8);
    const q = curve.order();
    const q3 = q ** BigInt(3);
    const q7 = q ** BigInt(7);
    if (proof.s1 > q3) {
        return false;
    }
    if (proof.t1 > q7) {
        return false;
    }
    const hash = (0, crypto_1.createHash)('sha256');
    hash.update('\x0d\x00\x00\x00\x00\x00\x00\x00');
    hash.update((0, util_1.bigIntToBufferBE)(pk.n, modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(pk.g, modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(X, 33));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(c1, 2 * modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(c2, 2 * modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(proof.u, 33));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(proof.z, modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(proof.zprm, modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(proof.t, modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(proof.v, 2 * modulusBytes));
    hash.update('$');
    hash.update((0, util_1.bigIntToBufferBE)(proof.w, modulusBytes));
    hash.update('$');
    const e = (0, util_1.bigIntFromBufferBE)(hash.digest()) % q;
    const gS1 = curve.basePointMult(curve.scalarReduce(proof.s1));
    const xEU = curve.pointAdd(curve.pointMultiply(X, e), proof.u);
    if (gS1 !== xEU) {
        return false;
    }
    let left, right;
    const h1ExpS1 = (0, bigint_mod_arith_1.modPow)(ntilde.h1, proof.s1, ntilde.ntilde);
    const h2ExpS2 = (0, bigint_mod_arith_1.modPow)(ntilde.h2, proof.s2, ntilde.ntilde);
    left = (h1ExpS1 * h2ExpS2) % ntilde.ntilde;
    const zExpE = (0, bigint_mod_arith_1.modPow)(proof.z, e, ntilde.ntilde);
    right = (zExpE * proof.zprm) % ntilde.ntilde;
    if (left !== right) {
        return false;
    }
    const h1ExpT1 = (0, bigint_mod_arith_1.modPow)(ntilde.h1, proof.t1, ntilde.ntilde);
    const h2ExpT2 = (0, bigint_mod_arith_1.modPow)(ntilde.h2, proof.t2, ntilde.ntilde);
    left = (h1ExpT1 * h2ExpT2) % ntilde.ntilde;
    const tExpE = (0, bigint_mod_arith_1.modPow)(proof.t, e, ntilde.ntilde);
    right = (tExpE * proof.w) % ntilde.ntilde;
    if (left !== right) {
        return false;
    }
    const c1ExpS1 = (0, bigint_mod_arith_1.modPow)(c1, proof.s1, pk._n2);
    const sExpN = (0, bigint_mod_arith_1.modPow)(proof.s, pk.n, pk._n2);
    const gammaExpT1 = (0, bigint_mod_arith_1.modPow)(pk.g, proof.t1, pk._n2);
    left = (((c1ExpS1 * sExpN) % pk._n2) * gammaExpT1) % pk._n2;
    const c2ExpE = (0, bigint_mod_arith_1.modPow)(c2, e, pk._n2);
    right = (c2ExpE * proof.v) % pk._n2;
    return left === right;
}
exports.verifyWithCheck = verifyWithCheck;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2Vwcm9vZi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy90c3MvZWNkc2EvcmFuZ2Vwcm9vZi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7O0dBR0c7QUFDSCxtQ0FBb0M7QUFHcEMsNkRBQTZEO0FBQzdELHVEQUFrRDtBQVNsRCxxQ0FBMkY7QUFDM0YsbUNBQThDO0FBQzlDLCtDQUFxRDtBQUVyRCwyRkFBMkY7QUFDM0YsTUFBTSxVQUFVLEdBQUcsR0FBRyxDQUFDO0FBRXZCLEtBQUssVUFBVSxlQUFlLENBQUMsU0FBUyxHQUFHLDJCQUFtQixFQUFFLEtBQUssR0FBRyxFQUFFO0lBQ3hFLElBQUksU0FBUyxHQUFHLDJCQUFtQixFQUFFO1FBQ25DLGtDQUFrQztRQUNsQyxzQ0FBc0M7UUFDdEMsT0FBTyxDQUFDLElBQUksQ0FBQyw4REFBOEQsQ0FBQyxDQUFDO0tBQzlFO0lBQ0QsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDN0MsTUFBTSxVQUFVLEdBQUcsU0FBUyxHQUFHLFVBQVUsQ0FBQztJQUMxQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQzlCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsTUFBTSxJQUFBLDhCQUFrQixFQUFDLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFDbEUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNoQix3R0FBd0c7UUFDeEcsSUFBSSxJQUFBLCtCQUFTLEVBQUMsQ0FBQyxDQUFDLEtBQUssU0FBUyxFQUFFO1lBQzlCLFNBQVM7U0FDVjtRQUNELE9BQU8sRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENB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Z2UgUmFuZ2UgUHJvb2ZzIGFzIGRlc2NyaWJlZCBpbiAoVHdvLXBhcnR5IGdlbmVyYXRpb24gb2YgRFNBIHNpZ25hdHVyZXMpWzFdLlxuICogWzFdOiBodHRwczovL3JlaXRlcm1rLmdpdGh1Yi5pby9wYXBlcnMvMjAwNC9JSklTLnBkZlxuICovXG5pbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IEJhc2VDdXJ2ZSB9IGZyb20gJy4uLy4uL2N1cnZlcyc7XG5pbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdwYWlsbGllci1iaWdpbnQnO1xuaW1wb3J0IHsgYml0TGVuZ3RoLCByYW5kQmV0d2VlbiB9IGZyb20gJ2JpZ2ludC1jcnlwdG8tdXRpbHMnO1xuaW1wb3J0IHsgbW9kSW52LCBtb2RQb3cgfSBmcm9tICdiaWdpbnQtbW9kLWFyaXRoJztcbmltcG9ydCB7XG4gIERlc2VyaWFsaXplZE50aWxkZSxcbiAgRGVzZXJpYWxpemVkTnRpbGRlUHJvb2YsXG4gIFJTQU1vZHVsdXMsXG4gIFJhbmdlUHJvb2YsXG4gIFJhbmdlUHJvb2ZXaXRoQ2hlY2ssXG4gIERlc2VyaWFsaXplZE50aWxkZVdpdGhQcm9vZnMsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgYmlnSW50RnJvbUJ1ZmZlckJFLCBiaWdJbnRUb0J1ZmZlckJFLCByYW5kb21Qb3NpdGl2ZUNvUHJpbWVUbyB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgbWluTW9kdWx1c0JpdExlbmd0aCB9IGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHsgZ2VuZXJhdGVTYWZlUHJpbWVzIH0gZnJvbSAnLi4vLi4vc2FmZVByaW1lJztcblxuLy8gMTI4IGFzIHJlY29tbWVuZCBieSBodHRwczovL2Jsb2cudmVyaWNoYWlucy5pby9wL3ZzYS0yMDIyLTEyMC1tdWx0aWNoYWluLWtleS1leHRyYWN0aW9uLlxuY29uc3QgSVRFUkFUSU9OUyA9IDEyODtcblxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVNb2R1bHVzKGJpdGxlbmd0aCA9IG1pbk1vZHVsdXNCaXRMZW5ndGgsIHJldHJ5ID0gMTApOiBQcm9taXNlPFJTQU1vZHVsdXM+IHtcbiAgaWYgKGJpdGxlbmd0aCA8IG1pbk1vZHVsdXNCaXRMZW5ndGgpIHtcbiAgICAvLyBodHRwczovL3d3dy5rZXlsZW5ndGguY29tL2VuLzYvXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oJ0dlbmVyYXRpbmcgYSBtb2R1bHVzIHdpdGggbGVzcyB0aGFuIDMwNzIgaXMgbm90IHJlY29tbWVuZGVkIScpO1xuICB9XG4gIGNvbnN0IGJpdGxlbmd0aFAgPSBNYXRoLmZsb29yKGJpdGxlbmd0aCAvIDIpO1xuICBjb25zdCBiaXRsZW5ndGhRID0gYml0bGVuZ3RoIC0gYml0bGVuZ3RoUDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXRyeTsgaSsrKSB7XG4gICAgY29uc3QgW3AsIHFdID0gYXdhaXQgZ2VuZXJhdGVTYWZlUHJpbWVzKFtiaXRsZW5ndGhQLCBiaXRsZW5ndGhRXSk7XG4gICAgY29uc3QgbiA9IHAgKiBxO1xuICAgIC8vIEZvciBsYXJnZSBiaXQgbGVuZ3RocywgdGhlIHByb2JhYmlsaXR5IG9mIGdlbmVyYXRpbmcgYSBtb2R1bHVzIHdpdGggdGhlIHdyb25nIGJpdCBsZW5ndGggaXMgdmVyeSBsb3cuXG4gICAgaWYgKGJpdExlbmd0aChuKSAhPT0gYml0bGVuZ3RoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbiwgcTE6IChwIC0gQmlnSW50KDEpKSAvIEJpZ0ludCgyKSwgcTI6IChxIC0gQmlnSW50KDEpKSAvIEJpZ0ludCgyKSB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgVW5hYmxlIHRvIGdlbmVyYXRlIG1vZHVsdXMgd2l0aCBiaXQgbGVuZ3RoIG9mICR7Yml0bGVuZ3RofSBhZnRlciAke3JldHJ5fSB0cmllcy4gUGxlYXNlIHRyeSBhZ2FpbiBvciByZWFjaCBvdXQgdG8gc3VwcG9ydEBiaXRnby5jb21gXG4gICk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgXCJjaGFsbGVuZ2VcIiB2YWx1ZXMgZm9yIHJhbmdlIHByb29mcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRsZW5ndGggVGhlIGJpdCBsZW5ndGggb2YgdGhlIG1vZHVsdXMgdG8gZ2VuZXJhdGUuIFRoaXMgc2hvdWxkXG4gKiBiZSB0aGUgc2FtZSBhcyB0aGUgYml0IGxlbmd0aCBvZiB0aGUgcGFpbGxpZXIgcHVibGljIGtleXMgdXNlZCBmb3IgTXRBLlxuICogQHJldHVybnMge0Rlc2VyaWFsaXplZE50aWxkZX0gVGhlIGdlbmVyYXRlZCBOdGlsZGUgdmFsdWVzLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVOdGlsZGUoYml0bGVuZ3RoID0gbWluTW9kdWx1c0JpdExlbmd0aCk6IFByb21pc2U8RGVzZXJpYWxpemVkTnRpbGRlV2l0aFByb29mcz4ge1xuICBjb25zdCB7IG46IG50aWxkZSwgcTEsIHEyIH0gPSBhd2FpdCBnZW5lcmF0ZU1vZHVsdXMoYml0bGVuZ3RoKTtcbiAgY29uc3QgW2YxLCBmMl0gPSBhd2FpdCBQcm9taXNlLmFsbChbcmFuZG9tUG9zaXRpdmVDb1ByaW1lVG8obnRpbGRlKSwgcmFuZG9tUG9zaXRpdmVDb1ByaW1lVG8obnRpbGRlKV0pO1xuICBjb25zdCBoMSA9IG1vZFBvdyhmMSwgQmlnSW50KDIpLCBudGlsZGUpO1xuICBjb25zdCBoMiA9IG1vZFBvdyhoMSwgZjIsIG50aWxkZSk7XG4gIGNvbnN0IGJldGEgPSBtb2RJbnYoZjIsIHExICogcTIpO1xuICBjb25zdCBbaDF3cnRIMlByb29mcywgaDJ3cnRIMVByb29mc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgZ2VuZXJhdGVOdGlsZGVQcm9vZihcbiAgICAgIHtcbiAgICAgICAgaDE6IGgxLFxuICAgICAgICBoMjogaDIsXG4gICAgICAgIG50aWxkZTogbnRpbGRlLFxuICAgICAgfSxcbiAgICAgIGYyLFxuICAgICAgcTEsXG4gICAgICBxMlxuICAgICksXG4gICAgZ2VuZXJhdGVOdGlsZGVQcm9vZihcbiAgICAgIHtcbiAgICAgICAgaDE6IGgyLFxuICAgICAgICBoMjogaDEsXG4gICAgICAgIG50aWxkZTogbnRpbGRlLFxuICAgICAgfSxcbiAgICAgIGJldGEsXG4gICAgICBxMSxcbiAgICAgIHEyXG4gICAgKSxcbiAgXSk7XG4gIHJldHVybiB7XG4gICAgbnRpbGRlLFxuICAgIGgxLFxuICAgIGgyLFxuICAgIG50aWxkZVByb29mOiB7XG4gICAgICBoMVdydEgyOiB7XG4gICAgICAgIGFscGhhOiBoMXdydEgyUHJvb2ZzLmFscGhhLFxuICAgICAgICB0OiBoMXdydEgyUHJvb2ZzLnQsXG4gICAgICB9LFxuICAgICAgaDJXcnRIMToge1xuICAgICAgICBhbHBoYTogaDJ3cnRIMVByb29mcy5hbHBoYSxcbiAgICAgICAgdDogaDJ3cnRIMVByb29mcy50LFxuICAgICAgfSxcbiAgICB9LFxuICB9O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGl0ZXJhdGlvbnMgb2YgTnRpbGRlLCBoMSwgaDIgZGlzY3JldGUgbG9nIHByb29mcy5cbiAqIEBwYXJhbSB7RGVzZXJpYWxpemVkTnRpbGRlfSBudGlsZGUgTnRpbGRlLCBoMSwgaDIgdG8gZ2VuZXJhdGUgdGhlIHByb29mcyBmb3IuXG4gKiBAcGFyYW0ge2JpZ2ludH0geCBFaXRoZXIgYWxwaGEgb3IgYmV0YSBkZXBlbmRpbmcgb24gd2hldGhlciBpdCBpcyBhIGRpc2NyZXRlIGxvZyBwcm9vZiBvZlxuICogaDEgdy5yLnQgaDIgb3IgaDIgdy5yLnQgaDEuXG4gKiBAcGFyYW0ge2JpZ2ludH0gcTEgVGhlIFNvcGhpZSBHZXJtYWluIHByaW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmlyc3Qgc2FmZSBwcmltZSBwMSB1c2VkIHRvIGdlbmVyYXRlIE50aWxkZS5cbiAqIEBwYXJhbSB7YmlnaW50fSBxMiBUaGUgU29waGllIEdlcm1haW4gcHJpbWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBzZWNvbmQgc2FmZSBwcmltZSBwMiB1c2VkIHRvIGdlbmVyYXRlIE50aWxkZS5cbiAqIEByZXR1cm5zIHtOdGlsZGVQcm9vZn0gVGhlIGdlbmVyYXRlZCBOdGlsZGUgUHJvb2ZzLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVOdGlsZGVQcm9vZihcbiAgbnRpbGRlOiBEZXNlcmlhbGl6ZWROdGlsZGUsXG4gIHg6IGJpZ2ludCxcbiAgcTE6IGJpZ2ludCxcbiAgcTI6IGJpZ2ludFxuKTogUHJvbWlzZTxEZXNlcmlhbGl6ZWROdGlsZGVQcm9vZj4ge1xuICBjb25zdCBxMU11bFEyID0gcTEgKiBxMjtcbiAgY29uc3QgYTogYmlnaW50W10gPSBbXTtcbiAgY29uc3QgYWxwaGE6IGJpZ2ludFtdID0gW107XG4gIGxldCBtc2dUb0hhc2g6IEJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW1xuICAgIGJpZ0ludFRvQnVmZmVyQkUobnRpbGRlLmgxKSxcbiAgICBiaWdJbnRUb0J1ZmZlckJFKG50aWxkZS5oMiksXG4gICAgYmlnSW50VG9CdWZmZXJCRShudGlsZGUubnRpbGRlKSxcbiAgXSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgYS5wdXNoKHJhbmRCZXR3ZWVuKHExTXVsUTIpKTtcbiAgICBhbHBoYS5wdXNoKG1vZFBvdyhudGlsZGUuaDEsIGFbaV0sIG50aWxkZS5udGlsZGUpKTtcbiAgICBtc2dUb0hhc2ggPSBCdWZmZXIuY29uY2F0KFttc2dUb0hhc2gsIGJpZ0ludFRvQnVmZmVyQkUoYWxwaGFbaV0sIE1hdGguY2VpbChiaXRMZW5ndGgobnRpbGRlLm50aWxkZSkgLyA4KSldKTtcbiAgfVxuICBjb25zdCBzaW11bGF0ZWRSZXNwb25zZSA9IGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShtc2dUb0hhc2gpLmRpZ2VzdCgpO1xuICBjb25zdCB0OiBiaWdpbnRbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IElURVJBVElPTlM7IGkrKykge1xuICAgIC8vIEdldCB0aGUgaXRoIGJpdCBmcm9tIGEgYnVmZmVyIG9mIGJ5dGVzLlxuICAgIGNvbnN0IGl0aEJpdCA9IChzaW11bGF0ZWRSZXNwb25zZVtNYXRoLmZsb29yKGkgLyA4KV0gPj4gKDcgLSAoaSAlIDgpKSkgJiAxO1xuICAgIHQucHVzaCgoYVtpXSArICgoQmlnSW50KGl0aEJpdCkgKiB4KSAlIHExTXVsUTIpKSAlIHExTXVsUTIpO1xuICB9XG4gIHJldHVybiB7IGFscGhhLCB0IH07XG59XG5cbi8qKlxuICogVmVyaWZ5IGRpc2NyZXRlIGxvZyBwcm9vZnMgb2YgaDEgYW5kIGgyIG1vZCBOdGlsZGUuXG4gKiBAcGFyYW0ge0Rlc2VyaWFsaXplZE50aWxkZX0gbnRpbGRlIE50aWxkZSwgaDEsIGgyIHRvIGdlbmVyYXRlIHRoZSBwcm9vZnMgZm9yLlxuICogQHBhcmFtIHtEZXNlcmlhbGl6ZWROdGlsZGVQcm9vZn0gbnRpbGRlUHJvb2YgTnRpbGRlIFByb29mc1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgcHJvb2YgaXMgdmVyaWZpZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeU50aWxkZVByb29mKFxuICBudGlsZGU6IERlc2VyaWFsaXplZE50aWxkZSxcbiAgbnRpbGRlUHJvb2Y6IERlc2VyaWFsaXplZE50aWxkZVByb29mXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgaDFNb2ROdGlsZGUgPSBudGlsZGUuaDEgJSBudGlsZGUubnRpbGRlO1xuICBjb25zdCBoMk1vZE50aWxkZSA9IG50aWxkZS5oMiAlIG50aWxkZS5udGlsZGU7XG4gIGlmIChoMU1vZE50aWxkZSA9PT0gQmlnSW50KDApIHx8IGgyTW9kTnRpbGRlID09PSBCaWdJbnQoMCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGgxTW9kTnRpbGRlID09PSBCaWdJbnQoMSkgfHwgaDJNb2ROdGlsZGUgPT09IEJpZ0ludCgxKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaDFNb2ROdGlsZGUgPT09IGgyTW9kTnRpbGRlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChcbiAgICBudGlsZGVQcm9vZi5hbHBoYS5sZW5ndGggPiAyNTYgfHxcbiAgICBudGlsZGVQcm9vZi5hbHBoYS5sZW5ndGggIT09IElURVJBVElPTlMgfHxcbiAgICBudGlsZGVQcm9vZi50Lmxlbmd0aCAhPT0gSVRFUkFUSU9OU1xuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IG1zZ1RvSGFzaDogQnVmZmVyID0gQnVmZmVyLmNvbmNhdChbXG4gICAgYmlnSW50VG9CdWZmZXJCRShudGlsZGUuaDEpLFxuICAgIGJpZ0ludFRvQnVmZmVyQkUobnRpbGRlLmgyKSxcbiAgICBiaWdJbnRUb0J1ZmZlckJFKG50aWxkZS5udGlsZGUpLFxuICBdKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudGlsZGVQcm9vZi5hbHBoYS5sZW5ndGg7IGkrKykge1xuICAgIG1zZ1RvSGFzaCA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgbXNnVG9IYXNoLFxuICAgICAgYmlnSW50VG9CdWZmZXJCRShudGlsZGVQcm9vZi5hbHBoYVtpXSwgTWF0aC5jZWlsKGJpdExlbmd0aChudGlsZGUubnRpbGRlKSAvIDgpKSxcbiAgICBdKTtcbiAgfVxuICBjb25zdCBzaW11bGF0ZWRSZXNwb25zZSA9IGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShtc2dUb0hhc2gpLmRpZ2VzdCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG50aWxkZVByb29mLmFscGhhLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gR2V0IHRoZSBpdGggYml0IGZyb20gYSBidWZmZXIgb2YgYnl0ZXMuXG4gICAgY29uc3QgaXRoQml0ID0gKHNpbXVsYXRlZFJlc3BvbnNlW01hdGguZmxvb3IoaSAvIDgpXSA+PiAoNyAtIChpICUgOCkpKSAmIDE7XG4gICAgY29uc3QgaDFQb3dUaSA9IG1vZFBvdyhudGlsZGUuaDEsIG50aWxkZVByb29mLnRbaV0sIG50aWxkZS5udGlsZGUpO1xuICAgIGNvbnN0IGgyUG93Q2kgPSBtb2RQb3cobnRpbGRlLmgyLCBCaWdJbnQoaXRoQml0KSwgbnRpbGRlLm50aWxkZSk7XG4gICAgY29uc3QgYWxwaGFNdWxoMlBvd0NpID0gKG50aWxkZVByb29mLmFscGhhW2ldICogaDJQb3dDaSkgJSBudGlsZGUubnRpbGRlO1xuICAgIGlmIChoMVBvd1RpICE9PSBhbHBoYU11bGgyUG93Q2kpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEgemVyby1rbm93bGVkZ2UgcmFuZ2UgcHJvb2YgdGhhdCBhbiBlbmNyeXB0ZWQgdmFsdWUgaXMgXCJzbWFsbFwiLlxuICogQHBhcmFtIHtCYXNlQ3VydmV9IGN1cnZlIEFuIGVsbGlwdGljIGN1cnZlIHRvIHVzZSBmb3IgZ3JvdXAgb3BlcmF0aW9ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtb2R1bHVzQml0cyBUaGUgYml0IGNvdW50IG9mIHRoZSBwcm92ZXIncyBwdWJsaWMga2V5LlxuICogQHBhcmFtIHtQdWJsaWNLZXl9IHBrIFRoZSBwcm92ZXIncyBwdWJsaWMga2V5LlxuICogQHBhcmFtIHtEZXNlcmlhbGl6ZWROdGlsZGV9IG50aWxkZSBUaGUgdmVyaWZpZXIncyBOdGlsZGUgdmFsdWVzLlxuICogQHBhcmFtIHtiaWdpbnR9IGMgVGhlIGNpcGhlcnRleHQuXG4gKiBAcGFyYW0ge2JpZ2ludH0gbSBUaGUgcGxhaW50ZXh0LlxuICogQHBhcmFtIHtiaWdpbnR9IHIgVGhlIG9iZnVzY2F0aW9uIHZhbHVlIHVzZWQgdG8gZW5jcnlwdCBtLlxuICogQHJldHVybnMge1JhbmdlUHJvb2Z9IFRoZSBnZW5lcmF0ZWQgcHJvb2YuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm92ZShcbiAgY3VydmU6IEJhc2VDdXJ2ZSxcbiAgbW9kdWx1c0JpdHM6IG51bWJlcixcbiAgcGs6IFB1YmxpY0tleSxcbiAgbnRpbGRlOiBEZXNlcmlhbGl6ZWROdGlsZGUsXG4gIGM6IGJpZ2ludCxcbiAgbTogYmlnaW50LFxuICByOiBiaWdpbnRcbik6IFByb21pc2U8UmFuZ2VQcm9vZj4ge1xuICBjb25zdCBtb2R1bHVzQnl0ZXMgPSBNYXRoLmZsb29yKChtb2R1bHVzQml0cyArIDcpIC8gOCk7XG4gIGNvbnN0IHEgPSBjdXJ2ZS5vcmRlcigpO1xuICBjb25zdCBxMyA9IHEgKiogQmlnSW50KDMpO1xuICBjb25zdCBxbnRpbGRlID0gcSAqIG50aWxkZS5udGlsZGU7XG4gIGNvbnN0IHEzbnRpbGRlID0gcTMgKiBudGlsZGUubnRpbGRlO1xuICBjb25zdCBhbHBoYSA9IHJhbmRCZXR3ZWVuKHEzKTtcbiAgY29uc3QgYmV0YSA9IGF3YWl0IHJhbmRvbVBvc2l0aXZlQ29QcmltZVRvKHBrLm4pO1xuICBjb25zdCBnYW1tYSA9IHJhbmRCZXR3ZWVuKHEzbnRpbGRlKTtcbiAgY29uc3QgcmhvID0gcmFuZEJldHdlZW4ocW50aWxkZSk7XG4gIGNvbnN0IHogPSAobW9kUG93KG50aWxkZS5oMSwgbSwgbnRpbGRlLm50aWxkZSkgKiBtb2RQb3cobnRpbGRlLmgyLCByaG8sIG50aWxkZS5udGlsZGUpKSAlIG50aWxkZS5udGlsZGU7XG4gIGNvbnN0IHUgPSAobW9kUG93KHBrLmcsIGFscGhhLCBway5fbjIpICogbW9kUG93KGJldGEsIHBrLm4sIHBrLl9uMikpICUgcGsuX24yO1xuICBjb25zdCB3ID0gKG1vZFBvdyhudGlsZGUuaDEsIGFscGhhLCBudGlsZGUubnRpbGRlKSAqIG1vZFBvdyhudGlsZGUuaDIsIGdhbW1hLCBudGlsZGUubnRpbGRlKSkgJSBudGlsZGUubnRpbGRlO1xuICBjb25zdCBoYXNoID0gY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XG4gIGhhc2gudXBkYXRlKCdcXHgwNlxceDAwXFx4MDBcXHgwMFxceDAwXFx4MDBcXHgwMFxceDAwJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUocGsubiwgbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUocGsuZywgbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUoYywgMiAqIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHosIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHUsIDIgKiBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRSh3LCBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgY29uc3QgZSA9IGJpZ0ludEZyb21CdWZmZXJCRShoYXNoLmRpZ2VzdCgpKSAlIHE7XG4gIGNvbnN0IHMgPSAobW9kUG93KHIsIGUsIHBrLm4pICogYmV0YSkgJSBway5uO1xuICBjb25zdCBzMSA9IGUgKiBtICsgYWxwaGE7XG4gIGNvbnN0IHMyID0gZSAqIHJobyArIGdhbW1hO1xuICByZXR1cm4geyB6LCB1LCB3LCBzLCBzMSwgczIgfTtcbn1cblxuLyoqXG4gKiBWZXJpZnkgYSB6ZXJvLWtub3dsZWRnZSByYW5nZSBwcm9vZiB0aGF0IGFuIGVuY3J5cHRlZCB2YWx1ZSBpcyBcInNtYWxsXCIuXG4gKiBAcGFyYW0ge0Jhc2VDdXJ2ZX0gY3VydmUgQW4gZWxsaXB0aWMgY3VydmUgdG8gdXNlIGZvciBncm91cCBvcGVyYXRpb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IG1vZHVsdXNCaXRzIFRoZSBiaXQgY291bnQgb2YgdGhlIHByb3ZlcidzIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gcGsgVGhlIHByb3ZlcidzIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0ge0Rlc2VyaWFsaXplZE50aWxkZX0gbnRpbGRlIFRoZSB2ZXJpZmllcidzIE50aWxkZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge1JhbmdlUHJvb2Z9IHByb29mIFRoZSByYW5nZSBwcm9vZi5cbiAqIEBwYXJhbSB7YmlnaW50fSBjIFRoZSBjaXBoZXJ0ZXh0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmVyaWZpY2F0aW9uIHN1Y2NlZWRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5KFxuICBjdXJ2ZTogQmFzZUN1cnZlLFxuICBtb2R1bHVzQml0czogbnVtYmVyLFxuICBwazogUHVibGljS2V5LFxuICBudGlsZGU6IERlc2VyaWFsaXplZE50aWxkZSxcbiAgcHJvb2Y6IFJhbmdlUHJvb2YsXG4gIGM6IGJpZ2ludFxuKTogYm9vbGVhbiB7XG4gIGlmIChwcm9vZi51ID09PSBCaWdJbnQoMCkgfHwgcHJvb2YucyA9PT0gQmlnSW50KDApKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG1vZHVsdXNCeXRlcyA9IE1hdGguZmxvb3IoKG1vZHVsdXNCaXRzICsgNykgLyA4KTtcbiAgY29uc3QgcSA9IGN1cnZlLm9yZGVyKCk7XG4gIGNvbnN0IHEzID0gcSAqKiBCaWdJbnQoMyk7XG4gIGlmIChwcm9vZi5zMSA+IHEzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGhhc2ggPSBjcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgaGFzaC51cGRhdGUoJ1xceDA2XFx4MDBcXHgwMFxceDAwXFx4MDBcXHgwMFxceDAwXFx4MDAnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShway5uLCBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShway5nLCBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShjLCAyICogbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUocHJvb2YueiwgbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudSwgMiAqIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHByb29mLncsIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBjb25zdCBlID0gYmlnSW50RnJvbUJ1ZmZlckJFKGhhc2guZGlnZXN0KCkpICUgcTtcbiAgbGV0IHByb2R1Y3RzOiBiaWdpbnQ7XG4gIHByb2R1Y3RzID0gKG1vZFBvdyhway5nLCBwcm9vZi5zMSwgcGsuX24yKSAqIG1vZFBvdyhwcm9vZi5zLCBway5uLCBway5fbjIpICogbW9kUG93KGMsIC1lLCBway5fbjIpKSAlIHBrLl9uMjtcbiAgaWYgKHByb29mLnUgIT09IHByb2R1Y3RzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHByb2R1Y3RzID1cbiAgICAoKChtb2RQb3cobnRpbGRlLmgxLCBwcm9vZi5zMSwgbnRpbGRlLm50aWxkZSkgKiBtb2RQb3cobnRpbGRlLmgyLCBwcm9vZi5zMiwgbnRpbGRlLm50aWxkZSkpICUgbnRpbGRlLm50aWxkZSkgKlxuICAgICAgbW9kUG93KHByb29mLnosIC1lLCBudGlsZGUubnRpbGRlKSkgJVxuICAgIG50aWxkZS5udGlsZGU7XG4gIHJldHVybiBwcm9vZi53ID09PSBwcm9kdWN0cztcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHplcm8ta25vd2xlZGdlIHJhbmdlIHByb29mIHRoYXQgYSBob21vbW9ycGhpY2FsbHkgbWFuaXB1bGF0ZWQgdmFsdWUgaXMgXCJzbWFsbFwiLlxuICogQHBhcmFtIHtCYXNlQ3VydmV9IGN1cnZlIEFuIGVsbGlwdGljIGN1cnZlIHRvIHVzZSBmb3IgZ3JvdXAgb3BlcmF0aW9ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtb2R1bHVzQml0cyBUaGUgYml0IGNvdW50IG9mIHRoZSBwcm92ZXIncyBwdWJsaWMga2V5LlxuICogQHBhcmFtIHtQdWJsaWNLZXl9IHBrIFRoZSBwcm92ZXIncyBwdWJsaWMga2V5LlxuICogQHBhcmFtIHtEZXNlcmlhbGl6ZWROdGlsZGV9IG50aWxkZSBUaGUgdmVyaWZpZXIncyBOdGlsZGUgdmFsdWVzLlxuICogQHBhcmFtIHtiaWdpbnR9IGMxIFRoZSBvcmlnaW5hbCBjaXBoZXJ0ZXh0LlxuICogQHBhcmFtIHtiaWdpbnR9IGMyIFRoZSBtYW5pcHVsYXRlZCBjaXBoZXJ0ZXh0LlxuICogQHBhcmFtIHtiaWdpbnR9IHggVGhlIHBsYWludGV4dCB2YWx1ZSBtdWx0aXBsaWVkIGJ5IHRoZSBvcmlnaW5hbCBwbGFpbnRleHQuXG4gKiBAcGFyYW0ge2JpZ2ludH0geSBUaGUgcGxhaW50ZXh0IHZhbHVlIHRoYXQgaXMgYWRkZWQgdG8geC5cbiAqIEBwYXJhbSB7YmlnaW50fSByIFRoZSBvYmZ1c2NhdGlvbiB2YWx1ZSB1c2VkIHRvIGVuY3J5cHQgeC5cbiAqIEBwYXJhbSB7YmlnaW50fSBYIFRoZSBjdXJ2ZSdzIGJhc2UgcG9pbnQgcmFpc2VkIHRvIHguXG4gKiBAcmV0dXJucyB7UmFuZ2VQcm9vZldpdGhDaGVja30gVGhlIGdlbmVyYXRlZCBwcm9vZi5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb3ZlV2l0aENoZWNrKFxuICBjdXJ2ZTogQmFzZUN1cnZlLFxuICBtb2R1bHVzQml0czogbnVtYmVyLFxuICBwazogUHVibGljS2V5LFxuICBudGlsZGU6IERlc2VyaWFsaXplZE50aWxkZSxcbiAgYzE6IGJpZ2ludCxcbiAgYzI6IGJpZ2ludCxcbiAgeDogYmlnaW50LFxuICB5OiBiaWdpbnQsXG4gIHI6IGJpZ2ludCxcbiAgWDogYmlnaW50XG4pOiBQcm9taXNlPFJhbmdlUHJvb2ZXaXRoQ2hlY2s+IHtcbiAgY29uc3QgbW9kdWx1c0J5dGVzID0gTWF0aC5mbG9vcigobW9kdWx1c0JpdHMgKyA3KSAvIDgpO1xuICBjb25zdCBxID0gY3VydmUub3JkZXIoKTtcbiAgY29uc3QgcTMgPSBxICoqIEJpZ0ludCgzKTtcbiAgY29uc3QgcTcgPSBxICoqIEJpZ0ludCg3KTtcbiAgY29uc3QgcW50aWxkZSA9IHEgKiBudGlsZGUubnRpbGRlO1xuICBjb25zdCBxM250aWxkZSA9IHEzICogbnRpbGRlLm50aWxkZTtcbiAgY29uc3QgYWxwaGEgPSByYW5kQmV0d2VlbihxMyk7XG4gIGNvbnN0IHJobyA9IHJhbmRCZXR3ZWVuKHFudGlsZGUpO1xuICBjb25zdCBzaWdtYSA9IHJhbmRCZXR3ZWVuKHFudGlsZGUpO1xuICBjb25zdCB0YXUgPSByYW5kQmV0d2VlbihxM250aWxkZSk7XG4gIGNvbnN0IHJob3BybSA9IHJhbmRCZXR3ZWVuKHEzbnRpbGRlKTtcbiAgY29uc3QgYmV0YSA9IGF3YWl0IHJhbmRvbVBvc2l0aXZlQ29QcmltZVRvKHBrLm4pO1xuICBjb25zdCBnYW1tYSA9IHJhbmRCZXR3ZWVuKHE3KTtcbiAgY29uc3QgdSA9IGN1cnZlLmJhc2VQb2ludE11bHQoY3VydmUuc2NhbGFyUmVkdWNlKGFscGhhKSk7XG4gIGNvbnN0IHogPSAobW9kUG93KG50aWxkZS5oMSwgeCwgbnRpbGRlLm50aWxkZSkgKiBtb2RQb3cobnRpbGRlLmgyLCByaG8sIG50aWxkZS5udGlsZGUpKSAlIG50aWxkZS5udGlsZGU7XG4gIGNvbnN0IHpwcm0gPSAobW9kUG93KG50aWxkZS5oMSwgYWxwaGEsIG50aWxkZS5udGlsZGUpICogbW9kUG93KG50aWxkZS5oMiwgcmhvcHJtLCBudGlsZGUubnRpbGRlKSkgJSBudGlsZGUubnRpbGRlO1xuICBjb25zdCB0ID0gKG1vZFBvdyhudGlsZGUuaDEsIHksIG50aWxkZS5udGlsZGUpICogbW9kUG93KG50aWxkZS5oMiwgc2lnbWEsIG50aWxkZS5udGlsZGUpKSAlIG50aWxkZS5udGlsZGU7XG4gIGNvbnN0IHYgPVxuICAgICgoKG1vZFBvdyhjMSwgYWxwaGEsIHBrLl9uMikgKiBtb2RQb3cocGsuZywgZ2FtbWEsIHBrLl9uMikpICUgcGsuX24yKSAqIG1vZFBvdyhiZXRhLCBway5uLCBway5fbjIpKSAlIHBrLl9uMjtcbiAgY29uc3QgdyA9IChtb2RQb3cobnRpbGRlLmgxLCBnYW1tYSwgbnRpbGRlLm50aWxkZSkgKiBtb2RQb3cobnRpbGRlLmgyLCB0YXUsIG50aWxkZS5udGlsZGUpKSAlIG50aWxkZS5udGlsZGU7XG4gIGNvbnN0IGhhc2ggPSBjcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgaGFzaC51cGRhdGUoJ1xceDBkXFx4MDBcXHgwMFxceDAwXFx4MDBcXHgwMFxceDAwXFx4MDAnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShway5uLCBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShway5nLCBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShYLCAzMykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKGMxLCAyICogbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUoYzIsIDIgKiBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRSh1LCAzMykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHosIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHpwcm0sIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHQsIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHYsIDIgKiBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRSh3LCBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgY29uc3QgZSA9IGJpZ0ludEZyb21CdWZmZXJCRShoYXNoLmRpZ2VzdCgpKSAlIHE7XG4gIGNvbnN0IHMgPSAobW9kUG93KHIsIGUsIHBrLm4pICogYmV0YSkgJSBway5uO1xuICBjb25zdCBzMSA9IGUgKiB4ICsgYWxwaGE7XG4gIGNvbnN0IHMyID0gZSAqIHJobyArIHJob3BybTtcbiAgY29uc3QgdDEgPSBlICogeSArIGdhbW1hO1xuICBjb25zdCB0MiA9IGUgKiBzaWdtYSArIHRhdTtcbiAgcmV0dXJuIHsgeiwgenBybSwgdCwgdiwgdywgcywgczEsIHMyLCB0MSwgdDIsIHUgfTtcbn1cblxuLyoqXG4gKiBWZXJpZnkgYSB6ZXJvLWtub3dsZWRnZSByYW5nZSBwcm9vZiB0aGF0IGEgaG9tb21vcnBoaWNhbGx5IG1hbmlwdWxhdGVkIHZhbHVlIGlzIFwic21hbGxcIi5cbiAqIEBwYXJhbSB7QmFzZUN1cnZlfSBjdXJ2ZSBBbiBlbGxpcHRpYyBjdXJ2ZSB0byB1c2UgZm9yIGdyb3VwIG9wZXJhdGlvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gbW9kdWx1c0JpdHMgVGhlIGJpdCBjb3VudCBvZiB0aGUgcHJvdmVyJ3MgcHVibGljIGtleS5cbiAqIEBwYXJhbSB7UHVibGljS2V5fSBwayBUaGUgcHJvdmVyJ3MgcHVibGljIGtleS5cbiAqIEBwYXJhbSB7RGVzZXJpYWxpemVkTnRpbGRlfSBudGlsZGUgVGhlIHZlcmlmaWVyJ3MgTnRpbGRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7UmFuZ2VQcm9vZldpdGhDaGVja30gcHJvb2YgVGhlIHJhbmdlIHByb29mLlxuICogQHBhcmFtIHtiaWdpbnR9IGMxIFRoZSBvcmlnaW5hbCBjaXBoZXJ0ZXh0LlxuICogQHBhcmFtIHtiaWdpbnR9IGMyIFRoZSBtYW5pcHVsYXRlZCBjaXBoZXJ0ZXh0LlxuICogQHBhcmFtIHtiaWdpbnR9IFggVGhlIGN1cnZlJ3MgYmFzZSBwb2ludCByYWlzZWQgdG8geC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZlcmlmaWNhdGlvbiBzdWNjZWVkcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVdpdGhDaGVjayhcbiAgY3VydmU6IEJhc2VDdXJ2ZSxcbiAgbW9kdWx1c0JpdHM6IG51bWJlcixcbiAgcGs6IFB1YmxpY0tleSxcbiAgbnRpbGRlOiBEZXNlcmlhbGl6ZWROdGlsZGUsXG4gIHByb29mOiBSYW5nZVByb29mV2l0aENoZWNrLFxuICBjMTogYmlnaW50LFxuICBjMjogYmlnaW50LFxuICBYOiBiaWdpbnRcbik6IGJvb2xlYW4ge1xuICBjb25zdCBtb2R1bHVzQnl0ZXMgPSBNYXRoLmZsb29yKChtb2R1bHVzQml0cyArIDcpIC8gOCk7XG4gIGNvbnN0IHEgPSBjdXJ2ZS5vcmRlcigpO1xuICBjb25zdCBxMyA9IHEgKiogQmlnSW50KDMpO1xuICBjb25zdCBxNyA9IHEgKiogQmlnSW50KDcpO1xuICBpZiAocHJvb2YuczEgPiBxMykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocHJvb2YudDEgPiBxNykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBoYXNoID0gY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XG4gIGhhc2gudXBkYXRlKCdcXHgwZFxceDAwXFx4MDBcXHgwMFxceDAwXFx4MDBcXHgwMFxceDAwJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUocGsubiwgbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUocGsuZywgbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUoWCwgMzMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShjMSwgMiAqIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKGMyLCAyICogbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudSwgMzMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShwcm9vZi56LCBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShwcm9vZi56cHJtLCBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShwcm9vZi50LCBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShwcm9vZi52LCAyICogbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudywgbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGNvbnN0IGUgPSBiaWdJbnRGcm9tQnVmZmVyQkUoaGFzaC5kaWdlc3QoKSkgJSBxO1xuICBjb25zdCBnUzEgPSBjdXJ2ZS5iYXNlUG9pbnRNdWx0KGN1cnZlLnNjYWxhclJlZHVjZShwcm9vZi5zMSkpO1xuICBjb25zdCB4RVUgPSBjdXJ2ZS5wb2ludEFkZChjdXJ2ZS5wb2ludE11bHRpcGx5KFgsIGUpLCBwcm9vZi51KTtcbiAgaWYgKGdTMSAhPT0geEVVKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBsZWZ0LCByaWdodDtcbiAgY29uc3QgaDFFeHBTMSA9IG1vZFBvdyhudGlsZGUuaDEsIHByb29mLnMxLCBudGlsZGUubnRpbGRlKTtcbiAgY29uc3QgaDJFeHBTMiA9IG1vZFBvdyhudGlsZGUuaDIsIHByb29mLnMyLCBudGlsZGUubnRpbGRlKTtcbiAgbGVmdCA9IChoMUV4cFMxICogaDJFeHBTMikgJSBudGlsZGUubnRpbGRlO1xuICBjb25zdCB6RXhwRSA9IG1vZFBvdyhwcm9vZi56LCBlLCBudGlsZGUubnRpbGRlKTtcbiAgcmlnaHQgPSAoekV4cEUgKiBwcm9vZi56cHJtKSAlIG50aWxkZS5udGlsZGU7XG4gIGlmIChsZWZ0ICE9PSByaWdodCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBoMUV4cFQxID0gbW9kUG93KG50aWxkZS5oMSwgcHJvb2YudDEsIG50aWxkZS5udGlsZGUpO1xuICBjb25zdCBoMkV4cFQyID0gbW9kUG93KG50aWxkZS5oMiwgcHJvb2YudDIsIG50aWxkZS5udGlsZGUpO1xuICBsZWZ0ID0gKGgxRXhwVDEgKiBoMkV4cFQyKSAlIG50aWxkZS5udGlsZGU7XG4gIGNvbnN0IHRFeHBFID0gbW9kUG93KHByb29mLnQsIGUsIG50aWxkZS5udGlsZGUpO1xuICByaWdodCA9ICh0RXhwRSAqIHByb29mLncpICUgbnRpbGRlLm50aWxkZTtcbiAgaWYgKGxlZnQgIT09IHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGMxRXhwUzEgPSBtb2RQb3coYzEsIHByb29mLnMxLCBway5fbjIpO1xuICBjb25zdCBzRXhwTiA9IG1vZFBvdyhwcm9vZi5zLCBway5uLCBway5fbjIpO1xuICBjb25zdCBnYW1tYUV4cFQxID0gbW9kUG93KHBrLmcsIHByb29mLnQxLCBway5fbjIpO1xuICBsZWZ0ID0gKCgoYzFFeHBTMSAqIHNFeHBOKSAlIHBrLl9uMikgKiBnYW1tYUV4cFQxKSAlIHBrLl9uMjtcbiAgY29uc3QgYzJFeHBFID0gbW9kUG93KGMyLCBlLCBway5fbjIpO1xuICByaWdodCA9IChjMkV4cEUgKiBwcm9vZi52KSAlIHBrLl9uMjtcbiAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0O1xufVxuIl19