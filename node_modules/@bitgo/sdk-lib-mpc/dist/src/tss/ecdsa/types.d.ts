import { SchnorrProof } from '../../types';
export declare type XShare = {
    i: number;
    l: string;
    m: string;
    n: string;
    y: string;
    x: string;
    schnorrProofX: SchnorrProof;
    chaincode: string;
};
interface NtildeProof<T> {
    alpha: T[];
    t: T[];
}
interface NtildeProofs<T> {
    h1WrtH2: NtildeProof<T>;
    h2WrtH1: NtildeProof<T>;
}
interface Ntilde<T> {
    ntilde: T;
    h1: T;
    h2: T;
}
export declare type DeserializedNtilde = Ntilde<bigint>;
export declare type SerializedNtilde = Ntilde<string>;
export declare type DeserializedNtildeProof = NtildeProof<bigint>;
export declare type SerializedNtildeProof = NtildeProof<string>;
export declare type DeserializedNtildeProofs = NtildeProofs<bigint>;
export declare type SerializedNtildeProofs = NtildeProofs<string>;
/**
 * The ntilde proofs are done non-interactively,
 * therefore a party generates both ntilde, h1, h2 and the proofs without
 * interaction with the other party.
 */
export declare type DeserializedNtildeWithProofs = DeserializedNtilde & {
    ntildeProof: DeserializedNtildeProofs;
};
export declare type SerializedNtildeWithProofs = SerializedNtilde & {
    ntildeProof: SerializedNtildeProofs;
};
export declare type SerializedEcdsaChallenges = SerializedNtilde & SerializedPaillierChallenge;
/**
 * Deserializes a challenge from hex strings to bigint
 * @param challenge
 */
export declare function deserializeNtilde(challenge: SerializedNtilde): DeserializedNtilde;
/**
 * Serializes a challenge from big int to hex strings.
 * @param challenge
 */
export declare function serializeNtilde(challenge: DeserializedNtilde): SerializedNtilde;
/**
 * Deserializes a challenge and it's proofs from hex strings to bigint
 * @param challenge
 */
export declare function deserializeNtildeWithProofs(challenge: SerializedNtildeWithProofs): DeserializedNtildeWithProofs;
/**
 * Serializes a challenge and it's proofs from big int to hex strings.
 * @param challenge
 */
export declare function serializeNtildeWithProofs(challenge: DeserializedNtildeWithProofs): SerializedNtildeWithProofs;
declare type PaillierChallenge<T> = {
    p: T[];
};
declare type PaillierChallengeProof<T> = {
    sigma: T[];
};
export declare type DeserializedPaillierChallenge = PaillierChallenge<bigint>;
export declare type SerializedPaillierChallenge = PaillierChallenge<string>;
export declare type DeserializedPaillierChallengeProofs = PaillierChallengeProof<bigint>;
export declare type SerializedPaillierChallengeProofs = PaillierChallengeProof<string>;
/**
 * The paillier proofs are done interactively between two parties.
 * If party A is completing a paillier proof $sigma$ with party B, then $p$ refers to
 * a challenge given to A by B, and $sigma$ represents the proof to the challenge
 */
export declare type DeserializedPaillierChallengeWithProofs = DeserializedPaillierChallenge & DeserializedPaillierChallengeProofs;
export declare type SerializedPaillierChallengeWithProofs = SerializedPaillierChallenge & SerializedPaillierChallengeProofs;
/**
 * Deserializes a paillier challenge to hex strings.
 * @param challenge
 */
export declare function deserializePaillierChallenge(challenge: SerializedPaillierChallenge): DeserializedPaillierChallenge;
/**
 * Deserializes a paillier challenge proof to hex strings.
 * @param challenge
 */
export declare function deserializePaillierChallengeProofs(challenge: SerializedPaillierChallengeProofs): DeserializedPaillierChallengeProofs;
/**
 * Deserializes a paillier challenge and its proof to hex strings.
 * @param challengeWithProofs
 */
export declare function deserializePaillierChallengeWithProofs(challengeWithProofs: SerializedPaillierChallengeWithProofs): DeserializedPaillierChallengeWithProofs;
/**
 * Serializes a paillier challenge to hex strings.
 * @param challenge
 */
export declare function serializePaillierChallenge(challenge: DeserializedPaillierChallenge): SerializedPaillierChallenge;
/**
 * Serializes a paillier challenge proof to hex strings.
 * @param challenge
 */
export declare function serializePaillierChallengeProofs(challenge: DeserializedPaillierChallengeProofs): SerializedPaillierChallengeProofs;
/**
 * Serializes a paillier challenge and its proof to hex strings.
 * @param challengeWithProofs
 */
export declare function serializePaillierChallengeWithProofs(challengeWithProofs: DeserializedPaillierChallengeWithProofs): SerializedPaillierChallengeWithProofs;
export interface RSAModulus {
    n: bigint;
    q1: bigint;
    q2: bigint;
}
export interface RangeProof {
    z: bigint;
    u: bigint;
    w: bigint;
    s: bigint;
    s1: bigint;
    s2: bigint;
}
export interface RangeProofWithCheck {
    z: bigint;
    zprm: bigint;
    t: bigint;
    v: bigint;
    w: bigint;
    s: bigint;
    s1: bigint;
    s2: bigint;
    t1: bigint;
    t2: bigint;
    u: bigint;
}
export interface ZkVProof {
    Alpha: bigint;
    t: bigint;
    u: bigint;
}
export {};
//# sourceMappingURL=types.d.ts.map