"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDerivationPath = exports.randomBigInt = exports.randomPositiveCoPrimeLessThan = exports.randomPositiveCoPrimeTo = exports.getPaillierPublicKey = exports.clamp = exports.bigIntFromU8ABE = exports.bigIntFromBufferBE = exports.bigIntToBufferBE = exports.bigIntFromBufferLE = exports.bigIntToBufferLE = exports.bigIntToHex = exports.hexToBigInt = exports.convertBigIntArrToHexArr = exports.convertHexArrToBigIntArr = void 0;
const paillier_bigint_1 = require("paillier-bigint");
const bigint_crypto_utils_1 = require("bigint-crypto-utils");
const bigint_mod_arith_1 = require("bigint-mod-arith");
const crypto_1 = __importDefault(require("crypto"));
/**
 * Returns a bigint array from a hex string array
 * @param values
 */
function convertHexArrToBigIntArr(values) {
    return values.map((value) => {
        return hexToBigInt(value);
    });
}
exports.convertHexArrToBigIntArr = convertHexArrToBigIntArr;
/**
 * Returns a hex string array from a bigint array
 * @param values
 * @param hexLength - length to pad each big int number too
 */
function convertBigIntArrToHexArr(values, hexLength) {
    return values.map((value) => {
        return bigIntToHex(value, hexLength);
    });
}
exports.convertBigIntArrToHexArr = convertBigIntArrToHexArr;
function hexToBigInt(hex) {
    // Strangely bigint.toString(16) gives a hex string without 0x,
    // but it won't accept the same string without 0x to convert
    // to a bigint (BigInt(hex string)). So have to introduce this
    // check to convert to add 0x in case if hex string
    // doesn't have it.
    if (hex.slice(0, 2) === '0x') {
        return BigInt(hex);
    }
    return BigInt('0x' + hex);
}
exports.hexToBigInt = hexToBigInt;
/**
 * Returns an hex string of the given bigint
 *
 * @param {bigint} bigint - the bigint to be converted to hex
 * @param hexLength
 * @returns {string} - the hex value
 */
function bigIntToHex(bigint, hexLength) {
    let hex = bigint.toString(16);
    hex = '0'.slice(0, hex.length % 2) + hex;
    if (hexLength) {
        hex = hex.padStart(hexLength, '0');
    }
    return hex;
}
exports.bigIntToHex = bigIntToHex;
function bigIntToBufferLE(n, minBytes) {
    let v = n.toString(16);
    v = '0'.slice(0, v.length % 2) + v;
    const buf = Buffer.from(v, 'hex').reverse();
    if (minBytes && buf.length < minBytes) {
        return Buffer.concat([buf, Buffer.alloc(minBytes - buf.length)]);
    }
    return buf;
}
exports.bigIntToBufferLE = bigIntToBufferLE;
function bigIntFromBufferLE(buf) {
    return BigInt('0x' + Buffer.from(buf).reverse().toString('hex'));
}
exports.bigIntFromBufferLE = bigIntFromBufferLE;
function bigIntToBufferBE(n, minBytes) {
    let v = n.toString(16);
    v = '0'.slice(0, v.length % 2) + v;
    const buf = Buffer.from(v, 'hex');
    if (minBytes && buf.length < minBytes) {
        return Buffer.concat([Buffer.alloc(minBytes - buf.length), buf]);
    }
    return buf;
}
exports.bigIntToBufferBE = bigIntToBufferBE;
function bigIntFromBufferBE(buf) {
    return BigInt('0x' + buf.toString('hex'));
}
exports.bigIntFromBufferBE = bigIntFromBufferBE;
function bigIntFromU8ABE(buf) {
    return bigIntFromBufferBE(Buffer.from(buf));
}
exports.bigIntFromU8ABE = bigIntFromU8ABE;
function clamp(u) {
    u &= BigInt('0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8');
    u |= BigInt('0x4000000000000000000000000000000000000000000000000000000000000000');
    return u;
}
exports.clamp = clamp;
/**
 * Function get paillier public key simple varient
 * @param {bigint} n
 * @returns {bigint}
 */
function getPaillierPublicKey(n) {
    return new paillier_bigint_1.PublicKey(n, n + BigInt(1));
}
exports.getPaillierPublicKey = getPaillierPublicKey;
/**
 * Generate a random positive integer co-prime to x
 * @param x
 * @returns {Promise<bigint>}
 */
async function randomPositiveCoPrimeTo(x) {
    while (true) {
        const y = await randomBigInt((0, bigint_crypto_utils_1.bitLength)(x));
        if (y > BigInt(0) && (0, bigint_mod_arith_1.gcd)(x, y) === BigInt(1)) {
            return y;
        }
    }
}
exports.randomPositiveCoPrimeTo = randomPositiveCoPrimeTo;
/**
 * Generate a random positive integer coprime less than x with the same bit depth.
 * @param x
 * @returns {Promise<bigint>}
 */
async function randomPositiveCoPrimeLessThan(x) {
    if (x <= BigInt(2)) {
        throw new Error('x must be larger than 2');
    }
    while (true) {
        const y = await randomBigInt((0, bigint_crypto_utils_1.bitLength)(x));
        if (y > BigInt(0) && y < x && (0, bigint_mod_arith_1.gcd)(x, y) === BigInt(1)) {
            return y;
        }
    }
}
exports.randomPositiveCoPrimeLessThan = randomPositiveCoPrimeLessThan;
/**
 * Generate a random number of a given bitlength
 * @param bitlength
 * @returns {Promise<bigint>}
 */
async function randomBigInt(bitlength) {
    return bigIntFromBufferBE(Buffer.from(await (0, bigint_crypto_utils_1.randBits)(bitlength, true)));
}
exports.randomBigInt = randomBigInt;
/**
 * @param seed - used to construct derivation path deterministically
 * @param isMaster - if set, path starts with prefix `m/`
 * @return path `(m/)/999999/a/b` where `a` and `b` are 7-byte pseudorandom numbers based on seed
 */
function getDerivationPath(seed, isMaster = true) {
    const derivationPathInput = sha256(sha256(`${seed}`)).toString('hex');
    const derivationPathParts = [
        parseInt(derivationPathInput.slice(0, 7), 16),
        parseInt(derivationPathInput.slice(7, 14), 16),
    ];
    const prefix = isMaster ? 'm/' : '';
    return prefix + '999999/' + derivationPathParts.join('/');
}
exports.getDerivationPath = getDerivationPath;
function sha256(input) {
    return crypto_1.default.createHash('sha256').update(input).digest();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHFEQUE0QztBQUM1Qyw2REFBMEQ7QUFDMUQsdURBQXVDO0FBQ3ZDLG9EQUE0QjtBQUU1Qjs7O0dBR0c7QUFDSCxTQUFnQix3QkFBd0IsQ0FBQyxNQUFnQjtJQUN2RCxPQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtRQUMxQixPQUFPLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1QixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFKRCw0REFJQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQix3QkFBd0IsQ0FBQyxNQUFnQixFQUFFLFNBQWtCO0lBQzNFLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFO1FBQzFCLE9BQU8sV0FBVyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQztJQUN2QyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFKRCw0REFJQztBQUVELFNBQWdCLFdBQVcsQ0FBQyxHQUFXO0lBQ3JDLCtEQUErRDtJQUMvRCw0REFBNEQ7SUFDNUQsOERBQThEO0lBQzlELG1EQUFtRDtJQUNuRCxtQkFBbUI7SUFDbkIsSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUU7UUFDNUIsT0FBTyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDcEI7SUFDRCxPQUFPLE1BQU0sQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7QUFDNUIsQ0FBQztBQVZELGtDQVVDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsV0FBVyxDQUFDLE1BQWMsRUFBRSxTQUFrQjtJQUM1RCxJQUFJLEdBQUcsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzlC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MUUsQ0FBQztBQUZELG9DQUVDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLGlCQUFpQixDQUFDLElBQVksRUFBRSxRQUFRLEdBQUcsSUFBSTtJQUM3RCxNQUFNLG1CQUFtQixHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3RFLE1BQU0sbUJBQW1CLEdBQUc7UUFDMUIsUUFBUSxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQzdDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztLQUMvQyxDQUFDO0lBQ0YsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUNwQyxPQUFPLE1BQU0sR0FBRyxTQUFTLEdBQUcsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzVELENBQUM7QUFSRCw4Q0FRQztBQUVELFNBQVMsTUFBTSxDQUFDLEtBQXdCO0lBQ3RDLE9BQU8sZ0JBQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQzVELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdwYWlsbGllci1iaWdpbnQnO1xuaW1wb3J0IHsgYml0TGVuZ3RoLCByYW5kQml0cyB9IGZyb20gJ2JpZ2ludC1jcnlwdG8tdXRpbHMnO1xuaW1wb3J0IHsgZ2NkIH0gZnJvbSAnYmlnaW50LW1vZC1hcml0aCc7XG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbi8qKlxuICogUmV0dXJucyBhIGJpZ2ludCBhcnJheSBmcm9tIGEgaGV4IHN0cmluZyBhcnJheVxuICogQHBhcmFtIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydEhleEFyclRvQmlnSW50QXJyKHZhbHVlczogc3RyaW5nW10pOiBiaWdpbnRbXSB7XG4gIHJldHVybiB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBoZXhUb0JpZ0ludCh2YWx1ZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBoZXggc3RyaW5nIGFycmF5IGZyb20gYSBiaWdpbnQgYXJyYXlcbiAqIEBwYXJhbSB2YWx1ZXNcbiAqIEBwYXJhbSBoZXhMZW5ndGggLSBsZW5ndGggdG8gcGFkIGVhY2ggYmlnIGludCBudW1iZXIgdG9vXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0QmlnSW50QXJyVG9IZXhBcnIodmFsdWVzOiBiaWdpbnRbXSwgaGV4TGVuZ3RoPzogbnVtYmVyKTogc3RyaW5nW10ge1xuICByZXR1cm4gdmFsdWVzLm1hcCgodmFsdWUpID0+IHtcbiAgICByZXR1cm4gYmlnSW50VG9IZXgodmFsdWUsIGhleExlbmd0aCk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CaWdJbnQoaGV4OiBzdHJpbmcpOiBiaWdpbnQge1xuICAvLyBTdHJhbmdlbHkgYmlnaW50LnRvU3RyaW5nKDE2KSBnaXZlcyBhIGhleCBzdHJpbmcgd2l0aG91dCAweCxcbiAgLy8gYnV0IGl0IHdvbid0IGFjY2VwdCB0aGUgc2FtZSBzdHJpbmcgd2l0aG91dCAweCB0byBjb252ZXJ0XG4gIC8vIHRvIGEgYmlnaW50IChCaWdJbnQoaGV4IHN0cmluZykpLiBTbyBoYXZlIHRvIGludHJvZHVjZSB0aGlzXG4gIC8vIGNoZWNrIHRvIGNvbnZlcnQgdG8gYWRkIDB4IGluIGNhc2UgaWYgaGV4IHN0cmluZ1xuICAvLyBkb2Vzbid0IGhhdmUgaXQuXG4gIGlmIChoZXguc2xpY2UoMCwgMikgPT09ICcweCcpIHtcbiAgICByZXR1cm4gQmlnSW50KGhleCk7XG4gIH1cbiAgcmV0dXJuIEJpZ0ludCgnMHgnICsgaGV4KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGhleCBzdHJpbmcgb2YgdGhlIGdpdmVuIGJpZ2ludFxuICpcbiAqIEBwYXJhbSB7YmlnaW50fSBiaWdpbnQgLSB0aGUgYmlnaW50IHRvIGJlIGNvbnZlcnRlZCB0byBoZXhcbiAqIEBwYXJhbSBoZXhMZW5ndGhcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGhleCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmlnSW50VG9IZXgoYmlnaW50OiBiaWdpbnQsIGhleExlbmd0aD86IG51bWJlcik6IHN0cmluZyB7XG4gIGxldCBoZXggPSBiaWdpbnQudG9TdHJpbmcoMTYpO1xuICBoZXggPSAnMCcuc2xpY2UoMCwgaGV4Lmxlbmd0aCAlIDIpICsgaGV4O1xuICBpZiAoaGV4TGVuZ3RoKSB7XG4gICAgaGV4ID0gaGV4LnBhZFN0YXJ0KGhleExlbmd0aCwgJzAnKTtcbiAgfVxuICByZXR1cm4gaGV4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmlnSW50VG9CdWZmZXJMRShuOiBiaWdpbnQsIG1pbkJ5dGVzPzogbnVtYmVyKTogQnVmZmVyIHtcbiAgbGV0IHYgPSBuLnRvU3RyaW5nKDE2KTtcbiAgdiA9ICcwJy5zbGljZSgwLCB2Lmxlbmd0aCAlIDIpICsgdjtcbiAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20odiwgJ2hleCcpLnJldmVyc2UoKTtcbiAgaWYgKG1pbkJ5dGVzICYmIGJ1Zi5sZW5ndGggPCBtaW5CeXRlcykge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtidWYsIEJ1ZmZlci5hbGxvYyhtaW5CeXRlcyAtIGJ1Zi5sZW5ndGgpXSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpZ0ludEZyb21CdWZmZXJMRShidWY6IEJ1ZmZlcik6IGJpZ2ludCB7XG4gIHJldHVybiBCaWdJbnQoJzB4JyArIEJ1ZmZlci5mcm9tKGJ1ZikucmV2ZXJzZSgpLnRvU3RyaW5nKCdoZXgnKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiaWdJbnRUb0J1ZmZlckJFKG46IGJpZ2ludCwgbWluQnl0ZXM/OiBudW1iZXIpOiBCdWZmZXIge1xuICBsZXQgdiA9IG4udG9TdHJpbmcoMTYpO1xuICB2ID0gJzAnLnNsaWNlKDAsIHYubGVuZ3RoICUgMikgKyB2O1xuICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbSh2LCAnaGV4Jyk7XG4gIGlmIChtaW5CeXRlcyAmJiBidWYubGVuZ3RoIDwgbWluQnl0ZXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmFsbG9jKG1pbkJ5dGVzIC0gYnVmLmxlbmd0aCksIGJ1Zl0pO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiaWdJbnRGcm9tQnVmZmVyQkUoYnVmOiBCdWZmZXIpOiBiaWdpbnQge1xuICByZXR1cm4gQmlnSW50KCcweCcgKyBidWYudG9TdHJpbmcoJ2hleCcpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpZ0ludEZyb21VOEFCRShidWY6IFVpbnQ4QXJyYXkpOiBiaWdpbnQge1xuICByZXR1cm4gYmlnSW50RnJvbUJ1ZmZlckJFKEJ1ZmZlci5mcm9tKGJ1ZikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xhbXAodTogYmlnaW50KTogYmlnaW50IHtcbiAgdSAmPSBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmOCcpO1xuICB1IHw9IEJpZ0ludCgnMHg0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7XG4gIHJldHVybiB1O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGdldCBwYWlsbGllciBwdWJsaWMga2V5IHNpbXBsZSB2YXJpZW50XG4gKiBAcGFyYW0ge2JpZ2ludH0gblxuICogQHJldHVybnMge2JpZ2ludH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBhaWxsaWVyUHVibGljS2V5KG46IGJpZ2ludCk6IFB1YmxpY0tleSB7XG4gIHJldHVybiBuZXcgUHVibGljS2V5KG4sIG4gKyBCaWdJbnQoMSkpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIHBvc2l0aXZlIGludGVnZXIgY28tcHJpbWUgdG8geFxuICogQHBhcmFtIHhcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJpZ2ludD59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByYW5kb21Qb3NpdGl2ZUNvUHJpbWVUbyh4OiBiaWdpbnQpOiBQcm9taXNlPGJpZ2ludD4ge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHkgPSBhd2FpdCByYW5kb21CaWdJbnQoYml0TGVuZ3RoKHgpKTtcbiAgICBpZiAoeSA+IEJpZ0ludCgwKSAmJiBnY2QoeCwgeSkgPT09IEJpZ0ludCgxKSkge1xuICAgICAgcmV0dXJuIHk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSByYW5kb20gcG9zaXRpdmUgaW50ZWdlciBjb3ByaW1lIGxlc3MgdGhhbiB4IHdpdGggdGhlIHNhbWUgYml0IGRlcHRoLlxuICogQHBhcmFtIHhcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJpZ2ludD59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByYW5kb21Qb3NpdGl2ZUNvUHJpbWVMZXNzVGhhbih4OiBiaWdpbnQpOiBQcm9taXNlPGJpZ2ludD4ge1xuICBpZiAoeCA8PSBCaWdJbnQoMikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggbXVzdCBiZSBsYXJnZXIgdGhhbiAyJyk7XG4gIH1cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB5ID0gYXdhaXQgcmFuZG9tQmlnSW50KGJpdExlbmd0aCh4KSk7XG4gICAgaWYgKHkgPiBCaWdJbnQoMCkgJiYgeSA8IHggJiYgZ2NkKHgsIHkpID09PSBCaWdJbnQoMSkpIHtcbiAgICAgIHJldHVybiB5O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciBvZiBhIGdpdmVuIGJpdGxlbmd0aFxuICogQHBhcmFtIGJpdGxlbmd0aFxuICogQHJldHVybnMge1Byb21pc2U8YmlnaW50Pn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJhbmRvbUJpZ0ludChiaXRsZW5ndGg6IG51bWJlcik6IFByb21pc2U8YmlnaW50PiB7XG4gIHJldHVybiBiaWdJbnRGcm9tQnVmZmVyQkUoQnVmZmVyLmZyb20oYXdhaXQgcmFuZEJpdHMoYml0bGVuZ3RoLCB0cnVlKSkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSBzZWVkIC0gdXNlZCB0byBjb25zdHJ1Y3QgZGVyaXZhdGlvbiBwYXRoIGRldGVybWluaXN0aWNhbGx5XG4gKiBAcGFyYW0gaXNNYXN0ZXIgLSBpZiBzZXQsIHBhdGggc3RhcnRzIHdpdGggcHJlZml4IGBtL2BcbiAqIEByZXR1cm4gcGF0aCBgKG0vKS85OTk5OTkvYS9iYCB3aGVyZSBgYWAgYW5kIGBiYCBhcmUgNy1ieXRlIHBzZXVkb3JhbmRvbSBudW1iZXJzIGJhc2VkIG9uIHNlZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERlcml2YXRpb25QYXRoKHNlZWQ6IHN0cmluZywgaXNNYXN0ZXIgPSB0cnVlKTogc3RyaW5nIHtcbiAgY29uc3QgZGVyaXZhdGlvblBhdGhJbnB1dCA9IHNoYTI1NihzaGEyNTYoYCR7c2VlZH1gKSkudG9TdHJpbmcoJ2hleCcpO1xuICBjb25zdCBkZXJpdmF0aW9uUGF0aFBhcnRzID0gW1xuICAgIHBhcnNlSW50KGRlcml2YXRpb25QYXRoSW5wdXQuc2xpY2UoMCwgNyksIDE2KSxcbiAgICBwYXJzZUludChkZXJpdmF0aW9uUGF0aElucHV0LnNsaWNlKDcsIDE0KSwgMTYpLFxuICBdO1xuICBjb25zdCBwcmVmaXggPSBpc01hc3RlciA/ICdtLycgOiAnJztcbiAgcmV0dXJuIHByZWZpeCArICc5OTk5OTkvJyArIGRlcml2YXRpb25QYXRoUGFydHMuam9pbignLycpO1xufVxuXG5mdW5jdGlvbiBzaGEyNTYoaW5wdXQ6IGNyeXB0by5CaW5hcnlMaWtlKTogQnVmZmVyIHtcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoaW5wdXQpLmRpZ2VzdCgpO1xufVxuIl19