"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ed25519Curve = void 0;
const libsodium_wrappers_sumo_1 = __importDefault(require("libsodium-wrappers-sumo"));
const crypto_1 = require("crypto");
const util_1 = require("../util");
const privateKeySize = 32;
const publicKeySize = 32;
class Ed25519Curve {
    constructor() {
        this.scalarBytes = privateKeySize;
        this.pointBytes = publicKeySize;
    }
    static async initialize() {
        if (!Ed25519Curve.initialized) {
            await libsodium_wrappers_sumo_1.default.ready;
            Ed25519Curve.initialized = true;
        }
        return new Ed25519Curve();
    }
    scalarRandom() {
        return (0, util_1.bigIntFromBufferLE)(Buffer.from(libsodium_wrappers_sumo_1.default.crypto_core_ed25519_scalar_reduce((0, util_1.bigIntFromBufferLE)((0, crypto_1.randomBytes)(64)))));
    }
    scalarReduce(s) {
        return (0, util_1.bigIntFromBufferLE)(Buffer.from(libsodium_wrappers_sumo_1.default.crypto_core_ed25519_scalar_reduce((0, util_1.bigIntToBufferLE)(s, 64))));
    }
    scalarNegate(s) {
        return (0, util_1.bigIntFromBufferLE)(Buffer.from(libsodium_wrappers_sumo_1.default.crypto_core_ed25519_scalar_negate((0, util_1.bigIntToBufferLE)(s, privateKeySize))));
    }
    scalarInvert(s) {
        return (0, util_1.bigIntFromBufferLE)(Buffer.from(libsodium_wrappers_sumo_1.default.crypto_core_ed25519_scalar_invert((0, util_1.bigIntToBufferLE)(s, privateKeySize))));
    }
    scalarAdd(x, y) {
        return (0, util_1.bigIntFromBufferLE)(Buffer.from(libsodium_wrappers_sumo_1.default.crypto_core_ed25519_scalar_add((0, util_1.bigIntToBufferLE)(x, privateKeySize), (0, util_1.bigIntToBufferLE)(y, privateKeySize))));
    }
    scalarSub(x, y) {
        return (0, util_1.bigIntFromBufferLE)(Buffer.from(libsodium_wrappers_sumo_1.default.crypto_core_ed25519_scalar_sub((0, util_1.bigIntToBufferLE)(x, privateKeySize), (0, util_1.bigIntToBufferLE)(y, privateKeySize))));
    }
    scalarMult(x, y) {
        return (0, util_1.bigIntFromBufferLE)(Buffer.from(libsodium_wrappers_sumo_1.default.crypto_core_ed25519_scalar_mul((0, util_1.bigIntToBufferLE)(x, privateKeySize), (0, util_1.bigIntToBufferLE)(y, privateKeySize))));
    }
    basePointMult(n) {
        return (0, util_1.bigIntFromBufferLE)(Buffer.from(libsodium_wrappers_sumo_1.default.crypto_scalarmult_ed25519_base_noclamp((0, util_1.bigIntToBufferLE)(n, privateKeySize))));
    }
    pointAdd(p, q) {
        return (0, util_1.bigIntFromBufferLE)(Buffer.from(libsodium_wrappers_sumo_1.default.crypto_core_ed25519_add((0, util_1.bigIntToBufferLE)(p, publicKeySize), (0, util_1.bigIntToBufferLE)(q, publicKeySize))));
    }
    pointMultiply(p, s) {
        return (0, util_1.bigIntFromBufferLE)(Buffer.from(libsodium_wrappers_sumo_1.default.crypto_scalarmult_ed25519_noclamp((0, util_1.bigIntToBufferLE)(s, publicKeySize), (0, util_1.bigIntToBufferLE)(p, publicKeySize))));
    }
    verify(message, signature, publicKey) {
        const signedMessage = Buffer.concat([signature, message]);
        try {
            // Returns the message which was signed if the signature is valid
            const result = Buffer.from(libsodium_wrappers_sumo_1.default.crypto_sign_open(signedMessage, (0, util_1.bigIntToBufferLE)(publicKey, publicKeySize)));
            return Buffer.compare(message, result) === 0;
        }
        catch (error) {
            // Invalid signature causes an exception
            return false;
        }
    }
    order() {
        return BigInt('0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed') * BigInt('0x08');
    }
}
exports.Ed25519Curve = Ed25519Curve;
Ed25519Curve.initialized = false;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWQyNTUxOS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jdXJ2ZXMvZWQyNTUxOS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxzRkFBNkM7QUFDN0MsbUNBQXFDO0FBQ3JDLGtDQUErRDtBQUcvRCxNQUFNLGNBQWMsR0FBRyxFQUFFLENBQUM7QUFDMUIsTUFBTSxhQUFhLEdBQUcsRUFBRSxDQUFDO0FBRXpCLE1BQWEsWUFBWTtJQUF6QjtRQWdHRSxnQkFBVyxHQUFHLGNBQWMsQ0FBQztRQUU3QixlQUFVLEdBQUcsYUFBYSxDQUFDO0lBQzdCLENBQUM7SUFoR0MsTUFBTSxDQUFDLEtBQUssQ0FBQyxVQUFVO1FBQ3JCLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFO1lBQzdCLE1BQU0saUNBQU0sQ0FBQyxLQUFLLENBQUM7WUFDbkIsWUFBWSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7U0FDakM7UUFFRCxPQUFPLElBQUksWUFBWSxFQUFFLENBQUM7SUFDNUIsQ0FBQztJQUVELFlBQVk7UUFDVixPQUFPLElBQUEseUJBQWtCLEVBQ3ZCLE1BQU0sQ0FBQyxJQUFJLENBQUMsaUNBQU0sQ0FBQyxpQ0FBaUMsQ0FBQyxJQUFBLHlCQUFrQixFQUFDLElBQUEsb0JBQVcsRUFBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDM0YsQ0FBQztJQUNKLENBQUM7SUFFRCxZQUFZLENBQUMsQ0FBUztRQUNwQixPQUFPLElBQUEseUJBQWtCLEVBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxpQ0FBTSxDQUFDLGlDQUFpQyxDQUFDLElBQUEsdUJBQWdCLEVBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVHLENBQUM7SUFFRCxZQUFZLENBQUMsQ0FBUztRQUNwQixPQUFPLElBQUEseUJBQWtCLEVBQ3ZCLE1BQU0sQ0FBQyxJQUFJLENBQUMsaUNBQU0sQ0FBQyxpQ0FBaUMsQ0FB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QUFLLEVBQUU7WUFDZCx3Q0FBd0M7WUFDeEMsT0FBTyxLQUFLLENBQUM7U0FDZDtJQUNILENBQUM7SUFFRCxLQUFLO1FBQ0gsT0FBTyxNQUFNLENBQUMsb0VBQW9FLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdkcsQ0FBQzs7QUE5Rkgsb0NBbUdDO0FBbEdRLHdCQUFXLEdBQUcsS0FBSyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNvZGl1bSBmcm9tICdsaWJzb2RpdW0td3JhcHBlcnMtc3Vtbyc7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBiaWdJbnRGcm9tQnVmZmVyTEUsIGJpZ0ludFRvQnVmZmVyTEUgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB7IEJhc2VDdXJ2ZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBwcml2YXRlS2V5U2l6ZSA9IDMyO1xuY29uc3QgcHVibGljS2V5U2l6ZSA9IDMyO1xuXG5leHBvcnQgY2xhc3MgRWQyNTUxOUN1cnZlIGltcGxlbWVudHMgQmFzZUN1cnZlIHtcbiAgc3RhdGljIGluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgc3RhdGljIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTxFZDI1NTE5Q3VydmU+IHtcbiAgICBpZiAoIUVkMjU1MTlDdXJ2ZS5pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgc29kaXVtLnJlYWR5O1xuICAgICAgRWQyNTUxOUN1cnZlLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEVkMjU1MTlDdXJ2ZSgpO1xuICB9XG5cbiAgc2NhbGFyUmFuZG9tKCk6IGJpZ2ludCB7XG4gICAgcmV0dXJuIGJpZ0ludEZyb21CdWZmZXJMRShcbiAgICAgIEJ1ZmZlci5mcm9tKHNvZGl1bS5jcnlwdG9fY29yZV9lZDI1NTE5X3NjYWxhcl9yZWR1Y2UoYmlnSW50RnJvbUJ1ZmZlckxFKHJhbmRvbUJ5dGVzKDY0KSkpKVxuICAgICk7XG4gIH1cblxuICBzY2FsYXJSZWR1Y2UoczogYmlnaW50KTogYmlnaW50IHtcbiAgICByZXR1cm4gYmlnSW50RnJvbUJ1ZmZlckxFKEJ1ZmZlci5mcm9tKHNvZGl1bS5jcnlwdG9fY29yZV9lZDI1NTE5X3NjYWxhcl9yZWR1Y2UoYmlnSW50VG9CdWZmZXJMRShzLCA2NCkpKSk7XG4gIH1cblxuICBzY2FsYXJOZWdhdGUoczogYmlnaW50KTogYmlnaW50IHtcbiAgICByZXR1cm4gYmlnSW50RnJvbUJ1ZmZlckxFKFxuICAgICAgQnVmZmVyLmZyb20oc29kaXVtLmNyeXB0b19jb3JlX2VkMjU1MTlfc2NhbGFyX25lZ2F0ZShiaWdJbnRUb0J1ZmZlckxFKHMsIHByaXZhdGVLZXlTaXplKSkpXG4gICAgKTtcbiAgfVxuXG4gIHNjYWxhckludmVydChzOiBiaWdpbnQpOiBiaWdpbnQge1xuICAgIHJldHVybiBiaWdJbnRGcm9tQnVmZmVyTEUoXG4gICAgICBCdWZmZXIuZnJvbShzb2RpdW0uY3J5cHRvX2NvcmVfZWQyNTUxOV9zY2FsYXJfaW52ZXJ0KGJpZ0ludFRvQnVmZmVyTEUocywgcHJpdmF0ZUtleVNpemUpKSlcbiAgICApO1xuICB9XG5cbiAgc2NhbGFyQWRkKHg6IGJpZ2ludCwgeTogYmlnaW50KTogYmlnaW50IHtcbiAgICByZXR1cm4gYmlnSW50RnJvbUJ1ZmZlckxFKFxuICAgICAgQnVmZmVyLmZyb20oXG4gICAgICAgIHNvZGl1bS5jcnlwdG9fY29yZV9lZDI1NTE5X3NjYWxhcl9hZGQoYmlnSW50VG9CdWZmZXJMRSh4LCBwcml2YXRlS2V5U2l6ZSksIGJpZ0ludFRvQnVmZmVyTEUoeSwgcHJpdmF0ZUtleVNpemUpKVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBzY2FsYXJTdWIoeDogYmlnaW50LCB5OiBiaWdpbnQpOiBiaWdpbnQge1xuICAgIHJldHVybiBiaWdJbnRGcm9tQnVmZmVyTEUoXG4gICAgICBCdWZmZXIuZnJvbShcbiAgICAgICAgc29kaXVtLmNyeXB0b19jb3JlX2VkMjU1MTlfc2NhbGFyX3N1YihiaWdJbnRUb0J1ZmZlckxFKHgsIHByaXZhdGVLZXlTaXplKSwgYmlnSW50VG9CdWZmZXJMRSh5LCBwcml2YXRlS2V5U2l6ZSkpXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIHNjYWxhck11bHQoeDogYmlnaW50LCB5OiBiaWdpbnQpOiBiaWdpbnQge1xuICAgIHJldHVybiBiaWdJbnRGcm9tQnVmZmVyTEUoXG4gICAgICBCdWZmZXIuZnJvbShcbiAgICAgICAgc29kaXVtLmNyeXB0b19jb3JlX2VkMjU1MTlfc2NhbGFyX211bChiaWdJbnRUb0J1ZmZlckxFKHgsIHByaXZhdGVLZXlTaXplKSwgYmlnSW50VG9CdWZmZXJMRSh5LCBwcml2YXRlS2V5U2l6ZSkpXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIGJhc2VQb2ludE11bHQobjogYmlnaW50KTogYmlnaW50IHtcbiAgICByZXR1cm4gYmlnSW50RnJvbUJ1ZmZlckxFKFxuICAgICAgQnVmZmVyLmZyb20oc29kaXVtLmNyeXB0b19zY2FsYXJtdWx0X2VkMjU1MTlfYmFzZV9ub2NsYW1wKGJpZ0ludFRvQnVmZmVyTEUobiwgcHJpdmF0ZUtleVNpemUpKSlcbiAgICApO1xuICB9XG5cbiAgcG9pbnRBZGQocDogYmlnaW50LCBxOiBiaWdpbnQpOiBiaWdpbnQge1xuICAgIHJldHVybiBiaWdJbnRGcm9tQnVmZmVyTEUoXG4gICAgICBCdWZmZXIuZnJvbShcbiAgICAgICAgc29kaXVtLmNyeXB0b19jb3JlX2VkMjU1MTlfYWRkKGJpZ0ludFRvQnVmZmVyTEUocCwgcHVibGljS2V5U2l6ZSksIGJpZ0ludFRvQnVmZmVyTEUocSwgcHVibGljS2V5U2l6ZSkpXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIHBvaW50TXVsdGlwbHkocDogYmlnaW50LCBzOiBiaWdpbnQpOiBiaWdpbnQge1xuICAgIHJldHVybiBiaWdJbnRGcm9tQnVmZmVyTEUoXG4gICAgICBCdWZmZXIuZnJvbShcbiAgICAgICAgc29kaXVtLmNyeXB0b19zY2FsYXJtdWx0X2VkMjU1MTlfbm9jbGFtcChiaWdJbnRUb0J1ZmZlckxFKHMsIHB1YmxpY0tleVNpemUpLCBiaWdJbnRUb0J1ZmZlckxFKHAsIHB1YmxpY0tleVNpemUpKVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICB2ZXJpZnkobWVzc2FnZTogQnVmZmVyLCBzaWduYXR1cmU6IEJ1ZmZlciwgcHVibGljS2V5OiBiaWdpbnQpOiBib29sZWFuIHtcbiAgICBjb25zdCBzaWduZWRNZXNzYWdlID0gQnVmZmVyLmNvbmNhdChbc2lnbmF0dXJlLCBtZXNzYWdlXSk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFJldHVybnMgdGhlIG1lc3NhZ2Ugd2hpY2ggd2FzIHNpZ25lZCBpZiB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkXG4gICAgICBjb25zdCByZXN1bHQgPSBCdWZmZXIuZnJvbShzb2RpdW0uY3J5cHRvX3NpZ25fb3BlbihzaWduZWRNZXNzYWdlLCBiaWdJbnRUb0J1ZmZlckxFKHB1YmxpY0tleSwgcHVibGljS2V5U2l6ZSkpKTtcbiAgICAgIHJldHVybiBCdWZmZXIuY29tcGFyZShtZXNzYWdlLCByZXN1bHQpID09PSAwO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJbnZhbGlkIHNpZ25hdHVyZSBjYXVzZXMgYW4gZXhjZXB0aW9uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgb3JkZXIoKTogYmlnaW50IHtcbiAgICByZXR1cm4gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTRkZWY5ZGVhMmY3OWNkNjU4MTI2MzFhNWNmNWQzZWQnKSAqIEJpZ0ludCgnMHgwOCcpO1xuICB9XG5cbiAgc2NhbGFyQnl0ZXMgPSBwcml2YXRlS2V5U2l6ZTtcblxuICBwb2ludEJ5dGVzID0gcHVibGljS2V5U2l6ZTtcbn1cbiJdfQ==