"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyCommitment = exports.createCommitment = void 0;
const crypto_1 = require("crypto");
const util_1 = require("./util");
const minRandomnessLength = 32;
/**
 * Create hash commitment and decommietment of a secret value.
 * @param secret The secret value/message.
 * @param r The randomness/nonce to be added to the commmitment.
 * @returns The created commitment and decommitment.
 */
function createCommitment(secret, r = (0, crypto_1.randomBytes)(minRandomnessLength)) {
    if (r.length < minRandomnessLength) {
        throw new Error(`randomness must be at least ${minRandomnessLength} bytes long`);
    }
    return {
        commitment: hash(secret, r),
        decommitment: {
            blindingFactor: r,
            secret: secret,
        },
    };
}
exports.createCommitment = createCommitment;
const bytesPerUint32 = 4;
function hash(secret, r) {
    return (0, crypto_1.createHash)('sha256')
        .update((0, util_1.bigIntToBufferBE)(BigInt(secret.length), bytesPerUint32))
        .update(secret)
        .update((0, util_1.bigIntToBufferBE)(BigInt(r.length), bytesPerUint32))
        .update(r)
        .digest();
}
/**
 * Verify hash commitment and decommietment of a secret value.
 * @param commitment The commitment.
 * @param decommietment The decommitment.
 * @returns True if verification succeeds.
 */
function verifyCommitment(commitment, decommietment) {
    return hash(decommietment.secret, decommietment.blindingFactor).compare(commitment) === 0;
}
exports.verifyCommitment = verifyCommitment;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFzaENvbW1pdG1lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaGFzaENvbW1pdG1lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsbUNBQWlEO0FBRWpELGlDQUEwQztBQUUxQyxNQUFNLG1CQUFtQixHQUFHLEVBQUUsQ0FBQztBQUUvQjs7Ozs7R0FLRztBQUNILFNBQWdCLGdCQUFnQixDQUFDLE1BQWMsRUFBRSxJQUFZLElBQUEsb0JBQVcsRUFBQyxtQkFBbUIsQ0FBQztJQUMzRixJQUFJLENBQUMsQ0FBQyxNQUFNLEdBQUcsbUJBQW1CLEVBQUU7UUFDbEMsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsbUJBQW1CLGFBQWEsQ0FBQyxDQUFDO0tBQ2xGO0lBQ0QsT0FBTztRQUNMLFVBQVUsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUMzQixZQUFZLEVBQUU7WUFDWixjQUFjLEVBQUUsQ0FBQztZQUNqQixNQUFNLEVBQUUsTUFBTTtTQUNmO0tBQ0YsQ0FBQztBQUNKLENBQUM7QUFYRCw0Q0FXQztBQUVELE1BQU0sY0FBYyxHQUFHLENBQUMsQ0FBQztBQUV6QixTQUFTLElBQUksQ0FBQyxNQUFjLEVBQUUsQ0FBUztJQUNyQyxPQUFPLElBQUEsbUJBQVUsRUFBQyxRQUFRLENBQUM7U0FDeEIsTUFBTSxDQUFDLElBQUEsdUJBQWdCLEVBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxjQUFjLENBQUMsQ0FBQztTQUMvRCxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQ2QsTUFBTSxDQUFDLElBQUEsdUJBQWdCLEVBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxjQUFjLENBQUMsQ0FBQztTQUMxRCxNQUFNLENBQUMsQ0FBQyxDQUFDO1NBQ1QsTUFBTSxFQUFFLENBQUM7QUFDZCxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixnQkFBZ0IsQ0FBQyxVQUFrQixFQUFFLGFBQStCO0lBQ2xGLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsYUFBYSxDQUFDLGNBQWMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDNUYsQ0FBQztBQUZELDRDQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlSGFzaCwgcmFuZG9tQnl0ZXMgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgSGFzaENvbW1pdERlY29tbWl0LCBIYXNoRGVjb21taXRtZW50IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBiaWdJbnRUb0J1ZmZlckJFIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3QgbWluUmFuZG9tbmVzc0xlbmd0aCA9IDMyO1xuXG4vKipcbiAqIENyZWF0ZSBoYXNoIGNvbW1pdG1lbnQgYW5kIGRlY29tbWlldG1lbnQgb2YgYSBzZWNyZXQgdmFsdWUuXG4gKiBAcGFyYW0gc2VjcmV0IFRoZSBzZWNyZXQgdmFsdWUvbWVzc2FnZS5cbiAqIEBwYXJhbSByIFRoZSByYW5kb21uZXNzL25vbmNlIHRvIGJlIGFkZGVkIHRvIHRoZSBjb21tbWl0bWVudC5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGNvbW1pdG1lbnQgYW5kIGRlY29tbWl0bWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbW1pdG1lbnQoc2VjcmV0OiBCdWZmZXIsIHI6IEJ1ZmZlciA9IHJhbmRvbUJ5dGVzKG1pblJhbmRvbW5lc3NMZW5ndGgpKTogSGFzaENvbW1pdERlY29tbWl0IHtcbiAgaWYgKHIubGVuZ3RoIDwgbWluUmFuZG9tbmVzc0xlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgcmFuZG9tbmVzcyBtdXN0IGJlIGF0IGxlYXN0ICR7bWluUmFuZG9tbmVzc0xlbmd0aH0gYnl0ZXMgbG9uZ2ApO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29tbWl0bWVudDogaGFzaChzZWNyZXQsIHIpLFxuICAgIGRlY29tbWl0bWVudDoge1xuICAgICAgYmxpbmRpbmdGYWN0b3I6IHIsXG4gICAgICBzZWNyZXQ6IHNlY3JldCxcbiAgICB9LFxuICB9O1xufVxuXG5jb25zdCBieXRlc1BlclVpbnQzMiA9IDQ7XG5cbmZ1bmN0aW9uIGhhc2goc2VjcmV0OiBCdWZmZXIsIHI6IEJ1ZmZlcik6IEJ1ZmZlciB7XG4gIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKVxuICAgIC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShCaWdJbnQoc2VjcmV0Lmxlbmd0aCksIGJ5dGVzUGVyVWludDMyKSlcbiAgICAudXBkYXRlKHNlY3JldClcbiAgICAudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUoQmlnSW50KHIubGVuZ3RoKSwgYnl0ZXNQZXJVaW50MzIpKVxuICAgIC51cGRhdGUocilcbiAgICAuZGlnZXN0KCk7XG59XG5cbi8qKlxuICogVmVyaWZ5IGhhc2ggY29tbWl0bWVudCBhbmQgZGVjb21taWV0bWVudCBvZiBhIHNlY3JldCB2YWx1ZS5cbiAqIEBwYXJhbSBjb21taXRtZW50IFRoZSBjb21taXRtZW50LlxuICogQHBhcmFtIGRlY29tbWlldG1lbnQgVGhlIGRlY29tbWl0bWVudC5cbiAqIEByZXR1cm5zIFRydWUgaWYgdmVyaWZpY2F0aW9uIHN1Y2NlZWRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5Q29tbWl0bWVudChjb21taXRtZW50OiBCdWZmZXIsIGRlY29tbWlldG1lbnQ6IEhhc2hEZWNvbW1pdG1lbnQpOiBib29sZWFuIHtcbiAgcmV0dXJuIGhhc2goZGVjb21taWV0bWVudC5zZWNyZXQsIGRlY29tbWlldG1lbnQuYmxpbmRpbmdGYWN0b3IpLmNvbXBhcmUoY29tbWl0bWVudCkgPT09IDA7XG59XG4iXX0=