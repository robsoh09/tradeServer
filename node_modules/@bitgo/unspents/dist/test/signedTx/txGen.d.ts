/// <reference types="node" />
import * as utxolib from '@bitgo/utxo-lib';
import { BIP32Interface } from '@bitgo/utxo-lib';
import 'lodash.combinations';
import { Dimensions } from '../../src';
import { InputScriptType, TestUnspentType } from '../testutils';
interface IUnspent {
    scriptPubKey: Buffer;
    redeemScript?: Buffer;
    witnessScript?: Buffer;
    value: number;
    inputType: utxolib.bitgo.outputScripts.ScriptType;
}
/**
 *
 * @param keys - Pubkeys to use for generating the address.
 *               If unspentType is one of UnspentTypePubKeyHash is used, the first key will be used.
 * @param unspentType {String} - one of UnspentTypeScript2of3 or UnspentTypePubKeyHash
 * @return {String} address
 */
export declare const createScriptPubKey: (keys: BIP32Interface[], unspentType: TestUnspentType) => Buffer;
declare class TxCombo {
    walletKeys: BIP32Interface[];
    inputTypes: string[];
    outputTypes: TestUnspentType[];
    expectedDims: Readonly<Dimensions>;
    signKeys?: utxolib.BIP32Interface[] | undefined;
    inputValue: number;
    unspents: IUnspent[];
    inputTx: any;
    constructor(walletKeys: BIP32Interface[], inputTypes: string[], outputTypes: TestUnspentType[], expectedDims?: Readonly<Dimensions>, signKeys?: utxolib.BIP32Interface[] | undefined, inputValue?: number);
    getBuilderWithUnsignedTx(): utxolib.bitgo.UtxoTransactionBuilder;
    getUnsignedTx(): utxolib.bitgo.UtxoTransaction;
    getSignedTx(): utxolib.Transaction;
}
declare const runCombinations: ({ inputTypes, maxNInputs, outputTypes, maxNOutputs, }: {
    inputTypes: InputScriptType[];
    maxNInputs: number;
    outputTypes: TestUnspentType[];
    maxNOutputs: number;
}, callback: (inputCombo: InputScriptType[], outputCombo: TestUnspentType[]) => void) => void;
declare class Histogram {
    map: Map<number, number>;
    total: number;
    constructor(map?: Map<number, number>);
    add(size: number): void;
    asSortedArray(): number[][];
    asFullSortedArray(): number[][];
    getPercentile(p: number): number;
    toString(): string;
}
/**
 *
 * Calls `callback` with a variety of signed txs, based on input parameters
 * Callback arguments are
 *   inputType, inputCount, outputType, txs
 *  where `txs` implements `forEach()`
 *
 * @param inputTypes - input types to test
 * @param nInputKeyTriplets - number of different input key triples to cycle through
 * @param outputTypes - output types to test
 * @param nOutputKeyTriplets - number of different output key triplets to cycle through
 * @param callback
 */
declare const runSignedTransactions: ({ inputTypes, nInputKeyTriplets, outputTypes, nOutputKeyTriplets, }: {
    inputTypes: Array<{
        inputType: string;
        count: number;
    }>;
    nInputKeyTriplets: number;
    outputTypes: TestUnspentType[];
    nOutputKeyTriplets: number;
}, callback: (inputType: string, inputCount: number, outputType: TestUnspentType, txs: any) => void) => void;
export { TxCombo, Histogram, runCombinations, runSignedTransactions };
//# sourceMappingURL=txGen.d.ts.map