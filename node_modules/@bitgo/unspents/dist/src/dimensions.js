"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dimensions = exports.OutputDimensions = exports.VirtualSizes = void 0;
const utxolib = __importStar(require("@bitgo/utxo-lib"));
const utxo_lib_1 = require("@bitgo/utxo-lib");
const { isChainCode, scriptTypeForChain } = utxo_lib_1.bitgo;
const scriptSizes_1 = require("./scriptSizes");
const types_1 = require("./types");
const virtualSizes_1 = require("./virtualSizes");
Object.defineProperty(exports, "VirtualSizes", { enumerable: true, get: function () { return virtualSizes_1.VirtualSizes; } });
/**
 * Apply `f` to all properties of `d`
 */
function mapDimensions(d, f) {
    return new Dimensions(Object.fromEntries(Object.entries(d).map(([key, value]) => [key, f(key, value)])));
}
/**
 * Aggregate count and size of transaction outputs
 */
class OutputDimensions {
    constructor({ count = 0, size = 0 } = { count: 0, size: 0 }) {
        if (count === 0 || size === 0) {
            if (count !== 0 || size !== 0) {
                throw new Error(`count and size must both be zero if one is zero`);
            }
        }
        this.count = count;
        this.size = size;
        Object.freeze(this);
    }
}
exports.OutputDimensions = OutputDimensions;
const defaultUnspentParams = {
    p2tr: {
        // Default to recovery script paths, to make it easier for recovery case callers (WRW etc).
        // WP can explicitly pass scriptPathLevel: 1 to use happy path.
        scriptPathLevel: 2,
    },
    p2trMusig2: {
        // Default to script path spend, to make it easier for recovery case callers (WRW etc).
        // WP can explicitly pass scriptPathLevel: undefined to use key path.
        scriptPathLevel: 1,
    },
};
/**
 * Dimensions of a BitGo wallet transactions.
 */
class Dimensions {
    constructor(d = {}) {
        /** Input counts for BitGo wallet multi-signature inputs */
        this.nP2shInputs = 0;
        this.nP2shP2wshInputs = 0;
        this.nP2wshInputs = 0;
        this.nP2trKeypathInputs = 0;
        this.nP2trScriptPathLevel1Inputs = 0;
        this.nP2trScriptPathLevel2Inputs = 0;
        /* Input count for single-signature inputs (Replay Protection inputs) */
        this.nP2shP2pkInputs = 0;
        this.outputs = new OutputDimensions();
        Object.entries(d).forEach(([key, value]) => this.setProperty(key, value));
        Object.freeze(this);
    }
    setProperty(k, v) {
        switch (k) {
            case 'nP2shInputs':
            case 'nP2shP2wshInputs':
            case 'nP2wshInputs':
            case 'nP2trKeypathInputs':
            case 'nP2trScriptPathLevel1Inputs':
            case 'nP2trScriptPathLevel2Inputs':
            case 'nP2shP2pkInputs':
                if (typeof v !== 'number') {
                    throw new Error(`property ${k} must be number`);
                }
                if (!Number.isSafeInteger(v) || v < 0) {
                    throw new Error(`property ${k} must be zero or positive integer`);
                }
                break;
            case 'outputs':
                if (!(v instanceof OutputDimensions)) {
                    v = new OutputDimensions(v);
                }
                break;
            default:
                throw new Error(`unknown property ${k}`);
        }
        this[k] = v;
    }
    /**
     * @deprecated use ZERO
     * @return Dimensions for an empty transaction
     */
    static zero() {
        return this.ZERO;
    }
    /**
     * @param size
     * @return Dimensions for a single output with given size
     */
    static singleOutput(size) {
        return Dimensions.sum({ outputs: { count: 1, size } });
    }
    /**
     * @return Number of total inputs (p2sh + p2shP2wsh + p2wsh + p2tr)
     */
    get nInputs() {
        return (this.nP2shInputs +
            this.nP2shP2wshInputs +
            this.nP2wshInputs +
            this.nP2trKeypathInputs +
            this.nP2trScriptPathLevel1Inputs +
            this.nP2trScriptPathLevel2Inputs +
            this.nP2shP2pkInputs);
    }
    set nInputs(_) {
        throw new Error('read-only property nInputs');
    }
    /**
     * @return Number of total outputs
     */
    get nOutputs() {
        return this.outputs.count;
    }
    set nOutputs(_) {
        throw new Error(`read-only property nOutputs`);
    }
    /**
     * @param args - Dimensions (can be partially defined)
     * @return {Dimensions} sum of arguments
     */
    static sum(...args) {
        return args.reduce((a, b) => a.plus(b), new Dimensions());
    }
    /**
     * @param chain
     * @return {Number}
     */
    static getOutputScriptLengthForChain(chain) {
        switch (scriptTypeForChain(chain)) {
            case 'p2wsh':
            case 'p2tr':
            case 'p2trMusig2':
                return 34;
            default:
                return 23;
        }
    }
    /**
     * @param scriptLength
     * @return {Number} vSize of an output with script length
     */
    static getVSizeForOutputWithScriptLength(scriptLength) {
        if (!types_1.PositiveInteger.is(scriptLength)) {
            throw new TypeError(`expected positive integer for scriptLength, got ${scriptLength}`);
        }
        return scriptLength + (0, scriptSizes_1.compactSize)(scriptLength) + virtualSizes_1.VirtualSizes.txOutputAmountSize;
    }
    /**
     * @return
     */
    static fromScriptType(scriptType, params = {}) {
        switch (scriptType) {
            case 'p2sh':
            case 'p2shP2wsh':
            case 'p2wsh':
            case 'p2shP2pk':
                return Dimensions.SingleInput[scriptType];
            case 'p2tr':
            case 'taprootScriptPathSpend':
                switch (params.scriptPathLevel) {
                    case 1:
                        return Dimensions.SingleInput.p2trScriptPathLevel1;
                    case 2:
                        return Dimensions.SingleInput.p2trScriptPathLevel2;
                    default:
                        throw new Error(`unexpected script path level`);
                }
            case 'p2trMusig2':
                switch (params.scriptPathLevel) {
                    case undefined:
                        return Dimensions.SingleInput.p2trKeypath;
                    case 1:
                        return Dimensions.SingleInput.p2trScriptPathLevel1;
                    default:
                        throw new Error(`unexpected script path level`);
                }
            case 'taprootKeyPathSpend':
                return Dimensions.SingleInput.p2trKeypath;
            default:
                throw new Error(`unexpected scriptType ${scriptType}`);
        }
    }
    static getAssumedDimension(params = {}, index) {
        const { assumeUnsigned } = params;
        if (!assumeUnsigned) {
            throw new Error(`illegal input ${index}: empty script and assumeUnsigned not set`);
        }
        return assumeUnsigned;
    }
    /**
     * @param input - the transaction input to count
     * @param params
     *        [param.assumeUnsigned] - default type for unsigned input
     */
    static fromInput(input, params = {}) {
        var _a, _b;
        if (((_a = input.script) === null || _a === void 0 ? void 0 : _a.length) || ((_b = input.witness) === null || _b === void 0 ? void 0 : _b.length)) {
            const parsed = utxolib.bitgo.parseSignatureScript(input);
            return Dimensions.fromScriptType(parsed.scriptType, parsed);
        }
        return Dimensions.getAssumedDimension(params, input.index);
    }
    /**
     * Create Dimensions from psbt input
     * @param input - psbt input
     */
    static fromPsbtInput(input) {
        const parsed = utxo_lib_1.bitgo.parsePsbtInput(input);
        return Dimensions.fromScriptType(parsed.scriptType, parsed);
    }
    /**
     * @param inputs - Array of inputs
     * @param params - @see Dimensions.fromInput()
     * @return {Dimensions} sum of the dimensions for each input (@see Dimensions.fromInput())
     */
    static fromInputs(inputs, params) {
        if (!Array.isArray(inputs)) {
            throw new TypeError(`inputs must be array`);
        }
        return Dimensions.sum(...inputs.map((i) => Dimensions.fromInput(i, params)));
    }
    /**
     * Create Dimensions from multiple psbt inputs
     * @param inputs psbt input array
     * @return {Dimensions} sum of the dimensions for each input (@see Dimensions.fromPsbtInput())
     */
    static fromPsbtInputs(inputs) {
        if (!Array.isArray(inputs)) {
            throw new TypeError(`inputs must be array`);
        }
        return Dimensions.sum(...inputs.map((input, _) => Dimensions.fromPsbtInput(input)));
    }
    /**
     * @param scriptLength {number} - size of the output script in bytes
     * @return {Dimensions} - Dimensions of the output
     */
    static fromOutputScriptLength(scriptLength) {
        return Dimensions.sum({
            outputs: {
                count: 1,
                size: Dimensions.getVSizeForOutputWithScriptLength(scriptLength),
            },
        });
    }
    /**
     * @param output - a tx output
     * @return Dimensions - the dimensions of the given output
     */
    static fromOutput({ script }) {
        if (!script) {
            throw new Error('expected output script to be defined');
        }
        if (!Buffer.isBuffer(script)) {
            throw new TypeError('expected script to be buffer, got ' + typeof script);
        }
        return Dimensions.fromOutputScriptLength(script.length);
    }
    /**
     * @param outputs - Array of outputs
     * @return {Dimensions} sum of the dimensions for each output (@see Dimensions.fromOutput())
     */
    static fromOutputs(outputs) {
        if (!Array.isArray(outputs)) {
            throw new TypeError(`outputs must be array`);
        }
        return Dimensions.sum(...outputs.map(Dimensions.fromOutput));
    }
    /**
     * Returns the dimensions of an output that will be created on a specific chain.
     * Currently, this simply adds a default output.
     *
     * @param chain - Chain code as defined by utxolib.bitgo
     * @return {Dimensions} - Dimensions for a single output on the given chain.
     */
    static fromOutputOnChain(chain) {
        return Dimensions.fromOutputScriptLength(Dimensions.getOutputScriptLengthForChain(chain));
    }
    /**
     * Return dimensions of an unspent according to `chain` parameter
     * @param chain - Chain code as defined by utxo.chain
     * @param params - Hint for unspents with variable input sizes (p2tr, p2trMusig2)
     * @return {Dimensions} of the unspent
     * @throws if the chain code is invalid or unsupported
     */
    static fromUnspent({ chain }, params = defaultUnspentParams) {
        if (!isChainCode(chain)) {
            throw new TypeError('invalid chain code');
        }
        const scriptType = scriptTypeForChain(chain);
        return Dimensions.fromScriptType(scriptType, scriptType === 'p2tr' ? params.p2tr : scriptType === 'p2trMusig2' ? params.p2trMusig2 : {});
    }
    /**
     * @param unspents
     * @param params - Hint for unspents with variable input sizes (p2tr, p2trMusig2)
     * @return {Dimensions} sum of the dimensions for each unspent (@see Dimensions.fromUnspent())
     */
    static fromUnspents(unspents, params = defaultUnspentParams) {
        if (!Array.isArray(unspents)) {
            throw new TypeError(`unspents must be array`);
        }
        // Convert the individual unspents into dimensions and sum them up
        return Dimensions.sum(...unspents.map((u) => Dimensions.fromUnspent(u, params)));
    }
    /**
     * @param transaction - bitcoin-like transaction
     * @param [param.assumeUnsigned] - default type for unsigned inputs
     * @return {Dimensions}
     */
    static fromTransaction({ ins, outs, }, params) {
        return Dimensions.fromInputs(ins, params).plus(Dimensions.fromOutputs(outs));
    }
    /**
     * Create Dimensions from psbt inputs and outputs
     * @param psbt
     * @return {Dimensions}
     */
    static fromPsbt(psbt) {
        return Dimensions.fromPsbtInputs(psbt.data.inputs).plus(Dimensions.fromOutputs(psbt.getUnsignedTx().outs));
    }
    /**
     * @param dimensions (can be partially defined)
     * @return new dimensions with argument added
     */
    plus(dimensions) {
        if (typeof dimensions !== 'object') {
            throw new TypeError(`expected argument to be object`);
        }
        if (!(dimensions instanceof Dimensions)) {
            dimensions = new Dimensions(dimensions);
        }
        // Catch instances where we try to initialize Dimensions from partial data using deprecated parameters
        // using only "nOutputs".
        if ('nOutputs' in dimensions) {
            if (!('outputs' in dimensions)) {
                throw new Error('deprecated partial addition: argument has key "nOutputs" but no "outputs"');
            }
            const { outputs, nOutputs } = dimensions;
            if (outputs.count !== nOutputs) {
                throw new Error('deprecated partial addition: inconsistent values for "nOutputs" and "outputs.count"');
            }
        }
        return mapDimensions(this, (key, v) => {
            var _a;
            const w = (_a = dimensions[key]) !== null && _a !== void 0 ? _a : Dimensions.ZERO[key];
            if (key === 'outputs') {
                const vOutputs = v;
                const wOutputs = w;
                return new OutputDimensions({
                    count: vOutputs.count + wOutputs.count,
                    size: vOutputs.size + wOutputs.size,
                });
            }
            return v + w;
        });
    }
    /**
     * Multiply dimensions by a given factor
     * @param factor - Positive integer
     * @return {Dimensions}
     */
    times(factor) {
        if (!types_1.PositiveInteger.is(factor)) {
            throw new TypeError(`expected factor to be positive integer`);
        }
        return mapDimensions(this, (key, value) => {
            if (key === 'outputs') {
                const vOutputs = value;
                return {
                    count: vOutputs.count * factor,
                    size: vOutputs.size * factor,
                };
            }
            return value * factor;
        });
    }
    /**
     * @return Number of total inputs (p2sh, p2shP2wsh and p2wsh)
     * @deprecated use `dimension.nInputs` instead
     */
    getNInputs() {
        return this.nInputs;
    }
    /**
     * @returns {boolean} true iff dimensions have one or more (p2sh)p2wsh inputs
     */
    isSegwit() {
        return (this.nP2wshInputs +
            this.nP2shP2wshInputs +
            this.nP2trKeypathInputs +
            this.nP2trScriptPathLevel1Inputs +
            this.nP2trScriptPathLevel2Inputs >
            0);
    }
    /**
     * @return {Number} overhead vsize, based on result isSegwit().
     */
    getOverheadVSize() {
        return this.isSegwit() ? virtualSizes_1.VirtualSizes.txSegOverheadVSize : virtualSizes_1.VirtualSizes.txOverheadSize;
    }
    /**
     * @returns {number} vsize of inputs, without transaction overhead
     */
    getInputsVSize() {
        const { txP2shInputSize, txP2shP2wshInputSize, txP2wshInputSize, txP2trKeypathInputSize, txP2trScriptPathLevel1InputSize, txP2trScriptPathLevel2InputSize, txP2shP2pkInputSize, } = virtualSizes_1.VirtualSizes;
        const { nP2shInputs, nP2shP2wshInputs, nP2wshInputs, nP2trKeypathInputs, nP2trScriptPathLevel1Inputs, nP2trScriptPathLevel2Inputs, nP2shP2pkInputs, } = this;
        const size = nP2shInputs * txP2shInputSize +
            nP2shP2wshInputs * txP2shP2wshInputSize +
            nP2wshInputs * txP2wshInputSize +
            nP2trKeypathInputs * txP2trKeypathInputSize +
            nP2shP2pkInputs * txP2shP2pkInputSize +
            nP2trScriptPathLevel1Inputs * txP2trScriptPathLevel1InputSize +
            nP2trScriptPathLevel2Inputs * txP2trScriptPathLevel2InputSize;
        if (Number.isNaN(size)) {
            throw new Error(`invalid size`);
        }
        return size;
    }
    /**
     * @returns {number} return vsize of outputs, without overhead
     */
    getOutputsVSize() {
        return this.outputs.size;
    }
    /**
     * Estimates the virtual size (1/4 weight) of a signed transaction as sum of
     * overhead vsize, input vsize and output vsize.
     * @returns {Number} The estimated vsize of the transaction dimensions.
     */
    getVSize() {
        return this.getOverheadVSize() + this.getInputsVSize() + this.getOutputsVSize();
    }
}
exports.Dimensions = Dimensions;
Dimensions.ZERO = Object.freeze(new Dimensions());
Dimensions.SingleOutput = Object.freeze({
    p2sh: Dimensions.singleOutput(virtualSizes_1.VirtualSizes.txP2shOutputSize),
    p2shP2wsh: Dimensions.singleOutput(virtualSizes_1.VirtualSizes.txP2shP2wshOutputSize),
    p2wsh: Dimensions.singleOutput(virtualSizes_1.VirtualSizes.txP2wshOutputSize),
    p2tr: Dimensions.singleOutput(virtualSizes_1.VirtualSizes.txP2trOutputSize),
    p2pkh: Dimensions.singleOutput(virtualSizes_1.VirtualSizes.txP2pkhOutputSize),
    p2wpkh: Dimensions.singleOutput(virtualSizes_1.VirtualSizes.txP2wpkhOutputSize),
});
Dimensions.SingleInput = Object.freeze({
    p2sh: Dimensions.sum({ nP2shInputs: 1 }),
    p2shP2wsh: Dimensions.sum({ nP2shP2wshInputs: 1 }),
    p2wsh: Dimensions.sum({ nP2wshInputs: 1 }),
    p2trKeypath: Dimensions.sum({ nP2trKeypathInputs: 1 }),
    p2trScriptPathLevel1: Dimensions.sum({ nP2trScriptPathLevel1Inputs: 1 }),
    p2trScriptPathLevel2: Dimensions.sum({ nP2trScriptPathLevel2Inputs: 1 }),
    p2shP2pk: Dimensions.sum({ nP2shP2pkInputs: 1 }),
});
Dimensions.ASSUME_P2SH = Dimensions.SingleInput.p2sh;
Dimensions.ASSUME_P2SH_P2WSH = Dimensions.SingleInput.p2shP2wsh;
Dimensions.ASSUME_P2WSH = Dimensions.SingleInput.p2wsh;
Dimensions.ASSUME_P2TR_KEYPATH = Dimensions.SingleInput.p2trKeypath;
Dimensions.ASSUME_P2TR_SCRIPTPATH_LEVEL1 = Dimensions.SingleInput.p2trScriptPathLevel1;
Dimensions.ASSUME_P2TR_SCRIPTPATH_LEVEL2 = Dimensions.SingleInput.p2trScriptPathLevel2;
Dimensions.ASSUME_P2SH_P2PK_INPUT = Dimensions.SingleInput.p2shP2pk;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGltZW5zaW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaW1lbnNpb25zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEseURBQTJDO0FBQzNDLDhDQUF3QztBQUN4QyxNQUFNLEVBQUUsV0FBVyxFQUFFLGtCQUFrQixFQUFFLEdBQUcsZ0JBQUssQ0FBQztBQUdsRCwrQ0FBNEM7QUFDNUMsbUNBQTBDO0FBRTFDLGlEQUE4QztBQUNyQyw2RkFEQSwyQkFBWSxPQUNBO0FBRXJCOztHQUVHO0FBQ0gsU0FBUyxhQUFhLENBQ3BCLENBQXNCLEVBQ3RCLENBQWdGO0lBRWhGLE9BQU8sSUFBSSxVQUFVLENBQ25CLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQXVCLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ3RHLENBQUM7QUFDSixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLGdCQUFnQjtJQVUzQixZQUFZLEVBQUUsS0FBSyxHQUFHLENBQUMsRUFBRSxJQUFJLEdBQUcsQ0FBQyxLQUF1QixFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRTtRQUMzRSxJQUFJLEtBQUssS0FBSyxDQUFDLElBQUksSUFBSSxLQUFLLENBQUMsRUFBRTtZQUM3QixJQUFJLEtBQUssS0FBSyxDQUFDLElBQUksSUFBSSxLQUFLLENBQUMsRUFBRTtnQkFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxpREFBaUQsQ0FBQyxDQUFDO2FBQ3BFO1NBQ0Y7UUFFRCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsSUFBSSxHQUFHLElB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aXRnby91dHhvLWxpYic7XG5pbXBvcnQgeyBiaXRnbyB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5jb25zdCB7IGlzQ2hhaW5Db2RlLCBzY3JpcHRUeXBlRm9yQ2hhaW4gfSA9IGJpdGdvO1xudHlwZSBDaGFpbkNvZGUgPSBiaXRnby5DaGFpbkNvZGU7XG5cbmltcG9ydCB7IGNvbXBhY3RTaXplIH0gZnJvbSAnLi9zY3JpcHRTaXplcyc7XG5pbXBvcnQgeyBQb3NpdGl2ZUludGVnZXIgfSBmcm9tICcuL3R5cGVzJztcblxuaW1wb3J0IHsgVmlydHVhbFNpemVzIH0gZnJvbSAnLi92aXJ0dWFsU2l6ZXMnO1xuZXhwb3J0IHsgVmlydHVhbFNpemVzIH07XG5cbi8qKlxuICogQXBwbHkgYGZgIHRvIGFsbCBwcm9wZXJ0aWVzIG9mIGBkYFxuICovXG5mdW5jdGlvbiBtYXBEaW1lbnNpb25zKFxuICBkOiBQYXJ0aWFsPERpbWVuc2lvbnM+LFxuICBmOiA8VCBleHRlbmRzIGtleW9mIERpbWVuc2lvbnM+KGtleTogVCwgdjogRGltZW5zaW9uc1tUXSB8IHVuZGVmaW5lZCkgPT4gdW5rbm93blxuKTogRGltZW5zaW9ucyB7XG4gIHJldHVybiBuZXcgRGltZW5zaW9ucyhcbiAgICBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZCkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXksIGYoa2V5IGFzIGtleW9mIERpbWVuc2lvbnMsIHZhbHVlKV0pKVxuICApO1xufVxuXG4vKipcbiAqIEFnZ3JlZ2F0ZSBjb3VudCBhbmQgc2l6ZSBvZiB0cmFuc2FjdGlvbiBvdXRwdXRzXG4gKi9cbmV4cG9ydCBjbGFzcyBPdXRwdXREaW1lbnNpb25zIHtcbiAgLyoqXG4gICAqIE51bWJlciBvZiBvdXRwdXRzXG4gICAqL1xuICBjb3VudDogbnVtYmVyO1xuICAvKipcbiAgICogQWdncmVnYXRlIHZTaXplXG4gICAqL1xuICBzaXplOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoeyBjb3VudCA9IDAsIHNpemUgPSAwIH06IE91dHB1dERpbWVuc2lvbnMgPSB7IGNvdW50OiAwLCBzaXplOiAwIH0pIHtcbiAgICBpZiAoY291bnQgPT09IDAgfHwgc2l6ZSA9PT0gMCkge1xuICAgICAgaWYgKGNvdW50ICE9PSAwIHx8IHNpemUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb3VudCBhbmQgc2l6ZSBtdXN0IGJvdGggYmUgemVybyBpZiBvbmUgaXMgemVyb2ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuXG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgRnJvbUlucHV0UGFyYW1zIHtcbiAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIGlucHV0IHR5cGUgaXMgYW1iaWd1b3VzLCB3ZSBtdXN0IHByb3ZpZGUgYSBoaW50IGFib3V0IHNwZW5kIHNjcmlwdCB0eXBlLlxuICBhc3N1bWVVbnNpZ25lZD86IERpbWVuc2lvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnJvbVVuc3BlbnRQYXJhbXMge1xuICBwMnRyOiB7XG4gICAgc2NyaXB0UGF0aExldmVsPzogbnVtYmVyO1xuICB9O1xuICBwMnRyTXVzaWcyOiB7XG4gICAgc2NyaXB0UGF0aExldmVsPzogbnVtYmVyO1xuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0VW5zcGVudFBhcmFtczogRnJvbVVuc3BlbnRQYXJhbXMgPSB7XG4gIHAydHI6IHtcbiAgICAvLyBEZWZhdWx0IHRvIHJlY292ZXJ5IHNjcmlwdCBwYXRocywgdG8gbWFrZSBpdCBlYXNpZXIgZm9yIHJlY292ZXJ5IGNhc2UgY2FsbGVycyAoV1JXIGV0YykuXG4gICAgLy8gV1AgY2FuIGV4cGxpY2l0bHkgcGFzcyBzY3JpcHRQYXRoTGV2ZWw6IDEgdG8gdXNlIGhhcHB5IHBhdGguXG4gICAgc2NyaXB0UGF0aExldmVsOiAyLFxuICB9LFxuICBwMnRyTXVzaWcyOiB7XG4gICAgLy8gRGVmYXVsdCB0byBzY3JpcHQgcGF0aCBzcGVuZCwgdG8gbWFrZSBpdCBlYXNpZXIgZm9yIHJlY292ZXJ5IGNhc2UgY2FsbGVycyAoV1JXIGV0YykuXG4gICAgLy8gV1AgY2FuIGV4cGxpY2l0bHkgcGFzcyBzY3JpcHRQYXRoTGV2ZWw6IHVuZGVmaW5lZCB0byB1c2Uga2V5IHBhdGguXG4gICAgc2NyaXB0UGF0aExldmVsOiAxLFxuICB9LFxufTtcblxuLyoqXG4gKiBEaW1lbnNpb25zIG9mIGEgQml0R28gd2FsbGV0IHRyYW5zYWN0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIERpbWVuc2lvbnMge1xuICAvKiogSW5wdXQgY291bnRzIGZvciBCaXRHbyB3YWxsZXQgbXVsdGktc2lnbmF0dXJlIGlucHV0cyAqL1xuICBwdWJsaWMgcmVhZG9ubHkgblAyc2hJbnB1dHM6IG51bWJlciA9IDA7XG4gIHB1YmxpYyByZWFkb25seSBuUDJzaFAyd3NoSW5wdXRzOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgcmVhZG9ubHkgblAyd3NoSW5wdXRzOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgcmVhZG9ubHkgblAydHJLZXlwYXRoSW5wdXRzOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgcmVhZG9ubHkgblAydHJTY3JpcHRQYXRoTGV2ZWwxSW5wdXRzOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgcmVhZG9ubHkgblAydHJTY3JpcHRQYXRoTGV2ZWwySW5wdXRzOiBudW1iZXIgPSAwO1xuXG4gIC8qIElucHV0IGNvdW50IGZvciBzaW5nbGUtc2lnbmF0dXJlIGlucHV0cyAoUmVwbGF5IFByb3RlY3Rpb24gaW5wdXRzKSAqL1xuICBwdWJsaWMgcmVhZG9ubHkgblAyc2hQMnBrSW5wdXRzOiBudW1iZXIgPSAwO1xuXG4gIHB1YmxpYyByZWFkb25seSBvdXRwdXRzOiBPdXRwdXREaW1lbnNpb25zID0gbmV3IE91dHB1dERpbWVuc2lvbnMoKTtcblxuICBjb25zdHJ1Y3RvcihkOiBQYXJ0aWFsPERpbWVuc2lvbnM+ID0ge30pIHtcbiAgICBPYmplY3QuZW50cmllcyhkKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHRoaXMuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSkpO1xuXG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0UHJvcGVydHkoazogc3RyaW5nLCB2OiB1bmtub3duKTogdm9pZCB7XG4gICAgc3dpdGNoIChrKSB7XG4gICAgICBjYXNlICduUDJzaElucHV0cyc6XG4gICAgICBjYXNlICduUDJzaFAyd3NoSW5wdXRzJzpcbiAgICAgIGNhc2UgJ25QMndzaElucHV0cyc6XG4gICAgICBjYXNlICduUDJ0cktleXBhdGhJbnB1dHMnOlxuICAgICAgY2FzZSAnblAydHJTY3JpcHRQYXRoTGV2ZWwxSW5wdXRzJzpcbiAgICAgIGNhc2UgJ25QMnRyU2NyaXB0UGF0aExldmVsMklucHV0cyc6XG4gICAgICBjYXNlICduUDJzaFAycGtJbnB1dHMnOlxuICAgICAgICBpZiAodHlwZW9mIHYgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcm9wZXJ0eSAke2t9IG11c3QgYmUgbnVtYmVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih2KSB8fCB2IDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJvcGVydHkgJHtrfSBtdXN0IGJlIHplcm8gb3IgcG9zaXRpdmUgaW50ZWdlcmApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3V0cHV0cyc6XG4gICAgICAgIGlmICghKHYgaW5zdGFuY2VvZiBPdXRwdXREaW1lbnNpb25zKSkge1xuICAgICAgICAgIHYgPSBuZXcgT3V0cHV0RGltZW5zaW9ucyh2IGFzIE91dHB1dERpbWVuc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHByb3BlcnR5ICR7a31gKTtcbiAgICB9XG5cbiAgICAodGhpcyBhcyBhbnkpW2tdID0gdjtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBaRVJPID0gT2JqZWN0LmZyZWV6ZShuZXcgRGltZW5zaW9ucygpKTtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIFpFUk9cbiAgICogQHJldHVybiBEaW1lbnNpb25zIGZvciBhbiBlbXB0eSB0cmFuc2FjdGlvblxuICAgKi9cbiAgc3RhdGljIHplcm8oKTogUmVhZG9ubHk8RGltZW5zaW9ucz4ge1xuICAgIHJldHVybiB0aGlzLlpFUk87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHNpemVcbiAgICogQHJldHVybiBEaW1lbnNpb25zIGZvciBhIHNpbmdsZSBvdXRwdXQgd2l0aCBnaXZlbiBzaXplXG4gICAqL1xuICBzdGF0aWMgc2luZ2xlT3V0cHV0KHNpemU6IG51bWJlcik6IERpbWVuc2lvbnMge1xuICAgIHJldHVybiBEaW1lbnNpb25zLnN1bSh7IG91dHB1dHM6IHsgY291bnQ6IDEsIHNpemUgfSB9KTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBTaW5nbGVPdXRwdXQgPSBPYmplY3QuZnJlZXplKHtcbiAgICBwMnNoOiBEaW1lbnNpb25zLnNpbmdsZU91dHB1dChWaXJ0dWFsU2l6ZXMudHhQMnNoT3V0cHV0U2l6ZSksXG4gICAgcDJzaFAyd3NoOiBEaW1lbnNpb25zLnNpbmdsZU91dHB1dChWaXJ0dWFsU2l6ZXMudHhQMnNoUDJ3c2hPdXRwdXRTaXplKSxcbiAgICBwMndzaDogRGltZW5zaW9ucy5zaW5nbGVPdXRwdXQoVmlydHVhbFNpemVzLnR4UDJ3c2hPdXRwdXRTaXplKSxcbiAgICBwMnRyOiBEaW1lbnNpb25zLnNpbmdsZU91dHB1dChWaXJ0dWFsU2l6ZXMudHhQMnRyT3V0cHV0U2l6ZSksXG5cbiAgICBwMnBraDogRGltZW5zaW9ucy5zaW5nbGVPdXRwdXQoVmlydHVhbFNpemVzLnR4UDJwa2hPdXRwdXRTaXplKSxcbiAgICBwMndwa2g6IERpbWVuc2lvbnMuc2luZ2xlT3V0cHV0KFZpcnR1YWxTaXplcy50eFAyd3BraE91dHB1dFNpemUpLFxuICB9KTtcblxuICAvKipcbiAgICogQHJldHVybiBOdW1iZXIgb2YgdG90YWwgaW5wdXRzIChwMnNoICsgcDJzaFAyd3NoICsgcDJ3c2ggKyBwMnRyKVxuICAgKi9cbiAgZ2V0IG5JbnB1dHMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5uUDJzaElucHV0cyArXG4gICAgICB0aGlzLm5QMnNoUDJ3c2hJbnB1dHMgK1xuICAgICAgdGhpcy5uUDJ3c2hJbnB1dHMgK1xuICAgICAgdGhpcy5uUDJ0cktleXBhdGhJbnB1dHMgK1xuICAgICAgdGhpcy5uUDJ0clNjcmlwdFBhdGhMZXZlbDFJbnB1dHMgK1xuICAgICAgdGhpcy5uUDJ0clNjcmlwdFBhdGhMZXZlbDJJbnB1dHMgK1xuICAgICAgdGhpcy5uUDJzaFAycGtJbnB1dHNcbiAgICApO1xuICB9XG5cbiAgc2V0IG5JbnB1dHMoXzogbnVtYmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZWFkLW9ubHkgcHJvcGVydHkgbklucHV0cycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4gTnVtYmVyIG9mIHRvdGFsIG91dHB1dHNcbiAgICovXG4gIGdldCBuT3V0cHV0cygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLm91dHB1dHMuY291bnQ7XG4gIH1cblxuICBzZXQgbk91dHB1dHMoXzogbnVtYmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGByZWFkLW9ubHkgcHJvcGVydHkgbk91dHB1dHNgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gYXJncyAtIERpbWVuc2lvbnMgKGNhbiBiZSBwYXJ0aWFsbHkgZGVmaW5lZClcbiAgICogQHJldHVybiB7RGltZW5zaW9uc30gc3VtIG9mIGFyZ3VtZW50c1xuICAgKi9cbiAgc3RhdGljIHN1bSguLi5hcmdzOiBQYXJ0aWFsPERpbWVuc2lvbnM+W10pOiBEaW1lbnNpb25zIHtcbiAgICByZXR1cm4gYXJncy5yZWR1Y2UoKGE6IERpbWVuc2lvbnMsIGI6IFBhcnRpYWw8RGltZW5zaW9ucz4pID0+IGEucGx1cyhiKSwgbmV3IERpbWVuc2lvbnMoKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGNoYWluXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIHN0YXRpYyBnZXRPdXRwdXRTY3JpcHRMZW5ndGhGb3JDaGFpbihjaGFpbjogQ2hhaW5Db2RlKTogbnVtYmVyIHtcbiAgICBzd2l0Y2ggKHNjcmlwdFR5cGVGb3JDaGFpbihjaGFpbikpIHtcbiAgICAgIGNhc2UgJ3Ayd3NoJzpcbiAgICAgIGNhc2UgJ3AydHInOlxuICAgICAgY2FzZSAncDJ0ck11c2lnMic6XG4gICAgICAgIHJldHVybiAzNDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAyMztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHNjcmlwdExlbmd0aFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHZTaXplIG9mIGFuIG91dHB1dCB3aXRoIHNjcmlwdCBsZW5ndGhcbiAgICovXG4gIHN0YXRpYyBnZXRWU2l6ZUZvck91dHB1dFdpdGhTY3JpcHRMZW5ndGgoc2NyaXB0TGVuZ3RoOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmICghUG9zaXRpdmVJbnRlZ2VyLmlzKHNjcmlwdExlbmd0aCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXIgZm9yIHNjcmlwdExlbmd0aCwgZ290ICR7c2NyaXB0TGVuZ3RofWApO1xuICAgIH1cbiAgICByZXR1cm4gc2NyaXB0TGVuZ3RoICsgY29tcGFjdFNpemUoc2NyaXB0TGVuZ3RoKSArIFZpcnR1YWxTaXplcy50eE91dHB1dEFtb3VudFNpemU7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgU2luZ2xlSW5wdXQgPSBPYmplY3QuZnJlZXplKHtcbiAgICBwMnNoOiBEaW1lbnNpb25zLnN1bSh7IG5QMnNoSW5wdXRzOiAxIH0pLFxuICAgIHAyc2hQMndzaDogRGltZW5zaW9ucy5zdW0oeyBuUDJzaFAyd3NoSW5wdXRzOiAxIH0pLFxuICAgIHAyd3NoOiBEaW1lbnNpb25zLnN1bSh7IG5QMndzaElucHV0czogMSB9KSxcbiAgICBwMnRyS2V5cGF0aDogRGltZW5zaW9ucy5zdW0oeyBuUDJ0cktleXBhdGhJbnB1dHM6IDEgfSksXG4gICAgcDJ0clNjcmlwdFBhdGhMZXZlbDE6IERpbWVuc2lvbnMuc3VtKHsgblAydHJTY3JpcHRQYXRoTGV2ZWwxSW5wdXRzOiAxIH0pLFxuICAgIHAydHJTY3JpcHRQYXRoTGV2ZWwyOiBEaW1lbnNpb25zLnN1bSh7IG5QMnRyU2NyaXB0UGF0aExldmVsMklucHV0czogMSB9KSxcbiAgICBwMnNoUDJwazogRGltZW5zaW9ucy5zdW0oeyBuUDJzaFAycGtJbnB1dHM6IDEgfSksXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuXG4gICAqL1xuICBzdGF0aWMgZnJvbVNjcmlwdFR5cGUoXG4gICAgc2NyaXB0VHlwZTogdXR4b2xpYi5iaXRnby5vdXRwdXRTY3JpcHRzLlNjcmlwdFR5cGUgfCB1dHhvbGliLmJpdGdvLlBhcnNlZFNjcmlwdFR5cGUyT2YzIHwgJ3AycGtoJyxcbiAgICBwYXJhbXM6IHtcbiAgICAgIHNjcmlwdFBhdGhMZXZlbD86IG51bWJlcjtcbiAgICB9ID0ge31cbiAgKTogRGltZW5zaW9ucyB7XG4gICAgc3dpdGNoIChzY3JpcHRUeXBlKSB7XG4gICAgICBjYXNlICdwMnNoJzpcbiAgICAgIGNhc2UgJ3Ayc2hQMndzaCc6XG4gICAgICBjYXNlICdwMndzaCc6XG4gICAgICBjYXNlICdwMnNoUDJwayc6XG4gICAgICAgIHJldHVybiBEaW1lbnNpb25zLlNpbmdsZUlucHV0W3NjcmlwdFR5cGVdO1xuICAgICAgY2FzZSAncDJ0cic6XG4gICAgICBjYXNlICd0YXByb290U2NyaXB0UGF0aFNwZW5kJzpcbiAgICAgICAgc3dpdGNoIChwYXJhbXMuc2NyaXB0UGF0aExldmVsKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIERpbWVuc2lvbnMuU2luZ2xlSW5wdXQucDJ0clNjcmlwdFBhdGhMZXZlbDE7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIERpbWVuc2lvbnMuU2luZ2xlSW5wdXQucDJ0clNjcmlwdFBhdGhMZXZlbDI7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBzY3JpcHQgcGF0aCBsZXZlbGApO1xuICAgICAgICB9XG4gICAgICBjYXNlICdwMnRyTXVzaWcyJzpcbiAgICAgICAgc3dpdGNoIChwYXJhbXMuc2NyaXB0UGF0aExldmVsKSB7XG4gICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICByZXR1cm4gRGltZW5zaW9ucy5TaW5nbGVJbnB1dC5wMnRyS2V5cGF0aDtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gRGltZW5zaW9ucy5TaW5nbGVJbnB1dC5wMnRyU2NyaXB0UGF0aExldmVsMTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIHNjcmlwdCBwYXRoIGxldmVsYCk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3RhcHJvb3RLZXlQYXRoU3BlbmQnOlxuICAgICAgICByZXR1cm4gRGltZW5zaW9ucy5TaW5nbGVJbnB1dC5wMnRyS2V5cGF0aDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBzY3JpcHRUeXBlICR7c2NyaXB0VHlwZX1gKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgQVNTVU1FX1AyU0ggPSBEaW1lbnNpb25zLlNpbmdsZUlucHV0LnAyc2g7XG4gIHN0YXRpYyByZWFkb25seSBBU1NVTUVfUDJTSF9QMldTSCA9IERpbWVuc2lvbnMuU2luZ2xlSW5wdXQucDJzaFAyd3NoO1xuICBzdGF0aWMgcmVhZG9ubHkgQVNTVU1FX1AyV1NIID0gRGltZW5zaW9ucy5TaW5nbGVJbnB1dC5wMndzaDtcbiAgc3RhdGljIHJlYWRvbmx5IEFTU1VNRV9QMlRSX0tFWVBBVEggPSBEaW1lbnNpb25zLlNpbmdsZUlucHV0LnAydHJLZXlwYXRoO1xuICBzdGF0aWMgcmVhZG9ubHkgQVNTVU1FX1AyVFJfU0NSSVBUUEFUSF9MRVZFTDEgPSBEaW1lbnNpb25zLlNpbmdsZUlucHV0LnAydHJTY3JpcHRQYXRoTGV2ZWwxO1xuICBzdGF0aWMgcmVhZG9ubHkgQVNTVU1FX1AyVFJfU0NSSVBUUEFUSF9MRVZFTDIgPSBEaW1lbnNpb25zLlNpbmdsZUlucHV0LnAydHJTY3JpcHRQYXRoTGV2ZWwyO1xuICBzdGF0aWMgcmVhZG9ubHkgQVNTVU1FX1AyU0hfUDJQS19JTlBVVCA9IERpbWVuc2lvbnMuU2luZ2xlSW5wdXQucDJzaFAycGs7XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0QXNzdW1lZERpbWVuc2lvbihwYXJhbXM6IEZyb21JbnB1dFBhcmFtcyA9IHt9LCBpbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3QgeyBhc3N1bWVVbnNpZ25lZCB9ID0gcGFyYW1zO1xuICAgIGlmICghYXNzdW1lVW5zaWduZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaWxsZWdhbCBpbnB1dCAke2luZGV4fTogZW1wdHkgc2NyaXB0IGFuZCBhc3N1bWVVbnNpZ25lZCBub3Qgc2V0YCk7XG4gICAgfVxuICAgIHJldHVybiBhc3N1bWVVbnNpZ25lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gaW5wdXQgLSB0aGUgdHJhbnNhY3Rpb24gaW5wdXQgdG8gY291bnRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAgICAgICAgW3BhcmFtLmFzc3VtZVVuc2lnbmVkXSAtIGRlZmF1bHQgdHlwZSBmb3IgdW5zaWduZWQgaW5wdXRcbiAgICovXG4gIHN0YXRpYyBmcm9tSW5wdXQoaW5wdXQ6IHV0eG9saWIuVHhJbnB1dCwgcGFyYW1zOiBGcm9tSW5wdXRQYXJhbXMgPSB7fSk6IERpbWVuc2lvbnMge1xuICAgIGlmIChpbnB1dC5zY3JpcHQ/Lmxlbmd0aCB8fCBpbnB1dC53aXRuZXNzPy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHV0eG9saWIuYml0Z28ucGFyc2VTaWduYXR1cmVTY3JpcHQoaW5wdXQpO1xuICAgICAgcmV0dXJuIERpbWVuc2lvbnMuZnJvbVNjcmlwdFR5cGUocGFyc2VkLnNjcmlwdFR5cGUsIHBhcnNlZCBhcyB7IHNjcmlwdFBhdGhMZXZlbD86IG51bWJlciB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gRGltZW5zaW9ucy5nZXRBc3N1bWVkRGltZW5zaW9uKHBhcmFtcywgaW5wdXQuaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBEaW1lbnNpb25zIGZyb20gcHNidCBpbnB1dFxuICAgKiBAcGFyYW0gaW5wdXQgLSBwc2J0IGlucHV0XG4gICAqL1xuICBzdGF0aWMgZnJvbVBzYnRJbnB1dChpbnB1dDogYml0Z28uUHNidElucHV0VHlwZSk6IERpbWVuc2lvbnMge1xuICAgIGNvbnN0IHBhcnNlZCA9IGJpdGdvLnBhcnNlUHNidElucHV0KGlucHV0KTtcbiAgICByZXR1cm4gRGltZW5zaW9ucy5mcm9tU2NyaXB0VHlwZShwYXJzZWQuc2NyaXB0VHlwZSwgcGFyc2VkIGFzIHsgc2NyaXB0UGF0aExldmVsPzogbnVtYmVyIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBpbnB1dHMgLSBBcnJheSBvZiBpbnB1dHNcbiAgICogQHBhcmFtIHBhcmFtcyAtIEBzZWUgRGltZW5zaW9ucy5mcm9tSW5wdXQoKVxuICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfSBzdW0gb2YgdGhlIGRpbWVuc2lvbnMgZm9yIGVhY2ggaW5wdXQgKEBzZWUgRGltZW5zaW9ucy5mcm9tSW5wdXQoKSlcbiAgICovXG4gIHN0YXRpYyBmcm9tSW5wdXRzKGlucHV0czogdXR4b2xpYi5UeElucHV0W10sIHBhcmFtcz86IEZyb21JbnB1dFBhcmFtcyk6IERpbWVuc2lvbnMge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnB1dHMgbXVzdCBiZSBhcnJheWApO1xuICAgIH1cbiAgICByZXR1cm4gRGltZW5zaW9ucy5zdW0oLi4uaW5wdXRzLm1hcCgoaSkgPT4gRGltZW5zaW9ucy5mcm9tSW5wdXQoaSwgcGFyYW1zKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBEaW1lbnNpb25zIGZyb20gbXVsdGlwbGUgcHNidCBpbnB1dHNcbiAgICogQHBhcmFtIGlucHV0cyBwc2J0IGlucHV0IGFycmF5XG4gICAqIEByZXR1cm4ge0RpbWVuc2lvbnN9IHN1bSBvZiB0aGUgZGltZW5zaW9ucyBmb3IgZWFjaCBpbnB1dCAoQHNlZSBEaW1lbnNpb25zLmZyb21Qc2J0SW5wdXQoKSlcbiAgICovXG4gIHN0YXRpYyBmcm9tUHNidElucHV0cyhpbnB1dHM6IGJpdGdvLlBzYnRJbnB1dFR5cGVbXSk6IERpbWVuc2lvbnMge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnB1dHMgbXVzdCBiZSBhcnJheWApO1xuICAgIH1cbiAgICByZXR1cm4gRGltZW5zaW9ucy5zdW0oLi4uaW5wdXRzLm1hcCgoaW5wdXQsIF8pID0+IERpbWVuc2lvbnMuZnJvbVBzYnRJbnB1dChpbnB1dCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gc2NyaXB0TGVuZ3RoIHtudW1iZXJ9IC0gc2l6ZSBvZiB0aGUgb3V0cHV0IHNjcmlwdCBpbiBieXRlc1xuICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfSAtIERpbWVuc2lvbnMgb2YgdGhlIG91dHB1dFxuICAgKi9cbiAgc3RhdGljIGZyb21PdXRwdXRTY3JpcHRMZW5ndGgoc2NyaXB0TGVuZ3RoOiBudW1iZXIpOiBEaW1lbnNpb25zIHtcbiAgICByZXR1cm4gRGltZW5zaW9ucy5zdW0oe1xuICAgICAgb3V0cHV0czoge1xuICAgICAgICBjb3VudDogMSxcbiAgICAgICAgc2l6ZTogRGltZW5zaW9ucy5nZXRWU2l6ZUZvck91dHB1dFdpdGhTY3JpcHRMZW5ndGgoc2NyaXB0TGVuZ3RoKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIG91dHB1dCAtIGEgdHggb3V0cHV0XG4gICAqIEByZXR1cm4gRGltZW5zaW9ucyAtIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBnaXZlbiBvdXRwdXRcbiAgICovXG4gIHN0YXRpYyBmcm9tT3V0cHV0KHsgc2NyaXB0IH06IHsgc2NyaXB0OiBCdWZmZXIgfSk6IERpbWVuc2lvbnMge1xuICAgIGlmICghc2NyaXB0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIG91dHB1dCBzY3JpcHQgdG8gYmUgZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihzY3JpcHQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBzY3JpcHQgdG8gYmUgYnVmZmVyLCBnb3QgJyArIHR5cGVvZiBzY3JpcHQpO1xuICAgIH1cbiAgICByZXR1cm4gRGltZW5zaW9ucy5mcm9tT3V0cHV0U2NyaXB0TGVuZ3RoKHNjcmlwdC5sZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBvdXRwdXRzIC0gQXJyYXkgb2Ygb3V0cHV0c1xuICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfSBzdW0gb2YgdGhlIGRpbWVuc2lvbnMgZm9yIGVhY2ggb3V0cHV0IChAc2VlIERpbWVuc2lvbnMuZnJvbU91dHB1dCgpKVxuICAgKi9cbiAgc3RhdGljIGZyb21PdXRwdXRzKG91dHB1dHM6IHsgc2NyaXB0OiBCdWZmZXIgfVtdKTogRGltZW5zaW9ucyB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG91dHB1dHMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBvdXRwdXRzIG11c3QgYmUgYXJyYXlgKTtcbiAgICB9XG4gICAgcmV0dXJuIERpbWVuc2lvbnMuc3VtKC4uLm91dHB1dHMubWFwKERpbWVuc2lvbnMuZnJvbU91dHB1dCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpbWVuc2lvbnMgb2YgYW4gb3V0cHV0IHRoYXQgd2lsbCBiZSBjcmVhdGVkIG9uIGEgc3BlY2lmaWMgY2hhaW4uXG4gICAqIEN1cnJlbnRseSwgdGhpcyBzaW1wbHkgYWRkcyBhIGRlZmF1bHQgb3V0cHV0LlxuICAgKlxuICAgKiBAcGFyYW0gY2hhaW4gLSBDaGFpbiBjb2RlIGFzIGRlZmluZWQgYnkgdXR4b2xpYi5iaXRnb1xuICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfSAtIERpbWVuc2lvbnMgZm9yIGEgc2luZ2xlIG91dHB1dCBvbiB0aGUgZ2l2ZW4gY2hhaW4uXG4gICAqL1xuICBzdGF0aWMgZnJvbU91dHB1dE9uQ2hhaW4oY2hhaW46IENoYWluQ29kZSk6IERpbWVuc2lvbnMge1xuICAgIHJldHVybiBEaW1lbnNpb25zLmZyb21PdXRwdXRTY3JpcHRMZW5ndGgoRGltZW5zaW9ucy5nZXRPdXRwdXRTY3JpcHRMZW5ndGhGb3JDaGFpbihjaGFpbikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBkaW1lbnNpb25zIG9mIGFuIHVuc3BlbnQgYWNjb3JkaW5nIHRvIGBjaGFpbmAgcGFyYW1ldGVyXG4gICAqIEBwYXJhbSBjaGFpbiAtIENoYWluIGNvZGUgYXMgZGVmaW5lZCBieSB1dHhvLmNoYWluXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBIaW50IGZvciB1bnNwZW50cyB3aXRoIHZhcmlhYmxlIGlucHV0IHNpemVzIChwMnRyLCBwMnRyTXVzaWcyKVxuICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfSBvZiB0aGUgdW5zcGVudFxuICAgKiBAdGhyb3dzIGlmIHRoZSBjaGFpbiBjb2RlIGlzIGludmFsaWQgb3IgdW5zdXBwb3J0ZWRcbiAgICovXG4gIHN0YXRpYyBmcm9tVW5zcGVudCh7IGNoYWluIH06IHsgY2hhaW46IG51bWJlciB9LCBwYXJhbXM6IEZyb21VbnNwZW50UGFyYW1zID0gZGVmYXVsdFVuc3BlbnRQYXJhbXMpOiBEaW1lbnNpb25zIHtcbiAgICBpZiAoIWlzQ2hhaW5Db2RlKGNoYWluKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBjaGFpbiBjb2RlJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NyaXB0VHlwZSA9IHNjcmlwdFR5cGVGb3JDaGFpbihjaGFpbik7XG5cbiAgICByZXR1cm4gRGltZW5zaW9ucy5mcm9tU2NyaXB0VHlwZShcbiAgICAgIHNjcmlwdFR5cGUsXG4gICAgICBzY3JpcHRUeXBlID09PSAncDJ0cicgPyBwYXJhbXMucDJ0ciA6IHNjcmlwdFR5cGUgPT09ICdwMnRyTXVzaWcyJyA/IHBhcmFtcy5wMnRyTXVzaWcyIDoge31cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB1bnNwZW50c1xuICAgKiBAcGFyYW0gcGFyYW1zIC0gSGludCBmb3IgdW5zcGVudHMgd2l0aCB2YXJpYWJsZSBpbnB1dCBzaXplcyAocDJ0ciwgcDJ0ck11c2lnMilcbiAgICogQHJldHVybiB7RGltZW5zaW9uc30gc3VtIG9mIHRoZSBkaW1lbnNpb25zIGZvciBlYWNoIHVuc3BlbnQgKEBzZWUgRGltZW5zaW9ucy5mcm9tVW5zcGVudCgpKVxuICAgKi9cbiAgc3RhdGljIGZyb21VbnNwZW50cyh1bnNwZW50czogeyBjaGFpbjogQ2hhaW5Db2RlIH1bXSwgcGFyYW1zOiBGcm9tVW5zcGVudFBhcmFtcyA9IGRlZmF1bHRVbnNwZW50UGFyYW1zKTogRGltZW5zaW9ucyB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHVuc3BlbnRzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zcGVudHMgbXVzdCBiZSBhcnJheWApO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSBpbmRpdmlkdWFsIHVuc3BlbnRzIGludG8gZGltZW5zaW9ucyBhbmQgc3VtIHRoZW0gdXBcbiAgICByZXR1cm4gRGltZW5zaW9ucy5zdW0oLi4udW5zcGVudHMubWFwKCh1KSA9PiBEaW1lbnNpb25zLmZyb21VbnNwZW50KHUsIHBhcmFtcykpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBiaXRjb2luLWxpa2UgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIFtwYXJhbS5hc3N1bWVVbnNpZ25lZF0gLSBkZWZhdWx0IHR5cGUgZm9yIHVuc2lnbmVkIGlucHV0c1xuICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfVxuICAgKi9cbiAgc3RhdGljIGZyb21UcmFuc2FjdGlvbihcbiAgICB7XG4gICAgICBpbnMsXG4gICAgICBvdXRzLFxuICAgIH06IHtcbiAgICAgIGluczogdXR4b2xpYi5UeElucHV0W107XG4gICAgICBvdXRzOiB1dHhvbGliLlR4T3V0cHV0W107XG4gICAgfSxcbiAgICBwYXJhbXM/OiBGcm9tSW5wdXRQYXJhbXNcbiAgKTogRGltZW5zaW9ucyB7XG4gICAgcmV0dXJuIERpbWVuc2lvbnMuZnJvbUlucHV0cyhpbnMsIHBhcmFtcykucGx1cyhEaW1lbnNpb25zLmZyb21PdXRwdXRzKG91dHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgRGltZW5zaW9ucyBmcm9tIHBzYnQgaW5wdXRzIGFuZCBvdXRwdXRzXG4gICAqIEBwYXJhbSBwc2J0XG4gICAqIEByZXR1cm4ge0RpbWVuc2lvbnN9XG4gICAqL1xuICBzdGF0aWMgZnJvbVBzYnQocHNidDogYml0Z28uVXR4b1BzYnQpOiBEaW1lbnNpb25zIHtcbiAgICByZXR1cm4gRGltZW5zaW9ucy5mcm9tUHNidElucHV0cyhwc2J0LmRhdGEuaW5wdXRzKS5wbHVzKERpbWVuc2lvbnMuZnJvbU91dHB1dHMocHNidC5nZXRVbnNpZ25lZFR4KCkub3V0cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBkaW1lbnNpb25zIChjYW4gYmUgcGFydGlhbGx5IGRlZmluZWQpXG4gICAqIEByZXR1cm4gbmV3IGRpbWVuc2lvbnMgd2l0aCBhcmd1bWVudCBhZGRlZFxuICAgKi9cbiAgcGx1cyhkaW1lbnNpb25zOiBQYXJ0aWFsPERpbWVuc2lvbnM+KTogRGltZW5zaW9ucyB7XG4gICAgaWYgKHR5cGVvZiBkaW1lbnNpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgb2JqZWN0YCk7XG4gICAgfVxuXG4gICAgaWYgKCEoZGltZW5zaW9ucyBpbnN0YW5jZW9mIERpbWVuc2lvbnMpKSB7XG4gICAgICBkaW1lbnNpb25zID0gbmV3IERpbWVuc2lvbnMoZGltZW5zaW9ucyk7XG4gICAgfVxuXG4gICAgLy8gQ2F0Y2ggaW5zdGFuY2VzIHdoZXJlIHdlIHRyeSB0byBpbml0aWFsaXplIERpbWVuc2lvbnMgZnJvbSBwYXJ0aWFsIGRhdGEgdXNpbmcgZGVwcmVjYXRlZCBwYXJhbWV0ZXJzXG4gICAgLy8gdXNpbmcgb25seSBcIm5PdXRwdXRzXCIuXG4gICAgaWYgKCduT3V0cHV0cycgaW4gZGltZW5zaW9ucykge1xuICAgICAgaWYgKCEoJ291dHB1dHMnIGluIGRpbWVuc2lvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVwcmVjYXRlZCBwYXJ0aWFsIGFkZGl0aW9uOiBhcmd1bWVudCBoYXMga2V5IFwibk91dHB1dHNcIiBidXQgbm8gXCJvdXRwdXRzXCInKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBvdXRwdXRzLCBuT3V0cHV0cyB9ID0gZGltZW5zaW9ucyBhcyBEaW1lbnNpb25zO1xuXG4gICAgICBpZiAob3V0cHV0cy5jb3VudCAhPT0gbk91dHB1dHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXByZWNhdGVkIHBhcnRpYWwgYWRkaXRpb246IGluY29uc2lzdGVudCB2YWx1ZXMgZm9yIFwibk91dHB1dHNcIiBhbmQgXCJvdXRwdXRzLmNvdW50XCInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwRGltZW5zaW9ucyh0aGlzLCAoa2V5LCB2KSA9PiB7XG4gICAgICBjb25zdCB3ID0gZGltZW5zaW9uc1trZXldID8/IERpbWVuc2lvbnMuWkVST1trZXldO1xuICAgICAgaWYgKGtleSA9PT0gJ291dHB1dHMnKSB7XG4gICAgICAgIGNvbnN0IHZPdXRwdXRzID0gdiBhcyBPdXRwdXREaW1lbnNpb25zO1xuICAgICAgICBjb25zdCB3T3V0cHV0cyA9IHcgYXMgT3V0cHV0RGltZW5zaW9ucztcbiAgICAgICAgcmV0dXJuIG5ldyBPdXRwdXREaW1lbnNpb25zKHtcbiAgICAgICAgICBjb3VudDogdk91dHB1dHMuY291bnQgKyB3T3V0cHV0cy5jb3VudCxcbiAgICAgICAgICBzaXplOiB2T3V0cHV0cy5zaXplICsgd091dHB1dHMuc2l6ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHYgYXMgbnVtYmVyKSArICh3IGFzIG51bWJlcik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbHkgZGltZW5zaW9ucyBieSBhIGdpdmVuIGZhY3RvclxuICAgKiBAcGFyYW0gZmFjdG9yIC0gUG9zaXRpdmUgaW50ZWdlclxuICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfVxuICAgKi9cbiAgdGltZXMoZmFjdG9yOiBudW1iZXIpOiBEaW1lbnNpb25zIHtcbiAgICBpZiAoIVBvc2l0aXZlSW50ZWdlci5pcyhmYWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBmYWN0b3IgdG8gYmUgcG9zaXRpdmUgaW50ZWdlcmApO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBEaW1lbnNpb25zKHRoaXMsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSAnb3V0cHV0cycpIHtcbiAgICAgICAgY29uc3Qgdk91dHB1dHMgPSB2YWx1ZSBhcyBPdXRwdXREaW1lbnNpb25zO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvdW50OiB2T3V0cHV0cy5jb3VudCAqIGZhY3RvcixcbiAgICAgICAgICBzaXplOiB2T3V0cHV0cy5zaXplICogZmFjdG9yLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuICh2YWx1ZSBhcyBudW1iZXIpICogZmFjdG9yO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4gTnVtYmVyIG9mIHRvdGFsIGlucHV0cyAocDJzaCwgcDJzaFAyd3NoIGFuZCBwMndzaClcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBkaW1lbnNpb24ubklucHV0c2AgaW5zdGVhZFxuICAgKi9cbiAgZ2V0TklucHV0cygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLm5JbnB1dHM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWZmIGRpbWVuc2lvbnMgaGF2ZSBvbmUgb3IgbW9yZSAocDJzaClwMndzaCBpbnB1dHNcbiAgICovXG4gIGlzU2Vnd2l0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm5QMndzaElucHV0cyArXG4gICAgICAgIHRoaXMublAyc2hQMndzaElucHV0cyArXG4gICAgICAgIHRoaXMublAydHJLZXlwYXRoSW5wdXRzICtcbiAgICAgICAgdGhpcy5uUDJ0clNjcmlwdFBhdGhMZXZlbDFJbnB1dHMgK1xuICAgICAgICB0aGlzLm5QMnRyU2NyaXB0UGF0aExldmVsMklucHV0cyA+XG4gICAgICAwXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IG92ZXJoZWFkIHZzaXplLCBiYXNlZCBvbiByZXN1bHQgaXNTZWd3aXQoKS5cbiAgICovXG4gIGdldE92ZXJoZWFkVlNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5pc1NlZ3dpdCgpID8gVmlydHVhbFNpemVzLnR4U2VnT3ZlcmhlYWRWU2l6ZSA6IFZpcnR1YWxTaXplcy50eE92ZXJoZWFkU2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB2c2l6ZSBvZiBpbnB1dHMsIHdpdGhvdXQgdHJhbnNhY3Rpb24gb3ZlcmhlYWRcbiAgICovXG4gIGdldElucHV0c1ZTaXplKCk6IG51bWJlciB7XG4gICAgY29uc3Qge1xuICAgICAgdHhQMnNoSW5wdXRTaXplLFxuICAgICAgdHhQMnNoUDJ3c2hJbnB1dFNpemUsXG4gICAgICB0eFAyd3NoSW5wdXRTaXplLFxuICAgICAgdHhQMnRyS2V5cGF0aElucHV0U2l6ZSxcbiAgICAgIHR4UDJ0clNjcmlwdFBhdGhMZXZlbDFJbnB1dFNpemUsXG4gICAgICB0eFAydHJTY3JpcHRQYXRoTGV2ZWwySW5wdXRTaXplLFxuICAgICAgdHhQMnNoUDJwa0lucHV0U2l6ZSxcbiAgICB9ID0gVmlydHVhbFNpemVzO1xuXG4gICAgY29uc3Qge1xuICAgICAgblAyc2hJbnB1dHMsXG4gICAgICBuUDJzaFAyd3NoSW5wdXRzLFxuICAgICAgblAyd3NoSW5wdXRzLFxuICAgICAgblAydHJLZXlwYXRoSW5wdXRzLFxuICAgICAgblAydHJTY3JpcHRQYXRoTGV2ZWwxSW5wdXRzLFxuICAgICAgblAydHJTY3JpcHRQYXRoTGV2ZWwySW5wdXRzLFxuICAgICAgblAyc2hQMnBrSW5wdXRzLFxuICAgIH0gPSB0aGlzO1xuXG4gICAgY29uc3Qgc2l6ZSA9XG4gICAgICBuUDJzaElucHV0cyAqIHR4UDJzaElucHV0U2l6ZSArXG4gICAgICBuUDJzaFAyd3NoSW5wdXRzICogdHhQMnNoUDJ3c2hJbnB1dFNpemUgK1xuICAgICAgblAyd3NoSW5wdXRzICogdHhQMndzaElucHV0U2l6ZSArXG4gICAgICBuUDJ0cktleXBhdGhJbnB1dHMgKiB0eFAydHJLZXlwYXRoSW5wdXRTaXplICtcbiAgICAgIG5QMnNoUDJwa0lucHV0cyAqIHR4UDJzaFAycGtJbnB1dFNpemUgK1xuICAgICAgblAydHJTY3JpcHRQYXRoTGV2ZWwxSW5wdXRzICogdHhQMnRyU2NyaXB0UGF0aExldmVsMUlucHV0U2l6ZSArXG4gICAgICBuUDJ0clNjcmlwdFBhdGhMZXZlbDJJbnB1dHMgKiB0eFAydHJTY3JpcHRQYXRoTGV2ZWwySW5wdXRTaXplO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oc2l6ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzaXplYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpemU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge251bWJlcn0gcmV0dXJuIHZzaXplIG9mIG91dHB1dHMsIHdpdGhvdXQgb3ZlcmhlYWRcbiAgICovXG4gIGdldE91dHB1dHNWU2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLm91dHB1dHMuc2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc3RpbWF0ZXMgdGhlIHZpcnR1YWwgc2l6ZSAoMS80IHdlaWdodCkgb2YgYSBzaWduZWQgdHJhbnNhY3Rpb24gYXMgc3VtIG9mXG4gICAqIG92ZXJoZWFkIHZzaXplLCBpbnB1dCB2c2l6ZSBhbmQgb3V0cHV0IHZzaXplLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgZXN0aW1hdGVkIHZzaXplIG9mIHRoZSB0cmFuc2FjdGlvbiBkaW1lbnNpb25zLlxuICAgKi9cbiAgZ2V0VlNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPdmVyaGVhZFZTaXplKCkgKyB0aGlzLmdldElucHV0c1ZTaXplKCkgKyB0aGlzLmdldE91dHB1dHNWU2l6ZSgpO1xuICB9XG59XG4iXX0=