"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compactSize = exports.pushdataEncodingLength = void 0;
const types_1 = require("./types");
/**
 * Overhead size for a pushdata element in a script
 * @param i
 */
function pushdataEncodingLength(i) {
    /*
     * https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#push-operators
     * Pushing any other byte sequence up to 75 bytes must use the normal data push (opcode byte n, with n the number of bytes, followed n bytes of data being pushed).
     * Pushing 76 to 255 bytes must use OP_PUSHDATA1.
     * Pushing 256 to 520 bytes must use OP_PUSHDATA2.
     * OP_PUSHDATA4 can never be used, as pushes over 520 bytes are not allowed, and those below can be done using other operators.
     */
    if (i < 76) {
        return 1;
    }
    if (i < 255) {
        return 2;
    }
    if (i < 520) {
        return 3;
    }
    throw new Error(`invalid pushdata size`);
}
exports.pushdataEncodingLength = pushdataEncodingLength;
/**
 * https://developer.bitcoin.org/reference/transactions.html#compactsize-unsigned-integers
 * https://github.com/bitcoinjs/varuint-bitcoin/blob/1d5b253/index.js#L79
 * @param integer
 * @return {number} - The compact size the integer requires when serialized in a transaction
 */
function compactSize(integer) {
    if (!types_1.PositiveInteger.is(integer)) {
        throw new TypeError(`expected positive integer`);
    }
    if (integer <= 252) {
        return 1;
    }
    if (integer <= 0xffff) {
        return 3;
    }
    if (integer <= 0xffffffff) {
        return 5;
    }
    return 9;
}
exports.compactSize = compactSize;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NyaXB0U2l6ZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc2NyaXB0U2l6ZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsbUNBQTBDO0FBRTFDOzs7R0FHRztBQUNILFNBQWdCLHNCQUFzQixDQUFDLENBQVM7SUFDOUM7Ozs7OztPQU1HO0lBQ0gsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFO1FBQ1YsT0FBTyxDQUFDLENBQUM7S0FDVjtJQUNELElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRTtRQUNYLE9BQU8sQ0FBQyxDQUFDO0tBQ1Y7SUFDRCxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUU7UUFDWCxPQUFPLENBQUMsQ0FBQztLQUNWO0lBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBQzNDLENBQUM7QUFsQkQsd0RBa0JDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixXQUFXLENBQUMsT0FBZTtJQUN6QyxJQUFJLENBQUMsdUJBQWUsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDaEMsTUFBTSxJQUFJLFNBQVMsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO0tBQ2xEO0lBQ0QsSUFBSSxPQUFPLElBQUksR0FBRyxFQUFFO1FBQ2xCLE9BQU8sQ0FBQyxDQUFDO0tBQ1Y7SUFDRCxJQUFJLE9BQU8sSUFBSSxNQUFNLEVBQUU7UUFDckIsT0FBTyxDQUFDLENBQUM7S0FDVjtJQUNELElBQUksT0FBTyxJQUFJLFVBQVUsRUFBRTtRQUN6QixPQUFPLENBQUMsQ0FBQztLQUNWO0lBQ0QsT0FBTyxDQUFDLENBQUM7QUFDWCxDQUFDO0FBZEQsa0NBY0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb3NpdGl2ZUludGVnZXIgfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBPdmVyaGVhZCBzaXplIGZvciBhIHB1c2hkYXRhIGVsZW1lbnQgaW4gYSBzY3JpcHRcbiAqIEBwYXJhbSBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwdXNoZGF0YUVuY29kaW5nTGVuZ3RoKGk6IG51bWJlcik6IG51bWJlciB7XG4gIC8qXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwNjIubWVkaWF3aWtpI3B1c2gtb3BlcmF0b3JzXG4gICAqIFB1c2hpbmcgYW55IG90aGVyIGJ5dGUgc2VxdWVuY2UgdXAgdG8gNzUgYnl0ZXMgbXVzdCB1c2UgdGhlIG5vcm1hbCBkYXRhIHB1c2ggKG9wY29kZSBieXRlIG4sIHdpdGggbiB0aGUgbnVtYmVyIG9mIGJ5dGVzLCBmb2xsb3dlZCBuIGJ5dGVzIG9mIGRhdGEgYmVpbmcgcHVzaGVkKS5cbiAgICogUHVzaGluZyA3NiB0byAyNTUgYnl0ZXMgbXVzdCB1c2UgT1BfUFVTSERBVEExLlxuICAgKiBQdXNoaW5nIDI1NiB0byA1MjAgYnl0ZXMgbXVzdCB1c2UgT1BfUFVTSERBVEEyLlxuICAgKiBPUF9QVVNIREFUQTQgY2FuIG5ldmVyIGJlIHVzZWQsIGFzIHB1c2hlcyBvdmVyIDUyMCBieXRlcyBhcmUgbm90IGFsbG93ZWQsIGFuZCB0aG9zZSBiZWxvdyBjYW4gYmUgZG9uZSB1c2luZyBvdGhlciBvcGVyYXRvcnMuXG4gICAqL1xuICBpZiAoaSA8IDc2KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgaWYgKGkgPCAyNTUpIHtcbiAgICByZXR1cm4gMjtcbiAgfVxuICBpZiAoaSA8IDUyMCkge1xuICAgIHJldHVybiAzO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBwdXNoZGF0YSBzaXplYCk7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9kZXZlbG9wZXIuYml0Y29pbi5vcmcvcmVmZXJlbmNlL3RyYW5zYWN0aW9ucy5odG1sI2NvbXBhY3RzaXplLXVuc2lnbmVkLWludGVnZXJzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL3ZhcnVpbnQtYml0Y29pbi9ibG9iLzFkNWIyNTMvaW5kZXguanMjTDc5XG4gKiBAcGFyYW0gaW50ZWdlclxuICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSBjb21wYWN0IHNpemUgdGhlIGludGVnZXIgcmVxdWlyZXMgd2hlbiBzZXJpYWxpemVkIGluIGEgdHJhbnNhY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhY3RTaXplKGludGVnZXI6IG51bWJlcik6IG51bWJlciB7XG4gIGlmICghUG9zaXRpdmVJbnRlZ2VyLmlzKGludGVnZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcmApO1xuICB9XG4gIGlmIChpbnRlZ2VyIDw9IDI1Mikge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGlmIChpbnRlZ2VyIDw9IDB4ZmZmZikge1xuICAgIHJldHVybiAzO1xuICB9XG4gIGlmIChpbnRlZ2VyIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICByZXR1cm4gNTtcbiAgfVxuICByZXR1cm4gOTtcbn1cbiJdfQ==