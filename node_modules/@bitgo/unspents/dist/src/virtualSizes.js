"use strict";
/*
This is a reference implementation for calculating weights and vSizes from bitcoinjs-lib 3.3.2.
https://github.com/bitcoinjs/bitcoinjs-lib/blob/v3.3.2/src/transaction.js#L194-L219

```
  function encodingLength (number) {
    checkUInt53(number)

    return (
      number < 0xfd ? 1
    : number <= 0xffff ? 3
    : number <= 0xffffffff ? 5
    : 9
    )
  }

  function varSliceSize (someScript) {
    var length = someScript.length

    return encodingLength(length) + length
  }

  function vectorSize (someVector) {
    var length = someVector.length

    return varuint.encodingLength(length) + someVector.reduce(function (sum, witness) {
      return sum + varSliceSize(witness)
    }, 0)
  }

  Transaction.prototype.__byteLength = function (__allowWitness) {
    var hasWitnesses = __allowWitness && this.hasWitnesses()

    return (
      (hasWitnesses ? 10 : 8) +
      varuint.encodingLength(this.ins.length) +
      varuint.encodingLength(this.outs.length) +
      this.ins.reduce(function (sum, input) { return sum + 40 + varSliceSize(input.script) }, 0) +
      this.outs.reduce(function (sum, output) { return sum + 8 + varSliceSize(output.script) }, 0) +
      (hasWitnesses ? this.ins.reduce(function (sum, input) { return sum + vectorSize(input.witness) }, 0) : 0)
    )
  }

  Transaction.prototype.weight = function () {
    var base = this.__byteLength(false)
    var total = this.__byteLength(true)
    return base * 3 + total
  }

  Transaction.prototype.virtualSize = function () {
    return Math.ceil(this.weight() / 4)
  }
```
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.VirtualSizes = void 0;
const inputWeights_1 = require("./inputWeights");
function getVirtualInputSizeFromComponents(components) {
    return Math.ceil((0, inputWeights_1.getInputComponentsWeight)(components) / 4);
}
// Constants for signed TX input and output vsizes.
// See https://bitcoincore.org/en/segwit_wallet_dev/#transaction-serialization for full description
// FIXME(BG-9233): use weight units instead
exports.VirtualSizes = Object.freeze({
    // FIXME(BG-7873): add support for signature grinding
    // Size of a P2PKH input with (un)compressed key
    /** @deprecated */
    txP2pkhInputSizeCompressedKey: 148,
    /** @deprecated */
    txP2pkhInputSizeUncompressedKey: 180,
    // Input sizes
    txP2shInputSize: getVirtualInputSizeFromComponents(inputWeights_1.inputComponentsP2sh),
    txP2shP2wshInputSize: getVirtualInputSizeFromComponents(inputWeights_1.inputComponentsP2shP2wsh),
    txP2wshInputSize: getVirtualInputSizeFromComponents(inputWeights_1.inputComponentsP2wsh),
    txP2trKeypathInputSize: getVirtualInputSizeFromComponents(inputWeights_1.inputComponentsP2trKeySpend),
    txP2shP2pkInputSize: getVirtualInputSizeFromComponents(inputWeights_1.inputComponentsP2shP2pk),
    txP2trScriptPathLevel1InputSize: getVirtualInputSizeFromComponents(inputWeights_1.inputComponentsP2trScriptSpendLevel1),
    txP2trScriptPathLevel2InputSize: getVirtualInputSizeFromComponents(inputWeights_1.inputComponentsP2trScriptSpendLevel2),
    //
    // Output sizes
    //
    // The size is calculated as
    //
    //    scriptLength + compactSize(scriptLength) + txOutputAmountSize
    //
    // Since compactSize(scriptLength) is 1 for all scripts considered here, we can simplify this to
    //
    //    scriptLength + 9
    //
    // Size of single output amount
    txOutputAmountSize: 8,
    // https://github.com/bitcoinjs/bitcoinjs-lib/blob/v4.0.2/src/templates/scripthash/output.js#L9
    txP2shOutputSize: 32,
    txP2shP2wshOutputSize: 32,
    // https://github.com/bitcoinjs/bitcoinjs-lib/blob/v4.0.2/src/templates/witnessscripthash/output.js#L9
    txP2wshOutputSize: 43,
    // OP_1 OP_PUSH32 <schnorr_public_key>
    txP2trOutputSize: 43,
    // https://github.com/bitcoinjs/bitcoinjs-lib/blob/v4.0.2/src/templates/pubkeyhash/output.js#L9
    txP2pkhOutputSize: 34,
    // https://github.com/bitcoinjs/bitcoinjs-lib/blob/v4.0.2/src/templates/witnesspubkeyhash/output.js#L9
    txP2wpkhOutputSize: 31,
    /** @deprecated - use txP2pkhOutputSize instead */
    txOutputSize: 34,
    //
    // General tx size constants
    //
    txOverheadSize: 10,
    // Segwit adds one byte each for marker and flag to the witness section.
    // Thus, the vsize is only increased by one.
    txSegOverheadVSize: 11,
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlydHVhbFNpemVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3ZpcnR1YWxTaXplcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBcURFOzs7QUFFRixpREFVd0I7QUFFeEIsU0FBUyxpQ0FBaUMsQ0FBQyxVQUEyQjtJQUNwRSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBQSx1Q0FBd0IsRUFBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUM3RCxDQUFDO0FBRUQsbURBQW1EO0FBQ25ELG1HQUFtRztBQUNuRywyQ0FBMkM7QUFDOUIsUUFBQSxZQUFZLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztJQUN4QyxxREFBcUQ7SUFFckQsZ0RBQWdEO0lBQ2hELGtCQUFrQjtJQUNsQiw2QkFBNkIsRUFBRSxHQUFHO0lBQ2xDLGtCQUFrQjtJQUNsQiwrQkFBK0IsRUFBRSxHQUFHO0lBRXBDLGNBQWM7SUFDZCxlQUFlLEVBQUUsaUNBQWlDLENBQUMsa0NBQW1CLENBQUM7SUFDdkUsb0JBQW9CLEVBQUUsaUNBQWlDLENBQUMsdUNBQXdCLENBQUM7SUFDakYsZ0JBQWdCLEVBQUUsaUNBQWlDLENBQUMsbUNBQW9CLENBQUM7SUFDekUsc0JBQXNCLEVBQUUsaUNBQWlDLENBQUMsMENBQTJCLENBQUM7SUFDdEYsbUJBQW1CLEVBQUUsaUNBQWlDLENBQUMsc0NBQXVCLENBQUM7SUFDL0UsK0JBQStCLEVBQUUsaUNBQWlDLENBQUMsbURBQW9DLENBQUM7SUFDeEcsK0JBQStCLEVBQUUsaUNBQWlDLENBQUMsbURBQW9DLENBQUM7SUFFeEcsRUFBRTtJQUNGLGVBQWU7SUFDZixFQUFFO0lBRUYsNEJBQTRCO0lBQzVCLEVBQUU7SUFDRixtRUFBbUU7SUFDbkUsRUFBRTtJQUNGLGdHQUFnRztJQUNoRyxFQUFFO0lBQ0Ysc0JBQXNCO0lBQ3RCLEVBQUU7SUFFRiwrQkFBK0I7SUFDL0Isa0JBQWtCLEVBQUUsQ0FBQztJQUVyQiwrRkFBK0Y7SUFDL0YsZ0JBQWdCLEVBQUUsRUFBRTtJQUNwQixxQkFBcUIsRUFBRSxFQUFFO0lBQ3pCLHNHQUFzRztJQUN0RyxpQkFBaUIsRUFBRSxFQUFFO0lBQ3JCLHNDQUFzQztJQUN0QyxnQkFBZ0IsRUFBRSxFQUFFO0lBQ3BCLCtGQUErRjtJQUMvRixpQkFBaUIsRUFBRSxFQUFFO0lBQ3JCLHNHQUFzRztJQUN0RyxrQkFBa0IsRUFBRSxFQUFFO0lBRXRCLGtEQUFrRDtJQUNsRCxZQUFZLEVBQUUsRUFBRTtJQUVoQixFQUFFO0lBQ0YsNEJBQTRCO0lBQzVCLEVBQUU7SUFFRixjQUFjLEVBQUUsRUFBRTtJQUNsQix3RUFBd0U7SUFDeEUsNENBQTRDO0lBQzVDLGtCQUFrQixFQUFFLEVBQUU7Q0FDdkIsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLypcblRoaXMgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gZm9yIGNhbGN1bGF0aW5nIHdlaWdodHMgYW5kIHZTaXplcyBmcm9tIGJpdGNvaW5qcy1saWIgMy4zLjIuXG5odHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL2JpdGNvaW5qcy1saWIvYmxvYi92My4zLjIvc3JjL3RyYW5zYWN0aW9uLmpzI0wxOTQtTDIxOVxuXG5gYGBcbiAgZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKG51bWJlcikge1xuICAgIGNoZWNrVUludDUzKG51bWJlcilcblxuICAgIHJldHVybiAoXG4gICAgICBudW1iZXIgPCAweGZkID8gMVxuICAgIDogbnVtYmVyIDw9IDB4ZmZmZiA/IDNcbiAgICA6IG51bWJlciA8PSAweGZmZmZmZmZmID8gNVxuICAgIDogOVxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhclNsaWNlU2l6ZSAoc29tZVNjcmlwdCkge1xuICAgIHZhciBsZW5ndGggPSBzb21lU2NyaXB0Lmxlbmd0aFxuXG4gICAgcmV0dXJuIGVuY29kaW5nTGVuZ3RoKGxlbmd0aCkgKyBsZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIHZlY3RvclNpemUgKHNvbWVWZWN0b3IpIHtcbiAgICB2YXIgbGVuZ3RoID0gc29tZVZlY3Rvci5sZW5ndGhcblxuICAgIHJldHVybiB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKGxlbmd0aCkgKyBzb21lVmVjdG9yLnJlZHVjZShmdW5jdGlvbiAoc3VtLCB3aXRuZXNzKSB7XG4gICAgICByZXR1cm4gc3VtICsgdmFyU2xpY2VTaXplKHdpdG5lc3MpXG4gICAgfSwgMClcbiAgfVxuXG4gIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5fX2J5dGVMZW5ndGggPSBmdW5jdGlvbiAoX19hbGxvd1dpdG5lc3MpIHtcbiAgICB2YXIgaGFzV2l0bmVzc2VzID0gX19hbGxvd1dpdG5lc3MgJiYgdGhpcy5oYXNXaXRuZXNzZXMoKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChoYXNXaXRuZXNzZXMgPyAxMCA6IDgpICtcbiAgICAgIHZhcnVpbnQuZW5jb2RpbmdMZW5ndGgodGhpcy5pbnMubGVuZ3RoKSArXG4gICAgICB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKHRoaXMub3V0cy5sZW5ndGgpICtcbiAgICAgIHRoaXMuaW5zLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBpbnB1dCkgeyByZXR1cm4gc3VtICsgNDAgKyB2YXJTbGljZVNpemUoaW5wdXQuc2NyaXB0KSB9LCAwKSArXG4gICAgICB0aGlzLm91dHMucmVkdWNlKGZ1bmN0aW9uIChzdW0sIG91dHB1dCkgeyByZXR1cm4gc3VtICsgOCArIHZhclNsaWNlU2l6ZShvdXRwdXQuc2NyaXB0KSB9LCAwKSArXG4gICAgICAoaGFzV2l0bmVzc2VzID8gdGhpcy5pbnMucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGlucHV0KSB7IHJldHVybiBzdW0gKyB2ZWN0b3JTaXplKGlucHV0LndpdG5lc3MpIH0sIDApIDogMClcbiAgICApXG4gIH1cblxuICBUcmFuc2FjdGlvbi5wcm90b3R5cGUud2VpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBiYXNlID0gdGhpcy5fX2J5dGVMZW5ndGgoZmFsc2UpXG4gICAgdmFyIHRvdGFsID0gdGhpcy5fX2J5dGVMZW5ndGgodHJ1ZSlcbiAgICByZXR1cm4gYmFzZSAqIDMgKyB0b3RhbFxuICB9XG5cbiAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLnZpcnR1YWxTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy53ZWlnaHQoKSAvIDQpXG4gIH1cbmBgYFxuKi9cblxuaW1wb3J0IHtcbiAgZ2V0SW5wdXRDb21wb25lbnRzV2VpZ2h0LFxuICBJbnB1dENvbXBvbmVudHMsXG4gIGlucHV0Q29tcG9uZW50c1Ayc2gsXG4gIGlucHV0Q29tcG9uZW50c1Ayc2hQMnBrLFxuICBpbnB1dENvbXBvbmVudHNQMnNoUDJ3c2gsXG4gIGlucHV0Q29tcG9uZW50c1AydHJLZXlTcGVuZCxcbiAgaW5wdXRDb21wb25lbnRzUDJ0clNjcmlwdFNwZW5kTGV2ZWwxLFxuICBpbnB1dENvbXBvbmVudHNQMnRyU2NyaXB0U3BlbmRMZXZlbDIsXG4gIGlucHV0Q29tcG9uZW50c1Ayd3NoLFxufSBmcm9tICcuL2lucHV0V2VpZ2h0cyc7XG5cbmZ1bmN0aW9uIGdldFZpcnR1YWxJbnB1dFNpemVGcm9tQ29tcG9uZW50cyhjb21wb25lbnRzOiBJbnB1dENvbXBvbmVudHMpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5jZWlsKGdldElucHV0Q29tcG9uZW50c1dlaWdodChjb21wb25lbnRzKSAvIDQpO1xufVxuXG4vLyBDb25zdGFudHMgZm9yIHNpZ25lZCBUWCBpbnB1dCBhbmQgb3V0cHV0IHZzaXplcy5cbi8vIFNlZSBodHRwczovL2JpdGNvaW5jb3JlLm9yZy9lbi9zZWd3aXRfd2FsbGV0X2Rldi8jdHJhbnNhY3Rpb24tc2VyaWFsaXphdGlvbiBmb3IgZnVsbCBkZXNjcmlwdGlvblxuLy8gRklYTUUoQkctOTIzMyk6IHVzZSB3ZWlnaHQgdW5pdHMgaW5zdGVhZFxuZXhwb3J0IGNvbnN0IFZpcnR1YWxTaXplcyA9IE9iamVjdC5mcmVlemUoe1xuICAvLyBGSVhNRShCRy03ODczKTogYWRkIHN1cHBvcnQgZm9yIHNpZ25hdHVyZSBncmluZGluZ1xuXG4gIC8vIFNpemUgb2YgYSBQMlBLSCBpbnB1dCB3aXRoICh1biljb21wcmVzc2VkIGtleVxuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgdHhQMnBraElucHV0U2l6ZUNvbXByZXNzZWRLZXk6IDE0OCxcbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIHR4UDJwa2hJbnB1dFNpemVVbmNvbXByZXNzZWRLZXk6IDE4MCxcblxuICAvLyBJbnB1dCBzaXplc1xuICB0eFAyc2hJbnB1dFNpemU6IGdldFZpcnR1YWxJbnB1dFNpemVGcm9tQ29tcG9uZW50cyhpbnB1dENvbXBvbmVudHNQMnNoKSxcbiAgdHhQMnNoUDJ3c2hJbnB1dFNpemU6IGdldFZpcnR1YWxJbnB1dFNpemVGcm9tQ29tcG9uZW50cyhpbnB1dENvbXBvbmVudHNQMnNoUDJ3c2gpLFxuICB0eFAyd3NoSW5wdXRTaXplOiBnZXRWaXJ0dWFsSW5wdXRTaXplRnJvbUNvbXBvbmVudHMoaW5wdXRDb21wb25lbnRzUDJ3c2gpLFxuICB0eFAydHJLZXlwYXRoSW5wdXRTaXplOiBnZXRWaXJ0dWFsSW5wdXRTaXplRnJvbUNvbXBvbmVudHMoaW5wdXRDb21wb25lbnRzUDJ0cktleVNwZW5kKSxcbiAgdHhQMnNoUDJwa0lucHV0U2l6ZTogZ2V0VmlydHVhbElucHV0U2l6ZUZyb21Db21wb25lbnRzKGlucHV0Q29tcG9uZW50c1Ayc2hQMnBrKSxcbiAgdHhQMnRyU2NyaXB0UGF0aExldmVsMUlucHV0U2l6ZTogZ2V0VmlydHVhbElucHV0U2l6ZUZyb21Db21wb25lbnRzKGlucHV0Q29tcG9uZW50c1AydHJTY3JpcHRTcGVuZExldmVsMSksXG4gIHR4UDJ0clNjcmlwdFBhdGhMZXZlbDJJbnB1dFNpemU6IGdldFZpcnR1YWxJbnB1dFNpemVGcm9tQ29tcG9uZW50cyhpbnB1dENvbXBvbmVudHNQMnRyU2NyaXB0U3BlbmRMZXZlbDIpLFxuXG4gIC8vXG4gIC8vIE91dHB1dCBzaXplc1xuICAvL1xuXG4gIC8vIFRoZSBzaXplIGlzIGNhbGN1bGF0ZWQgYXNcbiAgLy9cbiAgLy8gICAgc2NyaXB0TGVuZ3RoICsgY29tcGFjdFNpemUoc2NyaXB0TGVuZ3RoKSArIHR4T3V0cHV0QW1vdW50U2l6ZVxuICAvL1xuICAvLyBTaW5jZSBjb21wYWN0U2l6ZShzY3JpcHRMZW5ndGgpIGlzIDEgZm9yIGFsbCBzY3JpcHRzIGNvbnNpZGVyZWQgaGVyZSwgd2UgY2FuIHNpbXBsaWZ5IHRoaXMgdG9cbiAgLy9cbiAgLy8gICAgc2NyaXB0TGVuZ3RoICsgOVxuICAvL1xuXG4gIC8vIFNpemUgb2Ygc2luZ2xlIG91dHB1dCBhbW91bnRcbiAgdHhPdXRwdXRBbW91bnRTaXplOiA4LFxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luanMvYml0Y29pbmpzLWxpYi9ibG9iL3Y0LjAuMi9zcmMvdGVtcGxhdGVzL3NjcmlwdGhhc2gvb3V0cHV0LmpzI0w5XG4gIHR4UDJzaE91dHB1dFNpemU6IDMyLFxuICB0eFAyc2hQMndzaE91dHB1dFNpemU6IDMyLFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL2JpdGNvaW5qcy1saWIvYmxvYi92NC4wLjIvc3JjL3RlbXBsYXRlcy93aXRuZXNzc2NyaXB0aGFzaC9vdXRwdXQuanMjTDlcbiAgdHhQMndzaE91dHB1dFNpemU6IDQzLFxuICAvLyBPUF8xIE9QX1BVU0gzMiA8c2Nobm9ycl9wdWJsaWNfa2V5PlxuICB0eFAydHJPdXRwdXRTaXplOiA0MyxcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXRjb2luanMtbGliL2Jsb2IvdjQuMC4yL3NyYy90ZW1wbGF0ZXMvcHVia2V5aGFzaC9vdXRwdXQuanMjTDlcbiAgdHhQMnBraE91dHB1dFNpemU6IDM0LFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL2JpdGNvaW5qcy1saWIvYmxvYi92NC4wLjIvc3JjL3RlbXBsYXRlcy93aXRuZXNzcHVia2V5aGFzaC9vdXRwdXQuanMjTDlcbiAgdHhQMndwa2hPdXRwdXRTaXplOiAzMSxcblxuICAvKiogQGRlcHJlY2F0ZWQgLSB1c2UgdHhQMnBraE91dHB1dFNpemUgaW5zdGVhZCAqL1xuICB0eE91dHB1dFNpemU6IDM0LFxuXG4gIC8vXG4gIC8vIEdlbmVyYWwgdHggc2l6ZSBjb25zdGFudHNcbiAgLy9cblxuICB0eE92ZXJoZWFkU2l6ZTogMTAsXG4gIC8vIFNlZ3dpdCBhZGRzIG9uZSBieXRlIGVhY2ggZm9yIG1hcmtlciBhbmQgZmxhZyB0byB0aGUgd2l0bmVzcyBzZWN0aW9uLlxuICAvLyBUaHVzLCB0aGUgdnNpemUgaXMgb25seSBpbmNyZWFzZWQgYnkgb25lLlxuICB0eFNlZ092ZXJoZWFkVlNpemU6IDExLFxufSk7XG4iXX0=