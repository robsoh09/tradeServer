"use strict";
/**
 * @hidden
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 */
//
// TransactionBuilder
// A utility for building and signing transactions
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
const utxo_lib_1 = require("@bitgo/utxo-lib");
const Bluebird = require("bluebird");
const utxolib = require("@bitgo/utxo-lib");
const _ = require("lodash");
const unspents_1 = require("@bitgo/unspents");
const debugLib = require("debug");
const debug = debugLib('bitgo:v1:txb');
const sdk_core_1 = require("@bitgo/sdk-core");
const verifyAddress_1 = require("./verifyAddress");
//
// TransactionBuilder
// @params:
//   wallet:  a wallet object to send from
//   recipients: array of recipient objects and the amount to send to each e.g. [{address: '38BKDNZbPcLogvVbcx2ekJ9E6Vv94DqDqw', amount: 1500}, {address: '36eL8yQqCn1HMRmVFFo49t2PJ3pai8wQam', amount: 2000}]
//   fee: the fee to use with this transaction.  if not provided, a default, minimum fee will be used.
//   feeRate: the amount of fee per kilobyte - optional - specify either fee, feeRate, or feeTxConfirmTarget but not more than one
//   feeTxConfirmTarget: calculate the fees per kilobyte such that the transaction will be confirmed in this number of blocks
//   maxFeeRate: The maximum fee per kb to use in satoshis, for safety purposes when using dynamic fees
//   minConfirms: the minimum confirmations an output must have before spending
//   forceChangeAtEnd: force the change address to be the last output
//   changeAddress: specify the change address rather than generate a new one
//   noSplitChange: set to true to disable automatic change splitting for purposes of unspent management
//   targetWalletUnspents: specify a number of target unspents to maintain in the wallet (currently defaulted to 8 by the server)
//   validate: extra verification of the change addresses, which is always done server-side and is redundant client-side (defaults true)
//   minUnspentSize: The minimum size in satoshis of unspent to use (to prevent spending unspents worth less than fee added). Defaults to 0.
//   feeSingleKeySourceAddress: Use this single key address to pay fees
//   feeSingleKeyWIF: Use the address based on this private key to pay fees
//   unspentsFetchParams: Extra parameters to use for fetching unspents for this transaction
//   unspents: array of unspent objects to use while constructing the transaction instead of fetching from the API
exports.createTransaction = function (params) {
    const minConfirms = params.minConfirms || 0;
    const validate = params.validate === undefined ? true : params.validate;
    let recipients = [];
    let opReturns = [];
    let extraChangeAmounts = [];
    let estTxSize;
    let travelInfos;
    // Sanity check the arguments passed in
    if (!_.isObject(params.wallet) ||
        (params.fee && !_.isNumber(params.fee)) ||
        (params.feeRate && !_.isNumber(params.feeRate)) ||
        !_.isInteger(minConfirms) ||
        (params.forceChangeAtEnd && !_.isBoolean(params.forceChangeAtEnd)) ||
        (params.changeAddress && !_.isString(params.changeAddress)) ||
        (params.noSplitChange && !_.isBoolean(params.noSplitChange)) ||
        (params.targetWalletUnspents && !_.isInteger(params.targetWalletUnspents)) ||
        (validate && !_.isBoolean(validate)) ||
        (params.enforceMinConfirmsForChange && !_.isBoolean(params.enforceMinConfirmsForChange)) ||
        (params.minUnspentSize && !_.isNumber(params.minUnspentSize)) ||
        (params.maxFeeRate && !_.isNumber(params.maxFeeRate)) ||
        // this should be an array and its length must be at least 1
        (params.unspents && (!Array.isArray(params.unspents) || params.unspents.length < 1)) ||
        (params.feeTxConfirmTarget && !_.isInteger(params.feeTxConfirmTarget)) ||
        (params.instant && !_.isBoolean(params.instant)) ||
        (params.bitgoFee && !_.isObject(params.bitgoFee)) ||
        (params.unspentsFetchParams && !_.isObject(params.unspentsFetchParams))) {
        throw new Error('invalid argument');
    }
    const bitgo = params.wallet.bitgo;
    const constants = bitgo.getConstants();
    const network = (0, sdk_core_1.getNetwork)(sdk_core_1.common.Environments[bitgo.getEnv()].network);
    // The user can specify a seperate, single-key wallet for the purposes of paying miner's fees
    // When creating a transaction this can be specified as an input address or the private key in WIF
    let feeSingleKeySourceAddress;
    let feeSingleKeyInputAmount = 0;
    if (params.feeSingleKeySourceAddress) {
        try {
            utxolib.address.fromBase58Check(params.feeSingleKeySourceAddress, network);
            feeSingleKeySourceAddress = params.feeSingleKeySourceAddress;
        }
        catch (e) {
            throw new Error('invalid bitcoin address: ' + params.feeSingleKeySourceAddress);
        }
    }
    if (params.feeSingleKeyWIF) {
        const feeSingleKey = utxolib.ECPair.fromWIF(params.feeSingleKeyWIF, network);
        feeSingleKeySourceAddress = (0, sdk_core_1.getAddressP2PKH)(feeSingleKey);
        // If the user specifies both, check to make sure the feeSingleKeySourceAddress corresponds to the address of feeSingleKeyWIF
        if (params.feeSingleKeySourceAddress && params.feeSingleKeySourceAddress !== feeSingleKeySourceAddress) {
            throw new Error('feeSingleKeySourceAddress: ' +
                params.feeSingleKeySourceAddress +
                ' did not correspond to address of feeSingleKeyWIF: ' +
                feeSingleKeySourceAddress);
        }
    }
    if (!_.isObject(params.recipients)) {
        throw new Error('recipients must be array of { address: abc, amount: 100000 } objects');
    }
    let feeParamsDefined = 0;
    if (!_.isUndefined(params.fee)) {
        feeParamsDefined++;
    }
    if (!_.isUndefined(params.feeRate)) {
        feeParamsDefined++;
    }
    if (!_.isUndefined(params.feeTxConfirmTarget)) {
        feeParamsDefined++;
    }
    if (feeParamsDefined > 1) {
        throw new Error('cannot specify more than one of fee, feeRate and feeTxConfirmTarget');
    }
    if (_.isUndefined(params.maxFeeRate)) {
        params.maxFeeRate = constants.maxFeeRate;
    }
    // Convert the old format of params.recipients (dictionary of address:amount) to new format: { destinationAddress, amount }
    if (!(params.recipients instanceof Array)) {
        recipients = [];
        Object.keys(params.recipients).forEach(function (destinationAddress) {
            const amount = params.recipients[destinationAddress];
            recipients.push({ address: destinationAddress, amount: amount });
        });
    }
    else {
        recipients = params.recipients;
    }
    if (params.opReturns) {
        if (!(params.opReturns instanceof Array)) {
            opReturns = [];
            Object.keys(params.opReturns).forEach(function (message) {
                const amount = params.opReturns[message];
                opReturns.push({ message, amount });
            });
        }
        else {
            opReturns = params.opReturns;
        }
    }
    if (recipients.length === 0 && opReturns.length === 0) {
        throw new Error('must have at least one recipient');
    }
    let fee = params.fee;
    let feeRate = params.feeRate;
    // Flag indicating whether this class will compute the fee
    const shouldComputeBestFee = _.isUndefined(fee);
    let totalOutputAmount = 0;
    recipients.forEach(function (recipient) {
        if (_.isString(recipient.address)) {
            if (!(0, verifyAddress_1.verifyAddress)(recipient.address, network)) {
                throw new Error('invalid bitcoin address: ' + recipient.address);
            }
            if (!!recipient.script) {
                // A script was provided as well - validate that the address corresponds to that
                if (utxolib.address.toOutputScript(recipient.address, network).toString('hex') !== recipient.script) {
                    throw new Error('both script and address provided but they did not match: ' + recipient.address + ' ' + recipient.script);
                }
            }
        }
        if (!_.isInteger(recipient.amount) || recipient.amount < 0) {
            throw new Error('invalid amount for ' + recipient.address + ': ' + recipient.amount);
        }
        totalOutputAmount += recipient.amount;
    });
    opReturns.forEach(function (opReturn) {
        totalOutputAmount += opReturn.amount;
    });
    let bitgoFeeInfo = params.bitgoFee;
    if (bitgoFeeInfo && (!_.isInteger(bitgoFeeInfo.amount) || !_.isString(bitgoFeeInfo.address))) {
        throw new Error('invalid bitgoFeeInfo');
    }
    // The total amount needed for this transaction.
    let totalAmount = totalOutputAmount + (fee || 0);
    // The list of unspent transactions being used in this transaction.
    let unspents;
    // the total number of unspents on this wallet
    let totalUnspentsCount;
    // the number of unspents we fetched from the server, before filtering
    let fetchedUnspentsCount;
    // The list of unspent transactions being used with zero-confirmations
    let zeroConfUnspentTxIds;
    // The sum of the input values for this transaction.
    let inputAmount;
    let changeOutputs = [];
    let containsUncompressedPublicKeys = false;
    // The transaction.
    let transaction = utxolib.bitgo.createTransactionBuilderForNetwork(network);
    const getBitGoFee = function () {
        return Bluebird.try(function () {
            if (bitgoFeeInfo) {
                return;
            }
            return params.wallet.getBitGoFee({ amount: totalOutputAmount, instant: params.instant }).then(function (result) {
                if (result && result.fee > 0) {
                    bitgoFeeInfo = {
                        amount: result.fee,
                    };
                }
            });
        }).then(function () {
            if (bitgoFeeInfo && bitgoFeeInfo.amount > 0) {
                totalAmount += bitgoFeeInfo.amount;
            }
        });
    };
    const getBitGoFeeAddress = function () {
        return Bluebird.try(function () {
            // If we don't have bitgoFeeInfo, or address is already set, don't get a new one
            if (!bitgoFeeInfo || bitgoFeeInfo.address) {
                return;
            }
            return bitgo.getBitGoFeeAddress().then(function (result) {
                bitgoFeeInfo.address = result.address;
            });
        });
    };
    // Get a dynamic fee estimate from the BitGo server if feeTxConfirmTarget
    // is specified or if no fee-related params are specified
    const getDynamicFeeRateEstimate = function () {
        if (params.feeTxConfirmTarget || !feeParamsDefined) {
            return bitgo
                .estimateFee({
                numBlocks: params.feeTxConfirmTarget,
                maxFee: params.maxFeeRate,
                inputs: zeroConfUnspentTxIds,
                txSize: estTxSize,
                cpfpAware: true,
            })
                .then(function (result) {
                const estimatedFeeRate = result.cpfpFeePerKb;
                const minimum = params.instant
                    ? Math.max(constants.minFeeRate, constants.minInstantFeeRate)
                    : constants.minFeeRate;
                // 5 satoshis per byte
                // it is worth noting that the padding only applies when the threshold is crossed, but not when the delta is less than the padding
                const padding = 5000;
                if (estimatedFeeRate < minimum) {
                    console.log(new Date() +
                        ': Error when estimating fee for send from ' +
                        params.wallet.id() +
                        ', it was too low - ' +
                        estimatedFeeRate);
                    feeRate = minimum + padding;
                }
                else if (estimatedFeeRate > params.maxFeeRate) {
                    feeRate = params.maxFeeRate - padding;
                }
                else {
                    feeRate = estimatedFeeRate;
                }
                return feeRate;
            })
                .catch(function (e) {
                // sanity check failed on tx size
                if (_.includes(e.message, 'invalid txSize')) {
                    return Bluebird.reject(e);
                }
                else {
                    // couldn't estimate the fee, proceed using the default
                    feeRate = constants.fallbackFeeRate;
                    console.log('Error estimating fee for send from ' + params.wallet.id() + ': ' + e.message);
                    return Bluebird.resolve();
                }
            });
        }
    };
    // Get the unspents for the sending wallet.
    const getUnspents = function () {
        if (params.unspents) {
            // we just wanna use custom unspents
            unspents = params.unspents;
            return;
        }
        // Get enough unspents for the requested amount
        const options = _.merge({}, params.unspentsFetchParams || {}, {
            target: totalAmount,
            minSize: params.minUnspentSize || 0,
            instant: params.instant,
            targetWalletUnspents: params.targetWalletUnspents,
        });
        if (params.instant) {
            options.instant = params.instant; // insist on instant unspents only
        }
        return params.wallet.unspentsPaged(options).then(function (results) {
            console.log(`Unspents fetched\n:  ${JSON.stringify(results, null, 2)}`);
            totalUnspentsCount = results.total;
            fetchedUnspentsCount = results.count;
            unspents = results.unspents.filter(function (u) {
                const confirms = u.confirmations || 0;
                if (!params.enforceMinConfirmsForChange && u.isChange) {
                    return true;
                }
                return confirms >= minConfirms;
            });
            // abort early if there's no viable unspents, because it won't be possible to create the txn later
            if (unspents.length === 0) {
                throw Error('0 unspents available for transaction creation');
            }
            // create array of unconfirmed unspent ID strings of the form "txHash:outputIndex"
            zeroConfUnspentTxIds = _(results.unspents)
                .filter(function (u) {
                return !u.confirmations;
            })
                .map(function (u) {
                return u.tx_hash + ':' + u.tx_output_n;
            })
                .value();
            if (_.isEmpty(zeroConfUnspentTxIds)) {
                // we don't want to pass an empty array of inputs to the server, because it assumes if the
                // inputs arguments exists, it contains values
                zeroConfUnspentTxIds = undefined;
            }
            // For backwards compatibility, respect the old splitChangeSize=0 parameter
            if (!params.noSplitChange && params.splitChangeSize !== 0) {
                extraChangeAmounts = results.extraChangeAmounts || [];
            }
        });
    };
    // Get the unspents for the single key fee address
    let feeSingleKeyUnspents = [];
    const getUnspentsForSingleKey = function () {
        if (feeSingleKeySourceAddress) {
            let feeTarget = 0.01e8;
            if (params.instant) {
                feeTarget += totalAmount * 0.001;
            }
            return bitgo
                .get(bitgo.url('/address/' + feeSingleKeySourceAddress + '/unspents?target=' + feeTarget))
                .then(function (response) {
                if (response.body.total <= 0) {
                    throw new Error('No unspents available in single key fee source');
                }
                feeSingleKeyUnspents = response.body.unspents;
            });
        }
    };
    let minerFeeInfo = {};
    let txInfo = {};
    // Iterate unspents, sum the inputs, and save _inputs with the total
    // input amount and final list of inputs to use with the transaction.
    let feeSingleKeyUnspentsUsed = [];
    const collectInputs = function () {
        if (!unspents.length) {
            throw new Error('no unspents available on wallet');
        }
        inputAmount = 0;
        // Calculate the cost of spending a single input, i.e. the smallest economical unspent value
        return Bluebird.try(function () {
            if (_.isNumber(params.feeRate) || _.isNumber(params.originalFeeRate)) {
                return !_.isUndefined(params.feeRate) ? params.feeRate : params.originalFeeRate;
            }
            else {
                return bitgo
                    .estimateFee({
                    numBlocks: params.feeTxConfirmTarget,
                    maxFee: params.maxFeeRate,
                })
                    .then(function (feeRateEstimate) {
                    return feeRateEstimate.feePerKb;
                });
            }
        })
            .then(function (feeRate) {
            // Don't spend inputs that cannot pay for their own cost.
            let minInputValue = 0;
            if (_.isInteger(params.minUnspentSize)) {
                minInputValue = params.minUnspentSize;
            }
            let prunedUnspentCount = 0;
            const originalUnspentCount = unspents.length;
            unspents = _.filter(unspents, function (unspent) {
                const isSegwitInput = !!unspent.witnessScript;
                const currentInputSize = isSegwitInput ? unspents_1.VirtualSizes.txP2shP2wshInputSize : unspents_1.VirtualSizes.txP2shInputSize;
                const feeBasedMinInputValue = (feeRate * currentInputSize) / 1000;
                const currentMinInputValue = Math.max(minInputValue, feeBasedMinInputValue);
                if (currentMinInputValue > unspent.value) {
                    // pruning unspent
                    const pruneDetails = {
                        generalMinInputValue: minInputValue,
                        feeBasedMinInputValue,
                        currentMinInputValue,
                        feeRate,
                        inputSize: currentInputSize,
                        unspent: unspent,
                    };
                    console.log(`pruning unspent: ${JSON.stringify(pruneDetails, null, 4)}`);
                    prunedUnspentCount++;
                    return false;
                }
                return true;
            });
            if (prunedUnspentCount > 0) {
                console.log(`pruned ${prunedUnspentCount} out of ${originalUnspentCount} unspents`);
            }
            if (unspents.length === 0) {
                throw new Error('insufficient funds');
            }
            let segwitInputCount = 0;
            unspents.every(function (unspent) {
                if (unspent.witnessScript) {
                    segwitInputCount++;
                }
                inputAmount += unspent.value;
                transaction.addInput(unspent.tx_hash, unspent.tx_output_n, 0xffffffff);
                return inputAmount < (feeSingleKeySourceAddress ? totalOutputAmount : totalAmount);
            });
            // if paying fees from an external single key wallet, add the inputs
            if (feeSingleKeySourceAddress) {
                // collect the amount used in the fee inputs so we can get change later
                feeSingleKeyInputAmount = 0;
                feeSingleKeyUnspentsUsed = [];
                feeSingleKeyUnspents.every(function (unspent) {
                    feeSingleKeyInputAmount += unspent.value;
                    inputAmount += unspent.value;
                    transaction.addInput(unspent.tx_hash, unspent.tx_output_n);
                    feeSingleKeyUnspentsUsed.push(unspent);
                    // use the fee wallet to pay miner fees and potentially instant fees
                    return feeSingleKeyInputAmount < fee + (bitgoFeeInfo ? bitgoFeeInfo.amount : 0);
                });
            }
            txInfo = {
                nP2shInputs: transaction.tx.ins.length - (feeSingleKeySourceAddress ? 1 : 0) - segwitInputCount,
                nP2shP2wshInputs: segwitInputCount,
                nP2pkhInputs: feeSingleKeySourceAddress ? 1 : 0,
                // add single key source address change
                nOutputs: recipients.length +
                    1 + // recipients and change
                    extraChangeAmounts.length + // extra change splitting
                    (bitgoFeeInfo && bitgoFeeInfo.amount > 0 ? 1 : 0) + // add output for bitgo fee
                    (feeSingleKeySourceAddress ? 1 : 0),
            };
            // As per the response of get unspents API, for v1 safe wallets redeemScript is returned
            // in the response in hex format
            containsUncompressedPublicKeys = unspents.some((u) => u.redeemScript.length === 201 * 2 /* hex length is twice the length in bytes */);
            estTxSize = estimateTransactionSize({
                containsUncompressedPublicKeys,
                nP2shInputs: txInfo.nP2shInputs,
                nP2shP2wshInputs: txInfo.nP2shP2wshInputs,
                nP2pkhInputs: txInfo.nP2pkhInputs,
                nOutputs: txInfo.nOutputs,
            });
        })
            .then(getDynamicFeeRateEstimate)
            .then(function () {
            minerFeeInfo = exports.calculateMinerFeeInfo({
                bitgo: params.wallet.bitgo,
                containsUncompressedPublicKeys,
                feeRate: feeRate,
                nP2shInputs: txInfo.nP2shInputs,
                nP2shP2wshInputs: txInfo.nP2shP2wshInputs,
                nP2pkhInputs: txInfo.nP2pkhInputs,
                nOutputs: txInfo.nOutputs,
            });
            if (shouldComputeBestFee) {
                const approximateFee = minerFeeInfo.fee;
                const shouldRecurse = _.isUndefined(fee) || approximateFee > fee;
                fee = approximateFee;
                // Recompute totalAmount from scratch
                totalAmount = fee + totalOutputAmount;
                if (bitgoFeeInfo) {
                    totalAmount += bitgoFeeInfo.amount;
                }
                if (shouldRecurse) {
                    // if fee changed, re-collect inputs
                    inputAmount = 0;
                    transaction = utxolib.bitgo.createTransactionBuilderForNetwork(network);
                    return collectInputs();
                }
            }
            const totalFee = fee + (bitgoFeeInfo ? bitgoFeeInfo.amount : 0);
            if (feeSingleKeySourceAddress) {
                const summedSingleKeyUnspents = _.sumBy(feeSingleKeyUnspents, 'value');
                if (totalFee > summedSingleKeyUnspents) {
                    const err = new Error('Insufficient fee amount available in single key fee source: ' + summedSingleKeyUnspents);
                    err.result = {
                        fee: fee,
                        feeRate: feeRate,
                        estimatedSize: minerFeeInfo.size,
                        available: inputAmount,
                        bitgoFee: bitgoFeeInfo,
                        txInfo: txInfo,
                    };
                    return Bluebird.reject(err);
                }
            }
            if (inputAmount < (feeSingleKeySourceAddress ? totalOutputAmount : totalAmount)) {
                // The unspents we're using for inputs do not have sufficient value on them to
                // satisfy the user's requested spend amount. That may be because the wallet's balance
                // is simply too low, or it might be that the wallet's balance is sufficient but
                // we didn't fetch enough unspents. Too few unspents could result from the wallet
                // having many small unspents and we hit our limit on the number of inputs we can use
                // in a txn, or it might have been that the filters the user passed in (like minConfirms)
                // disqualified too many of the unspents
                let err;
                if (totalUnspentsCount === fetchedUnspentsCount) {
                    // we fetched every unspent the wallet had, but it still wasn't enough
                    err = new Error('Insufficient funds');
                }
                else {
                    // we weren't able to fetch all the unspents on the wallet
                    err = new Error(`Transaction size too large due to too many unspents. Can send only ${inputAmount} satoshis in this transaction`);
                }
                err.result = {
                    fee: fee,
                    feeRate: feeRate,
                    estimatedSize: minerFeeInfo.size,
                    available: inputAmount,
                    bitgoFee: bitgoFeeInfo,
                    txInfo: txInfo,
                };
                return Bluebird.reject(err);
            }
        });
    };
    // Add the outputs for this transaction.
    const collectOutputs = function () {
        if (minerFeeInfo.size >= 90000) {
            throw new Error('transaction too large: estimated size ' + minerFeeInfo.size + ' bytes');
        }
        const outputs = [];
        recipients.forEach(function (recipient) {
            let script;
            if (_.isString(recipient.address)) {
                script = utxolib.address.toOutputScript(recipient.address, network);
            }
            else if (_.isObject(recipient.script)) {
                script = recipient.script;
            }
            else {
                throw new Error('neither recipient address nor script was provided');
            }
            // validate travelInfo if it exists
            let travelInfo;
            if (!_.isEmpty(recipient.travelInfo)) {
                travelInfo = recipient.travelInfo;
                // Better to avoid trouble now, before tx is created
                bitgo.travelRule().validateTravelInfo(travelInfo);
            }
            outputs.push({
                script: script,
                amount: recipient.amount,
                travelInfo: travelInfo,
            });
        });
        opReturns.forEach(function ({ message, amount }) {
            const script = utxolib.script.fromASM('OP_RETURN ' + Buffer.from(message).toString('hex'));
            outputs.push({ script, amount });
        });
        const getChangeOutputs = function (changeAmount) {
            if (changeAmount < 0) {
                throw new Error('negative change amount: ' + changeAmount);
            }
            const result = [];
            // if we paid fees from a single key wallet, return the fee change first
            if (feeSingleKeySourceAddress) {
                const feeSingleKeyWalletChangeAmount = feeSingleKeyInputAmount - (fee + (bitgoFeeInfo ? bitgoFeeInfo.amount : 0));
                if (feeSingleKeyWalletChangeAmount >= constants.minOutputSize) {
                    result.push({ address: feeSingleKeySourceAddress, amount: feeSingleKeyWalletChangeAmount });
                    changeAmount = changeAmount - feeSingleKeyWalletChangeAmount;
                }
            }
            if (changeAmount < constants.minOutputSize) {
                // Give it to the miners
                return result;
            }
            if (params.wallet.type() === 'safe') {
                return params.wallet.addresses().then(function (response) {
                    result.push({ address: response.addresses[0].address, amount: changeAmount });
                    return result;
                });
            }
            let extraChangeTotal = _.sum(extraChangeAmounts);
            // Sanity check
            if (extraChangeTotal > changeAmount) {
                extraChangeAmounts = [];
                extraChangeTotal = 0;
            }
            // copy and add remaining change amount
            const allChangeAmounts = extraChangeAmounts.slice(0);
            allChangeAmounts.push(changeAmount - extraChangeTotal);
            // Recursive async func to add all change outputs
            const addChangeOutputs = function () {
                const thisAmount = allChangeAmounts.shift();
                if (!thisAmount) {
                    return result;
                }
                return Bluebird.try(function () {
                    if (params.changeAddress) {
                        // If user passed a change address, use it for all outputs
                        return params.changeAddress;
                    }
                    else {
                        // Otherwise create a new address per output, for privacy
                        // determine if segwit or not
                        const changeChain = params.wallet.getChangeChain(params);
                        return params.wallet.createAddress({ chain: changeChain, validate: validate }).then(function (result) {
                            return result.address;
                        });
                    }
                }).then(function (address) {
                    result.push({ address: address, amount: thisAmount });
                    return addChangeOutputs();
                });
            };
            return addChangeOutputs();
        };
        // Add change output(s) and instant fee output if applicable
        return Bluebird.try(function () {
            return getChangeOutputs(inputAmount - totalAmount);
        }).then(function (result) {
            changeOutputs = result;
            const extraOutputs = changeOutputs.concat([]); // copy the array
            if (bitgoFeeInfo && bitgoFeeInfo.amount > 0) {
                extraOutputs.push(bitgoFeeInfo);
            }
            extraOutputs.forEach(function (output) {
                if (output.address) {
                    output.script = utxolib.address.toOutputScript(output.address, network);
                }
                // decide where to put the outputs - default is to randomize unless forced to end
                const outputIndex = params.forceChangeAtEnd ? outputs.length : _.random(0, outputs.length);
                outputs.splice(outputIndex, 0, output);
            });
            // Add all outputs to the transaction
            outputs.forEach(function (output) {
                transaction.addOutput(output.script, output.amount);
            });
            travelInfos = _(outputs)
                .map(function (output, index) {
                const result = output.travelInfo;
                if (!result) {
                    return undefined;
                }
                result.outputIndex = index;
                return result;
            })
                .filter()
                .value();
        });
    };
    // Serialize the transaction, returning what is needed to sign it
    const serialize = function () {
        // only need to return the unspents that were used and just the chainPath, redeemScript, and instant flag
        const pickedUnspents = _.map(unspents, function (unspent) {
            return _.pick(unspent, ['chainPath', 'redeemScript', 'instant', 'witnessScript', 'script', 'value']);
        });
        const prunedUnspents = _.slice(pickedUnspents, 0, transaction.tx.ins.length - feeSingleKeyUnspentsUsed.length);
        _.each(feeSingleKeyUnspentsUsed, function (feeUnspent) {
            prunedUnspents.push({ redeemScript: false, chainPath: false }); // mark as false to signify a non-multisig address
        });
        const result = {
            transactionHex: transaction.buildIncomplete().toHex(),
            unspents: prunedUnspents,
            fee: fee,
            changeAddresses: changeOutputs.map(function (co) {
                return _.pick(co, ['address', 'path', 'amount']);
            }),
            walletId: params.wallet.id(),
            walletKeychains: params.wallet.keychains,
            feeRate: feeRate,
            instant: params.instant,
            bitgoFee: bitgoFeeInfo,
            estimatedSize: minerFeeInfo.size,
            txInfo: txInfo,
            travelInfos: travelInfos,
        };
        // Add for backwards compatibility
        if (result.instant && bitgoFeeInfo) {
            result.instantFee = _.pick(bitgoFeeInfo, ['amount', 'address']);
        }
        return result;
    };
    return Bluebird.try(function () {
        return getBitGoFee();
    })
        .then(function () {
        return Bluebird.all([getBitGoFeeAddress(), getUnspents(), getUnspentsForSingleKey()]);
    })
        .then(collectInputs)
        .then(collectOutputs)
        .then(serialize);
};
/**
 * Estimate the size of a transaction in bytes based on the number of
 * inputs and outputs present.
 * @params params {
 *   nP2shInputs: number of P2SH (multisig) inputs
 *   nP2pkhInputs: number of P2PKH (single sig) inputs
 *   nOutputs: number of outputs
 * }
 *
 * @returns size: estimated size of the transaction in bytes
 */
const estimateTransactionSize = function (params) {
    if (!_.isInteger(params.nP2shInputs) || params.nP2shInputs < 0) {
        throw new Error('expecting positive nP2shInputs');
    }
    if (!_.isInteger(params.nP2pkhInputs) || params.nP2pkhInputs < 0) {
        throw new Error('expecting positive nP2pkhInputs to be numeric');
    }
    if (!_.isInteger(params.nP2shP2wshInputs) || params.nP2shP2wshInputs < 0) {
        throw new Error('expecting positive nP2shP2wshInputs to be numeric');
    }
    if (params.nP2shInputs + params.nP2shP2wshInputs < 1) {
        throw new Error('expecting at least one nP2shInputs or nP2shP2wshInputs');
    }
    if (!_.isInteger(params.nOutputs) || params.nOutputs < 1) {
        throw new Error('expecting positive nOutputs');
    }
    // The size of an uncompressed public key is 32 bytes more than the compressed key,
    // and hence, needs to be accounted for in the transaction size estimation.
    const uncompressedPublicKeysTripleCorrectionFactor = 32 * 3;
    return (
    // This is not quite accurate - if there is a mix of inputs scripts where some used
    // compressed keys and some used uncompressed keys, we would overestimate the size.
    // Since we don't have mixed input sets, this should not be an issue in practice.
    (unspents_1.VirtualSizes.txP2shInputSize +
        (params.containsUncompressedPublicKeys ? uncompressedPublicKeysTripleCorrectionFactor : 0)) *
        params.nP2shInputs +
        unspents_1.VirtualSizes.txP2shP2wshInputSize * (params.nP2shP2wshInputs || 0) +
        unspents_1.VirtualSizes.txP2pkhInputSizeUncompressedKey * (params.nP2pkhInputs || 0) +
        unspents_1.VirtualSizes.txP2pkhOutputSize * params.nOutputs +
        // if the tx contains at least one segwit input, the tx overhead is increased by 1
        unspents_1.VirtualSizes.txOverheadSize +
        (params.nP2shP2wshInputs > 0 ? 1 : 0));
};
/**
 * Calculate the fee and estimated size in bytes for a transaction.
 * @params params {
 *   bitgo: bitgo object
 *   feeRate: satoshis per kilobyte
 *   nP2shInputs: number of P2SH (multisig) inputs
 *   nP2pkhInputs: number of P2PKH (single sig) inputs
 *   nOutputs: number of outputs
 * }
 *
 * @returns {
 *   size: estimated size of the transaction in bytes
 *   fee: estimated fee in satoshis for the transaction
 *   feeRate: fee rate that was used to estimate the fee for the transaction
 * }
 */
exports.calculateMinerFeeInfo = function (params) {
    const feeRateToUse = params.feeRate || params.bitgo.getConstants().fallbackFeeRate;
    const estimatedSize = estimateTransactionSize(params);
    return {
        size: estimatedSize,
        fee: Math.ceil((estimatedSize * feeRateToUse) / 1000),
        feeRate: feeRateToUse,
    };
};
/*
 * Given a transaction hex, unspent information (chain path and redeem scripts), and the keychain xprv,
 * perform key derivation and sign the inputs in the transaction based on the unspent information provided
 *
 * @params:
 *  transactionHex serialized form of the transaction in hex
 *  unspents array of unspent information, where each unspent is a chainPath and redeemScript with the same
 *  index as the inputs in the transactionHex
 *  keychain Keychain containing the xprv to sign with. For legacy support of safe wallets, keychain can
 also be a WIF private key.
 *  signingKey private key in WIF for safe wallets, when keychain is unavailable
 *  validate client-side signature verification - can be disabled for improved performance (signatures
 *           are still validated server-side).
 *  feeSingleKeyWIF Use the address based on this private key to pay fees
 * @returns {*}
 */
exports.signTransaction = function (params) {
    let keychain = params.keychain; // duplicate so as to not mutate below
    const validate = params.validate === undefined ? true : params.validate;
    let privKey;
    if (!_.isString(params.transactionHex)) {
        throw new Error('expecting the transaction hex as a string');
    }
    if (!Array.isArray(params.unspents)) {
        throw new Error('expecting the unspents array');
    }
    if (!_.isBoolean(validate)) {
        throw new Error('expecting validate to be a boolean');
    }
    let network = (0, sdk_core_1.getNetwork)();
    const enableBCH = _.isBoolean(params.forceBCH) && params.forceBCH === true;
    if (!_.isObject(keychain) || !_.isString(keychain.xprv)) {
        if (_.isString(params.signingKey)) {
            privKey = utxolib.ECPair.fromWIF(params.signingKey, network);
            keychain = undefined;
        }
        else {
            throw new Error('expecting the keychain object with xprv');
        }
    }
    let feeSingleKey;
    if (params.feeSingleKeyWIF) {
        feeSingleKey = utxolib.ECPair.fromWIF(params.feeSingleKeyWIF, network);
    }
    debug('Network: %O', network);
    if (enableBCH) {
        debug('Enabling BCHâ€¦');
        network = utxolib.networks.bitcoincash;
        debug('New network: %O', network);
    }
    const transaction = utxolib.bitgo.createTransactionFromHex(params.transactionHex, network);
    if (transaction.ins.length !== params.unspents.length) {
        throw new Error('length of unspents array should equal to the number of transaction inputs');
    }
    // decorate transaction with input values for TransactionBuilder instantiation
    const isUtxoTx = _.isObject(transaction) && Array.isArray(transaction.ins);
    const areValidUnspents = _.isObject(params) && Array.isArray(params.unspents);
    if (isUtxoTx && areValidUnspents) {
        // extend the transaction inputs with the values
        const inputValues = _.map(params.unspents, (u) => _.pick(u, 'value'));
        transaction.ins.map((currentItem, index) => _.extend(currentItem, inputValues[index]));
    }
    let rootExtKey;
    if (keychain) {
        rootExtKey = utxo_lib_1.bip32.fromBase58(keychain.xprv);
    }
    const txb = utxolib.bitgo.createTransactionBuilderFromTransaction(transaction);
    for (let index = 0; index < txb.tx.ins.length; ++index) {
        const currentUnspent = params.unspents[index];
        if (currentUnspent.redeemScript === false) {
            // this is the input from a single key fee address
            if (!feeSingleKey) {
                throw new Error('single key address used in input but feeSingleKeyWIF not provided');
            }
            if (enableBCH) {
                feeSingleKey.network = network;
            }
            txb.sign(index, feeSingleKey);
            continue;
        }
        if (currentUnspent.witnessScript && enableBCH) {
            throw new Error('BCH does not support segwit inputs');
        }
        const chainPath = currentUnspent.chainPath;
        if (rootExtKey) {
            const { walletSubPath = '/0/0' } = keychain;
            const path = (0, sdk_core_1.sanitizeLegacyPath)(keychain.path + walletSubPath + chainPath);
            debug('derived user key path "%s" using keychain path "%s", walletSubPath "%s", keychain walletSubPath "%s" and chainPath "%s"', path, keychain.path, walletSubPath, keychain.walletSubPath, chainPath);
            privKey = rootExtKey.derivePath(path);
        }
        privKey.network = network;
        // subscript is the part of the output script after the OP_CODESEPARATOR.
        // Since we are only ever signing p2sh outputs, which do not have
        // OP_CODESEPARATORS, it is always the output script.
        const subscript = Buffer.from(currentUnspent.redeemScript, 'hex');
        currentUnspent.validationScript = subscript;
        // In order to sign with bitcoinjs-lib, we must use its transaction
        // builder, confusingly named the same exact thing as our transaction
        // builder, but with inequivalent behavior.
        try {
            const witnessScript = currentUnspent.witnessScript ? Buffer.from(currentUnspent.witnessScript, 'hex') : undefined;
            const sigHash = utxolib.bitgo.getDefaultSigHash(network);
            txb.sign(index, privKey, subscript, sigHash, currentUnspent.value, witnessScript);
        }
        catch (e) {
            // try fallback derivation path (see BG-46497)
            let fallbackSigningSuccessful = false;
            try {
                const fallbackPath = (0, sdk_core_1.sanitizeLegacyPath)(keychain.path + chainPath);
                debug('derived fallback user key path "%s" using keychain path "%s" and chainPath "%s"', fallbackPath, keychain.path, chainPath);
                privKey = rootExtKey.derivePath(fallbackPath);
                const witnessScript = currentUnspent.witnessScript
                    ? Buffer.from(currentUnspent.witnessScript, 'hex')
                    : undefined;
                const sigHash = utxolib.bitgo.getDefaultSigHash(network);
                txb.sign(index, privKey, subscript, sigHash, currentUnspent.value, witnessScript);
                fallbackSigningSuccessful = true;
            }
            catch (fallbackError) {
                debug('input sign failed for fallback path: %s', fallbackError.message);
            }
            // we need to know what's causing this
            if (!fallbackSigningSuccessful) {
                e.result = {
                    unspent: currentUnspent,
                };
                e.message = `Failed to sign input #${index} - ${e.message} - ${JSON.stringify(e.result, null, 4)} - \n${e.stack}`;
                debug('input sign failed: %s', e.message);
                return Bluebird.reject(e);
            }
        }
    }
    const partialTransaction = txb.buildIncomplete();
    if (validate) {
        partialTransaction.ins.forEach((input, index) => {
            const signatureCount = utxolib.bitgo
                .getSignatureVerifications(partialTransaction, index, params.unspents[index].value)
                .filter((v) => v.signedBy !== undefined).length;
            if (signatureCount < 1) {
                throw new Error('expected at least one valid signature');
            }
            if (params.fullLocalSigning && signatureCount < 2) {
                throw new Error('fullLocalSigning set: expected at least two valid signatures');
            }
        });
    }
    return Bluebird.resolve({
        transactionHex: partialTransaction.toHex(),
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3YxL3RyYW5zYWN0aW9uQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7O0FBRUg7R0FDRztBQUNILEVBQUU7QUFDRixxQkFBcUI7QUFDckIsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvREFBb0Q7QUFDcEQsRUFBRTtBQUVGLDhDQUF3QztBQUN4QyxxQ0FBcUM7QUFDckMsMkNBQTJDO0FBQzNDLDRCQUE0QjtBQUM1Qiw4Q0FBK0M7QUFDL0Msa0NBQW1DO0FBQ25DLE1BQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN2Qyw4Q0FBMEY7QUFDMUYsbURBQWdEO0FBdUJoRCxFQUFFO0FBQ0YscUJBQXFCO0FBQ3JCLFdBQVc7QUFDWCwwQ0FBMEM7QUFDMUMsOE1BQThNO0FBQzlNLHNHQUFzRztBQUN0RyxrSUFBa0k7QUFDbEksNkhBQTZIO0FBQzdILHVHQUF1RztBQUN2RywrRUFBK0U7QUFDL0UscUVBQXFFO0FBQ3JFLDZFQUE2RTtBQUM3RSx3R0FBd0c7QUFDeEcsaUlBQWlJO0FBQ2pJLHdJQUF3STtBQUN4SSw0SUFBNEk7QUFDNUksdUVBQXVFO0FBQ3ZFLDJFQUEyRTtBQUMzRSw0RkFBNEY7QUFDNUYsa0hBQWtIO0FBQ2xILE9BQU8sQ0FBQyxpQkFBaUIsR0FBRyxVQUFVLE1BQU07SUFDMUMsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLFdBQVcsSUFBSSxDQUFDLENBQUM7SUFDNUMsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztJQUN4RSxJQUFJLFVBQVUsR0FBNkUsRUFBRSxDQUFDO0lBQzlGLElBQUksU0FBUyxHQUEwQyxFQUFFLENBQUM7SUFDMUQsSUFBSSxrQkFB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QUMsdUNBQXVDLENBQUMsQ0FBQzthQUMxRDtZQUNELElBQUksTUFBTSxDQUFDLGdCQUFnQixJQUFJLGNBQWMsR0FBRyxDQUFDLEVBQUU7Z0JBQ2pELE1BQU0sSUFBSSxLQUFLLENBQUMsOERBQThELENBQUMsQ0FBQzthQUNqRjtRQUNILENBQUMsQ0FBQyxDQUFDO0tBQ0o7SUFFRCxPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUM7UUFDdEIsY0FBYyxFQUFFLGtCQUFrQixDQUFDLEtBQUssRUFBRTtLQUMzQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBoaWRkZW5cbiAqL1xuXG4vKipcbiAqL1xuLy9cbi8vIFRyYW5zYWN0aW9uQnVpbGRlclxuLy8gQSB1dGlsaXR5IGZvciBidWlsZGluZyBhbmQgc2lnbmluZyB0cmFuc2FjdGlvbnNcbi8vXG4vLyBDb3B5cmlnaHQgMjAxNCwgQml0R28sIEluYy4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuXG5pbXBvcnQgeyBiaXAzMiB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgKiBhcyB1dHhvbGliIGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBWaXJ0dWFsU2l6ZXMgfSBmcm9tICdAYml0Z28vdW5zcGVudHMnO1xuaW1wb3J0IGRlYnVnTGliID0gcmVxdWlyZSgnZGVidWcnKTtcbmNvbnN0IGRlYnVnID0gZGVidWdMaWIoJ2JpdGdvOnYxOnR4YicpO1xuaW1wb3J0IHsgY29tbW9uLCBnZXRBZGRyZXNzUDJQS0gsIGdldE5ldHdvcmssIHNhbml0aXplTGVnYWN5UGF0aCB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyB2ZXJpZnlBZGRyZXNzIH0gZnJvbSAnLi92ZXJpZnlBZGRyZXNzJztcblxuaW50ZXJmYWNlIEJhc2VPdXRwdXQge1xuICBhbW91bnQ6IG51bWJlcjtcbiAgdHJhdmVsSW5mbz86IGFueTtcbn1cblxuaW50ZXJmYWNlIEFkZHJlc3NPdXRwdXQgZXh0ZW5kcyBCYXNlT3V0cHV0IHtcbiAgYWRkcmVzczogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgU2NyaXB0T3V0cHV0IGV4dGVuZHMgQmFzZU91dHB1dCB7XG4gIHNjcmlwdDogQnVmZmVyO1xufVxuXG50eXBlIE91dHB1dCA9IEFkZHJlc3NPdXRwdXQgfCBTY3JpcHRPdXRwdXQ7XG5cbmludGVyZmFjZSBCaXRHb1Vuc3BlbnQge1xuICB2YWx1ZTogbnVtYmVyO1xuICB0eF9oYXNoOiBCdWZmZXI7XG4gIHR4X291dHB1dF9uOiBudW1iZXI7XG59XG5cbi8vXG4vLyBUcmFuc2FjdGlvbkJ1aWxkZXJcbi8vIEBwYXJhbXM6XG4vLyAgIHdhbGxldDogIGEgd2FsbGV0IG9iamVjdCB0byBzZW5kIGZyb21cbi8vICAgcmVjaXBpZW50czogYXJyYXkgb2YgcmVjaXBpZW50IG9iamVjdHMgYW5kIHRoZSBhbW91bnQgdG8gc2VuZCB0byBlYWNoIGUuZy4gW3thZGRyZXNzOiAnMzhCS0ROWmJQY0xvZ3ZWYmN4MmVrSjlFNlZ2OTREcURxdycsIGFtb3VudDogMTUwMH0sIHthZGRyZXNzOiAnMzZlTDh5UXFDbjFITVJtVkZGbzQ5dDJQSjNwYWk4d1FhbScsIGFtb3VudDogMjAwMH1dXG4vLyAgIGZlZTogdGhlIGZlZSB0byB1c2Ugd2l0aCB0aGlzIHRyYW5zYWN0aW9uLiAgaWYgbm90IHByb3ZpZGVkLCBhIGRlZmF1bHQsIG1pbmltdW0gZmVlIHdpbGwgYmUgdXNlZC5cbi8vICAgZmVlUmF0ZTogdGhlIGFtb3VudCBvZiBmZWUgcGVyIGtpbG9ieXRlIC0gb3B0aW9uYWwgLSBzcGVjaWZ5IGVpdGhlciBmZWUsIGZlZVJhdGUsIG9yIGZlZVR4Q29uZmlybVRhcmdldCBidXQgbm90IG1vcmUgdGhhbiBvbmVcbi8vICAgZmVlVHhDb25maXJtVGFyZ2V0OiBjYWxjdWxhdGUgdGhlIGZlZXMgcGVyIGtpbG9ieXRlIHN1Y2ggdGhhdCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBiZSBjb25maXJtZWQgaW4gdGhpcyBudW1iZXIgb2YgYmxvY2tzXG4vLyAgIG1heEZlZVJhdGU6IFRoZSBtYXhpbXVtIGZlZSBwZXIga2IgdG8gdXNlIGluIHNhdG9zaGlzLCBmb3Igc2FmZXR5IHB1cnBvc2VzIHdoZW4gdXNpbmcgZHluYW1pYyBmZWVzXG4vLyAgIG1pbkNvbmZpcm1zOiB0aGUgbWluaW11bSBjb25maXJtYXRpb25zIGFuIG91dHB1dCBtdXN0IGhhdmUgYmVmb3JlIHNwZW5kaW5nXG4vLyAgIGZvcmNlQ2hhbmdlQXRFbmQ6IGZvcmNlIHRoZSBjaGFuZ2UgYWRkcmVzcyB0byBiZSB0aGUgbGFzdCBvdXRwdXRcbi8vICAgY2hhbmdlQWRkcmVzczogc3BlY2lmeSB0aGUgY2hhbmdlIGFkZHJlc3MgcmF0aGVyIHRoYW4gZ2VuZXJhdGUgYSBuZXcgb25lXG4vLyAgIG5vU3BsaXRDaGFuZ2U6IHNldCB0byB0cnVlIHRvIGRpc2FibGUgYXV0b21hdGljIGNoYW5nZSBzcGxpdHRpbmcgZm9yIHB1cnBvc2VzIG9mIHVuc3BlbnQgbWFuYWdlbWVudFxuLy8gICB0YXJnZXRXYWxsZXRVbnNwZW50czogc3BlY2lmeSBhIG51bWJlciBvZiB0YXJnZXQgdW5zcGVudHMgdG8gbWFpbnRhaW4gaW4gdGhlIHdhbGxldCAoY3VycmVudGx5IGRlZmF1bHRlZCB0byA4IGJ5IHRoZSBzZXJ2ZXIpXG4vLyAgIHZhbGlkYXRlOiBleHRyYSB2ZXJpZmljYXRpb24gb2YgdGhlIGNoYW5nZSBhZGRyZXNzZXMsIHdoaWNoIGlzIGFsd2F5cyBkb25lIHNlcnZlci1zaWRlIGFuZCBpcyByZWR1bmRhbnQgY2xpZW50LXNpZGUgKGRlZmF1bHRzIHRydWUpXG4vLyAgIG1pblVuc3BlbnRTaXplOiBUaGUgbWluaW11bSBzaXplIGluIHNhdG9zaGlzIG9mIHVuc3BlbnQgdG8gdXNlICh0byBwcmV2ZW50IHNwZW5kaW5nIHVuc3BlbnRzIHdvcnRoIGxlc3MgdGhhbiBmZWUgYWRkZWQpLiBEZWZhdWx0cyB0byAwLlxuLy8gICBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzOiBVc2UgdGhpcyBzaW5nbGUga2V5IGFkZHJlc3MgdG8gcGF5IGZlZXNcbi8vICAgZmVlU2luZ2xlS2V5V0lGOiBVc2UgdGhlIGFkZHJlc3MgYmFzZWQgb24gdGhpcyBwcml2YXRlIGtleSB0byBwYXkgZmVlc1xuLy8gICB1bnNwZW50c0ZldGNoUGFyYW1zOiBFeHRyYSBwYXJhbWV0ZXJzIHRvIHVzZSBmb3IgZmV0Y2hpbmcgdW5zcGVudHMgZm9yIHRoaXMgdHJhbnNhY3Rpb25cbi8vICAgdW5zcGVudHM6IGFycmF5IG9mIHVuc3BlbnQgb2JqZWN0cyB0byB1c2Ugd2hpbGUgY29uc3RydWN0aW5nIHRoZSB0cmFuc2FjdGlvbiBpbnN0ZWFkIG9mIGZldGNoaW5nIGZyb20gdGhlIEFQSVxuZXhwb3J0cy5jcmVhdGVUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgY29uc3QgbWluQ29uZmlybXMgPSBwYXJhbXMubWluQ29uZmlybXMgfHwgMDtcbiAgY29uc3QgdmFsaWRhdGUgPSBwYXJhbXMudmFsaWRhdGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwYXJhbXMudmFsaWRhdGU7XG4gIGxldCByZWNpcGllbnRzOiB7IGFkZHJlc3M6IHN0cmluZzsgYW1vdW50OiBudW1iZXI7IHNjcmlwdD86IHN0cmluZzsgdHJhdmVsSW5mbz86IGFueSB9W10gPSBbXTtcbiAgbGV0IG9wUmV0dXJuczogeyBtZXNzYWdlOiBzdHJpbmc7IGFtb3VudDogbnVtYmVyIH1bXSA9IFtdO1xuICBsZXQgZXh0cmFDaGFuZ2VBbW91bnRzOiBudW1iZXJbXSA9IFtdO1xuICBsZXQgZXN0VHhTaXplOiBudW1iZXI7XG4gIGxldCB0cmF2ZWxJbmZvcztcblxuICAvLyBTYW5pdHkgY2hlY2sgdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW5cbiAgaWYgKFxuICAgICFfLmlzT2JqZWN0KHBhcmFtcy53YWxsZXQpIHx8XG4gICAgKHBhcmFtcy5mZWUgJiYgIV8uaXNOdW1iZXIocGFyYW1zLmZlZSkpIHx8XG4gICAgKHBhcmFtcy5mZWVSYXRlICYmICFfLmlzTnVtYmVyKHBhcmFtcy5mZWVSYXRlKSkgfHxcbiAgICAhXy5pc0ludGVnZXIobWluQ29uZmlybXMpIHx8XG4gICAgKHBhcmFtcy5mb3JjZUNoYW5nZUF0RW5kICYmICFfLmlzQm9vbGVhbihwYXJhbXMuZm9yY2VDaGFuZ2VBdEVuZCkpIHx8XG4gICAgKHBhcmFtcy5jaGFuZ2VBZGRyZXNzICYmICFfLmlzU3RyaW5nKHBhcmFtcy5jaGFuZ2VBZGRyZXNzKSkgfHxcbiAgICAocGFyYW1zLm5vU3BsaXRDaGFuZ2UgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5ub1NwbGl0Q2hhbmdlKSkgfHxcbiAgICAocGFyYW1zLnRhcmdldFdhbGxldFVuc3BlbnRzICYmICFfLmlzSW50ZWdlcihwYXJhbXMudGFyZ2V0V2FsbGV0VW5zcGVudHMpKSB8fFxuICAgICh2YWxpZGF0ZSAmJiAhXy5pc0Jvb2xlYW4odmFsaWRhdGUpKSB8fFxuICAgIChwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlICYmICFfLmlzQm9vbGVhbihwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlKSkgfHxcbiAgICAocGFyYW1zLm1pblVuc3BlbnRTaXplICYmICFfLmlzTnVtYmVyKHBhcmFtcy5taW5VbnNwZW50U2l6ZSkpIHx8XG4gICAgKHBhcmFtcy5tYXhGZWVSYXRlICYmICFfLmlzTnVtYmVyKHBhcmFtcy5tYXhGZWVSYXRlKSkgfHxcbiAgICAvLyB0aGlzIHNob3VsZCBiZSBhbiBhcnJheSBhbmQgaXRzIGxlbmd0aCBtdXN0IGJlIGF0IGxlYXN0IDFcbiAgICAocGFyYW1zLnVuc3BlbnRzICYmICghQXJyYXkuaXNBcnJheShwYXJhbXMudW5zcGVudHMpIHx8IHBhcmFtcy51bnNwZW50cy5sZW5ndGggPCAxKSkgfHxcbiAgICAocGFyYW1zLmZlZVR4Q29uZmlybVRhcmdldCAmJiAhXy5pc0ludGVnZXIocGFyYW1zLmZlZVR4Q29uZmlybVRhcmdldCkpIHx8XG4gICAgKHBhcmFtcy5pbnN0YW50ICYmICFfLmlzQm9vbGVhbihwYXJhbXMuaW5zdGFudCkpIHx8XG4gICAgKHBhcmFtcy5iaXRnb0ZlZSAmJiAhXy5pc09iamVjdChwYXJhbXMuYml0Z29GZWUpKSB8fFxuICAgIChwYXJhbXMudW5zcGVudHNGZXRjaFBhcmFtcyAmJiAhXy5pc09iamVjdChwYXJhbXMudW5zcGVudHNGZXRjaFBhcmFtcykpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgY29uc3QgYml0Z28gPSBwYXJhbXMud2FsbGV0LmJpdGdvO1xuICBjb25zdCBjb25zdGFudHMgPSBiaXRnby5nZXRDb25zdGFudHMoKTtcbiAgY29uc3QgbmV0d29yayA9IGdldE5ldHdvcmsoY29tbW9uLkVudmlyb25tZW50c1tiaXRnby5nZXRFbnYoKV0ubmV0d29yayk7XG5cbiAgLy8gVGhlIHVzZXIgY2FuIHNwZWNpZnkgYSBzZXBlcmF0ZSwgc2luZ2xlLWtleSB3YWxsZXQgZm9yIHRoZSBwdXJwb3NlcyBvZiBwYXlpbmcgbWluZXIncyBmZWVzXG4gIC8vIFdoZW4gY3JlYXRpbmcgYSB0cmFuc2FjdGlvbiB0aGlzIGNhbiBiZSBzcGVjaWZpZWQgYXMgYW4gaW5wdXQgYWRkcmVzcyBvciB0aGUgcHJpdmF0ZSBrZXkgaW4gV0lGXG4gIGxldCBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzO1xuICBsZXQgZmVlU2luZ2xlS2V5SW5wdXRBbW91bnQgPSAwO1xuICBpZiAocGFyYW1zLmZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgdXR4b2xpYi5hZGRyZXNzLmZyb21CYXNlNThDaGVjayhwYXJhbXMuZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcywgbmV0d29yayk7XG4gICAgICBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzID0gcGFyYW1zLmZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3M7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJpdGNvaW4gYWRkcmVzczogJyArIHBhcmFtcy5mZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzKTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFyYW1zLmZlZVNpbmdsZUtleVdJRikge1xuICAgIGNvbnN0IGZlZVNpbmdsZUtleSA9IHV0eG9saWIuRUNQYWlyLmZyb21XSUYocGFyYW1zLmZlZVNpbmdsZUtleVdJRiwgbmV0d29yayBhcyB1dHhvbGliLkJpdGNvaW5KU05ldHdvcmspO1xuICAgIGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgPSBnZXRBZGRyZXNzUDJQS0goZmVlU2luZ2xlS2V5KTtcbiAgICAvLyBJZiB0aGUgdXNlciBzcGVjaWZpZXMgYm90aCwgY2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzIGNvcnJlc3BvbmRzIHRvIHRoZSBhZGRyZXNzIG9mIGZlZVNpbmdsZUtleVdJRlxuICAgIGlmIChwYXJhbXMuZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyAmJiBwYXJhbXMuZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyAhPT0gZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzczogJyArXG4gICAgICAgICAgcGFyYW1zLmZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgK1xuICAgICAgICAgICcgZGlkIG5vdCBjb3JyZXNwb25kIHRvIGFkZHJlc3Mgb2YgZmVlU2luZ2xlS2V5V0lGOiAnICtcbiAgICAgICAgICBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmICghXy5pc09iamVjdChwYXJhbXMucmVjaXBpZW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY2lwaWVudHMgbXVzdCBiZSBhcnJheSBvZiB7IGFkZHJlc3M6IGFiYywgYW1vdW50OiAxMDAwMDAgfSBvYmplY3RzJyk7XG4gIH1cblxuICBsZXQgZmVlUGFyYW1zRGVmaW5lZCA9IDA7XG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZmVlKSkge1xuICAgIGZlZVBhcmFtc0RlZmluZWQrKztcbiAgfVxuXG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZmVlUmF0ZSkpIHtcbiAgICBmZWVQYXJhbXNEZWZpbmVkKys7XG4gIH1cblxuICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmZlZVR4Q29uZmlybVRhcmdldCkpIHtcbiAgICBmZWVQYXJhbXNEZWZpbmVkKys7XG4gIH1cblxuICBpZiAoZmVlUGFyYW1zRGVmaW5lZCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzcGVjaWZ5IG1vcmUgdGhhbiBvbmUgb2YgZmVlLCBmZWVSYXRlIGFuZCBmZWVUeENvbmZpcm1UYXJnZXQnKTtcbiAgfVxuXG4gIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5tYXhGZWVSYXRlKSkge1xuICAgIHBhcmFtcy5tYXhGZWVSYXRlID0gY29uc3RhbnRzLm1heEZlZVJhdGU7XG4gIH1cblxuICAvLyBDb252ZXJ0IHRoZSBvbGQgZm9ybWF0IG9mIHBhcmFtcy5yZWNpcGllbnRzIChkaWN0aW9uYXJ5IG9mIGFkZHJlc3M6YW1vdW50KSB0byBuZXcgZm9ybWF0OiB7IGRlc3RpbmF0aW9uQWRkcmVzcywgYW1vdW50IH1cbiAgaWYgKCEocGFyYW1zLnJlY2lwaWVudHMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICByZWNpcGllbnRzID0gW107XG4gICAgT2JqZWN0LmtleXMocGFyYW1zLnJlY2lwaWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGRlc3RpbmF0aW9uQWRkcmVzcykge1xuICAgICAgY29uc3QgYW1vdW50ID0gcGFyYW1zLnJlY2lwaWVudHNbZGVzdGluYXRpb25BZGRyZXNzXTtcbiAgICAgIHJlY2lwaWVudHMucHVzaCh7IGFkZHJlc3M6IGRlc3RpbmF0aW9uQWRkcmVzcywgYW1vdW50OiBhbW91bnQgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVjaXBpZW50cyA9IHBhcmFtcy5yZWNpcGllbnRzO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5vcFJldHVybnMpIHtcbiAgICBpZiAoIShwYXJhbXMub3BSZXR1cm5zIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICBvcFJldHVybnMgPSBbXTtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcy5vcFJldHVybnMpLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gcGFyYW1zLm9wUmV0dXJuc1ttZXNzYWdlXTtcbiAgICAgICAgb3BSZXR1cm5zLnB1c2goeyBtZXNzYWdlLCBhbW91bnQgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BSZXR1cm5zID0gcGFyYW1zLm9wUmV0dXJucztcbiAgICB9XG4gIH1cblxuICBpZiAocmVjaXBpZW50cy5sZW5ndGggPT09IDAgJiYgb3BSZXR1cm5zLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSByZWNpcGllbnQnKTtcbiAgfVxuXG4gIGxldCBmZWUgPSBwYXJhbXMuZmVlO1xuICBsZXQgZmVlUmF0ZSA9IHBhcmFtcy5mZWVSYXRlO1xuXG4gIC8vIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgY2xhc3Mgd2lsbCBjb21wdXRlIHRoZSBmZWVcbiAgY29uc3Qgc2hvdWxkQ29tcHV0ZUJlc3RGZWUgPSBfLmlzVW5kZWZpbmVkKGZlZSk7XG5cbiAgbGV0IHRvdGFsT3V0cHV0QW1vdW50ID0gMDtcblxuICByZWNpcGllbnRzLmZvckVhY2goZnVuY3Rpb24gKHJlY2lwaWVudCkge1xuICAgIGlmIChfLmlzU3RyaW5nKHJlY2lwaWVudC5hZGRyZXNzKSkge1xuICAgICAgaWYgKCF2ZXJpZnlBZGRyZXNzKHJlY2lwaWVudC5hZGRyZXNzLCBuZXR3b3JrKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYml0Y29pbiBhZGRyZXNzOiAnICsgcmVjaXBpZW50LmFkZHJlc3MpO1xuICAgICAgfVxuICAgICAgaWYgKCEhcmVjaXBpZW50LnNjcmlwdCkge1xuICAgICAgICAvLyBBIHNjcmlwdCB3YXMgcHJvdmlkZWQgYXMgd2VsbCAtIHZhbGlkYXRlIHRoYXQgdGhlIGFkZHJlc3MgY29ycmVzcG9uZHMgdG8gdGhhdFxuICAgICAgICBpZiAodXR4b2xpYi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KHJlY2lwaWVudC5hZGRyZXNzLCBuZXR3b3JrKS50b1N0cmluZygnaGV4JykgIT09IHJlY2lwaWVudC5zY3JpcHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnYm90aCBzY3JpcHQgYW5kIGFkZHJlc3MgcHJvdmlkZWQgYnV0IHRoZXkgZGlkIG5vdCBtYXRjaDogJyArIHJlY2lwaWVudC5hZGRyZXNzICsgJyAnICsgcmVjaXBpZW50LnNjcmlwdFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFfLmlzSW50ZWdlcihyZWNpcGllbnQuYW1vdW50KSB8fCByZWNpcGllbnQuYW1vdW50IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFtb3VudCBmb3IgJyArIHJlY2lwaWVudC5hZGRyZXNzICsgJzogJyArIHJlY2lwaWVudC5hbW91bnQpO1xuICAgIH1cbiAgICB0b3RhbE91dHB1dEFtb3VudCArPSByZWNpcGllbnQuYW1vdW50O1xuICB9KTtcblxuICBvcFJldHVybnMuZm9yRWFjaChmdW5jdGlvbiAob3BSZXR1cm4pIHtcbiAgICB0b3RhbE91dHB1dEFtb3VudCArPSBvcFJldHVybi5hbW91bnQ7XG4gIH0pO1xuXG4gIGxldCBiaXRnb0ZlZUluZm8gPSBwYXJhbXMuYml0Z29GZWU7XG4gIGlmIChiaXRnb0ZlZUluZm8gJiYgKCFfLmlzSW50ZWdlcihiaXRnb0ZlZUluZm8uYW1vdW50KSB8fCAhXy5pc1N0cmluZyhiaXRnb0ZlZUluZm8uYWRkcmVzcykpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJpdGdvRmVlSW5mbycpO1xuICB9XG5cbiAgLy8gVGhlIHRvdGFsIGFtb3VudCBuZWVkZWQgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gIGxldCB0b3RhbEFtb3VudCA9IHRvdGFsT3V0cHV0QW1vdW50ICsgKGZlZSB8fCAwKTtcblxuICAvLyBUaGUgbGlzdCBvZiB1bnNwZW50IHRyYW5zYWN0aW9ucyBiZWluZyB1c2VkIGluIHRoaXMgdHJhbnNhY3Rpb24uXG4gIGxldCB1bnNwZW50cztcblxuICAvLyB0aGUgdG90YWwgbnVtYmVyIG9mIHVuc3BlbnRzIG9uIHRoaXMgd2FsbGV0XG4gIGxldCB0b3RhbFVuc3BlbnRzQ291bnQ7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB1bnNwZW50cyB3ZSBmZXRjaGVkIGZyb20gdGhlIHNlcnZlciwgYmVmb3JlIGZpbHRlcmluZ1xuICBsZXQgZmV0Y2hlZFVuc3BlbnRzQ291bnQ7XG5cbiAgLy8gVGhlIGxpc3Qgb2YgdW5zcGVudCB0cmFuc2FjdGlvbnMgYmVpbmcgdXNlZCB3aXRoIHplcm8tY29uZmlybWF0aW9uc1xuICBsZXQgemVyb0NvbmZVbnNwZW50VHhJZHM7XG5cbiAgLy8gVGhlIHN1bSBvZiB0aGUgaW5wdXQgdmFsdWVzIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICBsZXQgaW5wdXRBbW91bnQ7XG5cbiAgbGV0IGNoYW5nZU91dHB1dHM6IE91dHB1dFtdID0gW107XG5cbiAgbGV0IGNvbnRhaW5zVW5jb21wcmVzc2VkUHVibGljS2V5cyA9IGZhbHNlO1xuXG4gIC8vIFRoZSB0cmFuc2FjdGlvbi5cbiAgbGV0IHRyYW5zYWN0aW9uID0gdXR4b2xpYi5iaXRnby5jcmVhdGVUcmFuc2FjdGlvbkJ1aWxkZXJGb3JOZXR3b3JrKG5ldHdvcmspO1xuXG4gIGNvbnN0IGdldEJpdEdvRmVlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBCbHVlYmlyZC50cnkoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGJpdGdvRmVlSW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1zLndhbGxldC5nZXRCaXRHb0ZlZSh7IGFtb3VudDogdG90YWxPdXRwdXRBbW91bnQsIGluc3RhbnQ6IHBhcmFtcy5pbnN0YW50IH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5mZWUgPiAwKSB7XG4gICAgICAgICAgYml0Z29GZWVJbmZvID0ge1xuICAgICAgICAgICAgYW1vdW50OiByZXN1bHQuZmVlLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGJpdGdvRmVlSW5mbyAmJiBiaXRnb0ZlZUluZm8uYW1vdW50ID4gMCkge1xuICAgICAgICB0b3RhbEFtb3VudCArPSBiaXRnb0ZlZUluZm8uYW1vdW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IGdldEJpdEdvRmVlQWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gQmx1ZWJpcmQudHJ5KGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYml0Z29GZWVJbmZvLCBvciBhZGRyZXNzIGlzIGFscmVhZHkgc2V0LCBkb24ndCBnZXQgYSBuZXcgb25lXG4gICAgICBpZiAoIWJpdGdvRmVlSW5mbyB8fCBiaXRnb0ZlZUluZm8uYWRkcmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gYml0Z28uZ2V0Qml0R29GZWVBZGRyZXNzKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGJpdGdvRmVlSW5mby5hZGRyZXNzID0gcmVzdWx0LmFkZHJlc3M7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBHZXQgYSBkeW5hbWljIGZlZSBlc3RpbWF0ZSBmcm9tIHRoZSBCaXRHbyBzZXJ2ZXIgaWYgZmVlVHhDb25maXJtVGFyZ2V0XG4gIC8vIGlzIHNwZWNpZmllZCBvciBpZiBubyBmZWUtcmVsYXRlZCBwYXJhbXMgYXJlIHNwZWNpZmllZFxuICBjb25zdCBnZXREeW5hbWljRmVlUmF0ZUVzdGltYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0IHx8ICFmZWVQYXJhbXNEZWZpbmVkKSB7XG4gICAgICByZXR1cm4gYml0Z29cbiAgICAgICAgLmVzdGltYXRlRmVlKHtcbiAgICAgICAgICBudW1CbG9ja3M6IHBhcmFtcy5mZWVUeENvbmZpcm1UYXJnZXQsXG4gICAgICAgICAgbWF4RmVlOiBwYXJhbXMubWF4RmVlUmF0ZSxcbiAgICAgICAgICBpbnB1dHM6IHplcm9Db25mVW5zcGVudFR4SWRzLFxuICAgICAgICAgIHR4U2l6ZTogZXN0VHhTaXplLFxuICAgICAgICAgIGNwZnBBd2FyZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIGNvbnN0IGVzdGltYXRlZEZlZVJhdGUgPSByZXN1bHQuY3BmcEZlZVBlcktiO1xuICAgICAgICAgIGNvbnN0IG1pbmltdW0gPSBwYXJhbXMuaW5zdGFudFxuICAgICAgICAgICAgPyBNYXRoLm1heChjb25zdGFudHMubWluRmVlUmF0ZSwgY29uc3RhbnRzLm1pbkluc3RhbnRGZWVSYXRlKVxuICAgICAgICAgICAgOiBjb25zdGFudHMubWluRmVlUmF0ZTtcbiAgICAgICAgICAvLyA1IHNhdG9zaGlzIHBlciBieXRlXG4gICAgICAgICAgLy8gaXQgaXMgd29ydGggbm90aW5nIHRoYXQgdGhlIHBhZGRpbmcgb25seSBhcHBsaWVzIHdoZW4gdGhlIHRocmVzaG9sZCBpcyBjcm9zc2VkLCBidXQgbm90IHdoZW4gdGhlIGRlbHRhIGlzIGxlc3MgdGhhbiB0aGUgcGFkZGluZ1xuICAgICAgICAgIGNvbnN0IHBhZGRpbmcgPSA1MDAwO1xuICAgICAgICAgIGlmIChlc3RpbWF0ZWRGZWVSYXRlIDwgbWluaW11bSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgIG5ldyBEYXRlKCkgK1xuICAgICAgICAgICAgICAgICc6IEVycm9yIHdoZW4gZXN0aW1hdGluZyBmZWUgZm9yIHNlbmQgZnJvbSAnICtcbiAgICAgICAgICAgICAgICBwYXJhbXMud2FsbGV0LmlkKCkgK1xuICAgICAgICAgICAgICAgICcsIGl0IHdhcyB0b28gbG93IC0gJyArXG4gICAgICAgICAgICAgICAgZXN0aW1hdGVkRmVlUmF0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZlZVJhdGUgPSBtaW5pbXVtICsgcGFkZGluZztcbiAgICAgICAgICB9IGVsc2UgaWYgKGVzdGltYXRlZEZlZVJhdGUgPiBwYXJhbXMubWF4RmVlUmF0ZSkge1xuICAgICAgICAgICAgZmVlUmF0ZSA9IHBhcmFtcy5tYXhGZWVSYXRlIC0gcGFkZGluZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmVlUmF0ZSA9IGVzdGltYXRlZEZlZVJhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmZWVSYXRlO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAvLyBzYW5pdHkgY2hlY2sgZmFpbGVkIG9uIHR4IHNpemVcbiAgICAgICAgICBpZiAoXy5pbmNsdWRlcyhlLm1lc3NhZ2UsICdpbnZhbGlkIHR4U2l6ZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gQmx1ZWJpcmQucmVqZWN0KGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb3VsZG4ndCBlc3RpbWF0ZSB0aGUgZmVlLCBwcm9jZWVkIHVzaW5nIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICBmZWVSYXRlID0gY29uc3RhbnRzLmZhbGxiYWNrRmVlUmF0ZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBlc3RpbWF0aW5nIGZlZSBmb3Igc2VuZCBmcm9tICcgKyBwYXJhbXMud2FsbGV0LmlkKCkgKyAnOiAnICsgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gR2V0IHRoZSB1bnNwZW50cyBmb3IgdGhlIHNlbmRpbmcgd2FsbGV0LlxuICBjb25zdCBnZXRVbnNwZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocGFyYW1zLnVuc3BlbnRzKSB7XG4gICAgICAvLyB3ZSBqdXN0IHdhbm5hIHVzZSBjdXN0b20gdW5zcGVudHNcbiAgICAgIHVuc3BlbnRzID0gcGFyYW1zLnVuc3BlbnRzO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEdldCBlbm91Z2ggdW5zcGVudHMgZm9yIHRoZSByZXF1ZXN0ZWQgYW1vdW50XG4gICAgY29uc3Qgb3B0aW9ucyA9IF8ubWVyZ2Uoe30sIHBhcmFtcy51bnNwZW50c0ZldGNoUGFyYW1zIHx8IHt9LCB7XG4gICAgICB0YXJnZXQ6IHRvdGFsQW1vdW50LFxuICAgICAgbWluU2l6ZTogcGFyYW1zLm1pblVuc3BlbnRTaXplIHx8IDAsXG4gICAgICBpbnN0YW50OiBwYXJhbXMuaW5zdGFudCwgLy8gaW5zaXN0IG9uIGluc3RhbnQgdW5zcGVudHMgb25seVxuICAgICAgdGFyZ2V0V2FsbGV0VW5zcGVudHM6IHBhcmFtcy50YXJnZXRXYWxsZXRVbnNwZW50cyxcbiAgICB9KTtcbiAgICBpZiAocGFyYW1zLmluc3RhbnQpIHtcbiAgICAgIG9wdGlvbnMuaW5zdGFudCA9IHBhcmFtcy5pbnN0YW50OyAvLyBpbnNpc3Qgb24gaW5zdGFudCB1bnNwZW50cyBvbmx5XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcy53YWxsZXQudW5zcGVudHNQYWdlZChvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICBjb25zb2xlLmxvZyhgVW5zcGVudHMgZmV0Y2hlZFxcbjogICR7SlNPTi5zdHJpbmdpZnkocmVzdWx0cywgbnVsbCwgMil9YCk7XG4gICAgICB0b3RhbFVuc3BlbnRzQ291bnQgPSByZXN1bHRzLnRvdGFsO1xuICAgICAgZmV0Y2hlZFVuc3BlbnRzQ291bnQgPSByZXN1bHRzLmNvdW50O1xuICAgICAgdW5zcGVudHMgPSByZXN1bHRzLnVuc3BlbnRzLmZpbHRlcihmdW5jdGlvbiAodSkge1xuICAgICAgICBjb25zdCBjb25maXJtcyA9IHUuY29uZmlybWF0aW9ucyB8fCAwO1xuICAgICAgICBpZiAoIXBhcmFtcy5lbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2UgJiYgdS5pc0NoYW5nZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25maXJtcyA+PSBtaW5Db25maXJtcztcbiAgICAgIH0pO1xuXG4gICAgICAvLyBhYm9ydCBlYXJseSBpZiB0aGVyZSdzIG5vIHZpYWJsZSB1bnNwZW50cywgYmVjYXVzZSBpdCB3b24ndCBiZSBwb3NzaWJsZSB0byBjcmVhdGUgdGhlIHR4biBsYXRlclxuICAgICAgaWYgKHVuc3BlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBFcnJvcignMCB1bnNwZW50cyBhdmFpbGFibGUgZm9yIHRyYW5zYWN0aW9uIGNyZWF0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNyZWF0ZSBhcnJheSBvZiB1bmNvbmZpcm1lZCB1bnNwZW50IElEIHN0cmluZ3Mgb2YgdGhlIGZvcm0gXCJ0eEhhc2g6b3V0cHV0SW5kZXhcIlxuICAgICAgemVyb0NvbmZVbnNwZW50VHhJZHMgPSBfKHJlc3VsdHMudW5zcGVudHMpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgICByZXR1cm4gIXUuY29uZmlybWF0aW9ucztcbiAgICAgICAgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodSkge1xuICAgICAgICAgIHJldHVybiB1LnR4X2hhc2ggKyAnOicgKyB1LnR4X291dHB1dF9uO1xuICAgICAgICB9KVxuICAgICAgICAudmFsdWUoKTtcbiAgICAgIGlmIChfLmlzRW1wdHkoemVyb0NvbmZVbnNwZW50VHhJZHMpKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gcGFzcyBhbiBlbXB0eSBhcnJheSBvZiBpbnB1dHMgdG8gdGhlIHNlcnZlciwgYmVjYXVzZSBpdCBhc3N1bWVzIGlmIHRoZVxuICAgICAgICAvLyBpbnB1dHMgYXJndW1lbnRzIGV4aXN0cywgaXQgY29udGFpbnMgdmFsdWVzXG4gICAgICAgIHplcm9Db25mVW5zcGVudFR4SWRzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHJlc3BlY3QgdGhlIG9sZCBzcGxpdENoYW5nZVNpemU9MCBwYXJhbWV0ZXJcbiAgICAgIGlmICghcGFyYW1zLm5vU3BsaXRDaGFuZ2UgJiYgcGFyYW1zLnNwbGl0Q2hhbmdlU2l6ZSAhPT0gMCkge1xuICAgICAgICBleHRyYUNoYW5nZUFtb3VudHMgPSByZXN1bHRzLmV4dHJhQ2hhbmdlQW1vdW50cyB8fCBbXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIHVuc3BlbnRzIGZvciB0aGUgc2luZ2xlIGtleSBmZWUgYWRkcmVzc1xuICBsZXQgZmVlU2luZ2xlS2V5VW5zcGVudHM6IEJpdEdvVW5zcGVudFtdID0gW107XG4gIGNvbnN0IGdldFVuc3BlbnRzRm9yU2luZ2xlS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzKSB7XG4gICAgICBsZXQgZmVlVGFyZ2V0ID0gMC4wMWU4O1xuICAgICAgaWYgKHBhcmFtcy5pbnN0YW50KSB7XG4gICAgICAgIGZlZVRhcmdldCArPSB0b3RhbEFtb3VudCAqIDAuMDAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpdGdvXG4gICAgICAgIC5nZXQoYml0Z28udXJsKCcvYWRkcmVzcy8nICsgZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyArICcvdW5zcGVudHM/dGFyZ2V0PScgKyBmZWVUYXJnZXQpKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICBpZiAocmVzcG9uc2UuYm9keS50b3RhbCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHVuc3BlbnRzIGF2YWlsYWJsZSBpbiBzaW5nbGUga2V5IGZlZSBzb3VyY2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmVlU2luZ2xlS2V5VW5zcGVudHMgPSByZXNwb25zZS5ib2R5LnVuc3BlbnRzO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgbGV0IG1pbmVyRmVlSW5mbzogYW55ID0ge307XG4gIGxldCB0eEluZm86IGFueSA9IHt9O1xuXG4gIC8vIEl0ZXJhdGUgdW5zcGVudHMsIHN1bSB0aGUgaW5wdXRzLCBhbmQgc2F2ZSBfaW5wdXRzIHdpdGggdGhlIHRvdGFsXG4gIC8vIGlucHV0IGFtb3VudCBhbmQgZmluYWwgbGlzdCBvZiBpbnB1dHMgdG8gdXNlIHdpdGggdGhlIHRyYW5zYWN0aW9uLlxuICBsZXQgZmVlU2luZ2xlS2V5VW5zcGVudHNVc2VkOiBCaXRHb1Vuc3BlbnRbXSA9IFtdO1xuXG4gIGNvbnN0IGNvbGxlY3RJbnB1dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF1bnNwZW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gdW5zcGVudHMgYXZhaWxhYmxlIG9uIHdhbGxldCcpO1xuICAgIH1cbiAgICBpbnB1dEFtb3VudCA9IDA7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGNvc3Qgb2Ygc3BlbmRpbmcgYSBzaW5nbGUgaW5wdXQsIGkuZS4gdGhlIHNtYWxsZXN0IGVjb25vbWljYWwgdW5zcGVudCB2YWx1ZVxuICAgIHJldHVybiBCbHVlYmlyZC50cnkoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF8uaXNOdW1iZXIocGFyYW1zLmZlZVJhdGUpIHx8IF8uaXNOdW1iZXIocGFyYW1zLm9yaWdpbmFsRmVlUmF0ZSkpIHtcbiAgICAgICAgcmV0dXJuICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5mZWVSYXRlKSA/IHBhcmFtcy5mZWVSYXRlIDogcGFyYW1zLm9yaWdpbmFsRmVlUmF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiaXRnb1xuICAgICAgICAgIC5lc3RpbWF0ZUZlZSh7XG4gICAgICAgICAgICBudW1CbG9ja3M6IHBhcmFtcy5mZWVUeENvbmZpcm1UYXJnZXQsXG4gICAgICAgICAgICBtYXhGZWU6IHBhcmFtcy5tYXhGZWVSYXRlLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZlZVJhdGVFc3RpbWF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZlZVJhdGVFc3RpbWF0ZS5mZWVQZXJLYjtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKGZlZVJhdGUpIHtcbiAgICAgICAgLy8gRG9uJ3Qgc3BlbmQgaW5wdXRzIHRoYXQgY2Fubm90IHBheSBmb3IgdGhlaXIgb3duIGNvc3QuXG4gICAgICAgIGxldCBtaW5JbnB1dFZhbHVlID0gMDtcbiAgICAgICAgaWYgKF8uaXNJbnRlZ2VyKHBhcmFtcy5taW5VbnNwZW50U2l6ZSkpIHtcbiAgICAgICAgICBtaW5JbnB1dFZhbHVlID0gcGFyYW1zLm1pblVuc3BlbnRTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBydW5lZFVuc3BlbnRDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVW5zcGVudENvdW50ID0gdW5zcGVudHMubGVuZ3RoO1xuICAgICAgICB1bnNwZW50cyA9IF8uZmlsdGVyKHVuc3BlbnRzLCBmdW5jdGlvbiAodW5zcGVudCkge1xuICAgICAgICAgIGNvbnN0IGlzU2Vnd2l0SW5wdXQgPSAhIXVuc3BlbnQud2l0bmVzc1NjcmlwdDtcbiAgICAgICAgICBjb25zdCBjdXJyZW50SW5wdXRTaXplID0gaXNTZWd3aXRJbnB1dCA/IFZpcnR1YWxTaXplcy50eFAyc2hQMndzaElucHV0U2l6ZSA6IFZpcnR1YWxTaXplcy50eFAyc2hJbnB1dFNpemU7XG4gICAgICAgICAgY29uc3QgZmVlQmFzZWRNaW5JbnB1dFZhbHVlID0gKGZlZVJhdGUgKiBjdXJyZW50SW5wdXRTaXplKSAvIDEwMDA7XG4gICAgICAgICAgY29uc3QgY3VycmVudE1pbklucHV0VmFsdWUgPSBNYXRoLm1heChtaW5JbnB1dFZhbHVlLCBmZWVCYXNlZE1pbklucHV0VmFsdWUpO1xuICAgICAgICAgIGlmIChjdXJyZW50TWluSW5wdXRWYWx1ZSA+IHVuc3BlbnQudmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHBydW5pbmcgdW5zcGVudFxuICAgICAgICAgICAgY29uc3QgcHJ1bmVEZXRhaWxzID0ge1xuICAgICAgICAgICAgICBnZW5lcmFsTWluSW5wdXRWYWx1ZTogbWluSW5wdXRWYWx1ZSxcbiAgICAgICAgICAgICAgZmVlQmFzZWRNaW5JbnB1dFZhbHVlLFxuICAgICAgICAgICAgICBjdXJyZW50TWluSW5wdXRWYWx1ZSxcbiAgICAgICAgICAgICAgZmVlUmF0ZSxcbiAgICAgICAgICAgICAgaW5wdXRTaXplOiBjdXJyZW50SW5wdXRTaXplLFxuICAgICAgICAgICAgICB1bnNwZW50OiB1bnNwZW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBwcnVuaW5nIHVuc3BlbnQ6ICR7SlNPTi5zdHJpbmdpZnkocHJ1bmVEZXRhaWxzLCBudWxsLCA0KX1gKTtcbiAgICAgICAgICAgIHBydW5lZFVuc3BlbnRDb3VudCsrO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHBydW5lZFVuc3BlbnRDb3VudCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgcHJ1bmVkICR7cHJ1bmVkVW5zcGVudENvdW50fSBvdXQgb2YgJHtvcmlnaW5hbFVuc3BlbnRDb3VudH0gdW5zcGVudHNgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bnNwZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luc3VmZmljaWVudCBmdW5kcycpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWd3aXRJbnB1dENvdW50ID0gMDtcbiAgICAgICAgdW5zcGVudHMuZXZlcnkoZnVuY3Rpb24gKHVuc3BlbnQpIHtcbiAgICAgICAgICBpZiAodW5zcGVudC53aXRuZXNzU2NyaXB0KSB7XG4gICAgICAgICAgICBzZWd3aXRJbnB1dENvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0QW1vdW50ICs9IHVuc3BlbnQudmFsdWU7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uYWRkSW5wdXQodW5zcGVudC50eF9oYXNoLCB1bnNwZW50LnR4X291dHB1dF9uLCAweGZmZmZmZmZmKTtcblxuICAgICAgICAgIHJldHVybiBpbnB1dEFtb3VudCA8IChmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzID8gdG90YWxPdXRwdXRBbW91bnQgOiB0b3RhbEFtb3VudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIHBheWluZyBmZWVzIGZyb20gYW4gZXh0ZXJuYWwgc2luZ2xlIGtleSB3YWxsZXQsIGFkZCB0aGUgaW5wdXRzXG4gICAgICAgIGlmIChmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzKSB7XG4gICAgICAgICAgLy8gY29sbGVjdCB0aGUgYW1vdW50IHVzZWQgaW4gdGhlIGZlZSBpbnB1dHMgc28gd2UgY2FuIGdldCBjaGFuZ2UgbGF0ZXJcbiAgICAgICAgICBmZWVTaW5nbGVLZXlJbnB1dEFtb3VudCA9IDA7XG4gICAgICAgICAgZmVlU2luZ2xlS2V5VW5zcGVudHNVc2VkID0gW107XG4gICAgICAgICAgZmVlU2luZ2xlS2V5VW5zcGVudHMuZXZlcnkoZnVuY3Rpb24gKHVuc3BlbnQpIHtcbiAgICAgICAgICAgIGZlZVNpbmdsZUtleUlucHV0QW1vdW50ICs9IHVuc3BlbnQudmFsdWU7XG4gICAgICAgICAgICBpbnB1dEFtb3VudCArPSB1bnNwZW50LnZhbHVlO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWRkSW5wdXQodW5zcGVudC50eF9oYXNoLCB1bnNwZW50LnR4X291dHB1dF9uKTtcbiAgICAgICAgICAgIGZlZVNpbmdsZUtleVVuc3BlbnRzVXNlZC5wdXNoKHVuc3BlbnQpO1xuICAgICAgICAgICAgLy8gdXNlIHRoZSBmZWUgd2FsbGV0IHRvIHBheSBtaW5lciBmZWVzIGFuZCBwb3RlbnRpYWxseSBpbnN0YW50IGZlZXNcbiAgICAgICAgICAgIHJldHVybiBmZWVTaW5nbGVLZXlJbnB1dEFtb3VudCA8IGZlZSArIChiaXRnb0ZlZUluZm8gPyBiaXRnb0ZlZUluZm8uYW1vdW50IDogMCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0eEluZm8gPSB7XG4gICAgICAgICAgblAyc2hJbnB1dHM6IHRyYW5zYWN0aW9uLnR4Lmlucy5sZW5ndGggLSAoZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyA/IDEgOiAwKSAtIHNlZ3dpdElucHV0Q291bnQsXG4gICAgICAgICAgblAyc2hQMndzaElucHV0czogc2Vnd2l0SW5wdXRDb3VudCxcbiAgICAgICAgICBuUDJwa2hJbnB1dHM6IGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgPyAxIDogMCxcbiAgICAgICAgICAvLyBhZGQgc2luZ2xlIGtleSBzb3VyY2UgYWRkcmVzcyBjaGFuZ2VcbiAgICAgICAgICBuT3V0cHV0czpcbiAgICAgICAgICAgIHJlY2lwaWVudHMubGVuZ3RoICtcbiAgICAgICAgICAgIDEgKyAvLyByZWNpcGllbnRzIGFuZCBjaGFuZ2VcbiAgICAgICAgICAgIGV4dHJhQ2hhbmdlQW1vdW50cy5sZW5ndGggKyAvLyBleHRyYSBjaGFuZ2Ugc3BsaXR0aW5nXG4gICAgICAgICAgICAoYml0Z29GZWVJbmZvICYmIGJpdGdvRmVlSW5mby5hbW91bnQgPiAwID8gMSA6IDApICsgLy8gYWRkIG91dHB1dCBmb3IgYml0Z28gZmVlXG4gICAgICAgICAgICAoZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyA/IDEgOiAwKSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBcyBwZXIgdGhlIHJlc3BvbnNlIG9mIGdldCB1bnNwZW50cyBBUEksIGZvciB2MSBzYWZlIHdhbGxldHMgcmVkZWVtU2NyaXB0IGlzIHJldHVybmVkXG4gICAgICAgIC8vIGluIHRoZSByZXNwb25zZSBpbiBoZXggZm9ybWF0XG4gICAgICAgIGNvbnRhaW5zVW5jb21wcmVzc2VkUHVibGljS2V5cyA9IHVuc3BlbnRzLnNvbWUoXG4gICAgICAgICAgKHUpID0+IHUucmVkZWVtU2NyaXB0Lmxlbmd0aCA9PT0gMjAxICogMiAvKiBoZXggbGVuZ3RoIGlzIHR3aWNlIHRoZSBsZW5ndGggaW4gYnl0ZXMgKi9cbiAgICAgICAgKTtcblxuICAgICAgICBlc3RUeFNpemUgPSBlc3RpbWF0ZVRyYW5zYWN0aW9uU2l6ZSh7XG4gICAgICAgICAgY29udGFpbnNVbmNvbXByZXNzZWRQdWJsaWNLZXlzLFxuICAgICAgICAgIG5QMnNoSW5wdXRzOiB0eEluZm8ublAyc2hJbnB1dHMsXG4gICAgICAgICAgblAyc2hQMndzaElucHV0czogdHhJbmZvLm5QMnNoUDJ3c2hJbnB1dHMsXG4gICAgICAgICAgblAycGtoSW5wdXRzOiB0eEluZm8ublAycGtoSW5wdXRzLFxuICAgICAgICAgIG5PdXRwdXRzOiB0eEluZm8ubk91dHB1dHMsXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC50aGVuKGdldER5bmFtaWNGZWVSYXRlRXN0aW1hdGUpXG4gICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1pbmVyRmVlSW5mbyA9IGV4cG9ydHMuY2FsY3VsYXRlTWluZXJGZWVJbmZvKHtcbiAgICAgICAgICBiaXRnbzogcGFyYW1zLndhbGxldC5iaXRnbyxcbiAgICAgICAgICBjb250YWluc1VuY29tcHJlc3NlZFB1YmxpY0tleXMsXG4gICAgICAgICAgZmVlUmF0ZTogZmVlUmF0ZSxcbiAgICAgICAgICBuUDJzaElucHV0czogdHhJbmZvLm5QMnNoSW5wdXRzLFxuICAgICAgICAgIG5QMnNoUDJ3c2hJbnB1dHM6IHR4SW5mby5uUDJzaFAyd3NoSW5wdXRzLFxuICAgICAgICAgIG5QMnBraElucHV0czogdHhJbmZvLm5QMnBraElucHV0cyxcbiAgICAgICAgICBuT3V0cHV0czogdHhJbmZvLm5PdXRwdXRzLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2hvdWxkQ29tcHV0ZUJlc3RGZWUpIHtcbiAgICAgICAgICBjb25zdCBhcHByb3hpbWF0ZUZlZSA9IG1pbmVyRmVlSW5mby5mZWU7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkUmVjdXJzZSA9IF8uaXNVbmRlZmluZWQoZmVlKSB8fCBhcHByb3hpbWF0ZUZlZSA+IGZlZTtcbiAgICAgICAgICBmZWUgPSBhcHByb3hpbWF0ZUZlZTtcbiAgICAgICAgICAvLyBSZWNvbXB1dGUgdG90YWxBbW91bnQgZnJvbSBzY3JhdGNoXG4gICAgICAgICAgdG90YWxBbW91bnQgPSBmZWUgKyB0b3RhbE91dHB1dEFtb3VudDtcbiAgICAgICAgICBpZiAoYml0Z29GZWVJbmZvKSB7XG4gICAgICAgICAgICB0b3RhbEFtb3VudCArPSBiaXRnb0ZlZUluZm8uYW1vdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2hvdWxkUmVjdXJzZSkge1xuICAgICAgICAgICAgLy8gaWYgZmVlIGNoYW5nZWQsIHJlLWNvbGxlY3QgaW5wdXRzXG4gICAgICAgICAgICBpbnB1dEFtb3VudCA9IDA7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbiA9IHV0eG9saWIuYml0Z28uY3JlYXRlVHJhbnNhY3Rpb25CdWlsZGVyRm9yTmV0d29yayhuZXR3b3JrKTtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0SW5wdXRzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG90YWxGZWUgPSBmZWUgKyAoYml0Z29GZWVJbmZvID8gYml0Z29GZWVJbmZvLmFtb3VudCA6IDApO1xuXG4gICAgICAgIGlmIChmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzKSB7XG4gICAgICAgICAgY29uc3Qgc3VtbWVkU2luZ2xlS2V5VW5zcGVudHMgPSBfLnN1bUJ5KGZlZVNpbmdsZUtleVVuc3BlbnRzLCAndmFsdWUnKTtcbiAgICAgICAgICBpZiAodG90YWxGZWUgPiBzdW1tZWRTaW5nbGVLZXlVbnNwZW50cykge1xuICAgICAgICAgICAgY29uc3QgZXJyOiBhbnkgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdJbnN1ZmZpY2llbnQgZmVlIGFtb3VudCBhdmFpbGFibGUgaW4gc2luZ2xlIGtleSBmZWUgc291cmNlOiAnICsgc3VtbWVkU2luZ2xlS2V5VW5zcGVudHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIucmVzdWx0ID0ge1xuICAgICAgICAgICAgICBmZWU6IGZlZSxcbiAgICAgICAgICAgICAgZmVlUmF0ZTogZmVlUmF0ZSxcbiAgICAgICAgICAgICAgZXN0aW1hdGVkU2l6ZTogbWluZXJGZWVJbmZvLnNpemUsXG4gICAgICAgICAgICAgIGF2YWlsYWJsZTogaW5wdXRBbW91bnQsXG4gICAgICAgICAgICAgIGJpdGdvRmVlOiBiaXRnb0ZlZUluZm8sXG4gICAgICAgICAgICAgIHR4SW5mbzogdHhJbmZvLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBCbHVlYmlyZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXRBbW91bnQgPCAoZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyA/IHRvdGFsT3V0cHV0QW1vdW50IDogdG90YWxBbW91bnQpKSB7XG4gICAgICAgICAgLy8gVGhlIHVuc3BlbnRzIHdlJ3JlIHVzaW5nIGZvciBpbnB1dHMgZG8gbm90IGhhdmUgc3VmZmljaWVudCB2YWx1ZSBvbiB0aGVtIHRvXG4gICAgICAgICAgLy8gc2F0aXNmeSB0aGUgdXNlcidzIHJlcXVlc3RlZCBzcGVuZCBhbW91bnQuIFRoYXQgbWF5IGJlIGJlY2F1c2UgdGhlIHdhbGxldCdzIGJhbGFuY2VcbiAgICAgICAgICAvLyBpcyBzaW1wbHkgdG9vIGxvdywgb3IgaXQgbWlnaHQgYmUgdGhhdCB0aGUgd2FsbGV0J3MgYmFsYW5jZSBpcyBzdWZmaWNpZW50IGJ1dFxuICAgICAgICAgIC8vIHdlIGRpZG4ndCBmZXRjaCBlbm91Z2ggdW5zcGVudHMuIFRvbyBmZXcgdW5zcGVudHMgY291bGQgcmVzdWx0IGZyb20gdGhlIHdhbGxldFxuICAgICAgICAgIC8vIGhhdmluZyBtYW55IHNtYWxsIHVuc3BlbnRzIGFuZCB3ZSBoaXQgb3VyIGxpbWl0IG9uIHRoZSBudW1iZXIgb2YgaW5wdXRzIHdlIGNhbiB1c2VcbiAgICAgICAgICAvLyBpbiBhIHR4biwgb3IgaXQgbWlnaHQgaGF2ZSBiZWVuIHRoYXQgdGhlIGZpbHRlcnMgdGhlIHVzZXIgcGFzc2VkIGluIChsaWtlIG1pbkNvbmZpcm1zKVxuICAgICAgICAgIC8vIGRpc3F1YWxpZmllZCB0b28gbWFueSBvZiB0aGUgdW5zcGVudHNcbiAgICAgICAgICBsZXQgZXJyO1xuICAgICAgICAgIGlmICh0b3RhbFVuc3BlbnRzQ291bnQgPT09IGZldGNoZWRVbnNwZW50c0NvdW50KSB7XG4gICAgICAgICAgICAvLyB3ZSBmZXRjaGVkIGV2ZXJ5IHVuc3BlbnQgdGhlIHdhbGxldCBoYWQsIGJ1dCBpdCBzdGlsbCB3YXNuJ3QgZW5vdWdoXG4gICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoJ0luc3VmZmljaWVudCBmdW5kcycpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSB3ZXJlbid0IGFibGUgdG8gZmV0Y2ggYWxsIHRoZSB1bnNwZW50cyBvbiB0aGUgd2FsbGV0XG4gICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBUcmFuc2FjdGlvbiBzaXplIHRvbyBsYXJnZSBkdWUgdG8gdG9vIG1hbnkgdW5zcGVudHMuIENhbiBzZW5kIG9ubHkgJHtpbnB1dEFtb3VudH0gc2F0b3NoaXMgaW4gdGhpcyB0cmFuc2FjdGlvbmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVyci5yZXN1bHQgPSB7XG4gICAgICAgICAgICBmZWU6IGZlZSxcbiAgICAgICAgICAgIGZlZVJhdGU6IGZlZVJhdGUsXG4gICAgICAgICAgICBlc3RpbWF0ZWRTaXplOiBtaW5lckZlZUluZm8uc2l6ZSxcbiAgICAgICAgICAgIGF2YWlsYWJsZTogaW5wdXRBbW91bnQsXG4gICAgICAgICAgICBiaXRnb0ZlZTogYml0Z29GZWVJbmZvLFxuICAgICAgICAgICAgdHhJbmZvOiB0eEluZm8sXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gQmx1ZWJpcmQucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9O1xuXG4gIC8vIEFkZCB0aGUgb3V0cHV0cyBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgY29uc3QgY29sbGVjdE91dHB1dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1pbmVyRmVlSW5mby5zaXplID49IDkwMDAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHRvbyBsYXJnZTogZXN0aW1hdGVkIHNpemUgJyArIG1pbmVyRmVlSW5mby5zaXplICsgJyBieXRlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dHM6IE91dHB1dFtdID0gW107XG5cbiAgICByZWNpcGllbnRzLmZvckVhY2goZnVuY3Rpb24gKHJlY2lwaWVudCkge1xuICAgICAgbGV0IHNjcmlwdDtcbiAgICAgIGlmIChfLmlzU3RyaW5nKHJlY2lwaWVudC5hZGRyZXNzKSkge1xuICAgICAgICBzY3JpcHQgPSB1dHhvbGliLmFkZHJlc3MudG9PdXRwdXRTY3JpcHQocmVjaXBpZW50LmFkZHJlc3MsIG5ldHdvcmspO1xuICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHJlY2lwaWVudC5zY3JpcHQpKSB7XG4gICAgICAgIHNjcmlwdCA9IHJlY2lwaWVudC5zY3JpcHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25laXRoZXIgcmVjaXBpZW50IGFkZHJlc3Mgbm9yIHNjcmlwdCB3YXMgcHJvdmlkZWQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWRhdGUgdHJhdmVsSW5mbyBpZiBpdCBleGlzdHNcbiAgICAgIGxldCB0cmF2ZWxJbmZvO1xuICAgICAgaWYgKCFfLmlzRW1wdHkocmVjaXBpZW50LnRyYXZlbEluZm8pKSB7XG4gICAgICAgIHRyYXZlbEluZm8gPSByZWNpcGllbnQudHJhdmVsSW5mbztcbiAgICAgICAgLy8gQmV0dGVyIHRvIGF2b2lkIHRyb3VibGUgbm93LCBiZWZvcmUgdHggaXMgY3JlYXRlZFxuICAgICAgICBiaXRnby50cmF2ZWxSdWxlKCkudmFsaWRhdGVUcmF2ZWxJbmZvKHRyYXZlbEluZm8pO1xuICAgICAgfVxuXG4gICAgICBvdXRwdXRzLnB1c2goe1xuICAgICAgICBzY3JpcHQ6IHNjcmlwdCxcbiAgICAgICAgYW1vdW50OiByZWNpcGllbnQuYW1vdW50LFxuICAgICAgICB0cmF2ZWxJbmZvOiB0cmF2ZWxJbmZvLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBvcFJldHVybnMuZm9yRWFjaChmdW5jdGlvbiAoeyBtZXNzYWdlLCBhbW91bnQgfSkge1xuICAgICAgY29uc3Qgc2NyaXB0ID0gdXR4b2xpYi5zY3JpcHQuZnJvbUFTTSgnT1BfUkVUVVJOICcgKyBCdWZmZXIuZnJvbShtZXNzYWdlKS50b1N0cmluZygnaGV4JykpO1xuICAgICAgb3V0cHV0cy5wdXNoKHsgc2NyaXB0LCBhbW91bnQgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBnZXRDaGFuZ2VPdXRwdXRzID0gZnVuY3Rpb24gKGNoYW5nZUFtb3VudDogbnVtYmVyKTogT3V0cHV0W10gfCBCbHVlYmlyZDxPdXRwdXRbXT4ge1xuICAgICAgaWYgKGNoYW5nZUFtb3VudCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWdhdGl2ZSBjaGFuZ2UgYW1vdW50OiAnICsgY2hhbmdlQW1vdW50KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0OiBPdXRwdXRbXSA9IFtdO1xuICAgICAgLy8gaWYgd2UgcGFpZCBmZWVzIGZyb20gYSBzaW5nbGUga2V5IHdhbGxldCwgcmV0dXJuIHRoZSBmZWUgY2hhbmdlIGZpcnN0XG4gICAgICBpZiAoZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcykge1xuICAgICAgICBjb25zdCBmZWVTaW5nbGVLZXlXYWxsZXRDaGFuZ2VBbW91bnQgPVxuICAgICAgICAgIGZlZVNpbmdsZUtleUlucHV0QW1vdW50IC0gKGZlZSArIChiaXRnb0ZlZUluZm8gPyBiaXRnb0ZlZUluZm8uYW1vdW50IDogMCkpO1xuICAgICAgICBpZiAoZmVlU2luZ2xlS2V5V2FsbGV0Q2hhbmdlQW1vdW50ID49IGNvbnN0YW50cy5taW5PdXRwdXRTaXplKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goeyBhZGRyZXNzOiBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzLCBhbW91bnQ6IGZlZVNpbmdsZUtleVdhbGxldENoYW5nZUFtb3VudCB9KTtcbiAgICAgICAgICBjaGFuZ2VBbW91bnQgPSBjaGFuZ2VBbW91bnQgLSBmZWVTaW5nbGVLZXlXYWxsZXRDaGFuZ2VBbW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZUFtb3VudCA8IGNvbnN0YW50cy5taW5PdXRwdXRTaXplKSB7XG4gICAgICAgIC8vIEdpdmUgaXQgdG8gdGhlIG1pbmVyc1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLndhbGxldC50eXBlKCkgPT09ICdzYWZlJykge1xuICAgICAgICByZXR1cm4gcGFyYW1zLndhbGxldC5hZGRyZXNzZXMoKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHsgYWRkcmVzczogcmVzcG9uc2UuYWRkcmVzc2VzWzBdLmFkZHJlc3MsIGFtb3VudDogY2hhbmdlQW1vdW50IH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBsZXQgZXh0cmFDaGFuZ2VUb3RhbCA9IF8uc3VtKGV4dHJhQ2hhbmdlQW1vdW50cyk7XG4gICAgICAvLyBTYW5pdHkgY2hlY2tcbiAgICAgIGlmIChleHRyYUNoYW5nZVRvdGFsID4gY2hhbmdlQW1vdW50KSB7XG4gICAgICAgIGV4dHJhQ2hhbmdlQW1vdW50cyA9IFtdO1xuICAgICAgICBleHRyYUNoYW5nZVRvdGFsID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gY29weSBhbmQgYWRkIHJlbWFpbmluZyBjaGFuZ2UgYW1vdW50XG4gICAgICBjb25zdCBhbGxDaGFuZ2VBbW91bnRzID0gZXh0cmFDaGFuZ2VBbW91bnRzLnNsaWNlKDApO1xuICAgICAgYWxsQ2hhbmdlQW1vdW50cy5wdXNoKGNoYW5nZUFtb3VudCAtIGV4dHJhQ2hhbmdlVG90YWwpO1xuXG4gICAgICAvLyBSZWN1cnNpdmUgYXN5bmMgZnVuYyB0byBhZGQgYWxsIGNoYW5nZSBvdXRwdXRzXG4gICAgICBjb25zdCBhZGRDaGFuZ2VPdXRwdXRzID0gZnVuY3Rpb24gKCk6IE91dHB1dFtdIHwgQmx1ZWJpcmQ8T3V0cHV0W10+IHtcbiAgICAgICAgY29uc3QgdGhpc0Ftb3VudCA9IGFsbENoYW5nZUFtb3VudHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKCF0aGlzQW1vdW50KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmx1ZWJpcmQudHJ5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLmNoYW5nZUFkZHJlc3MpIHtcbiAgICAgICAgICAgIC8vIElmIHVzZXIgcGFzc2VkIGEgY2hhbmdlIGFkZHJlc3MsIHVzZSBpdCBmb3IgYWxsIG91dHB1dHNcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuY2hhbmdlQWRkcmVzcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBhZGRyZXNzIHBlciBvdXRwdXQsIGZvciBwcml2YWN5XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgaWYgc2Vnd2l0IG9yIG5vdFxuICAgICAgICAgICAgY29uc3QgY2hhbmdlQ2hhaW4gPSBwYXJhbXMud2FsbGV0LmdldENoYW5nZUNoYWluKHBhcmFtcyk7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLndhbGxldC5jcmVhdGVBZGRyZXNzKHsgY2hhaW46IGNoYW5nZUNoYWluLCB2YWxpZGF0ZTogdmFsaWRhdGUgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQuYWRkcmVzcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHsgYWRkcmVzczogYWRkcmVzcywgYW1vdW50OiB0aGlzQW1vdW50IH0pO1xuICAgICAgICAgIHJldHVybiBhZGRDaGFuZ2VPdXRwdXRzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGFkZENoYW5nZU91dHB1dHMoKTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGNoYW5nZSBvdXRwdXQocykgYW5kIGluc3RhbnQgZmVlIG91dHB1dCBpZiBhcHBsaWNhYmxlXG4gICAgcmV0dXJuIEJsdWViaXJkLnRyeShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2V0Q2hhbmdlT3V0cHV0cyhpbnB1dEFtb3VudCAtIHRvdGFsQW1vdW50KTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIGNoYW5nZU91dHB1dHMgPSByZXN1bHQ7XG4gICAgICBjb25zdCBleHRyYU91dHB1dHMgPSBjaGFuZ2VPdXRwdXRzLmNvbmNhdChbXSk7IC8vIGNvcHkgdGhlIGFycmF5XG4gICAgICBpZiAoYml0Z29GZWVJbmZvICYmIGJpdGdvRmVlSW5mby5hbW91bnQgPiAwKSB7XG4gICAgICAgIGV4dHJhT3V0cHV0cy5wdXNoKGJpdGdvRmVlSW5mbyk7XG4gICAgICB9XG4gICAgICBleHRyYU91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgICAgIGlmICgob3V0cHV0IGFzIEFkZHJlc3NPdXRwdXQpLmFkZHJlc3MpIHtcbiAgICAgICAgICAob3V0cHV0IGFzIFNjcmlwdE91dHB1dCkuc2NyaXB0ID0gdXR4b2xpYi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KChvdXRwdXQgYXMgQWRkcmVzc091dHB1dCkuYWRkcmVzcywgbmV0d29yayk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZWNpZGUgd2hlcmUgdG8gcHV0IHRoZSBvdXRwdXRzIC0gZGVmYXVsdCBpcyB0byByYW5kb21pemUgdW5sZXNzIGZvcmNlZCB0byBlbmRcbiAgICAgICAgY29uc3Qgb3V0cHV0SW5kZXggPSBwYXJhbXMuZm9yY2VDaGFuZ2VBdEVuZCA/IG91dHB1dHMubGVuZ3RoIDogXy5yYW5kb20oMCwgb3V0cHV0cy5sZW5ndGgpO1xuICAgICAgICBvdXRwdXRzLnNwbGljZShvdXRwdXRJbmRleCwgMCwgb3V0cHV0KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGQgYWxsIG91dHB1dHMgdG8gdGhlIHRyYW5zYWN0aW9uXG4gICAgICBvdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICB0cmFuc2FjdGlvbi5hZGRPdXRwdXQoKG91dHB1dCBhcyBTY3JpcHRPdXRwdXQpLnNjcmlwdCwgb3V0cHV0LmFtb3VudCk7XG4gICAgICB9KTtcblxuICAgICAgdHJhdmVsSW5mb3MgPSBfKG91dHB1dHMpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKG91dHB1dCwgaW5kZXgpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBvdXRwdXQudHJhdmVsSW5mbztcbiAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0Lm91dHB1dEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSlcbiAgICAgICAgLmZpbHRlcigpXG4gICAgICAgIC52YWx1ZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFNlcmlhbGl6ZSB0aGUgdHJhbnNhY3Rpb24sIHJldHVybmluZyB3aGF0IGlzIG5lZWRlZCB0byBzaWduIGl0XG4gIGNvbnN0IHNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBvbmx5IG5lZWQgdG8gcmV0dXJuIHRoZSB1bnNwZW50cyB0aGF0IHdlcmUgdXNlZCBhbmQganVzdCB0aGUgY2hhaW5QYXRoLCByZWRlZW1TY3JpcHQsIGFuZCBpbnN0YW50IGZsYWdcbiAgICBjb25zdCBwaWNrZWRVbnNwZW50czogYW55ID0gXy5tYXAodW5zcGVudHMsIGZ1bmN0aW9uICh1bnNwZW50KSB7XG4gICAgICByZXR1cm4gXy5waWNrKHVuc3BlbnQsIFsnY2hhaW5QYXRoJywgJ3JlZGVlbVNjcmlwdCcsICdpbnN0YW50JywgJ3dpdG5lc3NTY3JpcHQnLCAnc2NyaXB0JywgJ3ZhbHVlJ10pO1xuICAgIH0pO1xuICAgIGNvbnN0IHBydW5lZFVuc3BlbnRzID0gXy5zbGljZShwaWNrZWRVbnNwZW50cywgMCwgdHJhbnNhY3Rpb24udHguaW5zLmxlbmd0aCAtIGZlZVNpbmdsZUtleVVuc3BlbnRzVXNlZC5sZW5ndGgpO1xuICAgIF8uZWFjaChmZWVTaW5nbGVLZXlVbnNwZW50c1VzZWQsIGZ1bmN0aW9uIChmZWVVbnNwZW50KSB7XG4gICAgICBwcnVuZWRVbnNwZW50cy5wdXNoKHsgcmVkZWVtU2NyaXB0OiBmYWxzZSwgY2hhaW5QYXRoOiBmYWxzZSB9KTsgLy8gbWFyayBhcyBmYWxzZSB0byBzaWduaWZ5IGEgbm9uLW11bHRpc2lnIGFkZHJlc3NcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQ6IGFueSA9IHtcbiAgICAgIHRyYW5zYWN0aW9uSGV4OiB0cmFuc2FjdGlvbi5idWlsZEluY29tcGxldGUoKS50b0hleCgpLFxuICAgICAgdW5zcGVudHM6IHBydW5lZFVuc3BlbnRzLFxuICAgICAgZmVlOiBmZWUsXG4gICAgICBjaGFuZ2VBZGRyZXNzZXM6IGNoYW5nZU91dHB1dHMubWFwKGZ1bmN0aW9uIChjbykge1xuICAgICAgICByZXR1cm4gXy5waWNrKGNvLCBbJ2FkZHJlc3MnLCAncGF0aCcsICdhbW91bnQnXSk7XG4gICAgICB9KSxcbiAgICAgIHdhbGxldElkOiBwYXJhbXMud2FsbGV0LmlkKCksXG4gICAgICB3YWxsZXRLZXljaGFpbnM6IHBhcmFtcy53YWxsZXQua2V5Y2hhaW5zLFxuICAgICAgZmVlUmF0ZTogZmVlUmF0ZSxcbiAgICAgIGluc3RhbnQ6IHBhcmFtcy5pbnN0YW50LFxuICAgICAgYml0Z29GZWU6IGJpdGdvRmVlSW5mbyxcbiAgICAgIGVzdGltYXRlZFNpemU6IG1pbmVyRmVlSW5mby5zaXplLFxuICAgICAgdHhJbmZvOiB0eEluZm8sXG4gICAgICB0cmF2ZWxJbmZvczogdHJhdmVsSW5mb3MsXG4gICAgfTtcblxuICAgIC8vIEFkZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBpZiAocmVzdWx0Lmluc3RhbnQgJiYgYml0Z29GZWVJbmZvKSB7XG4gICAgICByZXN1bHQuaW5zdGFudEZlZSA9IF8ucGljayhiaXRnb0ZlZUluZm8sIFsnYW1vdW50JywgJ2FkZHJlc3MnXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gQmx1ZWJpcmQudHJ5KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0Qml0R29GZWUoKTtcbiAgfSlcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gQmx1ZWJpcmQuYWxsKFtnZXRCaXRHb0ZlZUFkZHJlc3MoKSwgZ2V0VW5zcGVudHMoKSwgZ2V0VW5zcGVudHNGb3JTaW5nbGVLZXkoKV0pO1xuICAgIH0pXG4gICAgLnRoZW4oY29sbGVjdElucHV0cylcbiAgICAudGhlbihjb2xsZWN0T3V0cHV0cylcbiAgICAudGhlbihzZXJpYWxpemUpO1xufTtcblxuLyoqXG4gKiBFc3RpbWF0ZSB0aGUgc2l6ZSBvZiBhIHRyYW5zYWN0aW9uIGluIGJ5dGVzIGJhc2VkIG9uIHRoZSBudW1iZXIgb2ZcbiAqIGlucHV0cyBhbmQgb3V0cHV0cyBwcmVzZW50LlxuICogQHBhcmFtcyBwYXJhbXMge1xuICogICBuUDJzaElucHV0czogbnVtYmVyIG9mIFAyU0ggKG11bHRpc2lnKSBpbnB1dHNcbiAqICAgblAycGtoSW5wdXRzOiBudW1iZXIgb2YgUDJQS0ggKHNpbmdsZSBzaWcpIGlucHV0c1xuICogICBuT3V0cHV0czogbnVtYmVyIG9mIG91dHB1dHNcbiAqIH1cbiAqXG4gKiBAcmV0dXJucyBzaXplOiBlc3RpbWF0ZWQgc2l6ZSBvZiB0aGUgdHJhbnNhY3Rpb24gaW4gYnl0ZXNcbiAqL1xuY29uc3QgZXN0aW1hdGVUcmFuc2FjdGlvblNpemUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIGlmICghXy5pc0ludGVnZXIocGFyYW1zLm5QMnNoSW5wdXRzKSB8fCBwYXJhbXMublAyc2hJbnB1dHMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgcG9zaXRpdmUgblAyc2hJbnB1dHMnKTtcbiAgfVxuICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5uUDJwa2hJbnB1dHMpIHx8IHBhcmFtcy5uUDJwa2hJbnB1dHMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgcG9zaXRpdmUgblAycGtoSW5wdXRzIHRvIGJlIG51bWVyaWMnKTtcbiAgfVxuICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5uUDJzaFAyd3NoSW5wdXRzKSB8fCBwYXJhbXMublAyc2hQMndzaElucHV0cyA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyBwb3NpdGl2ZSBuUDJzaFAyd3NoSW5wdXRzIHRvIGJlIG51bWVyaWMnKTtcbiAgfVxuICBpZiAocGFyYW1zLm5QMnNoSW5wdXRzICsgcGFyYW1zLm5QMnNoUDJ3c2hJbnB1dHMgPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgYXQgbGVhc3Qgb25lIG5QMnNoSW5wdXRzIG9yIG5QMnNoUDJ3c2hJbnB1dHMnKTtcbiAgfVxuICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5uT3V0cHV0cykgfHwgcGFyYW1zLm5PdXRwdXRzIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIHBvc2l0aXZlIG5PdXRwdXRzJyk7XG4gIH1cblxuICAvLyBUaGUgc2l6ZSBvZiBhbiB1bmNvbXByZXNzZWQgcHVibGljIGtleSBpcyAzMiBieXRlcyBtb3JlIHRoYW4gdGhlIGNvbXByZXNzZWQga2V5LFxuICAvLyBhbmQgaGVuY2UsIG5lZWRzIHRvIGJlIGFjY291bnRlZCBmb3IgaW4gdGhlIHRyYW5zYWN0aW9uIHNpemUgZXN0aW1hdGlvbi5cbiAgY29uc3QgdW5jb21wcmVzc2VkUHVibGljS2V5c1RyaXBsZUNvcnJlY3Rpb25GYWN0b3IgPSAzMiAqIDM7XG5cbiAgcmV0dXJuIChcbiAgICAvLyBUaGlzIGlzIG5vdCBxdWl0ZSBhY2N1cmF0ZSAtIGlmIHRoZXJlIGlzIGEgbWl4IG9mIGlucHV0cyBzY3JpcHRzIHdoZXJlIHNvbWUgdXNlZFxuICAgIC8vIGNvbXByZXNzZWQga2V5cyBhbmQgc29tZSB1c2VkIHVuY29tcHJlc3NlZCBrZXlzLCB3ZSB3b3VsZCBvdmVyZXN0aW1hdGUgdGhlIHNpemUuXG4gICAgLy8gU2luY2Ugd2UgZG9uJ3QgaGF2ZSBtaXhlZCBpbnB1dCBzZXRzLCB0aGlzIHNob3VsZCBub3QgYmUgYW4gaXNzdWUgaW4gcHJhY3RpY2UuXG4gICAgKFZpcnR1YWxTaXplcy50eFAyc2hJbnB1dFNpemUgK1xuICAgICAgKHBhcmFtcy5jb250YWluc1VuY29tcHJlc3NlZFB1YmxpY0tleXMgPyB1bmNvbXByZXNzZWRQdWJsaWNLZXlzVHJpcGxlQ29ycmVjdGlvbkZhY3RvciA6IDApKSAqXG4gICAgICBwYXJhbXMublAyc2hJbnB1dHMgK1xuICAgIFZpcnR1YWxTaXplcy50eFAyc2hQMndzaElucHV0U2l6ZSAqIChwYXJhbXMublAyc2hQMndzaElucHV0cyB8fCAwKSArXG4gICAgVmlydHVhbFNpemVzLnR4UDJwa2hJbnB1dFNpemVVbmNvbXByZXNzZWRLZXkgKiAocGFyYW1zLm5QMnBraElucHV0cyB8fCAwKSArXG4gICAgVmlydHVhbFNpemVzLnR4UDJwa2hPdXRwdXRTaXplICogcGFyYW1zLm5PdXRwdXRzICtcbiAgICAvLyBpZiB0aGUgdHggY29udGFpbnMgYXQgbGVhc3Qgb25lIHNlZ3dpdCBpbnB1dCwgdGhlIHR4IG92ZXJoZWFkIGlzIGluY3JlYXNlZCBieSAxXG4gICAgVmlydHVhbFNpemVzLnR4T3ZlcmhlYWRTaXplICtcbiAgICAocGFyYW1zLm5QMnNoUDJ3c2hJbnB1dHMgPiAwID8gMSA6IDApXG4gICk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgZmVlIGFuZCBlc3RpbWF0ZWQgc2l6ZSBpbiBieXRlcyBmb3IgYSB0cmFuc2FjdGlvbi5cbiAqIEBwYXJhbXMgcGFyYW1zIHtcbiAqICAgYml0Z286IGJpdGdvIG9iamVjdFxuICogICBmZWVSYXRlOiBzYXRvc2hpcyBwZXIga2lsb2J5dGVcbiAqICAgblAyc2hJbnB1dHM6IG51bWJlciBvZiBQMlNIIChtdWx0aXNpZykgaW5wdXRzXG4gKiAgIG5QMnBraElucHV0czogbnVtYmVyIG9mIFAyUEtIIChzaW5nbGUgc2lnKSBpbnB1dHNcbiAqICAgbk91dHB1dHM6IG51bWJlciBvZiBvdXRwdXRzXG4gKiB9XG4gKlxuICogQHJldHVybnMge1xuICogICBzaXplOiBlc3RpbWF0ZWQgc2l6ZSBvZiB0aGUgdHJhbnNhY3Rpb24gaW4gYnl0ZXNcbiAqICAgZmVlOiBlc3RpbWF0ZWQgZmVlIGluIHNhdG9zaGlzIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAqICAgZmVlUmF0ZTogZmVlIHJhdGUgdGhhdCB3YXMgdXNlZCB0byBlc3RpbWF0ZSB0aGUgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAqIH1cbiAqL1xuZXhwb3J0cy5jYWxjdWxhdGVNaW5lckZlZUluZm8gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIGNvbnN0IGZlZVJhdGVUb1VzZSA9IHBhcmFtcy5mZWVSYXRlIHx8IHBhcmFtcy5iaXRnby5nZXRDb25zdGFudHMoKS5mYWxsYmFja0ZlZVJhdGU7XG4gIGNvbnN0IGVzdGltYXRlZFNpemUgPSBlc3RpbWF0ZVRyYW5zYWN0aW9uU2l6ZShwYXJhbXMpO1xuXG4gIHJldHVybiB7XG4gICAgc2l6ZTogZXN0aW1hdGVkU2l6ZSxcbiAgICBmZWU6IE1hdGguY2VpbCgoZXN0aW1hdGVkU2l6ZSAqIGZlZVJhdGVUb1VzZSkgLyAxMDAwKSxcbiAgICBmZWVSYXRlOiBmZWVSYXRlVG9Vc2UsXG4gIH07XG59O1xuXG4vKlxuICogR2l2ZW4gYSB0cmFuc2FjdGlvbiBoZXgsIHVuc3BlbnQgaW5mb3JtYXRpb24gKGNoYWluIHBhdGggYW5kIHJlZGVlbSBzY3JpcHRzKSwgYW5kIHRoZSBrZXljaGFpbiB4cHJ2LFxuICogcGVyZm9ybSBrZXkgZGVyaXZhdGlvbiBhbmQgc2lnbiB0aGUgaW5wdXRzIGluIHRoZSB0cmFuc2FjdGlvbiBiYXNlZCBvbiB0aGUgdW5zcGVudCBpbmZvcm1hdGlvbiBwcm92aWRlZFxuICpcbiAqIEBwYXJhbXM6XG4gKiAgdHJhbnNhY3Rpb25IZXggc2VyaWFsaXplZCBmb3JtIG9mIHRoZSB0cmFuc2FjdGlvbiBpbiBoZXhcbiAqICB1bnNwZW50cyBhcnJheSBvZiB1bnNwZW50IGluZm9ybWF0aW9uLCB3aGVyZSBlYWNoIHVuc3BlbnQgaXMgYSBjaGFpblBhdGggYW5kIHJlZGVlbVNjcmlwdCB3aXRoIHRoZSBzYW1lXG4gKiAgaW5kZXggYXMgdGhlIGlucHV0cyBpbiB0aGUgdHJhbnNhY3Rpb25IZXhcbiAqICBrZXljaGFpbiBLZXljaGFpbiBjb250YWluaW5nIHRoZSB4cHJ2IHRvIHNpZ24gd2l0aC4gRm9yIGxlZ2FjeSBzdXBwb3J0IG9mIHNhZmUgd2FsbGV0cywga2V5Y2hhaW4gY2FuXG4gYWxzbyBiZSBhIFdJRiBwcml2YXRlIGtleS5cbiAqICBzaWduaW5nS2V5IHByaXZhdGUga2V5IGluIFdJRiBmb3Igc2FmZSB3YWxsZXRzLCB3aGVuIGtleWNoYWluIGlzIHVuYXZhaWxhYmxlXG4gKiAgdmFsaWRhdGUgY2xpZW50LXNpZGUgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiAtIGNhbiBiZSBkaXNhYmxlZCBmb3IgaW1wcm92ZWQgcGVyZm9ybWFuY2UgKHNpZ25hdHVyZXNcbiAqICAgICAgICAgICBhcmUgc3RpbGwgdmFsaWRhdGVkIHNlcnZlci1zaWRlKS5cbiAqICBmZWVTaW5nbGVLZXlXSUYgVXNlIHRoZSBhZGRyZXNzIGJhc2VkIG9uIHRoaXMgcHJpdmF0ZSBrZXkgdG8gcGF5IGZlZXNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnRzLnNpZ25UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgbGV0IGtleWNoYWluID0gcGFyYW1zLmtleWNoYWluOyAvLyBkdXBsaWNhdGUgc28gYXMgdG8gbm90IG11dGF0ZSBiZWxvd1xuXG4gIGNvbnN0IHZhbGlkYXRlID0gcGFyYW1zLnZhbGlkYXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogcGFyYW1zLnZhbGlkYXRlO1xuICBsZXQgcHJpdktleTtcbiAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy50cmFuc2FjdGlvbkhleCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyB0aGUgdHJhbnNhY3Rpb24gaGV4IGFzIGEgc3RyaW5nJyk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcy51bnNwZW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyB0aGUgdW5zcGVudHMgYXJyYXknKTtcbiAgfVxuICBpZiAoIV8uaXNCb29sZWFuKHZhbGlkYXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIHZhbGlkYXRlIHRvIGJlIGEgYm9vbGVhbicpO1xuICB9XG4gIGxldCBuZXR3b3JrID0gZ2V0TmV0d29yaygpO1xuICBjb25zdCBlbmFibGVCQ0ggPSBfLmlzQm9vbGVhbihwYXJhbXMuZm9yY2VCQ0gpICYmIHBhcmFtcy5mb3JjZUJDSCA9PT0gdHJ1ZTtcblxuICBpZiAoIV8uaXNPYmplY3Qoa2V5Y2hhaW4pIHx8ICFfLmlzU3RyaW5nKChrZXljaGFpbiBhcyBhbnkpLnhwcnYpKSB7XG4gICAgaWYgKF8uaXNTdHJpbmcocGFyYW1zLnNpZ25pbmdLZXkpKSB7XG4gICAgICBwcml2S2V5ID0gdXR4b2xpYi5FQ1BhaXIuZnJvbVdJRihwYXJhbXMuc2lnbmluZ0tleSwgbmV0d29yayBhcyB1dHhvbGliLkJpdGNvaW5KU05ldHdvcmspO1xuICAgICAga2V5Y2hhaW4gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIHRoZSBrZXljaGFpbiBvYmplY3Qgd2l0aCB4cHJ2Jyk7XG4gICAgfVxuICB9XG5cbiAgbGV0IGZlZVNpbmdsZUtleTtcbiAgaWYgKHBhcmFtcy5mZWVTaW5nbGVLZXlXSUYpIHtcbiAgICBmZWVTaW5nbGVLZXkgPSB1dHhvbGliLkVDUGFpci5mcm9tV0lGKHBhcmFtcy5mZWVTaW5nbGVLZXlXSUYsIG5ldHdvcmsgYXMgdXR4b2xpYi5CaXRjb2luSlNOZXR3b3JrKTtcbiAgfVxuXG4gIGRlYnVnKCdOZXR3b3JrOiAlTycsIG5ldHdvcmspO1xuXG4gIGlmIChlbmFibGVCQ0gpIHtcbiAgICBkZWJ1ZygnRW5hYmxpbmcgQkNI4oCmJyk7XG4gICAgbmV0d29yayA9IHV0eG9saWIubmV0d29ya3MuYml0Y29pbmNhc2g7XG4gICAgZGVidWcoJ05ldyBuZXR3b3JrOiAlTycsIG5ldHdvcmspO1xuICB9XG5cbiAgY29uc3QgdHJhbnNhY3Rpb24gPSB1dHhvbGliLmJpdGdvLmNyZWF0ZVRyYW5zYWN0aW9uRnJvbUhleChwYXJhbXMudHJhbnNhY3Rpb25IZXgsIG5ldHdvcmspO1xuICBpZiAodHJhbnNhY3Rpb24uaW5zLmxlbmd0aCAhPT0gcGFyYW1zLnVuc3BlbnRzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHVuc3BlbnRzIGFycmF5IHNob3VsZCBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9uIGlucHV0cycpO1xuICB9XG5cbiAgLy8gZGVjb3JhdGUgdHJhbnNhY3Rpb24gd2l0aCBpbnB1dCB2YWx1ZXMgZm9yIFRyYW5zYWN0aW9uQnVpbGRlciBpbnN0YW50aWF0aW9uXG4gIGNvbnN0IGlzVXR4b1R4ID0gXy5pc09iamVjdCh0cmFuc2FjdGlvbikgJiYgQXJyYXkuaXNBcnJheSgodHJhbnNhY3Rpb24gYXMgYW55KS5pbnMpO1xuICBjb25zdCBhcmVWYWxpZFVuc3BlbnRzID0gXy5pc09iamVjdChwYXJhbXMpICYmIEFycmF5LmlzQXJyYXkoKHBhcmFtcyBhcyBhbnkpLnVuc3BlbnRzKTtcbiAgaWYgKGlzVXR4b1R4ICYmIGFyZVZhbGlkVW5zcGVudHMpIHtcbiAgICAvLyBleHRlbmQgdGhlIHRyYW5zYWN0aW9uIGlucHV0cyB3aXRoIHRoZSB2YWx1ZXNcbiAgICBjb25zdCBpbnB1dFZhbHVlcyA9IF8ubWFwKChwYXJhbXMgYXMgYW55KS51bnNwZW50cywgKHUpID0+IF8ucGljayh1LCAndmFsdWUnKSk7XG4gICAgdHJhbnNhY3Rpb24uaW5zLm1hcCgoY3VycmVudEl0ZW0sIGluZGV4KSA9PiBfLmV4dGVuZChjdXJyZW50SXRlbSwgaW5wdXRWYWx1ZXNbaW5kZXhdKSk7XG4gIH1cblxuICBsZXQgcm9vdEV4dEtleTtcbiAgaWYgKGtleWNoYWluKSB7XG4gICAgcm9vdEV4dEtleSA9IGJpcDMyLmZyb21CYXNlNTgoa2V5Y2hhaW4ueHBydik7XG4gIH1cblxuICBjb25zdCB0eGIgPSB1dHhvbGliLmJpdGdvLmNyZWF0ZVRyYW5zYWN0aW9uQnVpbGRlckZyb21UcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHR4Yi50eC5pbnMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgY29uc3QgY3VycmVudFVuc3BlbnQgPSBwYXJhbXMudW5zcGVudHNbaW5kZXhdO1xuICAgIGlmIChjdXJyZW50VW5zcGVudC5yZWRlZW1TY3JpcHQgPT09IGZhbHNlKSB7XG4gICAgICAvLyB0aGlzIGlzIHRoZSBpbnB1dCBmcm9tIGEgc2luZ2xlIGtleSBmZWUgYWRkcmVzc1xuICAgICAgaWYgKCFmZWVTaW5nbGVLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaW5nbGUga2V5IGFkZHJlc3MgdXNlZCBpbiBpbnB1dCBidXQgZmVlU2luZ2xlS2V5V0lGIG5vdCBwcm92aWRlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5hYmxlQkNIKSB7XG4gICAgICAgIGZlZVNpbmdsZUtleS5uZXR3b3JrID0gbmV0d29yaztcbiAgICAgIH1cblxuICAgICAgdHhiLnNpZ24oaW5kZXgsIGZlZVNpbmdsZUtleSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFVuc3BlbnQud2l0bmVzc1NjcmlwdCAmJiBlbmFibGVCQ0gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQkNIIGRvZXMgbm90IHN1cHBvcnQgc2Vnd2l0IGlucHV0cycpO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYWluUGF0aCA9IGN1cnJlbnRVbnNwZW50LmNoYWluUGF0aDtcbiAgICBpZiAocm9vdEV4dEtleSkge1xuICAgICAgY29uc3QgeyB3YWxsZXRTdWJQYXRoID0gJy8wLzAnIH0gPSBrZXljaGFpbjtcbiAgICAgIGNvbnN0IHBhdGggPSBzYW5pdGl6ZUxlZ2FjeVBhdGgoa2V5Y2hhaW4ucGF0aCArIHdhbGxldFN1YlBhdGggKyBjaGFpblBhdGgpO1xuICAgICAgZGVidWcoXG4gICAgICAgICdkZXJpdmVkIHVzZXIga2V5IHBhdGggXCIlc1wiIHVzaW5nIGtleWNoYWluIHBhdGggXCIlc1wiLCB3YWxsZXRTdWJQYXRoIFwiJXNcIiwga2V5Y2hhaW4gd2FsbGV0U3ViUGF0aCBcIiVzXCIgYW5kIGNoYWluUGF0aCBcIiVzXCInLFxuICAgICAgICBwYXRoLFxuICAgICAgICBrZXljaGFpbi5wYXRoLFxuICAgICAgICB3YWxsZXRTdWJQYXRoLFxuICAgICAgICBrZXljaGFpbi53YWxsZXRTdWJQYXRoLFxuICAgICAgICBjaGFpblBhdGhcbiAgICAgICk7XG4gICAgICBwcml2S2V5ID0gcm9vdEV4dEtleS5kZXJpdmVQYXRoKHBhdGgpO1xuICAgIH1cblxuICAgIHByaXZLZXkubmV0d29yayA9IG5ldHdvcms7XG5cbiAgICAvLyBzdWJzY3JpcHQgaXMgdGhlIHBhcnQgb2YgdGhlIG91dHB1dCBzY3JpcHQgYWZ0ZXIgdGhlIE9QX0NPREVTRVBBUkFUT1IuXG4gICAgLy8gU2luY2Ugd2UgYXJlIG9ubHkgZXZlciBzaWduaW5nIHAyc2ggb3V0cHV0cywgd2hpY2ggZG8gbm90IGhhdmVcbiAgICAvLyBPUF9DT0RFU0VQQVJBVE9SUywgaXQgaXMgYWx3YXlzIHRoZSBvdXRwdXQgc2NyaXB0LlxuICAgIGNvbnN0IHN1YnNjcmlwdCA9IEJ1ZmZlci5mcm9tKGN1cnJlbnRVbnNwZW50LnJlZGVlbVNjcmlwdCwgJ2hleCcpO1xuICAgIGN1cnJlbnRVbnNwZW50LnZhbGlkYXRpb25TY3JpcHQgPSBzdWJzY3JpcHQ7XG5cbiAgICAvLyBJbiBvcmRlciB0byBzaWduIHdpdGggYml0Y29pbmpzLWxpYiwgd2UgbXVzdCB1c2UgaXRzIHRyYW5zYWN0aW9uXG4gICAgLy8gYnVpbGRlciwgY29uZnVzaW5nbHkgbmFtZWQgdGhlIHNhbWUgZXhhY3QgdGhpbmcgYXMgb3VyIHRyYW5zYWN0aW9uXG4gICAgLy8gYnVpbGRlciwgYnV0IHdpdGggaW5lcXVpdmFsZW50IGJlaGF2aW9yLlxuICAgIHRyeSB7XG4gICAgICBjb25zdCB3aXRuZXNzU2NyaXB0ID0gY3VycmVudFVuc3BlbnQud2l0bmVzc1NjcmlwdCA/IEJ1ZmZlci5mcm9tKGN1cnJlbnRVbnNwZW50LndpdG5lc3NTY3JpcHQsICdoZXgnKSA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IHNpZ0hhc2ggPSB1dHhvbGliLmJpdGdvLmdldERlZmF1bHRTaWdIYXNoKG5ldHdvcmspO1xuICAgICAgdHhiLnNpZ24oaW5kZXgsIHByaXZLZXksIHN1YnNjcmlwdCwgc2lnSGFzaCwgY3VycmVudFVuc3BlbnQudmFsdWUsIHdpdG5lc3NTY3JpcHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHRyeSBmYWxsYmFjayBkZXJpdmF0aW9uIHBhdGggKHNlZSBCRy00NjQ5NylcbiAgICAgIGxldCBmYWxsYmFja1NpZ25pbmdTdWNjZXNzZnVsID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBmYWxsYmFja1BhdGggPSBzYW5pdGl6ZUxlZ2FjeVBhdGgoa2V5Y2hhaW4ucGF0aCArIGNoYWluUGF0aCk7XG4gICAgICAgIGRlYnVnKFxuICAgICAgICAgICdkZXJpdmVkIGZhbGxiYWNrIHVzZXIga2V5IHBhdGggXCIlc1wiIHVzaW5nIGtleWNoYWluIHBhdGggXCIlc1wiIGFuZCBjaGFpblBhdGggXCIlc1wiJyxcbiAgICAgICAgICBmYWxsYmFja1BhdGgsXG4gICAgICAgICAga2V5Y2hhaW4ucGF0aCxcbiAgICAgICAgICBjaGFpblBhdGhcbiAgICAgICAgKTtcbiAgICAgICAgcHJpdktleSA9IHJvb3RFeHRLZXkuZGVyaXZlUGF0aChmYWxsYmFja1BhdGgpO1xuICAgICAgICBjb25zdCB3aXRuZXNzU2NyaXB0ID0gY3VycmVudFVuc3BlbnQud2l0bmVzc1NjcmlwdFxuICAgICAgICAgID8gQnVmZmVyLmZyb20oY3VycmVudFVuc3BlbnQud2l0bmVzc1NjcmlwdCwgJ2hleCcpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNpZ0hhc2ggPSB1dHhvbGliLmJpdGdvLmdldERlZmF1bHRTaWdIYXNoKG5ldHdvcmspO1xuICAgICAgICB0eGIuc2lnbihpbmRleCwgcHJpdktleSwgc3Vic2NyaXB0LCBzaWdIYXNoLCBjdXJyZW50VW5zcGVudC52YWx1ZSwgd2l0bmVzc1NjcmlwdCk7XG4gICAgICAgIGZhbGxiYWNrU2lnbmluZ1N1Y2Nlc3NmdWwgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZmFsbGJhY2tFcnJvcikge1xuICAgICAgICBkZWJ1ZygnaW5wdXQgc2lnbiBmYWlsZWQgZm9yIGZhbGxiYWNrIHBhdGg6ICVzJywgZmFsbGJhY2tFcnJvci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIC8vIHdlIG5lZWQgdG8ga25vdyB3aGF0J3MgY2F1c2luZyB0aGlzXG4gICAgICBpZiAoIWZhbGxiYWNrU2lnbmluZ1N1Y2Nlc3NmdWwpIHtcbiAgICAgICAgZS5yZXN1bHQgPSB7XG4gICAgICAgICAgdW5zcGVudDogY3VycmVudFVuc3BlbnQsXG4gICAgICAgIH07XG4gICAgICAgIGUubWVzc2FnZSA9IGBGYWlsZWQgdG8gc2lnbiBpbnB1dCAjJHtpbmRleH0gLSAke2UubWVzc2FnZX0gLSAke0pTT04uc3RyaW5naWZ5KGUucmVzdWx0LCBudWxsLCA0KX0gLSBcXG4ke1xuICAgICAgICAgIGUuc3RhY2tcbiAgICAgICAgfWA7XG4gICAgICAgIGRlYnVnKCdpbnB1dCBzaWduIGZhaWxlZDogJXMnLCBlLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gQmx1ZWJpcmQucmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHBhcnRpYWxUcmFuc2FjdGlvbiA9IHR4Yi5idWlsZEluY29tcGxldGUoKTtcblxuICBpZiAodmFsaWRhdGUpIHtcbiAgICBwYXJ0aWFsVHJhbnNhY3Rpb24uaW5zLmZvckVhY2goKGlucHV0LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlQ291bnQgPSB1dHhvbGliLmJpdGdvXG4gICAgICAgIC5nZXRTaWduYXR1cmVWZXJpZmljYXRpb25zKHBhcnRpYWxUcmFuc2FjdGlvbiwgaW5kZXgsIHBhcmFtcy51bnNwZW50c1tpbmRleF0udmFsdWUpXG4gICAgICAgIC5maWx0ZXIoKHYpID0+IHYuc2lnbmVkQnkgIT09IHVuZGVmaW5lZCkubGVuZ3RoO1xuICAgICAgaWYgKHNpZ25hdHVyZUNvdW50IDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGF0IGxlYXN0IG9uZSB2YWxpZCBzaWduYXR1cmUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuZnVsbExvY2FsU2lnbmluZyAmJiBzaWduYXR1cmVDb3VudCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdWxsTG9jYWxTaWduaW5nIHNldDogZXhwZWN0ZWQgYXQgbGVhc3QgdHdvIHZhbGlkIHNpZ25hdHVyZXMnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHtcbiAgICB0cmFuc2FjdGlvbkhleDogcGFydGlhbFRyYW5zYWN0aW9uLnRvSGV4KCksXG4gIH0pO1xufTtcbiJdfQ==