"use strict";
/**
 * @hidden
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 */
//
// TravelRule Object
// BitGo accessor for a specific enterprise
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
const sdk_core_1 = require("@bitgo/sdk-core");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const utxolib = require("@bitgo/utxo-lib");
const Bluebird = require("bluebird");
const _ = require("lodash");
//
// Constructor
//
const TravelRule = function (bitgo) {
    // @ts-expect-error - no implicit this
    this.bitgo = bitgo;
};
TravelRule.prototype.url = function (extra) {
    extra = extra || '';
    return this.bitgo.url('/travel/' + extra);
};
/**
 * Get available travel-rule info recipients for a transaction
 * @param params
 *  txid: transaction id
 * @param callback
 * @returns {*}
 */
TravelRule.prototype.getRecipients = function (params, callback) {
    params = params || {};
    params.txid = params.txid || params.hash;
    sdk_core_1.common.validateParams(params, ['txid'], [], callback);
    const url = this.url(params.txid + '/recipients');
    return Bluebird.resolve(this.bitgo.get(url).result('recipients')).nodeify(callback);
};
TravelRule.prototype.validateTravelInfo = function (info) {
    const fields = {
        amount: { type: 'number' },
        toAddress: { type: 'string' },
        toEnterprise: { type: 'string' },
        fromUserName: { type: 'string' },
        fromUserAccount: { type: 'string' },
        fromUserAddress: { type: 'string' },
        toUserName: { type: 'string' },
        toUserAccount: { type: 'string' },
        toUserAddress: { type: 'string' },
        extra: { type: 'object' },
    };
    _.forEach(fields, function (field, fieldName) {
        // No required fields yet -- should there be?
        if (field.required) {
            if (info[fieldName] === undefined) {
                throw new Error('missing required field ' + fieldName + ' in travel info');
            }
        }
        if (info[fieldName] && typeof info[fieldName] !== field.type) {
            throw new Error('incorrect type for field ' + fieldName + ' in travel info, expected ' + field.type);
        }
    });
    // Strip out any other fields we don't know about
    const result = _.pick(info, _.keys(fields));
    if (_.isEmpty(result)) {
        throw new Error('empty travel data');
    }
    return result;
};
/**
 * Takes a transaction object as returned by getTransaction or listTransactions, along
 * with a keychain (or hdnode object), and attempts to decrypt any encrypted travel
 * info included in the transaction's receivedTravelInfo field.
 * Parameters:
 *   tx: a transaction object
 *   keychain: keychain object (with xprv)
 * Returns:
 *   the tx object, augmented with decrypted travelInfo fields
 */
TravelRule.prototype.decryptReceivedTravelInfo = function (params = {}) {
    const tx = params.tx;
    if (!_.isObject(tx)) {
        throw new Error('expecting tx param to be object');
    }
    if (!tx.receivedTravelInfo || !tx.receivedTravelInfo.length) {
        return tx;
    }
    const keychain = params.keychain;
    if (!_.isObject(keychain) || !_.isString(keychain.xprv)) {
        throw new Error('expecting keychain param with xprv');
    }
    const hdNode = utxo_lib_1.bip32.fromBase58(keychain.xprv);
    tx.receivedTravelInfo.forEach((info) => {
        const key = hdNode.derivePath((0, sdk_core_1.sanitizeLegacyPath)(info.toPubKeyPath));
        const secret = (0, sdk_core_1.getSharedSecret)(key, Buffer.from(info.fromPubKey, 'hex')).toString('hex');
        try {
            const decrypted = this.bitgo.decrypt({
                input: info.encryptedTravelInfo,
                password: secret,
            });
            info.travelInfo = JSON.parse(decrypted);
        }
        catch (err) {
            console.error('failed to decrypt or parse travel info for ', info.transactionId + ':' + info.outputIndex);
        }
    });
    return tx;
};
TravelRule.prototype.prepareParams = function (params) {
    params = params || {};
    params.txid = params.txid || params.hash;
    sdk_core_1.common.validateParams(params, ['txid'], ['fromPrivateInfo']);
    const txid = params.txid;
    const recipient = params.recipient;
    let travelInfo = params.travelInfo;
    if (!recipient || !_.isObject(recipient)) {
        throw new Error('invalid or missing recipient');
    }
    if (!travelInfo || !_.isObject(travelInfo)) {
        throw new Error('invalid or missing travelInfo');
    }
    if (!params.noValidate) {
        travelInfo = this.validateTravelInfo(travelInfo);
    }
    // Fill in toEnterprise if not already filled
    if (!travelInfo.toEnterprise && recipient.enterprise) {
        travelInfo.toEnterprise = recipient.enterprise;
    }
    // If a key was not provided, create a new random key
    let fromKey = params.fromKey && utxolib.ECPair.fromWIF(params.fromKey, (0, sdk_core_1.getNetwork)());
    if (!fromKey) {
        fromKey = (0, sdk_core_1.makeRandomKey)();
    }
    // Compute the shared key for encryption
    const sharedSecret = (0, sdk_core_1.getSharedSecret)(fromKey, Buffer.from(recipient.pubKey, 'hex')).toString('hex');
    // JSON-ify and encrypt the payload
    const travelInfoJSON = JSON.stringify(travelInfo);
    const encryptedTravelInfo = this.bitgo.encrypt({
        input: travelInfoJSON,
        password: sharedSecret,
    });
    const result = {
        txid: txid,
        outputIndex: recipient.outputIndex,
        toPubKey: recipient.pubKey,
        fromPubKey: fromKey.publicKey.toString('hex'),
        encryptedTravelInfo: encryptedTravelInfo,
        fromPrivateInfo: undefined,
    };
    if (params.fromPrivateInfo) {
        result.fromPrivateInfo = params.fromPrivateInfo;
    }
    return result;
};
/**
 * Send travel data to the server for a transaction
 */
TravelRule.prototype.send = function (params, callback) {
    params = params || {};
    params.txid = params.txid || params.hash;
    sdk_core_1.common.validateParams(params, ['txid', 'toPubKey', 'encryptedTravelInfo'], ['fromPubKey', 'fromPrivateInfo'], callback);
    if (!_.isNumber(params.outputIndex)) {
        throw new Error('invalid outputIndex');
    }
    return Bluebird.resolve(this.bitgo
        .post(this.url(params.txid + '/' + params.outputIndex))
        .send(params)
        .result()).nodeify(callback);
};
/**
 * Send multiple travel rule infos for the outputs of a single transaction.
 * Parameters:
 *   - txid (or hash): txid of the transaction (must be a sender of the tx)
 *   - travelInfos: array of travelInfo objects which look like the following:
 *     {
 *       outputIndex: number,     // tx output index
 *       fromUserName: string,    // name of the sending user
 *       fromUserAccount: string, // account id of the sending user
 *       fromUserAddress: string, // mailing address of the sending user
 *       toUserName: string,      // name of the receiving user
 *       toUserAccount: string,   // account id of the receiving user
 *       toUserAddress: string    // mailing address of the receiving user
 *     }
 *     All fields aside from outputIndex are optional, but at least one must
 *     be defined.
 *
 *  It is not necessary to provide travelInfo for all output indices.
 *  End-to-end encryption of the travel info is handled automatically by this method.
 *
 */
TravelRule.prototype.sendMany = function (params, callback) {
    params = params || {};
    params.txid = params.txid || params.hash;
    sdk_core_1.common.validateParams(params, ['txid'], callback);
    const travelInfos = params.travelInfos;
    if (!_.isArray(travelInfos)) {
        throw new Error('expected parameter travelInfos to be array');
    }
    const self = this;
    const travelInfoMap = _(travelInfos)
        .keyBy('outputIndex')
        .mapValues(function (travelInfo) {
        return self.validateTravelInfo(travelInfo);
    })
        .value();
    return self.getRecipients({ txid: params.txid }).then(function (recipients) {
        // Build up data to post
        const sendParamsList = [];
        // don't regenerate a new random key for each recipient
        const fromKey = params.fromKey || (0, sdk_core_1.makeRandomKey)().toWIF();
        recipients.forEach(function (recipient) {
            const outputIndex = recipient.outputIndex;
            const info = travelInfoMap[outputIndex];
            if (info) {
                if (info.amount && info.amount !== recipient.amount) {
                    throw new Error('amount did not match for output index ' + outputIndex);
                }
                const sendParams = self.prepareParams({
                    txid: params.txid,
                    recipient: recipient,
                    travelInfo: info,
                    fromKey: fromKey,
                    noValidate: true, // don't re-validate
                });
                sendParamsList.push(sendParams);
            }
        });
        const result = {
            matched: sendParamsList.length,
            results: [],
        };
        const sendSerial = function () {
            const sendParams = sendParamsList.shift();
            if (!sendParams) {
                return result;
            }
            return self
                .send(sendParams)
                .then(function (res) {
                result.results.push({ result: res });
                return sendSerial();
            })
                .catch(function (err) {
                result.results.push({ error: err.toString() });
                return sendSerial();
            });
        };
        return sendSerial();
    });
};
module.exports = TravelRule;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhdmVsUnVsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy92MS90cmF2ZWxSdWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7R0FFRzs7QUFFSDtHQUNHO0FBQ0gsRUFBRTtBQUNGLG9CQUFvQjtBQUNwQiwyQ0FBMkM7QUFDM0MsRUFBRTtBQUNGLG9EQUFvRDtBQUNwRCxFQUFFO0FBQ0YsOENBQXlHO0FBQ3pHLDhDQUF3RDtBQUN4RCwyQ0FBMkM7QUFDM0MscUNBQXFDO0FBQ3JDLDRCQUE0QjtBQXlCNUIsRUFBRTtBQUNGLGNBQWM7QUFDZCxFQUFFO0FBQ0YsTUFBTSxVQUFVLEdBQUcsVUFBVSxLQUFLO0lBQ2hDLHNDQUFzQztJQUN0QyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNyQixDQUFDLENBQUM7QUFFRixVQUFVLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRyxVQUFVLEtBQUs7SUFDeEMsS0FBSyxHQUFHLEtBQUssSUFBSSxFQUFFLENBQUM7SUFDcEIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDLENBQUM7QUFDNUMsQ0FBQyxDQUFDO0FBRUY7Ozs7OztHQU1HO0FBQ0gsVUFBVSxDQUFDLFNBQVMsQ0FBQyxhQUFhLEdBQUcsVUFBVSxNQUFNLEVBQUUsUUFBUTtJQUM3RCxNQUFNLEdBQUcsTUFBTSxJQUFJLEVBQUUsQ0FBQztJQUN0QixNQUFNLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQztJQUN6QyxpQkFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFFdEQsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLGFBQWEsQ0FBQyxDQUFDO0lBQ2xE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QztZQUMxQyxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNmLE9BQU8sTUFBTSxDQUFDO2FBQ2Y7WUFDRCxPQUFPLElBQUk7aUJBQ1IsSUFBSSxDQUFDLFVBQVUsQ0FBQztpQkFDaEIsSUFBSSxDQUFDLFVBQVUsR0FBRztnQkFDakIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztnQkFDckMsT0FBTyxVQUFVLEVBQUUsQ0FBQztZQUN0QixDQUFDLENBQUM7aUJBQ0QsS0FBSyxDQUFDLFVBQVUsR0FBRztnQkFDbEIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsR0FBRyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDL0MsT0FBTyxVQUFVLEVBQUUsQ0FBQztZQUN0QixDQUFDLENBQUMsQ0FBQztRQUNQLENBQUMsQ0FBQztRQUVGLE9BQU8sVUFBVSxFQUFFLENBQUM7SUFDdEIsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUM7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLFVBQVUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGhpZGRlblxuICovXG5cbi8qKlxuICovXG4vL1xuLy8gVHJhdmVsUnVsZSBPYmplY3Rcbi8vIEJpdEdvIGFjY2Vzc29yIGZvciBhIHNwZWNpZmljIGVudGVycHJpc2Vcbi8vXG4vLyBDb3B5cmlnaHQgMjAxNCwgQml0R28sIEluYy4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuaW1wb3J0IHsgY29tbW9uLCBnZXROZXR3b3JrLCBnZXRTaGFyZWRTZWNyZXQsIG1ha2VSYW5kb21LZXksIHNhbml0aXplTGVnYWN5UGF0aCB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBiaXAzMiwgQklQMzJJbnRlcmZhY2UgfSBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0ICogYXMgdXR4b2xpYiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuXG5pbnRlcmZhY2UgRGVjcnlwdFJlY2VpdmVkVHJhdmVsUnVsZU9wdGlvbnMge1xuICB0eD86IHtcbiAgICByZWNlaXZlZFRyYXZlbEluZm8/OiB7XG4gICAgICB0b1B1YktleVBhdGg6IHN0cmluZztcbiAgICAgIGZyb21QdWJLZXk6IHN0cmluZztcbiAgICAgIGVuY3J5cHRlZFRyYXZlbEluZm86IHN0cmluZztcbiAgICAgIHRyYXZlbEluZm86IHN0cmluZztcbiAgICAgIHRyYW5zYWN0aW9uSWQ6IHN0cmluZztcbiAgICAgIG91dHB1dEluZGV4OiBudW1iZXI7XG4gICAgfVtdO1xuICB9O1xuICBrZXljaGFpbj86IHtcbiAgICB4cHJ2Pzogc3RyaW5nO1xuICB9O1xuICBoZG5vZGU/OiBCSVAzMkludGVyZmFjZTtcbn1cblxuaW50ZXJmYWNlIFJlY2lwaWVudCB7XG4gIGVudGVycHJpc2U6IHN0cmluZztcbiAgcHViS2V5OiBzdHJpbmc7XG4gIG91dHB1dEluZGV4OiBzdHJpbmc7XG59XG5cbi8vXG4vLyBDb25zdHJ1Y3RvclxuLy9cbmNvbnN0IFRyYXZlbFJ1bGUgPSBmdW5jdGlvbiAoYml0Z28pIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIG5vIGltcGxpY2l0IHRoaXNcbiAgdGhpcy5iaXRnbyA9IGJpdGdvO1xufTtcblxuVHJhdmVsUnVsZS5wcm90b3R5cGUudXJsID0gZnVuY3Rpb24gKGV4dHJhKSB7XG4gIGV4dHJhID0gZXh0cmEgfHwgJyc7XG4gIHJldHVybiB0aGlzLmJpdGdvLnVybCgnL3RyYXZlbC8nICsgZXh0cmEpO1xufTtcblxuLyoqXG4gKiBHZXQgYXZhaWxhYmxlIHRyYXZlbC1ydWxlIGluZm8gcmVjaXBpZW50cyBmb3IgYSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHBhcmFtc1xuICogIHR4aWQ6IHRyYW5zYWN0aW9uIGlkXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHsqfVxuICovXG5UcmF2ZWxSdWxlLnByb3RvdHlwZS5nZXRSZWNpcGllbnRzID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBwYXJhbXMudHhpZCA9IHBhcmFtcy50eGlkIHx8IHBhcmFtcy5oYXNoO1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3R4aWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICBjb25zdCB1cmwgPSB0aGlzLnVybChwYXJhbXMudHhpZCArICcvcmVjaXBpZW50cycpO1xuICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSh0aGlzLmJpdGdvLmdldCh1cmwpLnJlc3VsdCgncmVjaXBpZW50cycpKS5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cblRyYXZlbFJ1bGUucHJvdG90eXBlLnZhbGlkYXRlVHJhdmVsSW5mbyA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gIGNvbnN0IGZpZWxkcyA9IHtcbiAgICBhbW91bnQ6IHsgdHlwZTogJ251bWJlcicgfSxcbiAgICB0b0FkZHJlc3M6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICB0b0VudGVycHJpc2U6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICBmcm9tVXNlck5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICBmcm9tVXNlckFjY291bnQ6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICBmcm9tVXNlckFkZHJlc3M6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICB0b1VzZXJOYW1lOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgdG9Vc2VyQWNjb3VudDogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgIHRvVXNlckFkZHJlc3M6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICBleHRyYTogeyB0eXBlOiAnb2JqZWN0JyB9LFxuICB9O1xuXG4gIF8uZm9yRWFjaChmaWVsZHMsIGZ1bmN0aW9uIChmaWVsZDogYW55LCBmaWVsZE5hbWUpIHtcbiAgICAvLyBObyByZXF1aXJlZCBmaWVsZHMgeWV0IC0tIHNob3VsZCB0aGVyZSBiZT9cbiAgICBpZiAoZmllbGQucmVxdWlyZWQpIHtcbiAgICAgIGlmIChpbmZvW2ZpZWxkTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgZmllbGQgJyArIGZpZWxkTmFtZSArICcgaW4gdHJhdmVsIGluZm8nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluZm9bZmllbGROYW1lXSAmJiB0eXBlb2YgaW5mb1tmaWVsZE5hbWVdICE9PSBmaWVsZC50eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29ycmVjdCB0eXBlIGZvciBmaWVsZCAnICsgZmllbGROYW1lICsgJyBpbiB0cmF2ZWwgaW5mbywgZXhwZWN0ZWQgJyArIGZpZWxkLnR5cGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU3RyaXAgb3V0IGFueSBvdGhlciBmaWVsZHMgd2UgZG9uJ3Qga25vdyBhYm91dFxuICBjb25zdCByZXN1bHQgPSBfLnBpY2soaW5mbywgXy5rZXlzKGZpZWxkcykpO1xuICBpZiAoXy5pc0VtcHR5KHJlc3VsdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VtcHR5IHRyYXZlbCBkYXRhJyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVGFrZXMgYSB0cmFuc2FjdGlvbiBvYmplY3QgYXMgcmV0dXJuZWQgYnkgZ2V0VHJhbnNhY3Rpb24gb3IgbGlzdFRyYW5zYWN0aW9ucywgYWxvbmdcbiAqIHdpdGggYSBrZXljaGFpbiAob3IgaGRub2RlIG9iamVjdCksIGFuZCBhdHRlbXB0cyB0byBkZWNyeXB0IGFueSBlbmNyeXB0ZWQgdHJhdmVsXG4gKiBpbmZvIGluY2x1ZGVkIGluIHRoZSB0cmFuc2FjdGlvbidzIHJlY2VpdmVkVHJhdmVsSW5mbyBmaWVsZC5cbiAqIFBhcmFtZXRlcnM6XG4gKiAgIHR4OiBhIHRyYW5zYWN0aW9uIG9iamVjdFxuICogICBrZXljaGFpbjoga2V5Y2hhaW4gb2JqZWN0ICh3aXRoIHhwcnYpXG4gKiBSZXR1cm5zOlxuICogICB0aGUgdHggb2JqZWN0LCBhdWdtZW50ZWQgd2l0aCBkZWNyeXB0ZWQgdHJhdmVsSW5mbyBmaWVsZHNcbiAqL1xuVHJhdmVsUnVsZS5wcm90b3R5cGUuZGVjcnlwdFJlY2VpdmVkVHJhdmVsSW5mbyA9IGZ1bmN0aW9uIChwYXJhbXM6IERlY3J5cHRSZWNlaXZlZFRyYXZlbFJ1bGVPcHRpb25zID0ge30pIHtcbiAgY29uc3QgdHggPSBwYXJhbXMudHg7XG4gIGlmICghXy5pc09iamVjdCh0eCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyB0eCBwYXJhbSB0byBiZSBvYmplY3QnKTtcbiAgfVxuXG4gIGlmICghdHgucmVjZWl2ZWRUcmF2ZWxJbmZvIHx8ICF0eC5yZWNlaXZlZFRyYXZlbEluZm8ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHR4O1xuICB9XG5cbiAgY29uc3Qga2V5Y2hhaW4gPSBwYXJhbXMua2V5Y2hhaW47XG4gIGlmICghXy5pc09iamVjdChrZXljaGFpbikgfHwgIV8uaXNTdHJpbmcoa2V5Y2hhaW4ueHBydikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyBrZXljaGFpbiBwYXJhbSB3aXRoIHhwcnYnKTtcbiAgfVxuICBjb25zdCBoZE5vZGUgPSBiaXAzMi5mcm9tQmFzZTU4KGtleWNoYWluLnhwcnYpO1xuXG4gIHR4LnJlY2VpdmVkVHJhdmVsSW5mby5mb3JFYWNoKChpbmZvKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaGROb2RlLmRlcml2ZVBhdGgoc2FuaXRpemVMZWdhY3lQYXRoKGluZm8udG9QdWJLZXlQYXRoKSk7XG4gICAgY29uc3Qgc2VjcmV0ID0gZ2V0U2hhcmVkU2VjcmV0KGtleSwgQnVmZmVyLmZyb20oaW5mby5mcm9tUHViS2V5LCAnaGV4JykpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVjcnlwdGVkID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgaW5wdXQ6IGluZm8uZW5jcnlwdGVkVHJhdmVsSW5mbyxcbiAgICAgICAgcGFzc3dvcmQ6IHNlY3JldCxcbiAgICAgIH0pO1xuICAgICAgaW5mby50cmF2ZWxJbmZvID0gSlNPTi5wYXJzZShkZWNyeXB0ZWQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignZmFpbGVkIHRvIGRlY3J5cHQgb3IgcGFyc2UgdHJhdmVsIGluZm8gZm9yICcsIGluZm8udHJhbnNhY3Rpb25JZCArICc6JyArIGluZm8ub3V0cHV0SW5kZXgpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHR4O1xufTtcblxuVHJhdmVsUnVsZS5wcm90b3R5cGUucHJlcGFyZVBhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBwYXJhbXMudHhpZCA9IHBhcmFtcy50eGlkIHx8IHBhcmFtcy5oYXNoO1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3R4aWQnXSwgWydmcm9tUHJpdmF0ZUluZm8nXSk7XG4gIGNvbnN0IHR4aWQgPSBwYXJhbXMudHhpZDtcbiAgY29uc3QgcmVjaXBpZW50OiBSZWNpcGllbnQgfCB1bmRlZmluZWQgPSBwYXJhbXMucmVjaXBpZW50O1xuICBsZXQgdHJhdmVsSW5mbyA9IHBhcmFtcy50cmF2ZWxJbmZvO1xuICBpZiAoIXJlY2lwaWVudCB8fCAhXy5pc09iamVjdChyZWNpcGllbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG9yIG1pc3NpbmcgcmVjaXBpZW50Jyk7XG4gIH1cbiAgaWYgKCF0cmF2ZWxJbmZvIHx8ICFfLmlzT2JqZWN0KHRyYXZlbEluZm8pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG9yIG1pc3NpbmcgdHJhdmVsSW5mbycpO1xuICB9XG4gIGlmICghcGFyYW1zLm5vVmFsaWRhdGUpIHtcbiAgICB0cmF2ZWxJbmZvID0gdGhpcy52YWxpZGF0ZVRyYXZlbEluZm8odHJhdmVsSW5mbyk7XG4gIH1cblxuICAvLyBGaWxsIGluIHRvRW50ZXJwcmlzZSBpZiBub3QgYWxyZWFkeSBmaWxsZWRcbiAgaWYgKCF0cmF2ZWxJbmZvLnRvRW50ZXJwcmlzZSAmJiByZWNpcGllbnQuZW50ZXJwcmlzZSkge1xuICAgIHRyYXZlbEluZm8udG9FbnRlcnByaXNlID0gcmVjaXBpZW50LmVudGVycHJpc2U7XG4gIH1cblxuICAvLyBJZiBhIGtleSB3YXMgbm90IHByb3ZpZGVkLCBjcmVhdGUgYSBuZXcgcmFuZG9tIGtleVxuICBsZXQgZnJvbUtleSA9IHBhcmFtcy5mcm9tS2V5ICYmIHV0eG9saWIuRUNQYWlyLmZyb21XSUYocGFyYW1zLmZyb21LZXksIGdldE5ldHdvcmsoKSBhcyB1dHhvbGliLkJpdGNvaW5KU05ldHdvcmspO1xuICBpZiAoIWZyb21LZXkpIHtcbiAgICBmcm9tS2V5ID0gbWFrZVJhbmRvbUtleSgpO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgc2hhcmVkIGtleSBmb3IgZW5jcnlwdGlvblxuICBjb25zdCBzaGFyZWRTZWNyZXQgPSBnZXRTaGFyZWRTZWNyZXQoZnJvbUtleSwgQnVmZmVyLmZyb20ocmVjaXBpZW50LnB1YktleSwgJ2hleCcpKS50b1N0cmluZygnaGV4Jyk7XG5cbiAgLy8gSlNPTi1pZnkgYW5kIGVuY3J5cHQgdGhlIHBheWxvYWRcbiAgY29uc3QgdHJhdmVsSW5mb0pTT04gPSBKU09OLnN0cmluZ2lmeSh0cmF2ZWxJbmZvKTtcbiAgY29uc3QgZW5jcnlwdGVkVHJhdmVsSW5mbyA9IHRoaXMuYml0Z28uZW5jcnlwdCh7XG4gICAgaW5wdXQ6IHRyYXZlbEluZm9KU09OLFxuICAgIHBhc3N3b3JkOiBzaGFyZWRTZWNyZXQsXG4gIH0pO1xuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB0eGlkOiB0eGlkLFxuICAgIG91dHB1dEluZGV4OiByZWNpcGllbnQub3V0cHV0SW5kZXgsXG4gICAgdG9QdWJLZXk6IHJlY2lwaWVudC5wdWJLZXksXG4gICAgZnJvbVB1YktleTogZnJvbUtleS5wdWJsaWNLZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgIGVuY3J5cHRlZFRyYXZlbEluZm86IGVuY3J5cHRlZFRyYXZlbEluZm8sXG4gICAgZnJvbVByaXZhdGVJbmZvOiB1bmRlZmluZWQsXG4gIH07XG5cbiAgaWYgKHBhcmFtcy5mcm9tUHJpdmF0ZUluZm8pIHtcbiAgICByZXN1bHQuZnJvbVByaXZhdGVJbmZvID0gcGFyYW1zLmZyb21Qcml2YXRlSW5mbztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFNlbmQgdHJhdmVsIGRhdGEgdG8gdGhlIHNlcnZlciBmb3IgYSB0cmFuc2FjdGlvblxuICovXG5UcmF2ZWxSdWxlLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBwYXJhbXMudHhpZCA9IHBhcmFtcy50eGlkIHx8IHBhcmFtcy5oYXNoO1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMoXG4gICAgcGFyYW1zLFxuICAgIFsndHhpZCcsICd0b1B1YktleScsICdlbmNyeXB0ZWRUcmF2ZWxJbmZvJ10sXG4gICAgWydmcm9tUHViS2V5JywgJ2Zyb21Qcml2YXRlSW5mbyddLFxuICAgIGNhbGxiYWNrXG4gICk7XG5cbiAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5vdXRwdXRJbmRleCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgb3V0cHV0SW5kZXgnKTtcbiAgfVxuXG4gIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKFxuICAgIHRoaXMuYml0Z29cbiAgICAgIC5wb3N0KHRoaXMudXJsKHBhcmFtcy50eGlkICsgJy8nICsgcGFyYW1zLm91dHB1dEluZGV4KSlcbiAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgIC5yZXN1bHQoKVxuICApLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTZW5kIG11bHRpcGxlIHRyYXZlbCBydWxlIGluZm9zIGZvciB0aGUgb3V0cHV0cyBvZiBhIHNpbmdsZSB0cmFuc2FjdGlvbi5cbiAqIFBhcmFtZXRlcnM6XG4gKiAgIC0gdHhpZCAob3IgaGFzaCk6IHR4aWQgb2YgdGhlIHRyYW5zYWN0aW9uIChtdXN0IGJlIGEgc2VuZGVyIG9mIHRoZSB0eClcbiAqICAgLSB0cmF2ZWxJbmZvczogYXJyYXkgb2YgdHJhdmVsSW5mbyBvYmplY3RzIHdoaWNoIGxvb2sgbGlrZSB0aGUgZm9sbG93aW5nOlxuICogICAgIHtcbiAqICAgICAgIG91dHB1dEluZGV4OiBudW1iZXIsICAgICAvLyB0eCBvdXRwdXQgaW5kZXhcbiAqICAgICAgIGZyb21Vc2VyTmFtZTogc3RyaW5nLCAgICAvLyBuYW1lIG9mIHRoZSBzZW5kaW5nIHVzZXJcbiAqICAgICAgIGZyb21Vc2VyQWNjb3VudDogc3RyaW5nLCAvLyBhY2NvdW50IGlkIG9mIHRoZSBzZW5kaW5nIHVzZXJcbiAqICAgICAgIGZyb21Vc2VyQWRkcmVzczogc3RyaW5nLCAvLyBtYWlsaW5nIGFkZHJlc3Mgb2YgdGhlIHNlbmRpbmcgdXNlclxuICogICAgICAgdG9Vc2VyTmFtZTogc3RyaW5nLCAgICAgIC8vIG5hbWUgb2YgdGhlIHJlY2VpdmluZyB1c2VyXG4gKiAgICAgICB0b1VzZXJBY2NvdW50OiBzdHJpbmcsICAgLy8gYWNjb3VudCBpZCBvZiB0aGUgcmVjZWl2aW5nIHVzZXJcbiAqICAgICAgIHRvVXNlckFkZHJlc3M6IHN0cmluZyAgICAvLyBtYWlsaW5nIGFkZHJlc3Mgb2YgdGhlIHJlY2VpdmluZyB1c2VyXG4gKiAgICAgfVxuICogICAgIEFsbCBmaWVsZHMgYXNpZGUgZnJvbSBvdXRwdXRJbmRleCBhcmUgb3B0aW9uYWwsIGJ1dCBhdCBsZWFzdCBvbmUgbXVzdFxuICogICAgIGJlIGRlZmluZWQuXG4gKlxuICogIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gcHJvdmlkZSB0cmF2ZWxJbmZvIGZvciBhbGwgb3V0cHV0IGluZGljZXMuXG4gKiAgRW5kLXRvLWVuZCBlbmNyeXB0aW9uIG9mIHRoZSB0cmF2ZWwgaW5mbyBpcyBoYW5kbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhpcyBtZXRob2QuXG4gKlxuICovXG5UcmF2ZWxSdWxlLnByb3RvdHlwZS5zZW5kTWFueSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgcGFyYW1zLnR4aWQgPSBwYXJhbXMudHhpZCB8fCBwYXJhbXMuaGFzaDtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd0eGlkJ10sIGNhbGxiYWNrKTtcblxuICBjb25zdCB0cmF2ZWxJbmZvcyA9IHBhcmFtcy50cmF2ZWxJbmZvcztcbiAgaWYgKCFfLmlzQXJyYXkodHJhdmVsSW5mb3MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBwYXJhbWV0ZXIgdHJhdmVsSW5mb3MgdG8gYmUgYXJyYXknKTtcbiAgfVxuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICBjb25zdCB0cmF2ZWxJbmZvTWFwID0gXyh0cmF2ZWxJbmZvcylcbiAgICAua2V5QnkoJ291dHB1dEluZGV4JylcbiAgICAubWFwVmFsdWVzKGZ1bmN0aW9uICh0cmF2ZWxJbmZvKSB7XG4gICAgICByZXR1cm4gc2VsZi52YWxpZGF0ZVRyYXZlbEluZm8odHJhdmVsSW5mbyk7XG4gICAgfSlcbiAgICAudmFsdWUoKTtcblxuICByZXR1cm4gc2VsZi5nZXRSZWNpcGllbnRzKHsgdHhpZDogcGFyYW1zLnR4aWQgfSkudGhlbihmdW5jdGlvbiAocmVjaXBpZW50cykge1xuICAgIC8vIEJ1aWxkIHVwIGRhdGEgdG8gcG9zdFxuICAgIGNvbnN0IHNlbmRQYXJhbXNMaXN0OiBhbnlbXSA9IFtdO1xuICAgIC8vIGRvbid0IHJlZ2VuZXJhdGUgYSBuZXcgcmFuZG9tIGtleSBmb3IgZWFjaCByZWNpcGllbnRcbiAgICBjb25zdCBmcm9tS2V5ID0gcGFyYW1zLmZyb21LZXkgfHwgbWFrZVJhbmRvbUtleSgpLnRvV0lGKCk7XG5cbiAgICByZWNpcGllbnRzLmZvckVhY2goZnVuY3Rpb24gKHJlY2lwaWVudCkge1xuICAgICAgY29uc3Qgb3V0cHV0SW5kZXggPSByZWNpcGllbnQub3V0cHV0SW5kZXg7XG4gICAgICBjb25zdCBpbmZvID0gdHJhdmVsSW5mb01hcFtvdXRwdXRJbmRleF07XG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBpZiAoaW5mby5hbW91bnQgJiYgaW5mby5hbW91bnQgIT09IHJlY2lwaWVudC5hbW91bnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Ftb3VudCBkaWQgbm90IG1hdGNoIGZvciBvdXRwdXQgaW5kZXggJyArIG91dHB1dEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kUGFyYW1zID0gc2VsZi5wcmVwYXJlUGFyYW1zKHtcbiAgICAgICAgICB0eGlkOiBwYXJhbXMudHhpZCxcbiAgICAgICAgICByZWNpcGllbnQ6IHJlY2lwaWVudCxcbiAgICAgICAgICB0cmF2ZWxJbmZvOiBpbmZvLFxuICAgICAgICAgIGZyb21LZXk6IGZyb21LZXksXG4gICAgICAgICAgbm9WYWxpZGF0ZTogdHJ1ZSwgLy8gZG9uJ3QgcmUtdmFsaWRhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbmRQYXJhbXNMaXN0LnB1c2goc2VuZFBhcmFtcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXN1bHQ6IHtcbiAgICAgIG1hdGNoZWQ6IG51bWJlcjtcbiAgICAgIHJlc3VsdHM6IHtcbiAgICAgICAgcmVzdWx0PzogYW55O1xuICAgICAgICBlcnJvcj86IHN0cmluZztcbiAgICAgIH1bXTtcbiAgICB9ID0ge1xuICAgICAgbWF0Y2hlZDogc2VuZFBhcmFtc0xpc3QubGVuZ3RoLFxuICAgICAgcmVzdWx0czogW10sXG4gICAgfTtcblxuICAgIGNvbnN0IHNlbmRTZXJpYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBzZW5kUGFyYW1zID0gc2VuZFBhcmFtc0xpc3Quc2hpZnQoKTtcbiAgICAgIGlmICghc2VuZFBhcmFtcykge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGZcbiAgICAgICAgLnNlbmQoc2VuZFBhcmFtcylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgIHJlc3VsdC5yZXN1bHRzLnB1c2goeyByZXN1bHQ6IHJlcyB9KTtcbiAgICAgICAgICByZXR1cm4gc2VuZFNlcmlhbCgpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHJlc3VsdC5yZXN1bHRzLnB1c2goeyBlcnJvcjogZXJyLnRvU3RyaW5nKCkgfSk7XG4gICAgICAgICAgcmV0dXJuIHNlbmRTZXJpYWwoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZW5kU2VyaWFsKCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmF2ZWxSdWxlO1xuIl19