"use strict";
/**
 * @hidden
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 */
//
// Keychains Object
// BitGo accessor to a user's keychain.
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
const utxo_lib_1 = require("@bitgo/utxo-lib");
const crypto_1 = require("crypto");
const sdk_core_1 = require("@bitgo/sdk-core");
const _ = require('lodash');
const Bluebird = require("bluebird");
const co = Bluebird.coroutine;
//
// Constructor
//
const Keychains = function (bitgo) {
    // @ts-expect-error - no implicit this
    this.bitgo = bitgo;
};
//
// isValid
// Tests a xpub or xprv string to see if it is a valid keychain.
//
Keychains.prototype.isValid = function (params) {
    params = params || {};
    sdk_core_1.common.validateParams(params, [], []);
    if (!_.isString(params.key) && !_.isObject(params.key)) {
        throw new Error('key must be a string or object');
    }
    try {
        if (!params.key.path) {
            utxo_lib_1.bip32.fromBase58(params.key);
        }
        else {
            utxo_lib_1.bip32.fromBase58(params.key.xpub).derivePath((0, sdk_core_1.sanitizeLegacyPath)(params.key.path));
        }
        return true;
    }
    catch (e) {
        return false;
    }
};
//
// create
// Create a new keychain locally.
// Does not send the keychain to bitgo, only creates locally.
// If |seed| is provided, used to seed the keychain.  Otherwise,
// a random keychain is created.
//
Keychains.prototype.create = function (params) {
    params = params || {};
    sdk_core_1.common.validateParams(params, [], []);
    let seed;
    if (!params.seed) {
        // An extended private key has both a normal 256 bit private key and a 256
        // bit chain code, both of which must be random. 512 bits is therefore the
        // maximum entropy and gives us maximum security against cracking.
        seed = (0, crypto_1.randomBytes)(512 / 8);
    }
    else {
        seed = params.seed;
    }
    const extendedKey = utxo_lib_1.bip32.fromSeed(seed);
    const xpub = extendedKey.neutered().toBase58();
    let ethAddress;
    try {
        ethAddress = sdk_core_1.Util.xpubToEthAddress(xpub);
    }
    catch (e) {
        // ethereum is unavailable
    }
    return {
        xpub: xpub,
        xprv: extendedKey.toBase58(),
        ethAddress: ethAddress,
    };
};
// used by deriveLocal
const apiResponse = function (status, result, message) {
    const err = new Error(message);
    err.status = status;
    err.result = result;
    return err;
};
//
// deriveLocal
// Locally derives a keychain from a top level BIP32 string, given a path.
//
Keychains.prototype.deriveLocal = function (params) {
    params = params || {};
    sdk_core_1.common.validateParams(params, ['path'], ['xprv', 'xpub']);
    if (!params.xprv && !params.xpub) {
        throw new Error('must provide an xpub or xprv for derivation.');
    }
    if (params.xprv && params.xpub) {
        throw new Error('cannot provide both xpub and xprv');
    }
    let hdNode;
    try {
        hdNode = utxo_lib_1.bip32.fromBase58(params.xprv || params.xpub);
    }
    catch (e) {
        throw apiResponse(400, {}, 'Unable to parse the xprv or xpub');
    }
    let derivedNode;
    try {
        derivedNode = hdNode.derivePath((0, sdk_core_1.sanitizeLegacyPath)(params.path));
    }
    catch (e) {
        throw apiResponse(400, {}, 'Unable to derive HD key from path');
    }
    const xpub = derivedNode.neutered().toBase58();
    let ethAddress;
    try {
        ethAddress = sdk_core_1.Util.xpubToEthAddress(xpub);
    }
    catch (e) {
        // ethereum is unavailable
    }
    return {
        path: params.path,
        xpub: xpub,
        xprv: params.xprv && derivedNode.toBase58(),
        ethAddress: ethAddress,
    };
};
//
// list
// List the user's keychains
//
Keychains.prototype.list = function (params, callback) {
    params = params || {};
    sdk_core_1.common.validateParams(params, [], [], callback);
    return Bluebird.resolve(this.bitgo.get(this.bitgo.url('/keychain')).result('keychains'))
        .then(function (keychains) {
        keychains.map(function (keychain) {
            if (keychain.xpub &&
                keychain.ethAddress &&
                sdk_core_1.Util.xpubToEthAddress &&
                keychain.ethAddress !== sdk_core_1.Util.xpubToEthAddress(keychain.xpub)) {
                throw new Error('ethAddress and xpub do not match');
            }
        });
        return keychains;
    })
        .nodeify(callback);
};
/**
 * iterates through all keys associated with the user, decrypts them with the old password and encrypts them with the
 * new password
 * @param params.oldPassword {String} - The old password used for encrypting the key
 * @param params.newPassword {String} - The new password to be used for encrypting the key
 * @param callback
 * @returns result.keychains {Object} - e.g.:
 *  {
 *    xpub1: encryptedPrv1,
 *    xpub2: encryptedPrv2,
 *    ...
 *  }
 *  @returns result.version {Number}
 */
Keychains.prototype.updatePassword = function (params, callback) {
    return co(function* coUpdatePassword() {
        sdk_core_1.common.validateParams(params, ['oldPassword', 'newPassword'], [], callback);
        // @ts-expect-error - no implicit this
        const encrypted = yield this.bitgo.post(this.bitgo.url('/user/encrypted')).result();
        const newKeychains = {};
        // @ts-expect-error - no implicit this
        const self = this;
        _.forOwn(encrypted.keychains, function keychainsForOwn(oldEncryptedXprv, xpub) {
            try {
                const decryptedPrv = self.bitgo.decrypt({ input: oldEncryptedXprv, password: params.oldPassword });
                const newEncryptedPrv = self.bitgo.encrypt({ input: decryptedPrv, password: params.newPassword });
                newKeychains[xpub] = newEncryptedPrv;
            }
            catch (e) {
                // decrypting the keychain with the old password didn't work so we just keep it the way it is
                newKeychains[xpub] = oldEncryptedXprv;
            }
        });
        return { keychains: newKeychains, version: encrypted.version };
    })
        .call(this)
        .asCallback(callback);
};
//
// add
// Add a new keychain
//
Keychains.prototype.add = function (params, callback) {
    params = params || {};
    sdk_core_1.common.validateParams(params, ['xpub'], ['encryptedXprv', 'type', 'isLedger'], callback);
    return Bluebird.resolve(this.bitgo
        .post(this.bitgo.url('/keychain'))
        .send({
        xpub: params.xpub,
        encryptedXprv: params.encryptedXprv,
        type: params.type,
        originalPasscodeEncryptionCode: params.originalPasscodeEncryptionCode,
        isLedger: params.isLedger,
    })
        .result())
        .then(function (keychain) {
        if (keychain.xpub &&
            keychain.ethAddress &&
            sdk_core_1.Util.xpubToEthAddress &&
            keychain.ethAddress !== sdk_core_1.Util.xpubToEthAddress(keychain.xpub)) {
            throw new Error('ethAddress and xpub do not match');
        }
        return keychain;
    })
        .nodeify(callback);
};
//
// createBitGo
// Add a new BitGo server keychain
//
Keychains.prototype.createBitGo = function (params, callback) {
    params = params || {};
    sdk_core_1.common.validateParams(params, [], [], callback);
    return Bluebird.resolve(this.bitgo.post(this.bitgo.url('/keychain/bitgo')).send(params).result())
        .then(function (keychain) {
        if (keychain.xpub &&
            keychain.ethAddress &&
            sdk_core_1.Util.xpubToEthAddress &&
            keychain.ethAddress !== sdk_core_1.Util.xpubToEthAddress(keychain.xpub)) {
            throw new Error('ethAddress and xpub do not match');
        }
        return keychain;
    })
        .nodeify(callback);
};
//
// createBackup
// Create a new backup keychain through bitgo - often used for creating a keychain on a KRS
//
Keychains.prototype.createBackup = function (params, callback) {
    params = params || {};
    sdk_core_1.common.validateParams(params, ['provider'], [], callback);
    return Bluebird.resolve(this.bitgo.post(this.bitgo.url('/keychain/backup')).send(params).result())
        .then(function (keychain) {
        // not all keychains have an xpub
        if (keychain.xpub &&
            keychain.ethAddress &&
            sdk_core_1.Util.xpubToEthAddress &&
            keychain.ethAddress !== sdk_core_1.Util.xpubToEthAddress(keychain.xpub)) {
            throw new Error('ethAddress and xpub do not match');
        }
        return keychain;
    })
        .nodeify(callback);
};
//
// get
// Fetch an existing keychain
// Parameters include:
//   xpub:  the xpub of the key to lookup (required)
//
Keychains.prototype.get = function (params, callback) {
    params = params || {};
    sdk_core_1.common.validateParams(params, [], ['xpub', 'ethAddress'], callback);
    if (!params.xpub && !params.ethAddress) {
        throw new Error('xpub or ethAddress must be defined');
    }
    const id = params.xpub || params.ethAddress;
    return Bluebird.resolve(this.bitgo
        .post(this.bitgo.url('/keychain/' + encodeURIComponent(id)))
        .send({})
        .result())
        .then(function (keychain) {
        if (keychain.xpub &&
            keychain.ethAddress &&
            sdk_core_1.Util.xpubToEthAddress &&
            keychain.ethAddress !== sdk_core_1.Util.xpubToEthAddress(keychain.xpub)) {
            throw new Error('ethAddress and xpub do not match');
        }
        return keychain;
    })
        .nodeify(callback);
};
//
// update
// Update an existing keychain
// Parameters include:
//   xpub:  the xpub of the key to lookup (required)
//
Keychains.prototype.update = function (params, callback) {
    params = params || {};
    sdk_core_1.common.validateParams(params, ['xpub'], ['encryptedXprv'], callback);
    return Bluebird.resolve(this.bitgo
        .put(this.bitgo.url('/keychain/' + params.xpub))
        .send({
        encryptedXprv: params.encryptedXprv,
    })
        .result())
        .then(function (keychain) {
        if (keychain.xpub &&
            keychain.ethAddress &&
            sdk_core_1.Util.xpubToEthAddress &&
            keychain.ethAddress !== sdk_core_1.Util.xpubToEthAddress(keychain.xpub)) {
            throw new Error('ethAddress and xpub do not match');
        }
        return keychain;
    })
        .nodeify(callback);
};
module.exports = Keychains;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5Y2hhaW5zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3YxL2tleWNoYWlucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7O0FBRUg7R0FDRztBQUNILEVBQUU7QUFDRixtQkFBbUI7QUFDbkIsdUNBQXVDO0FBQ3ZDLEVBQUU7QUFDRixvREFBb0Q7QUFDcEQsRUFBRTtBQUVGLDhDQUF3QztBQUN4QyxtQ0FBcUM7QUFDckMsOENBQW1FO0FBQ25FLE1BQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM1QixxQ0FBcUM7QUFDckMsTUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQUU5QixFQUFFO0FBQ0YsY0FBYztBQUNkLEVBQUU7QUFDRixNQUFNLFNBQVMsR0FBRyxVQUFVLEtBQUs7SUFDL0Isc0NBQXNDO0lBQ3RDLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3JCLENBQUMsQ0FBQztBQUVGLEVBQUU7QUFDRixVQUFVO0FBQ1YsZ0VBQWdFO0FBQ2hFLEVBQUU7QUFDRixTQUFTLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRyxVQUFVLE1BQU07SUFDNUMsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFDdEIsaUJBQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUV0QyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUN0RCxNQUFNLElBQUksS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7S0FDbkQ7SUFFRCxJQUFJO1FBQ0YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFO1lBQ3BCLGdCQUFLLENBQUMsVUFBVSxDQUFD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WyIvKipcbiAqIEBoaWRkZW5cbiAqL1xuXG4vKipcbiAqL1xuLy9cbi8vIEtleWNoYWlucyBPYmplY3Rcbi8vIEJpdEdvIGFjY2Vzc29yIHRvIGEgdXNlcidzIGtleWNoYWluLlxuLy9cbi8vIENvcHlyaWdodCAyMDE0LCBCaXRHbywgSW5jLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG5cbmltcG9ydCB7IGJpcDMyIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IGNvbW1vbiwgVXRpbCwgc2FuaXRpemVMZWdhY3lQYXRoIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuXG4vL1xuLy8gQ29uc3RydWN0b3Jcbi8vXG5jb25zdCBLZXljaGFpbnMgPSBmdW5jdGlvbiAoYml0Z28pIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIG5vIGltcGxpY2l0IHRoaXNcbiAgdGhpcy5iaXRnbyA9IGJpdGdvO1xufTtcblxuLy9cbi8vIGlzVmFsaWRcbi8vIFRlc3RzIGEgeHB1YiBvciB4cHJ2IHN0cmluZyB0byBzZWUgaWYgaXQgaXMgYSB2YWxpZCBrZXljaGFpbi5cbi8vXG5LZXljaGFpbnMucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdKTtcblxuICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmtleSkgJiYgIV8uaXNPYmplY3QocGFyYW1zLmtleSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleSBtdXN0IGJlIGEgc3RyaW5nIG9yIG9iamVjdCcpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoIXBhcmFtcy5rZXkucGF0aCkge1xuICAgICAgYmlwMzIuZnJvbUJhc2U1OChwYXJhbXMua2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmlwMzIuZnJvbUJhc2U1OChwYXJhbXMua2V5LnhwdWIpLmRlcml2ZVBhdGgoc2FuaXRpemVMZWdhY3lQYXRoKHBhcmFtcy5rZXkucGF0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy9cbi8vIGNyZWF0ZVxuLy8gQ3JlYXRlIGEgbmV3IGtleWNoYWluIGxvY2FsbHkuXG4vLyBEb2VzIG5vdCBzZW5kIHRoZSBrZXljaGFpbiB0byBiaXRnbywgb25seSBjcmVhdGVzIGxvY2FsbHkuXG4vLyBJZiB8c2VlZHwgaXMgcHJvdmlkZWQsIHVzZWQgdG8gc2VlZCB0aGUga2V5Y2hhaW4uICBPdGhlcndpc2UsXG4vLyBhIHJhbmRvbSBrZXljaGFpbiBpcyBjcmVhdGVkLlxuLy9cbktleWNoYWlucy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSk7XG5cbiAgbGV0IHNlZWQ7XG4gIGlmICghcGFyYW1zLnNlZWQpIHtcbiAgICAvLyBBbiBleHRlbmRlZCBwcml2YXRlIGtleSBoYXMgYm90aCBhIG5vcm1hbCAyNTYgYml0IHByaXZhdGUga2V5IGFuZCBhIDI1NlxuICAgIC8vIGJpdCBjaGFpbiBjb2RlLCBib3RoIG9mIHdoaWNoIG11c3QgYmUgcmFuZG9tLiA1MTIgYml0cyBpcyB0aGVyZWZvcmUgdGhlXG4gICAgLy8gbWF4aW11bSBlbnRyb3B5IGFuZCBnaXZlcyB1cyBtYXhpbXVtIHNlY3VyaXR5IGFnYWluc3QgY3JhY2tpbmcuXG4gICAgc2VlZCA9IHJhbmRvbUJ5dGVzKDUxMiAvIDgpO1xuICB9IGVsc2Uge1xuICAgIHNlZWQgPSBwYXJhbXMuc2VlZDtcbiAgfVxuXG4gIGNvbnN0IGV4dGVuZGVkS2V5ID0gYmlwMzIuZnJvbVNlZWQoc2VlZCk7XG4gIGNvbnN0IHhwdWIgPSBleHRlbmRlZEtleS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCk7XG5cbiAgbGV0IGV0aEFkZHJlc3M7XG4gIHRyeSB7XG4gICAgZXRoQWRkcmVzcyA9IFV0aWwueHB1YlRvRXRoQWRkcmVzcyh4cHViKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGV0aGVyZXVtIGlzIHVuYXZhaWxhYmxlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHhwdWI6IHhwdWIsXG4gICAgeHBydjogZXh0ZW5kZWRLZXkudG9CYXNlNTgoKSxcbiAgICBldGhBZGRyZXNzOiBldGhBZGRyZXNzLFxuICB9O1xufTtcblxuLy8gdXNlZCBieSBkZXJpdmVMb2NhbFxuY29uc3QgYXBpUmVzcG9uc2UgPSBmdW5jdGlvbiAoc3RhdHVzLCByZXN1bHQsIG1lc3NhZ2UpIHtcbiAgY29uc3QgZXJyOiBhbnkgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVyci5zdGF0dXMgPSBzdGF0dXM7XG4gIGVyci5yZXN1bHQgPSByZXN1bHQ7XG4gIHJldHVybiBlcnI7XG59O1xuXG4vL1xuLy8gZGVyaXZlTG9jYWxcbi8vIExvY2FsbHkgZGVyaXZlcyBhIGtleWNoYWluIGZyb20gYSB0b3AgbGV2ZWwgQklQMzIgc3RyaW5nLCBnaXZlbiBhIHBhdGguXG4vL1xuS2V5Y2hhaW5zLnByb3RvdHlwZS5kZXJpdmVMb2NhbCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3BhdGgnXSwgWyd4cHJ2JywgJ3hwdWInXSk7XG5cbiAgaWYgKCFwYXJhbXMueHBydiAmJiAhcGFyYW1zLnhwdWIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgcHJvdmlkZSBhbiB4cHViIG9yIHhwcnYgZm9yIGRlcml2YXRpb24uJyk7XG4gIH1cbiAgaWYgKHBhcmFtcy54cHJ2ICYmIHBhcmFtcy54cHViKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcHJvdmlkZSBib3RoIHhwdWIgYW5kIHhwcnYnKTtcbiAgfVxuXG4gIGxldCBoZE5vZGU7XG4gIHRyeSB7XG4gICAgaGROb2RlID0gYmlwMzIuZnJvbUJhc2U1OChwYXJhbXMueHBydiB8fCBwYXJhbXMueHB1Yik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBhcGlSZXNwb25zZSg0MDAsIHt9LCAnVW5hYmxlIHRvIHBhcnNlIHRoZSB4cHJ2IG9yIHhwdWInKTtcbiAgfVxuXG4gIGxldCBkZXJpdmVkTm9kZTtcbiAgdHJ5IHtcbiAgICBkZXJpdmVkTm9kZSA9IGhkTm9kZS5kZXJpdmVQYXRoKHNhbml0aXplTGVnYWN5UGF0aChwYXJhbXMucGF0aCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgYXBpUmVzcG9uc2UoNDAwLCB7fSwgJ1VuYWJsZSB0byBkZXJpdmUgSEQga2V5IGZyb20gcGF0aCcpO1xuICB9XG5cbiAgY29uc3QgeHB1YiA9IGRlcml2ZWROb2RlLm5ldXRlcmVkKCkudG9CYXNlNTgoKTtcblxuICBsZXQgZXRoQWRkcmVzcztcbiAgdHJ5IHtcbiAgICBldGhBZGRyZXNzID0gVXRpbC54cHViVG9FdGhBZGRyZXNzKHhwdWIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZXRoZXJldW0gaXMgdW5hdmFpbGFibGVcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aDogcGFyYW1zLnBhdGgsXG4gICAgeHB1YjogeHB1YixcbiAgICB4cHJ2OiBwYXJhbXMueHBydiAmJiBkZXJpdmVkTm9kZS50b0Jhc2U1OCgpLFxuICAgIGV0aEFkZHJlc3M6IGV0aEFkZHJlc3MsXG4gIH07XG59O1xuXG4vL1xuLy8gbGlzdFxuLy8gTGlzdCB0aGUgdXNlcidzIGtleWNoYWluc1xuLy9cbktleWNoYWlucy5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG5cbiAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUodGhpcy5iaXRnby5nZXQodGhpcy5iaXRnby51cmwoJy9rZXljaGFpbicpKS5yZXN1bHQoJ2tleWNoYWlucycpKVxuICAgIC50aGVuKGZ1bmN0aW9uIChrZXljaGFpbnMpIHtcbiAgICAgIGtleWNoYWlucy5tYXAoZnVuY3Rpb24gKGtleWNoYWluKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXljaGFpbi54cHViICYmXG4gICAgICAgICAga2V5Y2hhaW4uZXRoQWRkcmVzcyAmJlxuICAgICAgICAgIFV0aWwueHB1YlRvRXRoQWRkcmVzcyAmJlxuICAgICAgICAgIGtleWNoYWluLmV0aEFkZHJlc3MgIT09IFV0aWwueHB1YlRvRXRoQWRkcmVzcyhrZXljaGFpbi54cHViKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V0aEFkZHJlc3MgYW5kIHhwdWIgZG8gbm90IG1hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGtleWNoYWlucztcbiAgICB9KVxuICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogaXRlcmF0ZXMgdGhyb3VnaCBhbGwga2V5cyBhc3NvY2lhdGVkIHdpdGggdGhlIHVzZXIsIGRlY3J5cHRzIHRoZW0gd2l0aCB0aGUgb2xkIHBhc3N3b3JkIGFuZCBlbmNyeXB0cyB0aGVtIHdpdGggdGhlXG4gKiBuZXcgcGFzc3dvcmRcbiAqIEBwYXJhbSBwYXJhbXMub2xkUGFzc3dvcmQge1N0cmluZ30gLSBUaGUgb2xkIHBhc3N3b3JkIHVzZWQgZm9yIGVuY3J5cHRpbmcgdGhlIGtleVxuICogQHBhcmFtIHBhcmFtcy5uZXdQYXNzd29yZCB7U3RyaW5nfSAtIFRoZSBuZXcgcGFzc3dvcmQgdG8gYmUgdXNlZCBmb3IgZW5jcnlwdGluZyB0aGUga2V5XG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHJlc3VsdC5rZXljaGFpbnMge09iamVjdH0gLSBlLmcuOlxuICogIHtcbiAqICAgIHhwdWIxOiBlbmNyeXB0ZWRQcnYxLFxuICogICAgeHB1YjI6IGVuY3J5cHRlZFBydjIsXG4gKiAgICAuLi5cbiAqICB9XG4gKiAgQHJldHVybnMgcmVzdWx0LnZlcnNpb24ge051bWJlcn1cbiAqL1xuS2V5Y2hhaW5zLnByb3RvdHlwZS51cGRhdGVQYXNzd29yZCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBjbyhmdW5jdGlvbiogY29VcGRhdGVQYXNzd29yZCgpIHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ29sZFBhc3N3b3JkJywgJ25ld1Bhc3N3b3JkJ10sIFtdLCBjYWxsYmFjayk7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIG5vIGltcGxpY2l0IHRoaXNcbiAgICBjb25zdCBlbmNyeXB0ZWQgPSB5aWVsZCB0aGlzLmJpdGdvLnBvc3QodGhpcy5iaXRnby51cmwoJy91c2VyL2VuY3J5cHRlZCcpKS5yZXN1bHQoKTtcbiAgICBjb25zdCBuZXdLZXljaGFpbnMgPSB7fTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gbm8gaW1wbGljaXQgdGhpc1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIF8uZm9yT3duKChlbmNyeXB0ZWQgYXMgYW55KS5rZXljaGFpbnMsIGZ1bmN0aW9uIGtleWNoYWluc0Zvck93bihvbGRFbmNyeXB0ZWRYcHJ2LCB4cHViKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNyeXB0ZWRQcnYgPSBzZWxmLmJpdGdvLmRlY3J5cHQoeyBpbnB1dDogb2xkRW5jcnlwdGVkWHBydiwgcGFzc3dvcmQ6IHBhcmFtcy5vbGRQYXNzd29yZCB9KTtcbiAgICAgICAgY29uc3QgbmV3RW5jcnlwdGVkUHJ2ID0gc2VsZi5iaXRnby5lbmNyeXB0KHsgaW5wdXQ6IGRlY3J5cHRlZFBydiwgcGFzc3dvcmQ6IHBhcmFtcy5uZXdQYXNzd29yZCB9KTtcbiAgICAgICAgbmV3S2V5Y2hhaW5zW3hwdWJdID0gbmV3RW5jcnlwdGVkUHJ2O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBkZWNyeXB0aW5nIHRoZSBrZXljaGFpbiB3aXRoIHRoZSBvbGQgcGFzc3dvcmQgZGlkbid0IHdvcmsgc28gd2UganVzdCBrZWVwIGl0IHRoZSB3YXkgaXQgaXNcbiAgICAgICAgbmV3S2V5Y2hhaW5zW3hwdWJdID0gb2xkRW5jcnlwdGVkWHBydjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4geyBrZXljaGFpbnM6IG5ld0tleWNoYWlucywgdmVyc2lvbjogKGVuY3J5cHRlZCBhcyBhbnkpLnZlcnNpb24gfTtcbiAgfSlcbiAgICAuY2FsbCh0aGlzKVxuICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBhZGRcbi8vIEFkZCBhIG5ldyBrZXljaGFpblxuLy9cbktleWNoYWlucy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3hwdWInXSwgWydlbmNyeXB0ZWRYcHJ2JywgJ3R5cGUnLCAnaXNMZWRnZXInXSwgY2FsbGJhY2spO1xuXG4gIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKFxuICAgIHRoaXMuYml0Z29cbiAgICAgIC5wb3N0KHRoaXMuYml0Z28udXJsKCcva2V5Y2hhaW4nKSlcbiAgICAgIC5zZW5kKHtcbiAgICAgICAgeHB1YjogcGFyYW1zLnhwdWIsXG4gICAgICAgIGVuY3J5cHRlZFhwcnY6IHBhcmFtcy5lbmNyeXB0ZWRYcHJ2LFxuICAgICAgICB0eXBlOiBwYXJhbXMudHlwZSxcbiAgICAgICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlOiBwYXJhbXMub3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgICAgICBpc0xlZGdlcjogcGFyYW1zLmlzTGVkZ2VyLFxuICAgICAgfSlcbiAgICAgIC5yZXN1bHQoKVxuICApXG4gICAgLnRoZW4oZnVuY3Rpb24gKGtleWNoYWluKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGtleWNoYWluLnhwdWIgJiZcbiAgICAgICAga2V5Y2hhaW4uZXRoQWRkcmVzcyAmJlxuICAgICAgICBVdGlsLnhwdWJUb0V0aEFkZHJlc3MgJiZcbiAgICAgICAga2V5Y2hhaW4uZXRoQWRkcmVzcyAhPT0gVXRpbC54cHViVG9FdGhBZGRyZXNzKGtleWNoYWluLnhwdWIpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdldGhBZGRyZXNzIGFuZCB4cHViIGRvIG5vdCBtYXRjaCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleWNoYWluO1xuICAgIH0pXG4gICAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIGNyZWF0ZUJpdEdvXG4vLyBBZGQgYSBuZXcgQml0R28gc2VydmVyIGtleWNoYWluXG4vL1xuS2V5Y2hhaW5zLnByb3RvdHlwZS5jcmVhdGVCaXRHbyA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG5cbiAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUodGhpcy5iaXRnby5wb3N0KHRoaXMuYml0Z28udXJsKCcva2V5Y2hhaW4vYml0Z28nKSkuc2VuZChwYXJhbXMpLnJlc3VsdCgpKVxuICAgIC50aGVuKGZ1bmN0aW9uIChrZXljaGFpbikge1xuICAgICAgaWYgKFxuICAgICAgICBrZXljaGFpbi54cHViICYmXG4gICAgICAgIGtleWNoYWluLmV0aEFkZHJlc3MgJiZcbiAgICAgICAgVXRpbC54cHViVG9FdGhBZGRyZXNzICYmXG4gICAgICAgIGtleWNoYWluLmV0aEFkZHJlc3MgIT09IFV0aWwueHB1YlRvRXRoQWRkcmVzcyhrZXljaGFpbi54cHViKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXRoQWRkcmVzcyBhbmQgeHB1YiBkbyBub3QgbWF0Y2gnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXljaGFpbjtcbiAgICB9KVxuICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBjcmVhdGVCYWNrdXBcbi8vIENyZWF0ZSBhIG5ldyBiYWNrdXAga2V5Y2hhaW4gdGhyb3VnaCBiaXRnbyAtIG9mdGVuIHVzZWQgZm9yIGNyZWF0aW5nIGEga2V5Y2hhaW4gb24gYSBLUlNcbi8vXG5LZXljaGFpbnMucHJvdG90eXBlLmNyZWF0ZUJhY2t1cCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydwcm92aWRlciddLCBbXSwgY2FsbGJhY2spO1xuXG4gIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHRoaXMuYml0Z28ucG9zdCh0aGlzLmJpdGdvLnVybCgnL2tleWNoYWluL2JhY2t1cCcpKS5zZW5kKHBhcmFtcykucmVzdWx0KCkpXG4gICAgLnRoZW4oZnVuY3Rpb24gKGtleWNoYWluKSB7XG4gICAgICAvLyBub3QgYWxsIGtleWNoYWlucyBoYXZlIGFuIHhwdWJcbiAgICAgIGlmIChcbiAgICAgICAga2V5Y2hhaW4ueHB1YiAmJlxuICAgICAgICBrZXljaGFpbi5ldGhBZGRyZXNzICYmXG4gICAgICAgIFV0aWwueHB1YlRvRXRoQWRkcmVzcyAmJlxuICAgICAgICBrZXljaGFpbi5ldGhBZGRyZXNzICE9PSBVdGlsLnhwdWJUb0V0aEFkZHJlc3Moa2V5Y2hhaW4ueHB1YilcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V0aEFkZHJlc3MgYW5kIHhwdWIgZG8gbm90IG1hdGNoJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5Y2hhaW47XG4gICAgfSlcbiAgICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gZ2V0XG4vLyBGZXRjaCBhbiBleGlzdGluZyBrZXljaGFpblxuLy8gUGFyYW1ldGVycyBpbmNsdWRlOlxuLy8gICB4cHViOiAgdGhlIHhwdWIgb2YgdGhlIGtleSB0byBsb29rdXAgKHJlcXVpcmVkKVxuLy9cbktleWNoYWlucy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWyd4cHViJywgJ2V0aEFkZHJlc3MnXSwgY2FsbGJhY2spO1xuXG4gIGlmICghcGFyYW1zLnhwdWIgJiYgIXBhcmFtcy5ldGhBZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd4cHViIG9yIGV0aEFkZHJlc3MgbXVzdCBiZSBkZWZpbmVkJyk7XG4gIH1cblxuICBjb25zdCBpZCA9IHBhcmFtcy54cHViIHx8IHBhcmFtcy5ldGhBZGRyZXNzO1xuICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZShcbiAgICB0aGlzLmJpdGdvXG4gICAgICAucG9zdCh0aGlzLmJpdGdvLnVybCgnL2tleWNoYWluLycgKyBlbmNvZGVVUklDb21wb25lbnQoaWQpKSlcbiAgICAgIC5zZW5kKHt9KVxuICAgICAgLnJlc3VsdCgpXG4gIClcbiAgICAudGhlbihmdW5jdGlvbiAoa2V5Y2hhaW4pIHtcbiAgICAgIGlmIChcbiAgICAgICAga2V5Y2hhaW4ueHB1YiAmJlxuICAgICAgICBrZXljaGFpbi5ldGhBZGRyZXNzICYmXG4gICAgICAgIFV0aWwueHB1YlRvRXRoQWRkcmVzcyAmJlxuICAgICAgICBrZXljaGFpbi5ldGhBZGRyZXNzICE9PSBVdGlsLnhwdWJUb0V0aEFkZHJlc3Moa2V5Y2hhaW4ueHB1YilcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V0aEFkZHJlc3MgYW5kIHhwdWIgZG8gbm90IG1hdGNoJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5Y2hhaW47XG4gICAgfSlcbiAgICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gdXBkYXRlXG4vLyBVcGRhdGUgYW4gZXhpc3Rpbmcga2V5Y2hhaW5cbi8vIFBhcmFtZXRlcnMgaW5jbHVkZTpcbi8vICAgeHB1YjogIHRoZSB4cHViIG9mIHRoZSBrZXkgdG8gbG9va3VwIChyZXF1aXJlZClcbi8vXG5LZXljaGFpbnMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd4cHViJ10sIFsnZW5jcnlwdGVkWHBydiddLCBjYWxsYmFjayk7XG5cbiAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUoXG4gICAgdGhpcy5iaXRnb1xuICAgICAgLnB1dCh0aGlzLmJpdGdvLnVybCgnL2tleWNoYWluLycgKyBwYXJhbXMueHB1YikpXG4gICAgICAuc2VuZCh7XG4gICAgICAgIGVuY3J5cHRlZFhwcnY6IHBhcmFtcy5lbmNyeXB0ZWRYcHJ2LFxuICAgICAgfSlcbiAgICAgIC5yZXN1bHQoKVxuICApXG4gICAgLnRoZW4oZnVuY3Rpb24gKGtleWNoYWluKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGtleWNoYWluLnhwdWIgJiZcbiAgICAgICAga2V5Y2hhaW4uZXRoQWRkcmVzcyAmJlxuICAgICAgICBVdGlsLnhwdWJUb0V0aEFkZHJlc3MgJiZcbiAgICAgICAga2V5Y2hhaW4uZXRoQWRkcmVzcyAhPT0gVXRpbC54cHViVG9FdGhBZGRyZXNzKGtleWNoYWluLnhwdWIpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdldGhBZGRyZXNzIGFuZCB4cHViIGRvIG5vdCBtYXRjaCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleWNoYWluO1xuICAgIH0pXG4gICAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXljaGFpbnM7XG4iXX0=