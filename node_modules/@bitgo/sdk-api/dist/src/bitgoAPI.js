"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitGoAPI = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const sjcl = require("@bitgo/sjcl");
const utxolib = require("@bitgo/utxo-lib");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const bitcoinMessage = require("bitcoinjs-message");
const browser_or_node_1 = require("browser-or-node");
const crypto_1 = require("crypto");
const debug_1 = require("debug");
const _ = require("lodash");
const secp256k1 = require("secp256k1");
const superagent = require("superagent");
const urlLib = require("url");
const api_1 = require("./api");
const encrypt_1 = require("./encrypt");
const verifyAddress_1 = require("./v1/verifyAddress");
const shamir = require("secrets.js-grempe");
const pjson = require("../package.json");
const debug = (0, debug_1.default)('bitgo:api');
const Blockchain = require('./v1/blockchain');
const Keychains = require('./v1/keychains');
const Wallet = require("./v1/wallet");
const Wallets = require('./v1/wallets');
const Markets = require('./v1/markets');
const PendingApprovals = require('./v1/pendingapprovals');
const TravelRule = require('./v1/travelRule');
const TransactionBuilder = require('./v1/transactionBuilder');
let enableProxyAgent = false;
let proxyAgentModule;
if (!browser_or_node_1.isBrowser && !browser_or_node_1.isWebWorker) {
    debug('enabling proxy-agent');
    enableProxyAgent = true;
    proxyAgentModule = require('proxy-agent');
}
const patchedRequestMethods = ['get', 'post', 'put', 'del', 'patch', 'options'];
class BitGoAPI {
    constructor(params = {}) {
        this._authVersion = 2;
        this._hmacVerification = true;
        this._version = pjson.version;
        this.cookiesPropagationEnabled = false;
        if (!sdk_core_1.common.validateParams(params, [], [
            'accessToken',
            'userAgent',
            'customRootURI',
            'customBitcoinNetwork',
            'serverXpub',
            'stellarFederationServerUrl',
        ]) ||
            (params.useProduction && !_.isBoolean(params.useProduction))) {
            throw new Error('invalid argument');
        }
        // By default, we operate on the test server.
        // Deprecate useProduction in the future
        let env;
        if (params.useProduction) {
            if (params.env && params.env !== 'prod') {
                throw new Error('cannot use useProduction when env=' + params.env);
            }
            env = 'prod';
        }
        else if (params.customRootURI ||
            params.customBitcoinNetwork ||
            params.customSigningAddress ||
            params.serverXpub ||
            process.env.BITGO_CUSTOM_ROOT_URI ||
            process.env.BITGO_CUSTOM_BITCOIN_NETWORK) {
            // for branch deploys, we want to be able to specify custom endpoints while still
            // maintaining the name of specified the environment
            env = params.env === 'branch' ? 'branch' : 'custom';
            if (params.customRootURI) {
                sdk_core_1.common.Environments[env].uri = params.customRootURI;
            }
            if (params.customBitcoinNetwork) {
                sdk_core_1.common.Environments[env].network = params.customBitcoinNetwork;
            }
            if (params.customSigningAddress) {
                sdk_core_1.common.Environments[env].customSigningAddress = params.customSigningAddress;
            }
            if (params.serverXpub) {
                sdk_core_1.common.Environments[env].serverXpub = params.serverXpub;
            }
            if (params.stellarFederationServerUrl) {
                sdk_core_1.common.Environments[env].stellarFederationServerUrl = params.stellarFederationServerUrl;
            }
            if (params.cookiesPropagationEnabled) {
                this.cookiesPropagationEnabled = true;
            }
        }
        else {
            env = params.env || process.env.BITGO_ENV;
        }
        // if this hasn't been set to true already some conditions are not met
        if (params.cookiesPropagationEnabled && !this.cookiesPropagationEnabled) {
            throw new Error('Cookies are only allowed when custom URIs are in use');
        }
        if (params.authVersion !== undefined) {
            this._authVersion = params.authVersion;
        }
        // if this env is an alias, swap it out with the equivalent supported environment
        if (env in sdk_core_1.AliasEnvironments) {
            env = sdk_core_1.AliasEnvironments[env];
        }
        if (env === 'custom' && _.isUndefined(sdk_core_1.common.Environments[env].uri)) {
            throw new Error('must use --customrooturi or set the BITGO_CUSTOM_ROOT_URI environment variable when using the custom environment');
        }
        if (env) {
            if (sdk_core_1.common.Environments[env]) {
                this._baseUrl = sdk_core_1.common.Environments[env].uri;
            }
            else {
                throw new Error('invalid environment ' + env + '. Supported environments: prod, test, dev, latest');
            }
        }
        else {
            env = 'test';
            if (!BitGoAPI._testnetWarningMessage) {
                BitGoAPI._testnetWarningMessage = true;
                console.log('BitGo SDK env not set - defaulting to test at test.bitgo.com.');
            }
            this._baseUrl = sdk_core_1.common.Environments[env].uri;
        }
        this._env = this.env = env;
        const supportedApiTokens = [
            'etherscanApiToken',
            'polygonscanApiToken',
            'arbiscanApiToken',
            'optimisticEtherscanApiToken',
            'zksyncExplorerApiToken',
        ];
        Object.keys(params).forEach((key) => {
            if (supportedApiTokens.includes(key)) {
                sdk_core_1.common.Environments[env][key] = params[key];
            }
        });
        sdk_core_1.common.setNetwork(sdk_core_1.common.Environments[env].network);
        this._baseApiUrl = this._baseUrl + '/api/v1';
        this._baseApiUrlV2 = this._baseUrl + '/api/v2';
        this._token = params.accessToken;
        this._userAgent = params.userAgent || 'BitGoJS-api/' + this.version();
        this._reqId = undefined;
        this._refreshToken = params.refreshToken;
        this._clientId = params.clientId;
        this._clientSecret = params.clientSecret;
        this._keychains = null;
        this._wallets = null;
        // whether to perform extra client-side validation for some things, such as
        // address validation or signature validation. defaults to true, but can be
        // turned off by setting to false. can also be overridden individually in the
        // functions that use it.
        this._validate = params.validate === undefined ? true : params.validate;
        if (!params.hmacVerification && params.hmacVerification !== undefined) {
            if ((env == 'prod' || env == 'adminProd') && sdk_core_1.common.Environments[env].hmacVerificationEnforced) {
                throw new Error(`Cannot disable request HMAC verification in environment ${this.getEnv()}`);
            }
            debug('HMAC verification explicitly disabled by constructor option');
            this._hmacVerification = params.hmacVerification;
        }
        if (!params.proxy && process.env.BITGO_USE_PROXY) {
            params.proxy = process.env.BITGO_USE_PROXY;
        }
        if (process.browser && params.proxy) {
            throw new Error('cannot use https proxy params while in browser');
        }
        this._proxy = params.proxy;
        // capture outer stack so we have useful debug information if fetch constants fails
        const e = new Error();
        // Kick off first load of constants
        this.fetchConstants().catch((err) => {
            if (err) {
                // make sure an error does not terminate the entire script
                console.error('failed to fetch initial client constants from BitGo');
                debug(e.stack);
            }
        });
    }
    /**
     * Get a superagent request for specified http method and URL configured to the SDK configuration
     * @param method - http method for the new request
     * @param url - URL for the new request
     */
    getAgentRequest(method, url) {
        let req = superagent[method](url);
        if (this.cookiesPropagationEnabled) {
            req = req.withCredentials();
        }
        return req;
    }
    /**
     * Create a basecoin object
     * @param name
     */
    coin(name) {
        return sdk_core_1.GlobalCoinFactory.getInstance(this, name);
    }
    /**
     * Return the current BitGo environment
     */
    getEnv() {
        return this._env;
    }
    /**
     * Return the current auth version used for requests to the BitGo server
     */
    getAuthVersion() {
        return this._authVersion;
    }
    /**
     * This is a patching function which can apply our authorization
     * headers to any outbound request.
     * @param method
     */
    requestPatch(method, url) {
        const req = this.getAgentRequest(method, url);
        if (this._proxy && enableProxyAgent) {
            debug('proxying request through %s', this._proxy);
            const proxyUrl = this._proxy;
            const agent = new proxyAgentModule.ProxyAgent({
                getProxyForUrl: () => proxyUrl,
            });
            if (agent) {
                req.agent(agent);
            }
        }
        const originalThen = req.then.bind(req);
        req.then = (onfulfilled, onrejected) => {
            var _a, _b;
            // intercept a request before it's submitted to the server for v2 authentication (based on token)
            if (this._version) {
                // TODO - decide where to get version
                req.set('BitGo-SDK-Version', this._version);
            }
            if (!_.isUndefined(this._reqId)) {
                req.set('Request-ID', this._reqId.toString());
                // increment after setting the header so the sequence numbers start at 0
                this._reqId.inc();
                // request ids must be set before each request instead of being kept
                // inside the bitgo object. This is to prevent reentrancy issues where
                // multiple simultaneous requests could cause incorrect reqIds to be used
                delete this._reqId;
            }
            // prevent IE from caching requests
            req.set('If-Modified-Since', 'Mon, 26 Jul 1997 05:00:00 GMT');
            if (!process.browser && this._userAgent) {
                // If not in the browser, set the User-Agent. Browsers don't allow
                // setting of User-Agent, so we must disable this when run in the
                // browser (browserify sets process.browser).
                req.set('User-Agent', this._userAgent);
            }
            // Set the request timeout to just above 5 minutes by default
            req.timeout(process.env.BITGO_TIMEOUT * 1000 || 305 * 1000);
            // if there is no token, and we're not logged in, the request cannot be v2 authenticated
            req.isV2Authenticated = true;
            req.authenticationToken = this._token;
            // some of the older tokens appear to be only 40 characters long
            if ((this._token && this._token.length !== 67 && this._token.indexOf('v2x') !== 0) || req.forceV1Auth) {
                // use the old method
                req.isV2Authenticated = false;
                req.set('Authorization', 'Bearer ' + this._token);
                debug('sending v1 %s request to %s with token %s', method, url, (_a = this._token) === null || _a === void 0 ? void 0 : _a.substr(0, 8));
                return originalThen(onfulfilled).catch(onrejected);
            }
            req.set('BitGo-Auth-Version', this._authVersion === 3 ? '3.0' : '2.0');
            if (this._token) {
                const data = (0, api_1.serializeRequestData)(req);
                (0, api_1.setRequestQueryString)(req);
                const requestProperties = this.calculateRequestHeaders({
                    url: req.url,
                    token: this._token,
                    method,
                    text: data || '',
                });
                req.set('Auth-Timestamp', requestProperties.timestamp.toString());
                // we're not sending the actual token, but only its hash
                req.set('Authorization', 'Bearer ' + requestProperties.tokenHash);
                debug('sending v2 %s request to %s with token %s', method, url, (_b = this._token) === null || _b === void 0 ? void 0 : _b.substr(0, 8));
                // set the HMAC
                req.set('HMAC', requestProperties.hmac);
            }
            /**
             * Verify the response before calling the original onfulfilled handler,
             * and make sure onrejected is called if a verification error is encountered
             */
            const newOnFulfilled = onfulfilled
                ? (response) => {
                    // HMAC verification is only allowed to be skipped in certain environments.
                    // This is checked in the constructor, but checking it again at request time
                    // will help prevent against tampering of this property after the object is created
                    if (!this._hmacVerification && !sdk_core_1.common.Environments[this.getEnv()].hmacVerificationEnforced) {
                        return onfulfilled(response);
                    }
                    const verifiedResponse = (0, api_1.verifyResponse)(this, this._token, method, req, response);
                    return onfulfilled(verifiedResponse);
                }
                : null;
            return originalThen(newOnFulfilled).catch(onrejected);
        };
        return (0, api_1.toBitgoRequest)(req);
    }
    get(url) {
        return this.requestPatch('get', url);
    }
    post(url) {
        return this.requestPatch('post', url);
    }
    put(url) {
        return this.requestPatch('put', url);
    }
    del(url) {
        return this.requestPatch('del', url);
    }
    patch(url) {
        return this.requestPatch('patch', url);
    }
    options(url) {
        return this.requestPatch('options', url);
    }
    /**
     * Calculate the HMAC for the given key and message
     * @param key {String} - the key to use for the HMAC
     * @param message {String} - the actual message to HMAC
     * @returns {*} - the result of the HMAC operation
     */
    calculateHMAC(key, message) {
        return (0, crypto_1.createHmac)('sha256', key).update(message).digest('hex');
    }
    /**
     * Calculate the subject string that is to be HMAC'ed for a HTTP request or response
     * @param urlPath request url, including query params
     * @param text request body text
     * @param timestamp request timestamp from `Date.now()`
     * @param statusCode Only set for HTTP responses, leave blank for requests
     * @param method request method
     * @returns {string}
     */
    calculateHMACSubject({ urlPath, text, timestamp, statusCode, method }) {
        const urlDetails = urlLib.parse(urlPath);
        const queryPath = urlDetails.query && urlDetails.query.length > 0 ? urlDetails.path : urlDetails.pathname;
        if (!_.isUndefined(statusCode) && _.isInteger(statusCode) && _.isFinite(statusCode)) {
            if (this._authVersion === 3) {
                return [method.toUpperCase(), timestamp, queryPath, statusCode, text].join('|');
            }
            return [timestamp, queryPath, statusCode, text].join('|');
        }
        if (this._authVersion === 3) {
            return [method.toUpperCase(), timestamp, '3.0', queryPath, text].join('|');
        }
        return [timestamp, queryPath, text].join('|');
    }
    /**
     * Calculate the HMAC for an HTTP request
     */
    calculateRequestHMAC({ url: urlPath, text, timestamp, token, method }) {
        const signatureSubject = this.calculateHMACSubject({ urlPath, text, timestamp, method });
        // calculate the HMAC
        return this.calculateHMAC(token, signatureSubject);
    }
    /**
     * Calculate request headers with HMAC
     */
    calculateRequestHeaders({ url, text, token, method }) {
        const timestamp = Date.now();
        const hmac = this.calculateRequestHMAC({ url, text, timestamp, token, method });
        // calculate the SHA256 hash of the token
        const hashDigest = sjcl.hash.sha256.hash(token);
        const tokenHash = sjcl.codec.hex.fromBits(hashDigest);
        return {
            hmac,
            timestamp,
            tokenHash,
        };
    }
    /**
     * Verify the HMAC for an HTTP response
     */
    verifyResponse({ url: urlPath, statusCode, text, timestamp, token, hmac, method, }) {
        const signatureSubject = this.calculateHMACSubject({
            urlPath,
            text,
            timestamp,
            statusCode,
            method,
        });
        // calculate the HMAC
        const expectedHmac = this.calculateHMAC(token, signatureSubject);
        // determine if the response is still within the validity window (5 minute window)
        const now = Date.now();
        const isInResponseValidityWindow = timestamp >= now - 1000 * 60 * 5 && timestamp <= now;
        // verify the HMAC and timestamp
        return {
            isValid: expectedHmac === hmac,
            expectedHmac,
            signatureSubject,
            isInResponseValidityWindow,
            verificationTime: now,
        };
    }
    /**
     * Fetch useful constant values from the BitGo server.
     * These values do change infrequently, so they need to be fetched,
     * but are unlikely to change during the lifetime of a BitGo object,
     * so they can safely cached.
     */
    async fetchConstants() {
        var _a, _b;
        const env = this.getEnv();
        if (!BitGoAPI._constants) {
            BitGoAPI._constants = {};
        }
        if (!BitGoAPI._constantsExpire) {
            BitGoAPI._constantsExpire = {};
        }
        if (BitGoAPI._constants[env] && BitGoAPI._constantsExpire[env] && new Date() < BitGoAPI._constantsExpire[env]) {
            return BitGoAPI._constants[env];
        }
        // client constants call cannot be authenticated using the normal HMAC validation
        // scheme, so we need to use a raw superagent instance to do this request.
        // Proxy settings must still be respected however
        const resultPromise = this.getAgentRequest('get', this.url('/client/constants'));
        resultPromise.set('BitGo-SDK-Version', this._version);
        if (this._proxy && enableProxyAgent) {
            const proxyUrl = this._proxy;
            const agent = new proxyAgentModule.ProxyAgent({
                getProxyForUrl: () => proxyUrl,
            });
            if (agent) {
                resultPromise.agent(agent);
            }
        }
        const result = await resultPromise;
        BitGoAPI._constants[env] = result.body.constants;
        if (((_a = result.body) === null || _a === void 0 ? void 0 : _a.ttl) && typeof ((_b = result.body) === null || _b === void 0 ? void 0 : _b.ttl) === 'number') {
            BitGoAPI._constantsExpire[env] = new Date(new Date().getTime() + result.body.ttl * 1000);
        }
        return BitGoAPI._constants[env];
    }
    /**
     * Create a url for calling BitGo platform APIs
     * @param path
     * @param version
     */
    url(path, version = 1) {
        const baseUrl = version === 2 ? this._baseApiUrlV2 : this._baseApiUrl;
        return baseUrl + path;
    }
    /**
     * Create a url for calling BitGo microservice APIs
     */
    microservicesUrl(path) {
        return this._baseUrl + path;
    }
    /**
     * Gets the version of the BitGoJS package
     */
    version() {
        return this._version;
    }
    /**
     * Test connectivity to the server
     * @param params
     */
    ping({ reqId } = {}) {
        if (reqId) {
            this._reqId = reqId;
        }
        return this.get(this.url('/ping')).result();
    }
    /**
     * Set a request tracer to provide request IDs during multi-request workflows
     */
    setRequestTracer(reqTracer) {
        if (reqTracer) {
            this._reqId = reqTracer;
        }
    }
    /**
     * Utility function to encrypt locally.
     */
    encrypt(params) {
        sdk_core_1.common.validateParams(params, ['input', 'password'], []);
        if (!params.password) {
            throw new Error(`cannot encrypt without password`);
        }
        return (0, encrypt_1.encrypt)(params.password, params.input);
    }
    /**
     * Decrypt an encrypted string locally.
     */
    decrypt(params) {
        params = params || {};
        sdk_core_1.common.validateParams(params, ['input', 'password'], []);
        if (!params.password) {
            throw new Error(`cannot decrypt without password`);
        }
        try {
            return (0, encrypt_1.decrypt)(params.password, params.input);
        }
        catch (error) {
            if (error.message.includes("ccm: tag doesn't match")) {
                error.message = 'password error - ' + error.message;
            }
            throw error;
        }
    }
    /**
     * Serialize this BitGo object to a JSON object.
     *
     * Caution: contains sensitive data
     */
    toJSON() {
        return {
            user: this._user,
            token: this._token,
            extensionKey: this._extensionKey ? this._extensionKey.toWIF() : undefined,
            ecdhXprv: this._ecdhXprv,
        };
    }
    /**
     * Get the current user
     */
    user() {
        return this._user;
    }
    /**
     * Deserialize a JSON serialized BitGo object.
     *
     * Overwrites the properties on the current BitGo object with
     * those of the deserialzed object.
     *
     * @param json
     */
    fromJSON(json) {
        this._user = json.user;
        this._token = json.token;
        this._ecdhXprv = json.ecdhXprv;
        if (json.extensionKey) {
            const network = sdk_core_1.common.Environments[this.getEnv()].network;
            this._extensionKey = utxolib.ECPair.fromWIF(json.extensionKey, utxolib.networks[network]);
        }
    }
    /**
     * Process the username, password and otp into an object containing the username and hashed password, ready to
     * send to bitgo for authentication.
     */
    preprocessAuthenticationParams({ username, password, otp, forceSMS, extensible, trust, forReset2FA, }) {
        if (!_.isString(username)) {
            throw new Error('expected string username');
        }
        if (!_.isString(password)) {
            throw new Error('expected string password');
        }
        const lowerName = username.toLowerCase();
        // Calculate the password HMAC so we don't send clear-text passwords
        const hmacPassword = this.calculateHMAC(lowerName, password);
        const authParams = {
            email: lowerName,
            password: hmacPassword,
            forceSMS: !!forceSMS,
        };
        if (otp) {
            authParams.otp = otp;
            if (trust) {
                authParams.trust = 1;
            }
        }
        if (extensible) {
            this._extensionKey = (0, sdk_core_1.makeRandomKey)();
            authParams.extensible = true;
            authParams.extensionAddress = (0, sdk_core_1.getAddressP2PKH)(this._extensionKey);
        }
        if (forReset2FA) {
            authParams.forReset2FA = true;
        }
        return authParams;
    }
    /**
     * Synchronous method for activating an access token.
     */
    authenticateWithAccessToken({ accessToken }) {
        debug('now authenticating with access token %s', accessToken.substring(0, 8));
        this._token = accessToken;
    }
    /**
     * Creates a new ECDH keychain for the user.
     * @param {string} loginPassword - The user's login password.
     * @returns {Promise<any>} - A promise that resolves with the new ECDH keychain data.
     * @throws {Error} - Throws an error if there is an issue creating the keychain.
     */
    async createUserEcdhKeychain(loginPassword) {
        const keyData = this.keychains().create();
        const hdNode = sdk_core_1.bitcoin.HDNode.fromBase58(keyData.xprv);
        /**
         * Add the new ECDH keychain to the user's account.
         * @type {Promise<any>} - A promise that resolves with the new ECDH keychain.
         */
        return await this.keychains().add({
            source: 'ecdh',
            xpub: hdNode.neutered().toBase58(),
            encryptedXprv: this.encrypt({
                password: loginPassword,
                input: hdNode.toBase58(),
            }),
        });
    }
    /**
     * Updates the user's settings with the provided parameters.
     * @param {Object} params - The parameters to update the user's settings with.
     * @returns {Promise<any>}
     * @throws {Error} - Throws an error if there is an issue updating the user's settings.
     */
    async updateUserSettings(params) {
        return this.put(this.url('/user/settings', 2)).send(params).result();
    }
    /**
     * Ensures that the user's ECDH keychain is created for wallet sharing and TSS wallets.
     * If the keychain does not exist, it will be created and the user's settings will be updated.
     * @param {string} loginPassword - The user's login password.
     * @returns {Promise<any>} - A promise that resolves with the user's settings ensuring we have the ecdhKeychain in there.
     * @throws {Error} - Throws an error if there is an issue creating the keychain or updating the user's settings.
     */
    async ensureUserEcdhKeychainIsCreated(loginPassword) {
        /**
         * Get the user's current settings.
         */
        const userSettings = await this.get(this.url('/user/settings')).result();
        /**
         * If the user's ECDH keychain does not exist, create a new keychain and update the user's settings.
         */
        if (!userSettings.settings.ecdhKeychain) {
            const newKeychain = await this.createUserEcdhKeychain(loginPassword);
            await this.updateUserSettings({
                settings: {
                    ecdhKeychain: newKeychain.xpub,
                },
            });
            /**
             * Update the user's settings object with the new ECDH keychain.
             */
            userSettings.settings.ecdhKeychain = newKeychain.xpub;
        }
        /**
         * Return the user's ECDH keychain settings.
         */
        return userSettings.settings;
    }
    /**
     * Login to the bitgo platform.
     */
    async authenticate(params) {
        try {
            if (!_.isObject(params)) {
                throw new Error('required object params');
            }
            if (!_.isString(params.password)) {
                throw new Error('expected string password');
            }
            const forceV1Auth = !!params.forceV1Auth;
            const authParams = this.preprocessAuthenticationParams(params);
            const password = params.password;
            if (this._token) {
                return new Error('already logged in');
            }
            const authUrl = this.microservicesUrl('/api/auth/v1/session');
            const request = this.post(authUrl);
            if (forceV1Auth) {
                request.forceV1Auth = true;
                // tell the server that the client was forced to downgrade the authentication protocol
                authParams.forceV1Auth = true;
                debug('forcing v1 auth for call to authenticate');
            }
            const response = await request.send(authParams);
            // extract body and user information
            const body = response.body;
            this._user = body.user;
            if (body.access_token) {
                this._token = body.access_token;
                // if the downgrade was forced, adding a warning message might be prudent
            }
            else {
                // check the presence of an encrypted ECDH xprv
                // if not present, legacy account
                const encryptedXprv = body.encryptedECDHXprv;
                if (!encryptedXprv) {
                    throw new Error('Keychain needs encryptedXprv property');
                }
                const responseDetails = this.handleTokenIssuance(response.body, password);
                this._token = responseDetails.token;
                this._ecdhXprv = responseDetails.ecdhXprv;
                // verify the response's authenticity
                (0, api_1.verifyResponse)(this, responseDetails.token, 'post', request, response);
                // add the remaining component for easier access
                response.body.access_token = this._token;
            }
            const userSettings = params.ensureEcdhKeychain ? await this.ensureUserEcdhKeychainIsCreated(password) : undefined;
            if (userSettings === null || userSettings === void 0 ? void 0 : userSettings.ecdhKeychain) {
                response.body.user.ecdhKeychain = userSettings.ecdhKeychain;
            }
            return (0, api_1.handleResponseResult)()(response);
        }
        catch (e) {
            (0, api_1.handleResponseError)(e);
        }
    }
    /**
     *
     * @param responseBody Response body object
     * @param password Password for the symmetric decryption
     */
    handleTokenIssuance(responseBody, password) {
        // make sure the response body contains the necessary properties
        sdk_core_1.common.validateParams(responseBody, ['derivationPath'], ['encryptedECDHXprv']);
        const environment = this._env;
        const environmentConfig = sdk_core_1.common.Environments[environment];
        const serverXpub = environmentConfig.serverXpub;
        let ecdhXprv = this._ecdhXprv;
        if (!ecdhXprv) {
            if (!password || !responseBody.encryptedECDHXprv) {
                throw new Error('ecdhXprv property must be set or password and encrypted encryptedECDHXprv must be provided');
            }
            try {
                ecdhXprv = this.decrypt({
                    input: responseBody.encryptedECDHXprv,
                    password: password,
                });
            }
            catch (e) {
                e.errorCode = 'ecdh_xprv_decryption_failure';
                console.error('Failed to decrypt encryptedECDHXprv.');
                throw e;
            }
        }
        // construct HDNode objects for client's xprv and server's xpub
        const clientHDNode = utxo_lib_1.bip32.fromBase58(ecdhXprv);
        const serverHDNode = utxo_lib_1.bip32.fromBase58(serverXpub);
        // BIP32 derivation path is applied to both client and server master keys
        const derivationPath = (0, sdk_core_1.sanitizeLegacyPath)(responseBody.derivationPath);
        const clientDerivedNode = clientHDNode.derivePath(derivationPath);
        const serverDerivedNode = serverHDNode.derivePath(derivationPath);
        const publicKey = serverDerivedNode.publicKey;
        const secretKey = clientDerivedNode.privateKey;
        if (!secretKey) {
            throw new Error('no client private Key');
        }
        const secret = Buffer.from(
        // FIXME(BG-34386): we should use `secp256k1.ecdh()` in the future
        //                  see discussion here https://github.com/bitcoin-core/secp256k1/issues/352
        secp256k1.publicKeyTweakMul(publicKey, secretKey)).toString('hex');
        // decrypt token with symmetric ECDH key
        let response;
        try {
            response = {
                token: this.decrypt({
                    input: responseBody.encryptedToken,
                    password: secret,
                }),
            };
        }
        catch (e) {
            e.errorCode = 'token_decryption_failure';
            console.error('Failed to decrypt token.');
            throw e;
        }
        if (!this._ecdhXprv) {
            response.ecdhXprv = ecdhXprv;
        }
        return response;
    }
    /**
     */
    verifyPassword(params = {}) {
        if (!_.isString(params.password)) {
            throw new Error('missing required string password');
        }
        if (!this._user || !this._user.username) {
            throw new Error('no current user');
        }
        const hmacPassword = this.calculateHMAC(this._user.username, params.password);
        return this.post(this.url('/user/verifypassword')).send({ password: hmacPassword }).result('valid');
    }
    /**
     * Clear out all state from this BitGo object, effectively logging out the current user.
     */
    clear() {
        // TODO: are there any other fields which should be cleared?
        this._user = undefined;
        this._token = undefined;
        this._refreshToken = undefined;
        this._ecdhXprv = undefined;
    }
    /**
     * Use refresh token to get new access token.
     * If the refresh token is null/defined, then we use the stored token from auth
     */
    async refreshToken(params = {}) {
        sdk_core_1.common.validateParams(params, [], ['refreshToken']);
        const refreshToken = params.refreshToken || this._refreshToken;
        if (!refreshToken) {
            throw new Error('Must provide refresh token or have authenticated with Oauth before');
        }
        if (!this._clientId || !this._clientSecret) {
            throw new Error('Need client id and secret set first to use this');
        }
        const body = await this.post(this._baseUrl + '/oauth/token')
            .send({
            grant_type: 'refresh_token',
            refresh_token: refreshToken,
            client_id: this._clientId,
            client_secret: this._clientSecret,
        })
            .result();
        this._token = body.access_token;
        this._refreshToken = body.refresh_token;
        return body;
    }
    /**
     *
     * listAccessTokens
     * Get information on all of the BitGo access tokens on the user
     * @return {
     *  id: <id of the token>
     *  label: <the user-provided label for this token>
     *  user: <id of the user on the token>
     *  enterprise <id of the enterprise this token is valid for>
     *  client: <the auth client that this token belongs to>
     *  scope: <list of allowed OAuth scope values>
     *  created: <date the token was created>
     *  expires: <date the token will expire>
     *  origin: <the origin for which this token is valid>
     *  isExtensible: <flag indicating if the token can be extended>
     *  extensionAddress: <address whose private key's signature is necessary for extensions>
     *  unlock: <info for actions that require an unlock before firing>
     * }
     */
    async listAccessTokens() {
        return this.get(this.url('/user/accesstoken')).send().result('accessTokens');
    }
    /**
     * addAccessToken
     * Add a BitGo API Access Token to the current user account
     * @param params {
     *    otp: (required) <valid otp code>
     *    label: (required) <label for the token>
     *    duration: <length of time in seconds the token will be valid for>
     *    ipRestrict: <array of IP address strings to whitelist>
     *    txValueLimit: <number of outgoing satoshis allowed on this token>
     *    scope: (required) <authorization scope of the requested token>
     * }
     * @return {
     *    id: <id of the token>
     *    token: <access token hex string to be used for BitGo API request verification>
     *    label: <user-provided label for this token>
     *    user: <id of the user on the token>
     *    enterprise <id of the enterprise this token is valid for>
     *    client: <the auth client that this token belongs to>
     *    scope: <list of allowed OAuth scope values>
     *    created: <date the token was created>
     *    expires: <date the token will expire>
     *    origin: <the origin for which this token is valid>
     *    isExtensible: <flag indicating if the token can be extended>
     *    extensionAddress: <address whose private key's signature is necessary for extensions>
     *    unlock: <info for actions that require an unlock before firing>
     * }
     */
    async addAccessToken(params) {
        var _a;
        try {
            if (!_.isString(params.label)) {
                throw new Error('required string label');
            }
            // check non-string params
            if (params.duration) {
                if (!_.isNumber(params.duration) || params.duration < 0) {
                    throw new Error('duration must be a non-negative number');
                }
            }
            if (params.ipRestrict) {
                if (!_.isArray(params.ipRestrict)) {
                    throw new Error('ipRestrict must be an array');
                }
                _.forEach(params.ipRestrict, (ipAddr) => {
                    if (!_.isString(ipAddr)) {
                        throw new Error('ipRestrict must be an array of IP address strings');
                    }
                });
            }
            if (params.txValueLimit) {
                if (!_.isNumber(params.txValueLimit)) {
                    throw new Error('txValueLimit must be a number');
                }
                if (params.txValueLimit < 0) {
                    throw new Error('txValueLimit must be a non-negative number');
                }
            }
            if (params.scope && params.scope.length > 0) {
                if (!_.isArray(params.scope)) {
                    throw new Error('scope must be an array');
                }
            }
            else {
                throw new Error('must specify scope for token');
            }
            const authUrl = this.microservicesUrl('/api/auth/v1/accesstoken');
            const request = this.post(authUrl);
            if (!this._ecdhXprv) {
                // without a private key, the user cannot decrypt the new access token the server will send
                request.forceV1Auth = true;
                debug('forcing v1 auth for adding access token using token %s', (_a = this._token) === null || _a === void 0 ? void 0 : _a.substr(0, 8));
            }
            const response = await request.send(params);
            if (request.forceV1Auth) {
                response.body.warning = 'A protocol downgrade has occurred because this is a legacy account.';
                return (0, api_1.handleResponseResult)()(response);
            }
            // verify the authenticity of the server's response before proceeding any further
            (0, api_1.verifyResponse)(this, this._token, 'post', request, response);
            const responseDetails = this.handleTokenIssuance(response.body);
            response.body.token = responseDetails.token;
            return (0, api_1.handleResponseResult)()(response);
        }
        catch (e) {
            (0, api_1.handleResponseError)(e);
        }
    }
    /**
     * Sets the expire time of an access token matching either the id or label to the current date, effectively deleting it
     *
     * Params:
     * id: <id of the access token to be deleted>
     * label: <label of the access token to be deleted>
     *
     * Returns:
     * id: <id of the token>
     * label: <user-provided label for this token>
     * user: <id of the user on the token>
     * enterprise <id of the enterprise this token is valid for>
     * client: <the auth client that this token belongs to>
     * scope: <list of allowed OAuth scope values>
     * created: <date the token was created>
     * expires: <date the token will expire>
     * origin: <the origin for which this token is valid>
     * isExtensible: <flag indicating if the token can be extended>
     * extensionAddress: <address whose private key's signature is ne*cessary for extensions>
     * unlock: <info for actions that require an unlock before firing>
     * @param params
     */
    async removeAccessToken({ id, label }) {
        if ((!id && !label) || (id && label)) {
            throw new Error('must provide exactly one of id or label');
        }
        if (id) {
            return this.del(this.url(`/user/accesstoken/${id}`))
                .send()
                .result();
        }
        const tokens = await this.listAccessTokens();
        if (!tokens) {
            throw new Error('token with this label does not exist');
        }
        const matchingTokens = _.filter(tokens, { label });
        if (matchingTokens.length > 1) {
            throw new Error('ambiguous call: multiple tokens matching this label');
        }
        if (matchingTokens.length === 0) {
            throw new Error('token with this label does not exist');
        }
        return this.del(this.url(`/user/accesstoken/${matchingTokens[0].id}`))
            .send()
            .result();
    }
    /**
     * Generate a random password
     * @param   {Number} numWords     Number of 32-bit words
     * @returns {String}          base58 random password
     */
    generateRandomPassword(numWords = 5) {
        return (0, sdk_core_1.generateRandomPassword)(numWords);
    }
    /**
     * Logout of BitGo
     */
    async logout() {
        const result = await this.get(this.url('/user/logout')).result();
        this.clear();
        return result;
    }
    /**
     * Get a user by ID (name/email only)
     * @param id
     *
     * @deprecated
     */
    async getUser({ id }) {
        if (!_.isString(id)) {
            throw new Error('expected string id');
        }
        return this.get(this.url(`/user/${id}`)).result('user');
    }
    /**
     * Get the current logged in user
     */
    async me() {
        return this.getUser({ id: 'me' });
    }
    /**
     * Unlock the session by providing OTP
     * @param {string} otp Required OTP code for the account.
     * @param {number} duration Desired duration of the unlock in seconds (default=600, max=3600).
     */
    async unlock({ otp, duration }) {
        if (otp && !_.isString(otp)) {
            throw new Error('expected string or undefined otp');
        }
        return this.post(this.url('/user/unlock')).send({ otp, duration }).result();
    }
    /**
     * Lock the session
     */
    async lock() {
        return this.post(this.url('/user/lock')).result();
    }
    /**
     * Get the current session
     */
    async session() {
        return this.get(this.url('/user/session')).result('session');
    }
    /**
     * Trigger a push/sms for the OTP code
     * @param {boolean} params.forceSMS If set to true, will use SMS to send the OTP to the user even if they have other 2FA method set up.
     * @deprecated
     */
    async sendOTP(params = {}) {
        return this.post(this.url('/user/sendotp')).send(params).result();
    }
    /**
     * Extend token, provided the current token is extendable
     * @param params
     * - duration: duration in seconds by which to extend the token, starting at the current time
     */
    async extendToken(params = {}) {
        if (!this._extensionKey) {
            throw new Error('missing required property _extensionKey');
        }
        const timestamp = Date.now();
        const duration = params.duration;
        const message = timestamp + '|' + this._token + '|' + duration;
        const privateKey = this._extensionKey.privateKey;
        if (!privateKey) {
            throw new Error('no privateKey on extensionKey');
        }
        const isCompressed = this._extensionKey.compressed;
        const prefix = utxolib.networks.bitcoin.messagePrefix;
        const signature = bitcoinMessage.sign(message, privateKey, isCompressed, prefix).toString('hex');
        return this.post(this.url('/user/extendtoken'))
            .send(params)
            .set('timestamp', timestamp.toString())
            .set('signature', signature)
            .result();
    }
    /**
     * Get a key for sharing a wallet with a user
     * @param email email of user to share wallet with
     */
    async getSharingKey({ email }) {
        if (!_.isString(email)) {
            throw new Error('required string email');
        }
        return this.post(this.url('/user/sharingkey')).send({ email }).result();
    }
    /**
     * Users that want to sign with a key will use this api to fetch the keychain and the path.
     * Users that want to verify a signature will use this api to fetch another users ecdh pubkey.
     * Note: If the user id is not provided, it will default to getting the current user's keychain.
     * @param bitgo
     * @param enterpriseId
     * @param userId
     */
    async getSigningKeyForUser(enterpriseId, userId) {
        const user = userId !== null && userId !== void 0 ? userId : 'me';
        return this.get(this.url(`/enterprise/${enterpriseId}/user/${user}/signingkey`, 2))
            .query({})
            .result();
    }
    /**
     *
     */
    getValidate() {
        return this._validate;
    }
    /**
     *
     */
    setValidate(validate) {
        if (!_.isBoolean(validate)) {
            throw new Error('invalid argument');
        }
        this._validate = validate;
    }
    /**
     * Register a new coin instance with its builder factory
     * @param {string} name coin name as it was registered in @bitgo/statics
     * @param {CoinConstructor} coin the builder factory class for that coin
     * @returns {void}
     */
    register(name, coin) {
        sdk_core_1.GlobalCoinFactory.register(name, coin);
    }
    /**
     * Get bitcoin market data
     *
     * @deprecated
     */
    markets() {
        if (!this._markets) {
            this._markets = new Markets(this);
        }
        return this._markets;
    }
    /**
     * Get the latest bitcoin prices
     * (Deprecated: Will be removed in the future) use `bitgo.markets().latest()`
     * @deprecated
     */
    // cb-compat
    async market() {
        return this.get(this.url('/market/latest')).result();
    }
    /**
     * Get market data from yesterday
     * (Deprecated: Will be removed in the future) use bitgo.markets().yesterday()
     * @deprecated
     */
    async yesterday() {
        return this.get(this.url('/market/yesterday')).result();
    }
    /**
     * Get the blockchain object.
     * @deprecated
     */
    blockchain() {
        if (!this._blockchain) {
            this._blockchain = new Blockchain(this);
        }
        return this._blockchain;
    }
    /**
     * Get the user's keychains object.
     * @deprecated
     */
    keychains() {
        if (!this._keychains) {
            this._keychains = new Keychains(this);
        }
        return this._keychains;
    }
    /**
     * Get the travel rule object
     * @deprecated
     */
    travelRule() {
        if (!this._travelRule) {
            this._travelRule = new TravelRule(this);
        }
        return this._travelRule;
    }
    /**
     * Get the user's wallets object.
     * @deprecated
     */
    wallets() {
        if (!this._wallets) {
            this._wallets = new Wallets(this);
        }
        return this._wallets;
    }
    /**
     * Get pending approvals that can be approved/ or rejected
     * @deprecated
     */
    pendingApprovals() {
        if (!this._pendingApprovals) {
            this._pendingApprovals = new PendingApprovals(this);
        }
        return this._pendingApprovals;
    }
    /**
     * A factory method to create a new Wallet object, initialized with the wallet params
     * Can be used to reconstitute a wallet from cached data
     * @param walletParams
     * @deprecated
     */
    newWalletObject(walletParams) {
        return new Wallet(this, walletParams);
    }
    /**
     * V1 method for calculating miner fee amounts, given the number and
     * type of transaction inputs, along with a fee rate in satoshis per vkB.
     *
     * This method should not be used for new code.
     *
     * @deprecated
     * @param params
     * @return {any}
     */
    async calculateMinerFeeInfo(params) {
        return TransactionBuilder.calculateMinerFeeInfo(params);
    }
    /**
     * Verify a Bitcoin address is a valid base58 address
     * @deprecated
     */
    verifyAddress(params = {}) {
        sdk_core_1.common.validateParams(params, ['address'], []);
        if (!_.isString(params.address)) {
            throw new Error('missing required string address');
        }
        const networkName = sdk_core_1.common.Environments[this.getEnv()].network;
        const network = utxolib.networks[networkName];
        return (0, verifyAddress_1.verifyAddress)(params.address, network);
    }
    /**
     * Split a secret into shards using Shamir Secret Sharing.
     * @param seed A hexadecimal secret to split
     * @param passwords An array of the passwords used to encrypt each share
     * @param m The threshold number of shards necessary to reconstitute the secret
     */
    splitSecret({ seed, passwords, m }) {
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (!_.isInteger(m) || m < 2) {
            throw new Error('m must be a positive integer greater than or equal to 2');
        }
        if (passwords.length < m) {
            throw new Error('passwords array length cannot be less than m');
        }
        const n = passwords.length;
        const secrets = shamir.share(seed, n, m);
        const shards = _.zipWith(secrets, passwords, (shard, password) => {
            return this.encrypt({ input: shard, password });
        });
        const node = utxo_lib_1.bip32.fromSeed(Buffer.from(seed, 'hex'));
        return {
            xpub: node.neutered().toBase58(),
            m,
            n,
            seedShares: shards,
        };
    }
    /**
     * Reconstitute a secret which was sharded with `splitSecret`.
     * @param shards
     * @param passwords
     */
    reconstituteSecret({ shards, passwords }) {
        if (!Array.isArray(shards)) {
            throw new Error('shards must be an array');
        }
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (shards.length !== passwords.length) {
            throw new Error('shards and passwords arrays must have same length');
        }
        const secrets = _.zipWith(shards, passwords, (shard, password) => {
            return this.decrypt({ input: shard, password });
        });
        const seed = shamir.combine(secrets);
        const node = utxo_lib_1.bip32.fromSeed(Buffer.from(seed, 'hex'));
        return {
            xpub: node.neutered().toBase58(),
            xprv: node.toBase58(),
            seed,
        };
    }
    /**
     *
     * @param shards
     * @param passwords
     * @param m
     * @param xpub Optional xpub to verify the results against
     */
    verifyShards({ shards, passwords, m, xpub }) {
        /**
         * Generate all possible combinations of a given array's values given subset size m
         * @param array The array whose values are to be arranged in all combinations
         * @param m The size of each subset
         * @param entryIndices Recursively trailing set of currently chosen array indices for the combination subset under construction
         * @returns {Array}
         */
        const generateCombinations = (array, m, entryIndices = []) => {
            let combinations = [];
            if (entryIndices.length === m) {
                const currentCombination = _.at(array, entryIndices);
                return [currentCombination];
            }
            // The highest index
            let entryIndex = _.last(entryIndices);
            // If there are currently no indices, assume -1
            if (_.isUndefined(entryIndex)) {
                entryIndex = -1;
            }
            for (let i = entryIndex + 1; i < array.length; i++) {
                // append the current index to the trailing indices
                const currentEntryIndices = [...entryIndices, i];
                const newCombinations = generateCombinations(array, m, currentEntryIndices);
                combinations = [...combinations, ...newCombinations];
            }
            return combinations;
        };
        if (!Array.isArray(shards)) {
            throw new Error('shards must be an array');
        }
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (shards.length !== passwords.length) {
            throw new Error('shards and passwords arrays must have same length');
        }
        const secrets = _.zipWith(shards, passwords, (shard, password) => {
            return this.decrypt({ input: shard, password });
        });
        const secretCombinations = generateCombinations(secrets, m);
        const seeds = secretCombinations.map((currentCombination) => {
            return shamir.combine(currentCombination);
        });
        const uniqueSeeds = _.uniq(seeds);
        if (uniqueSeeds.length !== 1) {
            return false;
        }
        const seed = _.first(uniqueSeeds);
        const node = utxo_lib_1.bip32.fromSeed(Buffer.from(seed, 'hex'));
        const restoredXpub = node.neutered().toBase58();
        if (!_.isUndefined(xpub)) {
            if (!_.isString(xpub)) {
                throw new Error('xpub must be a string');
            }
            if (restoredXpub !== xpub) {
                return false;
            }
        }
        return true;
    }
    /**
     * @deprecated - use `getSharedSecret()`
     */
    getECDHSecret({ otherPubKeyHex, eckey }) {
        if (!_.isString(otherPubKeyHex)) {
            throw new Error('otherPubKeyHex string required');
        }
        if (!_.isObject(eckey)) {
            throw new Error('eckey object required');
        }
        return (0, sdk_core_1.getSharedSecret)(eckey, Buffer.from(otherPubKeyHex, 'hex')).toString('hex');
    }
    /**
     * Gets the user's private ECDH keychain
     */
    async getECDHKeychain(ecdhKeychainPub) {
        if (!ecdhKeychainPub) {
            const result = await this.get(this.url('/user/settings')).result();
            if (!result.settings.ecdhKeychain) {
                return new Error('ecdh keychain not found for user');
            }
            ecdhKeychainPub = result.settings.ecdhKeychain;
        }
        return this.keychains().get({ xpub: ecdhKeychainPub });
    }
    /**
     * Returns the user derived public and private ECDH keypair
     * @param password password to decrypt the user's ECDH encrypted private key
     * @param entId? optional enterprise id to check for permissions
     */
    async getEcdhKeypairPrivate(password, entId) {
        const userSigningKey = await this.getSigningKeyForUser(entId);
        const pubkeyOfAdminEcdhKeyHex = userSigningKey.derivedPubkey;
        if (!userSigningKey.ecdhKeychain || !userSigningKey.derivationPath) {
            throw new Error('Something went wrong with the user keychain. Please contact support@bitgo.com.');
        }
        const userEcdhKeychain = await this.getECDHKeychain(userSigningKey.ecdhKeychain);
        let xprv;
        try {
            xprv = this.decrypt({
                password: password,
                input: userEcdhKeychain.encryptedXprv,
            });
        }
        catch (e) {
            throw new Error('Incorrect password. Please try again.');
        }
        return {
            derivedPubKey: pubkeyOfAdminEcdhKeyHex,
            derivationPath: userSigningKey.derivationPath,
            xprv,
        };
    }
    /**
     * @param params
     * - operatingSystem: one of ios, android
     * - pushToken: hex-formatted token for the respective native push notification service
     * @returns {*}
     * @deprecated
     */
    async registerPushToken(params) {
        params = params || {};
        sdk_core_1.common.validateParams(params, ['pushToken', 'operatingSystem'], []);
        if (!this._token) {
            // this device has to be registered to an extensible session
            throw new Error('not logged in');
        }
        const postParams = _.pick(params, ['pushToken', 'operatingSystem']);
        return this.post(this.url('/devices')).send(postParams).result();
    }
    /**
     * @param params
     * - pushVerificationToken: the token received via push notification to confirm the device's mobility
     * @deprecated
     */
    verifyPushToken(params) {
        if (!_.isObject(params)) {
            throw new Error('required object params');
        }
        if (!_.isString(params.pushVerificationToken)) {
            throw new Error('required string pushVerificationToken');
        }
        if (!this._token) {
            // this device has to be registered to an extensible session
            throw new Error('not logged in');
        }
        const postParams = _.pick(params, 'pushVerificationToken');
        return this.post(this.url('/devices/verify')).send(postParams).result();
    }
    /**
     * Login to the bitgo system using an authcode generated via Oauth
     */
    async authenticateWithAuthCode(params) {
        if (!_.isObject(params)) {
            throw new Error('required object params');
        }
        if (!_.isString(params.authCode)) {
            throw new Error('required string authCode');
        }
        if (!this._clientId || !this._clientSecret) {
            throw new Error('Need client id and secret set first to use this');
        }
        const authCode = params.authCode;
        if (this._token) {
            throw new Error('already logged in');
        }
        const request = this.post(this._baseUrl + '/oauth/token');
        request.forceV1Auth = true; // OAuth currently only supports v1 authentication
        const body = await request
            .send({
            grant_type: 'authorization_code',
            code: authCode,
            client_id: this._clientId,
            client_secret: this._clientSecret,
        })
            .result();
        this._token = body.access_token;
        this._refreshToken = body.refresh_token;
        this._user = await this.me();
        return body;
    }
    /**
     * Change the password of the currently logged in user.
     * Also change all v1 and v2 keychain passwords if they match the
     * given oldPassword. Returns nothing on success.
     * @param oldPassword {String} - the current password
     * @param newPassword {String} - the new password
     */
    async changePassword({ oldPassword, newPassword }) {
        if (!_.isString(oldPassword)) {
            throw new Error('expected string oldPassword');
        }
        if (!_.isString(newPassword)) {
            throw new Error('expected string newPassword');
        }
        const user = this.user();
        if (typeof user !== 'object' || !user.username) {
            throw new Error('missing required object user');
        }
        const validation = await this.verifyPassword({ password: oldPassword });
        if (!validation) {
            throw new Error('the provided oldPassword is incorrect');
        }
        // it doesn't matter which coin we choose because the v2 updatePassword functions updates all v2 keychains
        // we just need to choose a coin that exists in the current environment
        const coin = sdk_core_1.common.Environments[this.getEnv()].network === 'bitcoin' ? 'btc' : 'tbtc';
        const updateKeychainPasswordParams = { oldPassword, newPassword };
        const v1KeychainUpdatePWResult = await this.keychains().updatePassword(updateKeychainPasswordParams);
        const v2Keychains = await this.coin(coin).keychains().updatePassword(updateKeychainPasswordParams);
        const updatePasswordParams = {
            keychains: v1KeychainUpdatePWResult.keychains,
            v2_keychains: v2Keychains,
            version: v1KeychainUpdatePWResult.version,
            oldPassword: this.calculateHMAC(user.username, oldPassword),
            password: this.calculateHMAC(user.username, newPassword),
        };
        return this.post(this.url('/user/changepassword')).send(updatePasswordParams).result();
    }
    /**
     * Get all the address labels on all of the user's wallets
     *
     * @deprecated
     */
    async labels() {
        return this.get(this.url('/labels')).result('labels');
    }
    /**
     * Estimates approximate fee per kb needed for a tx to get into a block
     * @param {number} params.numBlocks target blocks for the transaction to be confirmed
     * @param {number} params.maxFee maximum fee willing to be paid (for safety)
     * @param {array[string]} params.inputs list of unconfirmed txIds from which this transaction uses inputs
     * @param {number} params.txSize estimated transaction size in bytes, optional parameter used for CPFP estimation.
     * @param {boolean} params.cpfpAware flag indicating fee should take into account CPFP
     * @deprecated
     */
    async estimateFee(params = {}) {
        const queryParams = { version: 12 };
        if (params.numBlocks) {
            if (!_.isNumber(params.numBlocks)) {
                throw new Error('invalid argument');
            }
            queryParams.numBlocks = params.numBlocks;
        }
        if (params.maxFee) {
            if (!_.isNumber(params.maxFee)) {
                throw new Error('invalid argument');
            }
            queryParams.maxFee = params.maxFee;
        }
        if (params.inputs) {
            if (!Array.isArray(params.inputs)) {
                throw new Error('invalid argument');
            }
            queryParams.inputs = params.inputs;
        }
        if (params.txSize) {
            if (!_.isNumber(params.txSize)) {
                throw new Error('invalid argument');
            }
            queryParams.txSize = params.txSize;
        }
        if (params.cpfpAware) {
            if (!_.isBoolean(params.cpfpAware)) {
                throw new Error('invalid argument');
            }
            queryParams.cpfpAware = params.cpfpAware;
        }
        return this.get(this.url('/tx/fee')).query(queryParams).result();
    }
    /**
     * Get BitGo's guarantee using an instant id
     * @param params
     * @deprecated
     */
    async instantGuarantee(params) {
        if (!_.isString(params.id)) {
            throw new Error('required string id');
        }
        const body = await this.get(this.url('/instant/' + params.id)).result();
        if (!body.guarantee) {
            throw new Error('no guarantee found in response body');
        }
        if (!body.signature) {
            throw new Error('no signature found in guarantee response body');
        }
        const signingAddress = sdk_core_1.common.Environments[this.getEnv()].signingAddress;
        const signatureBuffer = Buffer.from(body.signature, 'hex');
        const prefix = utxolib.networks[sdk_core_1.common.Environments[this.getEnv()].network].messagePrefix;
        const isValidSignature = bitcoinMessage.verify(body.guarantee, signingAddress, signatureBuffer, prefix);
        if (!isValidSignature) {
            throw new Error('incorrect signature');
        }
        return body;
    }
    /**
     * Get a target address for payment of a BitGo fee
     * @deprecated
     */
    async getBitGoFeeAddress() {
        return this.post(this.url('/billing/address')).send({}).result();
    }
    /**
     * Gets an address object (including the wallet id) for a given address.
     * @param {string} params.address The address to look up.
     * @deprecated
     */
    async getWalletAddress({ address }) {
        return this.get(this.url(`/walletaddress/${address}`)).result();
    }
    /**
     * Fetch list of user webhooks
     *
     * @returns {*}
     * @deprecated
     */
    async listWebhooks() {
        return this.get(this.url('/webhooks')).result();
    }
    /**
     * Add new user webhook
     *
     * @param params
     * @returns {*}
     * @deprecated
     */
    async addWebhook(params) {
        if (!_.isString(params.url)) {
            throw new Error('required string url');
        }
        if (!_.isString(params.type)) {
            throw new Error('required string type');
        }
        return this.post(this.url('/webhooks')).send(params).result();
    }
    /**
     * Remove user webhook
     *
     * @param params
     * @returns {*}
     * @deprecated
     */
    async removeWebhook(params) {
        if (!_.isString(params.url)) {
            throw new Error('required string url');
        }
        if (!_.isString(params.type)) {
            throw new Error('required string type');
        }
        return this.del(this.url('/webhooks')).send(params).result();
    }
    /**
     * Fetch list of webhook notifications for the user
     *
     * @param params
     * @returns {*}
     */
    async listWebhookNotifications(params = {}) {
        const query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        return this.get(this.url('/webhooks/notifications')).query(query).result();
    }
    /**
     * Simulate a user webhook
     *
     * @param params
     * @returns {*}
     */
    async simulateWebhook(params) {
        sdk_core_1.common.validateParams(params, ['webhookId', 'blockId'], []);
        if (!_.isString(params.webhookId)) {
            throw new Error('required string webhookId');
        }
        if (!_.isString(params.blockId)) {
            throw new Error('required string blockId');
        }
        return this.post(this.url(`/webhooks/${params.webhookId}/simulate`))
            .send(params)
            .result();
    }
    /**
     * Synchronously get constants which are relevant to the client.
     *
     * Note: This function has a known race condition. It may return different values over time,
     * especially if called shortly after creation of the BitGo object.
     *
     * New code should call fetchConstants() directly instead.
     *
     * @deprecated
     * @return {Object} The client constants object
     */
    getConstants() {
        // kick off a fresh request for the client constants
        this.fetchConstants().catch(function (err) {
            if (err) {
                // make sure an error does not terminate the entire script
                console.error('failed to fetch client constants from BitGo');
                console.trace(err);
            }
        });
        // use defaultConstants as the backup for keys that are not set in this._constants
        return _.merge({}, (0, sdk_core_1.defaultConstants)(this.getEnv()), BitGoAPI._constants[this.getEnv()]);
    }
}
exports.BitGoAPI = BitGoAPI;
BitGoAPI._testnetWarningMessage = false;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYml0Z29BUEkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYml0Z29BUEkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsOENBc0J5QjtBQUN6QixvQ0FBb0M7QUFDcEMsMkNBQTJDO0FBQzNDLDhDQUF5RDtBQUN6RCxvREFBb0Q7QUFDcEQscURBQXlEO0FBQ3pELG1DQUFvQztBQUNwQyxpQ0FBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLHVDQUF1QztBQUN2Qyx5Q0FBeUM7QUFDekMsOEJBQThCO0FBQzlCLCtCQU9lO0FBQ2YsdUNBQTZDO0FBQzdDLHNEQUFtRDtBQXlDbkQsNENBQTZDO0FBQzdDLHlDQUEwQztBQUMxQyxNQUFNLEtBQUssR0FBRyxJQUFBLGVBQVEsRUFBQyxXQUFXLENBQUMsQ0FBQztBQUVwQyxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUM5QyxNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUM1QyxzQ0FBdUM7QUFFdkMsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQ3hDLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN4QyxNQUFNLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBQzFELE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBQzlDLE1BQU0sa0JBQWtCLEdBQUcsT0FBTyxDQUFDLHlCQUF5QixDQUFDLENBQUM7QUFFOUQsSUFBSSxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7QUFDN0IsSUFBSSxnQkFBZ0IsQ0FBQztBQUNyQixJQUFJLENBQUMsMkJBQVMsSUFBSSxDQUFDLDZCQUFXLEVBQUU7SUFDOUIsS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7SUFDOUIsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO0lBQ3hCLGdC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LFdBQVcsQ0FBQyxDQUFDO2FBQ2pFLElBQUksQ0FBQyxNQUFNLENBQUM7YUFDWixNQUFNLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0gsWUFBWTtRQUNWLG9EQUFvRDtRQUNwRCxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRztZQUN2QyxJQUFJLEdBQUcsRUFBRTtnQkFDUCwwREFBMEQ7Z0JBQzFELE9BQU8sQ0FBQyxLQUFLLENBQUMsNkNBQTZDLENBQUMsQ0FBQztnQkFDN0QsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNwQjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsa0ZBQWtGO1FBQ2xGLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsSUFBQSwyQkFBZ0IsRUFBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxRQUFRLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDMUYsQ0FBQzs7QUE3M0RILDRCQTgzREM7QUFuM0RrQiwrQkFBc0IsR0FBRyxLQUFLLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBbGlhc0Vudmlyb25tZW50cyxcbiAgQmFzZUNvaW4sXG4gIGJpdGNvaW4sXG4gIEJpdEdvQmFzZSxcbiAgQml0R29SZXF1ZXN0LFxuICBDb2luQ29uc3RydWN0b3IsXG4gIGNvbW1vbixcbiAgRGVjcnlwdE9wdGlvbnMsXG4gIGRlZmF1bHRDb25zdGFudHMsXG4gIEVjZGhEZXJpdmVkS2V5cGFpcixcbiAgRW5jcnlwdE9wdGlvbnMsXG4gIEVudmlyb25tZW50TmFtZSxcbiAgZ2VuZXJhdGVSYW5kb21QYXNzd29yZCxcbiAgZ2V0QWRkcmVzc1AyUEtILFxuICBnZXRTaGFyZWRTZWNyZXQsXG4gIEdldFNoYXJpbmdLZXlPcHRpb25zLFxuICBHZXRTaWduaW5nS2V5QXBpLFxuICBHbG9iYWxDb2luRmFjdG9yeSxcbiAgSVJlcXVlc3RUcmFjZXIsXG4gIG1ha2VSYW5kb21LZXksXG4gIHNhbml0aXplTGVnYWN5UGF0aCxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCAqIGFzIHNqY2wgZnJvbSAnQGJpdGdvL3NqY2wnO1xuaW1wb3J0ICogYXMgdXR4b2xpYiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0IHsgYmlwMzIsIEVDUGFpckludGVyZmFjZSB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgKiBhcyBiaXRjb2luTWVzc2FnZSBmcm9tICdiaXRjb2luanMtbWVzc2FnZSc7XG5pbXBvcnQgeyBpc0Jyb3dzZXIsIGlzV2ViV29ya2VyIH0gZnJvbSAnYnJvd3Nlci1vci1ub2RlJztcbmltcG9ydCB7IGNyZWF0ZUhtYWMgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IGRlYnVnTGliIGZyb20gJ2RlYnVnJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIHNlY3AyNTZrMSBmcm9tICdzZWNwMjU2azEnO1xuaW1wb3J0ICogYXMgc3VwZXJhZ2VudCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCAqIGFzIHVybExpYiBmcm9tICd1cmwnO1xuaW1wb3J0IHtcbiAgaGFuZGxlUmVzcG9uc2VFcnJvcixcbiAgaGFuZGxlUmVzcG9uc2VSZXN1bHQsXG4gIHNlcmlhbGl6ZVJlcXVlc3REYXRhLFxuICBzZXRSZXF1ZXN0UXVlcnlTdHJpbmcsXG4gIHRvQml0Z29SZXF1ZXN0LFxuICB2ZXJpZnlSZXNwb25zZSxcbn0gZnJvbSAnLi9hcGknO1xuaW1wb3J0IHsgZGVjcnlwdCwgZW5jcnlwdCB9IGZyb20gJy4vZW5jcnlwdCc7XG5pbXBvcnQgeyB2ZXJpZnlBZGRyZXNzIH0gZnJvbSAnLi92MS92ZXJpZnlBZGRyZXNzJztcbmltcG9ydCB7XG4gIEFjY2Vzc1Rva2VuT3B0aW9ucyxcbiAgQWRkQWNjZXNzVG9rZW5PcHRpb25zLFxuICBBZGRBY2Nlc3NUb2tlblJlc3BvbnNlLFxuICBBdXRoZW50aWNhdGVPcHRpb25zLFxuICBBdXRoZW50aWNhdGVXaXRoQXV0aENvZGVPcHRpb25zLFxuICBCaXRHb0FQSU9wdGlvbnMsXG4gIEJpdEdvSnNvbixcbiAgQml0R29TaW11bGF0ZVdlYmhvb2tPcHRpb25zLFxuICBDYWxjdWxhdGVIbWFjU3ViamVjdE9wdGlvbnMsXG4gIENhbGN1bGF0ZVJlcXVlc3RIZWFkZXJzT3B0aW9ucyxcbiAgQ2FsY3VsYXRlUmVxdWVzdEhtYWNPcHRpb25zLFxuICBDaGFuZ2VQYXNzd29yZE9wdGlvbnMsXG4gIERlcHJlY2F0ZWRWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgRXN0aW1hdGVGZWVPcHRpb25zLFxuICBFeHRlbmRUb2tlbk9wdGlvbnMsXG4gIEdldEVjZGhTZWNyZXRPcHRpb25zLFxuICBHZXRVc2VyT3B0aW9ucyxcbiAgTGlzdFdlYmhvb2tOb3RpZmljYXRpb25zT3B0aW9ucyxcbiAgTG9naW5SZXNwb25zZSxcbiAgUGluZ09wdGlvbnMsXG4gIFByb2Nlc3NlZEF1dGhlbnRpY2F0aW9uT3B0aW9ucyxcbiAgUmVjb25zdGl0dXRlZFNlY3JldCxcbiAgUmVjb25zdGl0dXRlU2VjcmV0T3B0aW9ucyxcbiAgUmVnaXN0ZXJQdXNoVG9rZW5PcHRpb25zLFxuICBSZW1vdmVBY2Nlc3NUb2tlbk9wdGlvbnMsXG4gIFJlcXVlc3RIZWFkZXJzLFxuICBTcGxpdFNlY3JldCxcbiAgU3BsaXRTZWNyZXRPcHRpb25zLFxuICBUb2tlbklzc3VhbmNlLFxuICBUb2tlbklzc3VhbmNlUmVzcG9uc2UsXG4gIFVubG9ja09wdGlvbnMsXG4gIFVzZXIsXG4gIFZlcmlmeVBhc3N3b3JkT3B0aW9ucyxcbiAgVmVyaWZ5UHVzaFRva2VuT3B0aW9ucyxcbiAgVmVyaWZ5UmVzcG9uc2VJbmZvLFxuICBWZXJpZnlSZXNwb25zZU9wdGlvbnMsXG4gIFZlcmlmeVNoYXJkc09wdGlvbnMsXG4gIFdlYmhvb2tPcHRpb25zLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCBzaGFtaXIgPSByZXF1aXJlKCdzZWNyZXRzLmpzLWdyZW1wZScpO1xuaW1wb3J0IHBqc29uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTGliKCdiaXRnbzphcGknKTtcblxuY29uc3QgQmxvY2tjaGFpbiA9IHJlcXVpcmUoJy4vdjEvYmxvY2tjaGFpbicpO1xuY29uc3QgS2V5Y2hhaW5zID0gcmVxdWlyZSgnLi92MS9rZXljaGFpbnMnKTtcbmltcG9ydCBXYWxsZXQgPSByZXF1aXJlKCcuL3YxL3dhbGxldCcpO1xuXG5jb25zdCBXYWxsZXRzID0gcmVxdWlyZSgnLi92MS93YWxsZXRzJyk7XG5jb25zdCBNYXJrZXRzID0gcmVxdWlyZSgnLi92MS9tYXJrZXRzJyk7XG5jb25zdCBQZW5kaW5nQXBwcm92YWxzID0gcmVxdWlyZSgnLi92MS9wZW5kaW5nYXBwcm92YWxzJyk7XG5jb25zdCBUcmF2ZWxSdWxlID0gcmVxdWlyZSgnLi92MS90cmF2ZWxSdWxlJyk7XG5jb25zdCBUcmFuc2FjdGlvbkJ1aWxkZXIgPSByZXF1aXJlKCcuL3YxL3RyYW5zYWN0aW9uQnVpbGRlcicpO1xuXG5sZXQgZW5hYmxlUHJveHlBZ2VudCA9IGZhbHNlO1xubGV0IHByb3h5QWdlbnRNb2R1bGU7XG5pZiAoIWlzQnJvd3NlciAmJiAhaXNXZWJXb3JrZXIpIHtcbiAgZGVidWcoJ2VuYWJsaW5nIHByb3h5LWFnZW50Jyk7XG4gIGVuYWJsZVByb3h5QWdlbnQgPSB0cnVlO1xuICBwcm94eUFnZW50TW9kdWxlID0gcmVxdWlyZSgncHJveHktYWdlbnQnKTtcbn1cblxuY29uc3QgcGF0Y2hlZFJlcXVlc3RNZXRob2RzID0gWydnZXQnLCAncG9zdCcsICdwdXQnLCAnZGVsJywgJ3BhdGNoJywgJ29wdGlvbnMnXSBhcyBjb25zdDtcblxuZXhwb3J0IGNsYXNzIEJpdEdvQVBJIGltcGxlbWVudHMgQml0R29CYXNlIHtcbiAgLy8gdjEgdHlwZXNcbiAgcHJvdGVjdGVkIF9rZXljaGFpbnM6IGFueTtcbiAgcHJvdGVjdGVkIF93YWxsZXRzOiBhbnk7XG4gIHByb3RlY3RlZCBfbWFya2V0cz86IGFueTtcbiAgcHJvdGVjdGVkIF9ibG9ja2NoYWluPzogYW55O1xuICBwcm90ZWN0ZWQgX3RyYXZlbFJ1bGU/OiBhbnk7XG4gIHByb3RlY3RlZCBfcGVuZGluZ0FwcHJvdmFscz86IGFueTtcblxuICBwcm90ZWN0ZWQgc3RhdGljIF9jb25zdGFudHM6IGFueTtcbiAgcHJvdGVjdGVkIHN0YXRpYyBfY29uc3RhbnRzRXhwaXJlOiBhbnk7XG4gIHByb3RlY3RlZCBzdGF0aWMgX3Rlc3RuZXRXYXJuaW5nTWVzc2FnZSA9IGZhbHNlO1xuICBwdWJsaWMgcmVhZG9ubHkgZW52OiBFbnZpcm9ubWVudE5hbWU7XG4gIHByb3RlY3RlZCByZWFkb25seSBfYmFzZVVybDogc3RyaW5nO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX2Jhc2VBcGlVcmw6IHN0cmluZztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9iYXNlQXBpVXJsVjI6IHN0cmluZztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9lbnY6IEVudmlyb25tZW50TmFtZTtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9hdXRoVmVyc2lvbjogRXhjbHVkZTxCaXRHb0FQSU9wdGlvbnNbJ2F1dGhWZXJzaW9uJ10sIHVuZGVmaW5lZD4gPSAyO1xuICBwcm90ZWN0ZWQgX2htYWNWZXJpZmljYXRpb24gPSB0cnVlO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3Byb3h5Pzogc3RyaW5nO1xuICBwcm90ZWN0ZWQgX3VzZXI/OiBVc2VyO1xuICBwcm90ZWN0ZWQgX2V4dGVuc2lvbktleT86IEVDUGFpckludGVyZmFjZTtcbiAgcHJvdGVjdGVkIF9yZXFJZD86IElSZXF1ZXN0VHJhY2VyO1xuICBwcm90ZWN0ZWQgX3Rva2VuPzogc3RyaW5nO1xuICBwcm90ZWN0ZWQgX3ZlcnNpb24gPSBwanNvbi52ZXJzaW9uO1xuICBwcm90ZWN0ZWQgX3VzZXJBZ2VudD86IHN0cmluZztcbiAgcHJvdGVjdGVkIF9lY2RoWHBydj86IHN0cmluZztcbiAgcHJvdGVjdGVkIF9yZWZyZXNoVG9rZW4/OiBzdHJpbmc7XG4gIHByb3RlY3RlZCByZWFkb25seSBfY2xpZW50SWQ/OiBzdHJpbmc7XG4gIHByb3RlY3RlZCByZWFkb25seSBfY2xpZW50U2VjcmV0Pzogc3RyaW5nO1xuICBwcm90ZWN0ZWQgX3ZhbGlkYXRlOiBib29sZWFuO1xuICBwdWJsaWMgcmVhZG9ubHkgY29va2llc1Byb3BhZ2F0aW9uRW5hYmxlZDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXM6IEJpdEdvQVBJT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5jb29raWVzUHJvcGFnYXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgaWYgKFxuICAgICAgIWNvbW1vbi52YWxpZGF0ZVBhcmFtcyhcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBbXSxcbiAgICAgICAgW1xuICAgICAgICAgICdhY2Nlc3NUb2tlbicsXG4gICAgICAgICAgJ3VzZXJBZ2VudCcsXG4gICAgICAgICAgJ2N1c3RvbVJvb3RVUkknLFxuICAgICAgICAgICdjdXN0b21CaXRjb2luTmV0d29yaycsXG4gICAgICAgICAgJ3NlcnZlclhwdWInLFxuICAgICAgICAgICdzdGVsbGFyRmVkZXJhdGlvblNlcnZlclVybCcsXG4gICAgICAgIF1cbiAgICAgICkgfHxcbiAgICAgIChwYXJhbXMudXNlUHJvZHVjdGlvbiAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLnVzZVByb2R1Y3Rpb24pKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2Ugb3BlcmF0ZSBvbiB0aGUgdGVzdCBzZXJ2ZXIuXG4gICAgLy8gRGVwcmVjYXRlIHVzZVByb2R1Y3Rpb24gaW4gdGhlIGZ1dHVyZVxuICAgIGxldCBlbnY6IEVudmlyb25tZW50TmFtZTtcblxuICAgIGlmIChwYXJhbXMudXNlUHJvZHVjdGlvbikge1xuICAgICAgaWYgKHBhcmFtcy5lbnYgJiYgcGFyYW1zLmVudiAhPT0gJ3Byb2QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHVzZSB1c2VQcm9kdWN0aW9uIHdoZW4gZW52PScgKyBwYXJhbXMuZW52KTtcbiAgICAgIH1cbiAgICAgIGVudiA9ICdwcm9kJztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgcGFyYW1zLmN1c3RvbVJvb3RVUkkgfHxcbiAgICAgIHBhcmFtcy5jdXN0b21CaXRjb2luTmV0d29yayB8fFxuICAgICAgcGFyYW1zLmN1c3RvbVNpZ25pbmdBZGRyZXNzIHx8XG4gICAgICBwYXJhbXMuc2VydmVyWHB1YiB8fFxuICAgICAgcHJvY2Vzcy5lbnYuQklUR09fQ1VTVE9NX1JPT1RfVVJJIHx8XG4gICAgICBwcm9jZXNzLmVudi5CSVRHT19DVVNUT01fQklUQ09JTl9ORVRXT1JLXG4gICAgKSB7XG4gICAgICAvLyBmb3IgYnJhbmNoIGRlcGxveXMsIHdlIHdhbnQgdG8gYmUgYWJsZSB0byBzcGVjaWZ5IGN1c3RvbSBlbmRwb2ludHMgd2hpbGUgc3RpbGxcbiAgICAgIC8vIG1haW50YWluaW5nIHRoZSBuYW1lIG9mIHNwZWNpZmllZCB0aGUgZW52aXJvbm1lbnRcbiAgICAgIGVudiA9IHBhcmFtcy5lbnYgPT09ICdicmFuY2gnID8gJ2JyYW5jaCcgOiAnY3VzdG9tJztcbiAgICAgIGlmIChwYXJhbXMuY3VzdG9tUm9vdFVSSSkge1xuICAgICAgICBjb21tb24uRW52aXJvbm1lbnRzW2Vudl0udXJpID0gcGFyYW1zLmN1c3RvbVJvb3RVUkk7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLmN1c3RvbUJpdGNvaW5OZXR3b3JrKSB7XG4gICAgICAgIGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS5uZXR3b3JrID0gcGFyYW1zLmN1c3RvbUJpdGNvaW5OZXR3b3JrO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5jdXN0b21TaWduaW5nQWRkcmVzcykge1xuICAgICAgICAoY29tbW9uLkVudmlyb25tZW50c1tlbnZdIGFzIGFueSkuY3VzdG9tU2lnbmluZ0FkZHJlc3MgPSBwYXJhbXMuY3VzdG9tU2lnbmluZ0FkZHJlc3M7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnNlcnZlclhwdWIpIHtcbiAgICAgICAgY29tbW9uLkVudmlyb25tZW50c1tlbnZdLnNlcnZlclhwdWIgPSBwYXJhbXMuc2VydmVyWHB1YjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuc3RlbGxhckZlZGVyYXRpb25TZXJ2ZXJVcmwpIHtcbiAgICAgICAgY29tbW9uLkVudmlyb25tZW50c1tlbnZdLnN0ZWxsYXJGZWRlcmF0aW9uU2VydmVyVXJsID0gcGFyYW1zLnN0ZWxsYXJGZWRlcmF0aW9uU2VydmVyVXJsO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5jb29raWVzUHJvcGFnYXRpb25FbmFibGVkKSB7XG4gICAgICAgIHRoaXMuY29va2llc1Byb3BhZ2F0aW9uRW5hYmxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudiA9IHBhcmFtcy5lbnYgfHwgKHByb2Nlc3MuZW52LkJJVEdPX0VOViBhcyBFbnZpcm9ubWVudE5hbWUpO1xuICAgIH1cblxuICAgIC8vIGlmIHRoaXMgaGFzbid0IGJlZW4gc2V0IHRvIHRydWUgYWxyZWFkeSBzb21lIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXRcbiAgICBpZiAocGFyYW1zLmNvb2tpZXNQcm9wYWdhdGlvbkVuYWJsZWQgJiYgIXRoaXMuY29va2llc1Byb3BhZ2F0aW9uRW5hYmxlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb29raWVzIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiBjdXN0b20gVVJJcyBhcmUgaW4gdXNlJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5hdXRoVmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9hdXRoVmVyc2lvbiA9IHBhcmFtcy5hdXRoVmVyc2lvbjtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGlzIGVudiBpcyBhbiBhbGlhcywgc3dhcCBpdCBvdXQgd2l0aCB0aGUgZXF1aXZhbGVudCBzdXBwb3J0ZWQgZW52aXJvbm1lbnRcbiAgICBpZiAoZW52IGluIEFsaWFzRW52aXJvbm1lbnRzKSB7XG4gICAgICBlbnYgPSBBbGlhc0Vudmlyb25tZW50c1tlbnZdO1xuICAgIH1cblxuICAgIGlmIChlbnYgPT09ICdjdXN0b20nICYmIF8uaXNVbmRlZmluZWQoY29tbW9uLkVudmlyb25tZW50c1tlbnZdLnVyaSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ211c3QgdXNlIC0tY3VzdG9tcm9vdHVyaSBvciBzZXQgdGhlIEJJVEdPX0NVU1RPTV9ST09UX1VSSSBlbnZpcm9ubWVudCB2YXJpYWJsZSB3aGVuIHVzaW5nIHRoZSBjdXN0b20gZW52aXJvbm1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChlbnYpIHtcbiAgICAgIGlmIChjb21tb24uRW52aXJvbm1lbnRzW2Vudl0pIHtcbiAgICAgICAgdGhpcy5fYmFzZVVybCA9IGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS51cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW52aXJvbm1lbnQgJyArIGVudiArICcuIFN1cHBvcnRlZCBlbnZpcm9ubWVudHM6IHByb2QsIHRlc3QsIGRldiwgbGF0ZXN0Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudiA9ICd0ZXN0JztcbiAgICAgIGlmICghQml0R29BUEkuX3Rlc3RuZXRXYXJuaW5nTWVzc2FnZSkge1xuICAgICAgICBCaXRHb0FQSS5fdGVzdG5ldFdhcm5pbmdNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5sb2coJ0JpdEdvIFNESyBlbnYgbm90IHNldCAtIGRlZmF1bHRpbmcgdG8gdGVzdCBhdCB0ZXN0LmJpdGdvLmNvbS4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Jhc2VVcmwgPSBjb21tb24uRW52aXJvbm1lbnRzW2Vudl0udXJpO1xuICAgIH1cbiAgICB0aGlzLl9lbnYgPSB0aGlzLmVudiA9IGVudjtcblxuICAgIGNvbnN0IHN1cHBvcnRlZEFwaVRva2VucyA9IFtcbiAgICAgICdldGhlcnNjYW5BcGlUb2tlbicsXG4gICAgICAncG9seWdvbnNjYW5BcGlUb2tlbicsXG4gICAgICAnYXJiaXNjYW5BcGlUb2tlbicsXG4gICAgICAnb3B0aW1pc3RpY0V0aGVyc2NhbkFwaVRva2VuJyxcbiAgICAgICd6a3N5bmNFeHBsb3JlckFwaVRva2VuJyxcbiAgICBdO1xuXG4gICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChzdXBwb3J0ZWRBcGlUb2tlbnMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBjb21tb24uRW52aXJvbm1lbnRzW2Vudl1ba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29tbW9uLnNldE5ldHdvcmsoY29tbW9uLkVudmlyb25tZW50c1tlbnZdLm5ldHdvcmspO1xuXG4gICAgdGhpcy5fYmFzZUFwaVVybCA9IHRoaXMuX2Jhc2VVcmwgKyAnL2FwaS92MSc7XG4gICAgdGhpcy5fYmFzZUFwaVVybFYyID0gdGhpcy5fYmFzZVVybCArICcvYXBpL3YyJztcbiAgICB0aGlzLl90b2tlbiA9IHBhcmFtcy5hY2Nlc3NUb2tlbjtcbiAgICB0aGlzLl91c2VyQWdlbnQgPSBwYXJhbXMudXNlckFnZW50IHx8ICdCaXRHb0pTLWFwaS8nICsgdGhpcy52ZXJzaW9uKCk7XG4gICAgdGhpcy5fcmVxSWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVmcmVzaFRva2VuID0gcGFyYW1zLnJlZnJlc2hUb2tlbjtcbiAgICB0aGlzLl9jbGllbnRJZCA9IHBhcmFtcy5jbGllbnRJZDtcbiAgICB0aGlzLl9jbGllbnRTZWNyZXQgPSBwYXJhbXMuY2xpZW50U2VjcmV0O1xuICAgIHRoaXMuX2tleWNoYWlucyA9IG51bGw7XG4gICAgdGhpcy5fd2FsbGV0cyA9IG51bGw7XG5cbiAgICAvLyB3aGV0aGVyIHRvIHBlcmZvcm0gZXh0cmEgY2xpZW50LXNpZGUgdmFsaWRhdGlvbiBmb3Igc29tZSB0aGluZ3MsIHN1Y2ggYXNcbiAgICAvLyBhZGRyZXNzIHZhbGlkYXRpb24gb3Igc2lnbmF0dXJlIHZhbGlkYXRpb24uIGRlZmF1bHRzIHRvIHRydWUsIGJ1dCBjYW4gYmVcbiAgICAvLyB0dXJuZWQgb2ZmIGJ5IHNldHRpbmcgdG8gZmFsc2UuIGNhbiBhbHNvIGJlIG92ZXJyaWRkZW4gaW5kaXZpZHVhbGx5IGluIHRoZVxuICAgIC8vIGZ1bmN0aW9ucyB0aGF0IHVzZSBpdC5cbiAgICB0aGlzLl92YWxpZGF0ZSA9IHBhcmFtcy52YWxpZGF0ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHBhcmFtcy52YWxpZGF0ZTtcblxuICAgIGlmICghcGFyYW1zLmhtYWNWZXJpZmljYXRpb24gJiYgcGFyYW1zLmhtYWNWZXJpZmljYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKChlbnYgPT0gJ3Byb2QnIHx8IGVudiA9PSAnYWRtaW5Qcm9kJykgJiYgY29tbW9uLkVudmlyb25tZW50c1tlbnZdLmhtYWNWZXJpZmljYXRpb25FbmZvcmNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkaXNhYmxlIHJlcXVlc3QgSE1BQyB2ZXJpZmljYXRpb24gaW4gZW52aXJvbm1lbnQgJHt0aGlzLmdldEVudigpfWApO1xuICAgICAgfVxuICAgICAgZGVidWcoJ0hNQUMgdmVyaWZpY2F0aW9uIGV4cGxpY2l0bHkgZGlzYWJsZWQgYnkgY29uc3RydWN0b3Igb3B0aW9uJyk7XG4gICAgICB0aGlzLl9obWFjVmVyaWZpY2F0aW9uID0gcGFyYW1zLmhtYWNWZXJpZmljYXRpb247XG4gICAgfVxuICAgIGlmICghcGFyYW1zLnByb3h5ICYmIHByb2Nlc3MuZW52LkJJVEdPX1VTRV9QUk9YWSkge1xuICAgICAgcGFyYW1zLnByb3h5ID0gcHJvY2Vzcy5lbnYuQklUR09fVVNFX1BST1hZO1xuICAgIH1cblxuICAgIGlmICgocHJvY2VzcyBhcyBhbnkpLmJyb3dzZXIgJiYgcGFyYW1zLnByb3h5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCB1c2UgaHR0cHMgcHJveHkgcGFyYW1zIHdoaWxlIGluIGJyb3dzZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcm94eSA9IHBhcmFtcy5wcm94eTtcblxuICAgIC8vIGNhcHR1cmUgb3V0ZXIgc3RhY2sgc28gd2UgaGF2ZSB1c2VmdWwgZGVidWcgaW5mb3JtYXRpb24gaWYgZmV0Y2ggY29uc3RhbnRzIGZhaWxzXG4gICAgY29uc3QgZSA9IG5ldyBFcnJvcigpO1xuXG4gICAgLy8gS2ljayBvZmYgZmlyc3QgbG9hZCBvZiBjb25zdGFudHNcbiAgICB0aGlzLmZldGNoQ29uc3RhbnRzKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBtYWtlIHN1cmUgYW4gZXJyb3IgZG9lcyBub3QgdGVybWluYXRlIHRoZSBlbnRpcmUgc2NyaXB0XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCB0byBmZXRjaCBpbml0aWFsIGNsaWVudCBjb25zdGFudHMgZnJvbSBCaXRHbycpO1xuICAgICAgICBkZWJ1ZyhlLnN0YWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBzdXBlcmFnZW50IHJlcXVlc3QgZm9yIHNwZWNpZmllZCBodHRwIG1ldGhvZCBhbmQgVVJMIGNvbmZpZ3VyZWQgdG8gdGhlIFNESyBjb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSBtZXRob2QgLSBodHRwIG1ldGhvZCBmb3IgdGhlIG5ldyByZXF1ZXN0XG4gICAqIEBwYXJhbSB1cmwgLSBVUkwgZm9yIHRoZSBuZXcgcmVxdWVzdFxuICAgKi9cbiAgcHJvdGVjdGVkIGdldEFnZW50UmVxdWVzdChtZXRob2Q6ICh0eXBlb2YgcGF0Y2hlZFJlcXVlc3RNZXRob2RzKVtudW1iZXJdLCB1cmw6IHN0cmluZyk6IHN1cGVyYWdlbnQuU3VwZXJBZ2VudFJlcXVlc3Qge1xuICAgIGxldCByZXE6IHN1cGVyYWdlbnQuU3VwZXJBZ2VudFJlcXVlc3QgPSBzdXBlcmFnZW50W21ldGhvZF0odXJsKTtcbiAgICBpZiAodGhpcy5jb29raWVzUHJvcGFnYXRpb25FbmFibGVkKSB7XG4gICAgICByZXEgPSByZXEud2l0aENyZWRlbnRpYWxzKCk7XG4gICAgfVxuICAgIHJldHVybiByZXE7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJhc2Vjb2luIG9iamVjdFxuICAgKiBAcGFyYW0gbmFtZVxuICAgKi9cbiAgcHVibGljIGNvaW4obmFtZTogc3RyaW5nKTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBHbG9iYWxDb2luRmFjdG9yeS5nZXRJbnN0YW5jZSh0aGlzLCBuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgQml0R28gZW52aXJvbm1lbnRcbiAgICovXG4gIGdldEVudigpOiBFbnZpcm9ubWVudE5hbWUge1xuICAgIHJldHVybiB0aGlzLl9lbnY7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IGF1dGggdmVyc2lvbiB1c2VkIGZvciByZXF1ZXN0cyB0byB0aGUgQml0R28gc2VydmVyXG4gICAqL1xuICBnZXRBdXRoVmVyc2lvbigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9hdXRoVmVyc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgcGF0Y2hpbmcgZnVuY3Rpb24gd2hpY2ggY2FuIGFwcGx5IG91ciBhdXRob3JpemF0aW9uXG4gICAqIGhlYWRlcnMgdG8gYW55IG91dGJvdW5kIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBtZXRob2RcbiAgICovXG4gIHByaXZhdGUgcmVxdWVzdFBhdGNoKG1ldGhvZDogKHR5cGVvZiBwYXRjaGVkUmVxdWVzdE1ldGhvZHMpW251bWJlcl0sIHVybDogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVxID0gdGhpcy5nZXRBZ2VudFJlcXVlc3QobWV0aG9kLCB1cmwpO1xuICAgIGlmICh0aGlzLl9wcm94eSAmJiBlbmFibGVQcm94eUFnZW50KSB7XG4gICAgICBkZWJ1ZygncHJveHlpbmcgcmVxdWVzdCB0aHJvdWdoICVzJywgdGhpcy5fcHJveHkpO1xuICAgICAgY29uc3QgcHJveHlVcmw6IHN0cmluZyA9IHRoaXMuX3Byb3h5O1xuICAgICAgY29uc3QgYWdlbnQgPSBuZXcgcHJveHlBZ2VudE1vZHVsZS5Qcm94eUFnZW50KHtcbiAgICAgICAgZ2V0UHJveHlGb3JVcmw6ICgpID0+IHByb3h5VXJsLFxuICAgICAgfSk7XG4gICAgICBpZiAoYWdlbnQpIHtcbiAgICAgICAgcmVxLmFnZW50KGFnZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvcmlnaW5hbFRoZW4gPSByZXEudGhlbi5iaW5kKHJlcSk7XG4gICAgcmVxLnRoZW4gPSAob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpID0+IHtcbiAgICAgIC8vIGludGVyY2VwdCBhIHJlcXVlc3QgYmVmb3JlIGl0J3Mgc3VibWl0dGVkIHRvIHRoZSBzZXJ2ZXIgZm9yIHYyIGF1dGhlbnRpY2F0aW9uIChiYXNlZCBvbiB0b2tlbilcbiAgICAgIGlmICh0aGlzLl92ZXJzaW9uKSB7XG4gICAgICAgIC8vIFRPRE8gLSBkZWNpZGUgd2hlcmUgdG8gZ2V0IHZlcnNpb25cbiAgICAgICAgcmVxLnNldCgnQml0R28tU0RLLVZlcnNpb24nLCB0aGlzLl92ZXJzaW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRoaXMuX3JlcUlkKSkge1xuICAgICAgICByZXEuc2V0KCdSZXF1ZXN0LUlEJywgdGhpcy5fcmVxSWQudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgLy8gaW5jcmVtZW50IGFmdGVyIHNldHRpbmcgdGhlIGhlYWRlciBzbyB0aGUgc2VxdWVuY2UgbnVtYmVycyBzdGFydCBhdCAwXG4gICAgICAgIHRoaXMuX3JlcUlkLmluYygpO1xuXG4gICAgICAgIC8vIHJlcXVlc3QgaWRzIG11c3QgYmUgc2V0IGJlZm9yZSBlYWNoIHJlcXVlc3QgaW5zdGVhZCBvZiBiZWluZyBrZXB0XG4gICAgICAgIC8vIGluc2lkZSB0aGUgYml0Z28gb2JqZWN0LiBUaGlzIGlzIHRvIHByZXZlbnQgcmVlbnRyYW5jeSBpc3N1ZXMgd2hlcmVcbiAgICAgICAgLy8gbXVsdGlwbGUgc2ltdWx0YW5lb3VzIHJlcXVlc3RzIGNvdWxkIGNhdXNlIGluY29ycmVjdCByZXFJZHMgdG8gYmUgdXNlZFxuICAgICAgICBkZWxldGUgdGhpcy5fcmVxSWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHByZXZlbnQgSUUgZnJvbSBjYWNoaW5nIHJlcXVlc3RzXG4gICAgICByZXEuc2V0KCdJZi1Nb2RpZmllZC1TaW5jZScsICdNb24sIDI2IEp1bCAxOTk3IDA1OjAwOjAwIEdNVCcpO1xuXG4gICAgICBpZiAoIShwcm9jZXNzIGFzIGFueSkuYnJvd3NlciAmJiB0aGlzLl91c2VyQWdlbnQpIHtcbiAgICAgICAgLy8gSWYgbm90IGluIHRoZSBicm93c2VyLCBzZXQgdGhlIFVzZXItQWdlbnQuIEJyb3dzZXJzIGRvbid0IGFsbG93XG4gICAgICAgIC8vIHNldHRpbmcgb2YgVXNlci1BZ2VudCwgc28gd2UgbXVzdCBkaXNhYmxlIHRoaXMgd2hlbiBydW4gaW4gdGhlXG4gICAgICAgIC8vIGJyb3dzZXIgKGJyb3dzZXJpZnkgc2V0cyBwcm9jZXNzLmJyb3dzZXIpLlxuICAgICAgICByZXEuc2V0KCdVc2VyLUFnZW50JywgdGhpcy5fdXNlckFnZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgdG8ganVzdCBhYm92ZSA1IG1pbnV0ZXMgYnkgZGVmYXVsdFxuICAgICAgcmVxLnRpbWVvdXQoKHByb2Nlc3MuZW52LkJJVEdPX1RJTUVPVVQgYXMgYW55KSAqIDEwMDAgfHwgMzA1ICogMTAwMCk7XG5cbiAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIHRva2VuLCBhbmQgd2UncmUgbm90IGxvZ2dlZCBpbiwgdGhlIHJlcXVlc3QgY2Fubm90IGJlIHYyIGF1dGhlbnRpY2F0ZWRcbiAgICAgIHJlcS5pc1YyQXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgICByZXEuYXV0aGVudGljYXRpb25Ub2tlbiA9IHRoaXMuX3Rva2VuO1xuICAgICAgLy8gc29tZSBvZiB0aGUgb2xkZXIgdG9rZW5zIGFwcGVhciB0byBiZSBvbmx5IDQwIGNoYXJhY3RlcnMgbG9uZ1xuICAgICAgaWYgKCh0aGlzLl90b2tlbiAmJiB0aGlzLl90b2tlbi5sZW5ndGggIT09IDY3ICYmIHRoaXMuX3Rva2VuLmluZGV4T2YoJ3YyeCcpICE9PSAwKSB8fCByZXEuZm9yY2VWMUF1dGgpIHtcbiAgICAgICAgLy8gdXNlIHRoZSBvbGQgbWV0aG9kXG4gICAgICAgIHJlcS5pc1YyQXV0aGVudGljYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIHJlcS5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyICcgKyB0aGlzLl90b2tlbik7XG4gICAgICAgIGRlYnVnKCdzZW5kaW5nIHYxICVzIHJlcXVlc3QgdG8gJXMgd2l0aCB0b2tlbiAlcycsIG1ldGhvZCwgdXJsLCB0aGlzLl90b2tlbj8uc3Vic3RyKDAsIDgpKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsVGhlbihvbmZ1bGZpbGxlZCkuY2F0Y2gob25yZWplY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHJlcS5zZXQoJ0JpdEdvLUF1dGgtVmVyc2lvbicsIHRoaXMuX2F1dGhWZXJzaW9uID09PSAzID8gJzMuMCcgOiAnMi4wJyk7XG5cbiAgICAgIGlmICh0aGlzLl90b2tlbikge1xuICAgICAgICBjb25zdCBkYXRhID0gc2VyaWFsaXplUmVxdWVzdERhdGEocmVxKTtcbiAgICAgICAgc2V0UmVxdWVzdFF1ZXJ5U3RyaW5nKHJlcSk7XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdFByb3BlcnRpZXMgPSB0aGlzLmNhbGN1bGF0ZVJlcXVlc3RIZWFkZXJzKHtcbiAgICAgICAgICB1cmw6IHJlcS51cmwsXG4gICAgICAgICAgdG9rZW46IHRoaXMuX3Rva2VuLFxuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICB0ZXh0OiBkYXRhIHx8ICcnLFxuICAgICAgICB9KTtcbiAgICAgICAgcmVxLnNldCgnQXV0aC1UaW1lc3RhbXAnLCByZXF1ZXN0UHJvcGVydGllcy50aW1lc3RhbXAudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgLy8gd2UncmUgbm90IHNlbmRpbmcgdGhlIGFjdHVhbCB0b2tlbiwgYnV0IG9ubHkgaXRzIGhhc2hcbiAgICAgICAgcmVxLnNldCgnQXV0aG9yaXphdGlvbicsICdCZWFyZXIgJyArIHJlcXVlc3RQcm9wZXJ0aWVzLnRva2VuSGFzaCk7XG4gICAgICAgIGRlYnVnKCdzZW5kaW5nIHYyICVzIHJlcXVlc3QgdG8gJXMgd2l0aCB0b2tlbiAlcycsIG1ldGhvZCwgdXJsLCB0aGlzLl90b2tlbj8uc3Vic3RyKDAsIDgpKTtcblxuICAgICAgICAvLyBzZXQgdGhlIEhNQUNcbiAgICAgICAgcmVxLnNldCgnSE1BQycsIHJlcXVlc3RQcm9wZXJ0aWVzLmhtYWMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFZlcmlmeSB0aGUgcmVzcG9uc2UgYmVmb3JlIGNhbGxpbmcgdGhlIG9yaWdpbmFsIG9uZnVsZmlsbGVkIGhhbmRsZXIsXG4gICAgICAgKiBhbmQgbWFrZSBzdXJlIG9ucmVqZWN0ZWQgaXMgY2FsbGVkIGlmIGEgdmVyaWZpY2F0aW9uIGVycm9yIGlzIGVuY291bnRlcmVkXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IG5ld09uRnVsZmlsbGVkID0gb25mdWxmaWxsZWRcbiAgICAgICAgPyAocmVzcG9uc2U6IHN1cGVyYWdlbnQuUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIC8vIEhNQUMgdmVyaWZpY2F0aW9uIGlzIG9ubHkgYWxsb3dlZCB0byBiZSBza2lwcGVkIGluIGNlcnRhaW4gZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBjaGVja2VkIGluIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGNoZWNraW5nIGl0IGFnYWluIGF0IHJlcXVlc3QgdGltZVxuICAgICAgICAgICAgLy8gd2lsbCBoZWxwIHByZXZlbnQgYWdhaW5zdCB0YW1wZXJpbmcgb2YgdGhpcyBwcm9wZXJ0eSBhZnRlciB0aGUgb2JqZWN0IGlzIGNyZWF0ZWRcbiAgICAgICAgICAgIGlmICghdGhpcy5faG1hY1ZlcmlmaWNhdGlvbiAmJiAhY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmdldEVudigpXS5obWFjVmVyaWZpY2F0aW9uRW5mb3JjZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9uZnVsZmlsbGVkKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdmVyaWZpZWRSZXNwb25zZSA9IHZlcmlmeVJlc3BvbnNlKHRoaXMsIHRoaXMuX3Rva2VuLCBtZXRob2QsIHJlcSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG9uZnVsZmlsbGVkKHZlcmlmaWVkUmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgOiBudWxsO1xuICAgICAgcmV0dXJuIG9yaWdpbmFsVGhlbihuZXdPbkZ1bGZpbGxlZCkuY2F0Y2gob25yZWplY3RlZCk7XG4gICAgfTtcbiAgICByZXR1cm4gdG9CaXRnb1JlcXVlc3QocmVxKTtcbiAgfVxuXG4gIGdldCh1cmw6IHN0cmluZyk6IEJpdEdvUmVxdWVzdCB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdFBhdGNoKCdnZXQnLCB1cmwpO1xuICB9XG4gIHBvc3QodXJsOiBzdHJpbmcpOiBCaXRHb1JlcXVlc3Qge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RQYXRjaCgncG9zdCcsIHVybCk7XG4gIH1cbiAgcHV0KHVybDogc3RyaW5nKTogQml0R29SZXF1ZXN0IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0UGF0Y2goJ3B1dCcsIHVybCk7XG4gIH1cbiAgZGVsKHVybDogc3RyaW5nKTogQml0R29SZXF1ZXN0IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0UGF0Y2goJ2RlbCcsIHVybCk7XG4gIH1cbiAgcGF0Y2godXJsOiBzdHJpbmcpOiBCaXRHb1JlcXVlc3Qge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RQYXRjaCgncGF0Y2gnLCB1cmwpO1xuICB9XG4gIG9wdGlvbnModXJsOiBzdHJpbmcpOiBCaXRHb1JlcXVlc3Qge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RQYXRjaCgnb3B0aW9ucycsIHVybCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBITUFDIGZvciB0aGUgZ2l2ZW4ga2V5IGFuZCBtZXNzYWdlXG4gICAqIEBwYXJhbSBrZXkge1N0cmluZ30gLSB0aGUga2V5IHRvIHVzZSBmb3IgdGhlIEhNQUNcbiAgICogQHBhcmFtIG1lc3NhZ2Uge1N0cmluZ30gLSB0aGUgYWN0dWFsIG1lc3NhZ2UgdG8gSE1BQ1xuICAgKiBAcmV0dXJucyB7Kn0gLSB0aGUgcmVzdWx0IG9mIHRoZSBITUFDIG9wZXJhdGlvblxuICAgKi9cbiAgY2FsY3VsYXRlSE1BQyhrZXk6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gY3JlYXRlSG1hYygnc2hhMjU2Jywga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCdoZXgnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHN1YmplY3Qgc3RyaW5nIHRoYXQgaXMgdG8gYmUgSE1BQydlZCBmb3IgYSBIVFRQIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAgICogQHBhcmFtIHVybFBhdGggcmVxdWVzdCB1cmwsIGluY2x1ZGluZyBxdWVyeSBwYXJhbXNcbiAgICogQHBhcmFtIHRleHQgcmVxdWVzdCBib2R5IHRleHRcbiAgICogQHBhcmFtIHRpbWVzdGFtcCByZXF1ZXN0IHRpbWVzdGFtcCBmcm9tIGBEYXRlLm5vdygpYFxuICAgKiBAcGFyYW0gc3RhdHVzQ29kZSBPbmx5IHNldCBmb3IgSFRUUCByZXNwb25zZXMsIGxlYXZlIGJsYW5rIGZvciByZXF1ZXN0c1xuICAgKiBAcGFyYW0gbWV0aG9kIHJlcXVlc3QgbWV0aG9kXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBjYWxjdWxhdGVITUFDU3ViamVjdCh7IHVybFBhdGgsIHRleHQsIHRpbWVzdGFtcCwgc3RhdHVzQ29kZSwgbWV0aG9kIH06IENhbGN1bGF0ZUhtYWNTdWJqZWN0T3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3QgdXJsRGV0YWlscyA9IHVybExpYi5wYXJzZSh1cmxQYXRoKTtcbiAgICBjb25zdCBxdWVyeVBhdGggPSB1cmxEZXRhaWxzLnF1ZXJ5ICYmIHVybERldGFpbHMucXVlcnkubGVuZ3RoID4gMCA/IHVybERldGFpbHMucGF0aCA6IHVybERldGFpbHMucGF0aG5hbWU7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHN0YXR1c0NvZGUpICYmIF8uaXNJbnRlZ2VyKHN0YXR1c0NvZGUpICYmIF8uaXNGaW5pdGUoc3RhdHVzQ29kZSkpIHtcbiAgICAgIGlmICh0aGlzLl9hdXRoVmVyc2lvbiA9PT0gMykge1xuICAgICAgICByZXR1cm4gW21ldGhvZC50b1VwcGVyQ2FzZSgpLCB0aW1lc3RhbXAsIHF1ZXJ5UGF0aCwgc3RhdHVzQ29kZSwgdGV4dF0uam9pbignfCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0aW1lc3RhbXAsIHF1ZXJ5UGF0aCwgc3RhdHVzQ29kZSwgdGV4dF0uam9pbignfCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYXV0aFZlcnNpb24gPT09IDMpIHtcbiAgICAgIHJldHVybiBbbWV0aG9kLnRvVXBwZXJDYXNlKCksIHRpbWVzdGFtcCwgJzMuMCcsIHF1ZXJ5UGF0aCwgdGV4dF0uam9pbignfCcpO1xuICAgIH1cbiAgICByZXR1cm4gW3RpbWVzdGFtcCwgcXVlcnlQYXRoLCB0ZXh0XS5qb2luKCd8Jyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBITUFDIGZvciBhbiBIVFRQIHJlcXVlc3RcbiAgICovXG4gIGNhbGN1bGF0ZVJlcXVlc3RITUFDKHsgdXJsOiB1cmxQYXRoLCB0ZXh0LCB0aW1lc3RhbXAsIHRva2VuLCBtZXRob2QgfTogQ2FsY3VsYXRlUmVxdWVzdEhtYWNPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCBzaWduYXR1cmVTdWJqZWN0ID0gdGhpcy5jYWxjdWxhdGVITUFDU3ViamVjdCh7IHVybFBhdGgsIHRleHQsIHRpbWVzdGFtcCwgbWV0aG9kIH0pO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBITUFDXG4gICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlSE1BQyh0b2tlbiwgc2lnbmF0dXJlU3ViamVjdCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHJlcXVlc3QgaGVhZGVycyB3aXRoIEhNQUNcbiAgICovXG4gIGNhbGN1bGF0ZVJlcXVlc3RIZWFkZXJzKHsgdXJsLCB0ZXh0LCB0b2tlbiwgbWV0aG9kIH06IENhbGN1bGF0ZVJlcXVlc3RIZWFkZXJzT3B0aW9ucyk6IFJlcXVlc3RIZWFkZXJzIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGhtYWMgPSB0aGlzLmNhbGN1bGF0ZVJlcXVlc3RITUFDKHsgdXJsLCB0ZXh0LCB0aW1lc3RhbXAsIHRva2VuLCBtZXRob2QgfSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIFNIQTI1NiBoYXNoIG9mIHRoZSB0b2tlblxuICAgIGNvbnN0IGhhc2hEaWdlc3QgPSBzamNsLmhhc2guc2hhMjU2Lmhhc2godG9rZW4pO1xuICAgIGNvbnN0IHRva2VuSGFzaCA9IHNqY2wuY29kZWMuaGV4LmZyb21CaXRzKGhhc2hEaWdlc3QpO1xuICAgIHJldHVybiB7XG4gICAgICBobWFjLFxuICAgICAgdGltZXN0YW1wLFxuICAgICAgdG9rZW5IYXNoLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoZSBITUFDIGZvciBhbiBIVFRQIHJlc3BvbnNlXG4gICAqL1xuICB2ZXJpZnlSZXNwb25zZSh7XG4gICAgdXJsOiB1cmxQYXRoLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgdGV4dCxcbiAgICB0aW1lc3RhbXAsXG4gICAgdG9rZW4sXG4gICAgaG1hYyxcbiAgICBtZXRob2QsXG4gIH06IFZlcmlmeVJlc3BvbnNlT3B0aW9ucyk6IFZlcmlmeVJlc3BvbnNlSW5mbyB7XG4gICAgY29uc3Qgc2lnbmF0dXJlU3ViamVjdCA9IHRoaXMuY2FsY3VsYXRlSE1BQ1N1YmplY3Qoe1xuICAgICAgdXJsUGF0aCxcbiAgICAgIHRleHQsXG4gICAgICB0aW1lc3RhbXAsXG4gICAgICBzdGF0dXNDb2RlLFxuICAgICAgbWV0aG9kLFxuICAgIH0pO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBITUFDXG4gICAgY29uc3QgZXhwZWN0ZWRIbWFjID0gdGhpcy5jYWxjdWxhdGVITUFDKHRva2VuLCBzaWduYXR1cmVTdWJqZWN0KTtcblxuICAgIC8vIGRldGVybWluZSBpZiB0aGUgcmVzcG9uc2UgaXMgc3RpbGwgd2l0aGluIHRoZSB2YWxpZGl0eSB3aW5kb3cgKDUgbWludXRlIHdpbmRvdylcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGlzSW5SZXNwb25zZVZhbGlkaXR5V2luZG93ID0gdGltZXN0YW1wID49IG5vdyAtIDEwMDAgKiA2MCAqIDUgJiYgdGltZXN0YW1wIDw9IG5vdztcblxuICAgIC8vIHZlcmlmeSB0aGUgSE1BQyBhbmQgdGltZXN0YW1wXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGV4cGVjdGVkSG1hYyA9PT0gaG1hYyxcbiAgICAgIGV4cGVjdGVkSG1hYyxcbiAgICAgIHNpZ25hdHVyZVN1YmplY3QsXG4gICAgICBpc0luUmVzcG9uc2VWYWxpZGl0eVdpbmRvdyxcbiAgICAgIHZlcmlmaWNhdGlvblRpbWU6IG5vdyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHVzZWZ1bCBjb25zdGFudCB2YWx1ZXMgZnJvbSB0aGUgQml0R28gc2VydmVyLlxuICAgKiBUaGVzZSB2YWx1ZXMgZG8gY2hhbmdlIGluZnJlcXVlbnRseSwgc28gdGhleSBuZWVkIHRvIGJlIGZldGNoZWQsXG4gICAqIGJ1dCBhcmUgdW5saWtlbHkgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgYSBCaXRHbyBvYmplY3QsXG4gICAqIHNvIHRoZXkgY2FuIHNhZmVseSBjYWNoZWQuXG4gICAqL1xuICBhc3luYyBmZXRjaENvbnN0YW50cygpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IGVudiA9IHRoaXMuZ2V0RW52KCk7XG5cbiAgICBpZiAoIUJpdEdvQVBJLl9jb25zdGFudHMpIHtcbiAgICAgIEJpdEdvQVBJLl9jb25zdGFudHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKCFCaXRHb0FQSS5fY29uc3RhbnRzRXhwaXJlKSB7XG4gICAgICBCaXRHb0FQSS5fY29uc3RhbnRzRXhwaXJlID0ge307XG4gICAgfVxuXG4gICAgaWYgKEJpdEdvQVBJLl9jb25zdGFudHNbZW52XSAmJiBCaXRHb0FQSS5fY29uc3RhbnRzRXhwaXJlW2Vudl0gJiYgbmV3IERhdGUoKSA8IEJpdEdvQVBJLl9jb25zdGFudHNFeHBpcmVbZW52XSkge1xuICAgICAgcmV0dXJuIEJpdEdvQVBJLl9jb25zdGFudHNbZW52XTtcbiAgICB9XG5cbiAgICAvLyBjbGllbnQgY29uc3RhbnRzIGNhbGwgY2Fubm90IGJlIGF1dGhlbnRpY2F0ZWQgdXNpbmcgdGhlIG5vcm1hbCBITUFDIHZhbGlkYXRpb25cbiAgICAvLyBzY2hlbWUsIHNvIHdlIG5lZWQgdG8gdXNlIGEgcmF3IHN1cGVyYWdlbnQgaW5zdGFuY2UgdG8gZG8gdGhpcyByZXF1ZXN0LlxuICAgIC8vIFByb3h5IHNldHRpbmdzIG11c3Qgc3RpbGwgYmUgcmVzcGVjdGVkIGhvd2V2ZXJcbiAgICBjb25zdCByZXN1bHRQcm9taXNlID0gdGhpcy5nZXRBZ2VudFJlcXVlc3QoJ2dldCcsIHRoaXMudXJsKCcvY2xpZW50L2NvbnN0YW50cycpKTtcbiAgICByZXN1bHRQcm9taXNlLnNldCgnQml0R28tU0RLLVZlcnNpb24nLCB0aGlzLl92ZXJzaW9uKTtcbiAgICBpZiAodGhpcy5fcHJveHkgJiYgZW5hYmxlUHJveHlBZ2VudCkge1xuICAgICAgY29uc3QgcHJveHlVcmw6IHN0cmluZyA9IHRoaXMuX3Byb3h5O1xuICAgICAgY29uc3QgYWdlbnQgPSBuZXcgcHJveHlBZ2VudE1vZHVsZS5Qcm94eUFnZW50KHtcbiAgICAgICAgZ2V0UHJveHlGb3JVcmw6ICgpID0+IHByb3h5VXJsLFxuICAgICAgfSk7XG4gICAgICBpZiAoYWdlbnQpIHtcbiAgICAgICAgcmVzdWx0UHJvbWlzZS5hZ2VudChhZ2VudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3VsdFByb21pc2U7XG4gICAgQml0R29BUEkuX2NvbnN0YW50c1tlbnZdID0gcmVzdWx0LmJvZHkuY29uc3RhbnRzO1xuXG4gICAgaWYgKHJlc3VsdC5ib2R5Py50dGwgJiYgdHlwZW9mIHJlc3VsdC5ib2R5Py50dGwgPT09ICdudW1iZXInKSB7XG4gICAgICBCaXRHb0FQSS5fY29uc3RhbnRzRXhwaXJlW2Vudl0gPSBuZXcgRGF0ZShuZXcgRGF0ZSgpLmdldFRpbWUoKSArIChyZXN1bHQuYm9keS50dGwgYXMgbnVtYmVyKSAqIDEwMDApO1xuICAgIH1cblxuICAgIHJldHVybiBCaXRHb0FQSS5fY29uc3RhbnRzW2Vudl07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdXJsIGZvciBjYWxsaW5nIEJpdEdvIHBsYXRmb3JtIEFQSXNcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHBhcmFtIHZlcnNpb25cbiAgICovXG4gIHVybChwYXRoOiBzdHJpbmcsIHZlcnNpb24gPSAxKTogc3RyaW5nIHtcbiAgICBjb25zdCBiYXNlVXJsID0gdmVyc2lvbiA9PT0gMiA/IHRoaXMuX2Jhc2VBcGlVcmxWMiA6IHRoaXMuX2Jhc2VBcGlVcmw7XG4gICAgcmV0dXJuIGJhc2VVcmwgKyBwYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHVybCBmb3IgY2FsbGluZyBCaXRHbyBtaWNyb3NlcnZpY2UgQVBJc1xuICAgKi9cbiAgbWljcm9zZXJ2aWNlc1VybChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9iYXNlVXJsICsgcGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2ZXJzaW9uIG9mIHRoZSBCaXRHb0pTIHBhY2thZ2VcbiAgICovXG4gIHZlcnNpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IGNvbm5lY3Rpdml0eSB0byB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIHBpbmcoeyByZXFJZCB9OiBQaW5nT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAocmVxSWQpIHtcbiAgICAgIHRoaXMuX3JlcUlkID0gcmVxSWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKCcvcGluZycpKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSByZXF1ZXN0IHRyYWNlciB0byBwcm92aWRlIHJlcXVlc3QgSURzIGR1cmluZyBtdWx0aS1yZXF1ZXN0IHdvcmtmbG93c1xuICAgKi9cbiAgc2V0UmVxdWVzdFRyYWNlcihyZXFUcmFjZXI6IElSZXF1ZXN0VHJhY2VyKTogdm9pZCB7XG4gICAgaWYgKHJlcVRyYWNlcikge1xuICAgICAgdGhpcy5fcmVxSWQgPSByZXFUcmFjZXI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZW5jcnlwdCBsb2NhbGx5LlxuICAgKi9cbiAgZW5jcnlwdChwYXJhbXM6IEVuY3J5cHRPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2lucHV0JywgJ3Bhc3N3b3JkJ10sIFtdKTtcbiAgICBpZiAoIXBhcmFtcy5wYXNzd29yZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZW5jcnlwdCB3aXRob3V0IHBhc3N3b3JkYCk7XG4gICAgfVxuICAgIHJldHVybiBlbmNyeXB0KHBhcmFtcy5wYXNzd29yZCwgcGFyYW1zLmlucHV0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNyeXB0IGFuIGVuY3J5cHRlZCBzdHJpbmcgbG9jYWxseS5cbiAgICovXG4gIGRlY3J5cHQocGFyYW1zOiBEZWNyeXB0T3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaW5wdXQnLCAncGFzc3dvcmQnXSwgW10pO1xuICAgIGlmICghcGFyYW1zLnBhc3N3b3JkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNyeXB0IHdpdGhvdXQgcGFzc3dvcmRgKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBkZWNyeXB0KHBhcmFtcy5wYXNzd29yZCwgcGFyYW1zLmlucHV0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJjY206IHRhZyBkb2Vzbid0IG1hdGNoXCIpKSB7XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgPSAncGFzc3dvcmQgZXJyb3IgLSAnICsgZXJyb3IubWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhpcyBCaXRHbyBvYmplY3QgdG8gYSBKU09OIG9iamVjdC5cbiAgICpcbiAgICogQ2F1dGlvbjogY29udGFpbnMgc2Vuc2l0aXZlIGRhdGFcbiAgICovXG4gIHRvSlNPTigpOiBCaXRHb0pzb24ge1xuICAgIHJldHVybiB7XG4gICAgICB1c2VyOiB0aGlzLl91c2VyLFxuICAgICAgdG9rZW46IHRoaXMuX3Rva2VuLFxuICAgICAgZXh0ZW5zaW9uS2V5OiB0aGlzLl9leHRlbnNpb25LZXkgPyB0aGlzLl9leHRlbnNpb25LZXkudG9XSUYoKSA6IHVuZGVmaW5lZCxcbiAgICAgIGVjZGhYcHJ2OiB0aGlzLl9lY2RoWHBydixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB1c2VyXG4gICAqL1xuICB1c2VyKCk6IFVzZXIgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgSlNPTiBzZXJpYWxpemVkIEJpdEdvIG9iamVjdC5cbiAgICpcbiAgICogT3ZlcndyaXRlcyB0aGUgcHJvcGVydGllcyBvbiB0aGUgY3VycmVudCBCaXRHbyBvYmplY3Qgd2l0aFxuICAgKiB0aG9zZSBvZiB0aGUgZGVzZXJpYWx6ZWQgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ganNvblxuICAgKi9cbiAgZnJvbUpTT04oanNvbjogQml0R29Kc29uKTogdm9pZCB7XG4gICAgdGhpcy5fdXNlciA9IGpzb24udXNlcjtcbiAgICB0aGlzLl90b2tlbiA9IGpzb24udG9rZW47XG4gICAgdGhpcy5fZWNkaFhwcnYgPSBqc29uLmVjZGhYcHJ2O1xuICAgIGlmIChqc29uLmV4dGVuc2lvbktleSkge1xuICAgICAgY29uc3QgbmV0d29yayA9IGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5nZXRFbnYoKV0ubmV0d29yaztcbiAgICAgIHRoaXMuX2V4dGVuc2lvbktleSA9IHV0eG9saWIuRUNQYWlyLmZyb21XSUYoXG4gICAgICAgIGpzb24uZXh0ZW5zaW9uS2V5LFxuICAgICAgICB1dHhvbGliLm5ldHdvcmtzW25ldHdvcmtdIGFzIHV0eG9saWIuQml0Y29pbkpTTmV0d29ya1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgdXNlcm5hbWUsIHBhc3N3b3JkIGFuZCBvdHAgaW50byBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgdXNlcm5hbWUgYW5kIGhhc2hlZCBwYXNzd29yZCwgcmVhZHkgdG9cbiAgICogc2VuZCB0byBiaXRnbyBmb3IgYXV0aGVudGljYXRpb24uXG4gICAqL1xuICBwcmVwcm9jZXNzQXV0aGVudGljYXRpb25QYXJhbXMoe1xuICAgIHVzZXJuYW1lLFxuICAgIHBhc3N3b3JkLFxuICAgIG90cCxcbiAgICBmb3JjZVNNUyxcbiAgICBleHRlbnNpYmxlLFxuICAgIHRydXN0LFxuICAgIGZvclJlc2V0MkZBLFxuICB9OiBBdXRoZW50aWNhdGVPcHRpb25zKTogUHJvY2Vzc2VkQXV0aGVudGljYXRpb25PcHRpb25zIHtcbiAgICBpZiAoIV8uaXNTdHJpbmcodXNlcm5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyB1c2VybmFtZScpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhwYXNzd29yZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgc3RyaW5nIHBhc3N3b3JkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbG93ZXJOYW1lID0gdXNlcm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHBhc3N3b3JkIEhNQUMgc28gd2UgZG9uJ3Qgc2VuZCBjbGVhci10ZXh0IHBhc3N3b3Jkc1xuICAgIGNvbnN0IGhtYWNQYXNzd29yZCA9IHRoaXMuY2FsY3VsYXRlSE1BQyhsb3dlck5hbWUsIHBhc3N3b3JkKTtcblxuICAgIGNvbnN0IGF1dGhQYXJhbXM6IFByb2Nlc3NlZEF1dGhlbnRpY2F0aW9uT3B0aW9ucyA9IHtcbiAgICAgIGVtYWlsOiBsb3dlck5hbWUsXG4gICAgICBwYXNzd29yZDogaG1hY1Bhc3N3b3JkLFxuICAgICAgZm9yY2VTTVM6ICEhZm9yY2VTTVMsXG4gICAgfTtcblxuICAgIGlmIChvdHApIHtcbiAgICAgIGF1dGhQYXJhbXMub3RwID0gb3RwO1xuICAgICAgaWYgKHRydXN0KSB7XG4gICAgICAgIGF1dGhQYXJhbXMudHJ1c3QgPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRlbnNpYmxlKSB7XG4gICAgICB0aGlzLl9leHRlbnNpb25LZXkgPSBtYWtlUmFuZG9tS2V5KCk7XG4gICAgICBhdXRoUGFyYW1zLmV4dGVuc2libGUgPSB0cnVlO1xuICAgICAgYXV0aFBhcmFtcy5leHRlbnNpb25BZGRyZXNzID0gZ2V0QWRkcmVzc1AyUEtIKHRoaXMuX2V4dGVuc2lvbktleSk7XG4gICAgfVxuXG4gICAgaWYgKGZvclJlc2V0MkZBKSB7XG4gICAgICBhdXRoUGFyYW1zLmZvclJlc2V0MkZBID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXV0aFBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbm91cyBtZXRob2QgZm9yIGFjdGl2YXRpbmcgYW4gYWNjZXNzIHRva2VuLlxuICAgKi9cbiAgYXV0aGVudGljYXRlV2l0aEFjY2Vzc1Rva2VuKHsgYWNjZXNzVG9rZW4gfTogQWNjZXNzVG9rZW5PcHRpb25zKTogdm9pZCB7XG4gICAgZGVidWcoJ25vdyBhdXRoZW50aWNhdGluZyB3aXRoIGFjY2VzcyB0b2tlbiAlcycsIGFjY2Vzc1Rva2VuLnN1YnN0cmluZygwLCA4KSk7XG4gICAgdGhpcy5fdG9rZW4gPSBhY2Nlc3NUb2tlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEVDREgga2V5Y2hhaW4gZm9yIHRoZSB1c2VyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9naW5QYXNzd29yZCAtIFRoZSB1c2VyJ3MgbG9naW4gcGFzc3dvcmQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbmV3IEVDREgga2V5Y2hhaW4gZGF0YS5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGlzIGFuIGlzc3VlIGNyZWF0aW5nIHRoZSBrZXljaGFpbi5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBjcmVhdGVVc2VyRWNkaEtleWNoYWluKGxvZ2luUGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3Qga2V5RGF0YSA9IHRoaXMua2V5Y2hhaW5zKCkuY3JlYXRlKCk7XG4gICAgY29uc3QgaGROb2RlID0gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OChrZXlEYXRhLnhwcnYpO1xuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBuZXcgRUNESCBrZXljaGFpbiB0byB0aGUgdXNlcidzIGFjY291bnQuXG4gICAgICogQHR5cGUge1Byb21pc2U8YW55Pn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBuZXcgRUNESCBrZXljaGFpbi5cbiAgICAgKi9cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5rZXljaGFpbnMoKS5hZGQoe1xuICAgICAgc291cmNlOiAnZWNkaCcsXG4gICAgICB4cHViOiBoZE5vZGUubmV1dGVyZWQoKS50b0Jhc2U1OCgpLFxuICAgICAgZW5jcnlwdGVkWHBydjogdGhpcy5lbmNyeXB0KHtcbiAgICAgICAgcGFzc3dvcmQ6IGxvZ2luUGFzc3dvcmQsXG4gICAgICAgIGlucHV0OiBoZE5vZGUudG9CYXNlNTgoKSxcbiAgICAgIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHVzZXIncyBzZXR0aW5ncyB3aXRoIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgdG8gdXBkYXRlIHRoZSB1c2VyJ3Mgc2V0dGluZ3Mgd2l0aC5cbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICogQHRocm93cyB7RXJyb3J9IC0gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGlzIGFuIGlzc3VlIHVwZGF0aW5nIHRoZSB1c2VyJ3Mgc2V0dGluZ3MuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHVwZGF0ZVVzZXJTZXR0aW5ncyhwYXJhbXM6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMucHV0KHRoaXMudXJsKCcvdXNlci9zZXR0aW5ncycsIDIpKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IHRoZSB1c2VyJ3MgRUNESCBrZXljaGFpbiBpcyBjcmVhdGVkIGZvciB3YWxsZXQgc2hhcmluZyBhbmQgVFNTIHdhbGxldHMuXG4gICAqIElmIHRoZSBrZXljaGFpbiBkb2VzIG5vdCBleGlzdCwgaXQgd2lsbCBiZSBjcmVhdGVkIGFuZCB0aGUgdXNlcidzIHNldHRpbmdzIHdpbGwgYmUgdXBkYXRlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvZ2luUGFzc3dvcmQgLSBUaGUgdXNlcidzIGxvZ2luIHBhc3N3b3JkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHVzZXIncyBzZXR0aW5ncyBlbnN1cmluZyB3ZSBoYXZlIHRoZSBlY2RoS2V5Y2hhaW4gaW4gdGhlcmUuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBpcyBhbiBpc3N1ZSBjcmVhdGluZyB0aGUga2V5Y2hhaW4gb3IgdXBkYXRpbmcgdGhlIHVzZXIncyBzZXR0aW5ncy5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZW5zdXJlVXNlckVjZGhLZXljaGFpbklzQ3JlYXRlZChsb2dpblBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdXNlcidzIGN1cnJlbnQgc2V0dGluZ3MuXG4gICAgICovXG4gICAgY29uc3QgdXNlclNldHRpbmdzID0gYXdhaXQgdGhpcy5nZXQodGhpcy51cmwoJy91c2VyL3NldHRpbmdzJykpLnJlc3VsdCgpO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSB1c2VyJ3MgRUNESCBrZXljaGFpbiBkb2VzIG5vdCBleGlzdCwgY3JlYXRlIGEgbmV3IGtleWNoYWluIGFuZCB1cGRhdGUgdGhlIHVzZXIncyBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICBpZiAoIXVzZXJTZXR0aW5ncy5zZXR0aW5ncy5lY2RoS2V5Y2hhaW4pIHtcbiAgICAgIGNvbnN0IG5ld0tleWNoYWluID0gYXdhaXQgdGhpcy5jcmVhdGVVc2VyRWNkaEtleWNoYWluKGxvZ2luUGFzc3dvcmQpO1xuICAgICAgYXdhaXQgdGhpcy51cGRhdGVVc2VyU2V0dGluZ3Moe1xuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGVjZGhLZXljaGFpbjogbmV3S2V5Y2hhaW4ueHB1YixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGUgdGhlIHVzZXIncyBzZXR0aW5ncyBvYmplY3Qgd2l0aCB0aGUgbmV3IEVDREgga2V5Y2hhaW4uXG4gICAgICAgKi9cbiAgICAgIHVzZXJTZXR0aW5ncy5zZXR0aW5ncy5lY2RoS2V5Y2hhaW4gPSBuZXdLZXljaGFpbi54cHViO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHVzZXIncyBFQ0RIIGtleWNoYWluIHNldHRpbmdzLlxuICAgICAqL1xuICAgIHJldHVybiB1c2VyU2V0dGluZ3Muc2V0dGluZ3M7XG4gIH1cblxuICAvKipcbiAgICogTG9naW4gdG8gdGhlIGJpdGdvIHBsYXRmb3JtLlxuICAgKi9cbiAgYXN5bmMgYXV0aGVudGljYXRlKHBhcmFtczogQXV0aGVudGljYXRlT3B0aW9ucyk6IFByb21pc2U8TG9naW5SZXNwb25zZSB8IGFueT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIG9iamVjdCBwYXJhbXMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wYXNzd29yZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgcGFzc3dvcmQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9yY2VWMUF1dGggPSAhIXBhcmFtcy5mb3JjZVYxQXV0aDtcbiAgICAgIGNvbnN0IGF1dGhQYXJhbXMgPSB0aGlzLnByZXByb2Nlc3NBdXRoZW50aWNhdGlvblBhcmFtcyhwYXJhbXMpO1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSBwYXJhbXMucGFzc3dvcmQ7XG5cbiAgICAgIGlmICh0aGlzLl90b2tlbikge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdhbHJlYWR5IGxvZ2dlZCBpbicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdXRoVXJsID0gdGhpcy5taWNyb3NlcnZpY2VzVXJsKCcvYXBpL2F1dGgvdjEvc2Vzc2lvbicpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMucG9zdChhdXRoVXJsKTtcblxuICAgICAgaWYgKGZvcmNlVjFBdXRoKSB7XG4gICAgICAgIHJlcXVlc3QuZm9yY2VWMUF1dGggPSB0cnVlO1xuICAgICAgICAvLyB0ZWxsIHRoZSBzZXJ2ZXIgdGhhdCB0aGUgY2xpZW50IHdhcyBmb3JjZWQgdG8gZG93bmdyYWRlIHRoZSBhdXRoZW50aWNhdGlvbiBwcm90b2NvbFxuICAgICAgICBhdXRoUGFyYW1zLmZvcmNlVjFBdXRoID0gdHJ1ZTtcbiAgICAgICAgZGVidWcoJ2ZvcmNpbmcgdjEgYXV0aCBmb3IgY2FsbCB0byBhdXRoZW50aWNhdGUnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlOiBzdXBlcmFnZW50LlJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5zZW5kKGF1dGhQYXJhbXMpO1xuICAgICAgLy8gZXh0cmFjdCBib2R5IGFuZCB1c2VyIGluZm9ybWF0aW9uXG4gICAgICBjb25zdCBib2R5ID0gcmVzcG9uc2UuYm9keTtcbiAgICAgIHRoaXMuX3VzZXIgPSBib2R5LnVzZXI7XG5cbiAgICAgIGlmIChib2R5LmFjY2Vzc190b2tlbikge1xuICAgICAgICB0aGlzLl90b2tlbiA9IGJvZHkuYWNjZXNzX3Rva2VuO1xuICAgICAgICAvLyBpZiB0aGUgZG93bmdyYWRlIHdhcyBmb3JjZWQsIGFkZGluZyBhIHdhcm5pbmcgbWVzc2FnZSBtaWdodCBiZSBwcnVkZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjaGVjayB0aGUgcHJlc2VuY2Ugb2YgYW4gZW5jcnlwdGVkIEVDREggeHBydlxuICAgICAgICAvLyBpZiBub3QgcHJlc2VudCwgbGVnYWN5IGFjY291bnRcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkWHBydiA9IGJvZHkuZW5jcnlwdGVkRUNESFhwcnY7XG4gICAgICAgIGlmICghZW5jcnlwdGVkWHBydikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5Y2hhaW4gbmVlZHMgZW5jcnlwdGVkWHBydiBwcm9wZXJ0eScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2VEZXRhaWxzID0gdGhpcy5oYW5kbGVUb2tlbklzc3VhbmNlKHJlc3BvbnNlLmJvZHksIHBhc3N3b3JkKTtcbiAgICAgICAgdGhpcy5fdG9rZW4gPSByZXNwb25zZURldGFpbHMudG9rZW47XG4gICAgICAgIHRoaXMuX2VjZGhYcHJ2ID0gcmVzcG9uc2VEZXRhaWxzLmVjZGhYcHJ2O1xuXG4gICAgICAgIC8vIHZlcmlmeSB0aGUgcmVzcG9uc2UncyBhdXRoZW50aWNpdHlcbiAgICAgICAgdmVyaWZ5UmVzcG9uc2UodGhpcywgcmVzcG9uc2VEZXRhaWxzLnRva2VuLCAncG9zdCcsIHJlcXVlc3QsIHJlc3BvbnNlKTtcblxuICAgICAgICAvLyBhZGQgdGhlIHJlbWFpbmluZyBjb21wb25lbnQgZm9yIGVhc2llciBhY2Nlc3NcbiAgICAgICAgcmVzcG9uc2UuYm9keS5hY2Nlc3NfdG9rZW4gPSB0aGlzLl90b2tlbjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXNlclNldHRpbmdzID0gcGFyYW1zLmVuc3VyZUVjZGhLZXljaGFpbiA/IGF3YWl0IHRoaXMuZW5zdXJlVXNlckVjZGhLZXljaGFpbklzQ3JlYXRlZChwYXNzd29yZCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodXNlclNldHRpbmdzPy5lY2RoS2V5Y2hhaW4pIHtcbiAgICAgICAgcmVzcG9uc2UuYm9keS51c2VyLmVjZGhLZXljaGFpbiA9IHVzZXJTZXR0aW5ncy5lY2RoS2V5Y2hhaW47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYW5kbGVSZXNwb25zZVJlc3VsdDxMb2dpblJlc3BvbnNlPigpKHJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVSZXNwb25zZUVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gcmVzcG9uc2VCb2R5IFJlc3BvbnNlIGJvZHkgb2JqZWN0XG4gICAqIEBwYXJhbSBwYXNzd29yZCBQYXNzd29yZCBmb3IgdGhlIHN5bW1ldHJpYyBkZWNyeXB0aW9uXG4gICAqL1xuICBoYW5kbGVUb2tlbklzc3VhbmNlKHJlc3BvbnNlQm9keTogVG9rZW5Jc3N1YW5jZVJlc3BvbnNlLCBwYXNzd29yZD86IHN0cmluZyk6IFRva2VuSXNzdWFuY2Uge1xuICAgIC8vIG1ha2Ugc3VyZSB0aGUgcmVzcG9uc2UgYm9keSBjb250YWlucyB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocmVzcG9uc2VCb2R5LCBbJ2Rlcml2YXRpb25QYXRoJ10sIFsnZW5jcnlwdGVkRUNESFhwcnYnXSk7XG5cbiAgICBjb25zdCBlbnZpcm9ubWVudCA9IHRoaXMuX2VudjtcbiAgICBjb25zdCBlbnZpcm9ubWVudENvbmZpZyA9IGNvbW1vbi5FbnZpcm9ubWVudHNbZW52aXJvbm1lbnRdO1xuICAgIGNvbnN0IHNlcnZlclhwdWIgPSBlbnZpcm9ubWVudENvbmZpZy5zZXJ2ZXJYcHViO1xuICAgIGxldCBlY2RoWHBydiA9IHRoaXMuX2VjZGhYcHJ2O1xuICAgIGlmICghZWNkaFhwcnYpIHtcbiAgICAgIGlmICghcGFzc3dvcmQgfHwgIXJlc3BvbnNlQm9keS5lbmNyeXB0ZWRFQ0RIWHBydikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VjZGhYcHJ2IHByb3BlcnR5IG11c3QgYmUgc2V0IG9yIHBhc3N3b3JkIGFuZCBlbmNyeXB0ZWQgZW5jcnlwdGVkRUNESFhwcnYgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgZWNkaFhwcnYgPSB0aGlzLmRlY3J5cHQoe1xuICAgICAgICAgIGlucHV0OiByZXNwb25zZUJvZHkuZW5jcnlwdGVkRUNESFhwcnYsXG4gICAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZS5lcnJvckNvZGUgPSAnZWNkaF94cHJ2X2RlY3J5cHRpb25fZmFpbHVyZSc7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IGVuY3J5cHRlZEVDREhYcHJ2LicpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnN0cnVjdCBIRE5vZGUgb2JqZWN0cyBmb3IgY2xpZW50J3MgeHBydiBhbmQgc2VydmVyJ3MgeHB1YlxuICAgIGNvbnN0IGNsaWVudEhETm9kZSA9IGJpcDMyLmZyb21CYXNlNTgoZWNkaFhwcnYpO1xuICAgIGNvbnN0IHNlcnZlckhETm9kZSA9IGJpcDMyLmZyb21CYXNlNTgoc2VydmVyWHB1Yik7XG5cbiAgICAvLyBCSVAzMiBkZXJpdmF0aW9uIHBhdGggaXMgYXBwbGllZCB0byBib3RoIGNsaWVudCBhbmQgc2VydmVyIG1hc3RlciBrZXlzXG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGggPSBzYW5pdGl6ZUxlZ2FjeVBhdGgocmVzcG9uc2VCb2R5LmRlcml2YXRpb25QYXRoKTtcbiAgICBjb25zdCBjbGllbnREZXJpdmVkTm9kZSA9IGNsaWVudEhETm9kZS5kZXJpdmVQYXRoKGRlcml2YXRpb25QYXRoKTtcbiAgICBjb25zdCBzZXJ2ZXJEZXJpdmVkTm9kZSA9IHNlcnZlckhETm9kZS5kZXJpdmVQYXRoKGRlcml2YXRpb25QYXRoKTtcblxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHNlcnZlckRlcml2ZWROb2RlLnB1YmxpY0tleTtcbiAgICBjb25zdCBzZWNyZXRLZXkgPSBjbGllbnREZXJpdmVkTm9kZS5wcml2YXRlS2V5O1xuICAgIGlmICghc2VjcmV0S2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGNsaWVudCBwcml2YXRlIEtleScpO1xuICAgIH1cbiAgICBjb25zdCBzZWNyZXQgPSBCdWZmZXIuZnJvbShcbiAgICAgIC8vIEZJWE1FKEJHLTM0Mzg2KTogd2Ugc2hvdWxkIHVzZSBgc2VjcDI1NmsxLmVjZGgoKWAgaW4gdGhlIGZ1dHVyZVxuICAgICAgLy8gICAgICAgICAgICAgICAgICBzZWUgZGlzY3Vzc2lvbiBoZXJlIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luLWNvcmUvc2VjcDI1NmsxL2lzc3Vlcy8zNTJcbiAgICAgIHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha011bChwdWJsaWNLZXksIHNlY3JldEtleSlcbiAgICApLnRvU3RyaW5nKCdoZXgnKTtcblxuICAgIC8vIGRlY3J5cHQgdG9rZW4gd2l0aCBzeW1tZXRyaWMgRUNESCBrZXlcbiAgICBsZXQgcmVzcG9uc2U6IFRva2VuSXNzdWFuY2U7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICB0b2tlbjogdGhpcy5kZWNyeXB0KHtcbiAgICAgICAgICBpbnB1dDogcmVzcG9uc2VCb2R5LmVuY3J5cHRlZFRva2VuLFxuICAgICAgICAgIHBhc3N3b3JkOiBzZWNyZXQsXG4gICAgICAgIH0pLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLmVycm9yQ29kZSA9ICd0b2tlbl9kZWNyeXB0aW9uX2ZhaWx1cmUnO1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgdG9rZW4uJyk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2VjZGhYcHJ2KSB7XG4gICAgICByZXNwb25zZS5lY2RoWHBydiA9IGVjZGhYcHJ2O1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICAvKipcbiAgICovXG4gIHZlcmlmeVBhc3N3b3JkKHBhcmFtczogVmVyaWZ5UGFzc3dvcmRPcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucGFzc3dvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgc3RyaW5nIHBhc3N3b3JkJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl91c2VyIHx8ICF0aGlzLl91c2VyLnVzZXJuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGN1cnJlbnQgdXNlcicpO1xuICAgIH1cbiAgICBjb25zdCBobWFjUGFzc3dvcmQgPSB0aGlzLmNhbGN1bGF0ZUhNQUModGhpcy5fdXNlci51c2VybmFtZSwgcGFyYW1zLnBhc3N3b3JkKTtcblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy91c2VyL3ZlcmlmeXBhc3N3b3JkJykpLnNlbmQoeyBwYXNzd29yZDogaG1hY1Bhc3N3b3JkIH0pLnJlc3VsdCgndmFsaWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBvdXQgYWxsIHN0YXRlIGZyb20gdGhpcyBCaXRHbyBvYmplY3QsIGVmZmVjdGl2ZWx5IGxvZ2dpbmcgb3V0IHRoZSBjdXJyZW50IHVzZXIuXG4gICAqL1xuICBjbGVhcigpOiB2b2lkIHtcbiAgICAvLyBUT0RPOiBhcmUgdGhlcmUgYW55IG90aGVyIGZpZWxkcyB3aGljaCBzaG91bGQgYmUgY2xlYXJlZD9cbiAgICB0aGlzLl91c2VyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Rva2VuID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JlZnJlc2hUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9lY2RoWHBydiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgcmVmcmVzaCB0b2tlbiB0byBnZXQgbmV3IGFjY2VzcyB0b2tlbi5cbiAgICogSWYgdGhlIHJlZnJlc2ggdG9rZW4gaXMgbnVsbC9kZWZpbmVkLCB0aGVuIHdlIHVzZSB0aGUgc3RvcmVkIHRva2VuIGZyb20gYXV0aFxuICAgKi9cbiAgYXN5bmMgcmVmcmVzaFRva2VuKHBhcmFtczogeyByZWZyZXNoVG9rZW4/OiBzdHJpbmcgfSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWydyZWZyZXNoVG9rZW4nXSk7XG5cbiAgICBjb25zdCByZWZyZXNoVG9rZW4gPSBwYXJhbXMucmVmcmVzaFRva2VuIHx8IHRoaXMuX3JlZnJlc2hUb2tlbjtcblxuICAgIGlmICghcmVmcmVzaFRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSByZWZyZXNoIHRva2VuIG9yIGhhdmUgYXV0aGVudGljYXRlZCB3aXRoIE9hdXRoIGJlZm9yZScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fY2xpZW50SWQgfHwgIXRoaXMuX2NsaWVudFNlY3JldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIGNsaWVudCBpZCBhbmQgc2VjcmV0IHNldCBmaXJzdCB0byB1c2UgdGhpcycpO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCB0aGlzLnBvc3QodGhpcy5fYmFzZVVybCArICcvb2F1dGgvdG9rZW4nKVxuICAgICAgLnNlbmQoe1xuICAgICAgICBncmFudF90eXBlOiAncmVmcmVzaF90b2tlbicsXG4gICAgICAgIHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbixcbiAgICAgICAgY2xpZW50X2lkOiB0aGlzLl9jbGllbnRJZCxcbiAgICAgICAgY2xpZW50X3NlY3JldDogdGhpcy5fY2xpZW50U2VjcmV0LFxuICAgICAgfSlcbiAgICAgIC5yZXN1bHQoKTtcbiAgICB0aGlzLl90b2tlbiA9IGJvZHkuYWNjZXNzX3Rva2VuO1xuICAgIHRoaXMuX3JlZnJlc2hUb2tlbiA9IGJvZHkucmVmcmVzaF90b2tlbjtcbiAgICByZXR1cm4gYm9keTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBsaXN0QWNjZXNzVG9rZW5zXG4gICAqIEdldCBpbmZvcm1hdGlvbiBvbiBhbGwgb2YgdGhlIEJpdEdvIGFjY2VzcyB0b2tlbnMgb24gdGhlIHVzZXJcbiAgICogQHJldHVybiB7XG4gICAqICBpZDogPGlkIG9mIHRoZSB0b2tlbj5cbiAgICogIGxhYmVsOiA8dGhlIHVzZXItcHJvdmlkZWQgbGFiZWwgZm9yIHRoaXMgdG9rZW4+XG4gICAqICB1c2VyOiA8aWQgb2YgdGhlIHVzZXIgb24gdGhlIHRva2VuPlxuICAgKiAgZW50ZXJwcmlzZSA8aWQgb2YgdGhlIGVudGVycHJpc2UgdGhpcyB0b2tlbiBpcyB2YWxpZCBmb3I+XG4gICAqICBjbGllbnQ6IDx0aGUgYXV0aCBjbGllbnQgdGhhdCB0aGlzIHRva2VuIGJlbG9uZ3MgdG8+XG4gICAqICBzY29wZTogPGxpc3Qgb2YgYWxsb3dlZCBPQXV0aCBzY29wZSB2YWx1ZXM+XG4gICAqICBjcmVhdGVkOiA8ZGF0ZSB0aGUgdG9rZW4gd2FzIGNyZWF0ZWQ+XG4gICAqICBleHBpcmVzOiA8ZGF0ZSB0aGUgdG9rZW4gd2lsbCBleHBpcmU+XG4gICAqICBvcmlnaW46IDx0aGUgb3JpZ2luIGZvciB3aGljaCB0aGlzIHRva2VuIGlzIHZhbGlkPlxuICAgKiAgaXNFeHRlbnNpYmxlOiA8ZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSB0b2tlbiBjYW4gYmUgZXh0ZW5kZWQ+XG4gICAqICBleHRlbnNpb25BZGRyZXNzOiA8YWRkcmVzcyB3aG9zZSBwcml2YXRlIGtleSdzIHNpZ25hdHVyZSBpcyBuZWNlc3NhcnkgZm9yIGV4dGVuc2lvbnM+XG4gICAqICB1bmxvY2s6IDxpbmZvIGZvciBhY3Rpb25zIHRoYXQgcmVxdWlyZSBhbiB1bmxvY2sgYmVmb3JlIGZpcmluZz5cbiAgICogfVxuICAgKi9cbiAgYXN5bmMgbGlzdEFjY2Vzc1Rva2VucygpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3VzZXIvYWNjZXNzdG9rZW4nKSkuc2VuZCgpLnJlc3VsdCgnYWNjZXNzVG9rZW5zJyk7XG4gIH1cblxuICAvKipcbiAgICogYWRkQWNjZXNzVG9rZW5cbiAgICogQWRkIGEgQml0R28gQVBJIEFjY2VzcyBUb2tlbiB0byB0aGUgY3VycmVudCB1c2VyIGFjY291bnRcbiAgICogQHBhcmFtIHBhcmFtcyB7XG4gICAqICAgIG90cDogKHJlcXVpcmVkKSA8dmFsaWQgb3RwIGNvZGU+XG4gICAqICAgIGxhYmVsOiAocmVxdWlyZWQpIDxsYWJlbCBmb3IgdGhlIHRva2VuPlxuICAgKiAgICBkdXJhdGlvbjogPGxlbmd0aCBvZiB0aW1lIGluIHNlY29uZHMgdGhlIHRva2VuIHdpbGwgYmUgdmFsaWQgZm9yPlxuICAgKiAgICBpcFJlc3RyaWN0OiA8YXJyYXkgb2YgSVAgYWRkcmVzcyBzdHJpbmdzIHRvIHdoaXRlbGlzdD5cbiAgICogICAgdHhWYWx1ZUxpbWl0OiA8bnVtYmVyIG9mIG91dGdvaW5nIHNhdG9zaGlzIGFsbG93ZWQgb24gdGhpcyB0b2tlbj5cbiAgICogICAgc2NvcGU6IChyZXF1aXJlZCkgPGF1dGhvcml6YXRpb24gc2NvcGUgb2YgdGhlIHJlcXVlc3RlZCB0b2tlbj5cbiAgICogfVxuICAgKiBAcmV0dXJuIHtcbiAgICogICAgaWQ6IDxpZCBvZiB0aGUgdG9rZW4+XG4gICAqICAgIHRva2VuOiA8YWNjZXNzIHRva2VuIGhleCBzdHJpbmcgdG8gYmUgdXNlZCBmb3IgQml0R28gQVBJIHJlcXVlc3QgdmVyaWZpY2F0aW9uPlxuICAgKiAgICBsYWJlbDogPHVzZXItcHJvdmlkZWQgbGFiZWwgZm9yIHRoaXMgdG9rZW4+XG4gICAqICAgIHVzZXI6IDxpZCBvZiB0aGUgdXNlciBvbiB0aGUgdG9rZW4+XG4gICAqICAgIGVudGVycHJpc2UgPGlkIG9mIHRoZSBlbnRlcnByaXNlIHRoaXMgdG9rZW4gaXMgdmFsaWQgZm9yPlxuICAgKiAgICBjbGllbnQ6IDx0aGUgYXV0aCBjbGllbnQgdGhhdCB0aGlzIHRva2VuIGJlbG9uZ3MgdG8+XG4gICAqICAgIHNjb3BlOiA8bGlzdCBvZiBhbGxvd2VkIE9BdXRoIHNjb3BlIHZhbHVlcz5cbiAgICogICAgY3JlYXRlZDogPGRhdGUgdGhlIHRva2VuIHdhcyBjcmVhdGVkPlxuICAgKiAgICBleHBpcmVzOiA8ZGF0ZSB0aGUgdG9rZW4gd2lsbCBleHBpcmU+XG4gICAqICAgIG9yaWdpbjogPHRoZSBvcmlnaW4gZm9yIHdoaWNoIHRoaXMgdG9rZW4gaXMgdmFsaWQ+XG4gICAqICAgIGlzRXh0ZW5zaWJsZTogPGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgdG9rZW4gY2FuIGJlIGV4dGVuZGVkPlxuICAgKiAgICBleHRlbnNpb25BZGRyZXNzOiA8YWRkcmVzcyB3aG9zZSBwcml2YXRlIGtleSdzIHNpZ25hdHVyZSBpcyBuZWNlc3NhcnkgZm9yIGV4dGVuc2lvbnM+XG4gICAqICAgIHVubG9jazogPGluZm8gZm9yIGFjdGlvbnMgdGhhdCByZXF1aXJlIGFuIHVubG9jayBiZWZvcmUgZmlyaW5nPlxuICAgKiB9XG4gICAqL1xuICBhc3luYyBhZGRBY2Nlc3NUb2tlbihwYXJhbXM6IEFkZEFjY2Vzc1Rva2VuT3B0aW9ucyk6IFByb21pc2U8QWRkQWNjZXNzVG9rZW5SZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmxhYmVsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyBsYWJlbCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBub24tc3RyaW5nIHBhcmFtc1xuICAgICAgaWYgKHBhcmFtcy5kdXJhdGlvbikge1xuICAgICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLmR1cmF0aW9uKSB8fCBwYXJhbXMuZHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkdXJhdGlvbiBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLmlwUmVzdHJpY3QpIHtcbiAgICAgICAgaWYgKCFfLmlzQXJyYXkocGFyYW1zLmlwUmVzdHJpY3QpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcFJlc3RyaWN0IG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBfLmZvckVhY2gocGFyYW1zLmlwUmVzdHJpY3QsIChpcEFkZHIpID0+IHtcbiAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcoaXBBZGRyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcFJlc3RyaWN0IG11c3QgYmUgYW4gYXJyYXkgb2YgSVAgYWRkcmVzcyBzdHJpbmdzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMudHhWYWx1ZUxpbWl0KSB7XG4gICAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMudHhWYWx1ZUxpbWl0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHhWYWx1ZUxpbWl0IG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLnR4VmFsdWVMaW1pdCA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4VmFsdWVMaW1pdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnNjb3BlICYmIHBhcmFtcy5zY29wZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICghXy5pc0FycmF5KHBhcmFtcy5zY29wZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Njb3BlIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNwZWNpZnkgc2NvcGUgZm9yIHRva2VuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF1dGhVcmwgPSB0aGlzLm1pY3Jvc2VydmljZXNVcmwoJy9hcGkvYXV0aC92MS9hY2Nlc3N0b2tlbicpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMucG9zdChhdXRoVXJsKTtcblxuICAgICAgaWYgKCF0aGlzLl9lY2RoWHBydikge1xuICAgICAgICAvLyB3aXRob3V0IGEgcHJpdmF0ZSBrZXksIHRoZSB1c2VyIGNhbm5vdCBkZWNyeXB0IHRoZSBuZXcgYWNjZXNzIHRva2VuIHRoZSBzZXJ2ZXIgd2lsbCBzZW5kXG4gICAgICAgIHJlcXVlc3QuZm9yY2VWMUF1dGggPSB0cnVlO1xuICAgICAgICBkZWJ1ZygnZm9yY2luZyB2MSBhdXRoIGZvciBhZGRpbmcgYWNjZXNzIHRva2VuIHVzaW5nIHRva2VuICVzJywgdGhpcy5fdG9rZW4/LnN1YnN0cigwLCA4KSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5zZW5kKHBhcmFtcyk7XG4gICAgICBpZiAocmVxdWVzdC5mb3JjZVYxQXV0aCkge1xuICAgICAgICAocmVzcG9uc2UgYXMgYW55KS5ib2R5Lndhcm5pbmcgPSAnQSBwcm90b2NvbCBkb3duZ3JhZGUgaGFzIG9jY3VycmVkIGJlY2F1c2UgdGhpcyBpcyBhIGxlZ2FjeSBhY2NvdW50Lic7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXNwb25zZVJlc3VsdDxBZGRBY2Nlc3NUb2tlblJlc3BvbnNlPigpKHJlc3BvbnNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gdmVyaWZ5IHRoZSBhdXRoZW50aWNpdHkgb2YgdGhlIHNlcnZlcidzIHJlc3BvbnNlIGJlZm9yZSBwcm9jZWVkaW5nIGFueSBmdXJ0aGVyXG4gICAgICB2ZXJpZnlSZXNwb25zZSh0aGlzLCB0aGlzLl90b2tlbiwgJ3Bvc3QnLCByZXF1ZXN0LCByZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlRGV0YWlscyA9IHRoaXMuaGFuZGxlVG9rZW5Jc3N1YW5jZShyZXNwb25zZS5ib2R5KTtcbiAgICAgIHJlc3BvbnNlLmJvZHkudG9rZW4gPSByZXNwb25zZURldGFpbHMudG9rZW47XG5cbiAgICAgIHJldHVybiBoYW5kbGVSZXNwb25zZVJlc3VsdDxBZGRBY2Nlc3NUb2tlblJlc3BvbnNlPigpKHJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVSZXNwb25zZUVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBleHBpcmUgdGltZSBvZiBhbiBhY2Nlc3MgdG9rZW4gbWF0Y2hpbmcgZWl0aGVyIHRoZSBpZCBvciBsYWJlbCB0byB0aGUgY3VycmVudCBkYXRlLCBlZmZlY3RpdmVseSBkZWxldGluZyBpdFxuICAgKlxuICAgKiBQYXJhbXM6XG4gICAqIGlkOiA8aWQgb2YgdGhlIGFjY2VzcyB0b2tlbiB0byBiZSBkZWxldGVkPlxuICAgKiBsYWJlbDogPGxhYmVsIG9mIHRoZSBhY2Nlc3MgdG9rZW4gdG8gYmUgZGVsZXRlZD5cbiAgICpcbiAgICogUmV0dXJuczpcbiAgICogaWQ6IDxpZCBvZiB0aGUgdG9rZW4+XG4gICAqIGxhYmVsOiA8dXNlci1wcm92aWRlZCBsYWJlbCBmb3IgdGhpcyB0b2tlbj5cbiAgICogdXNlcjogPGlkIG9mIHRoZSB1c2VyIG9uIHRoZSB0b2tlbj5cbiAgICogZW50ZXJwcmlzZSA8aWQgb2YgdGhlIGVudGVycHJpc2UgdGhpcyB0b2tlbiBpcyB2YWxpZCBmb3I+XG4gICAqIGNsaWVudDogPHRoZSBhdXRoIGNsaWVudCB0aGF0IHRoaXMgdG9rZW4gYmVsb25ncyB0bz5cbiAgICogc2NvcGU6IDxsaXN0IG9mIGFsbG93ZWQgT0F1dGggc2NvcGUgdmFsdWVzPlxuICAgKiBjcmVhdGVkOiA8ZGF0ZSB0aGUgdG9rZW4gd2FzIGNyZWF0ZWQ+XG4gICAqIGV4cGlyZXM6IDxkYXRlIHRoZSB0b2tlbiB3aWxsIGV4cGlyZT5cbiAgICogb3JpZ2luOiA8dGhlIG9yaWdpbiBmb3Igd2hpY2ggdGhpcyB0b2tlbiBpcyB2YWxpZD5cbiAgICogaXNFeHRlbnNpYmxlOiA8ZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSB0b2tlbiBjYW4gYmUgZXh0ZW5kZWQ+XG4gICAqIGV4dGVuc2lvbkFkZHJlc3M6IDxhZGRyZXNzIHdob3NlIHByaXZhdGUga2V5J3Mgc2lnbmF0dXJlIGlzIG5lKmNlc3NhcnkgZm9yIGV4dGVuc2lvbnM+XG4gICAqIHVubG9jazogPGluZm8gZm9yIGFjdGlvbnMgdGhhdCByZXF1aXJlIGFuIHVubG9jayBiZWZvcmUgZmlyaW5nPlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyByZW1vdmVBY2Nlc3NUb2tlbih7IGlkLCBsYWJlbCB9OiBSZW1vdmVBY2Nlc3NUb2tlbk9wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICgoIWlkICYmICFsYWJlbCkgfHwgKGlkICYmIGxhYmVsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHByb3ZpZGUgZXhhY3RseSBvbmUgb2YgaWQgb3IgbGFiZWwnKTtcbiAgICB9XG4gICAgaWYgKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWwodGhpcy51cmwoYC91c2VyL2FjY2Vzc3Rva2VuLyR7aWR9YCkpXG4gICAgICAgIC5zZW5kKClcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHRva2VucyA9IGF3YWl0IHRoaXMubGlzdEFjY2Vzc1Rva2VucygpO1xuXG4gICAgaWYgKCF0b2tlbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndG9rZW4gd2l0aCB0aGlzIGxhYmVsIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0Y2hpbmdUb2tlbnMgPSBfLmZpbHRlcih0b2tlbnMsIHsgbGFiZWwgfSk7XG4gICAgaWYgKG1hdGNoaW5nVG9rZW5zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYW1iaWd1b3VzIGNhbGw6IG11bHRpcGxlIHRva2VucyBtYXRjaGluZyB0aGlzIGxhYmVsJyk7XG4gICAgfVxuICAgIGlmIChtYXRjaGluZ1Rva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndG9rZW4gd2l0aCB0aGlzIGxhYmVsIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGVsKHRoaXMudXJsKGAvdXNlci9hY2Nlc3N0b2tlbi8ke21hdGNoaW5nVG9rZW5zWzBdLmlkfWApKVxuICAgICAgLnNlbmQoKVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgcmFuZG9tIHBhc3N3b3JkXG4gICAqIEBwYXJhbSAgIHtOdW1iZXJ9IG51bVdvcmRzICAgICBOdW1iZXIgb2YgMzItYml0IHdvcmRzXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9ICAgICAgICAgIGJhc2U1OCByYW5kb20gcGFzc3dvcmRcbiAgICovXG4gIGdlbmVyYXRlUmFuZG9tUGFzc3dvcmQobnVtV29yZHMgPSA1KTogc3RyaW5nIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVSYW5kb21QYXNzd29yZChudW1Xb3Jkcyk7XG4gIH1cblxuICAvKipcbiAgICogTG9nb3V0IG9mIEJpdEdvXG4gICAqL1xuICBhc3luYyBsb2dvdXQoKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldCh0aGlzLnVybCgnL3VzZXIvbG9nb3V0JykpLnJlc3VsdCgpO1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHVzZXIgYnkgSUQgKG5hbWUvZW1haWwgb25seSlcbiAgICogQHBhcmFtIGlkXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyBnZXRVc2VyKHsgaWQgfTogR2V0VXNlck9wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghXy5pc1N0cmluZyhpZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgc3RyaW5nIGlkJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybChgL3VzZXIvJHtpZH1gKSkucmVzdWx0KCd1c2VyJyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBsb2dnZWQgaW4gdXNlclxuICAgKi9cbiAgYXN5bmMgbWUoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXRVc2VyKHsgaWQ6ICdtZScgfSk7XG4gIH1cblxuICAvKipcbiAgICogVW5sb2NrIHRoZSBzZXNzaW9uIGJ5IHByb3ZpZGluZyBPVFBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG90cCBSZXF1aXJlZCBPVFAgY29kZSBmb3IgdGhlIGFjY291bnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBEZXNpcmVkIGR1cmF0aW9uIG9mIHRoZSB1bmxvY2sgaW4gc2Vjb25kcyAoZGVmYXVsdD02MDAsIG1heD0zNjAwKS5cbiAgICovXG4gIGFzeW5jIHVubG9jayh7IG90cCwgZHVyYXRpb24gfTogVW5sb2NrT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKG90cCAmJiAhXy5pc1N0cmluZyhvdHApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBvciB1bmRlZmluZWQgb3RwJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy91c2VyL3VubG9jaycpKS5zZW5kKHsgb3RwLCBkdXJhdGlvbiB9KS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NrIHRoZSBzZXNzaW9uXG4gICAqL1xuICBhc3luYyBsb2NrKCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybCgnL3VzZXIvbG9jaycpKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc2Vzc2lvblxuICAgKi9cbiAgYXN5bmMgc2Vzc2lvbigpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3VzZXIvc2Vzc2lvbicpKS5yZXN1bHQoJ3Nlc3Npb24nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgcHVzaC9zbXMgZm9yIHRoZSBPVFAgY29kZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5mb3JjZVNNUyBJZiBzZXQgdG8gdHJ1ZSwgd2lsbCB1c2UgU01TIHRvIHNlbmQgdGhlIE9UUCB0byB0aGUgdXNlciBldmVuIGlmIHRoZXkgaGF2ZSBvdGhlciAyRkEgbWV0aG9kIHNldCB1cC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIHNlbmRPVFAocGFyYW1zOiB7IGZvcmNlU01TPzogYm9vbGVhbiB9ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy91c2VyL3NlbmRvdHAnKSkuc2VuZChwYXJhbXMpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dGVuZCB0b2tlbiwgcHJvdmlkZWQgdGhlIGN1cnJlbnQgdG9rZW4gaXMgZXh0ZW5kYWJsZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gZHVyYXRpb246IGR1cmF0aW9uIGluIHNlY29uZHMgYnkgd2hpY2ggdG8gZXh0ZW5kIHRoZSB0b2tlbiwgc3RhcnRpbmcgYXQgdGhlIGN1cnJlbnQgdGltZVxuICAgKi9cbiAgYXN5bmMgZXh0ZW5kVG9rZW4ocGFyYW1zOiBFeHRlbmRUb2tlbk9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCF0aGlzLl9leHRlbnNpb25LZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBfZXh0ZW5zaW9uS2V5Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHBhcmFtcy5kdXJhdGlvbjtcbiAgICBjb25zdCBtZXNzYWdlID0gdGltZXN0YW1wICsgJ3wnICsgdGhpcy5fdG9rZW4gKyAnfCcgKyBkdXJhdGlvbjtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gdGhpcy5fZXh0ZW5zaW9uS2V5LnByaXZhdGVLZXk7XG4gICAgaWYgKCFwcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHByaXZhdGVLZXkgb24gZXh0ZW5zaW9uS2V5Jyk7XG4gICAgfVxuICAgIGNvbnN0IGlzQ29tcHJlc3NlZCA9IHRoaXMuX2V4dGVuc2lvbktleS5jb21wcmVzc2VkO1xuICAgIGNvbnN0IHByZWZpeCA9IHV0eG9saWIubmV0d29ya3MuYml0Y29pbi5tZXNzYWdlUHJlZml4O1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGJpdGNvaW5NZXNzYWdlLnNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkLCBwcmVmaXgpLnRvU3RyaW5nKCdoZXgnKTtcblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy91c2VyL2V4dGVuZHRva2VuJykpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAuc2V0KCd0aW1lc3RhbXAnLCB0aW1lc3RhbXAudG9TdHJpbmcoKSlcbiAgICAgIC5zZXQoJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSlcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBrZXkgZm9yIHNoYXJpbmcgYSB3YWxsZXQgd2l0aCBhIHVzZXJcbiAgICogQHBhcmFtIGVtYWlsIGVtYWlsIG9mIHVzZXIgdG8gc2hhcmUgd2FsbGV0IHdpdGhcbiAgICovXG4gIGFzeW5jIGdldFNoYXJpbmdLZXkoeyBlbWFpbCB9OiBHZXRTaGFyaW5nS2V5T3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKGVtYWlsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgZW1haWwnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci9zaGFyaW5na2V5JykpLnNlbmQoeyBlbWFpbCB9KS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VycyB0aGF0IHdhbnQgdG8gc2lnbiB3aXRoIGEga2V5IHdpbGwgdXNlIHRoaXMgYXBpIHRvIGZldGNoIHRoZSBrZXljaGFpbiBhbmQgdGhlIHBhdGguXG4gICAqIFVzZXJzIHRoYXQgd2FudCB0byB2ZXJpZnkgYSBzaWduYXR1cmUgd2lsbCB1c2UgdGhpcyBhcGkgdG8gZmV0Y2ggYW5vdGhlciB1c2VycyBlY2RoIHB1YmtleS5cbiAgICogTm90ZTogSWYgdGhlIHVzZXIgaWQgaXMgbm90IHByb3ZpZGVkLCBpdCB3aWxsIGRlZmF1bHQgdG8gZ2V0dGluZyB0aGUgY3VycmVudCB1c2VyJ3Mga2V5Y2hhaW4uXG4gICAqIEBwYXJhbSBiaXRnb1xuICAgKiBAcGFyYW0gZW50ZXJwcmlzZUlkXG4gICAqIEBwYXJhbSB1c2VySWRcbiAgICovXG4gIGFzeW5jIGdldFNpZ25pbmdLZXlGb3JVc2VyKGVudGVycHJpc2VJZDogc3RyaW5nLCB1c2VySWQ/OiBzdHJpbmcpOiBQcm9taXNlPEdldFNpZ25pbmdLZXlBcGk+IHtcbiAgICBjb25zdCB1c2VyID0gdXNlcklkID8/ICdtZSc7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKGAvZW50ZXJwcmlzZS8ke2VudGVycHJpc2VJZH0vdXNlci8ke3VzZXJ9L3NpZ25pbmdrZXlgLCAyKSlcbiAgICAgIC5xdWVyeSh7fSlcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgZ2V0VmFsaWRhdGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICBzZXRWYWxpZGF0ZSh2YWxpZGF0ZTogYm9vbGVhbik6IHZvaWQge1xuICAgIGlmICghXy5pc0Jvb2xlYW4odmFsaWRhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgdGhpcy5fdmFsaWRhdGUgPSB2YWxpZGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIG5ldyBjb2luIGluc3RhbmNlIHdpdGggaXRzIGJ1aWxkZXIgZmFjdG9yeVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjb2luIG5hbWUgYXMgaXQgd2FzIHJlZ2lzdGVyZWQgaW4gQGJpdGdvL3N0YXRpY3NcbiAgICogQHBhcmFtIHtDb2luQ29uc3RydWN0b3J9IGNvaW4gdGhlIGJ1aWxkZXIgZmFjdG9yeSBjbGFzcyBmb3IgdGhhdCBjb2luXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcHVibGljIHJlZ2lzdGVyKG5hbWU6IHN0cmluZywgY29pbjogQ29pbkNvbnN0cnVjdG9yKTogdm9pZCB7XG4gICAgR2xvYmFsQ29pbkZhY3RvcnkucmVnaXN0ZXIobmFtZSwgY29pbik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGJpdGNvaW4gbWFya2V0IGRhdGFcbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIG1hcmtldHMoKTogYW55IHtcbiAgICBpZiAoIXRoaXMuX21hcmtldHMpIHtcbiAgICAgIHRoaXMuX21hcmtldHMgPSBuZXcgTWFya2V0cyh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21hcmtldHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXRlc3QgYml0Y29pbiBwcmljZXNcbiAgICogKERlcHJlY2F0ZWQ6IFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlKSB1c2UgYGJpdGdvLm1hcmtldHMoKS5sYXRlc3QoKWBcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIC8vIGNiLWNvbXBhdFxuICBhc3luYyBtYXJrZXQoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy9tYXJrZXQvbGF0ZXN0JykpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBtYXJrZXQgZGF0YSBmcm9tIHllc3RlcmRheVxuICAgKiAoRGVwcmVjYXRlZDogV2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUpIHVzZSBiaXRnby5tYXJrZXRzKCkueWVzdGVyZGF5KClcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIHllc3RlcmRheSgpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL21hcmtldC95ZXN0ZXJkYXknKSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBibG9ja2NoYWluIG9iamVjdC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGJsb2NrY2hhaW4oKTogYW55IHtcbiAgICBpZiAoIXRoaXMuX2Jsb2NrY2hhaW4pIHtcbiAgICAgIHRoaXMuX2Jsb2NrY2hhaW4gPSBuZXcgQmxvY2tjaGFpbih0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2NrY2hhaW47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB1c2VyJ3Mga2V5Y2hhaW5zIG9iamVjdC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGtleWNoYWlucygpOiBhbnkge1xuICAgIGlmICghdGhpcy5fa2V5Y2hhaW5zKSB7XG4gICAgICB0aGlzLl9rZXljaGFpbnMgPSBuZXcgS2V5Y2hhaW5zKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fa2V5Y2hhaW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHJhdmVsIHJ1bGUgb2JqZWN0XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICB0cmF2ZWxSdWxlKCk6IGFueSB7XG4gICAgaWYgKCF0aGlzLl90cmF2ZWxSdWxlKSB7XG4gICAgICB0aGlzLl90cmF2ZWxSdWxlID0gbmV3IFRyYXZlbFJ1bGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90cmF2ZWxSdWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlcidzIHdhbGxldHMgb2JqZWN0LlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgd2FsbGV0cygpOiBhbnkge1xuICAgIGlmICghdGhpcy5fd2FsbGV0cykge1xuICAgICAgdGhpcy5fd2FsbGV0cyA9IG5ldyBXYWxsZXRzKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcGVuZGluZyBhcHByb3ZhbHMgdGhhdCBjYW4gYmUgYXBwcm92ZWQvIG9yIHJlamVjdGVkXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBwZW5kaW5nQXBwcm92YWxzKCk6IGFueSB7XG4gICAgaWYgKCF0aGlzLl9wZW5kaW5nQXBwcm92YWxzKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nQXBwcm92YWxzID0gbmV3IFBlbmRpbmdBcHByb3ZhbHModGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFdhbGxldCBvYmplY3QsIGluaXRpYWxpemVkIHdpdGggdGhlIHdhbGxldCBwYXJhbXNcbiAgICogQ2FuIGJlIHVzZWQgdG8gcmVjb25zdGl0dXRlIGEgd2FsbGV0IGZyb20gY2FjaGVkIGRhdGFcbiAgICogQHBhcmFtIHdhbGxldFBhcmFtc1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgbmV3V2FsbGV0T2JqZWN0KHdhbGxldFBhcmFtcyk6IGFueSB7XG4gICAgcmV0dXJuIG5ldyBXYWxsZXQodGhpcywgd2FsbGV0UGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWMSBtZXRob2QgZm9yIGNhbGN1bGF0aW5nIG1pbmVyIGZlZSBhbW91bnRzLCBnaXZlbiB0aGUgbnVtYmVyIGFuZFxuICAgKiB0eXBlIG9mIHRyYW5zYWN0aW9uIGlucHV0cywgYWxvbmcgd2l0aCBhIGZlZSByYXRlIGluIHNhdG9zaGlzIHBlciB2a0IuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZCBmb3IgbmV3IGNvZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgYXN5bmMgY2FsY3VsYXRlTWluZXJGZWVJbmZvKHBhcmFtczogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25CdWlsZGVyLmNhbGN1bGF0ZU1pbmVyRmVlSW5mbyhwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBhIEJpdGNvaW4gYWRkcmVzcyBpcyBhIHZhbGlkIGJhc2U1OCBhZGRyZXNzXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICB2ZXJpZnlBZGRyZXNzKHBhcmFtczogRGVwcmVjYXRlZFZlcmlmeUFkZHJlc3NPcHRpb25zID0ge30pOiBib29sZWFuIHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2FkZHJlc3MnXSwgW10pO1xuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5hZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHN0cmluZyBhZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV0d29ya05hbWUgPSBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuZ2V0RW52KCldLm5ldHdvcms7XG4gICAgY29uc3QgbmV0d29yayA9IHV0eG9saWIubmV0d29ya3NbbmV0d29ya05hbWVdO1xuXG4gICAgcmV0dXJuIHZlcmlmeUFkZHJlc3MocGFyYW1zLmFkZHJlc3MsIG5ldHdvcmspO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IGEgc2VjcmV0IGludG8gc2hhcmRzIHVzaW5nIFNoYW1pciBTZWNyZXQgU2hhcmluZy5cbiAgICogQHBhcmFtIHNlZWQgQSBoZXhhZGVjaW1hbCBzZWNyZXQgdG8gc3BsaXRcbiAgICogQHBhcmFtIHBhc3N3b3JkcyBBbiBhcnJheSBvZiB0aGUgcGFzc3dvcmRzIHVzZWQgdG8gZW5jcnlwdCBlYWNoIHNoYXJlXG4gICAqIEBwYXJhbSBtIFRoZSB0aHJlc2hvbGQgbnVtYmVyIG9mIHNoYXJkcyBuZWNlc3NhcnkgdG8gcmVjb25zdGl0dXRlIHRoZSBzZWNyZXRcbiAgICovXG4gIHNwbGl0U2VjcmV0KHsgc2VlZCwgcGFzc3dvcmRzLCBtIH06IFNwbGl0U2VjcmV0T3B0aW9ucyk6IFNwbGl0U2VjcmV0IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFzc3dvcmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzd29yZHMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cbiAgICBpZiAoIV8uaXNJbnRlZ2VyKG0pIHx8IG0gPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ20gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDInKTtcbiAgICB9XG5cbiAgICBpZiAocGFzc3dvcmRzLmxlbmd0aCA8IG0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFzc3dvcmRzIGFycmF5IGxlbmd0aCBjYW5ub3QgYmUgbGVzcyB0aGFuIG0nKTtcbiAgICB9XG5cbiAgICBjb25zdCBuID0gcGFzc3dvcmRzLmxlbmd0aDtcbiAgICBjb25zdCBzZWNyZXRzOiBzdHJpbmdbXSA9IHNoYW1pci5zaGFyZShzZWVkLCBuLCBtKTtcbiAgICBjb25zdCBzaGFyZHMgPSBfLnppcFdpdGgoc2VjcmV0cywgcGFzc3dvcmRzLCAoc2hhcmQsIHBhc3N3b3JkKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNyeXB0KHsgaW5wdXQ6IHNoYXJkLCBwYXNzd29yZCB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBub2RlID0gYmlwMzIuZnJvbVNlZWQoQnVmZmVyLmZyb20oc2VlZCwgJ2hleCcpKTtcbiAgICByZXR1cm4ge1xuICAgICAgeHB1Yjogbm9kZS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCksXG4gICAgICBtLFxuICAgICAgbixcbiAgICAgIHNlZWRTaGFyZXM6IHNoYXJkcyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY29uc3RpdHV0ZSBhIHNlY3JldCB3aGljaCB3YXMgc2hhcmRlZCB3aXRoIGBzcGxpdFNlY3JldGAuXG4gICAqIEBwYXJhbSBzaGFyZHNcbiAgICogQHBhcmFtIHBhc3N3b3Jkc1xuICAgKi9cbiAgcmVjb25zdGl0dXRlU2VjcmV0KHsgc2hhcmRzLCBwYXNzd29yZHMgfTogUmVjb25zdGl0dXRlU2VjcmV0T3B0aW9ucyk6IFJlY29uc3RpdHV0ZWRTZWNyZXQge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzaGFyZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXJkcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXNzd29yZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3N3b3JkcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuXG4gICAgaWYgKHNoYXJkcy5sZW5ndGggIT09IHBhc3N3b3Jkcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2hhcmRzIGFuZCBwYXNzd29yZHMgYXJyYXlzIG11c3QgaGF2ZSBzYW1lIGxlbmd0aCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY3JldHMgPSBfLnppcFdpdGgoc2hhcmRzLCBwYXNzd29yZHMsIChzaGFyZCwgcGFzc3dvcmQpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmRlY3J5cHQoeyBpbnB1dDogc2hhcmQsIHBhc3N3b3JkIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHNlZWQ6IHN0cmluZyA9IHNoYW1pci5jb21iaW5lKHNlY3JldHMpO1xuICAgIGNvbnN0IG5vZGUgPSBiaXAzMi5mcm9tU2VlZChCdWZmZXIuZnJvbShzZWVkLCAnaGV4JykpO1xuICAgIHJldHVybiB7XG4gICAgICB4cHViOiBub2RlLm5ldXRlcmVkKCkudG9CYXNlNTgoKSBhcyBzdHJpbmcsXG4gICAgICB4cHJ2OiBub2RlLnRvQmFzZTU4KCkgYXMgc3RyaW5nLFxuICAgICAgc2VlZCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBzaGFyZHNcbiAgICogQHBhcmFtIHBhc3N3b3Jkc1xuICAgKiBAcGFyYW0gbVxuICAgKiBAcGFyYW0geHB1YiBPcHRpb25hbCB4cHViIHRvIHZlcmlmeSB0aGUgcmVzdWx0cyBhZ2FpbnN0XG4gICAqL1xuICB2ZXJpZnlTaGFyZHMoeyBzaGFyZHMsIHBhc3N3b3JkcywgbSwgeHB1YiB9OiBWZXJpZnlTaGFyZHNPcHRpb25zKTogYm9vbGVhbiB7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYWxsIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBvZiBhIGdpdmVuIGFycmF5J3MgdmFsdWVzIGdpdmVuIHN1YnNldCBzaXplIG1cbiAgICAgKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5IHdob3NlIHZhbHVlcyBhcmUgdG8gYmUgYXJyYW5nZWQgaW4gYWxsIGNvbWJpbmF0aW9uc1xuICAgICAqIEBwYXJhbSBtIFRoZSBzaXplIG9mIGVhY2ggc3Vic2V0XG4gICAgICogQHBhcmFtIGVudHJ5SW5kaWNlcyBSZWN1cnNpdmVseSB0cmFpbGluZyBzZXQgb2YgY3VycmVudGx5IGNob3NlbiBhcnJheSBpbmRpY2VzIGZvciB0aGUgY29tYmluYXRpb24gc3Vic2V0IHVuZGVyIGNvbnN0cnVjdGlvblxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBjb25zdCBnZW5lcmF0ZUNvbWJpbmF0aW9ucyA9IChhcnJheTogc3RyaW5nW10sIG06IG51bWJlciwgZW50cnlJbmRpY2VzOiBudW1iZXJbXSA9IFtdKTogc3RyaW5nW11bXSA9PiB7XG4gICAgICBsZXQgY29tYmluYXRpb25zOiBzdHJpbmdbXVtdID0gW107XG5cbiAgICAgIGlmIChlbnRyeUluZGljZXMubGVuZ3RoID09PSBtKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb21iaW5hdGlvbiA9IF8uYXQoYXJyYXksIGVudHJ5SW5kaWNlcyk7XG4gICAgICAgIHJldHVybiBbY3VycmVudENvbWJpbmF0aW9uXTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGhpZ2hlc3QgaW5kZXhcbiAgICAgIGxldCBlbnRyeUluZGV4ID0gXy5sYXN0KGVudHJ5SW5kaWNlcyk7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgY3VycmVudGx5IG5vIGluZGljZXMsIGFzc3VtZSAtMVxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoZW50cnlJbmRleCkpIHtcbiAgICAgICAgZW50cnlJbmRleCA9IC0xO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IGVudHJ5SW5kZXggKyAxOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBjdXJyZW50IGluZGV4IHRvIHRoZSB0cmFpbGluZyBpbmRpY2VzXG4gICAgICAgIGNvbnN0IGN1cnJlbnRFbnRyeUluZGljZXMgPSBbLi4uZW50cnlJbmRpY2VzLCBpXTtcbiAgICAgICAgY29uc3QgbmV3Q29tYmluYXRpb25zID0gZ2VuZXJhdGVDb21iaW5hdGlvbnMoYXJyYXksIG0sIGN1cnJlbnRFbnRyeUluZGljZXMpO1xuICAgICAgICBjb21iaW5hdGlvbnMgPSBbLi4uY29tYmluYXRpb25zLCAuLi5uZXdDb21iaW5hdGlvbnNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tYmluYXRpb25zO1xuICAgIH07XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2hhcmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGFyZHMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFzc3dvcmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzd29yZHMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cblxuICAgIGlmIChzaGFyZHMubGVuZ3RoICE9PSBwYXNzd29yZHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXJkcyBhbmQgcGFzc3dvcmRzIGFycmF5cyBtdXN0IGhhdmUgc2FtZSBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWNyZXRzID0gXy56aXBXaXRoKHNoYXJkcywgcGFzc3dvcmRzLCAoc2hhcmQsIHBhc3N3b3JkKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNyeXB0KHsgaW5wdXQ6IHNoYXJkLCBwYXNzd29yZCB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBzZWNyZXRDb21iaW5hdGlvbnMgPSBnZW5lcmF0ZUNvbWJpbmF0aW9ucyhzZWNyZXRzLCBtKTtcbiAgICBjb25zdCBzZWVkcyA9IHNlY3JldENvbWJpbmF0aW9ucy5tYXAoKGN1cnJlbnRDb21iaW5hdGlvbikgPT4ge1xuICAgICAgcmV0dXJuIHNoYW1pci5jb21iaW5lKGN1cnJlbnRDb21iaW5hdGlvbik7XG4gICAgfSk7XG4gICAgY29uc3QgdW5pcXVlU2VlZHMgPSBfLnVuaXEoc2VlZHMpO1xuICAgIGlmICh1bmlxdWVTZWVkcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2VlZCA9IF8uZmlyc3QodW5pcXVlU2VlZHMpO1xuICAgIGNvbnN0IG5vZGUgPSBiaXAzMi5mcm9tU2VlZChCdWZmZXIuZnJvbShzZWVkLCAnaGV4JykpO1xuICAgIGNvbnN0IHJlc3RvcmVkWHB1YiA9IG5vZGUubmV1dGVyZWQoKS50b0Jhc2U1OCgpO1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHhwdWIpKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcoeHB1YikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4cHViIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN0b3JlZFhwdWIgIT09IHhwdWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIC0gdXNlIGBnZXRTaGFyZWRTZWNyZXQoKWBcbiAgICovXG4gIGdldEVDREhTZWNyZXQoeyBvdGhlclB1YktleUhleCwgZWNrZXkgfTogR2V0RWNkaFNlY3JldE9wdGlvbnMpOiBzdHJpbmcge1xuICAgIGlmICghXy5pc1N0cmluZyhvdGhlclB1YktleUhleCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3RoZXJQdWJLZXlIZXggc3RyaW5nIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghXy5pc09iamVjdChlY2tleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZWNrZXkgb2JqZWN0IHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFNoYXJlZFNlY3JldChlY2tleSwgQnVmZmVyLmZyb20ob3RoZXJQdWJLZXlIZXgsICdoZXgnKSkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVzZXIncyBwcml2YXRlIEVDREgga2V5Y2hhaW5cbiAgICovXG4gIGFzeW5jIGdldEVDREhLZXljaGFpbihlY2RoS2V5Y2hhaW5QdWI/OiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghZWNkaEtleWNoYWluUHViKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldCh0aGlzLnVybCgnL3VzZXIvc2V0dGluZ3MnKSkucmVzdWx0KCk7XG4gICAgICBpZiAoIXJlc3VsdC5zZXR0aW5ncy5lY2RoS2V5Y2hhaW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignZWNkaCBrZXljaGFpbiBub3QgZm91bmQgZm9yIHVzZXInKTtcbiAgICAgIH1cbiAgICAgIGVjZGhLZXljaGFpblB1YiA9IHJlc3VsdC5zZXR0aW5ncy5lY2RoS2V5Y2hhaW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmtleWNoYWlucygpLmdldCh7IHhwdWI6IGVjZGhLZXljaGFpblB1YiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1c2VyIGRlcml2ZWQgcHVibGljIGFuZCBwcml2YXRlIEVDREgga2V5cGFpclxuICAgKiBAcGFyYW0gcGFzc3dvcmQgcGFzc3dvcmQgdG8gZGVjcnlwdCB0aGUgdXNlcidzIEVDREggZW5jcnlwdGVkIHByaXZhdGUga2V5XG4gICAqIEBwYXJhbSBlbnRJZD8gb3B0aW9uYWwgZW50ZXJwcmlzZSBpZCB0byBjaGVjayBmb3IgcGVybWlzc2lvbnNcbiAgICovXG4gIGFzeW5jIGdldEVjZGhLZXlwYWlyUHJpdmF0ZShwYXNzd29yZDogc3RyaW5nLCBlbnRJZDogc3RyaW5nKTogUHJvbWlzZTxFY2RoRGVyaXZlZEtleXBhaXI+IHtcbiAgICBjb25zdCB1c2VyU2lnbmluZ0tleSA9IGF3YWl0IHRoaXMuZ2V0U2lnbmluZ0tleUZvclVzZXIoZW50SWQpO1xuICAgIGNvbnN0IHB1YmtleU9mQWRtaW5FY2RoS2V5SGV4ID0gdXNlclNpZ25pbmdLZXkuZGVyaXZlZFB1YmtleTtcbiAgICBpZiAoIXVzZXJTaWduaW5nS2V5LmVjZGhLZXljaGFpbiB8fCAhdXNlclNpZ25pbmdLZXkuZGVyaXZhdGlvblBhdGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2l0aCB0aGUgdXNlciBrZXljaGFpbi4gUGxlYXNlIGNvbnRhY3Qgc3VwcG9ydEBiaXRnby5jb20uJyk7XG4gICAgfVxuICAgIGNvbnN0IHVzZXJFY2RoS2V5Y2hhaW4gPSBhd2FpdCB0aGlzLmdldEVDREhLZXljaGFpbih1c2VyU2lnbmluZ0tleS5lY2RoS2V5Y2hhaW4pO1xuICAgIGxldCB4cHJ2O1xuICAgIHRyeSB7XG4gICAgICB4cHJ2ID0gdGhpcy5kZWNyeXB0KHtcbiAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkLFxuICAgICAgICBpbnB1dDogdXNlckVjZGhLZXljaGFpbi5lbmNyeXB0ZWRYcHJ2LFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgcGFzc3dvcmQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkZXJpdmVkUHViS2V5OiBwdWJrZXlPZkFkbWluRWNkaEtleUhleCxcbiAgICAgIGRlcml2YXRpb25QYXRoOiB1c2VyU2lnbmluZ0tleS5kZXJpdmF0aW9uUGF0aCxcbiAgICAgIHhwcnYsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gb3BlcmF0aW5nU3lzdGVtOiBvbmUgb2YgaW9zLCBhbmRyb2lkXG4gICAqIC0gcHVzaFRva2VuOiBoZXgtZm9ybWF0dGVkIHRva2VuIGZvciB0aGUgcmVzcGVjdGl2ZSBuYXRpdmUgcHVzaCBub3RpZmljYXRpb24gc2VydmljZVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIHJlZ2lzdGVyUHVzaFRva2VuKHBhcmFtczogUmVnaXN0ZXJQdXNoVG9rZW5PcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydwdXNoVG9rZW4nLCAnb3BlcmF0aW5nU3lzdGVtJ10sIFtdKTtcblxuICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgIC8vIHRoaXMgZGV2aWNlIGhhcyB0byBiZSByZWdpc3RlcmVkIHRvIGFuIGV4dGVuc2libGUgc2Vzc2lvblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgbG9nZ2VkIGluJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcG9zdFBhcmFtcyA9IF8ucGljayhwYXJhbXMsIFsncHVzaFRva2VuJywgJ29wZXJhdGluZ1N5c3RlbSddKTtcblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy9kZXZpY2VzJykpLnNlbmQocG9zdFBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHB1c2hWZXJpZmljYXRpb25Ub2tlbjogdGhlIHRva2VuIHJlY2VpdmVkIHZpYSBwdXNoIG5vdGlmaWNhdGlvbiB0byBjb25maXJtIHRoZSBkZXZpY2UncyBtb2JpbGl0eVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgdmVyaWZ5UHVzaFRva2VuKHBhcmFtczogVmVyaWZ5UHVzaFRva2VuT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgb2JqZWN0IHBhcmFtcycpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucHVzaFZlcmlmaWNhdGlvblRva2VuKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgcHVzaFZlcmlmaWNhdGlvblRva2VuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgLy8gdGhpcyBkZXZpY2UgaGFzIHRvIGJlIHJlZ2lzdGVyZWQgdG8gYW4gZXh0ZW5zaWJsZSBzZXNzaW9uXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBsb2dnZWQgaW4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBwb3N0UGFyYW1zID0gXy5waWNrKHBhcmFtcywgJ3B1c2hWZXJpZmljYXRpb25Ub2tlbicpO1xuXG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybCgnL2RldmljZXMvdmVyaWZ5JykpLnNlbmQocG9zdFBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogTG9naW4gdG8gdGhlIGJpdGdvIHN5c3RlbSB1c2luZyBhbiBhdXRoY29kZSBnZW5lcmF0ZWQgdmlhIE9hdXRoXG4gICAqL1xuICBhc3luYyBhdXRoZW50aWNhdGVXaXRoQXV0aENvZGUocGFyYW1zOiBBdXRoZW50aWNhdGVXaXRoQXV0aENvZGVPcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBvYmplY3QgcGFyYW1zJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5hdXRoQ29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIGF1dGhDb2RlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9jbGllbnRJZCB8fCAhdGhpcy5fY2xpZW50U2VjcmV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgY2xpZW50IGlkIGFuZCBzZWNyZXQgc2V0IGZpcnN0IHRvIHVzZSB0aGlzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYXV0aENvZGUgPSBwYXJhbXMuYXV0aENvZGU7XG5cbiAgICBpZiAodGhpcy5fdG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWxyZWFkeSBsb2dnZWQgaW4nKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5wb3N0KHRoaXMuX2Jhc2VVcmwgKyAnL29hdXRoL3Rva2VuJyk7XG4gICAgcmVxdWVzdC5mb3JjZVYxQXV0aCA9IHRydWU7IC8vIE9BdXRoIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHYxIGF1dGhlbnRpY2F0aW9uXG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcXVlc3RcbiAgICAgIC5zZW5kKHtcbiAgICAgICAgZ3JhbnRfdHlwZTogJ2F1dGhvcml6YXRpb25fY29kZScsXG4gICAgICAgIGNvZGU6IGF1dGhDb2RlLFxuICAgICAgICBjbGllbnRfaWQ6IHRoaXMuX2NsaWVudElkLFxuICAgICAgICBjbGllbnRfc2VjcmV0OiB0aGlzLl9jbGllbnRTZWNyZXQsXG4gICAgICB9KVxuICAgICAgLnJlc3VsdCgpO1xuXG4gICAgdGhpcy5fdG9rZW4gPSBib2R5LmFjY2Vzc190b2tlbjtcbiAgICB0aGlzLl9yZWZyZXNoVG9rZW4gPSBib2R5LnJlZnJlc2hfdG9rZW47XG4gICAgdGhpcy5fdXNlciA9IGF3YWl0IHRoaXMubWUoKTtcbiAgICByZXR1cm4gYm9keTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIHBhc3N3b3JkIG9mIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIuXG4gICAqIEFsc28gY2hhbmdlIGFsbCB2MSBhbmQgdjIga2V5Y2hhaW4gcGFzc3dvcmRzIGlmIHRoZXkgbWF0Y2ggdGhlXG4gICAqIGdpdmVuIG9sZFBhc3N3b3JkLiBSZXR1cm5zIG5vdGhpbmcgb24gc3VjY2Vzcy5cbiAgICogQHBhcmFtIG9sZFBhc3N3b3JkIHtTdHJpbmd9IC0gdGhlIGN1cnJlbnQgcGFzc3dvcmRcbiAgICogQHBhcmFtIG5ld1Bhc3N3b3JkIHtTdHJpbmd9IC0gdGhlIG5ldyBwYXNzd29yZFxuICAgKi9cbiAgYXN5bmMgY2hhbmdlUGFzc3dvcmQoeyBvbGRQYXNzd29yZCwgbmV3UGFzc3dvcmQgfTogQ2hhbmdlUGFzc3dvcmRPcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcob2xkUGFzc3dvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBvbGRQYXNzd29yZCcpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhuZXdQYXNzd29yZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgc3RyaW5nIG5ld1Bhc3N3b3JkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlciA9IHRoaXMudXNlcigpO1xuICAgIGlmICh0eXBlb2YgdXNlciAhPT0gJ29iamVjdCcgfHwgIXVzZXIudXNlcm5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBvYmplY3QgdXNlcicpO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB0aGlzLnZlcmlmeVBhc3N3b3JkKHsgcGFzc3dvcmQ6IG9sZFBhc3N3b3JkIH0pO1xuICAgIGlmICghdmFsaWRhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgcHJvdmlkZWQgb2xkUGFzc3dvcmQgaXMgaW5jb3JyZWN0Jyk7XG4gICAgfVxuXG4gICAgLy8gaXQgZG9lc24ndCBtYXR0ZXIgd2hpY2ggY29pbiB3ZSBjaG9vc2UgYmVjYXVzZSB0aGUgdjIgdXBkYXRlUGFzc3dvcmQgZnVuY3Rpb25zIHVwZGF0ZXMgYWxsIHYyIGtleWNoYWluc1xuICAgIC8vIHdlIGp1c3QgbmVlZCB0byBjaG9vc2UgYSBjb2luIHRoYXQgZXhpc3RzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50XG4gICAgY29uc3QgY29pbiA9IGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5nZXRFbnYoKV0ubmV0d29yayA9PT0gJ2JpdGNvaW4nID8gJ2J0YycgOiAndGJ0Yyc7XG5cbiAgICBjb25zdCB1cGRhdGVLZXljaGFpblBhc3N3b3JkUGFyYW1zID0geyBvbGRQYXNzd29yZCwgbmV3UGFzc3dvcmQgfTtcbiAgICBjb25zdCB2MUtleWNoYWluVXBkYXRlUFdSZXN1bHQgPSBhd2FpdCB0aGlzLmtleWNoYWlucygpLnVwZGF0ZVBhc3N3b3JkKHVwZGF0ZUtleWNoYWluUGFzc3dvcmRQYXJhbXMpO1xuICAgIGNvbnN0IHYyS2V5Y2hhaW5zID0gYXdhaXQgdGhpcy5jb2luKGNvaW4pLmtleWNoYWlucygpLnVwZGF0ZVBhc3N3b3JkKHVwZGF0ZUtleWNoYWluUGFzc3dvcmRQYXJhbXMpO1xuXG4gICAgY29uc3QgdXBkYXRlUGFzc3dvcmRQYXJhbXMgPSB7XG4gICAgICBrZXljaGFpbnM6IHYxS2V5Y2hhaW5VcGRhdGVQV1Jlc3VsdC5rZXljaGFpbnMsXG4gICAgICB2Ml9rZXljaGFpbnM6IHYyS2V5Y2hhaW5zLFxuICAgICAgdmVyc2lvbjogdjFLZXljaGFpblVwZGF0ZVBXUmVzdWx0LnZlcnNpb24sXG4gICAgICBvbGRQYXNzd29yZDogdGhpcy5jYWxjdWxhdGVITUFDKHVzZXIudXNlcm5hbWUsIG9sZFBhc3N3b3JkKSxcbiAgICAgIHBhc3N3b3JkOiB0aGlzLmNhbGN1bGF0ZUhNQUModXNlci51c2VybmFtZSwgbmV3UGFzc3dvcmQpLFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci9jaGFuZ2VwYXNzd29yZCcpKS5zZW5kKHVwZGF0ZVBhc3N3b3JkUGFyYW1zKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHRoZSBhZGRyZXNzIGxhYmVscyBvbiBhbGwgb2YgdGhlIHVzZXIncyB3YWxsZXRzXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyBsYWJlbHMoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy9sYWJlbHMnKSkucmVzdWx0KCdsYWJlbHMnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc3RpbWF0ZXMgYXBwcm94aW1hdGUgZmVlIHBlciBrYiBuZWVkZWQgZm9yIGEgdHggdG8gZ2V0IGludG8gYSBibG9ja1xuICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm51bUJsb2NrcyB0YXJnZXQgYmxvY2tzIGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgY29uZmlybWVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4RmVlIG1heGltdW0gZmVlIHdpbGxpbmcgdG8gYmUgcGFpZCAoZm9yIHNhZmV0eSlcbiAgICogQHBhcmFtIHthcnJheVtzdHJpbmddfSBwYXJhbXMuaW5wdXRzIGxpc3Qgb2YgdW5jb25maXJtZWQgdHhJZHMgZnJvbSB3aGljaCB0aGlzIHRyYW5zYWN0aW9uIHVzZXMgaW5wdXRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudHhTaXplIGVzdGltYXRlZCB0cmFuc2FjdGlvbiBzaXplIGluIGJ5dGVzLCBvcHRpb25hbCBwYXJhbWV0ZXIgdXNlZCBmb3IgQ1BGUCBlc3RpbWF0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5jcGZwQXdhcmUgZmxhZyBpbmRpY2F0aW5nIGZlZSBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgQ1BGUFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXN5bmMgZXN0aW1hdGVGZWUocGFyYW1zOiBFc3RpbWF0ZUZlZU9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcXVlcnlQYXJhbXM6IGFueSA9IHsgdmVyc2lvbjogMTIgfTtcbiAgICBpZiAocGFyYW1zLm51bUJsb2Nrcykge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5udW1CbG9ja3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgfVxuICAgICAgcXVlcnlQYXJhbXMubnVtQmxvY2tzID0gcGFyYW1zLm51bUJsb2NrcztcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5tYXhGZWUpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubWF4RmVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5UGFyYW1zLm1heEZlZSA9IHBhcmFtcy5tYXhGZWU7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuaW5wdXRzKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLmlucHV0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICB9XG4gICAgICBxdWVyeVBhcmFtcy5pbnB1dHMgPSBwYXJhbXMuaW5wdXRzO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnR4U2l6ZSkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy50eFNpemUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgfVxuICAgICAgcXVlcnlQYXJhbXMudHhTaXplID0gcGFyYW1zLnR4U2l6ZTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jcGZwQXdhcmUpIHtcbiAgICAgIGlmICghXy5pc0Jvb2xlYW4ocGFyYW1zLmNwZnBBd2FyZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICB9XG4gICAgICBxdWVyeVBhcmFtcy5jcGZwQXdhcmUgPSBwYXJhbXMuY3BmcEF3YXJlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3R4L2ZlZScpKS5xdWVyeShxdWVyeVBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IEJpdEdvJ3MgZ3VhcmFudGVlIHVzaW5nIGFuIGluc3RhbnQgaWRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXN5bmMgaW5zdGFudEd1YXJhbnRlZShwYXJhbXM6IHsgaWQ6IHN0cmluZyB9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgaWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5ID0gYXdhaXQgdGhpcy5nZXQodGhpcy51cmwoJy9pbnN0YW50LycgKyBwYXJhbXMuaWQpKS5yZXN1bHQoKTtcbiAgICBpZiAoIWJvZHkuZ3VhcmFudGVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGd1YXJhbnRlZSBmb3VuZCBpbiByZXNwb25zZSBib2R5Jyk7XG4gICAgfVxuICAgIGlmICghYm9keS5zaWduYXR1cmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gc2lnbmF0dXJlIGZvdW5kIGluIGd1YXJhbnRlZSByZXNwb25zZSBib2R5Jyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25pbmdBZGRyZXNzID0gY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmdldEVudigpXS5zaWduaW5nQWRkcmVzcztcbiAgICBjb25zdCBzaWduYXR1cmVCdWZmZXIgPSBCdWZmZXIuZnJvbShib2R5LnNpZ25hdHVyZSwgJ2hleCcpO1xuICAgIGNvbnN0IHByZWZpeCA9IHV0eG9saWIubmV0d29ya3NbY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmdldEVudigpXS5uZXR3b3JrXS5tZXNzYWdlUHJlZml4O1xuICAgIGNvbnN0IGlzVmFsaWRTaWduYXR1cmUgPSBiaXRjb2luTWVzc2FnZS52ZXJpZnkoYm9keS5ndWFyYW50ZWUsIHNpZ25pbmdBZGRyZXNzLCBzaWduYXR1cmVCdWZmZXIsIHByZWZpeCk7XG4gICAgaWYgKCFpc1ZhbGlkU2lnbmF0dXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29ycmVjdCBzaWduYXR1cmUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdGFyZ2V0IGFkZHJlc3MgZm9yIHBheW1lbnQgb2YgYSBCaXRHbyBmZWVcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIGdldEJpdEdvRmVlQWRkcmVzcygpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy9iaWxsaW5nL2FkZHJlc3MnKSkuc2VuZCh7fSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBhZGRyZXNzIG9iamVjdCAoaW5jbHVkaW5nIHRoZSB3YWxsZXQgaWQpIGZvciBhIGdpdmVuIGFkZHJlc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYWRkcmVzcyBUaGUgYWRkcmVzcyB0byBsb29rIHVwLlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXN5bmMgZ2V0V2FsbGV0QWRkcmVzcyh7IGFkZHJlc3MgfTogeyBhZGRyZXNzOiBzdHJpbmcgfSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKGAvd2FsbGV0YWRkcmVzcy8ke2FkZHJlc3N9YCkpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGxpc3Qgb2YgdXNlciB3ZWJob29rc1xuICAgKlxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIGxpc3RXZWJob29rcygpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3dlYmhvb2tzJykpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBuZXcgdXNlciB3ZWJob29rXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMgeyp9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyBhZGRXZWJob29rKHBhcmFtczogV2ViaG9va09wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMudXJsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgdXJsJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy50eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgdHlwZScpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy93ZWJob29rcycpKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHVzZXIgd2ViaG9va1xuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlV2ViaG9vayhwYXJhbXM6IFdlYmhvb2tPcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnVybCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIHVybCcpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMudHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIHR5cGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kZWwodGhpcy51cmwoJy93ZWJob29rcycpKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggbGlzdCBvZiB3ZWJob29rIG5vdGlmaWNhdGlvbnMgZm9yIHRoZSB1c2VyXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyBsaXN0V2ViaG9va05vdGlmaWNhdGlvbnMocGFyYW1zOiBMaXN0V2ViaG9va05vdGlmaWNhdGlvbnNPcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHF1ZXJ5OiBhbnkgPSB7fTtcbiAgICBpZiAocGFyYW1zLnByZXZJZCkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcmV2SWQgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnByZXZJZCA9IHBhcmFtcy5wcmV2SWQ7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubGltaXQpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubGltaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgcXVlcnkubGltaXQgPSBwYXJhbXMubGltaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKCcvd2ViaG9va3Mvbm90aWZpY2F0aW9ucycpKS5xdWVyeShxdWVyeSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2ltdWxhdGUgYSB1c2VyIHdlYmhvb2tcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGFzeW5jIHNpbXVsYXRlV2ViaG9vayhwYXJhbXM6IEJpdEdvU2ltdWxhdGVXZWJob29rT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3ZWJob29rSWQnLCAnYmxvY2tJZCddLCBbXSk7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy53ZWJob29rSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyB3ZWJob29rSWQnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmJsb2NrSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyBibG9ja0lkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybChgL3dlYmhvb2tzLyR7cGFyYW1zLndlYmhvb2tJZH0vc2ltdWxhdGVgKSlcbiAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbm91c2x5IGdldCBjb25zdGFudHMgd2hpY2ggYXJlIHJlbGV2YW50IHRvIHRoZSBjbGllbnQuXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaGFzIGEga25vd24gcmFjZSBjb25kaXRpb24uIEl0IG1heSByZXR1cm4gZGlmZmVyZW50IHZhbHVlcyBvdmVyIHRpbWUsXG4gICAqIGVzcGVjaWFsbHkgaWYgY2FsbGVkIHNob3J0bHkgYWZ0ZXIgY3JlYXRpb24gb2YgdGhlIEJpdEdvIG9iamVjdC5cbiAgICpcbiAgICogTmV3IGNvZGUgc2hvdWxkIGNhbGwgZmV0Y2hDb25zdGFudHMoKSBkaXJlY3RseSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbGllbnQgY29uc3RhbnRzIG9iamVjdFxuICAgKi9cbiAgZ2V0Q29uc3RhbnRzKCk6IGFueSB7XG4gICAgLy8ga2ljayBvZmYgYSBmcmVzaCByZXF1ZXN0IGZvciB0aGUgY2xpZW50IGNvbnN0YW50c1xuICAgIHRoaXMuZmV0Y2hDb25zdGFudHMoKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBhbiBlcnJvciBkb2VzIG5vdCB0ZXJtaW5hdGUgdGhlIGVudGlyZSBzY3JpcHRcbiAgICAgICAgY29uc29sZS5lcnJvcignZmFpbGVkIHRvIGZldGNoIGNsaWVudCBjb25zdGFudHMgZnJvbSBCaXRHbycpO1xuICAgICAgICBjb25zb2xlLnRyYWNlKGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyB1c2UgZGVmYXVsdENvbnN0YW50cyBhcyB0aGUgYmFja3VwIGZvciBrZXlzIHRoYXQgYXJlIG5vdCBzZXQgaW4gdGhpcy5fY29uc3RhbnRzXG4gICAgcmV0dXJuIF8ubWVyZ2Uoe30sIGRlZmF1bHRDb25zdGFudHModGhpcy5nZXRFbnYoKSksIEJpdEdvQVBJLl9jb25zdGFudHNbdGhpcy5nZXRFbnYoKV0pO1xuICB9XG59XG4iXX0=