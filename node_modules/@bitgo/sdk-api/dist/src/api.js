"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyResponse = exports.setRequestQueryString = exports.serializeRequestData = exports.handleResponseError = exports.handleResponseResult = exports.toBitgoRequest = void 0;
/**
 * @prettier
 */
const debug_1 = require("debug");
const eol = require("eol");
const _ = require("lodash");
const sanitizeHtml = require("sanitize-html");
const superagent = require("superagent");
const urlLib = require("url");
const querystring = require("querystring");
const sdk_core_1 = require("@bitgo/sdk-core");
const debug = (0, debug_1.default)('bitgo:api');
/**
 * Add the bitgo-specific result() function on a superagent request.
 *
 * If the server response is successful, the `result()` function will return either the entire response body,
 * or the field from the response body specified by the `optionalField` parameter if it is provided.
 *
 * If the server response with an error, `result()` will handle HTTP errors appropriately by
 * rethrowing them as an `ApiResponseError` if possible, and otherwise rethrowing the underlying response error.
 *
 * @param req
 */
function toBitgoRequest(req) {
    return Object.assign(req, {
        result(optionalField) {
            return req.then((response) => handleResponseResult(optionalField)(response), (error) => handleResponseError(error));
        },
    });
}
exports.toBitgoRequest = toBitgoRequest;
/**
 * Return a function which extracts the specified response body property from the response if successful,
 * otherwise throw an `ApiErrorResponse` parsed from the response body.
 * @param optionalField
 */
function handleResponseResult(optionalField) {
    return function (res) {
        if (_.isNumber(res.status) && res.status >= 200 && res.status < 300) {
            return optionalField ? res.body[optionalField] : res.body;
        }
        throw errFromResponse(res);
    };
}
exports.handleResponseResult = handleResponseResult;
/**
 * Extract relevant information from a successful response (that is, a response with an HTTP status code
 * between 200 and 299), but which resulted in an application specific error and use it to construct and
 * throw an `ApiErrorResponse`.
 *
 * @param res
 */
function errFromResponse(res) {
    var _a;
    const message = createResponseErrorString(res);
    const status = res.status;
    const result = res.body;
    const invalidToken = _.has(res.header, 'x-auth-required') && res.header['x-auth-required'] === 'true';
    const needsOtp = ((_a = res.body) === null || _a === void 0 ? void 0 : _a.needsOTP) !== undefined;
    return new sdk_core_1.ApiResponseError(message, status, result, invalidToken, needsOtp);
}
/**
 * Handle an error or an error containing an HTTP response and use it to throw a well-formed error object.
 *
 * @param e
 */
function handleResponseError(e) {
    if (e.response) {
        throw errFromResponse(e.response);
    }
    throw e;
}
exports.handleResponseError = handleResponseError;
/**
 * There are many ways a request can fail, and may ways information on that failure can be
 * communicated to the client. This function tries to handle those cases and create a sane error string
 * @param res Response from an HTTP request
 */
function createResponseErrorString(res) {
    var _a;
    let errString = res.status.toString(); // at the very least we'll have the status code
    if ((_a = res.body) === null || _a === void 0 ? void 0 : _a.error) {
        // this is the case we hope for, where the server gives us a nice error from the JSON body
        errString = res.body.error;
    }
    else if (res.text) {
        // if the response came back as text, we try to parse it as HTML and remove all tags, leaving us
        // just the bare text, which we then trim of excessive newlines and limit to a certain length
        try {
            let sanitizedText = sanitizeHtml(res.text, { allowedTags: [] });
            sanitizedText = sanitizedText.trim();
            sanitizedText = eol.lf(sanitizedText); // use '\n' for all newlines
            sanitizedText = _.replace(sanitizedText, /\n[ |\t]{1,}\n/g, '\n\n'); // remove the spaces/tabs between newlines
            sanitizedText = _.replace(sanitizedText, /[\n]{3,}/g, '\n\n'); // have at most 2 consecutive newlines
            sanitizedText = sanitizedText.substring(0, 5000); // prevent message from getting too large
            errString = errString + '\n' + sanitizedText; // add it to our existing errString (at this point the more info the better!)
        }
        catch (e) {
            // do nothing, the response's HTML was too wacky to be parsed cleanly
            debug('got error with message "%s" while creating response error string from response: %s', e.message, res.text);
        }
    }
    return errString;
}
/**
 * Serialize request data based on the request content type
 * Note: Not sure this is still needed or even useful. Consider removing.
 * @param req
 */
function serializeRequestData(req) {
    let data = req._data;
    if (typeof data !== 'string') {
        let contentType = req.get('Content-Type');
        // Parse out just the content type from the header (ignore the charset)
        if (contentType) {
            contentType = contentType.split(';')[0];
        }
        let serialize = superagent.serialize[contentType];
        if (!serialize && /[\/+]json\b/.test(contentType)) {
            serialize = superagent.serialize['application/json'];
        }
        if (serialize) {
            data = serialize(data);
            req._data = data;
            return data;
        }
    }
}
exports.serializeRequestData = serializeRequestData;
/**
 * Set the superagent query string correctly for browsers or node.
 * @param req
 */
function setRequestQueryString(req) {
    const urlDetails = urlLib.parse(req.url);
    let queryString;
    const query = req._query;
    const qs = req.qs;
    if (query && query.length > 0) {
        // browser version
        queryString = query.join('&');
        req._query = [];
    }
    else if (qs) {
        // node version
        queryString = querystring.stringify(qs);
        req.qs = null;
    }
    if (queryString) {
        if (urlDetails.search) {
            urlDetails.search += '&' + queryString;
        }
        else {
            urlDetails.search = '?' + queryString;
        }
        req.url = urlLib.format(urlDetails);
    }
}
exports.setRequestQueryString = setRequestQueryString;
/**
 * Verify that the response received from the server is signed correctly.
 * Right now, it is very permissive with the timestamp variance.
 */
function verifyResponse(bitgo, token, method, req, response) {
    // we can't verify the response if we're not authenticated
    if (!req.isV2Authenticated || !req.authenticationToken) {
        return response;
    }
    const verificationResponse = bitgo.verifyResponse({
        url: req.url,
        hmac: response.header.hmac,
        statusCode: response.status,
        text: response.text,
        timestamp: response.header.timestamp,
        token: req.authenticationToken,
        method,
    });
    if (!verificationResponse.isValid) {
        // calculate the HMAC
        const receivedHmac = response.header.hmac;
        const expectedHmac = verificationResponse.expectedHmac;
        const signatureSubject = verificationResponse.signatureSubject;
        // Log only the first 10 characters of the token to ensure the full token isn't logged.
        const partialBitgoToken = token ? token.substring(0, 10) : '';
        const errorDetails = {
            expectedHmac,
            receivedHmac,
            hmacInput: signatureSubject,
            requestToken: req.authenticationToken,
            bitgoToken: partialBitgoToken,
        };
        debug('Invalid response HMAC: %O', errorDetails);
        throw new sdk_core_1.ApiResponseError('invalid response HMAC, possible man-in-the-middle-attack', 511, errorDetails);
    }
    if (bitgo.getAuthVersion() === 3 && !verificationResponse.isInResponseValidityWindow) {
        const errorDetails = {
            timestamp: response.header.timestamp,
            verificationTime: verificationResponse.verificationTime,
        };
        debug('Server response outside response validity time window: %O', errorDetails);
        throw new sdk_core_1.ApiResponseError('server response outside response validity time window, possible man-in-the-middle-attack', 511, errorDetails);
    }
    return response;
}
exports.verifyResponse = verifyResponse;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2FwaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7R0FFRztBQUNILGlDQUEwQjtBQUMxQiwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCLDhDQUE4QztBQUM5Qyx5Q0FBeUM7QUFDekMsOEJBQThCO0FBQzlCLDJDQUEyQztBQUUzQyw4Q0FBaUU7QUFLakUsTUFBTSxLQUFLLEdBQUcsSUFBQSxlQUFLLEVBQUMsV0FBVyxDQUFDLENBQUM7QUFFakM7Ozs7Ozs7Ozs7R0FVRztBQUNILFNBQWdCLGNBQWMsQ0FDNUIsR0FBaUM7SUFFakMsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRTtRQUN4QixNQUFNLENBQUMsYUFBc0I7WUFDM0IsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUNiLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBcUIsYUFBYSxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQy9FLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FDdEMsQ0FBQztRQUNKLENBQUM7S0FDRixDQUFDLENBQUM7QUFDTCxDQUFDO0FBWEQsd0NBV0M7QUFFRDs7OztHQUlHO0FBQ0gsU0FBZ0Isb0JBQW9CLENBQ2xDLGFBQXNCO0lBRXRCLE9BQU8sVUFBVSxHQUF3QjtRQUN2QyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEdBQUcsR0FBRyxFQUFFO1lBQ25FLE9BQU8sYUFBYSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO1NBQzNEO1FBQ0QsTUFBTSxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUM7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Qy9ELHVGQUF1RjtRQUN2RixNQUFNLGlCQUFpQixHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUM5RCxNQUFNLFlBQVksR0FBRztZQUNuQixZQUFZO1lBQ1osWUFBWTtZQUNaLFNBQVMsRUFBRSxnQkFBZ0I7WUFDM0IsWUFBWSxFQUFFLEdBQUcsQ0FBQyxtQkFBbUI7WUFDckMsVUFBVSxFQUFFLGlCQUFpQjtTQUM5QixDQUFDO1FBQ0YsS0FBSyxDQUFDLDJCQUEyQixFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ2pELE1BQU0sSUFBSSwyQkFBZ0IsQ0FBQywwREFBMEQsRUFBRSxHQUFHLEVBQUUsWUFBWSxDQUFDLENBQUM7S0FDM0c7SUFFRCxJQUFJLEtBQUssQ0FBQyxjQUFjLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQywwQkFBMEIsRUFBRTtRQUNwRixNQUFNLFlBQVksR0FBRztZQUNuQixTQUFTLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxTQUFTO1lBQ3BDLGdCQUFnQixFQUFFLG9CQUFvQixDQUFDLGdCQUFnQjtTQUN4RCxDQUFDO1FBQ0YsS0FBSyxDQUFDLDJEQUEyRCxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ2pGLE1BQU0sSUFBSSwyQkFBZ0IsQ0FDeEIsMEZBQTBGLEVBQzFGLEdBQUcsRUFDSCxZQUFZLENBQ2IsQ0FBQztLQUNIO0lBQ0QsT0FBTyxRQUFRLENBQUM7QUFDbEIsQ0FBQztBQXJERCx3Q0FxREMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgRGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0ICogYXMgZW9sIGZyb20gJ2VvbCc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBzYW5pdGl6ZUh0bWwgZnJvbSAnc2FuaXRpemUtaHRtbCc7XG5pbXBvcnQgKiBhcyBzdXBlcmFnZW50IGZyb20gJ3N1cGVyYWdlbnQnO1xuaW1wb3J0ICogYXMgdXJsTGliIGZyb20gJ3VybCc7XG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICdxdWVyeXN0cmluZyc7XG5cbmltcG9ydCB7IEFwaVJlc3BvbnNlRXJyb3IsIEJpdEdvUmVxdWVzdCB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5cbmltcG9ydCB7IFZlcmlmeVJlc3BvbnNlT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgQml0R29BUEkgfSBmcm9tICcuL2JpdGdvQVBJJztcblxuY29uc3QgZGVidWcgPSBEZWJ1ZygnYml0Z286YXBpJyk7XG5cbi8qKlxuICogQWRkIHRoZSBiaXRnby1zcGVjaWZpYyByZXN1bHQoKSBmdW5jdGlvbiBvbiBhIHN1cGVyYWdlbnQgcmVxdWVzdC5cbiAqXG4gKiBJZiB0aGUgc2VydmVyIHJlc3BvbnNlIGlzIHN1Y2Nlc3NmdWwsIHRoZSBgcmVzdWx0KClgIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGVpdGhlciB0aGUgZW50aXJlIHJlc3BvbnNlIGJvZHksXG4gKiBvciB0aGUgZmllbGQgZnJvbSB0aGUgcmVzcG9uc2UgYm9keSBzcGVjaWZpZWQgYnkgdGhlIGBvcHRpb25hbEZpZWxkYCBwYXJhbWV0ZXIgaWYgaXQgaXMgcHJvdmlkZWQuXG4gKlxuICogSWYgdGhlIHNlcnZlciByZXNwb25zZSB3aXRoIGFuIGVycm9yLCBgcmVzdWx0KClgIHdpbGwgaGFuZGxlIEhUVFAgZXJyb3JzIGFwcHJvcHJpYXRlbHkgYnlcbiAqIHJldGhyb3dpbmcgdGhlbSBhcyBhbiBgQXBpUmVzcG9uc2VFcnJvcmAgaWYgcG9zc2libGUsIGFuZCBvdGhlcndpc2UgcmV0aHJvd2luZyB0aGUgdW5kZXJseWluZyByZXNwb25zZSBlcnJvci5cbiAqXG4gKiBAcGFyYW0gcmVxXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JpdGdvUmVxdWVzdDxSZXNwb25zZVJlc3VsdFR5cGUgPSBhbnk+KFxuICByZXE6IHN1cGVyYWdlbnQuU3VwZXJBZ2VudFJlcXVlc3Rcbik6IEJpdEdvUmVxdWVzdDxSZXNwb25zZVJlc3VsdFR5cGU+IHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocmVxLCB7XG4gICAgcmVzdWx0KG9wdGlvbmFsRmllbGQ/OiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiByZXEudGhlbihcbiAgICAgICAgKHJlc3BvbnNlKSA9PiBoYW5kbGVSZXNwb25zZVJlc3VsdDxSZXNwb25zZVJlc3VsdFR5cGU+KG9wdGlvbmFsRmllbGQpKHJlc3BvbnNlKSxcbiAgICAgICAgKGVycm9yKSA9PiBoYW5kbGVSZXNwb25zZUVycm9yKGVycm9yKVxuICAgICAgKTtcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB3aGljaCBleHRyYWN0cyB0aGUgc3BlY2lmaWVkIHJlc3BvbnNlIGJvZHkgcHJvcGVydHkgZnJvbSB0aGUgcmVzcG9uc2UgaWYgc3VjY2Vzc2Z1bCxcbiAqIG90aGVyd2lzZSB0aHJvdyBhbiBgQXBpRXJyb3JSZXNwb25zZWAgcGFyc2VkIGZyb20gdGhlIHJlc3BvbnNlIGJvZHkuXG4gKiBAcGFyYW0gb3B0aW9uYWxGaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2VSZXN1bHQ8UmVzcG9uc2VSZXN1bHRUeXBlPihcbiAgb3B0aW9uYWxGaWVsZD86IHN0cmluZ1xuKTogKHJlczogc3VwZXJhZ2VudC5SZXNwb25zZSkgPT4gUmVzcG9uc2VSZXN1bHRUeXBlIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXM6IHN1cGVyYWdlbnQuUmVzcG9uc2UpOiBSZXNwb25zZVJlc3VsdFR5cGUge1xuICAgIGlmIChfLmlzTnVtYmVyKHJlcy5zdGF0dXMpICYmIHJlcy5zdGF0dXMgPj0gMjAwICYmIHJlcy5zdGF0dXMgPCAzMDApIHtcbiAgICAgIHJldHVybiBvcHRpb25hbEZpZWxkID8gcmVzLmJvZHlbb3B0aW9uYWxGaWVsZF0gOiByZXMuYm9keTtcbiAgICB9XG4gICAgdGhyb3cgZXJyRnJvbVJlc3BvbnNlKHJlcyk7XG4gIH07XG59XG5cbi8qKlxuICogRXh0cmFjdCByZWxldmFudCBpbmZvcm1hdGlvbiBmcm9tIGEgc3VjY2Vzc2Z1bCByZXNwb25zZSAodGhhdCBpcywgYSByZXNwb25zZSB3aXRoIGFuIEhUVFAgc3RhdHVzIGNvZGVcbiAqIGJldHdlZW4gMjAwIGFuZCAyOTkpLCBidXQgd2hpY2ggcmVzdWx0ZWQgaW4gYW4gYXBwbGljYXRpb24gc3BlY2lmaWMgZXJyb3IgYW5kIHVzZSBpdCB0byBjb25zdHJ1Y3QgYW5kXG4gKiB0aHJvdyBhbiBgQXBpRXJyb3JSZXNwb25zZWAuXG4gKlxuICogQHBhcmFtIHJlc1xuICovXG5mdW5jdGlvbiBlcnJGcm9tUmVzcG9uc2U8UmVzcG9uc2VCb2R5VHlwZT4ocmVzOiBzdXBlcmFnZW50LlJlc3BvbnNlKTogQXBpUmVzcG9uc2VFcnJvciB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVSZXNwb25zZUVycm9yU3RyaW5nKHJlcyk7XG4gIGNvbnN0IHN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gIGNvbnN0IHJlc3VsdCA9IHJlcy5ib2R5IGFzIFJlc3BvbnNlQm9keVR5cGU7XG4gIGNvbnN0IGludmFsaWRUb2tlbiA9IF8uaGFzKHJlcy5oZWFkZXIsICd4LWF1dGgtcmVxdWlyZWQnKSAmJiByZXMuaGVhZGVyWyd4LWF1dGgtcmVxdWlyZWQnXSA9PT0gJ3RydWUnO1xuICBjb25zdCBuZWVkc090cCA9IHJlcy5ib2R5Py5uZWVkc09UUCAhPT0gdW5kZWZpbmVkO1xuICByZXR1cm4gbmV3IEFwaVJlc3BvbnNlRXJyb3IobWVzc2FnZSwgc3RhdHVzLCByZXN1bHQsIGludmFsaWRUb2tlbiwgbmVlZHNPdHApO1xufVxuXG4vKipcbiAqIEhhbmRsZSBhbiBlcnJvciBvciBhbiBlcnJvciBjb250YWluaW5nIGFuIEhUVFAgcmVzcG9uc2UgYW5kIHVzZSBpdCB0byB0aHJvdyBhIHdlbGwtZm9ybWVkIGVycm9yIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2VFcnJvcihlOiBFcnJvciAmIHsgcmVzcG9uc2U/OiBzdXBlcmFnZW50LlJlc3BvbnNlIH0pOiBuZXZlciB7XG4gIGlmIChlLnJlc3BvbnNlKSB7XG4gICAgdGhyb3cgZXJyRnJvbVJlc3BvbnNlKGUucmVzcG9uc2UpO1xuICB9XG4gIHRocm93IGU7XG59XG5cbi8qKlxuICogVGhlcmUgYXJlIG1hbnkgd2F5cyBhIHJlcXVlc3QgY2FuIGZhaWwsIGFuZCBtYXkgd2F5cyBpbmZvcm1hdGlvbiBvbiB0aGF0IGZhaWx1cmUgY2FuIGJlXG4gKiBjb21tdW5pY2F0ZWQgdG8gdGhlIGNsaWVudC4gVGhpcyBmdW5jdGlvbiB0cmllcyB0byBoYW5kbGUgdGhvc2UgY2FzZXMgYW5kIGNyZWF0ZSBhIHNhbmUgZXJyb3Igc3RyaW5nXG4gKiBAcGFyYW0gcmVzIFJlc3BvbnNlIGZyb20gYW4gSFRUUCByZXF1ZXN0XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlRXJyb3JTdHJpbmcocmVzOiBzdXBlcmFnZW50LlJlc3BvbnNlKTogc3RyaW5nIHtcbiAgbGV0IGVyclN0cmluZyA9IHJlcy5zdGF0dXMudG9TdHJpbmcoKTsgLy8gYXQgdGhlIHZlcnkgbGVhc3Qgd2UnbGwgaGF2ZSB0aGUgc3RhdHVzIGNvZGVcbiAgaWYgKHJlcy5ib2R5Py5lcnJvcikge1xuICAgIC8vIHRoaXMgaXMgdGhlIGNhc2Ugd2UgaG9wZSBmb3IsIHdoZXJlIHRoZSBzZXJ2ZXIgZ2l2ZXMgdXMgYSBuaWNlIGVycm9yIGZyb20gdGhlIEpTT04gYm9keVxuICAgIGVyclN0cmluZyA9IHJlcy5ib2R5LmVycm9yO1xuICB9IGVsc2UgaWYgKHJlcy50ZXh0KSB7XG4gICAgLy8gaWYgdGhlIHJlc3BvbnNlIGNhbWUgYmFjayBhcyB0ZXh0LCB3ZSB0cnkgdG8gcGFyc2UgaXQgYXMgSFRNTCBhbmQgcmVtb3ZlIGFsbCB0YWdzLCBsZWF2aW5nIHVzXG4gICAgLy8ganVzdCB0aGUgYmFyZSB0ZXh0LCB3aGljaCB3ZSB0aGVuIHRyaW0gb2YgZXhjZXNzaXZlIG5ld2xpbmVzIGFuZCBsaW1pdCB0byBhIGNlcnRhaW4gbGVuZ3RoXG4gICAgdHJ5IHtcbiAgICAgIGxldCBzYW5pdGl6ZWRUZXh0ID0gc2FuaXRpemVIdG1sKHJlcy50ZXh0LCB7IGFsbG93ZWRUYWdzOiBbXSB9KTtcbiAgICAgIHNhbml0aXplZFRleHQgPSBzYW5pdGl6ZWRUZXh0LnRyaW0oKTtcbiAgICAgIHNhbml0aXplZFRleHQgPSBlb2wubGYoc2FuaXRpemVkVGV4dCk7IC8vIHVzZSAnXFxuJyBmb3IgYWxsIG5ld2xpbmVzXG4gICAgICBzYW5pdGl6ZWRUZXh0ID0gXy5yZXBsYWNlKHNhbml0aXplZFRleHQsIC9cXG5bIHxcXHRdezEsfVxcbi9nLCAnXFxuXFxuJyk7IC8vIHJlbW92ZSB0aGUgc3BhY2VzL3RhYnMgYmV0d2VlbiBuZXdsaW5lc1xuICAgICAgc2FuaXRpemVkVGV4dCA9IF8ucmVwbGFjZShzYW5pdGl6ZWRUZXh0LCAvW1xcbl17Myx9L2csICdcXG5cXG4nKTsgLy8gaGF2ZSBhdCBtb3N0IDIgY29uc2VjdXRpdmUgbmV3bGluZXNcbiAgICAgIHNhbml0aXplZFRleHQgPSBzYW5pdGl6ZWRUZXh0LnN1YnN0cmluZygwLCA1MDAwKTsgLy8gcHJldmVudCBtZXNzYWdlIGZyb20gZ2V0dGluZyB0b28gbGFyZ2VcbiAgICAgIGVyclN0cmluZyA9IGVyclN0cmluZyArICdcXG4nICsgc2FuaXRpemVkVGV4dDsgLy8gYWRkIGl0IHRvIG91ciBleGlzdGluZyBlcnJTdHJpbmcgKGF0IHRoaXMgcG9pbnQgdGhlIG1vcmUgaW5mbyB0aGUgYmV0dGVyISlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBkbyBub3RoaW5nLCB0aGUgcmVzcG9uc2UncyBIVE1MIHdhcyB0b28gd2Fja3kgdG8gYmUgcGFyc2VkIGNsZWFubHlcbiAgICAgIGRlYnVnKCdnb3QgZXJyb3Igd2l0aCBtZXNzYWdlIFwiJXNcIiB3aGlsZSBjcmVhdGluZyByZXNwb25zZSBlcnJvciBzdHJpbmcgZnJvbSByZXNwb25zZTogJXMnLCBlLm1lc3NhZ2UsIHJlcy50ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXJyU3RyaW5nO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSByZXF1ZXN0IGRhdGEgYmFzZWQgb24gdGhlIHJlcXVlc3QgY29udGVudCB0eXBlXG4gKiBOb3RlOiBOb3Qgc3VyZSB0aGlzIGlzIHN0aWxsIG5lZWRlZCBvciBldmVuIHVzZWZ1bC4gQ29uc2lkZXIgcmVtb3ZpbmcuXG4gKiBAcGFyYW0gcmVxXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVSZXF1ZXN0RGF0YShyZXE6IHN1cGVyYWdlbnQuUmVxdWVzdCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGxldCBkYXRhOiBzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IChyZXEgYXMgYW55KS5fZGF0YTtcbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgIGxldCBjb250ZW50VHlwZSA9IHJlcS5nZXQoJ0NvbnRlbnQtVHlwZScpO1xuICAgIC8vIFBhcnNlIG91dCBqdXN0IHRoZSBjb250ZW50IHR5cGUgZnJvbSB0aGUgaGVhZGVyIChpZ25vcmUgdGhlIGNoYXJzZXQpXG4gICAgaWYgKGNvbnRlbnRUeXBlKSB7XG4gICAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF07XG4gICAgfVxuICAgIGxldCBzZXJpYWxpemUgPSBzdXBlcmFnZW50LnNlcmlhbGl6ZVtjb250ZW50VHlwZV07XG4gICAgaWYgKCFzZXJpYWxpemUgJiYgL1tcXC8rXWpzb25cXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICBzZXJpYWxpemUgPSBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24vanNvbiddO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXplKSB7XG4gICAgICBkYXRhID0gc2VyaWFsaXplKGRhdGEpO1xuICAgICAgKHJlcSBhcyBhbnkpLl9kYXRhID0gZGF0YTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNldCB0aGUgc3VwZXJhZ2VudCBxdWVyeSBzdHJpbmcgY29ycmVjdGx5IGZvciBicm93c2VycyBvciBub2RlLlxuICogQHBhcmFtIHJlcVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UmVxdWVzdFF1ZXJ5U3RyaW5nKHJlcTogc3VwZXJhZ2VudC5TdXBlckFnZW50UmVxdWVzdCk6IHZvaWQge1xuICBjb25zdCB1cmxEZXRhaWxzID0gdXJsTGliLnBhcnNlKHJlcS51cmwpO1xuXG4gIGxldCBxdWVyeVN0cmluZzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBjb25zdCBxdWVyeTogc3RyaW5nW10gPSAocmVxIGFzIGFueSkuX3F1ZXJ5O1xuICBjb25zdCBxczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IChyZXEgYXMgYW55KS5xcztcbiAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5Lmxlbmd0aCA+IDApIHtcbiAgICAvLyBicm93c2VyIHZlcnNpb25cbiAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5LmpvaW4oJyYnKTtcbiAgICAocmVxIGFzIGFueSkuX3F1ZXJ5ID0gW107XG4gIH0gZWxzZSBpZiAocXMpIHtcbiAgICAvLyBub2RlIHZlcnNpb25cbiAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShxcyk7XG4gICAgKHJlcSBhcyBhbnkpLnFzID0gbnVsbDtcbiAgfVxuXG4gIGlmIChxdWVyeVN0cmluZykge1xuICAgIGlmICh1cmxEZXRhaWxzLnNlYXJjaCkge1xuICAgICAgdXJsRGV0YWlscy5zZWFyY2ggKz0gJyYnICsgcXVlcnlTdHJpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVybERldGFpbHMuc2VhcmNoID0gJz8nICsgcXVlcnlTdHJpbmc7XG4gICAgfVxuICAgIHJlcS51cmwgPSB1cmxMaWIuZm9ybWF0KHVybERldGFpbHMpO1xuICB9XG59XG5cbi8qKlxuICogVmVyaWZ5IHRoYXQgdGhlIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBpcyBzaWduZWQgY29ycmVjdGx5LlxuICogUmlnaHQgbm93LCBpdCBpcyB2ZXJ5IHBlcm1pc3NpdmUgd2l0aCB0aGUgdGltZXN0YW1wIHZhcmlhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5UmVzcG9uc2UoXG4gIGJpdGdvOiBCaXRHb0FQSSxcbiAgdG9rZW46IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgbWV0aG9kOiBWZXJpZnlSZXNwb25zZU9wdGlvbnNbJ21ldGhvZCddLFxuICByZXE6IHN1cGVyYWdlbnQuU3VwZXJBZ2VudFJlcXVlc3QsXG4gIHJlc3BvbnNlOiBzdXBlcmFnZW50LlJlc3BvbnNlXG4pOiBzdXBlcmFnZW50LlJlc3BvbnNlIHtcbiAgLy8gd2UgY2FuJ3QgdmVyaWZ5IHRoZSByZXNwb25zZSBpZiB3ZSdyZSBub3QgYXV0aGVudGljYXRlZFxuICBpZiAoIXJlcS5pc1YyQXV0aGVudGljYXRlZCB8fCAhcmVxLmF1dGhlbnRpY2F0aW9uVG9rZW4pIHtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICBjb25zdCB2ZXJpZmljYXRpb25SZXNwb25zZSA9IGJpdGdvLnZlcmlmeVJlc3BvbnNlKHtcbiAgICB1cmw6IHJlcS51cmwsXG4gICAgaG1hYzogcmVzcG9uc2UuaGVhZGVyLmhtYWMsXG4gICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgIHRleHQ6IHJlc3BvbnNlLnRleHQsXG4gICAgdGltZXN0YW1wOiByZXNwb25zZS5oZWFkZXIudGltZXN0YW1wLFxuICAgIHRva2VuOiByZXEuYXV0aGVudGljYXRpb25Ub2tlbixcbiAgICBtZXRob2QsXG4gIH0pO1xuXG4gIGlmICghdmVyaWZpY2F0aW9uUmVzcG9uc2UuaXNWYWxpZCkge1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgSE1BQ1xuICAgIGNvbnN0IHJlY2VpdmVkSG1hYyA9IHJlc3BvbnNlLmhlYWRlci5obWFjO1xuICAgIGNvbnN0IGV4cGVjdGVkSG1hYyA9IHZlcmlmaWNhdGlvblJlc3BvbnNlLmV4cGVjdGVkSG1hYztcbiAgICBjb25zdCBzaWduYXR1cmVTdWJqZWN0ID0gdmVyaWZpY2F0aW9uUmVzcG9uc2Uuc2lnbmF0dXJlU3ViamVjdDtcbiAgICAvLyBMb2cgb25seSB0aGUgZmlyc3QgMTAgY2hhcmFjdGVycyBvZiB0aGUgdG9rZW4gdG8gZW5zdXJlIHRoZSBmdWxsIHRva2VuIGlzbid0IGxvZ2dlZC5cbiAgICBjb25zdCBwYXJ0aWFsQml0Z29Ub2tlbiA9IHRva2VuID8gdG9rZW4uc3Vic3RyaW5nKDAsIDEwKSA6ICcnO1xuICAgIGNvbnN0IGVycm9yRGV0YWlscyA9IHtcbiAgICAgIGV4cGVjdGVkSG1hYyxcbiAgICAgIHJlY2VpdmVkSG1hYyxcbiAgICAgIGhtYWNJbnB1dDogc2lnbmF0dXJlU3ViamVjdCxcbiAgICAgIHJlcXVlc3RUb2tlbjogcmVxLmF1dGhlbnRpY2F0aW9uVG9rZW4sXG4gICAgICBiaXRnb1Rva2VuOiBwYXJ0aWFsQml0Z29Ub2tlbixcbiAgICB9O1xuICAgIGRlYnVnKCdJbnZhbGlkIHJlc3BvbnNlIEhNQUM6ICVPJywgZXJyb3JEZXRhaWxzKTtcbiAgICB0aHJvdyBuZXcgQXBpUmVzcG9uc2VFcnJvcignaW52YWxpZCByZXNwb25zZSBITUFDLCBwb3NzaWJsZSBtYW4taW4tdGhlLW1pZGRsZS1hdHRhY2snLCA1MTEsIGVycm9yRGV0YWlscyk7XG4gIH1cblxuICBpZiAoYml0Z28uZ2V0QXV0aFZlcnNpb24oKSA9PT0gMyAmJiAhdmVyaWZpY2F0aW9uUmVzcG9uc2UuaXNJblJlc3BvbnNlVmFsaWRpdHlXaW5kb3cpIHtcbiAgICBjb25zdCBlcnJvckRldGFpbHMgPSB7XG4gICAgICB0aW1lc3RhbXA6IHJlc3BvbnNlLmhlYWRlci50aW1lc3RhbXAsXG4gICAgICB2ZXJpZmljYXRpb25UaW1lOiB2ZXJpZmljYXRpb25SZXNwb25zZS52ZXJpZmljYXRpb25UaW1lLFxuICAgIH07XG4gICAgZGVidWcoJ1NlcnZlciByZXNwb25zZSBvdXRzaWRlIHJlc3BvbnNlIHZhbGlkaXR5IHRpbWUgd2luZG93OiAlTycsIGVycm9yRGV0YWlscyk7XG4gICAgdGhyb3cgbmV3IEFwaVJlc3BvbnNlRXJyb3IoXG4gICAgICAnc2VydmVyIHJlc3BvbnNlIG91dHNpZGUgcmVzcG9uc2UgdmFsaWRpdHkgdGltZSB3aW5kb3csIHBvc3NpYmxlIG1hbi1pbi10aGUtbWlkZGxlLWF0dGFjaycsXG4gICAgICA1MTEsXG4gICAgICBlcnJvckRldGFpbHNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNwb25zZTtcbn1cbiJdfQ==