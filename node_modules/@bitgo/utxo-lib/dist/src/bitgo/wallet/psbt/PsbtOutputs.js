"use strict";
/**
 * Contains helper methods for determining if a transaction output belongs to a given BitGo wallet
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTotalAmountOfInternalOutputs = exports.findInternalOutputIndices = exports.getTotalAmountOfWalletOutputs = exports.findWalletOutputIndices = exports.isWalletOutput = exports.deriveKeyPairForOutput = void 0;
const types_1 = require("../../types");
const outputScripts_1 = require("../../outputScripts");
const UtxoPsbt_1 = require("../../UtxoPsbt");
const utils_1 = require("bip174/src/lib/utils");
const RootNodes_1 = require("./RootNodes");
/**
 * Derives the appropriate BIP32 key pair for a given output.
 * It uses either tapBip32Derivation or bip32Derivation paths from the output.
 * @param bip32 - The BIP32Interface object to derive from.
 * @param output - The specific PSBT output to derive for.
 * @returns The derived BIP32 key pair if master fingerprint matches, or undefined.
 */
function deriveKeyPairForOutput(bip32, output) {
    var _a, _b;
    return ((_a = output.tapBip32Derivation) === null || _a === void 0 ? void 0 : _a.length)
        ? UtxoPsbt_1.UtxoPsbt.deriveKeyPair(bip32, output.tapBip32Derivation, { ignoreY: true })
        : ((_b = output.bip32Derivation) === null || _b === void 0 ? void 0 : _b.length)
            ? UtxoPsbt_1.UtxoPsbt.deriveKeyPair(bip32, output.bip32Derivation, { ignoreY: false })
            : undefined;
}
exports.deriveKeyPairForOutput = deriveKeyPairForOutput;
/**
 * Determines if a specified output in a PSBT is an output of the wallet represented by the given root nodes.
 * @param psbt - The PSBT to check.
 * @param outputIndex - The index of the output to check.
 * @param rootWalletNodes - The root nodes representing the wallet.
 * @returns A boolean indicating if the output belongs to the wallet.
 */
function isWalletOutput(psbt, outputIndex, rootWalletNodes) {
    const output = (0, utils_1.checkForOutput)(psbt.data.outputs, outputIndex);
    const pubKeys = rootWalletNodes.map((rootNode) => { var _a; return (_a = deriveKeyPairForOutput(rootNode, output)) === null || _a === void 0 ? void 0 : _a.publicKey; });
    if (!(0, types_1.isBufferArray)(pubKeys)) {
        return false;
    }
    const outputScript = psbt.getOutputScript(outputIndex);
    return outputScripts_1.scriptTypes2Of3.some((scriptType) => (0, outputScripts_1.createOutputScript2of3)(pubKeys, scriptType).scriptPubKey.equals(outputScript));
}
exports.isWalletOutput = isWalletOutput;
/**
 * Finds indices of all outputs in a PSBT that belong to the wallet represented by the given root nodes.
 * @param psbt - The PSBT to search through.
 * @param rootWalletNodes - The root nodes representing the wallet.
 * @returns An array of indices corresponding to wallet outputs.
 */
function findWalletOutputIndices(psbt, rootWalletNodes) {
    return psbt.data.outputs.flatMap((_, i) => (isWalletOutput(psbt, i, rootWalletNodes) ? [i] : []));
}
exports.findWalletOutputIndices = findWalletOutputIndices;
/**
 * Calculates the total amount of all wallet outputs in a PSBT for the wallet represented by the given root nodes.
 * @param psbt - The PSBT to calculate for.
 * @param rootWalletNodes - The root nodes representing the wallet.
 * @returns The total amount of wallet outputs.
 */
function getTotalAmountOfWalletOutputs(psbt, rootWalletNodes) {
    const indices = findWalletOutputIndices(psbt, rootWalletNodes);
    const txOutputs = psbt.txOutputs;
    return indices.reduce((sum, i) => sum + txOutputs[i].value, BigInt(0));
}
exports.getTotalAmountOfWalletOutputs = getTotalAmountOfWalletOutputs;
/**
 * Finds indices of all internal outputs in a PSBT, identified as outputs belonging to the wallet's root nodes within the PSBT.
 * @param psbt - The PSBT containing the wallet's root nodes as indicated by global Xpubs.
 * @returns An array of indices of internal outputs.
 */
function findInternalOutputIndices(psbt) {
    const rootNodes = (0, RootNodes_1.getSortedRootNodes)(psbt);
    return findWalletOutputIndices(psbt, rootNodes);
}
exports.findInternalOutputIndices = findInternalOutputIndices;
/**
 * Calculates the total amount of all internal outputs in a PSBT, identified as outputs belonging to the wallet's root nodes within the PSBT.
 * @param psbt - The PSBT containing the wallet's root nodes as indicated by global Xpubs.
 * @returns The total amount of internal outputs.
 */
function getTotalAmountOfInternalOutputs(psbt) {
    const rootNodes = (0, RootNodes_1.getSortedRootNodes)(psbt);
    return getTotalAmountOfWalletOutputs(psbt, rootNodes);
}
exports.getTotalAmountOfInternalOutputs = getTotalAmountOfInternalOutputs;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHNidE91dHB1dHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvYml0Z28vd2FsbGV0L3BzYnQvUHNidE91dHB1dHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOztHQUVHOzs7QUFFSCx1Q0FBb0Q7QUFDcEQsdURBQThFO0FBQzlFLDZDQUEwQztBQUUxQyxnREFBc0Q7QUFFdEQsMkNBQWlEO0FBRWpEOzs7Ozs7R0FNRztBQUNILFNBQWdCLHNCQUFzQixDQUFDLEtBQXFCLEVBQUUsTUFBa0I7O0lBQzlFLE9BQU8sQ0FBQSxNQUFBLE1BQU0sQ0FBQyxrQkFBa0IsMENBQUUsTUFBTTtRQUN0QyxDQUFDLENBQUMsbUJBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQztRQUM3RSxDQUFDLENBQUMsQ0FBQSxNQUFBLE1BQU0sQ0FBQyxlQUFlLDBDQUFFLE1BQU07WUFDaEMsQ0FBQyxDQUFDLG1CQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsZUFBZSxFQUFFLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxDQUFDO1lBQzNFLENBQUMsQ0FBQyxTQUFTLENBQUM7QUFDaEIsQ0FBQztBQU5ELHdEQU1DO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsY0FBYyxDQUFDLElBQWMsRUFBRSxXQUFtQixFQUFFLGVBQXVDO0lBQ3pHLE1BQU0sTUFBTSxHQUFHLElBQUEsc0JBQWMsRUFBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQztJQUU5RCxNQUFNLE9BQU8sR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUUsV0FBQyxPQUFBLE1BQUEsc0JBQXNCLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQywwQ0FBRSxTQUFTLENBQUEsRUFBQSxDQUFDLENBQUM7SUFFdkcsSUFBSSxDQUFDLElBQUEscUJBQWEsRUFBQyxPQUFPLENBQUMsRUFBRTtRQUMzQixPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUN2RCxPQUFPLCtCQUFlLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FDekMsSUFBQSxzQ0FBc0IsRUFBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FDOUUsQ0FBQztBQUNKLENBQUM7QUFiRCx3Q0FhQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsdUJBQXVCLENBQUMsSUFBYyxFQUFFLGVBQXVDO0lBQzdGLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNwRyxDQUFDO0FBRkQsMERBRUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLDZCQUE2QixDQUFDLElBQWMsRUFBRSxlQUF1QztJQUNuRyxNQUFNLE9BQU8sR0FBRyx1QkFBdUIsQ0FBQyxJQUFJLEVBQUUsZUFBZSxDQUFDLENBQUM7SUFDL0QsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUNqQyxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6RSxDQUFDO0FBSkQsc0VBSUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBZ0IseUJBQXlCLENBQUMsSUFBYztJQUN0RCxNQUFNLFNBQVMsR0FBRyxJQUFBLDhCQUFrQixFQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNDLE9BQU8sdUJBQXVCLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ2xELENBQUM7QUFIRCw4REFHQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQiwrQkFBK0IsQ0FBQyxJQUFjO0lBQzVELE1BQU0sU0FBUyxHQUFHLElBQUEsOEJBQWtCLEVBQUMsSUFBSSxDQUFDLENBQUM7SUFDM0MsT0FBTyw2QkFBNkIsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDeEQsQ0FBQztBQUhELDBFQUdDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb250YWlucyBoZWxwZXIgbWV0aG9kcyBmb3IgZGV0ZXJtaW5pbmcgaWYgYSB0cmFuc2FjdGlvbiBvdXRwdXQgYmVsb25ncyB0byBhIGdpdmVuIEJpdEdvIHdhbGxldFxuICovXG5cbmltcG9ydCB7IGlzQnVmZmVyQXJyYXksIFRyaXBsZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IGNyZWF0ZU91dHB1dFNjcmlwdDJvZjMsIHNjcmlwdFR5cGVzMk9mMyB9IGZyb20gJy4uLy4uL291dHB1dFNjcmlwdHMnO1xuaW1wb3J0IHsgVXR4b1BzYnQgfSBmcm9tICcuLi8uLi9VdHhvUHNidCc7XG5pbXBvcnQgeyBCSVAzMkludGVyZmFjZSB9IGZyb20gJ2JpcDMyJztcbmltcG9ydCB7IGNoZWNrRm9yT3V0cHV0IH0gZnJvbSAnYmlwMTc0L3NyYy9saWIvdXRpbHMnO1xuaW1wb3J0IHsgUHNidE91dHB1dCB9IGZyb20gJ2JpcDE3NC9zcmMvbGliL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgZ2V0U29ydGVkUm9vdE5vZGVzIH0gZnJvbSAnLi9Sb290Tm9kZXMnO1xuXG4vKipcbiAqIERlcml2ZXMgdGhlIGFwcHJvcHJpYXRlIEJJUDMyIGtleSBwYWlyIGZvciBhIGdpdmVuIG91dHB1dC5cbiAqIEl0IHVzZXMgZWl0aGVyIHRhcEJpcDMyRGVyaXZhdGlvbiBvciBiaXAzMkRlcml2YXRpb24gcGF0aHMgZnJvbSB0aGUgb3V0cHV0LlxuICogQHBhcmFtIGJpcDMyIC0gVGhlIEJJUDMySW50ZXJmYWNlIG9iamVjdCB0byBkZXJpdmUgZnJvbS5cbiAqIEBwYXJhbSBvdXRwdXQgLSBUaGUgc3BlY2lmaWMgUFNCVCBvdXRwdXQgdG8gZGVyaXZlIGZvci5cbiAqIEByZXR1cm5zIFRoZSBkZXJpdmVkIEJJUDMyIGtleSBwYWlyIGlmIG1hc3RlciBmaW5nZXJwcmludCBtYXRjaGVzLCBvciB1bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVLZXlQYWlyRm9yT3V0cHV0KGJpcDMyOiBCSVAzMkludGVyZmFjZSwgb3V0cHV0OiBQc2J0T3V0cHV0KTogQklQMzJJbnRlcmZhY2UgfCB1bmRlZmluZWQge1xuICByZXR1cm4gb3V0cHV0LnRhcEJpcDMyRGVyaXZhdGlvbj8ubGVuZ3RoXG4gICAgPyBVdHhvUHNidC5kZXJpdmVLZXlQYWlyKGJpcDMyLCBvdXRwdXQudGFwQmlwMzJEZXJpdmF0aW9uLCB7IGlnbm9yZVk6IHRydWUgfSlcbiAgICA6IG91dHB1dC5iaXAzMkRlcml2YXRpb24/Lmxlbmd0aFxuICAgID8gVXR4b1BzYnQuZGVyaXZlS2V5UGFpcihiaXAzMiwgb3V0cHV0LmJpcDMyRGVyaXZhdGlvbiwgeyBpZ25vcmVZOiBmYWxzZSB9KVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBzcGVjaWZpZWQgb3V0cHV0IGluIGEgUFNCVCBpcyBhbiBvdXRwdXQgb2YgdGhlIHdhbGxldCByZXByZXNlbnRlZCBieSB0aGUgZ2l2ZW4gcm9vdCBub2Rlcy5cbiAqIEBwYXJhbSBwc2J0IC0gVGhlIFBTQlQgdG8gY2hlY2suXG4gKiBAcGFyYW0gb3V0cHV0SW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIG91dHB1dCB0byBjaGVjay5cbiAqIEBwYXJhbSByb290V2FsbGV0Tm9kZXMgLSBUaGUgcm9vdCBub2RlcyByZXByZXNlbnRpbmcgdGhlIHdhbGxldC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBvdXRwdXQgYmVsb25ncyB0byB0aGUgd2FsbGV0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNXYWxsZXRPdXRwdXQocHNidDogVXR4b1BzYnQsIG91dHB1dEluZGV4OiBudW1iZXIsIHJvb3RXYWxsZXROb2RlczogVHJpcGxlPEJJUDMySW50ZXJmYWNlPik6IGJvb2xlYW4ge1xuICBjb25zdCBvdXRwdXQgPSBjaGVja0Zvck91dHB1dChwc2J0LmRhdGEub3V0cHV0cywgb3V0cHV0SW5kZXgpO1xuXG4gIGNvbnN0IHB1YktleXMgPSByb290V2FsbGV0Tm9kZXMubWFwKChyb290Tm9kZSkgPT4gZGVyaXZlS2V5UGFpckZvck91dHB1dChyb290Tm9kZSwgb3V0cHV0KT8ucHVibGljS2V5KTtcblxuICBpZiAoIWlzQnVmZmVyQXJyYXkocHViS2V5cykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBvdXRwdXRTY3JpcHQgPSBwc2J0LmdldE91dHB1dFNjcmlwdChvdXRwdXRJbmRleCk7XG4gIHJldHVybiBzY3JpcHRUeXBlczJPZjMuc29tZSgoc2NyaXB0VHlwZSkgPT5cbiAgICBjcmVhdGVPdXRwdXRTY3JpcHQyb2YzKHB1YktleXMsIHNjcmlwdFR5cGUpLnNjcmlwdFB1YktleS5lcXVhbHMob3V0cHV0U2NyaXB0KVxuICApO1xufVxuXG4vKipcbiAqIEZpbmRzIGluZGljZXMgb2YgYWxsIG91dHB1dHMgaW4gYSBQU0JUIHRoYXQgYmVsb25nIHRvIHRoZSB3YWxsZXQgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIHJvb3Qgbm9kZXMuXG4gKiBAcGFyYW0gcHNidCAtIFRoZSBQU0JUIHRvIHNlYXJjaCB0aHJvdWdoLlxuICogQHBhcmFtIHJvb3RXYWxsZXROb2RlcyAtIFRoZSByb290IG5vZGVzIHJlcHJlc2VudGluZyB0aGUgd2FsbGV0LlxuICogQHJldHVybnMgQW4gYXJyYXkgb2YgaW5kaWNlcyBjb3JyZXNwb25kaW5nIHRvIHdhbGxldCBvdXRwdXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZFdhbGxldE91dHB1dEluZGljZXMocHNidDogVXR4b1BzYnQsIHJvb3RXYWxsZXROb2RlczogVHJpcGxlPEJJUDMySW50ZXJmYWNlPik6IG51bWJlcltdIHtcbiAgcmV0dXJuIHBzYnQuZGF0YS5vdXRwdXRzLmZsYXRNYXAoKF8sIGkpID0+IChpc1dhbGxldE91dHB1dChwc2J0LCBpLCByb290V2FsbGV0Tm9kZXMpID8gW2ldIDogW10pKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB0b3RhbCBhbW91bnQgb2YgYWxsIHdhbGxldCBvdXRwdXRzIGluIGEgUFNCVCBmb3IgdGhlIHdhbGxldCByZXByZXNlbnRlZCBieSB0aGUgZ2l2ZW4gcm9vdCBub2Rlcy5cbiAqIEBwYXJhbSBwc2J0IC0gVGhlIFBTQlQgdG8gY2FsY3VsYXRlIGZvci5cbiAqIEBwYXJhbSByb290V2FsbGV0Tm9kZXMgLSBUaGUgcm9vdCBub2RlcyByZXByZXNlbnRpbmcgdGhlIHdhbGxldC5cbiAqIEByZXR1cm5zIFRoZSB0b3RhbCBhbW91bnQgb2Ygd2FsbGV0IG91dHB1dHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3RhbEFtb3VudE9mV2FsbGV0T3V0cHV0cyhwc2J0OiBVdHhvUHNidCwgcm9vdFdhbGxldE5vZGVzOiBUcmlwbGU8QklQMzJJbnRlcmZhY2U+KTogYmlnaW50IHtcbiAgY29uc3QgaW5kaWNlcyA9IGZpbmRXYWxsZXRPdXRwdXRJbmRpY2VzKHBzYnQsIHJvb3RXYWxsZXROb2Rlcyk7XG4gIGNvbnN0IHR4T3V0cHV0cyA9IHBzYnQudHhPdXRwdXRzO1xuICByZXR1cm4gaW5kaWNlcy5yZWR1Y2UoKHN1bSwgaSkgPT4gc3VtICsgdHhPdXRwdXRzW2ldLnZhbHVlLCBCaWdJbnQoMCkpO1xufVxuXG4vKipcbiAqIEZpbmRzIGluZGljZXMgb2YgYWxsIGludGVybmFsIG91dHB1dHMgaW4gYSBQU0JULCBpZGVudGlmaWVkIGFzIG91dHB1dHMgYmVsb25naW5nIHRvIHRoZSB3YWxsZXQncyByb290IG5vZGVzIHdpdGhpbiB0aGUgUFNCVC5cbiAqIEBwYXJhbSBwc2J0IC0gVGhlIFBTQlQgY29udGFpbmluZyB0aGUgd2FsbGV0J3Mgcm9vdCBub2RlcyBhcyBpbmRpY2F0ZWQgYnkgZ2xvYmFsIFhwdWJzLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2YgaW5kaWNlcyBvZiBpbnRlcm5hbCBvdXRwdXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEludGVybmFsT3V0cHV0SW5kaWNlcyhwc2J0OiBVdHhvUHNidCk6IG51bWJlcltdIHtcbiAgY29uc3Qgcm9vdE5vZGVzID0gZ2V0U29ydGVkUm9vdE5vZGVzKHBzYnQpO1xuICByZXR1cm4gZmluZFdhbGxldE91dHB1dEluZGljZXMocHNidCwgcm9vdE5vZGVzKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB0b3RhbCBhbW91bnQgb2YgYWxsIGludGVybmFsIG91dHB1dHMgaW4gYSBQU0JULCBpZGVudGlmaWVkIGFzIG91dHB1dHMgYmVsb25naW5nIHRvIHRoZSB3YWxsZXQncyByb290IG5vZGVzIHdpdGhpbiB0aGUgUFNCVC5cbiAqIEBwYXJhbSBwc2J0IC0gVGhlIFBTQlQgY29udGFpbmluZyB0aGUgd2FsbGV0J3Mgcm9vdCBub2RlcyBhcyBpbmRpY2F0ZWQgYnkgZ2xvYmFsIFhwdWJzLlxuICogQHJldHVybnMgVGhlIHRvdGFsIGFtb3VudCBvZiBpbnRlcm5hbCBvdXRwdXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG90YWxBbW91bnRPZkludGVybmFsT3V0cHV0cyhwc2J0OiBVdHhvUHNidCk6IGJpZ2ludCB7XG4gIGNvbnN0IHJvb3ROb2RlcyA9IGdldFNvcnRlZFJvb3ROb2Rlcyhwc2J0KTtcbiAgcmV0dXJuIGdldFRvdGFsQW1vdW50T2ZXYWxsZXRPdXRwdXRzKHBzYnQsIHJvb3ROb2Rlcyk7XG59XG4iXX0=