"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signInput2Of3 = exports.signInputP2shP2pk = exports.getDefaultSigHash = exports.verifySignatureWithPublicKey = exports.verifySignatureWithPublicKeys = exports.getSignaturesWithPublicKeys = exports.verifySignature = exports.getSignatureVerifications = void 0;
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const UtxoTransaction_1 = require("./UtxoTransaction");
const outputScripts_1 = require("./outputScripts");
const networks_1 = require("../networks");
const noble_ecc_1 = require("../noble_ecc");
const parseInput_1 = require("./parseInput");
const taproot_1 = require("../taproot");
/**
 * @deprecated - use {@see verifySignaturesWithPublicKeys} instead
 * Get signature verifications for multsig transaction
 * @param transaction
 * @param inputIndex
 * @param amount - must be set for segwit transactions and BIP143 transactions
 * @param verificationSettings
 * @param prevOutputs - must be set for p2tr and p2trMusig2 transactions
 * @returns SignatureVerification[] - in order of parsed non-empty signatures
 */
function getSignatureVerifications(transaction, inputIndex, amount, verificationSettings = {}, prevOutputs) {
    /* istanbul ignore next */
    if (!transaction.ins) {
        throw new Error(`invalid transaction`);
    }
    const input = transaction.ins[inputIndex];
    /* istanbul ignore next */
    if (!input) {
        throw new Error(`no input at index ${inputIndex}`);
    }
    if ((!input.script || input.script.length === 0) && input.witness.length === 0) {
        // Unsigned input: no signatures.
        return [];
    }
    const parsedScript = (0, parseInput_1.parseSignatureScript2Of3)(input);
    if (parsedScript.scriptType === 'taprootKeyPathSpend' || parsedScript.scriptType === 'taprootScriptPathSpend') {
        if (parsedScript.scriptType === 'taprootKeyPathSpend' &&
            (verificationSettings.signatureIndex || verificationSettings.publicKey)) {
            throw new Error(`signatureIndex and publicKey parameters not supported for taprootKeyPathSpend`);
        }
        if (verificationSettings.signatureIndex !== undefined) {
            throw new Error(`signatureIndex parameter not supported for taprootScriptPathSpend`);
        }
        if (!prevOutputs) {
            throw new Error(`prevOutputs not set`);
        }
        if (prevOutputs.length !== transaction.ins.length) {
            throw new Error(`prevOutputs length ${prevOutputs.length}, expected ${transaction.ins.length}`);
        }
    }
    if (parsedScript.scriptType !== 'taprootKeyPathSpend' &&
        parsedScript.scriptType !== 'taprootScriptPathSpend' &&
        prevOutputs) {
        const prevOutScript = prevOutputs[inputIndex].script;
        const output = (0, outputScripts_1.getOutputScript)(parsedScript.scriptType, parsedScript.pubScript);
        if (!prevOutScript.equals(output)) {
            throw new Error(`prevout script ${prevOutScript.toString('hex')} does not match computed script ${output.toString('hex')}`);
        }
    }
    let publicKeys;
    if (parsedScript.scriptType === 'taprootKeyPathSpend') {
        if (!prevOutputs) {
            throw new Error(`prevOutputs not set`);
        }
        publicKeys = [(0, taproot_1.getTaprootOutputKey)(prevOutputs[inputIndex].script)];
    }
    else {
        publicKeys = parsedScript.publicKeys.filter((buf) => verificationSettings.publicKey === undefined ||
            verificationSettings.publicKey.equals(buf) ||
            verificationSettings.publicKey.slice(1).equals(buf));
    }
    const signatures = parsedScript.signatures
        .filter((s) => s && s.length)
        .filter((s, i) => verificationSettings.signatureIndex === undefined || verificationSettings.signatureIndex === i);
    return signatures.map((signatureBuffer) => {
        if (signatureBuffer === 0 || signatureBuffer.length === 0) {
            return { signedBy: undefined, signature: undefined };
        }
        let hashType = bitcoinjs_lib_1.Transaction.SIGHASH_DEFAULT;
        if (signatureBuffer.length === 65) {
            hashType = signatureBuffer[signatureBuffer.length - 1];
            signatureBuffer = signatureBuffer.slice(0, -1);
        }
        if (parsedScript.scriptType === 'taprootScriptPathSpend') {
            if (!prevOutputs) {
                throw new Error(`prevOutputs not set`);
            }
            const { controlBlock, pubScript } = parsedScript;
            const leafHash = bitcoinjs_lib_1.taproot.getTapleafHash(noble_ecc_1.ecc, controlBlock, pubScript);
            const signatureHash = transaction.hashForWitnessV1(inputIndex, prevOutputs.map(({ script }) => script), prevOutputs.map(({ value }) => value), hashType, leafHash);
            const signedBy = publicKeys.filter((k) => Buffer.isBuffer(signatureBuffer) && noble_ecc_1.ecc.verifySchnorr(signatureHash, k, signatureBuffer));
            if (signedBy.length === 0) {
                return { signedBy: undefined, signature: undefined };
            }
            if (signedBy.length === 1) {
                return { signedBy: signedBy[0], signature: signatureBuffer };
            }
            throw new Error(`illegal state: signed by multiple public keys`);
        }
        else if (parsedScript.scriptType === 'taprootKeyPathSpend') {
            if (!prevOutputs) {
                throw new Error(`prevOutputs not set`);
            }
            const signatureHash = transaction.hashForWitnessV1(inputIndex, prevOutputs.map(({ script }) => script), prevOutputs.map(({ value }) => value), hashType);
            const result = noble_ecc_1.ecc.verifySchnorr(signatureHash, publicKeys[0], signatureBuffer);
            return result
                ? { signedBy: publicKeys[0], signature: signatureBuffer }
                : { signedBy: undefined, signature: undefined };
        }
        else {
            // slice the last byte from the signature hash input because it's the hash type
            const { signature, hashType } = bitcoinjs_lib_1.ScriptSignature.decode(signatureBuffer);
            const transactionHash = parsedScript.scriptType === 'p2shP2wsh' || parsedScript.scriptType === 'p2wsh'
                ? transaction.hashForWitnessV0(inputIndex, parsedScript.pubScript, amount, hashType)
                : transaction.hashForSignatureByNetwork(inputIndex, parsedScript.pubScript, amount, hashType);
            const signedBy = publicKeys.filter((publicKey) => noble_ecc_1.ecc.verify(transactionHash, publicKey, signature, 
            /*
              Strict verification (require lower-S value), as required by BIP-0146
              https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki
              https://github.com/bitcoin-core/secp256k1/blob/ac83be33/include/secp256k1.h#L478-L508
              https://github.com/bitcoinjs/tiny-secp256k1/blob/v1.1.6/js.js#L231-L233
            */
            true));
            if (signedBy.length === 0) {
                return { signedBy: undefined, signature: undefined };
            }
            if (signedBy.length === 1) {
                return { signedBy: signedBy[0], signature: signatureBuffer };
            }
            throw new Error(`illegal state: signed by multiple public keys`);
        }
    });
}
exports.getSignatureVerifications = getSignatureVerifications;
/**
 * @deprecated use {@see verifySignatureWithPublicKeys} instead
 * @param transaction
 * @param inputIndex
 * @param amount
 * @param verificationSettings - if publicKey is specified, returns true iff any signature is signed by publicKey.
 * @param prevOutputs - must be set for p2tr transactions
 */
function verifySignature(transaction, inputIndex, amount, verificationSettings = {}, prevOutputs) {
    const signatureVerifications = getSignatureVerifications(transaction, inputIndex, amount, verificationSettings, prevOutputs).filter((v) => 
    // If no publicKey is set in verificationSettings, all signatures must be valid.
    // Otherwise, a single valid signature by the specified pubkey is sufficient.
    verificationSettings.publicKey === undefined ||
        (v.signedBy !== undefined &&
            (verificationSettings.publicKey.equals(v.signedBy) ||
                verificationSettings.publicKey.slice(1).equals(v.signedBy))));
    return signatureVerifications.length > 0 && signatureVerifications.every((v) => v.signedBy !== undefined);
}
exports.verifySignature = verifySignature;
/**
 * @param v
 * @param publicKey
 * @return true iff signature is by publicKey (or xonly variant of publicKey)
 */
function isSignatureByPublicKey(v, publicKey) {
    return (!!v.signedBy &&
        (v.signedBy.equals(publicKey) ||
            /* for p2tr signatures, we pass the pubkey in 33-byte format recover it from the signature in 32-byte format */
            (publicKey.length === 33 && isSignatureByPublicKey(v, publicKey.slice(1)))));
}
/**
 * @param transaction
 * @param inputIndex
 * @param prevOutputs
 * @param publicKeys
 * @return array with signature corresponding to n-th key, undefined if no match found
 */
function getSignaturesWithPublicKeys(transaction, inputIndex, prevOutputs, publicKeys) {
    if (transaction.ins.length !== prevOutputs.length) {
        throw new Error(`input length must match prevOutputs length`);
    }
    const signatureVerifications = getSignatureVerifications(transaction, inputIndex, prevOutputs[inputIndex].value, {}, prevOutputs);
    return publicKeys.map((publicKey) => {
        const v = signatureVerifications.find((v) => isSignatureByPublicKey(v, publicKey));
        return v ? v.signature : undefined;
    });
}
exports.getSignaturesWithPublicKeys = getSignaturesWithPublicKeys;
/**
 * @param transaction
 * @param inputIndex
 * @param prevOutputs - transaction outputs for inputs
 * @param publicKeys - public keys to check signatures for
 * @return array of booleans indicating a valid signature for every pubkey in _publicKeys_
 */
function verifySignatureWithPublicKeys(transaction, inputIndex, prevOutputs, publicKeys) {
    return getSignaturesWithPublicKeys(transaction, inputIndex, prevOutputs, publicKeys).map((s) => s !== undefined);
}
exports.verifySignatureWithPublicKeys = verifySignatureWithPublicKeys;
/**
 * Wrapper for {@see verifySignatureWithPublicKeys} for single pubkey
 * @param transaction
 * @param inputIndex
 * @param prevOutputs
 * @param publicKey
 * @return true iff signature is valid
 */
function verifySignatureWithPublicKey(transaction, inputIndex, prevOutputs, publicKey) {
    return verifySignatureWithPublicKeys(transaction, inputIndex, prevOutputs, [publicKey])[0];
}
exports.verifySignatureWithPublicKey = verifySignatureWithPublicKey;
function getDefaultSigHash(network, scriptType) {
    switch ((0, networks_1.getMainnet)(network)) {
        case networks_1.networks.bitcoincash:
        case networks_1.networks.bitcoinsv:
        case networks_1.networks.bitcoingold:
        case networks_1.networks.ecash:
            return bitcoinjs_lib_1.Transaction.SIGHASH_ALL | UtxoTransaction_1.UtxoTransaction.SIGHASH_FORKID;
        default:
            switch (scriptType) {
                case 'p2tr':
                case 'p2trMusig2':
                    return bitcoinjs_lib_1.Transaction.SIGHASH_DEFAULT;
                default:
                    return bitcoinjs_lib_1.Transaction.SIGHASH_ALL;
            }
    }
}
exports.getDefaultSigHash = getDefaultSigHash;
function signInputP2shP2pk(txBuilder, vin, keyPair) {
    const prevOutScriptType = 'p2sh-p2pk';
    const { redeemScript, witnessScript } = (0, outputScripts_1.createOutputScriptP2shP2pk)(keyPair.publicKey);
    keyPair.network = txBuilder.network;
    txBuilder.sign({
        vin,
        prevOutScriptType,
        keyPair,
        hashType: getDefaultSigHash(txBuilder.network),
        redeemScript,
        witnessScript,
        witnessValue: undefined,
    });
}
exports.signInputP2shP2pk = signInputP2shP2pk;
function signInput2Of3(txBuilder, vin, scriptType, pubkeys, keyPair, cosigner, amount) {
    let controlBlock;
    let redeemScript;
    let witnessScript;
    const prevOutScriptType = (0, outputScripts_1.scriptType2Of3AsPrevOutType)(scriptType);
    if (scriptType === 'p2tr') {
        ({ witnessScript, controlBlock } = (0, outputScripts_1.createSpendScriptP2tr)(pubkeys, [keyPair.publicKey, cosigner]));
    }
    else {
        ({ redeemScript, witnessScript } = (0, outputScripts_1.createOutputScript2of3)(pubkeys, scriptType));
    }
    keyPair.network = txBuilder.network;
    txBuilder.sign({
        vin,
        prevOutScriptType,
        keyPair,
        hashType: getDefaultSigHash(txBuilder.network, scriptType),
        redeemScript,
        witnessScript,
        witnessValue: amount,
        controlBlock,
    });
}
exports.signInput2Of3 = signInput2Of3;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmF0dXJlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2JpdGdvL3NpZ25hdHVyZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFFQSxpREFBZ0Y7QUFFaEYsdURBQW9EO0FBRXBELG1EQVF5QjtBQUV6QiwwQ0FBNEQ7QUFDNUQsNENBQTZDO0FBQzdDLDZDQUF3RDtBQUN4RCx3Q0FBaUQ7QUE4QmpEOzs7Ozs7Ozs7R0FTRztBQUNILFNBQWdCLHlCQUF5QixDQUN2QyxXQUFxQyxFQUNyQyxVQUFrQixFQUNsQixNQUFlLEVBQ2YsdUJBQTZDLEVBQUUsRUFDL0MsV0FBaUM7SUFFakMsMEJBQTBCO0lBQzFCLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFO1FBQ3BCLE1BQU0sSUFBSSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztLQUN4QztJQUVELE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDMUMsMEJBQTBCO0lBQzFCLElBQUksQ0FBQyxLQUFLLEVBQUU7UUFDVixNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixVQUFVLEVBQUUsQ0FBQyxDQUFDO0tBQ3BEO0lBRUQsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDOUUsaUNBQWlDO1FBQ2pDLE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFFRCxNQUFNLFlBQVksR0FBRyxJQUFBLHFDQUF3QixFQUFDLEtBQUssQ0FBQyxDQUFDO0lBRXJELElBQUksWUFBWSxDQUFDLFVBQVUsS0FBSyxxQkFBcUIsSUFBSSxZQUFZLENBQUMsVUFBVSxLQUFLLHdCQUF3QixFQUFFO1FBQzdHLElBQ0UsWUFBWSxDQUFDLFVBQVUsS0FBSyxxQkFBcUI7WUFDakQs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QUFDO0lBQ2xFLElBQUksVUFBVSxLQUFLLE1BQU0sRUFBRTtRQUN6QixDQUFDLEVBQUUsYUFBYSxFQUFFLFlBQVksRUFBRSxHQUFHLElBQUEscUNBQXFCLEVBQUMsT0FBTyxFQUFFLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDbkc7U0FBTTtRQUNMLENBQUMsRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFLEdBQUcsSUFBQSxzQ0FBc0IsRUFBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQztLQUNqRjtJQUVELE9BQU8sQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQztJQUVwQyxTQUFTLENBQUMsSUFBSSxDQUFDO1FBQ2IsR0FBRztRQUNILGlCQUFpQjtRQUNqQixPQUFPO1FBQ1AsUUFBUSxFQUFFLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxPQUFrQixFQUFFLFVBQVUsQ0FBQztRQUNyRSxZQUFZO1FBQ1osYUFBYTtRQUNiLFlBQVksRUFBRSxNQUFNO1FBQ3BCLFlBQVk7S0FDYixDQUFDLENBQUM7QUFDTCxDQUFDO0FBaENELHNDQWdDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJJUDMySW50ZXJmYWNlIH0gZnJvbSAnYmlwMzInO1xuXG5pbXBvcnQgeyBUcmFuc2FjdGlvbiwgdGFwcm9vdCwgVHhPdXRwdXQsIFNjcmlwdFNpZ25hdHVyZSB9IGZyb20gJ2JpdGNvaW5qcy1saWInO1xuXG5pbXBvcnQgeyBVdHhvVHJhbnNhY3Rpb24gfSBmcm9tICcuL1V0eG9UcmFuc2FjdGlvbic7XG5pbXBvcnQgeyBVdHhvVHJhbnNhY3Rpb25CdWlsZGVyIH0gZnJvbSAnLi9VdHhvVHJhbnNhY3Rpb25CdWlsZGVyJztcbmltcG9ydCB7XG4gIGNyZWF0ZU91dHB1dFNjcmlwdDJvZjMsXG4gIGNyZWF0ZU91dHB1dFNjcmlwdFAyc2hQMnBrLFxuICBjcmVhdGVTcGVuZFNjcmlwdFAydHIsXG4gIGdldE91dHB1dFNjcmlwdCxcbiAgU2NyaXB0VHlwZSxcbiAgU2NyaXB0VHlwZTJPZjMsXG4gIHNjcmlwdFR5cGUyT2YzQXNQcmV2T3V0VHlwZSxcbn0gZnJvbSAnLi9vdXRwdXRTY3JpcHRzJztcbmltcG9ydCB7IFRyaXBsZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0TWFpbm5ldCwgTmV0d29yaywgbmV0d29ya3MgfSBmcm9tICcuLi9uZXR3b3Jrcyc7XG5pbXBvcnQgeyBlY2MgYXMgZWNjTGliIH0gZnJvbSAnLi4vbm9ibGVfZWNjJztcbmltcG9ydCB7IHBhcnNlU2lnbmF0dXJlU2NyaXB0Mk9mMyB9IGZyb20gJy4vcGFyc2VJbnB1dCc7XG5pbXBvcnQgeyBnZXRUYXByb290T3V0cHV0S2V5IH0gZnJvbSAnLi4vdGFwcm9vdCc7XG5cbi8qKlxuICogQ29uc3RyYWludHMgZm9yIHNpZ25hdHVyZSB2ZXJpZmljYXRpb25zLlxuICogUGFyYW1ldGVycyBhcmUgY29uanVuY3RpdmU6IGlmIG11bHRpcGxlIHBhcmFtZXRlcnMgYXJlIHNldCwgYSB2ZXJpZmljYXRpb24gZm9yIGFuIGluZGl2aWR1YWxcbiAqIHNpZ25hdHVyZSBtdXN0IHNhdGlzZnkgYWxsIG9mIHRoZW0uXG4gKi9cbmV4cG9ydCB0eXBlIFZlcmlmaWNhdGlvblNldHRpbmdzID0ge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBzaWduYXR1cmUgdG8gdmVyaWZ5LiBPbmx5IGl0ZXJhdGVzIG92ZXIgbm9uLWVtcHR5IHNpZ25hdHVyZXMuXG4gICAqL1xuICBzaWduYXR1cmVJbmRleD86IG51bWJlcjtcbiAgLyoqXG4gICAqIFRoZSBwdWJsaWMga2V5IHRvIHZlcmlmeS5cbiAgICovXG4gIHB1YmxpY0tleT86IEJ1ZmZlcjtcbn07XG5cbi8qKlxuICogUmVzdWx0IGZvciBhIGluZGl2aWR1YWwgc2lnbmF0dXJlIHZlcmlmaWNhdGlvblxuICovXG5leHBvcnQgdHlwZSBTaWduYXR1cmVWZXJpZmljYXRpb24gPVxuICB8IHtcbiAgICAgIC8qKiBTZXQgdG8gdGhlIHB1YmxpYyBrZXkgdGhhdCBzaWduZWQgZm9yIHRoZSBzaWduYXR1cmUgKi9cbiAgICAgIHNpZ25lZEJ5OiBCdWZmZXI7XG4gICAgICAvKiogU2V0IHRvIHRoZSBzaWduYXR1cmUgYnVmZmVyICovXG4gICAgICBzaWduYXR1cmU6IEJ1ZmZlcjtcbiAgICB9XG4gIHwgeyBzaWduZWRCeTogdW5kZWZpbmVkOyBzaWduYXR1cmU6IHVuZGVmaW5lZCB9O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIC0gdXNlIHtAc2VlIHZlcmlmeVNpZ25hdHVyZXNXaXRoUHVibGljS2V5c30gaW5zdGVhZFxuICogR2V0IHNpZ25hdHVyZSB2ZXJpZmljYXRpb25zIGZvciBtdWx0c2lnIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBpbnB1dEluZGV4XG4gKiBAcGFyYW0gYW1vdW50IC0gbXVzdCBiZSBzZXQgZm9yIHNlZ3dpdCB0cmFuc2FjdGlvbnMgYW5kIEJJUDE0MyB0cmFuc2FjdGlvbnNcbiAqIEBwYXJhbSB2ZXJpZmljYXRpb25TZXR0aW5nc1xuICogQHBhcmFtIHByZXZPdXRwdXRzIC0gbXVzdCBiZSBzZXQgZm9yIHAydHIgYW5kIHAydHJNdXNpZzIgdHJhbnNhY3Rpb25zXG4gKiBAcmV0dXJucyBTaWduYXR1cmVWZXJpZmljYXRpb25bXSAtIGluIG9yZGVyIG9mIHBhcnNlZCBub24tZW1wdHkgc2lnbmF0dXJlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnbmF0dXJlVmVyaWZpY2F0aW9uczxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50PihcbiAgdHJhbnNhY3Rpb246IFV0eG9UcmFuc2FjdGlvbjxUTnVtYmVyPixcbiAgaW5wdXRJbmRleDogbnVtYmVyLFxuICBhbW91bnQ6IFROdW1iZXIsXG4gIHZlcmlmaWNhdGlvblNldHRpbmdzOiBWZXJpZmljYXRpb25TZXR0aW5ncyA9IHt9LFxuICBwcmV2T3V0cHV0cz86IFR4T3V0cHV0PFROdW1iZXI+W11cbik6IFNpZ25hdHVyZVZlcmlmaWNhdGlvbltdIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCF0cmFuc2FjdGlvbi5pbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdHJhbnNhY3Rpb25gKTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0ID0gdHJhbnNhY3Rpb24uaW5zW2lucHV0SW5kZXhdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoIWlucHV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBubyBpbnB1dCBhdCBpbmRleCAke2lucHV0SW5kZXh9YCk7XG4gIH1cblxuICBpZiAoKCFpbnB1dC5zY3JpcHQgfHwgaW5wdXQuc2NyaXB0Lmxlbmd0aCA9PT0gMCkgJiYgaW5wdXQud2l0bmVzcy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBVbnNpZ25lZCBpbnB1dDogbm8gc2lnbmF0dXJlcy5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBwYXJzZWRTY3JpcHQgPSBwYXJzZVNpZ25hdHVyZVNjcmlwdDJPZjMoaW5wdXQpO1xuXG4gIGlmIChwYXJzZWRTY3JpcHQuc2NyaXB0VHlwZSA9PT0gJ3RhcHJvb3RLZXlQYXRoU3BlbmQnIHx8IHBhcnNlZFNjcmlwdC5zY3JpcHRUeXBlID09PSAndGFwcm9vdFNjcmlwdFBhdGhTcGVuZCcpIHtcbiAgICBpZiAoXG4gICAgICBwYXJzZWRTY3JpcHQuc2NyaXB0VHlwZSA9PT0gJ3RhcHJvb3RLZXlQYXRoU3BlbmQnICYmXG4gICAgICAodmVyaWZpY2F0aW9uU2V0dGluZ3Muc2lnbmF0dXJlSW5kZXggfHwgdmVyaWZpY2F0aW9uU2V0dGluZ3MucHVibGljS2V5KVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduYXR1cmVJbmRleCBhbmQgcHVibGljS2V5IHBhcmFtZXRlcnMgbm90IHN1cHBvcnRlZCBmb3IgdGFwcm9vdEtleVBhdGhTcGVuZGApO1xuICAgIH1cblxuICAgIGlmICh2ZXJpZmljYXRpb25TZXR0aW5ncy5zaWduYXR1cmVJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHNpZ25hdHVyZUluZGV4IHBhcmFtZXRlciBub3Qgc3VwcG9ydGVkIGZvciB0YXByb290U2NyaXB0UGF0aFNwZW5kYCk7XG4gICAgfVxuXG4gICAgaWYgKCFwcmV2T3V0cHV0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcmV2T3V0cHV0cyBub3Qgc2V0YCk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZPdXRwdXRzLmxlbmd0aCAhPT0gdHJhbnNhY3Rpb24uaW5zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcmV2T3V0cHV0cyBsZW5ndGggJHtwcmV2T3V0cHV0cy5sZW5ndGh9LCBleHBlY3RlZCAke3RyYW5zYWN0aW9uLmlucy5sZW5ndGh9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKFxuICAgIHBhcnNlZFNjcmlwdC5zY3JpcHRUeXBlICE9PSAndGFwcm9vdEtleVBhdGhTcGVuZCcgJiZcbiAgICBwYXJzZWRTY3JpcHQuc2NyaXB0VHlwZSAhPT0gJ3RhcHJvb3RTY3JpcHRQYXRoU3BlbmQnICYmXG4gICAgcHJldk91dHB1dHNcbiAgKSB7XG4gICAgY29uc3QgcHJldk91dFNjcmlwdCA9IHByZXZPdXRwdXRzW2lucHV0SW5kZXhdLnNjcmlwdDtcblxuICAgIGNvbnN0IG91dHB1dCA9IGdldE91dHB1dFNjcmlwdChwYXJzZWRTY3JpcHQuc2NyaXB0VHlwZSwgcGFyc2VkU2NyaXB0LnB1YlNjcmlwdCk7XG4gICAgaWYgKCFwcmV2T3V0U2NyaXB0LmVxdWFscyhvdXRwdXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBwcmV2b3V0IHNjcmlwdCAke3ByZXZPdXRTY3JpcHQudG9TdHJpbmcoJ2hleCcpfSBkb2VzIG5vdCBtYXRjaCBjb21wdXRlZCBzY3JpcHQgJHtvdXRwdXQudG9TdHJpbmcoJ2hleCcpfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHB1YmxpY0tleXM6IEJ1ZmZlcltdO1xuICBpZiAocGFyc2VkU2NyaXB0LnNjcmlwdFR5cGUgPT09ICd0YXByb290S2V5UGF0aFNwZW5kJykge1xuICAgIGlmICghcHJldk91dHB1dHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcHJldk91dHB1dHMgbm90IHNldGApO1xuICAgIH1cbiAgICBwdWJsaWNLZXlzID0gW2dldFRhcHJvb3RPdXRwdXRLZXkocHJldk91dHB1dHNbaW5wdXRJbmRleF0uc2NyaXB0KV07XG4gIH0gZWxzZSB7XG4gICAgcHVibGljS2V5cyA9IHBhcnNlZFNjcmlwdC5wdWJsaWNLZXlzLmZpbHRlcihcbiAgICAgIChidWYpID0+XG4gICAgICAgIHZlcmlmaWNhdGlvblNldHRpbmdzLnB1YmxpY0tleSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIHZlcmlmaWNhdGlvblNldHRpbmdzLnB1YmxpY0tleS5lcXVhbHMoYnVmKSB8fFxuICAgICAgICB2ZXJpZmljYXRpb25TZXR0aW5ncy5wdWJsaWNLZXkuc2xpY2UoMSkuZXF1YWxzKGJ1ZilcbiAgICApO1xuICB9XG5cbiAgY29uc3Qgc2lnbmF0dXJlcyA9IHBhcnNlZFNjcmlwdC5zaWduYXR1cmVzXG4gICAgLmZpbHRlcigocykgPT4gcyAmJiBzLmxlbmd0aClcbiAgICAuZmlsdGVyKChzLCBpKSA9PiB2ZXJpZmljYXRpb25TZXR0aW5ncy5zaWduYXR1cmVJbmRleCA9PT0gdW5kZWZpbmVkIHx8IHZlcmlmaWNhdGlvblNldHRpbmdzLnNpZ25hdHVyZUluZGV4ID09PSBpKTtcblxuICByZXR1cm4gc2lnbmF0dXJlcy5tYXAoKHNpZ25hdHVyZUJ1ZmZlcik6IFNpZ25hdHVyZVZlcmlmaWNhdGlvbiA9PiB7XG4gICAgaWYgKHNpZ25hdHVyZUJ1ZmZlciA9PT0gMCB8fCBzaWduYXR1cmVCdWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4geyBzaWduZWRCeTogdW5kZWZpbmVkLCBzaWduYXR1cmU6IHVuZGVmaW5lZCB9O1xuICAgIH1cblxuICAgIGxldCBoYXNoVHlwZSA9IFRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVDtcblxuICAgIGlmIChzaWduYXR1cmVCdWZmZXIubGVuZ3RoID09PSA2NSkge1xuICAgICAgaGFzaFR5cGUgPSBzaWduYXR1cmVCdWZmZXJbc2lnbmF0dXJlQnVmZmVyLmxlbmd0aCAtIDFdO1xuICAgICAgc2lnbmF0dXJlQnVmZmVyID0gc2lnbmF0dXJlQnVmZmVyLnNsaWNlKDAsIC0xKTtcbiAgICB9XG5cbiAgICBpZiAocGFyc2VkU2NyaXB0LnNjcmlwdFR5cGUgPT09ICd0YXByb290U2NyaXB0UGF0aFNwZW5kJykge1xuICAgICAgaWYgKCFwcmV2T3V0cHV0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByZXZPdXRwdXRzIG5vdCBzZXRgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY29udHJvbEJsb2NrLCBwdWJTY3JpcHQgfSA9IHBhcnNlZFNjcmlwdDtcbiAgICAgIGNvbnN0IGxlYWZIYXNoID0gdGFwcm9vdC5nZXRUYXBsZWFmSGFzaChlY2NMaWIsIGNvbnRyb2xCbG9jaywgcHViU2NyaXB0KTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZUhhc2ggPSB0cmFuc2FjdGlvbi5oYXNoRm9yV2l0bmVzc1YxKFxuICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICBwcmV2T3V0cHV0cy5tYXAoKHsgc2NyaXB0IH0pID0+IHNjcmlwdCksXG4gICAgICAgIHByZXZPdXRwdXRzLm1hcCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSksXG4gICAgICAgIGhhc2hUeXBlLFxuICAgICAgICBsZWFmSGFzaFxuICAgICAgKTtcblxuICAgICAgY29uc3Qgc2lnbmVkQnkgPSBwdWJsaWNLZXlzLmZpbHRlcihcbiAgICAgICAgKGspID0+IEJ1ZmZlci5pc0J1ZmZlcihzaWduYXR1cmVCdWZmZXIpICYmIGVjY0xpYi52ZXJpZnlTY2hub3JyKHNpZ25hdHVyZUhhc2gsIGssIHNpZ25hdHVyZUJ1ZmZlcilcbiAgICAgICk7XG5cbiAgICAgIGlmIChzaWduZWRCeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgc2lnbmVkQnk6IHVuZGVmaW5lZCwgc2lnbmF0dXJlOiB1bmRlZmluZWQgfTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduZWRCeS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHsgc2lnbmVkQnk6IHNpZ25lZEJ5WzBdLCBzaWduYXR1cmU6IHNpZ25hdHVyZUJ1ZmZlciB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbGxlZ2FsIHN0YXRlOiBzaWduZWQgYnkgbXVsdGlwbGUgcHVibGljIGtleXNgKTtcbiAgICB9IGVsc2UgaWYgKHBhcnNlZFNjcmlwdC5zY3JpcHRUeXBlID09PSAndGFwcm9vdEtleVBhdGhTcGVuZCcpIHtcbiAgICAgIGlmICghcHJldk91dHB1dHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcmV2T3V0cHV0cyBub3Qgc2V0YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzaWduYXR1cmVIYXNoID0gdHJhbnNhY3Rpb24uaGFzaEZvcldpdG5lc3NWMShcbiAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICAgcHJldk91dHB1dHMubWFwKCh7IHNjcmlwdCB9KSA9PiBzY3JpcHQpLFxuICAgICAgICBwcmV2T3V0cHV0cy5tYXAoKHsgdmFsdWUgfSkgPT4gdmFsdWUpLFxuICAgICAgICBoYXNoVHlwZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGVjY0xpYi52ZXJpZnlTY2hub3JyKHNpZ25hdHVyZUhhc2gsIHB1YmxpY0tleXNbMF0sIHNpZ25hdHVyZUJ1ZmZlcik7XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgID8geyBzaWduZWRCeTogcHVibGljS2V5c1swXSwgc2lnbmF0dXJlOiBzaWduYXR1cmVCdWZmZXIgfVxuICAgICAgICA6IHsgc2lnbmVkQnk6IHVuZGVmaW5lZCwgc2lnbmF0dXJlOiB1bmRlZmluZWQgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2xpY2UgdGhlIGxhc3QgYnl0ZSBmcm9tIHRoZSBzaWduYXR1cmUgaGFzaCBpbnB1dCBiZWNhdXNlIGl0J3MgdGhlIGhhc2ggdHlwZVxuICAgICAgY29uc3QgeyBzaWduYXR1cmUsIGhhc2hUeXBlIH0gPSBTY3JpcHRTaWduYXR1cmUuZGVjb2RlKHNpZ25hdHVyZUJ1ZmZlcik7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkhhc2ggPVxuICAgICAgICBwYXJzZWRTY3JpcHQuc2NyaXB0VHlwZSA9PT0gJ3Ayc2hQMndzaCcgfHwgcGFyc2VkU2NyaXB0LnNjcmlwdFR5cGUgPT09ICdwMndzaCdcbiAgICAgICAgICA/IHRyYW5zYWN0aW9uLmhhc2hGb3JXaXRuZXNzVjAoaW5wdXRJbmRleCwgcGFyc2VkU2NyaXB0LnB1YlNjcmlwdCwgYW1vdW50LCBoYXNoVHlwZSlcbiAgICAgICAgICA6IHRyYW5zYWN0aW9uLmhhc2hGb3JTaWduYXR1cmVCeU5ldHdvcmsoaW5wdXRJbmRleCwgcGFyc2VkU2NyaXB0LnB1YlNjcmlwdCwgYW1vdW50LCBoYXNoVHlwZSk7XG4gICAgICBjb25zdCBzaWduZWRCeSA9IHB1YmxpY0tleXMuZmlsdGVyKChwdWJsaWNLZXkpID0+XG4gICAgICAgIGVjY0xpYi52ZXJpZnkoXG4gICAgICAgICAgdHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgLypcbiAgICAgICAgICAgIFN0cmljdCB2ZXJpZmljYXRpb24gKHJlcXVpcmUgbG93ZXItUyB2YWx1ZSksIGFzIHJlcXVpcmVkIGJ5IEJJUC0wMTQ2XG4gICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMTQ2Lm1lZGlhd2lraVxuICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4tY29yZS9zZWNwMjU2azEvYmxvYi9hYzgzYmUzMy9pbmNsdWRlL3NlY3AyNTZrMS5oI0w0NzgtTDUwOFxuICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy90aW55LXNlY3AyNTZrMS9ibG9iL3YxLjEuNi9qcy5qcyNMMjMxLUwyMzNcbiAgICAgICAgICAqL1xuICAgICAgICAgIHRydWVcbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgICAgaWYgKHNpZ25lZEJ5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyBzaWduZWRCeTogdW5kZWZpbmVkLCBzaWduYXR1cmU6IHVuZGVmaW5lZCB9O1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25lZEJ5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4geyBzaWduZWRCeTogc2lnbmVkQnlbMF0sIHNpZ25hdHVyZTogc2lnbmF0dXJlQnVmZmVyIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGlsbGVnYWwgc3RhdGU6IHNpZ25lZCBieSBtdWx0aXBsZSBwdWJsaWMga2V5c2ApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIHtAc2VlIHZlcmlmeVNpZ25hdHVyZVdpdGhQdWJsaWNLZXlzfSBpbnN0ZWFkXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBpbnB1dEluZGV4XG4gKiBAcGFyYW0gYW1vdW50XG4gKiBAcGFyYW0gdmVyaWZpY2F0aW9uU2V0dGluZ3MgLSBpZiBwdWJsaWNLZXkgaXMgc3BlY2lmaWVkLCByZXR1cm5zIHRydWUgaWZmIGFueSBzaWduYXR1cmUgaXMgc2lnbmVkIGJ5IHB1YmxpY0tleS5cbiAqIEBwYXJhbSBwcmV2T3V0cHV0cyAtIG11c3QgYmUgc2V0IGZvciBwMnRyIHRyYW5zYWN0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KFxuICB0cmFuc2FjdGlvbjogVXR4b1RyYW5zYWN0aW9uPFROdW1iZXI+LFxuICBpbnB1dEluZGV4OiBudW1iZXIsXG4gIGFtb3VudDogVE51bWJlcixcbiAgdmVyaWZpY2F0aW9uU2V0dGluZ3M6IFZlcmlmaWNhdGlvblNldHRpbmdzID0ge30sXG4gIHByZXZPdXRwdXRzPzogVHhPdXRwdXQ8VE51bWJlcj5bXVxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IHNpZ25hdHVyZVZlcmlmaWNhdGlvbnMgPSBnZXRTaWduYXR1cmVWZXJpZmljYXRpb25zKFxuICAgIHRyYW5zYWN0aW9uLFxuICAgIGlucHV0SW5kZXgsXG4gICAgYW1vdW50LFxuICAgIHZlcmlmaWNhdGlvblNldHRpbmdzLFxuICAgIHByZXZPdXRwdXRzXG4gICkuZmlsdGVyKFxuICAgICh2KSA9PlxuICAgICAgLy8gSWYgbm8gcHVibGljS2V5IGlzIHNldCBpbiB2ZXJpZmljYXRpb25TZXR0aW5ncywgYWxsIHNpZ25hdHVyZXMgbXVzdCBiZSB2YWxpZC5cbiAgICAgIC8vIE90aGVyd2lzZSwgYSBzaW5nbGUgdmFsaWQgc2lnbmF0dXJlIGJ5IHRoZSBzcGVjaWZpZWQgcHVia2V5IGlzIHN1ZmZpY2llbnQuXG4gICAgICB2ZXJpZmljYXRpb25TZXR0aW5ncy5wdWJsaWNLZXkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKHYuc2lnbmVkQnkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAodmVyaWZpY2F0aW9uU2V0dGluZ3MucHVibGljS2V5LmVxdWFscyh2LnNpZ25lZEJ5KSB8fFxuICAgICAgICAgIHZlcmlmaWNhdGlvblNldHRpbmdzLnB1YmxpY0tleS5zbGljZSgxKS5lcXVhbHModi5zaWduZWRCeSkpKVxuICApO1xuXG4gIHJldHVybiBzaWduYXR1cmVWZXJpZmljYXRpb25zLmxlbmd0aCA+IDAgJiYgc2lnbmF0dXJlVmVyaWZpY2F0aW9ucy5ldmVyeSgodikgPT4gdi5zaWduZWRCeSAhPT0gdW5kZWZpbmVkKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gdlxuICogQHBhcmFtIHB1YmxpY0tleVxuICogQHJldHVybiB0cnVlIGlmZiBzaWduYXR1cmUgaXMgYnkgcHVibGljS2V5IChvciB4b25seSB2YXJpYW50IG9mIHB1YmxpY0tleSlcbiAqL1xuZnVuY3Rpb24gaXNTaWduYXR1cmVCeVB1YmxpY0tleSh2OiBTaWduYXR1cmVWZXJpZmljYXRpb24sIHB1YmxpY0tleTogQnVmZmVyKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgISF2LnNpZ25lZEJ5ICYmXG4gICAgKHYuc2lnbmVkQnkuZXF1YWxzKHB1YmxpY0tleSkgfHxcbiAgICAgIC8qIGZvciBwMnRyIHNpZ25hdHVyZXMsIHdlIHBhc3MgdGhlIHB1YmtleSBpbiAzMy1ieXRlIGZvcm1hdCByZWNvdmVyIGl0IGZyb20gdGhlIHNpZ25hdHVyZSBpbiAzMi1ieXRlIGZvcm1hdCAqL1xuICAgICAgKHB1YmxpY0tleS5sZW5ndGggPT09IDMzICYmIGlzU2lnbmF0dXJlQnlQdWJsaWNLZXkodiwgcHVibGljS2V5LnNsaWNlKDEpKSkpXG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gaW5wdXRJbmRleFxuICogQHBhcmFtIHByZXZPdXRwdXRzXG4gKiBAcGFyYW0gcHVibGljS2V5c1xuICogQHJldHVybiBhcnJheSB3aXRoIHNpZ25hdHVyZSBjb3JyZXNwb25kaW5nIHRvIG4tdGgga2V5LCB1bmRlZmluZWQgaWYgbm8gbWF0Y2ggZm91bmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25hdHVyZXNXaXRoUHVibGljS2V5czxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50PihcbiAgdHJhbnNhY3Rpb246IFV0eG9UcmFuc2FjdGlvbjxUTnVtYmVyPixcbiAgaW5wdXRJbmRleDogbnVtYmVyLFxuICBwcmV2T3V0cHV0czogVHhPdXRwdXQ8VE51bWJlcj5bXSxcbiAgcHVibGljS2V5czogQnVmZmVyW11cbik6IEFycmF5PEJ1ZmZlciB8IHVuZGVmaW5lZD4ge1xuICBpZiAodHJhbnNhY3Rpb24uaW5zLmxlbmd0aCAhPT0gcHJldk91dHB1dHMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCBsZW5ndGggbXVzdCBtYXRjaCBwcmV2T3V0cHV0cyBsZW5ndGhgKTtcbiAgfVxuXG4gIGNvbnN0IHNpZ25hdHVyZVZlcmlmaWNhdGlvbnMgPSBnZXRTaWduYXR1cmVWZXJpZmljYXRpb25zKFxuICAgIHRyYW5zYWN0aW9uLFxuICAgIGlucHV0SW5kZXgsXG4gICAgcHJldk91dHB1dHNbaW5wdXRJbmRleF0udmFsdWUsXG4gICAge30sXG4gICAgcHJldk91dHB1dHNcbiAgKTtcblxuICByZXR1cm4gcHVibGljS2V5cy5tYXAoKHB1YmxpY0tleSkgPT4ge1xuICAgIGNvbnN0IHYgPSBzaWduYXR1cmVWZXJpZmljYXRpb25zLmZpbmQoKHYpID0+IGlzU2lnbmF0dXJlQnlQdWJsaWNLZXkodiwgcHVibGljS2V5KSk7XG4gICAgcmV0dXJuIHYgPyB2LnNpZ25hdHVyZSA6IHVuZGVmaW5lZDtcbiAgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gaW5wdXRJbmRleFxuICogQHBhcmFtIHByZXZPdXRwdXRzIC0gdHJhbnNhY3Rpb24gb3V0cHV0cyBmb3IgaW5wdXRzXG4gKiBAcGFyYW0gcHVibGljS2V5cyAtIHB1YmxpYyBrZXlzIHRvIGNoZWNrIHNpZ25hdHVyZXMgZm9yXG4gKiBAcmV0dXJuIGFycmF5IG9mIGJvb2xlYW5zIGluZGljYXRpbmcgYSB2YWxpZCBzaWduYXR1cmUgZm9yIGV2ZXJ5IHB1YmtleSBpbiBfcHVibGljS2V5c19cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZVdpdGhQdWJsaWNLZXlzPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KFxuICB0cmFuc2FjdGlvbjogVXR4b1RyYW5zYWN0aW9uPFROdW1iZXI+LFxuICBpbnB1dEluZGV4OiBudW1iZXIsXG4gIHByZXZPdXRwdXRzOiBUeE91dHB1dDxUTnVtYmVyPltdLFxuICBwdWJsaWNLZXlzOiBCdWZmZXJbXVxuKTogYm9vbGVhbltdIHtcbiAgcmV0dXJuIGdldFNpZ25hdHVyZXNXaXRoUHVibGljS2V5cyh0cmFuc2FjdGlvbiwgaW5wdXRJbmRleCwgcHJldk91dHB1dHMsIHB1YmxpY0tleXMpLm1hcCgocykgPT4gcyAhPT0gdW5kZWZpbmVkKTtcbn1cblxuLyoqXG4gKiBXcmFwcGVyIGZvciB7QHNlZSB2ZXJpZnlTaWduYXR1cmVXaXRoUHVibGljS2V5c30gZm9yIHNpbmdsZSBwdWJrZXlcbiAqIEBwYXJhbSB0cmFuc2FjdGlvblxuICogQHBhcmFtIGlucHV0SW5kZXhcbiAqIEBwYXJhbSBwcmV2T3V0cHV0c1xuICogQHBhcmFtIHB1YmxpY0tleVxuICogQHJldHVybiB0cnVlIGlmZiBzaWduYXR1cmUgaXMgdmFsaWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZVdpdGhQdWJsaWNLZXk8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludD4oXG4gIHRyYW5zYWN0aW9uOiBVdHhvVHJhbnNhY3Rpb248VE51bWJlcj4sXG4gIGlucHV0SW5kZXg6IG51bWJlcixcbiAgcHJldk91dHB1dHM6IFR4T3V0cHV0PFROdW1iZXI+W10sXG4gIHB1YmxpY0tleTogQnVmZmVyXG4pOiBib29sZWFuIHtcbiAgcmV0dXJuIHZlcmlmeVNpZ25hdHVyZVdpdGhQdWJsaWNLZXlzKHRyYW5zYWN0aW9uLCBpbnB1dEluZGV4LCBwcmV2T3V0cHV0cywgW3B1YmxpY0tleV0pWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFNpZ0hhc2gobmV0d29yazogTmV0d29yaywgc2NyaXB0VHlwZT86IFNjcmlwdFR5cGUpOiBudW1iZXIge1xuICBzd2l0Y2ggKGdldE1haW5uZXQobmV0d29yaykpIHtcbiAgICBjYXNlIG5ldHdvcmtzLmJpdGNvaW5jYXNoOlxuICAgIGNhc2UgbmV0d29ya3MuYml0Y29pbnN2OlxuICAgIGNhc2UgbmV0d29ya3MuYml0Y29pbmdvbGQ6XG4gICAgY2FzZSBuZXR3b3Jrcy5lY2FzaDpcbiAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5TSUdIQVNIX0FMTCB8IFV0eG9UcmFuc2FjdGlvbi5TSUdIQVNIX0ZPUktJRDtcbiAgICBkZWZhdWx0OlxuICAgICAgc3dpdGNoIChzY3JpcHRUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3AydHInOlxuICAgICAgICBjYXNlICdwMnRyTXVzaWcyJzpcbiAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxUO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5TSUdIQVNIX0FMTDtcbiAgICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2lnbklucHV0UDJzaFAycGs8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludD4oXG4gIHR4QnVpbGRlcjogVXR4b1RyYW5zYWN0aW9uQnVpbGRlcjxUTnVtYmVyPixcbiAgdmluOiBudW1iZXIsXG4gIGtleVBhaXI6IEJJUDMySW50ZXJmYWNlXG4pOiB2b2lkIHtcbiAgY29uc3QgcHJldk91dFNjcmlwdFR5cGUgPSAncDJzaC1wMnBrJztcbiAgY29uc3QgeyByZWRlZW1TY3JpcHQsIHdpdG5lc3NTY3JpcHQgfSA9IGNyZWF0ZU91dHB1dFNjcmlwdFAyc2hQMnBrKGtleVBhaXIucHVibGljS2V5KTtcbiAga2V5UGFpci5uZXR3b3JrID0gdHhCdWlsZGVyLm5ldHdvcms7XG5cbiAgdHhCdWlsZGVyLnNpZ24oe1xuICAgIHZpbixcbiAgICBwcmV2T3V0U2NyaXB0VHlwZSxcbiAgICBrZXlQYWlyLFxuICAgIGhhc2hUeXBlOiBnZXREZWZhdWx0U2lnSGFzaCh0eEJ1aWxkZXIubmV0d29yayBhcyBOZXR3b3JrKSxcbiAgICByZWRlZW1TY3JpcHQsXG4gICAgd2l0bmVzc1NjcmlwdCxcbiAgICB3aXRuZXNzVmFsdWU6IHVuZGVmaW5lZCxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaWduSW5wdXQyT2YzPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KFxuICB0eEJ1aWxkZXI6IFV0eG9UcmFuc2FjdGlvbkJ1aWxkZXI8VE51bWJlcj4sXG4gIHZpbjogbnVtYmVyLFxuICBzY3JpcHRUeXBlOiBTY3JpcHRUeXBlMk9mMyxcbiAgcHVia2V5czogVHJpcGxlPEJ1ZmZlcj4sXG4gIGtleVBhaXI6IEJJUDMySW50ZXJmYWNlLFxuICBjb3NpZ25lcjogQnVmZmVyLFxuICBhbW91bnQ6IFROdW1iZXJcbik6IHZvaWQge1xuICBsZXQgY29udHJvbEJsb2NrO1xuICBsZXQgcmVkZWVtU2NyaXB0O1xuICBsZXQgd2l0bmVzc1NjcmlwdDtcblxuICBjb25zdCBwcmV2T3V0U2NyaXB0VHlwZSA9IHNjcmlwdFR5cGUyT2YzQXNQcmV2T3V0VHlwZShzY3JpcHRUeXBlKTtcbiAgaWYgKHNjcmlwdFR5cGUgPT09ICdwMnRyJykge1xuICAgICh7IHdpdG5lc3NTY3JpcHQsIGNvbnRyb2xCbG9jayB9ID0gY3JlYXRlU3BlbmRTY3JpcHRQMnRyKHB1YmtleXMsIFtrZXlQYWlyLnB1YmxpY0tleSwgY29zaWduZXJdKSk7XG4gIH0gZWxzZSB7XG4gICAgKHsgcmVkZWVtU2NyaXB0LCB3aXRuZXNzU2NyaXB0IH0gPSBjcmVhdGVPdXRwdXRTY3JpcHQyb2YzKHB1YmtleXMsIHNjcmlwdFR5cGUpKTtcbiAgfVxuXG4gIGtleVBhaXIubmV0d29yayA9IHR4QnVpbGRlci5uZXR3b3JrO1xuXG4gIHR4QnVpbGRlci5zaWduKHtcbiAgICB2aW4sXG4gICAgcHJldk91dFNjcmlwdFR5cGUsXG4gICAga2V5UGFpcixcbiAgICBoYXNoVHlwZTogZ2V0RGVmYXVsdFNpZ0hhc2godHhCdWlsZGVyLm5ldHdvcmsgYXMgTmV0d29yaywgc2NyaXB0VHlwZSksXG4gICAgcmVkZWVtU2NyaXB0LFxuICAgIHdpdG5lc3NTY3JpcHQsXG4gICAgd2l0bmVzc1ZhbHVlOiBhbW91bnQsXG4gICAgY29udHJvbEJsb2NrLFxuICB9KTtcbn1cbiJdfQ==