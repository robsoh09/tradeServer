"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DashTransaction = void 0;
const bufferutils_1 = require("bitcoinjs-lib/src/bufferutils");
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const UtxoTransaction_1 = require("../UtxoTransaction");
const networks_1 = require("../../networks");
class DashTransaction extends UtxoTransaction_1.UtxoTransaction {
    constructor(network, tx, amountType) {
        super(network, tx, amountType);
        this.type = 0;
        if (!(0, networks_1.isDash)(network)) {
            throw new Error(`invalid network`);
        }
        if (tx) {
            this.version = tx.version;
            if (tx instanceof DashTransaction) {
                this.type = tx.type;
                this.extraPayload = tx.extraPayload;
            }
        }
        // since `__toBuffer` is private we have to do a little hack here
        this.__toBuffer = this.toBufferWithExtraPayload;
    }
    static newTransaction(network, transaction, amountType) {
        return new DashTransaction(network, transaction, amountType);
    }
    static fromBuffer(buffer, noStrict, amountType = 'number', network) {
        const tx = new DashTransaction(network, super.fromBuffer(buffer, true, amountType, network));
        tx.type = tx.version >> 16;
        tx.version = tx.version & 0xffff;
        if (tx.byteLength() !== buffer.length) {
            const bufferReader = new bufferutils_1.BufferReader(buffer, tx.byteLength());
            tx.extraPayload = bufferReader.readVarSlice();
        }
        return tx;
    }
    clone(amountType) {
        return new DashTransaction(this.network, this, amountType);
    }
    byteLength(_ALLOW_WITNESS) {
        return super.byteLength(_ALLOW_WITNESS) + (this.extraPayload ? (0, UtxoTransaction_1.varSliceSize)(this.extraPayload) : 0);
    }
    /**
     * Helper to override `__toBuffer()` of bitcoinjs.Transaction.
     * Since the method is private, we use a hack in the constructor to make it work.
     *
     * TODO: remove `private` modifier in bitcoinjs `__toBuffer()` or find some other solution
     *
     * @param buffer - optional target buffer
     * @param initialOffset - can only be undefined or 0. Other values are only used for serialization in blocks.
     * @param _ALLOW_WITNESS - ignored
     */
    toBufferWithExtraPayload(buffer, initialOffset, _ALLOW_WITNESS = false) {
        // We can ignore the `_ALLOW_WITNESS` parameter here since it has no effect.
        if (!buffer) {
            buffer = Buffer.allocUnsafe(this.byteLength(false));
        }
        if (initialOffset !== undefined && initialOffset !== 0) {
            throw new Error(`not supported`);
        }
        // Start out with regular bitcoin byte sequence.
        // This buffer will have excess size because it uses `byteLength()` to allocate.
        const baseBuffer = bitcoinjs_lib_1.Transaction.prototype.__toBuffer.call(this);
        baseBuffer.copy(buffer);
        // overwrite leading version bytes (uint16 version, uint16 type)
        const bufferWriter = new bufferutils_1.BufferWriter(buffer, 0);
        bufferWriter.writeUInt32((this.version & 0xffff) | (this.type << 16));
        // Seek to end of original byte sequence and add extraPayload.
        // We must use the byteLength as calculated by the bitcoinjs implementation since
        // `baseBuffer` has an excess size.
        if (this.extraPayload) {
            bufferWriter.offset = bitcoinjs_lib_1.Transaction.prototype.byteLength.call(this);
            bufferWriter.writeVarSlice(this.extraPayload);
        }
        return buffer;
    }
    getHash(forWitness) {
        if (forWitness) {
            throw new Error(`invalid argument`);
        }
        return bitcoinjs_lib_1.crypto.hash256(this.toBuffer());
    }
    /**
     * Build a hash for all or none of the transaction inputs depending on the hashtype
     * @param hashType
     * @returns Buffer
     */
    getPrevoutHash(hashType) {
        if (!(hashType & UtxoTransaction_1.UtxoTransaction.SIGHASH_ANYONECANPAY)) {
            const bufferWriter = new bufferutils_1.BufferWriter(Buffer.allocUnsafe(36 * this.ins.length));
            this.ins.forEach(function (txIn) {
                bufferWriter.writeSlice(txIn.hash);
                bufferWriter.writeUInt32(txIn.index);
            });
            return bitcoinjs_lib_1.crypto.hash256(bufferWriter.buffer);
        }
        return Buffer.alloc(32, 0);
    }
}
exports.DashTransaction = DashTransaction;
DashTransaction.DASH_NORMAL = 0;
DashTransaction.DASH_PROVIDER_REGISTER = 1;
DashTransaction.DASH_PROVIDER_UPDATE_SERVICE = 2;
DashTransaction.DASH_PROVIDER_UPDATE_REGISTRAR = 3;
DashTransaction.DASH_PROVIDER_UPDATE_REVOKE = 4;
DashTransaction.DASH_COINBASE = 5;
DashTransaction.DASH_QUORUM_COMMITMENT = 6;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGFzaFRyYW5zYWN0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2JpdGdvL2Rhc2gvRGFzaFRyYW5zYWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtEQUEyRTtBQUMzRSxpREFBK0Q7QUFFL0Qsd0RBQW1FO0FBQ25FLDZDQUFpRDtBQUVqRCxNQUFhLGVBQTBELFNBQVEsaUNBQXdCO0lBWXJHLFlBQVksT0FBZ0IsRUFBRSxFQUFpQyxFQUFFLFVBQWdDO1FBQy9GLEtBQUssQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBSjFCLFNBQUksR0FBRyxDQUFDLENBQUM7UUFNZCxJQUFJLENBQUMsSUFBQSxpQkFBTSxFQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3BCLE1BQU0sSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztTQUNwQztRQUVELElBQUksRUFBRSxFQUFFO1lBQ04sSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDO1lBRTFCLElBQUksRUFBRSxZQUFZLGVBQWUsRUFBRTtnQkFDakMsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDO2dCQUNwQixJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUM7YUFDckM7U0FDRjtRQUVELGlFQUFpRTtRQUNoRSxJQUFZLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyx3QkFBd0IsQ0FBQztJQUMzRCxDQUFDO0lBRVMsTUFBTSxDQUFDLGNBQWMsQ0FDN0IsT0FBZ0IsRUFDaEIsV0FBOEMsRUFDOUMsVUFBZ0M7UUFFaEMsT0FBTyxJQUFJLGVBQWUsQ0FBVSxPQUFPLEVBQUUsV0FBVyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFRCxNQUFNLENBQUMsVUFBVSxDQUNmLE1BQWMsRUFDZCxRQUFpQixFQUNqQixhQUFrQyxRQUFRLEVBQzFDLE9B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Q0FBQyxDQUFDLFFBQVEsR0FBRyxpQ0FBZSxDQUFDLG9CQUFvQixDQUFDLEVBQUU7WUFDdEQsTUFBTSxZQUFZLEdBQUcsSUFBSSwwQkFBWSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUVoRixJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxVQUFVLElBQUk7Z0JBQzdCLFlBQVksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNuQyxZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN2QyxDQUFDLENBQUMsQ0FBQztZQUVILE9BQU8sc0JBQU8sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQzdDO1FBRUQsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM3QixDQUFDOztBQWpJSCwwQ0FrSUM7QUFqSVEsMkJBQVcsR0FBRyxDQUFDLENBQUM7QUFDaEIsc0NBQXNCLEdBQUcsQ0FBQyxDQUFDO0FBQzNCLDRDQUE0QixHQUFHLENBQUMsQ0FBQztBQUNqQyw4Q0FBOEIsR0FBRyxDQUFDLENBQUM7QUFDbkMsMkNBQTJCLEdBQUcsQ0FBQyxDQUFDO0FBQ2hDLDZCQUFhLEdBQUcsQ0FBQyxDQUFDO0FBQ2xCLHNDQUFzQixHQUFHLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlclJlYWRlciwgQnVmZmVyV3JpdGVyIH0gZnJvbSAnYml0Y29pbmpzLWxpYi9zcmMvYnVmZmVydXRpbHMnO1xuaW1wb3J0IHsgY3J5cHRvIGFzIGJjcnlwdG8sIFRyYW5zYWN0aW9uIH0gZnJvbSAnYml0Y29pbmpzLWxpYic7XG5cbmltcG9ydCB7IFV0eG9UcmFuc2FjdGlvbiwgdmFyU2xpY2VTaXplIH0gZnJvbSAnLi4vVXR4b1RyYW5zYWN0aW9uJztcbmltcG9ydCB7IGlzRGFzaCwgTmV0d29yayB9IGZyb20gJy4uLy4uL25ldHdvcmtzJztcblxuZXhwb3J0IGNsYXNzIERhc2hUcmFuc2FjdGlvbjxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50ID0gbnVtYmVyPiBleHRlbmRzIFV0eG9UcmFuc2FjdGlvbjxUTnVtYmVyPiB7XG4gIHN0YXRpYyBEQVNIX05PUk1BTCA9IDA7XG4gIHN0YXRpYyBEQVNIX1BST1ZJREVSX1JFR0lTVEVSID0gMTtcbiAgc3RhdGljIERBU0hfUFJPVklERVJfVVBEQVRFX1NFUlZJQ0UgPSAyO1xuICBzdGF0aWMgREFTSF9QUk9WSURFUl9VUERBVEVfUkVHSVNUUkFSID0gMztcbiAgc3RhdGljIERBU0hfUFJPVklERVJfVVBEQVRFX1JFVk9LRSA9IDQ7XG4gIHN0YXRpYyBEQVNIX0NPSU5CQVNFID0gNTtcbiAgc3RhdGljIERBU0hfUVVPUlVNX0NPTU1JVE1FTlQgPSA2O1xuXG4gIHB1YmxpYyB0eXBlID0gMDtcbiAgcHVibGljIGV4dHJhUGF5bG9hZD86IEJ1ZmZlcjtcblxuICBjb25zdHJ1Y3RvcihuZXR3b3JrOiBOZXR3b3JrLCB0eD86IFRyYW5zYWN0aW9uPGJpZ2ludCB8IG51bWJlcj4sIGFtb3VudFR5cGU/OiAnYmlnaW50JyB8ICdudW1iZXInKSB7XG4gICAgc3VwZXIobmV0d29yaywgdHgsIGFtb3VudFR5cGUpO1xuXG4gICAgaWYgKCFpc0Rhc2gobmV0d29yaykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBuZXR3b3JrYCk7XG4gICAgfVxuXG4gICAgaWYgKHR4KSB7XG4gICAgICB0aGlzLnZlcnNpb24gPSB0eC52ZXJzaW9uO1xuXG4gICAgICBpZiAodHggaW5zdGFuY2VvZiBEYXNoVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHgudHlwZTtcbiAgICAgICAgdGhpcy5leHRyYVBheWxvYWQgPSB0eC5leHRyYVBheWxvYWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2luY2UgYF9fdG9CdWZmZXJgIGlzIHByaXZhdGUgd2UgaGF2ZSB0byBkbyBhIGxpdHRsZSBoYWNrIGhlcmVcbiAgICAodGhpcyBhcyBhbnkpLl9fdG9CdWZmZXIgPSB0aGlzLnRvQnVmZmVyV2l0aEV4dHJhUGF5bG9hZDtcbiAgfVxuXG4gIHByb3RlY3RlZCBzdGF0aWMgbmV3VHJhbnNhY3Rpb248VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludCA9IG51bWJlcj4oXG4gICAgbmV0d29yazogTmV0d29yayxcbiAgICB0cmFuc2FjdGlvbj86IERhc2hUcmFuc2FjdGlvbjxudW1iZXIgfCBiaWdpbnQ+LFxuICAgIGFtb3VudFR5cGU/OiAnbnVtYmVyJyB8ICdiaWdpbnQnXG4gICk6IERhc2hUcmFuc2FjdGlvbjxUTnVtYmVyPiB7XG4gICAgcmV0dXJuIG5ldyBEYXNoVHJhbnNhY3Rpb248VE51bWJlcj4obmV0d29yaywgdHJhbnNhY3Rpb24sIGFtb3VudFR5cGUpO1xuICB9XG5cbiAgc3RhdGljIGZyb21CdWZmZXI8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludCA9IG51bWJlcj4oXG4gICAgYnVmZmVyOiBCdWZmZXIsXG4gICAgbm9TdHJpY3Q6IGJvb2xlYW4sXG4gICAgYW1vdW50VHlwZTogJ251bWJlcicgfCAnYmlnaW50JyA9ICdudW1iZXInLFxuICAgIG5ldHdvcms6IE5ldHdvcmtcbiAgKTogRGFzaFRyYW5zYWN0aW9uPFROdW1iZXI+IHtcbiAgICBjb25zdCB0eCA9IG5ldyBEYXNoVHJhbnNhY3Rpb248VE51bWJlcj4obmV0d29yaywgc3VwZXIuZnJvbUJ1ZmZlcjxUTnVtYmVyPihidWZmZXIsIHRydWUsIGFtb3VudFR5cGUsIG5ldHdvcmspKTtcbiAgICB0eC50eXBlID0gdHgudmVyc2lvbiA+PiAxNjtcbiAgICB0eC52ZXJzaW9uID0gdHgudmVyc2lvbiAmIDB4ZmZmZjtcbiAgICBpZiAodHguYnl0ZUxlbmd0aCgpICE9PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgICBjb25zdCBidWZmZXJSZWFkZXIgPSBuZXcgQnVmZmVyUmVhZGVyKGJ1ZmZlciwgdHguYnl0ZUxlbmd0aCgpKTtcbiAgICAgIHR4LmV4dHJhUGF5bG9hZCA9IGJ1ZmZlclJlYWRlci5yZWFkVmFyU2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHR4O1xuICB9XG5cbiAgY2xvbmU8VE4yIGV4dGVuZHMgYmlnaW50IHwgbnVtYmVyID0gVE51bWJlcj4oYW1vdW50VHlwZT86ICdudW1iZXInIHwgJ2JpZ2ludCcpOiBEYXNoVHJhbnNhY3Rpb248VE4yPiB7XG4gICAgcmV0dXJuIG5ldyBEYXNoVHJhbnNhY3Rpb248VE4yPih0aGlzLm5ldHdvcmssIHRoaXMsIGFtb3VudFR5cGUpO1xuICB9XG5cbiAgYnl0ZUxlbmd0aChfQUxMT1dfV0lUTkVTUz86IGJvb2xlYW4pOiBudW1iZXIge1xuICAgIHJldHVybiBzdXBlci5ieXRlTGVuZ3RoKF9BTExPV19XSVRORVNTKSArICh0aGlzLmV4dHJhUGF5bG9hZCA/IHZhclNsaWNlU2l6ZSh0aGlzLmV4dHJhUGF5bG9hZCkgOiAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gb3ZlcnJpZGUgYF9fdG9CdWZmZXIoKWAgb2YgYml0Y29pbmpzLlRyYW5zYWN0aW9uLlxuICAgKiBTaW5jZSB0aGUgbWV0aG9kIGlzIHByaXZhdGUsIHdlIHVzZSBhIGhhY2sgaW4gdGhlIGNvbnN0cnVjdG9yIHRvIG1ha2UgaXQgd29yay5cbiAgICpcbiAgICogVE9ETzogcmVtb3ZlIGBwcml2YXRlYCBtb2RpZmllciBpbiBiaXRjb2luanMgYF9fdG9CdWZmZXIoKWAgb3IgZmluZCBzb21lIG90aGVyIHNvbHV0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBvcHRpb25hbCB0YXJnZXQgYnVmZmVyXG4gICAqIEBwYXJhbSBpbml0aWFsT2Zmc2V0IC0gY2FuIG9ubHkgYmUgdW5kZWZpbmVkIG9yIDAuIE90aGVyIHZhbHVlcyBhcmUgb25seSB1c2VkIGZvciBzZXJpYWxpemF0aW9uIGluIGJsb2Nrcy5cbiAgICogQHBhcmFtIF9BTExPV19XSVRORVNTIC0gaWdub3JlZFxuICAgKi9cbiAgcHJpdmF0ZSB0b0J1ZmZlcldpdGhFeHRyYVBheWxvYWQoYnVmZmVyPzogQnVmZmVyLCBpbml0aWFsT2Zmc2V0PzogbnVtYmVyLCBfQUxMT1dfV0lUTkVTUyA9IGZhbHNlKTogQnVmZmVyIHtcbiAgICAvLyBXZSBjYW4gaWdub3JlIHRoZSBgX0FMTE9XX1dJVE5FU1NgIHBhcmFtZXRlciBoZXJlIHNpbmNlIGl0IGhhcyBubyBlZmZlY3QuXG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0aGlzLmJ5dGVMZW5ndGgoZmFsc2UpKTtcbiAgICB9XG5cbiAgICBpZiAoaW5pdGlhbE9mZnNldCAhPT0gdW5kZWZpbmVkICYmIGluaXRpYWxPZmZzZXQgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IG91dCB3aXRoIHJlZ3VsYXIgYml0Y29pbiBieXRlIHNlcXVlbmNlLlxuICAgIC8vIFRoaXMgYnVmZmVyIHdpbGwgaGF2ZSBleGNlc3Mgc2l6ZSBiZWNhdXNlIGl0IHVzZXMgYGJ5dGVMZW5ndGgoKWAgdG8gYWxsb2NhdGUuXG4gICAgY29uc3QgYmFzZUJ1ZmZlciA9IChUcmFuc2FjdGlvbi5wcm90b3R5cGUgYXMgYW55KS5fX3RvQnVmZmVyLmNhbGwodGhpcyk7XG4gICAgYmFzZUJ1ZmZlci5jb3B5KGJ1ZmZlcik7XG5cbiAgICAvLyBvdmVyd3JpdGUgbGVhZGluZyB2ZXJzaW9uIGJ5dGVzICh1aW50MTYgdmVyc2lvbiwgdWludDE2IHR5cGUpXG4gICAgY29uc3QgYnVmZmVyV3JpdGVyID0gbmV3IEJ1ZmZlcldyaXRlcihidWZmZXIsIDApO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMigodGhpcy52ZXJzaW9uICYgMHhmZmZmKSB8ICh0aGlzLnR5cGUgPDwgMTYpKTtcblxuICAgIC8vIFNlZWsgdG8gZW5kIG9mIG9yaWdpbmFsIGJ5dGUgc2VxdWVuY2UgYW5kIGFkZCBleHRyYVBheWxvYWQuXG4gICAgLy8gV2UgbXVzdCB1c2UgdGhlIGJ5dGVMZW5ndGggYXMgY2FsY3VsYXRlZCBieSB0aGUgYml0Y29pbmpzIGltcGxlbWVudGF0aW9uIHNpbmNlXG4gICAgLy8gYGJhc2VCdWZmZXJgIGhhcyBhbiBleGNlc3Mgc2l6ZS5cbiAgICBpZiAodGhpcy5leHRyYVBheWxvYWQpIHtcbiAgICAgIGJ1ZmZlcldyaXRlci5vZmZzZXQgPSBUcmFuc2FjdGlvbi5wcm90b3R5cGUuYnl0ZUxlbmd0aC5jYWxsKHRoaXMpO1xuICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVmFyU2xpY2UodGhpcy5leHRyYVBheWxvYWQpO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmZXI7XG4gIH1cblxuICBnZXRIYXNoKGZvcldpdG5lc3M/OiBib29sZWFuKTogQnVmZmVyIHtcbiAgICBpZiAoZm9yV2l0bmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFyZ3VtZW50YCk7XG4gICAgfVxuICAgIHJldHVybiBiY3J5cHRvLmhhc2gyNTYodGhpcy50b0J1ZmZlcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhIGhhc2ggZm9yIGFsbCBvciBub25lIG9mIHRoZSB0cmFuc2FjdGlvbiBpbnB1dHMgZGVwZW5kaW5nIG9uIHRoZSBoYXNodHlwZVxuICAgKiBAcGFyYW0gaGFzaFR5cGVcbiAgICogQHJldHVybnMgQnVmZmVyXG4gICAqL1xuICBnZXRQcmV2b3V0SGFzaChoYXNoVHlwZTogbnVtYmVyKTogQnVmZmVyIHtcbiAgICBpZiAoIShoYXNoVHlwZSAmIFV0eG9UcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWSkpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlcldyaXRlciA9IG5ldyBCdWZmZXJXcml0ZXIoQnVmZmVyLmFsbG9jVW5zYWZlKDM2ICogdGhpcy5pbnMubGVuZ3RoKSk7XG5cbiAgICAgIHRoaXMuaW5zLmZvckVhY2goZnVuY3Rpb24gKHR4SW4pIHtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlU2xpY2UodHhJbi5oYXNoKTtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHR4SW4uaW5kZXgpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiY3J5cHRvLmhhc2gyNTYoYnVmZmVyV3JpdGVyLmJ1ZmZlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygzMiwgMCk7XG4gIH1cbn1cbiJdfQ==