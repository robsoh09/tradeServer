"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UtxoPsbt = void 0;
const assert = require("assert");
const bip174_1 = require("bip174");
const utils_1 = require("bip174/src/lib/utils");
const bufferutils_1 = require("bitcoinjs-lib/src/bufferutils");
const bip32_1 = require("bip32");
const bs58check = require("bs58check");
const proprietaryKeyVal_1 = require("bip174/src/lib/proprietaryKeyVal");
const __1 = require("..");
const UtxoTransaction_1 = require("./UtxoTransaction");
const Unspent_1 = require("./Unspent");
const scriptTypes_1 = require("./psbt/scriptTypes");
const fromHalfSigned_1 = require("./psbt/fromHalfSigned");
const outputScripts_1 = require("./outputScripts");
const parseInput_1 = require("./parseInput");
const Musig2_1 = require("./Musig2");
const types_1 = require("./types");
const taproot_1 = require("../taproot");
const PsbtUtil_1 = require("./PsbtUtil");
function defaultSighashTypes() {
    return [__1.Transaction.SIGHASH_DEFAULT, __1.Transaction.SIGHASH_ALL];
}
function addForkIdToSighashesIfNeeded(network, sighashTypes) {
    switch ((0, __1.getMainnet)(network)) {
        case __1.networks.bitcoincash:
        case __1.networks.bitcoinsv:
        case __1.networks.bitcoingold:
        case __1.networks.ecash:
            return [...sighashTypes, ...sighashTypes.map((s) => s | UtxoTransaction_1.UtxoTransaction.SIGHASH_FORKID)];
        default:
            return sighashTypes;
    }
}
function toSignatureParams(network, v) {
    if (Array.isArray(v))
        return toSignatureParams(network, { sighashTypes: v });
    const defaultSignatureParams = { deterministic: false, sighashTypes: defaultSighashTypes() };
    const ret = { ...defaultSignatureParams, ...v };
    ret.sighashTypes = addForkIdToSighashesIfNeeded(network, ret.sighashTypes);
    return ret;
}
/**
 * @param a
 * @param b
 * @returns true if the two public keys are equal ignoring the y coordinate.
 */
function equalPublicKeyIgnoreY(a, b) {
    return (0, outputScripts_1.toXOnlyPublicKey)(a).equals((0, outputScripts_1.toXOnlyPublicKey)(b));
}
// TODO: upstream does `checkInputsForPartialSigs` before doing things like
// `setVersion`. Our inputs could have tapscriptsigs (or in future tapkeysigs)
// and not fail that check. Do we want to do anything about that?
class UtxoPsbt extends __1.Psbt {
    constructor() {
        super(...arguments);
        this.nonceStore = new Musig2_1.Musig2NonceStore();
    }
    static transactionFromBuffer(buffer, network) {
        return UtxoTransaction_1.UtxoTransaction.fromBuffer(buffer, false, 'bigint', network);
    }
    static createPsbt(opts, data) {
        return new UtxoPsbt(opts, data || new bip174_1.Psbt(new __1.PsbtTransaction({ tx: new UtxoTransaction_1.UtxoTransaction(opts.network) })));
    }
    static fromBuffer(buffer, opts) {
        const transactionFromBuffer = (buffer) => {
            const tx = this.transactionFromBuffer(buffer, opts.network);
            return new __1.PsbtTransaction({ tx });
        };
        const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer, {
            bip32PathsAbsolute: opts.bip32PathsAbsolute,
        });
        const psbt = this.createPsbt(opts, psbtBase);
        // Upstream checks for duplicate inputs here, but it seems to be of dubious value.
        return psbt;
    }
    static fromHex(data, opts) {
        return this.fromBuffer(Buffer.from(data, 'hex'), opts);
    }
    /**
     * @param parent - Parent key. Matched with `bip32Derivations` using `fingerprint` property.
     * @param bip32Derivations - possible derivations for input or output
     * @param ignoreY - when true, ignore the y coordinate when matching public keys
     * @return derived bip32 node if matching derivation is found, undefined if none is found
     * @throws Error if more than one match is found
     */
    static deriveKeyPair(parent, bip32Derivations, { ignoreY }) {
        const matchingDerivations = bip32Derivations.filter((bipDv) => {
            return bipDv.masterFingerprint.equals(parent.fingerprint);
        });
        if (!matchingDerivations.length) {
            // No fingerprint match
            return undefined;
        }
        if (matchingDerivations.length !== 1) {
            throw new Error(`more than one matching derivation for fingerprint ${parent.fingerprint.toString('hex')}: ${matchingDerivations.length}`);
        }
        const [derivation] = matchingDerivations;
        const node = parent.derivePath(derivation.path);
        if (!node.publicKey.equals(derivation.pubkey)) {
            if (!ignoreY || !equalPublicKeyIgnoreY(node.publicKey, derivation.pubkey)) {
                throw new Error('pubkey did not match bip32Derivation');
            }
        }
        return node;
    }
    static deriveKeyPairForInput(bip32, input) {
        var _a, _b, _c, _d;
        return ((_a = input.tapBip32Derivation) === null || _a === void 0 ? void 0 : _a.length)
            ? (_b = UtxoPsbt.deriveKeyPair(bip32, input.tapBip32Derivation, { ignoreY: true })) === null || _b === void 0 ? void 0 : _b.publicKey
            : ((_c = input.bip32Derivation) === null || _c === void 0 ? void 0 : _c.length)
                ? (_d = UtxoPsbt.deriveKeyPair(bip32, input.bip32Derivation, { ignoreY: false })) === null || _d === void 0 ? void 0 : _d.publicKey
                : bip32 === null || bip32 === void 0 ? void 0 : bip32.publicKey;
    }
    get network() {
        return this.tx.network;
    }
    toHex() {
        return this.toBuffer().toString('hex');
    }
    /**
     * It is expensive to attempt to compute every output address using psbt.txOutputs[outputIndex]
     * to then just get the script. Here, we are doing the same thing as what txOutputs() does in
     * bitcoinjs-lib, but without iterating over each output.
     * @param outputIndex
     * @returns output script at the given index
     */
    getOutputScript(outputIndex) {
        return this.__CACHE.__TX.outs[outputIndex].script;
    }
    getNonWitnessPreviousTxids() {
        const txInputs = this.txInputs; // These are somewhat costly to extract
        const txidSet = new Set();
        this.data.inputs.forEach((input, index) => {
            if (!input.witnessUtxo) {
                throw new Error('Must have witness UTXO for all inputs');
            }
            if (!(0, scriptTypes_1.isSegwit)(input.witnessUtxo.script, input.redeemScript)) {
                txidSet.add((0, Unspent_1.getOutputIdForInput)(txInputs[index]).txid);
            }
        });
        return [...txidSet];
    }
    addNonWitnessUtxos(txBufs) {
        const txInputs = this.txInputs; // These are somewhat costly to extract
        this.data.inputs.forEach((input, index) => {
            if (!input.witnessUtxo) {
                throw new Error('Must have witness UTXO for all inputs');
            }
            if (!(0, scriptTypes_1.isSegwit)(input.witnessUtxo.script, input.redeemScript)) {
                const { txid } = (0, Unspent_1.getOutputIdForInput)(txInputs[index]);
                if (txBufs[txid] === undefined) {
                    throw new Error('Not all required previous transactions provided');
                }
                this.updateInput(index, { nonWitnessUtxo: txBufs[txid] });
            }
        });
        return this;
    }
    static fromTransaction(transaction, prevOutputs) {
        if (prevOutputs.length !== transaction.ins.length) {
            throw new Error(`Transaction has ${transaction.ins.length} inputs, but ${prevOutputs.length} previous outputs provided`);
        }
        const clonedTransaction = transaction.clone();
        const updates = (0, fromHalfSigned_1.unsign)(clonedTransaction, prevOutputs);
        const psbtBase = new bip174_1.Psbt(new __1.PsbtTransaction({ tx: clonedTransaction }));
        clonedTransaction.ins.forEach(() => psbtBase.inputs.push({ unknownKeyVals: [] }));
        clonedTransaction.outs.forEach(() => psbtBase.outputs.push({ unknownKeyVals: [] }));
        const psbt = this.createPsbt({ network: transaction.network }, psbtBase);
        updates.forEach((update, index) => {
            psbt.updateInput(index, update);
            psbt.updateInput(index, { witnessUtxo: { script: prevOutputs[index].script, value: prevOutputs[index].value } });
        });
        return psbt;
    }
    getUnsignedTx() {
        return this.tx.clone();
    }
    static newTransaction(network) {
        return new UtxoTransaction_1.UtxoTransaction(network);
    }
    get tx() {
        return this.data.globalMap.unsignedTx.tx;
    }
    checkForSignatures(propName) {
        this.data.inputs.forEach((input) => {
            var _a, _b;
            if (((_a = input.tapScriptSig) === null || _a === void 0 ? void 0 : _a.length) || input.tapKeySig || ((_b = input.partialSig) === null || _b === void 0 ? void 0 : _b.length)) {
                throw new Error(`Cannot modify ${propName !== null && propName !== void 0 ? propName : 'transaction'} - signatures exist.`);
            }
        });
    }
    /**
     * @returns true if the input at inputIndex is a taproot key path.
     * Checks for presence of minimum required key path input fields and absence of any script path only input fields.
     */
    isTaprootKeyPathInput(inputIndex) {
        var _a, _b, _c;
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        return (!!input.tapInternalKey &&
            !!input.tapMerkleRoot &&
            !(((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) ||
                ((_b = input.tapScriptSig) === null || _b === void 0 ? void 0 : _b.length) ||
                ((_c = input.tapBip32Derivation) === null || _c === void 0 ? void 0 : _c.some((v) => v.leafHashes.length))));
    }
    /**
     * @returns true if the input at inputIndex is a taproot script path.
     * Checks for presence of minimum required script path input fields and absence of any key path only input fields.
     */
    isTaprootScriptPathInput(inputIndex) {
        var _a;
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        return (!!((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) &&
            !(this.getProprietaryKeyVals(inputIndex, {
                identifier: PsbtUtil_1.PSBT_PROPRIETARY_IDENTIFIER,
                subtype: PsbtUtil_1.ProprietaryKeySubtype.MUSIG2_PARTICIPANT_PUB_KEYS,
            }).length ||
                this.getProprietaryKeyVals(inputIndex, {
                    identifier: PsbtUtil_1.PSBT_PROPRIETARY_IDENTIFIER,
                    subtype: PsbtUtil_1.ProprietaryKeySubtype.MUSIG2_PUB_NONCE,
                }).length ||
                this.getProprietaryKeyVals(inputIndex, {
                    identifier: PsbtUtil_1.PSBT_PROPRIETARY_IDENTIFIER,
                    subtype: PsbtUtil_1.ProprietaryKeySubtype.MUSIG2_PARTIAL_SIG,
                }).length));
    }
    /**
     * @returns true if the input at inputIndex is a taproot
     */
    isTaprootInput(inputIndex) {
        var _a, _b, _c;
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        const isP2TR = (script) => {
            try {
                (0, taproot_1.getTaprootOutputKey)(script);
                return true;
            }
            catch (e) {
                return false;
            }
        };
        return !!(input.tapInternalKey ||
            input.tapMerkleRoot ||
            ((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) ||
            ((_b = input.tapBip32Derivation) === null || _b === void 0 ? void 0 : _b.length) ||
            ((_c = input.tapScriptSig) === null || _c === void 0 ? void 0 : _c.length) ||
            this.getProprietaryKeyVals(inputIndex, {
                identifier: PsbtUtil_1.PSBT_PROPRIETARY_IDENTIFIER,
                subtype: PsbtUtil_1.ProprietaryKeySubtype.MUSIG2_PARTICIPANT_PUB_KEYS,
            }).length ||
            this.getProprietaryKeyVals(inputIndex, {
                identifier: PsbtUtil_1.PSBT_PROPRIETARY_IDENTIFIER,
                subtype: PsbtUtil_1.ProprietaryKeySubtype.MUSIG2_PUB_NONCE,
            }).length ||
            this.getProprietaryKeyVals(inputIndex, {
                identifier: PsbtUtil_1.PSBT_PROPRIETARY_IDENTIFIER,
                subtype: PsbtUtil_1.ProprietaryKeySubtype.MUSIG2_PARTIAL_SIG,
            }).length ||
            (input.witnessUtxo && isP2TR(input.witnessUtxo.script)));
    }
    isMultisigTaprootScript(script) {
        try {
            (0, parseInput_1.parsePubScript2Of3)(script, 'taprootScriptPathSpend');
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Mostly copied from bitcoinjs-lib/ts_src/psbt.ts
     */
    finalizeAllInputs() {
        (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one
        this.data.inputs.map((input, idx) => {
            var _a;
            if ((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) {
                return this.isMultisigTaprootScript(input.tapLeafScript[0].script)
                    ? this.finalizeTaprootInput(idx)
                    : this.finalizeTapInputWithSingleLeafScriptAndSignature(idx);
            }
            else if (this.isTaprootKeyPathInput(idx)) {
                return this.finalizeTaprootMusig2Input(idx);
            }
            return this.finalizeInput(idx);
        });
        return this;
    }
    finalizeTaprootInput(inputIndex) {
        var _a, _b;
        const sanitizeSignature = (sig) => {
            const sighashType = sig.length === 64 ? __1.Transaction.SIGHASH_DEFAULT : sig.readUInt8(sig.length - 1);
            const inputSighashType = input.sighashType === undefined ? __1.Transaction.SIGHASH_DEFAULT : input.sighashType;
            assert(sighashType === inputSighashType, 'signature sighash does not match input sighash type');
            // TODO BTC-663 This should be fixed in platform. This is just a workaround fix.
            return sighashType === __1.Transaction.SIGHASH_DEFAULT && sig.length === 65 ? sig.slice(0, 64) : sig;
        };
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        // witness = control-block script first-sig second-sig
        if (((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) !== 1) {
            throw new Error('Only one leaf script supported for finalizing');
        }
        const { controlBlock, script } = input.tapLeafScript[0];
        const witness = [script, controlBlock];
        const [pubkey1, pubkey2] = (0, parseInput_1.parsePubScript2Of3)(script, 'taprootScriptPathSpend').publicKeys;
        for (const pk of [pubkey1, pubkey2]) {
            const sig = (_b = input.tapScriptSig) === null || _b === void 0 ? void 0 : _b.find(({ pubkey }) => equalPublicKeyIgnoreY(pk, pubkey));
            if (!sig) {
                throw new Error('Could not find signatures in Script Sig.');
            }
            witness.unshift(sanitizeSignature(sig.signature));
        }
        const witnessLength = witness.reduce((s, b) => s + b.length + bufferutils_1.varuint.encodingLength(b.length), 1);
        const bufferWriter = bufferutils_1.BufferWriter.withCapacity(witnessLength);
        bufferWriter.writeVector(witness);
        const finalScriptWitness = bufferWriter.end();
        this.data.updateInput(inputIndex, { finalScriptWitness });
        this.data.clearFinalizedInput(inputIndex);
        return this;
    }
    /**
     * Finalizes a taproot musig2 input by aggregating all partial sigs.
     * IMPORTANT: Always call validate* function before finalizing.
     */
    finalizeTaprootMusig2Input(inputIndex) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        const partialSigs = (0, Musig2_1.parsePsbtMusig2PartialSigs)(input);
        if ((partialSigs === null || partialSigs === void 0 ? void 0 : partialSigs.length) !== 2) {
            throw new Error(`invalid number of partial signatures ${partialSigs ? partialSigs.length : 0} to finalize`);
        }
        const { partialSigs: pSigs, sigHashType } = (0, Musig2_1.getSigHashTypeFromSigs)(partialSigs);
        const { sessionKey } = this.getMusig2SessionKey(inputIndex, sigHashType);
        const aggSig = (0, Musig2_1.musig2AggregateSigs)(pSigs.map((pSig) => pSig.partialSig), sessionKey);
        const sig = sigHashType === __1.Transaction.SIGHASH_DEFAULT ? aggSig : Buffer.concat([aggSig, Buffer.of(sigHashType)]);
        // single signature with 64/65 bytes size is script witness for key path spend
        const bufferWriter = bufferutils_1.BufferWriter.withCapacity(1 + bufferutils_1.varuint.encodingLength(sig.length) + sig.length);
        bufferWriter.writeVector([sig]);
        const finalScriptWitness = bufferWriter.end();
        this.data.updateInput(inputIndex, { finalScriptWitness });
        this.data.clearFinalizedInput(inputIndex);
        // deleting only BitGo proprietary key values.
        this.deleteProprietaryKeyVals(inputIndex, { identifier: PsbtUtil_1.PSBT_PROPRIETARY_IDENTIFIER });
        return this;
    }
    finalizeTapInputWithSingleLeafScriptAndSignature(inputIndex) {
        var _a, _b;
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if (((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) !== 1) {
            throw new Error('Only one leaf script supported for finalizing');
        }
        if (((_b = input.tapScriptSig) === null || _b === void 0 ? void 0 : _b.length) !== 1) {
            throw new Error('Could not find signatures in Script Sig.');
        }
        const { controlBlock, script } = input.tapLeafScript[0];
        const witness = [input.tapScriptSig[0].signature, script, controlBlock];
        const witnessLength = witness.reduce((s, b) => s + b.length + bufferutils_1.varuint.encodingLength(b.length), 1);
        const bufferWriter = bufferutils_1.BufferWriter.withCapacity(witnessLength);
        bufferWriter.writeVector(witness);
        const finalScriptWitness = bufferWriter.end();
        this.data.updateInput(inputIndex, { finalScriptWitness });
        this.data.clearFinalizedInput(inputIndex);
        return this;
    }
    /**
     * Mostly copied from bitcoinjs-lib/ts_src/psbt.ts
     *
     * Unlike the function it overrides, this does not take a validator. In BitGo
     * context, we know how we want to validate so we just hard code the right
     * validator.
     */
    validateSignaturesOfAllInputs() {
        (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one
        const results = this.data.inputs.map((input, idx) => {
            return this.validateSignaturesOfInputCommon(idx);
        });
        return results.reduce((final, res) => res && final, true);
    }
    /**
     * @returns true iff any matching valid signature is found for a derived pub key from given HD key pair.
     */
    validateSignaturesOfInputHD(inputIndex, hdKeyPair) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        const pubKey = UtxoPsbt.deriveKeyPairForInput(hdKeyPair, input);
        if (!pubKey) {
            throw new Error('can not derive from HD key pair');
        }
        return this.validateSignaturesOfInputCommon(inputIndex, pubKey);
    }
    /**
     * @returns true iff any valid signature(s) are found from bip32 data of PSBT or for given pub key.
     */
    validateSignaturesOfInputCommon(inputIndex, pubkey) {
        try {
            if (this.isTaprootScriptPathInput(inputIndex)) {
                return this.validateTaprootSignaturesOfInput(inputIndex, pubkey);
            }
            else if (this.isTaprootKeyPathInput(inputIndex)) {
                return this.validateTaprootMusig2SignaturesOfInput(inputIndex, pubkey);
            }
            return this.validateSignaturesOfInput(inputIndex, (p, m, s) => __1.ecc.verify(m, p, s, true), pubkey);
        }
        catch (err) {
            // Not an elegant solution. Might need upstream changes like custom error types.
            if (err.message === 'No signatures for this pubkey') {
                return false;
            }
            throw err;
        }
    }
    getMusig2SessionKey(inputIndex, sigHashType) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if (!input.tapInternalKey || !input.tapMerkleRoot) {
            throw new Error('both tapInternalKey and tapMerkleRoot are required');
        }
        const participants = this.getMusig2Participants(inputIndex, input.tapInternalKey, input.tapMerkleRoot);
        const nonces = this.getMusig2Nonces(inputIndex, participants);
        const { hash } = this.getTaprootHashForSig(inputIndex, [sigHashType]);
        const sessionKey = (0, Musig2_1.createMusig2SigningSession)({
            pubNonces: [nonces[0].pubNonce, nonces[1].pubNonce],
            pubKeys: participants.participantPubKeys,
            txHash: hash,
            internalPubKey: input.tapInternalKey,
            tapTreeRoot: input.tapMerkleRoot,
        });
        return { participants, nonces, hash, sessionKey };
    }
    /**
     * @returns true for following cases.
     * If valid musig2 partial signatures exists for both 2 keys, it will also verify aggregated sig
     * for aggregated tweaked key (output key), otherwise only verifies partial sig.
     * If pubkey is passed in input, it will check sig only for that pubkey,
     * if no sig exits for such key, throws error.
     * For invalid state of input data, it will throw errors.
     */
    validateTaprootMusig2SignaturesOfInput(inputIndex, pubkey) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        const partialSigs = (0, Musig2_1.parsePsbtMusig2PartialSigs)(input);
        if (!partialSigs) {
            throw new Error(`No signatures to validate`);
        }
        let myPartialSigs = partialSigs;
        if (pubkey) {
            myPartialSigs = partialSigs.filter((kv) => equalPublicKeyIgnoreY(kv.participantPubKey, pubkey));
            if ((myPartialSigs === null || myPartialSigs === void 0 ? void 0 : myPartialSigs.length) < 1) {
                throw new Error('No signatures for this pubkey');
            }
        }
        const { partialSigs: mySigs, sigHashType } = (0, Musig2_1.getSigHashTypeFromSigs)(myPartialSigs);
        const { participants, nonces, hash, sessionKey } = this.getMusig2SessionKey(inputIndex, sigHashType);
        const results = mySigs.map((mySig) => {
            const myNonce = nonces.find((kv) => equalPublicKeyIgnoreY(kv.participantPubKey, mySig.participantPubKey));
            if (!myNonce) {
                throw new Error('Found no pub nonce for pubkey');
            }
            return (0, Musig2_1.musig2PartialSigVerify)(mySig.partialSig, mySig.participantPubKey, myNonce.pubNonce, sessionKey);
        });
        // For valid single sig or 1 or 2 failure sigs, no need to validate aggregated sig. So skip.
        const result = results.every((res) => res);
        if (!result || mySigs.length < 2) {
            return result;
        }
        const aggSig = (0, Musig2_1.musig2AggregateSigs)(mySigs.map((mySig) => mySig.partialSig), sessionKey);
        return __1.ecc.verifySchnorr(hash, participants.tapOutputKey, aggSig);
    }
    validateTaprootSignaturesOfInput(inputIndex, pubkey) {
        var _a, _b;
        const input = this.data.inputs[inputIndex];
        const tapSigs = (input || {}).tapScriptSig;
        if (!input || !tapSigs || tapSigs.length < 1) {
            throw new Error('No signatures to validate');
        }
        let mySigs;
        if (pubkey) {
            mySigs = tapSigs.filter((sig) => equalPublicKeyIgnoreY(sig.pubkey, pubkey));
            if (mySigs.length < 1) {
                throw new Error('No signatures for this pubkey');
            }
        }
        else {
            mySigs = tapSigs;
        }
        const results = [];
        assert(((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) === 1, `single tapLeafScript is expected. Got ${(_b = input.tapLeafScript) === null || _b === void 0 ? void 0 : _b.length}`);
        const [tapLeafScript] = input.tapLeafScript;
        const pubKeys = this.isMultisigTaprootScript(tapLeafScript.script)
            ? (0, parseInput_1.parsePubScript2Of3)(tapLeafScript.script, 'taprootScriptPathSpend').publicKeys
            : undefined;
        for (const pSig of mySigs) {
            const { signature, leafHash, pubkey } = pSig;
            if (pubKeys) {
                assert(pubKeys.find((pk) => pubkey.equals(pk)), 'public key not found in tap leaf script');
            }
            let sigHashType;
            let sig;
            if (signature.length === 65) {
                sigHashType = signature[64];
                sig = signature.slice(0, 64);
            }
            else {
                sigHashType = __1.Transaction.SIGHASH_DEFAULT;
                sig = signature;
            }
            const { hash } = this.getTaprootHashForSig(inputIndex, [sigHashType], leafHash);
            results.push(__1.ecc.verifySchnorr(hash, pubkey, sig));
        }
        return results.every((res) => res);
    }
    /**
     * @param inputIndex
     * @param rootNodes optional input root bip32 nodes to verify with. If it is not provided, globalXpub will be used.
     * @return array of boolean values. True when corresponding index in `publicKeys` has signed the transaction.
     * If no signature in the tx or no public key matching signature, the validation is considered as false.
     */
    getSignatureValidationArray(inputIndex, { rootNodes } = {}) {
        var _a, _b;
        if (!rootNodes && (!((_a = this.data.globalMap.globalXpub) === null || _a === void 0 ? void 0 : _a.length) || !(0, types_1.isTriple)(this.data.globalMap.globalXpub))) {
            throw new Error('Cannot get signature validation array without 3 global xpubs');
        }
        const bip32s = rootNodes
            ? rootNodes
            : (_b = this.data.globalMap.globalXpub) === null || _b === void 0 ? void 0 : _b.map((xpub) => (0, bip32_1.BIP32Factory)(__1.ecc).fromBase58(bs58check.encode(xpub.extendedPubkey)));
        if (!bip32s) {
            throw new Error('either globalMap or rootNodes is required');
        }
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if (!(0, PsbtUtil_1.getPsbtInputSignatureCount)(input)) {
            return [false, false, false];
        }
        return bip32s.map((bip32) => {
            const pubKey = UtxoPsbt.deriveKeyPairForInput(bip32, input);
            if (!pubKey) {
                return false;
            }
            try {
                return this.validateSignaturesOfInputCommon(inputIndex, pubKey);
            }
            catch (err) {
                // Not an elegant solution. Might need upstream changes like custom error types.
                if (err.message === 'No signatures for this pubkey') {
                    return false;
                }
                throw err;
            }
        });
    }
    /**
     * Mostly copied from bitcoinjs-lib/ts_src/psbt.ts
     */
    signAllInputsHD(hdKeyPair, params) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            throw new Error('Need HDSigner to sign input');
        }
        const { sighashTypes, deterministic } = toSignatureParams(this.network, params);
        const results = [];
        for (let i = 0; i < this.data.inputs.length; i++) {
            try {
                this.signInputHD(i, hdKeyPair, { sighashTypes, deterministic });
                results.push(true);
            }
            catch (err) {
                results.push(false);
            }
        }
        if (results.every((v) => !v)) {
            throw new Error('No inputs were signed');
        }
        return this;
    }
    /**
     * Mostly copied from bitcoinjs-lib/ts_src/psbt.ts:signInputHD
     */
    signTaprootInputHD(inputIndex, hdKeyPair, { sighashTypes = [__1.Transaction.SIGHASH_DEFAULT, __1.Transaction.SIGHASH_ALL], deterministic = false } = {}) {
        var _a, _b;
        if (!this.isTaprootInput(inputIndex)) {
            throw new Error('not a taproot input');
        }
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            throw new Error('Need HDSigner to sign input');
        }
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if (!input.tapBip32Derivation || input.tapBip32Derivation.length === 0) {
            throw new Error('Need tapBip32Derivation to sign Taproot with HD');
        }
        const myDerivations = input.tapBip32Derivation
            .map((bipDv) => {
            if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
                return bipDv;
            }
        })
            .filter((v) => !!v);
        if (myDerivations.length === 0) {
            throw new Error('Need one tapBip32Derivation masterFingerprint to match the HDSigner fingerprint');
        }
        function getDerivedNode(bipDv) {
            const node = hdKeyPair.derivePath(bipDv.path);
            if (!equalPublicKeyIgnoreY(bipDv.pubkey, node.publicKey)) {
                throw new Error('pubkey did not match tapBip32Derivation');
            }
            return node;
        }
        if ((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) {
            const signers = myDerivations.map((bipDv) => {
                const signer = getDerivedNode(bipDv);
                if (!('signSchnorr' in signer)) {
                    throw new Error('signSchnorr function is required to sign p2tr');
                }
                return { signer, leafHashes: bipDv.leafHashes };
            });
            signers.forEach(({ signer, leafHashes }) => this.signTaprootInput(inputIndex, signer, leafHashes, sighashTypes));
        }
        else if ((_b = input.tapInternalKey) === null || _b === void 0 ? void 0 : _b.length) {
            const signers = myDerivations.map((bipDv) => {
                const signer = getDerivedNode(bipDv);
                if (!('privateKey' in signer) || !signer.privateKey) {
                    throw new Error('privateKey is required to sign p2tr musig2');
                }
                return signer;
            });
            signers.forEach((signer) => this.signTaprootMusig2Input(inputIndex, signer, { sighashTypes, deterministic }));
        }
        return this;
    }
    signInput(inputIndex, keyPair, sighashTypes) {
        const { sighashTypes: sighashForNetwork } = toSignatureParams(this.network, sighashTypes);
        return super.signInput(inputIndex, keyPair, sighashForNetwork);
    }
    signInputHD(inputIndex, hdKeyPair, params) {
        const { sighashTypes, deterministic } = toSignatureParams(this.network, params);
        if (this.isTaprootInput(inputIndex)) {
            return this.signTaprootInputHD(inputIndex, hdKeyPair, { sighashTypes, deterministic });
        }
        else {
            return super.signInputHD(inputIndex, hdKeyPair, sighashTypes);
        }
    }
    getMusig2Participants(inputIndex, tapInternalKey, tapMerkleRoot) {
        const participantsKeyValData = (0, Musig2_1.parsePsbtMusig2Participants)(this.data.inputs[inputIndex]);
        if (!participantsKeyValData) {
            throw new Error(`Found 0 matching participant key value instead of 1`);
        }
        (0, Musig2_1.assertPsbtMusig2Participants)(participantsKeyValData, tapInternalKey, tapMerkleRoot);
        return participantsKeyValData;
    }
    getMusig2Nonces(inputIndex, participantsKeyValData) {
        const noncesKeyValsData = (0, Musig2_1.parsePsbtMusig2Nonces)(this.data.inputs[inputIndex]);
        if (!noncesKeyValsData || !(0, types_1.isTuple)(noncesKeyValsData)) {
            throw new Error(`Found ${(noncesKeyValsData === null || noncesKeyValsData === void 0 ? void 0 : noncesKeyValsData.length) ? noncesKeyValsData.length : 0} matching nonce key value instead of 2`);
        }
        (0, Musig2_1.assertPsbtMusig2Nonces)(noncesKeyValsData, participantsKeyValData);
        return noncesKeyValsData;
    }
    /**
     * Signs p2tr musig2 key path input with 2 aggregated keys.
     *
     * Note: Only can sign deterministically as the cosigner
     * @param inputIndex
     * @param signer - XY public key and private key are required
     * @param sighashTypes
     * @param deterministic If true, sign the musig input deterministically
     */
    signTaprootMusig2Input(inputIndex, signer, { sighashTypes = [__1.Transaction.SIGHASH_DEFAULT, __1.Transaction.SIGHASH_ALL], deterministic = false } = {}) {
        if (!this.isTaprootKeyPathInput(inputIndex)) {
            throw new Error('not a taproot musig2 input');
        }
        const input = this.data.inputs[inputIndex];
        if (!input.tapInternalKey || !input.tapMerkleRoot) {
            throw new Error('missing required input data');
        }
        // Retrieve and check that we have two participant nonces
        const participants = this.getMusig2Participants(inputIndex, input.tapInternalKey, input.tapMerkleRoot);
        const { tapOutputKey, participantPubKeys } = participants;
        const signerPubKey = participantPubKeys.find((pubKey) => equalPublicKeyIgnoreY(pubKey, signer.publicKey));
        if (!signerPubKey) {
            throw new Error('signer pub key should match one of participant pub keys');
        }
        const nonces = this.getMusig2Nonces(inputIndex, participants);
        const { hash, sighashType } = this.getTaprootHashForSig(inputIndex, sighashTypes);
        let partialSig;
        if (deterministic) {
            if (!equalPublicKeyIgnoreY(signerPubKey, participantPubKeys[1])) {
                throw new Error('can only add a deterministic signature on the cosigner');
            }
            const firstSignerNonce = nonces.find((n) => equalPublicKeyIgnoreY(n.participantPubKey, participantPubKeys[0]));
            if (!firstSignerNonce) {
                throw new Error('could not find the user nonce');
            }
            partialSig = (0, Musig2_1.musig2DeterministicSign)({
                privateKey: signer.privateKey,
                otherNonce: firstSignerNonce.pubNonce,
                publicKeys: participantPubKeys,
                internalPubKey: input.tapInternalKey,
                tapTreeRoot: input.tapMerkleRoot,
                hash,
            }).sig;
        }
        else {
            const sessionKey = (0, Musig2_1.createMusig2SigningSession)({
                pubNonces: [nonces[0].pubNonce, nonces[1].pubNonce],
                pubKeys: participantPubKeys,
                txHash: hash,
                internalPubKey: input.tapInternalKey,
                tapTreeRoot: input.tapMerkleRoot,
            });
            const signerNonce = nonces.find((kv) => equalPublicKeyIgnoreY(kv.participantPubKey, signerPubKey));
            if (!signerNonce) {
                throw new Error('pubNonce is missing. retry signing process');
            }
            partialSig = (0, Musig2_1.musig2PartialSign)(signer.privateKey, signerNonce.pubNonce, sessionKey, this.nonceStore);
        }
        if (sighashType !== __1.Transaction.SIGHASH_DEFAULT) {
            partialSig = Buffer.concat([partialSig, Buffer.of(sighashType)]);
        }
        const sig = (0, Musig2_1.encodePsbtMusig2PartialSig)({
            participantPubKey: signerPubKey,
            tapOutputKey,
            partialSig: partialSig,
        });
        this.addProprietaryKeyValToInput(inputIndex, sig);
        return this;
    }
    signTaprootInput(inputIndex, signer, leafHashes, sighashTypes = [__1.Transaction.SIGHASH_DEFAULT, __1.Transaction.SIGHASH_ALL]) {
        var _a;
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        // Figure out if this is script path or not, if not, tweak the private key
        if (!((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length)) {
            throw new Error('tapLeafScript is required for p2tr script path');
        }
        const pubkey = (0, outputScripts_1.toXOnlyPublicKey)(signer.publicKey);
        if (input.tapLeafScript.length !== 1) {
            throw new Error('Only one leaf script supported for signing');
        }
        const [tapLeafScript] = input.tapLeafScript;
        if (this.isMultisigTaprootScript(tapLeafScript.script)) {
            const pubKeys = (0, parseInput_1.parsePubScript2Of3)(tapLeafScript.script, 'taprootScriptPathSpend').publicKeys;
            assert(pubKeys.find((pk) => pubkey.equals(pk)), 'public key not found in tap leaf script');
        }
        const parsedControlBlock = __1.taproot.parseControlBlock(__1.ecc, tapLeafScript.controlBlock);
        const { leafVersion } = parsedControlBlock;
        if (leafVersion !== tapLeafScript.leafVersion) {
            throw new Error('Tap script leaf version mismatch with control block');
        }
        const leafHash = __1.taproot.getTapleafHash(__1.ecc, parsedControlBlock, tapLeafScript.script);
        if (!leafHashes.find((l) => l.equals(leafHash))) {
            throw new Error(`Signer cannot sign for leaf hash ${leafHash.toString('hex')}`);
        }
        const { hash, sighashType } = this.getTaprootHashForSig(inputIndex, sighashTypes, leafHash);
        let signature = signer.signSchnorr(hash);
        if (sighashType !== __1.Transaction.SIGHASH_DEFAULT) {
            signature = Buffer.concat([signature, Buffer.of(sighashType)]);
        }
        this.data.updateInput(inputIndex, {
            tapScriptSig: [
                {
                    pubkey,
                    signature,
                    leafHash,
                },
            ],
        });
        return this;
    }
    getTaprootOutputScript(inputIndex) {
        var _a;
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((_a = input.tapLeafScript) === null || _a === void 0 ? void 0 : _a.length) {
            return __1.taproot.createTaprootOutputScript({
                controlBlock: input.tapLeafScript[0].controlBlock,
                leafScript: input.tapLeafScript[0].script,
            });
        }
        else if (input.tapInternalKey && input.tapMerkleRoot) {
            return __1.taproot.createTaprootOutputScript({
                internalPubKey: input.tapInternalKey,
                taptreeRoot: input.tapMerkleRoot,
            });
        }
        throw new Error('not a taproot input');
    }
    getTaprootHashForSig(inputIndex, sighashTypes, leafHash) {
        if (!this.isTaprootInput(inputIndex)) {
            throw new Error('not a taproot input');
        }
        const sighashType = this.data.inputs[inputIndex].sighashType || __1.Transaction.SIGHASH_DEFAULT;
        if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
            throw new Error(`Sighash type is not allowed. Retry the sign method passing the ` +
                `sighashTypes array of whitelisted types. Sighash type: ${sighashType}`);
        }
        const txInputs = this.txInputs; // These are somewhat costly to extract
        const prevoutScripts = [];
        const prevoutValues = [];
        this.data.inputs.forEach((input, i) => {
            let prevout;
            if (input.nonWitnessUtxo) {
                // TODO: This could be costly, either cache it here, or find a way to share with super
                const nonWitnessUtxoTx = this.constructor.transactionFromBuffer(input.nonWitnessUtxo, this.tx.network);
                const prevoutHash = txInputs[i].hash;
                const utxoHash = nonWitnessUtxoTx.getHash();
                // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout
                if (!prevoutHash.equals(utxoHash)) {
                    throw new Error(`Non-witness UTXO hash for input #${i} doesn't match the hash specified in the prevout`);
                }
                const prevoutIndex = txInputs[i].index;
                prevout = nonWitnessUtxoTx.outs[prevoutIndex];
            }
            else if (input.witnessUtxo) {
                prevout = input.witnessUtxo;
            }
            else {
                throw new Error('Need a Utxo input item for signing');
            }
            prevoutScripts.push(prevout.script);
            prevoutValues.push(prevout.value);
        });
        const outputScript = this.getTaprootOutputScript(inputIndex);
        if (!outputScript.equals(prevoutScripts[inputIndex])) {
            throw new Error(`Witness script for input #${inputIndex} doesn't match the scriptPubKey in the prevout`);
        }
        const hash = this.tx.hashForWitnessV1(inputIndex, prevoutScripts, prevoutValues, sighashType, leafHash);
        return { hash, sighashType };
    }
    /**
     * Adds proprietary key value pair to PSBT input.
     * Default identifierEncoding is utf-8 for identifier.
     */
    addProprietaryKeyValToInput(inputIndex, keyValueData) {
        return this.addUnknownKeyValToInput(inputIndex, {
            key: (0, proprietaryKeyVal_1.encodeProprietaryKey)(keyValueData.key),
            value: keyValueData.value,
        });
    }
    /**
     * Adds or updates (if exists) proprietary key value pair to PSBT input.
     * Default identifierEncoding is utf-8 for identifier.
     */
    addOrUpdateProprietaryKeyValToInput(inputIndex, keyValueData) {
        var _a;
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        const key = (0, proprietaryKeyVal_1.encodeProprietaryKey)(keyValueData.key);
        const { value } = keyValueData;
        if ((_a = input.unknownKeyVals) === null || _a === void 0 ? void 0 : _a.length) {
            const ukvIndex = input.unknownKeyVals.findIndex((ukv) => ukv.key.equals(key));
            if (ukvIndex > -1) {
                input.unknownKeyVals[ukvIndex] = { key, value };
                return this;
            }
        }
        this.addUnknownKeyValToInput(inputIndex, {
            key,
            value,
        });
        return this;
    }
    /**
     * To search any data from proprietary key value against keydata.
     * Default identifierEncoding is utf-8 for identifier.
     */
    getProprietaryKeyVals(inputIndex, keySearch) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        return (0, PsbtUtil_1.getPsbtInputProprietaryKeyVals)(input, keySearch);
    }
    /**
     * To delete any data from proprietary key value.
     * Default identifierEncoding is utf-8 for identifier.
     */
    deleteProprietaryKeyVals(inputIndex, keysToDelete) {
        var _a;
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if (!((_a = input.unknownKeyVals) === null || _a === void 0 ? void 0 : _a.length)) {
            return this;
        }
        if (keysToDelete && keysToDelete.subtype === undefined && Buffer.isBuffer(keysToDelete.keydata)) {
            throw new Error('invalid proprietary key search filter combination. subtype is required');
        }
        input.unknownKeyVals = input.unknownKeyVals.filter((keyValue, i) => {
            const key = (0, proprietaryKeyVal_1.decodeProprietaryKey)(keyValue.key);
            return !(keysToDelete === undefined ||
                (keysToDelete.identifier === key.identifier &&
                    (keysToDelete.subtype === undefined ||
                        (keysToDelete.subtype === key.subtype &&
                            (!Buffer.isBuffer(keysToDelete.keydata) || keysToDelete.keydata.equals(key.keydata))))));
        });
        return this;
    }
    createMusig2NonceForInput(inputIndex, keyPair, keyType, params = { deterministic: false }) {
        const input = this.data.inputs[inputIndex];
        if (!input.tapInternalKey) {
            throw new Error('tapInternalKey is required to create nonce');
        }
        if (!input.tapMerkleRoot) {
            throw new Error('tapMerkleRoot is required to create nonce');
        }
        const getDerivedKeyPair = () => {
            var _a;
            if (!((_a = input.tapBip32Derivation) === null || _a === void 0 ? void 0 : _a.length)) {
                throw new Error('tapBip32Derivation is required to create nonce');
            }
            const derived = UtxoPsbt.deriveKeyPair(keyPair, input.tapBip32Derivation, { ignoreY: true });
            if (!derived) {
                throw new Error('No bip32Derivation masterFingerprint matched the HD keyPair fingerprint');
            }
            return derived;
        };
        const derivedKeyPair = keyType === 'root' ? getDerivedKeyPair() : keyPair;
        if (!derivedKeyPair.privateKey) {
            throw new Error('privateKey is required to create nonce');
        }
        const participants = (0, Musig2_1.parsePsbtMusig2Participants)(input);
        if (!participants) {
            throw new Error(`Found 0 matching participant key value instead of 1`);
        }
        (0, Musig2_1.assertPsbtMusig2Participants)(participants, input.tapInternalKey, input.tapMerkleRoot);
        const { tapOutputKey, participantPubKeys } = participants;
        const participantPubKey = participantPubKeys.find((pubKey) => equalPublicKeyIgnoreY(pubKey, derivedKeyPair.publicKey));
        if (!Buffer.isBuffer(participantPubKey)) {
            throw new Error('participant plain pub key should match one bip32Derivation plain pub key');
        }
        const { hash } = this.getTaprootHashForSig(inputIndex);
        let pubNonce;
        if (params.deterministic) {
            if (params.sessionId) {
                throw new Error('Cannot add extra entropy when generating a deterministic nonce');
            }
            // There must be only 2 participant pubKeys if it got to this point
            if (!equalPublicKeyIgnoreY(participantPubKey, participantPubKeys[1])) {
                throw new Error(`Only the cosigner's nonce can be set deterministically`);
            }
            const nonces = (0, Musig2_1.parsePsbtMusig2Nonces)(input);
            if (!nonces) {
                throw new Error(`No nonces found on input #${inputIndex}`);
            }
            if (nonces.length > 2) {
                throw new Error(`Cannot have more than 2 nonces`);
            }
            const firstSignerNonce = nonces.find((kv) => equalPublicKeyIgnoreY(kv.participantPubKey, participantPubKeys[0]));
            if (!firstSignerNonce) {
                throw new Error('signer nonce must be set if cosigner nonce is to be derived deterministically');
            }
            pubNonce = (0, Musig2_1.createMusig2DeterministicNonce)({
                privateKey: derivedKeyPair.privateKey,
                otherNonce: firstSignerNonce.pubNonce,
                publicKeys: participantPubKeys,
                internalPubKey: input.tapInternalKey,
                tapTreeRoot: input.tapMerkleRoot,
                hash,
            });
        }
        else {
            pubNonce = Buffer.from(this.nonceStore.createMusig2Nonce(derivedKeyPair.privateKey, participantPubKey, tapOutputKey, hash, params.sessionId));
        }
        return { tapOutputKey, participantPubKey, pubNonce };
    }
    setMusig2NoncesInner(keyPair, keyType, inputIndex, params = { deterministic: false }) {
        if (keyPair.isNeutered()) {
            throw new Error('private key is required to generate nonce');
        }
        if (Buffer.isBuffer(params.sessionId) && params.sessionId.length !== 32) {
            throw new Error(`Invalid sessionId size ${params.sessionId.length}`);
        }
        const inputIndexes = inputIndex === undefined ? [...Array(this.inputCount).keys()] : [inputIndex];
        inputIndexes.forEach((index) => {
            if (!this.isTaprootKeyPathInput(index)) {
                return;
            }
            const nonce = this.createMusig2NonceForInput(index, keyPair, keyType, params);
            this.addOrUpdateProprietaryKeyValToInput(index, (0, Musig2_1.encodePsbtMusig2PubNonce)(nonce));
        });
        return this;
    }
    /**
     * Generates and sets MuSig2 nonce to taproot key path input at inputIndex.
     * If input is not a taproot key path, no action.
     *
     * @param inputIndex input index
     * @param keyPair derived key pair
     * @param sessionId Optional extra entropy. If provided it must either be a counter unique to this secret key,
     * (converted to an array of 32 bytes), or 32 uniformly random bytes.
     * @param deterministic If true, set the cosigner nonce deterministically
     */
    setInputMusig2Nonce(inputIndex, derivedKeyPair, params = { deterministic: false }) {
        return this.setMusig2NoncesInner(derivedKeyPair, 'derived', inputIndex, params);
    }
    /**
     * Generates and sets MuSig2 nonce to taproot key path input at inputIndex.
     * If input is not a taproot key path, no action.
     *
     * @param inputIndex input index
     * @param keyPair HD root key pair
     * @param sessionId Optional extra entropy. If provided it must either be a counter unique to this secret key,
     * (converted to an array of 32 bytes), or 32 uniformly random bytes.
     * @param deterministic If true, set the cosigner nonce deterministically
     */
    setInputMusig2NonceHD(inputIndex, keyPair, params = { deterministic: false }) {
        (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        return this.setMusig2NoncesInner(keyPair, 'root', inputIndex, params);
    }
    /**
     * Generates and sets MuSig2 nonce to all taproot key path inputs. Other inputs will be skipped.
     *
     * @param inputIndex input index
     * @param keyPair derived key pair
     * @param sessionId Optional extra entropy. If provided it must either be a counter unique to this secret key,
     * (converted to an array of 32 bytes), or 32 uniformly random bytes.
     */
    setAllInputsMusig2Nonce(keyPair, params = { deterministic: false }) {
        return this.setMusig2NoncesInner(keyPair, 'derived', undefined, params);
    }
    /**
     * Generates and sets MuSig2 nonce to all taproot key path inputs. Other inputs will be skipped.
     *
     * @param inputIndex input index
     * @param keyPair HD root key pair
     * @param sessionId Optional extra entropy. If provided it must either be a counter unique to this secret key,
     * (converted to an array of 32 bytes), or 32 uniformly random bytes.
     */
    setAllInputsMusig2NonceHD(keyPair, params = { deterministic: false }) {
        return this.setMusig2NoncesInner(keyPair, 'root', undefined, params);
    }
    clone() {
        return super.clone();
    }
    extractTransaction(disableFeeCheck = true) {
        const tx = super.extractTransaction(disableFeeCheck);
        if (tx instanceof UtxoTransaction_1.UtxoTransaction) {
            return tx;
        }
        throw new Error('extractTransaction did not return instace of UtxoTransaction');
    }
}
exports.UtxoPsbt = UtxoPsbt;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVXR4b1BzYnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYml0Z28vVXR4b1BzYnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsaUNBQWlDO0FBQ2pDLG1DQUEwQztBQVExQyxnREFBcUQ7QUFDckQsK0RBQXNFO0FBRXRFLGlDQUFxRDtBQUNyRCx1Q0FBdUM7QUFDdkMsd0VBQThGO0FBRTlGLDBCQVlZO0FBQ1osdURBQW9EO0FBQ3BELHVDQUFnRDtBQUNoRCxvREFBOEM7QUFDOUMsMERBQStDO0FBQy9DLG1EQUFtRDtBQUNuRCw2Q0FBa0Q7QUFDbEQscUNBa0JrQjtBQUNsQixtQ0FBMkQ7QUFDM0Qsd0NBQWlEO0FBQ2pELHlDQU9vQjtBQVlwQixTQUFTLG1CQUFtQjtJQUMxQixPQUFPLENBQUMsZUFBVyxDQUFDLGVBQWUsRUFBRSxlQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDaEUsQ0FBQztBQUVELFNBQVMsNEJBQTRCLENBQUMsT0FBZ0IsRUFBRSxZQUFzQjtJQUM1RSxRQUFRLElBQUEsY0FBVSxFQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQzNCLEtBQUssWUFBUSxDQUFDLFdBQVcsQ0FBQztRQUMxQixLQUFLLFlBQVEsQ0FBQyxTQUFTLENBQUM7UUFDeEIsS0FBSyxZQUFRLENBQUMsV0FBVyxDQUFDO1FBQzFCLEtBQUssWUFBUSxDQUFDLEtBQUs7WUFDakIsT0FBTyxDQUFDLEdBQUcsWUFBWSxFQUFFLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLGlDQUFlLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztRQUMzRjtZQUNFLE9BQU8sWUFBWSxDQUFDO0tBQ3ZCO0FBQ0gsQ0FBQztBQUVELFNBQVMsaUJBQWlCLENBQUMsT0FBZ0IsRUFBRSxDQUF1QztJQUNsRixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQUUsT0FBTyxpQkFB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O0lBQ2xGLENBQUM7Q0FDRjtBQWxwQ0QsNEJBa3BDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHsgUHNidCBhcyBQc2J0QmFzZSB9IGZyb20gJ2JpcDE3NCc7XG5pbXBvcnQge1xuICBCaXAzMkRlcml2YXRpb24sXG4gIFBzYnRJbnB1dCxcbiAgVGFwQmlwMzJEZXJpdmF0aW9uLFxuICBUcmFuc2FjdGlvbiBhcyBJVHJhbnNhY3Rpb24sXG4gIFRyYW5zYWN0aW9uRnJvbUJ1ZmZlcixcbn0gZnJvbSAnYmlwMTc0L3NyYy9saWIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBjaGVja0ZvcklucHV0IH0gZnJvbSAnYmlwMTc0L3NyYy9saWIvdXRpbHMnO1xuaW1wb3J0IHsgQnVmZmVyV3JpdGVyLCB2YXJ1aW50IH0gZnJvbSAnYml0Y29pbmpzLWxpYi9zcmMvYnVmZmVydXRpbHMnO1xuaW1wb3J0IHsgU2Vzc2lvbktleSB9IGZyb20gJ0BicmFuZG9uYmxhY2svbXVzaWcnO1xuaW1wb3J0IHsgQklQMzJGYWN0b3J5LCBCSVAzMkludGVyZmFjZSB9IGZyb20gJ2JpcDMyJztcbmltcG9ydCAqIGFzIGJzNThjaGVjayBmcm9tICdiczU4Y2hlY2snO1xuaW1wb3J0IHsgZGVjb2RlUHJvcHJpZXRhcnlLZXksIGVuY29kZVByb3ByaWV0YXJ5S2V5IH0gZnJvbSAnYmlwMTc0L3NyYy9saWIvcHJvcHJpZXRhcnlLZXlWYWwnO1xuXG5pbXBvcnQge1xuICB0YXByb290LFxuICBIRFNpZ25lcixcbiAgU2lnbmVyLFxuICBQc2J0LFxuICBQc2J0VHJhbnNhY3Rpb24sXG4gIFRyYW5zYWN0aW9uLFxuICBUeE91dHB1dCxcbiAgTmV0d29yayxcbiAgZWNjIGFzIGVjY0xpYixcbiAgZ2V0TWFpbm5ldCxcbiAgbmV0d29ya3MsXG59IGZyb20gJy4uJztcbmltcG9ydCB7IFV0eG9UcmFuc2FjdGlvbiB9IGZyb20gJy4vVXR4b1RyYW5zYWN0aW9uJztcbmltcG9ydCB7IGdldE91dHB1dElkRm9ySW5wdXQgfSBmcm9tICcuL1Vuc3BlbnQnO1xuaW1wb3J0IHsgaXNTZWd3aXQgfSBmcm9tICcuL3BzYnQvc2NyaXB0VHlwZXMnO1xuaW1wb3J0IHsgdW5zaWduIH0gZnJvbSAnLi9wc2J0L2Zyb21IYWxmU2lnbmVkJztcbmltcG9ydCB7IHRvWE9ubHlQdWJsaWNLZXkgfSBmcm9tICcuL291dHB1dFNjcmlwdHMnO1xuaW1wb3J0IHsgcGFyc2VQdWJTY3JpcHQyT2YzIH0gZnJvbSAnLi9wYXJzZUlucHV0JztcbmltcG9ydCB7XG4gIGNyZWF0ZU11c2lnMlNpZ25pbmdTZXNzaW9uLFxuICBlbmNvZGVQc2J0TXVzaWcyUGFydGlhbFNpZyxcbiAgZW5jb2RlUHNidE11c2lnMlB1Yk5vbmNlLFxuICBtdXNpZzJQYXJ0aWFsU2lnbixcbiAgcGFyc2VQc2J0TXVzaWcyTm9uY2VzLFxuICBwYXJzZVBzYnRNdXNpZzJQYXJ0aWNpcGFudHMsXG4gIFBzYnRNdXNpZzJQYXJ0aWNpcGFudHMsXG4gIGFzc2VydFBzYnRNdXNpZzJOb25jZXMsXG4gIGFzc2VydFBzYnRNdXNpZzJQYXJ0aWNpcGFudHMsXG4gIE11c2lnMk5vbmNlU3RvcmUsXG4gIFBzYnRNdXNpZzJQdWJOb25jZSxcbiAgcGFyc2VQc2J0TXVzaWcyUGFydGlhbFNpZ3MsXG4gIG11c2lnMlBhcnRpYWxTaWdWZXJpZnksXG4gIG11c2lnMkFnZ3JlZ2F0ZVNpZ3MsXG4gIGdldFNpZ0hhc2hUeXBlRnJvbVNpZ3MsXG4gIG11c2lnMkRldGVybWluaXN0aWNTaWduLFxuICBjcmVhdGVNdXNpZzJEZXRlcm1pbmlzdGljTm9uY2UsXG59IGZyb20gJy4vTXVzaWcyJztcbmltcG9ydCB7IGlzVHJpcGxlLCBpc1R1cGxlLCBUcmlwbGUsIFR1cGxlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRUYXByb290T3V0cHV0S2V5IH0gZnJvbSAnLi4vdGFwcm9vdCc7XG5pbXBvcnQge1xuICBnZXRQc2J0SW5wdXRQcm9wcmlldGFyeUtleVZhbHMsXG4gIGdldFBzYnRJbnB1dFNpZ25hdHVyZUNvdW50LFxuICBQcm9wcmlldGFyeUtleVNlYXJjaCxcbiAgUHJvcHJpZXRhcnlLZXlTdWJ0eXBlLFxuICBQcm9wcmlldGFyeUtleVZhbHVlLFxuICBQU0JUX1BST1BSSUVUQVJZX0lERU5USUZJRVIsXG59IGZyb20gJy4vUHNidFV0aWwnO1xuXG50eXBlIFNpZ25hdHVyZVBhcmFtcyA9IHtcbiAgLyoqIFdoZW4gdHJ1ZSwgYW5kIGFkZCB0aGUgc2Vjb25kIChsYXN0KSBub25jZSBhbmQgc2lnbmF0dXJlIGZvciBhIHRhcHJvb3Qga2V5XG4gICAqIHBhdGggc3BlbmQgZGV0ZXJtaW5pc3RpY2FsbHkuIFRocm93cyBhbiBlcnJvciBpZiBkb25lIGZvciB0aGUgZmlyc3Qgbm9uY2Uvc2lnbmF0dXJlXG4gICAqIG9mIGEgdGFwcm9vdCBrZXlwYXRoIHNwZW5kLiBJZ25vcmUgZm9yIGFsbCBvdGhlciBpbnB1dCB0eXBlcy5cbiAgICovXG4gIGRldGVybWluaXN0aWM6IGJvb2xlYW47XG4gIC8qKiBBbGxvd2VkIHNpZ2hhc2ggdHlwZXMgKi9cbiAgc2lnaGFzaFR5cGVzOiBudW1iZXJbXTtcbn07XG5cbmZ1bmN0aW9uIGRlZmF1bHRTaWdoYXNoVHlwZXMoKTogbnVtYmVyW10ge1xuICByZXR1cm4gW1RyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVCwgVHJhbnNhY3Rpb24uU0lHSEFTSF9BTExdO1xufVxuXG5mdW5jdGlvbiBhZGRGb3JrSWRUb1NpZ2hhc2hlc0lmTmVlZGVkKG5ldHdvcms6IE5ldHdvcmssIHNpZ2hhc2hUeXBlczogbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gIHN3aXRjaCAoZ2V0TWFpbm5ldChuZXR3b3JrKSkge1xuICAgIGNhc2UgbmV0d29ya3MuYml0Y29pbmNhc2g6XG4gICAgY2FzZSBuZXR3b3Jrcy5iaXRjb2luc3Y6XG4gICAgY2FzZSBuZXR3b3Jrcy5iaXRjb2luZ29sZDpcbiAgICBjYXNlIG5ldHdvcmtzLmVjYXNoOlxuICAgICAgcmV0dXJuIFsuLi5zaWdoYXNoVHlwZXMsIC4uLnNpZ2hhc2hUeXBlcy5tYXAoKHMpID0+IHMgfCBVdHhvVHJhbnNhY3Rpb24uU0lHSEFTSF9GT1JLSUQpXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHNpZ2hhc2hUeXBlcztcbiAgfVxufVxuXG5mdW5jdGlvbiB0b1NpZ25hdHVyZVBhcmFtcyhuZXR3b3JrOiBOZXR3b3JrLCB2PzogUGFydGlhbDxTaWduYXR1cmVQYXJhbXM+IHwgbnVtYmVyW10pOiBTaWduYXR1cmVQYXJhbXMge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2KSkgcmV0dXJuIHRvU2lnbmF0dXJlUGFyYW1zKG5ldHdvcmssIHsgc2lnaGFzaFR5cGVzOiB2IH0pO1xuICBjb25zdCBkZWZhdWx0U2lnbmF0dXJlUGFyYW1zID0geyBkZXRlcm1pbmlzdGljOiBmYWxzZSwgc2lnaGFzaFR5cGVzOiBkZWZhdWx0U2lnaGFzaFR5cGVzKCkgfTtcbiAgY29uc3QgcmV0ID0geyAuLi5kZWZhdWx0U2lnbmF0dXJlUGFyYW1zLCAuLi52IH07XG4gIHJldC5zaWdoYXNoVHlwZXMgPSBhZGRGb3JrSWRUb1NpZ2hhc2hlc0lmTmVlZGVkKG5ldHdvcmssIHJldC5zaWdoYXNoVHlwZXMpO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEBwYXJhbSBhXG4gKiBAcGFyYW0gYlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIHB1YmxpYyBrZXlzIGFyZSBlcXVhbCBpZ25vcmluZyB0aGUgeSBjb29yZGluYXRlLlxuICovXG5mdW5jdGlvbiBlcXVhbFB1YmxpY0tleUlnbm9yZVkoYTogQnVmZmVyLCBiOiBCdWZmZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIHRvWE9ubHlQdWJsaWNLZXkoYSkuZXF1YWxzKHRvWE9ubHlQdWJsaWNLZXkoYikpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhEVGFwcm9vdFNpZ25lciBleHRlbmRzIEhEU2lnbmVyIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHN0cmluZyBtdXN0IG1hdGNoIC9ebShcXC9cXGQrJz8pKyQvXG4gICAqIGV4LiBtLzQ0Jy8wJy8wJy8xLzIzIGxldmVscyB3aXRoICcgbXVzdCBiZSBoYXJkIGRlcml2YXRpb25zXG4gICAqL1xuICBkZXJpdmVQYXRoKHBhdGg6IHN0cmluZyk6IEhEVGFwcm9vdFNpZ25lcjtcbiAgLyoqXG4gICAqIElucHV0IGhhc2ggKHRoZSBcIm1lc3NhZ2UgZGlnZXN0XCIpIGZvciB0aGUgc2lnbmF0dXJlIGFsZ29yaXRobVxuICAgKiBSZXR1cm4gYSA2NCBieXRlIHNpZ25hdHVyZSAoMzIgYnl0ZSByIGFuZCAzMiBieXRlIHMgaW4gdGhhdCBvcmRlcilcbiAgICovXG4gIHNpZ25TY2hub3JyKGhhc2g6IEJ1ZmZlcik6IEJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBIRCBzaWduZXIgb2JqZWN0IGZvciB0YXByb290IHAydHIgbXVzaWcyIGtleSBwYXRoIHNpZ25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIRFRhcHJvb3RNdXNpZzJTaWduZXIgZXh0ZW5kcyBIRFNpZ25lciB7XG4gIC8qKlxuICAgKiBNdXNpZzIgcmVxdWlyZXMgc2lnbmVyJ3MgMzItYnl0ZXMgcHJpdmF0ZSBrZXkgdG8gYmUgcGFzc2VkIHRvIGl0LlxuICAgKi9cbiAgcHJpdmF0ZUtleTogQnVmZmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgcGF0aCBzdHJpbmcgbXVzdCBtYXRjaCAvXm0oXFwvXFxkKyc/KSskL1xuICAgKiBleC4gbS80NCcvMCcvMCcvMS8yMyBsZXZlbHMgd2l0aCAnIG11c3QgYmUgaGFyZCBkZXJpdmF0aW9uc1xuICAgKi9cbiAgZGVyaXZlUGF0aChwYXRoOiBzdHJpbmcpOiBIRFRhcHJvb3RNdXNpZzJTaWduZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Nobm9yclNpZ25lciB7XG4gIHB1YmxpY0tleTogQnVmZmVyO1xuICBzaWduU2Nobm9ycihoYXNoOiBCdWZmZXIpOiBCdWZmZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTXVzaWcyU2lnbmVyIHtcbiAgcHVibGljS2V5OiBCdWZmZXI7XG4gIHByaXZhdGVLZXk6IEJ1ZmZlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYXByb290U2lnbmVyIHtcbiAgbGVhZkhhc2hlczogQnVmZmVyW107XG4gIHNpZ25lcjogU2Nobm9yclNpZ25lcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQc2J0T3B0cyB7XG4gIG5ldHdvcms6IE5ldHdvcms7XG4gIG1heGltdW1GZWVSYXRlPzogbnVtYmVyOyAvLyBbc2F0L2J5dGVdXG4gIGJpcDMyUGF0aHNBYnNvbHV0ZT86IGJvb2xlYW47XG59XG5cbi8vIFRPRE86IHVwc3RyZWFtIGRvZXMgYGNoZWNrSW5wdXRzRm9yUGFydGlhbFNpZ3NgIGJlZm9yZSBkb2luZyB0aGluZ3MgbGlrZVxuLy8gYHNldFZlcnNpb25gLiBPdXIgaW5wdXRzIGNvdWxkIGhhdmUgdGFwc2NyaXB0c2lncyAob3IgaW4gZnV0dXJlIHRhcGtleXNpZ3MpXG4vLyBhbmQgbm90IGZhaWwgdGhhdCBjaGVjay4gRG8gd2Ugd2FudCB0byBkbyBhbnl0aGluZyBhYm91dCB0aGF0P1xuZXhwb3J0IGNsYXNzIFV0eG9Qc2J0PFR4IGV4dGVuZHMgVXR4b1RyYW5zYWN0aW9uPGJpZ2ludD4gPSBVdHhvVHJhbnNhY3Rpb248YmlnaW50Pj4gZXh0ZW5kcyBQc2J0IHtcbiAgcHJpdmF0ZSBub25jZVN0b3JlID0gbmV3IE11c2lnMk5vbmNlU3RvcmUoKTtcblxuICBwcm90ZWN0ZWQgc3RhdGljIHRyYW5zYWN0aW9uRnJvbUJ1ZmZlcihidWZmZXI6IEJ1ZmZlciwgbmV0d29yazogTmV0d29yayk6IFV0eG9UcmFuc2FjdGlvbjxiaWdpbnQ+IHtcbiAgICByZXR1cm4gVXR4b1RyYW5zYWN0aW9uLmZyb21CdWZmZXI8YmlnaW50PihidWZmZXIsIGZhbHNlLCAnYmlnaW50JywgbmV0d29yayk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlUHNidChvcHRzOiBQc2J0T3B0cywgZGF0YT86IFBzYnRCYXNlKTogVXR4b1BzYnQge1xuICAgIHJldHVybiBuZXcgVXR4b1BzYnQoXG4gICAgICBvcHRzLFxuICAgICAgZGF0YSB8fCBuZXcgUHNidEJhc2UobmV3IFBzYnRUcmFuc2FjdGlvbih7IHR4OiBuZXcgVXR4b1RyYW5zYWN0aW9uPGJpZ2ludD4ob3B0cy5uZXR3b3JrKSB9KSlcbiAgICApO1xuICB9XG5cbiAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyOiBCdWZmZXIsIG9wdHM6IFBzYnRPcHRzKTogVXR4b1BzYnQge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uRnJvbUJ1ZmZlcjogVHJhbnNhY3Rpb25Gcm9tQnVmZmVyID0gKGJ1ZmZlcjogQnVmZmVyKTogSVRyYW5zYWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IHR4ID0gdGhpcy50cmFuc2FjdGlvbkZyb21CdWZmZXIoYnVmZmVyLCBvcHRzLm5ldHdvcmspO1xuICAgICAgcmV0dXJuIG5ldyBQc2J0VHJhbnNhY3Rpb24oeyB0eCB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHBzYnRCYXNlID0gUHNidEJhc2UuZnJvbUJ1ZmZlcihidWZmZXIsIHRyYW5zYWN0aW9uRnJvbUJ1ZmZlciwge1xuICAgICAgYmlwMzJQYXRoc0Fic29sdXRlOiBvcHRzLmJpcDMyUGF0aHNBYnNvbHV0ZSxcbiAgICB9KTtcbiAgICBjb25zdCBwc2J0ID0gdGhpcy5jcmVhdGVQc2J0KG9wdHMsIHBzYnRCYXNlKTtcbiAgICAvLyBVcHN0cmVhbSBjaGVja3MgZm9yIGR1cGxpY2F0ZSBpbnB1dHMgaGVyZSwgYnV0IGl0IHNlZW1zIHRvIGJlIG9mIGR1YmlvdXMgdmFsdWUuXG4gICAgcmV0dXJuIHBzYnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbUhleChkYXRhOiBzdHJpbmcsIG9wdHM6IFBzYnRPcHRzKTogVXR4b1BzYnQge1xuICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIoQnVmZmVyLmZyb20oZGF0YSwgJ2hleCcpLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gcGFyZW50IC0gUGFyZW50IGtleS4gTWF0Y2hlZCB3aXRoIGBiaXAzMkRlcml2YXRpb25zYCB1c2luZyBgZmluZ2VycHJpbnRgIHByb3BlcnR5LlxuICAgKiBAcGFyYW0gYmlwMzJEZXJpdmF0aW9ucyAtIHBvc3NpYmxlIGRlcml2YXRpb25zIGZvciBpbnB1dCBvciBvdXRwdXRcbiAgICogQHBhcmFtIGlnbm9yZVkgLSB3aGVuIHRydWUsIGlnbm9yZSB0aGUgeSBjb29yZGluYXRlIHdoZW4gbWF0Y2hpbmcgcHVibGljIGtleXNcbiAgICogQHJldHVybiBkZXJpdmVkIGJpcDMyIG5vZGUgaWYgbWF0Y2hpbmcgZGVyaXZhdGlvbiBpcyBmb3VuZCwgdW5kZWZpbmVkIGlmIG5vbmUgaXMgZm91bmRcbiAgICogQHRocm93cyBFcnJvciBpZiBtb3JlIHRoYW4gb25lIG1hdGNoIGlzIGZvdW5kXG4gICAqL1xuICBzdGF0aWMgZGVyaXZlS2V5UGFpcihcbiAgICBwYXJlbnQ6IEJJUDMySW50ZXJmYWNlLFxuICAgIGJpcDMyRGVyaXZhdGlvbnM6IEJpcDMyRGVyaXZhdGlvbltdLFxuICAgIHsgaWdub3JlWSB9OiB7IGlnbm9yZVk6IGJvb2xlYW4gfVxuICApOiBCSVAzMkludGVyZmFjZSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgbWF0Y2hpbmdEZXJpdmF0aW9ucyA9IGJpcDMyRGVyaXZhdGlvbnMuZmlsdGVyKChiaXBEdikgPT4ge1xuICAgICAgcmV0dXJuIGJpcER2Lm1hc3RlckZpbmdlcnByaW50LmVxdWFscyhwYXJlbnQuZmluZ2VycHJpbnQpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFtYXRjaGluZ0Rlcml2YXRpb25zLmxlbmd0aCkge1xuICAgICAgLy8gTm8gZmluZ2VycHJpbnQgbWF0Y2hcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoaW5nRGVyaXZhdGlvbnMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBtb3JlIHRoYW4gb25lIG1hdGNoaW5nIGRlcml2YXRpb24gZm9yIGZpbmdlcnByaW50ICR7cGFyZW50LmZpbmdlcnByaW50LnRvU3RyaW5nKCdoZXgnKX06ICR7XG4gICAgICAgICAgbWF0Y2hpbmdEZXJpdmF0aW9ucy5sZW5ndGhcbiAgICAgICAgfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgW2Rlcml2YXRpb25dID0gbWF0Y2hpbmdEZXJpdmF0aW9ucztcbiAgICBjb25zdCBub2RlID0gcGFyZW50LmRlcml2ZVBhdGgoZGVyaXZhdGlvbi5wYXRoKTtcblxuICAgIGlmICghbm9kZS5wdWJsaWNLZXkuZXF1YWxzKGRlcml2YXRpb24ucHVia2V5KSkge1xuICAgICAgaWYgKCFpZ25vcmVZIHx8ICFlcXVhbFB1YmxpY0tleUlnbm9yZVkobm9kZS5wdWJsaWNLZXksIGRlcml2YXRpb24ucHVia2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B1YmtleSBkaWQgbm90IG1hdGNoIGJpcDMyRGVyaXZhdGlvbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgc3RhdGljIGRlcml2ZUtleVBhaXJGb3JJbnB1dChiaXAzMjogQklQMzJJbnRlcmZhY2UsIGlucHV0OiBQc2J0SW5wdXQpOiBCdWZmZXIgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBpbnB1dC50YXBCaXAzMkRlcml2YXRpb24/Lmxlbmd0aFxuICAgICAgPyBVdHhvUHNidC5kZXJpdmVLZXlQYWlyKGJpcDMyLCBpbnB1dC50YXBCaXAzMkRlcml2YXRpb24sIHsgaWdub3JlWTogdHJ1ZSB9KT8ucHVibGljS2V5XG4gICAgICA6IGlucHV0LmJpcDMyRGVyaXZhdGlvbj8ubGVuZ3RoXG4gICAgICA/IFV0eG9Qc2J0LmRlcml2ZUtleVBhaXIoYmlwMzIsIGlucHV0LmJpcDMyRGVyaXZhdGlvbiwgeyBpZ25vcmVZOiBmYWxzZSB9KT8ucHVibGljS2V5XG4gICAgICA6IGJpcDMyPy5wdWJsaWNLZXk7XG4gIH1cblxuICBnZXQgbmV0d29yaygpOiBOZXR3b3JrIHtcbiAgICByZXR1cm4gdGhpcy50eC5uZXR3b3JrO1xuICB9XG5cbiAgdG9IZXgoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdCBpcyBleHBlbnNpdmUgdG8gYXR0ZW1wdCB0byBjb21wdXRlIGV2ZXJ5IG91dHB1dCBhZGRyZXNzIHVzaW5nIHBzYnQudHhPdXRwdXRzW291dHB1dEluZGV4XVxuICAgKiB0byB0aGVuIGp1c3QgZ2V0IHRoZSBzY3JpcHQuIEhlcmUsIHdlIGFyZSBkb2luZyB0aGUgc2FtZSB0aGluZyBhcyB3aGF0IHR4T3V0cHV0cygpIGRvZXMgaW5cbiAgICogYml0Y29pbmpzLWxpYiwgYnV0IHdpdGhvdXQgaXRlcmF0aW5nIG92ZXIgZWFjaCBvdXRwdXQuXG4gICAqIEBwYXJhbSBvdXRwdXRJbmRleFxuICAgKiBAcmV0dXJucyBvdXRwdXQgc2NyaXB0IGF0IHRoZSBnaXZlbiBpbmRleFxuICAgKi9cbiAgZ2V0T3V0cHV0U2NyaXB0KG91dHB1dEluZGV4OiBudW1iZXIpOiBCdWZmZXIge1xuICAgIHJldHVybiAodGhpcyBhcyBhbnkpLl9fQ0FDSEUuX19UWC5vdXRzW291dHB1dEluZGV4XS5zY3JpcHQgYXMgQnVmZmVyO1xuICB9XG5cbiAgZ2V0Tm9uV2l0bmVzc1ByZXZpb3VzVHhpZHMoKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHR4SW5wdXRzID0gdGhpcy50eElucHV0czsgLy8gVGhlc2UgYXJlIHNvbWV3aGF0IGNvc3RseSB0byBleHRyYWN0XG4gICAgY29uc3QgdHhpZFNldCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIHRoaXMuZGF0YS5pbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIWlucHV0LndpdG5lc3NVdHhvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBoYXZlIHdpdG5lc3MgVVRYTyBmb3IgYWxsIGlucHV0cycpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1NlZ3dpdChpbnB1dC53aXRuZXNzVXR4by5zY3JpcHQsIGlucHV0LnJlZGVlbVNjcmlwdCkpIHtcbiAgICAgICAgdHhpZFNldC5hZGQoZ2V0T3V0cHV0SWRGb3JJbnB1dCh0eElucHV0c1tpbmRleF0pLnR4aWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBbLi4udHhpZFNldF07XG4gIH1cblxuICBhZGROb25XaXRuZXNzVXR4b3ModHhCdWZzOiBSZWNvcmQ8c3RyaW5nLCBCdWZmZXI+KTogdGhpcyB7XG4gICAgY29uc3QgdHhJbnB1dHMgPSB0aGlzLnR4SW5wdXRzOyAvLyBUaGVzZSBhcmUgc29tZXdoYXQgY29zdGx5IHRvIGV4dHJhY3RcbiAgICB0aGlzLmRhdGEuaW5wdXRzLmZvckVhY2goKGlucHV0LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKCFpbnB1dC53aXRuZXNzVXR4bykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgaGF2ZSB3aXRuZXNzIFVUWE8gZm9yIGFsbCBpbnB1dHMnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNTZWd3aXQoaW5wdXQud2l0bmVzc1V0eG8uc2NyaXB0LCBpbnB1dC5yZWRlZW1TY3JpcHQpKSB7XG4gICAgICAgIGNvbnN0IHsgdHhpZCB9ID0gZ2V0T3V0cHV0SWRGb3JJbnB1dCh0eElucHV0c1tpbmRleF0pO1xuICAgICAgICBpZiAodHhCdWZzW3R4aWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhbGwgcmVxdWlyZWQgcHJldmlvdXMgdHJhbnNhY3Rpb25zIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVJbnB1dChpbmRleCwgeyBub25XaXRuZXNzVXR4bzogdHhCdWZzW3R4aWRdIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RhdGljIGZyb21UcmFuc2FjdGlvbih0cmFuc2FjdGlvbjogVXR4b1RyYW5zYWN0aW9uPGJpZ2ludD4sIHByZXZPdXRwdXRzOiBUeE91dHB1dDxiaWdpbnQ+W10pOiBVdHhvUHNidCB7XG4gICAgaWYgKHByZXZPdXRwdXRzLmxlbmd0aCAhPT0gdHJhbnNhY3Rpb24uaW5zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVHJhbnNhY3Rpb24gaGFzICR7dHJhbnNhY3Rpb24uaW5zLmxlbmd0aH0gaW5wdXRzLCBidXQgJHtwcmV2T3V0cHV0cy5sZW5ndGh9IHByZXZpb3VzIG91dHB1dHMgcHJvdmlkZWRgXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBjbG9uZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLmNsb25lKCk7XG4gICAgY29uc3QgdXBkYXRlcyA9IHVuc2lnbihjbG9uZWRUcmFuc2FjdGlvbiwgcHJldk91dHB1dHMpO1xuXG4gICAgY29uc3QgcHNidEJhc2UgPSBuZXcgUHNidEJhc2UobmV3IFBzYnRUcmFuc2FjdGlvbih7IHR4OiBjbG9uZWRUcmFuc2FjdGlvbiB9KSk7XG4gICAgY2xvbmVkVHJhbnNhY3Rpb24uaW5zLmZvckVhY2goKCkgPT4gcHNidEJhc2UuaW5wdXRzLnB1c2goeyB1bmtub3duS2V5VmFsczogW10gfSkpO1xuICAgIGNsb25lZFRyYW5zYWN0aW9uLm91dHMuZm9yRWFjaCgoKSA9PiBwc2J0QmFzZS5vdXRwdXRzLnB1c2goeyB1bmtub3duS2V5VmFsczogW10gfSkpO1xuICAgIGNvbnN0IHBzYnQgPSB0aGlzLmNyZWF0ZVBzYnQoeyBuZXR3b3JrOiB0cmFuc2FjdGlvbi5uZXR3b3JrIH0sIHBzYnRCYXNlKTtcblxuICAgIHVwZGF0ZXMuZm9yRWFjaCgodXBkYXRlLCBpbmRleCkgPT4ge1xuICAgICAgcHNidC51cGRhdGVJbnB1dChpbmRleCwgdXBkYXRlKTtcbiAgICAgIHBzYnQudXBkYXRlSW5wdXQoaW5kZXgsIHsgd2l0bmVzc1V0eG86IHsgc2NyaXB0OiBwcmV2T3V0cHV0c1tpbmRleF0uc2NyaXB0LCB2YWx1ZTogcHJldk91dHB1dHNbaW5kZXhdLnZhbHVlIH0gfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHNidDtcbiAgfVxuXG4gIGdldFVuc2lnbmVkVHgoKTogVXR4b1RyYW5zYWN0aW9uPGJpZ2ludD4ge1xuICAgIHJldHVybiB0aGlzLnR4LmNsb25lKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RhdGljIG5ld1RyYW5zYWN0aW9uKG5ldHdvcms6IE5ldHdvcmspOiBVdHhvVHJhbnNhY3Rpb248YmlnaW50PiB7XG4gICAgcmV0dXJuIG5ldyBVdHhvVHJhbnNhY3Rpb248YmlnaW50PihuZXR3b3JrKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgdHgoKTogVHgge1xuICAgIHJldHVybiAodGhpcy5kYXRhLmdsb2JhbE1hcC51bnNpZ25lZFR4IGFzIFBzYnRUcmFuc2FjdGlvbikudHggYXMgVHg7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tGb3JTaWduYXR1cmVzKHByb3BOYW1lPzogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5kYXRhLmlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgaWYgKGlucHV0LnRhcFNjcmlwdFNpZz8ubGVuZ3RoIHx8IGlucHV0LnRhcEtleVNpZyB8fCBpbnB1dC5wYXJ0aWFsU2lnPy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgbW9kaWZ5ICR7cHJvcE5hbWUgPz8gJ3RyYW5zYWN0aW9uJ30gLSBzaWduYXR1cmVzIGV4aXN0LmApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGF0IGlucHV0SW5kZXggaXMgYSB0YXByb290IGtleSBwYXRoLlxuICAgKiBDaGVja3MgZm9yIHByZXNlbmNlIG9mIG1pbmltdW0gcmVxdWlyZWQga2V5IHBhdGggaW5wdXQgZmllbGRzIGFuZCBhYnNlbmNlIG9mIGFueSBzY3JpcHQgcGF0aCBvbmx5IGlucHV0IGZpZWxkcy5cbiAgICovXG4gIGlzVGFwcm9vdEtleVBhdGhJbnB1dChpbnB1dEluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgcmV0dXJuIChcbiAgICAgICEhaW5wdXQudGFwSW50ZXJuYWxLZXkgJiZcbiAgICAgICEhaW5wdXQudGFwTWVya2xlUm9vdCAmJlxuICAgICAgIShcbiAgICAgICAgaW5wdXQudGFwTGVhZlNjcmlwdD8ubGVuZ3RoIHx8XG4gICAgICAgIGlucHV0LnRhcFNjcmlwdFNpZz8ubGVuZ3RoIHx8XG4gICAgICAgIGlucHV0LnRhcEJpcDMyRGVyaXZhdGlvbj8uc29tZSgodikgPT4gdi5sZWFmSGFzaGVzLmxlbmd0aClcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGF0IGlucHV0SW5kZXggaXMgYSB0YXByb290IHNjcmlwdCBwYXRoLlxuICAgKiBDaGVja3MgZm9yIHByZXNlbmNlIG9mIG1pbmltdW0gcmVxdWlyZWQgc2NyaXB0IHBhdGggaW5wdXQgZmllbGRzIGFuZCBhYnNlbmNlIG9mIGFueSBrZXkgcGF0aCBvbmx5IGlucHV0IGZpZWxkcy5cbiAgICovXG4gIGlzVGFwcm9vdFNjcmlwdFBhdGhJbnB1dChpbnB1dEluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgcmV0dXJuIChcbiAgICAgICEhaW5wdXQudGFwTGVhZlNjcmlwdD8ubGVuZ3RoICYmXG4gICAgICAhKFxuICAgICAgICB0aGlzLmdldFByb3ByaWV0YXJ5S2V5VmFscyhpbnB1dEluZGV4LCB7XG4gICAgICAgICAgaWRlbnRpZmllcjogUFNCVF9QUk9QUklFVEFSWV9JREVOVElGSUVSLFxuICAgICAgICAgIHN1YnR5cGU6IFByb3ByaWV0YXJ5S2V5U3VidHlwZS5NVVNJRzJfUEFSVElDSVBBTlRfUFVCX0tFWVMsXG4gICAgICAgIH0pLmxlbmd0aCB8fFxuICAgICAgICB0aGlzLmdldFByb3ByaWV0YXJ5S2V5VmFscyhpbnB1dEluZGV4LCB7XG4gICAgICAgICAgaWRlbnRpZmllcjogUFNCVF9QUk9QUklFVEFSWV9JREVOVElGSUVSLFxuICAgICAgICAgIHN1YnR5cGU6IFByb3ByaWV0YXJ5S2V5U3VidHlwZS5NVVNJRzJfUFVCX05PTkNFLFxuICAgICAgICB9KS5sZW5ndGggfHxcbiAgICAgICAgdGhpcy5nZXRQcm9wcmlldGFyeUtleVZhbHMoaW5wdXRJbmRleCwge1xuICAgICAgICAgIGlkZW50aWZpZXI6IFBTQlRfUFJPUFJJRVRBUllfSURFTlRJRklFUixcbiAgICAgICAgICBzdWJ0eXBlOiBQcm9wcmlldGFyeUtleVN1YnR5cGUuTVVTSUcyX1BBUlRJQUxfU0lHLFxuICAgICAgICB9KS5sZW5ndGhcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGF0IGlucHV0SW5kZXggaXMgYSB0YXByb290XG4gICAqL1xuICBpc1RhcHJvb3RJbnB1dChpbnB1dEluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgY29uc3QgaXNQMlRSID0gKHNjcmlwdDogQnVmZmVyKTogYm9vbGVhbiA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBnZXRUYXByb290T3V0cHV0S2V5KHNjcmlwdCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gISEoXG4gICAgICBpbnB1dC50YXBJbnRlcm5hbEtleSB8fFxuICAgICAgaW5wdXQudGFwTWVya2xlUm9vdCB8fFxuICAgICAgaW5wdXQudGFwTGVhZlNjcmlwdD8ubGVuZ3RoIHx8XG4gICAgICBpbnB1dC50YXBCaXAzMkRlcml2YXRpb24/Lmxlbmd0aCB8fFxuICAgICAgaW5wdXQudGFwU2NyaXB0U2lnPy5sZW5ndGggfHxcbiAgICAgIHRoaXMuZ2V0UHJvcHJpZXRhcnlLZXlWYWxzKGlucHV0SW5kZXgsIHtcbiAgICAgICAgaWRlbnRpZmllcjogUFNCVF9QUk9QUklFVEFSWV9JREVOVElGSUVSLFxuICAgICAgICBzdWJ0eXBlOiBQcm9wcmlldGFyeUtleVN1YnR5cGUuTVVTSUcyX1BBUlRJQ0lQQU5UX1BVQl9LRVlTLFxuICAgICAgfSkubGVuZ3RoIHx8XG4gICAgICB0aGlzLmdldFByb3ByaWV0YXJ5S2V5VmFscyhpbnB1dEluZGV4LCB7XG4gICAgICAgIGlkZW50aWZpZXI6IFBTQlRfUFJPUFJJRVRBUllfSURFTlRJRklFUixcbiAgICAgICAgc3VidHlwZTogUHJvcHJpZXRhcnlLZXlTdWJ0eXBlLk1VU0lHMl9QVUJfTk9OQ0UsXG4gICAgICB9KS5sZW5ndGggfHxcbiAgICAgIHRoaXMuZ2V0UHJvcHJpZXRhcnlLZXlWYWxzKGlucHV0SW5kZXgsIHtcbiAgICAgICAgaWRlbnRpZmllcjogUFNCVF9QUk9QUklFVEFSWV9JREVOVElGSUVSLFxuICAgICAgICBzdWJ0eXBlOiBQcm9wcmlldGFyeUtleVN1YnR5cGUuTVVTSUcyX1BBUlRJQUxfU0lHLFxuICAgICAgfSkubGVuZ3RoIHx8XG4gICAgICAoaW5wdXQud2l0bmVzc1V0eG8gJiYgaXNQMlRSKGlucHV0LndpdG5lc3NVdHhvLnNjcmlwdCkpXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgaXNNdWx0aXNpZ1RhcHJvb3RTY3JpcHQoc2NyaXB0OiBCdWZmZXIpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgcGFyc2VQdWJTY3JpcHQyT2YzKHNjcmlwdCwgJ3RhcHJvb3RTY3JpcHRQYXRoU3BlbmQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW9zdGx5IGNvcGllZCBmcm9tIGJpdGNvaW5qcy1saWIvdHNfc3JjL3BzYnQudHNcbiAgICovXG4gIGZpbmFsaXplQWxsSW5wdXRzKCk6IHRoaXMge1xuICAgIGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgMCk7IC8vIG1ha2luZyBzdXJlIHdlIGhhdmUgYXQgbGVhc3Qgb25lXG4gICAgdGhpcy5kYXRhLmlucHV0cy5tYXAoKGlucHV0LCBpZHgpID0+IHtcbiAgICAgIGlmIChpbnB1dC50YXBMZWFmU2NyaXB0Py5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNNdWx0aXNpZ1RhcHJvb3RTY3JpcHQoaW5wdXQudGFwTGVhZlNjcmlwdFswXS5zY3JpcHQpXG4gICAgICAgICAgPyB0aGlzLmZpbmFsaXplVGFwcm9vdElucHV0KGlkeClcbiAgICAgICAgICA6IHRoaXMuZmluYWxpemVUYXBJbnB1dFdpdGhTaW5nbGVMZWFmU2NyaXB0QW5kU2lnbmF0dXJlKGlkeCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUYXByb290S2V5UGF0aElucHV0KGlkeCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemVUYXByb290TXVzaWcySW5wdXQoaWR4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplSW5wdXQoaWR4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZpbmFsaXplVGFwcm9vdElucHV0KGlucHV0SW5kZXg6IG51bWJlcik6IHRoaXMge1xuICAgIGNvbnN0IHNhbml0aXplU2lnbmF0dXJlID0gKHNpZzogQnVmZmVyKSA9PiB7XG4gICAgICBjb25zdCBzaWdoYXNoVHlwZSA9IHNpZy5sZW5ndGggPT09IDY0ID8gVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxUIDogc2lnLnJlYWRVSW50OChzaWcubGVuZ3RoIC0gMSk7XG4gICAgICBjb25zdCBpbnB1dFNpZ2hhc2hUeXBlID0gaW5wdXQuc2lnaGFzaFR5cGUgPT09IHVuZGVmaW5lZCA/IFRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVCA6IGlucHV0LnNpZ2hhc2hUeXBlO1xuICAgICAgYXNzZXJ0KHNpZ2hhc2hUeXBlID09PSBpbnB1dFNpZ2hhc2hUeXBlLCAnc2lnbmF0dXJlIHNpZ2hhc2ggZG9lcyBub3QgbWF0Y2ggaW5wdXQgc2lnaGFzaCB0eXBlJyk7XG4gICAgICAvLyBUT0RPIEJUQy02NjMgVGhpcyBzaG91bGQgYmUgZml4ZWQgaW4gcGxhdGZvcm0uIFRoaXMgaXMganVzdCBhIHdvcmthcm91bmQgZml4LlxuICAgICAgcmV0dXJuIHNpZ2hhc2hUeXBlID09PSBUcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFQgJiYgc2lnLmxlbmd0aCA9PT0gNjUgPyBzaWcuc2xpY2UoMCwgNjQpIDogc2lnO1xuICAgIH07XG4gICAgY29uc3QgaW5wdXQgPSBjaGVja0ZvcklucHV0KHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgIC8vIHdpdG5lc3MgPSBjb250cm9sLWJsb2NrIHNjcmlwdCBmaXJzdC1zaWcgc2Vjb25kLXNpZ1xuICAgIGlmIChpbnB1dC50YXBMZWFmU2NyaXB0Py5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgbGVhZiBzY3JpcHQgc3VwcG9ydGVkIGZvciBmaW5hbGl6aW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY29udHJvbEJsb2NrLCBzY3JpcHQgfSA9IGlucHV0LnRhcExlYWZTY3JpcHRbMF07XG4gICAgY29uc3Qgd2l0bmVzczogQnVmZmVyW10gPSBbc2NyaXB0LCBjb250cm9sQmxvY2tdO1xuICAgIGNvbnN0IFtwdWJrZXkxLCBwdWJrZXkyXSA9IHBhcnNlUHViU2NyaXB0Mk9mMyhzY3JpcHQsICd0YXByb290U2NyaXB0UGF0aFNwZW5kJykucHVibGljS2V5cztcbiAgICBmb3IgKGNvbnN0IHBrIG9mIFtwdWJrZXkxLCBwdWJrZXkyXSkge1xuICAgICAgY29uc3Qgc2lnID0gaW5wdXQudGFwU2NyaXB0U2lnPy5maW5kKCh7IHB1YmtleSB9KSA9PiBlcXVhbFB1YmxpY0tleUlnbm9yZVkocGssIHB1YmtleSkpO1xuICAgICAgaWYgKCFzaWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBzaWduYXR1cmVzIGluIFNjcmlwdCBTaWcuJyk7XG4gICAgICB9XG4gICAgICB3aXRuZXNzLnVuc2hpZnQoc2FuaXRpemVTaWduYXR1cmUoc2lnLnNpZ25hdHVyZSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHdpdG5lc3NMZW5ndGggPSB3aXRuZXNzLnJlZHVjZSgocywgYikgPT4gcyArIGIubGVuZ3RoICsgdmFydWludC5lbmNvZGluZ0xlbmd0aChiLmxlbmd0aCksIDEpO1xuXG4gICAgY29uc3QgYnVmZmVyV3JpdGVyID0gQnVmZmVyV3JpdGVyLndpdGhDYXBhY2l0eSh3aXRuZXNzTGVuZ3RoKTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVWZWN0b3Iod2l0bmVzcyk7XG4gICAgY29uc3QgZmluYWxTY3JpcHRXaXRuZXNzID0gYnVmZmVyV3JpdGVyLmVuZCgpO1xuXG4gICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgZmluYWxTY3JpcHRXaXRuZXNzIH0pO1xuICAgIHRoaXMuZGF0YS5jbGVhckZpbmFsaXplZElucHV0KGlucHV0SW5kZXgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRmluYWxpemVzIGEgdGFwcm9vdCBtdXNpZzIgaW5wdXQgYnkgYWdncmVnYXRpbmcgYWxsIHBhcnRpYWwgc2lncy5cbiAgICogSU1QT1JUQU5UOiBBbHdheXMgY2FsbCB2YWxpZGF0ZSogZnVuY3Rpb24gYmVmb3JlIGZpbmFsaXppbmcuXG4gICAqL1xuICBmaW5hbGl6ZVRhcHJvb3RNdXNpZzJJbnB1dChpbnB1dEluZGV4OiBudW1iZXIpOiB0aGlzIHtcbiAgICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgY29uc3QgcGFydGlhbFNpZ3MgPSBwYXJzZVBzYnRNdXNpZzJQYXJ0aWFsU2lncyhpbnB1dCk7XG4gICAgaWYgKHBhcnRpYWxTaWdzPy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBudW1iZXIgb2YgcGFydGlhbCBzaWduYXR1cmVzICR7cGFydGlhbFNpZ3MgPyBwYXJ0aWFsU2lncy5sZW5ndGggOiAwfSB0byBmaW5hbGl6ZWApO1xuICAgIH1cbiAgICBjb25zdCB7IHBhcnRpYWxTaWdzOiBwU2lncywgc2lnSGFzaFR5cGUgfSA9IGdldFNpZ0hhc2hUeXBlRnJvbVNpZ3MocGFydGlhbFNpZ3MpO1xuICAgIGNvbnN0IHsgc2Vzc2lvbktleSB9ID0gdGhpcy5nZXRNdXNpZzJTZXNzaW9uS2V5KGlucHV0SW5kZXgsIHNpZ0hhc2hUeXBlKTtcblxuICAgIGNvbnN0IGFnZ1NpZyA9IG11c2lnMkFnZ3JlZ2F0ZVNpZ3MoXG4gICAgICBwU2lncy5tYXAoKHBTaWcpID0+IHBTaWcucGFydGlhbFNpZyksXG4gICAgICBzZXNzaW9uS2V5XG4gICAgKTtcblxuICAgIGNvbnN0IHNpZyA9IHNpZ0hhc2hUeXBlID09PSBUcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFQgPyBhZ2dTaWcgOiBCdWZmZXIuY29uY2F0KFthZ2dTaWcsIEJ1ZmZlci5vZihzaWdIYXNoVHlwZSldKTtcblxuICAgIC8vIHNpbmdsZSBzaWduYXR1cmUgd2l0aCA2NC82NSBieXRlcyBzaXplIGlzIHNjcmlwdCB3aXRuZXNzIGZvciBrZXkgcGF0aCBzcGVuZFxuICAgIGNvbnN0IGJ1ZmZlcldyaXRlciA9IEJ1ZmZlcldyaXRlci53aXRoQ2FwYWNpdHkoMSArIHZhcnVpbnQuZW5jb2RpbmdMZW5ndGgoc2lnLmxlbmd0aCkgKyBzaWcubGVuZ3RoKTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVWZWN0b3IoW3NpZ10pO1xuICAgIGNvbnN0IGZpbmFsU2NyaXB0V2l0bmVzcyA9IGJ1ZmZlcldyaXRlci5lbmQoKTtcblxuICAgIHRoaXMuZGF0YS51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7IGZpbmFsU2NyaXB0V2l0bmVzcyB9KTtcbiAgICB0aGlzLmRhdGEuY2xlYXJGaW5hbGl6ZWRJbnB1dChpbnB1dEluZGV4KTtcbiAgICAvLyBkZWxldGluZyBvbmx5IEJpdEdvIHByb3ByaWV0YXJ5IGtleSB2YWx1ZXMuXG4gICAgdGhpcy5kZWxldGVQcm9wcmlldGFyeUtleVZhbHMoaW5wdXRJbmRleCwgeyBpZGVudGlmaWVyOiBQU0JUX1BST1BSSUVUQVJZX0lERU5USUZJRVIgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmaW5hbGl6ZVRhcElucHV0V2l0aFNpbmdsZUxlYWZTY3JpcHRBbmRTaWduYXR1cmUoaW5wdXRJbmRleDogbnVtYmVyKTogdGhpcyB7XG4gICAgY29uc3QgaW5wdXQgPSBjaGVja0ZvcklucHV0KHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgIGlmIChpbnB1dC50YXBMZWFmU2NyaXB0Py5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgbGVhZiBzY3JpcHQgc3VwcG9ydGVkIGZvciBmaW5hbGl6aW5nJyk7XG4gICAgfVxuICAgIGlmIChpbnB1dC50YXBTY3JpcHRTaWc/Lmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBzaWduYXR1cmVzIGluIFNjcmlwdCBTaWcuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBjb250cm9sQmxvY2ssIHNjcmlwdCB9ID0gaW5wdXQudGFwTGVhZlNjcmlwdFswXTtcbiAgICBjb25zdCB3aXRuZXNzOiBCdWZmZXJbXSA9IFtpbnB1dC50YXBTY3JpcHRTaWdbMF0uc2lnbmF0dXJlLCBzY3JpcHQsIGNvbnRyb2xCbG9ja107XG4gICAgY29uc3Qgd2l0bmVzc0xlbmd0aCA9IHdpdG5lc3MucmVkdWNlKChzLCBiKSA9PiBzICsgYi5sZW5ndGggKyB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKGIubGVuZ3RoKSwgMSk7XG5cbiAgICBjb25zdCBidWZmZXJXcml0ZXIgPSBCdWZmZXJXcml0ZXIud2l0aENhcGFjaXR5KHdpdG5lc3NMZW5ndGgpO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVZlY3Rvcih3aXRuZXNzKTtcbiAgICBjb25zdCBmaW5hbFNjcmlwdFdpdG5lc3MgPSBidWZmZXJXcml0ZXIuZW5kKCk7XG5cbiAgICB0aGlzLmRhdGEudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgeyBmaW5hbFNjcmlwdFdpdG5lc3MgfSk7XG4gICAgdGhpcy5kYXRhLmNsZWFyRmluYWxpemVkSW5wdXQoaW5wdXRJbmRleCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3N0bHkgY29waWVkIGZyb20gYml0Y29pbmpzLWxpYi90c19zcmMvcHNidC50c1xuICAgKlxuICAgKiBVbmxpa2UgdGhlIGZ1bmN0aW9uIGl0IG92ZXJyaWRlcywgdGhpcyBkb2VzIG5vdCB0YWtlIGEgdmFsaWRhdG9yLiBJbiBCaXRHb1xuICAgKiBjb250ZXh0LCB3ZSBrbm93IGhvdyB3ZSB3YW50IHRvIHZhbGlkYXRlIHNvIHdlIGp1c3QgaGFyZCBjb2RlIHRoZSByaWdodFxuICAgKiB2YWxpZGF0b3IuXG4gICAqL1xuICB2YWxpZGF0ZVNpZ25hdHVyZXNPZkFsbElucHV0cygpOiBib29sZWFuIHtcbiAgICBjaGVja0ZvcklucHV0KHRoaXMuZGF0YS5pbnB1dHMsIDApOyAvLyBtYWtpbmcgc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IG9uZVxuICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLmRhdGEuaW5wdXRzLm1hcCgoaW5wdXQsIGlkeCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVTaWduYXR1cmVzT2ZJbnB1dENvbW1vbihpZHgpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzLnJlZHVjZSgoZmluYWwsIHJlcykgPT4gcmVzICYmIGZpbmFsLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmZiBhbnkgbWF0Y2hpbmcgdmFsaWQgc2lnbmF0dXJlIGlzIGZvdW5kIGZvciBhIGRlcml2ZWQgcHViIGtleSBmcm9tIGdpdmVuIEhEIGtleSBwYWlyLlxuICAgKi9cbiAgdmFsaWRhdGVTaWduYXR1cmVzT2ZJbnB1dEhEKGlucHV0SW5kZXg6IG51bWJlciwgaGRLZXlQYWlyOiBCSVAzMkludGVyZmFjZSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGlucHV0ID0gY2hlY2tGb3JJbnB1dCh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICBjb25zdCBwdWJLZXkgPSBVdHhvUHNidC5kZXJpdmVLZXlQYWlyRm9ySW5wdXQoaGRLZXlQYWlyLCBpbnB1dCk7XG4gICAgaWYgKCFwdWJLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FuIG5vdCBkZXJpdmUgZnJvbSBIRCBrZXkgcGFpcicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVNpZ25hdHVyZXNPZklucHV0Q29tbW9uKGlucHV0SW5kZXgsIHB1YktleSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgdHJ1ZSBpZmYgYW55IHZhbGlkIHNpZ25hdHVyZShzKSBhcmUgZm91bmQgZnJvbSBiaXAzMiBkYXRhIG9mIFBTQlQgb3IgZm9yIGdpdmVuIHB1YiBrZXkuXG4gICAqL1xuICB2YWxpZGF0ZVNpZ25hdHVyZXNPZklucHV0Q29tbW9uKGlucHV0SW5kZXg6IG51bWJlciwgcHVia2V5PzogQnVmZmVyKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmlzVGFwcm9vdFNjcmlwdFBhdGhJbnB1dChpbnB1dEluZGV4KSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVRhcHJvb3RTaWduYXR1cmVzT2ZJbnB1dChpbnB1dEluZGV4LCBwdWJrZXkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzVGFwcm9vdEtleVBhdGhJbnB1dChpbnB1dEluZGV4KSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVRhcHJvb3RNdXNpZzJTaWduYXR1cmVzT2ZJbnB1dChpbnB1dEluZGV4LCBwdWJrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVTaWduYXR1cmVzT2ZJbnB1dChpbnB1dEluZGV4LCAocCwgbSwgcykgPT4gZWNjTGliLnZlcmlmeShtLCBwLCBzLCB0cnVlKSwgcHVia2V5KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIE5vdCBhbiBlbGVnYW50IHNvbHV0aW9uLiBNaWdodCBuZWVkIHVwc3RyZWFtIGNoYW5nZXMgbGlrZSBjdXN0b20gZXJyb3IgdHlwZXMuXG4gICAgICBpZiAoZXJyLm1lc3NhZ2UgPT09ICdObyBzaWduYXR1cmVzIGZvciB0aGlzIHB1YmtleScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0TXVzaWcyU2Vzc2lvbktleShcbiAgICBpbnB1dEluZGV4OiBudW1iZXIsXG4gICAgc2lnSGFzaFR5cGU6IG51bWJlclxuICApOiB7XG4gICAgcGFydGljaXBhbnRzOiBQc2J0TXVzaWcyUGFydGljaXBhbnRzO1xuICAgIG5vbmNlczogVHVwbGU8UHNidE11c2lnMlB1Yk5vbmNlPjtcbiAgICBoYXNoOiBCdWZmZXI7XG4gICAgc2Vzc2lvbktleTogU2Vzc2lvbktleTtcbiAgfSB7XG4gICAgY29uc3QgaW5wdXQgPSBjaGVja0ZvcklucHV0KHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgIGlmICghaW5wdXQudGFwSW50ZXJuYWxLZXkgfHwgIWlucHV0LnRhcE1lcmtsZVJvb3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYm90aCB0YXBJbnRlcm5hbEtleSBhbmQgdGFwTWVya2xlUm9vdCBhcmUgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJ0aWNpcGFudHMgPSB0aGlzLmdldE11c2lnMlBhcnRpY2lwYW50cyhpbnB1dEluZGV4LCBpbnB1dC50YXBJbnRlcm5hbEtleSwgaW5wdXQudGFwTWVya2xlUm9vdCk7XG4gICAgY29uc3Qgbm9uY2VzID0gdGhpcy5nZXRNdXNpZzJOb25jZXMoaW5wdXRJbmRleCwgcGFydGljaXBhbnRzKTtcblxuICAgIGNvbnN0IHsgaGFzaCB9ID0gdGhpcy5nZXRUYXByb290SGFzaEZvclNpZyhpbnB1dEluZGV4LCBbc2lnSGFzaFR5cGVdKTtcblxuICAgIGNvbnN0IHNlc3Npb25LZXkgPSBjcmVhdGVNdXNpZzJTaWduaW5nU2Vzc2lvbih7XG4gICAgICBwdWJOb25jZXM6IFtub25jZXNbMF0ucHViTm9uY2UsIG5vbmNlc1sxXS5wdWJOb25jZV0sXG4gICAgICBwdWJLZXlzOiBwYXJ0aWNpcGFudHMucGFydGljaXBhbnRQdWJLZXlzLFxuICAgICAgdHhIYXNoOiBoYXNoLFxuICAgICAgaW50ZXJuYWxQdWJLZXk6IGlucHV0LnRhcEludGVybmFsS2V5LFxuICAgICAgdGFwVHJlZVJvb3Q6IGlucHV0LnRhcE1lcmtsZVJvb3QsXG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcGFydGljaXBhbnRzLCBub25jZXMsIGhhc2gsIHNlc3Npb25LZXkgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB0cnVlIGZvciBmb2xsb3dpbmcgY2FzZXMuXG4gICAqIElmIHZhbGlkIG11c2lnMiBwYXJ0aWFsIHNpZ25hdHVyZXMgZXhpc3RzIGZvciBib3RoIDIga2V5cywgaXQgd2lsbCBhbHNvIHZlcmlmeSBhZ2dyZWdhdGVkIHNpZ1xuICAgKiBmb3IgYWdncmVnYXRlZCB0d2Vha2VkIGtleSAob3V0cHV0IGtleSksIG90aGVyd2lzZSBvbmx5IHZlcmlmaWVzIHBhcnRpYWwgc2lnLlxuICAgKiBJZiBwdWJrZXkgaXMgcGFzc2VkIGluIGlucHV0LCBpdCB3aWxsIGNoZWNrIHNpZyBvbmx5IGZvciB0aGF0IHB1YmtleSxcbiAgICogaWYgbm8gc2lnIGV4aXRzIGZvciBzdWNoIGtleSwgdGhyb3dzIGVycm9yLlxuICAgKiBGb3IgaW52YWxpZCBzdGF0ZSBvZiBpbnB1dCBkYXRhLCBpdCB3aWxsIHRocm93IGVycm9ycy5cbiAgICovXG4gIHZhbGlkYXRlVGFwcm9vdE11c2lnMlNpZ25hdHVyZXNPZklucHV0KGlucHV0SW5kZXg6IG51bWJlciwgcHVia2V5PzogQnVmZmVyKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaW5wdXQgPSBjaGVja0ZvcklucHV0KHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgIGNvbnN0IHBhcnRpYWxTaWdzID0gcGFyc2VQc2J0TXVzaWcyUGFydGlhbFNpZ3MoaW5wdXQpO1xuICAgIGlmICghcGFydGlhbFNpZ3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc2lnbmF0dXJlcyB0byB2YWxpZGF0ZWApO1xuICAgIH1cblxuICAgIGxldCBteVBhcnRpYWxTaWdzID0gcGFydGlhbFNpZ3M7XG4gICAgaWYgKHB1YmtleSkge1xuICAgICAgbXlQYXJ0aWFsU2lncyA9IHBhcnRpYWxTaWdzLmZpbHRlcigoa3YpID0+IGVxdWFsUHVibGljS2V5SWdub3JlWShrdi5wYXJ0aWNpcGFudFB1YktleSwgcHVia2V5KSk7XG4gICAgICBpZiAobXlQYXJ0aWFsU2lncz8ubGVuZ3RoIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25hdHVyZXMgZm9yIHRoaXMgcHVia2V5Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeyBwYXJ0aWFsU2lnczogbXlTaWdzLCBzaWdIYXNoVHlwZSB9ID0gZ2V0U2lnSGFzaFR5cGVGcm9tU2lncyhteVBhcnRpYWxTaWdzKTtcbiAgICBjb25zdCB7IHBhcnRpY2lwYW50cywgbm9uY2VzLCBoYXNoLCBzZXNzaW9uS2V5IH0gPSB0aGlzLmdldE11c2lnMlNlc3Npb25LZXkoaW5wdXRJbmRleCwgc2lnSGFzaFR5cGUpO1xuXG4gICAgY29uc3QgcmVzdWx0cyA9IG15U2lncy5tYXAoKG15U2lnKSA9PiB7XG4gICAgICBjb25zdCBteU5vbmNlID0gbm9uY2VzLmZpbmQoKGt2KSA9PiBlcXVhbFB1YmxpY0tleUlnbm9yZVkoa3YucGFydGljaXBhbnRQdWJLZXksIG15U2lnLnBhcnRpY2lwYW50UHViS2V5KSk7XG4gICAgICBpZiAoIW15Tm9uY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBubyBwdWIgbm9uY2UgZm9yIHB1YmtleScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG11c2lnMlBhcnRpYWxTaWdWZXJpZnkobXlTaWcucGFydGlhbFNpZywgbXlTaWcucGFydGljaXBhbnRQdWJLZXksIG15Tm9uY2UucHViTm9uY2UsIHNlc3Npb25LZXkpO1xuICAgIH0pO1xuXG4gICAgLy8gRm9yIHZhbGlkIHNpbmdsZSBzaWcgb3IgMSBvciAyIGZhaWx1cmUgc2lncywgbm8gbmVlZCB0byB2YWxpZGF0ZSBhZ2dyZWdhdGVkIHNpZy4gU28gc2tpcC5cbiAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzLmV2ZXJ5KChyZXMpID0+IHJlcyk7XG4gICAgaWYgKCFyZXN1bHQgfHwgbXlTaWdzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgY29uc3QgYWdnU2lnID0gbXVzaWcyQWdncmVnYXRlU2lncyhcbiAgICAgIG15U2lncy5tYXAoKG15U2lnKSA9PiBteVNpZy5wYXJ0aWFsU2lnKSxcbiAgICAgIHNlc3Npb25LZXlcbiAgICApO1xuXG4gICAgcmV0dXJuIGVjY0xpYi52ZXJpZnlTY2hub3JyKGhhc2gsIHBhcnRpY2lwYW50cy50YXBPdXRwdXRLZXksIGFnZ1NpZyk7XG4gIH1cblxuICB2YWxpZGF0ZVRhcHJvb3RTaWduYXR1cmVzT2ZJbnB1dChpbnB1dEluZGV4OiBudW1iZXIsIHB1YmtleT86IEJ1ZmZlcik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5kYXRhLmlucHV0c1tpbnB1dEluZGV4XTtcbiAgICBjb25zdCB0YXBTaWdzID0gKGlucHV0IHx8IHt9KS50YXBTY3JpcHRTaWc7XG4gICAgaWYgKCFpbnB1dCB8fCAhdGFwU2lncyB8fCB0YXBTaWdzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmF0dXJlcyB0byB2YWxpZGF0ZScpO1xuICAgIH1cbiAgICBsZXQgbXlTaWdzO1xuICAgIGlmIChwdWJrZXkpIHtcbiAgICAgIG15U2lncyA9IHRhcFNpZ3MuZmlsdGVyKChzaWcpID0+IGVxdWFsUHVibGljS2V5SWdub3JlWShzaWcucHVia2V5LCBwdWJrZXkpKTtcbiAgICAgIGlmIChteVNpZ3MubGVuZ3RoIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25hdHVyZXMgZm9yIHRoaXMgcHVia2V5Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG15U2lncyA9IHRhcFNpZ3M7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdHM6IGJvb2xlYW5bXSA9IFtdO1xuXG4gICAgYXNzZXJ0KGlucHV0LnRhcExlYWZTY3JpcHQ/Lmxlbmd0aCA9PT0gMSwgYHNpbmdsZSB0YXBMZWFmU2NyaXB0IGlzIGV4cGVjdGVkLiBHb3QgJHtpbnB1dC50YXBMZWFmU2NyaXB0Py5sZW5ndGh9YCk7XG4gICAgY29uc3QgW3RhcExlYWZTY3JpcHRdID0gaW5wdXQudGFwTGVhZlNjcmlwdDtcbiAgICBjb25zdCBwdWJLZXlzID0gdGhpcy5pc011bHRpc2lnVGFwcm9vdFNjcmlwdCh0YXBMZWFmU2NyaXB0LnNjcmlwdClcbiAgICAgID8gcGFyc2VQdWJTY3JpcHQyT2YzKHRhcExlYWZTY3JpcHQuc2NyaXB0LCAndGFwcm9vdFNjcmlwdFBhdGhTcGVuZCcpLnB1YmxpY0tleXNcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgZm9yIChjb25zdCBwU2lnIG9mIG15U2lncykge1xuICAgICAgY29uc3QgeyBzaWduYXR1cmUsIGxlYWZIYXNoLCBwdWJrZXkgfSA9IHBTaWc7XG4gICAgICBpZiAocHViS2V5cykge1xuICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgcHViS2V5cy5maW5kKChwaykgPT4gcHVia2V5LmVxdWFscyhwaykpLFxuICAgICAgICAgICdwdWJsaWMga2V5IG5vdCBmb3VuZCBpbiB0YXAgbGVhZiBzY3JpcHQnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBsZXQgc2lnSGFzaFR5cGU6IG51bWJlcjtcbiAgICAgIGxldCBzaWc6IEJ1ZmZlcjtcbiAgICAgIGlmIChzaWduYXR1cmUubGVuZ3RoID09PSA2NSkge1xuICAgICAgICBzaWdIYXNoVHlwZSA9IHNpZ25hdHVyZVs2NF07XG4gICAgICAgIHNpZyA9IHNpZ25hdHVyZS5zbGljZSgwLCA2NCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWdIYXNoVHlwZSA9IFRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVDtcbiAgICAgICAgc2lnID0gc2lnbmF0dXJlO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBoYXNoIH0gPSB0aGlzLmdldFRhcHJvb3RIYXNoRm9yU2lnKGlucHV0SW5kZXgsIFtzaWdIYXNoVHlwZV0sIGxlYWZIYXNoKTtcbiAgICAgIHJlc3VsdHMucHVzaChlY2NMaWIudmVyaWZ5U2Nobm9ycihoYXNoLCBwdWJrZXksIHNpZykpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cy5ldmVyeSgocmVzKSA9PiByZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBpbnB1dEluZGV4XG4gICAqIEBwYXJhbSByb290Tm9kZXMgb3B0aW9uYWwgaW5wdXQgcm9vdCBiaXAzMiBub2RlcyB0byB2ZXJpZnkgd2l0aC4gSWYgaXQgaXMgbm90IHByb3ZpZGVkLCBnbG9iYWxYcHViIHdpbGwgYmUgdXNlZC5cbiAgICogQHJldHVybiBhcnJheSBvZiBib29sZWFuIHZhbHVlcy4gVHJ1ZSB3aGVuIGNvcnJlc3BvbmRpbmcgaW5kZXggaW4gYHB1YmxpY0tleXNgIGhhcyBzaWduZWQgdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBJZiBubyBzaWduYXR1cmUgaW4gdGhlIHR4IG9yIG5vIHB1YmxpYyBrZXkgbWF0Y2hpbmcgc2lnbmF0dXJlLCB0aGUgdmFsaWRhdGlvbiBpcyBjb25zaWRlcmVkIGFzIGZhbHNlLlxuICAgKi9cbiAgZ2V0U2lnbmF0dXJlVmFsaWRhdGlvbkFycmF5KFxuICAgIGlucHV0SW5kZXg6IG51bWJlcixcbiAgICB7IHJvb3ROb2RlcyB9OiB7IHJvb3ROb2Rlcz86IFRyaXBsZTxCSVAzMkludGVyZmFjZT4gfSA9IHt9XG4gICk6IFRyaXBsZTxib29sZWFuPiB7XG4gICAgaWYgKCFyb290Tm9kZXMgJiYgKCF0aGlzLmRhdGEuZ2xvYmFsTWFwLmdsb2JhbFhwdWI/Lmxlbmd0aCB8fCAhaXNUcmlwbGUodGhpcy5kYXRhLmdsb2JhbE1hcC5nbG9iYWxYcHViKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGdldCBzaWduYXR1cmUgdmFsaWRhdGlvbiBhcnJheSB3aXRob3V0IDMgZ2xvYmFsIHhwdWJzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYmlwMzJzID0gcm9vdE5vZGVzXG4gICAgICA/IHJvb3ROb2Rlc1xuICAgICAgOiB0aGlzLmRhdGEuZ2xvYmFsTWFwLmdsb2JhbFhwdWI/Lm1hcCgoeHB1YikgPT5cbiAgICAgICAgICBCSVAzMkZhY3RvcnkoZWNjTGliKS5mcm9tQmFzZTU4KGJzNThjaGVjay5lbmNvZGUoeHB1Yi5leHRlbmRlZFB1YmtleSkpXG4gICAgICAgICk7XG5cbiAgICBpZiAoIWJpcDMycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlaXRoZXIgZ2xvYmFsTWFwIG9yIHJvb3ROb2RlcyBpcyByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0ID0gY2hlY2tGb3JJbnB1dCh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICBpZiAoIWdldFBzYnRJbnB1dFNpZ25hdHVyZUNvdW50KGlucHV0KSkge1xuICAgICAgcmV0dXJuIFtmYWxzZSwgZmFsc2UsIGZhbHNlXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmlwMzJzLm1hcCgoYmlwMzIpID0+IHtcbiAgICAgIGNvbnN0IHB1YktleSA9IFV0eG9Qc2J0LmRlcml2ZUtleVBhaXJGb3JJbnB1dChiaXAzMiwgaW5wdXQpO1xuICAgICAgaWYgKCFwdWJLZXkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVTaWduYXR1cmVzT2ZJbnB1dENvbW1vbihpbnB1dEluZGV4LCBwdWJLZXkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIE5vdCBhbiBlbGVnYW50IHNvbHV0aW9uLiBNaWdodCBuZWVkIHVwc3RyZWFtIGNoYW5nZXMgbGlrZSBjdXN0b20gZXJyb3IgdHlwZXMuXG4gICAgICAgIGlmIChlcnIubWVzc2FnZSA9PT0gJ05vIHNpZ25hdHVyZXMgZm9yIHRoaXMgcHVia2V5Jykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSkgYXMgVHJpcGxlPGJvb2xlYW4+O1xuICB9XG5cbiAgLyoqXG4gICAqIE1vc3RseSBjb3BpZWQgZnJvbSBiaXRjb2luanMtbGliL3RzX3NyYy9wc2J0LnRzXG4gICAqL1xuICBzaWduQWxsSW5wdXRzSEQoXG4gICAgaGRLZXlQYWlyOiBIRFRhcHJvb3RTaWduZXIgfCBIRFRhcHJvb3RNdXNpZzJTaWduZXIsXG4gICAgcGFyYW1zPzogbnVtYmVyW10gfCBQYXJ0aWFsPFNpZ25hdHVyZVBhcmFtcz5cbiAgKTogdGhpcyB7XG4gICAgaWYgKCFoZEtleVBhaXIgfHwgIWhkS2V5UGFpci5wdWJsaWNLZXkgfHwgIWhkS2V5UGFpci5maW5nZXJwcmludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIEhEU2lnbmVyIHRvIHNpZ24gaW5wdXQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBzaWdoYXNoVHlwZXMsIGRldGVybWluaXN0aWMgfSA9IHRvU2lnbmF0dXJlUGFyYW1zKHRoaXMubmV0d29yaywgcGFyYW1zKTtcblxuICAgIGNvbnN0IHJlc3VsdHM6IGJvb2xlYW5bXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zaWduSW5wdXRIRChpLCBoZEtleVBhaXIsIHsgc2lnaGFzaFR5cGVzLCBkZXRlcm1pbmlzdGljIH0pO1xuICAgICAgICByZXN1bHRzLnB1c2godHJ1ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdHMuZXZlcnkoKHYpID0+ICF2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbnB1dHMgd2VyZSBzaWduZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTW9zdGx5IGNvcGllZCBmcm9tIGJpdGNvaW5qcy1saWIvdHNfc3JjL3BzYnQudHM6c2lnbklucHV0SERcbiAgICovXG4gIHNpZ25UYXByb290SW5wdXRIRChcbiAgICBpbnB1dEluZGV4OiBudW1iZXIsXG4gICAgaGRLZXlQYWlyOiBIRFRhcHJvb3RTaWduZXIgfCBIRFRhcHJvb3RNdXNpZzJTaWduZXIsXG4gICAgeyBzaWdoYXNoVHlwZXMgPSBbVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxULCBUcmFuc2FjdGlvbi5TSUdIQVNIX0FMTF0sIGRldGVybWluaXN0aWMgPSBmYWxzZSB9ID0ge31cbiAgKTogdGhpcyB7XG4gICAgaWYgKCF0aGlzLmlzVGFwcm9vdElucHV0KGlucHV0SW5kZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBhIHRhcHJvb3QgaW5wdXQnKTtcbiAgICB9XG4gICAgaWYgKCFoZEtleVBhaXIgfHwgIWhkS2V5UGFpci5wdWJsaWNLZXkgfHwgIWhkS2V5UGFpci5maW5nZXJwcmludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIEhEU2lnbmVyIHRvIHNpZ24gaW5wdXQnKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXQgPSBjaGVja0ZvcklucHV0KHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgIGlmICghaW5wdXQudGFwQmlwMzJEZXJpdmF0aW9uIHx8IGlucHV0LnRhcEJpcDMyRGVyaXZhdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCB0YXBCaXAzMkRlcml2YXRpb24gdG8gc2lnbiBUYXByb290IHdpdGggSEQnKTtcbiAgICB9XG4gICAgY29uc3QgbXlEZXJpdmF0aW9ucyA9IGlucHV0LnRhcEJpcDMyRGVyaXZhdGlvblxuICAgICAgLm1hcCgoYmlwRHYpID0+IHtcbiAgICAgICAgaWYgKGJpcER2Lm1hc3RlckZpbmdlcnByaW50LmVxdWFscyhoZEtleVBhaXIuZmluZ2VycHJpbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIGJpcER2O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigodikgPT4gISF2KSBhcyBUYXBCaXAzMkRlcml2YXRpb25bXTtcbiAgICBpZiAobXlEZXJpdmF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBvbmUgdGFwQmlwMzJEZXJpdmF0aW9uIG1hc3RlckZpbmdlcnByaW50IHRvIG1hdGNoIHRoZSBIRFNpZ25lciBmaW5nZXJwcmludCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERlcml2ZWROb2RlKGJpcER2OiBUYXBCaXAzMkRlcml2YXRpb24pOiBIRFRhcHJvb3RNdXNpZzJTaWduZXIgfCBIRFRhcHJvb3RTaWduZXIge1xuICAgICAgY29uc3Qgbm9kZSA9IGhkS2V5UGFpci5kZXJpdmVQYXRoKGJpcER2LnBhdGgpO1xuICAgICAgaWYgKCFlcXVhbFB1YmxpY0tleUlnbm9yZVkoYmlwRHYucHVia2V5LCBub2RlLnB1YmxpY0tleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdWJrZXkgZGlkIG5vdCBtYXRjaCB0YXBCaXAzMkRlcml2YXRpb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGlmIChpbnB1dC50YXBMZWFmU2NyaXB0Py5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHNpZ25lcnM6IFRhcHJvb3RTaWduZXJbXSA9IG15RGVyaXZhdGlvbnMubWFwKChiaXBEdikgPT4ge1xuICAgICAgICBjb25zdCBzaWduZXIgPSBnZXREZXJpdmVkTm9kZShiaXBEdik7XG4gICAgICAgIGlmICghKCdzaWduU2Nobm9ycicgaW4gc2lnbmVyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnblNjaG5vcnIgZnVuY3Rpb24gaXMgcmVxdWlyZWQgdG8gc2lnbiBwMnRyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2lnbmVyLCBsZWFmSGFzaGVzOiBiaXBEdi5sZWFmSGFzaGVzIH07XG4gICAgICB9KTtcbiAgICAgIHNpZ25lcnMuZm9yRWFjaCgoeyBzaWduZXIsIGxlYWZIYXNoZXMgfSkgPT4gdGhpcy5zaWduVGFwcm9vdElucHV0KGlucHV0SW5kZXgsIHNpZ25lciwgbGVhZkhhc2hlcywgc2lnaGFzaFR5cGVzKSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dC50YXBJbnRlcm5hbEtleT8ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzaWduZXJzOiBNdXNpZzJTaWduZXJbXSA9IG15RGVyaXZhdGlvbnMubWFwKChiaXBEdikgPT4ge1xuICAgICAgICBjb25zdCBzaWduZXIgPSBnZXREZXJpdmVkTm9kZShiaXBEdik7XG4gICAgICAgIGlmICghKCdwcml2YXRlS2V5JyBpbiBzaWduZXIpIHx8ICFzaWduZXIucHJpdmF0ZUtleSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZUtleSBpcyByZXF1aXJlZCB0byBzaWduIHAydHIgbXVzaWcyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ25lcjtcbiAgICAgIH0pO1xuICAgICAgc2lnbmVycy5mb3JFYWNoKChzaWduZXIpID0+IHRoaXMuc2lnblRhcHJvb3RNdXNpZzJJbnB1dChpbnB1dEluZGV4LCBzaWduZXIsIHsgc2lnaGFzaFR5cGVzLCBkZXRlcm1pbmlzdGljIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzaWduSW5wdXQoaW5wdXRJbmRleDogbnVtYmVyLCBrZXlQYWlyOiBTaWduZXIsIHNpZ2hhc2hUeXBlcz86IG51bWJlcltdKTogdGhpcyB7XG4gICAgY29uc3QgeyBzaWdoYXNoVHlwZXM6IHNpZ2hhc2hGb3JOZXR3b3JrIH0gPSB0b1NpZ25hdHVyZVBhcmFtcyh0aGlzLm5ldHdvcmssIHNpZ2hhc2hUeXBlcyk7XG4gICAgcmV0dXJuIHN1cGVyLnNpZ25JbnB1dChpbnB1dEluZGV4LCBrZXlQYWlyLCBzaWdoYXNoRm9yTmV0d29yayk7XG4gIH1cblxuICBzaWduSW5wdXRIRChcbiAgICBpbnB1dEluZGV4OiBudW1iZXIsXG4gICAgaGRLZXlQYWlyOiBIRFRhcHJvb3RTaWduZXIgfCBIRFRhcHJvb3RNdXNpZzJTaWduZXIsXG4gICAgcGFyYW1zPzogbnVtYmVyW10gfCBQYXJ0aWFsPFNpZ25hdHVyZVBhcmFtcz5cbiAgKTogdGhpcyB7XG4gICAgY29uc3QgeyBzaWdoYXNoVHlwZXMsIGRldGVybWluaXN0aWMgfSA9IHRvU2lnbmF0dXJlUGFyYW1zKHRoaXMubmV0d29yaywgcGFyYW1zKTtcbiAgICBpZiAodGhpcy5pc1RhcHJvb3RJbnB1dChpbnB1dEluZGV4KSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2lnblRhcHJvb3RJbnB1dEhEKGlucHV0SW5kZXgsIGhkS2V5UGFpciwgeyBzaWdoYXNoVHlwZXMsIGRldGVybWluaXN0aWMgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5zaWduSW5wdXRIRChpbnB1dEluZGV4LCBoZEtleVBhaXIsIHNpZ2hhc2hUeXBlcyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRNdXNpZzJQYXJ0aWNpcGFudHMoaW5wdXRJbmRleDogbnVtYmVyLCB0YXBJbnRlcm5hbEtleTogQnVmZmVyLCB0YXBNZXJrbGVSb290OiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYXJ0aWNpcGFudHNLZXlWYWxEYXRhID0gcGFyc2VQc2J0TXVzaWcyUGFydGljaXBhbnRzKHRoaXMuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF0pO1xuICAgIGlmICghcGFydGljaXBhbnRzS2V5VmFsRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCAwIG1hdGNoaW5nIHBhcnRpY2lwYW50IGtleSB2YWx1ZSBpbnN0ZWFkIG9mIDFgKTtcbiAgICB9XG4gICAgYXNzZXJ0UHNidE11c2lnMlBhcnRpY2lwYW50cyhwYXJ0aWNpcGFudHNLZXlWYWxEYXRhLCB0YXBJbnRlcm5hbEtleSwgdGFwTWVya2xlUm9vdCk7XG4gICAgcmV0dXJuIHBhcnRpY2lwYW50c0tleVZhbERhdGE7XG4gIH1cblxuICBwcml2YXRlIGdldE11c2lnMk5vbmNlcyhpbnB1dEluZGV4OiBudW1iZXIsIHBhcnRpY2lwYW50c0tleVZhbERhdGE6IFBzYnRNdXNpZzJQYXJ0aWNpcGFudHMpIHtcbiAgICBjb25zdCBub25jZXNLZXlWYWxzRGF0YSA9IHBhcnNlUHNidE11c2lnMk5vbmNlcyh0aGlzLmRhdGEuaW5wdXRzW2lucHV0SW5kZXhdKTtcbiAgICBpZiAoIW5vbmNlc0tleVZhbHNEYXRhIHx8ICFpc1R1cGxlKG5vbmNlc0tleVZhbHNEYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRm91bmQgJHtub25jZXNLZXlWYWxzRGF0YT8ubGVuZ3RoID8gbm9uY2VzS2V5VmFsc0RhdGEubGVuZ3RoIDogMH0gbWF0Y2hpbmcgbm9uY2Uga2V5IHZhbHVlIGluc3RlYWQgb2YgMmBcbiAgICAgICk7XG4gICAgfVxuICAgIGFzc2VydFBzYnRNdXNpZzJOb25jZXMobm9uY2VzS2V5VmFsc0RhdGEsIHBhcnRpY2lwYW50c0tleVZhbERhdGEpO1xuICAgIHJldHVybiBub25jZXNLZXlWYWxzRGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyBwMnRyIG11c2lnMiBrZXkgcGF0aCBpbnB1dCB3aXRoIDIgYWdncmVnYXRlZCBrZXlzLlxuICAgKlxuICAgKiBOb3RlOiBPbmx5IGNhbiBzaWduIGRldGVybWluaXN0aWNhbGx5IGFzIHRoZSBjb3NpZ25lclxuICAgKiBAcGFyYW0gaW5wdXRJbmRleFxuICAgKiBAcGFyYW0gc2lnbmVyIC0gWFkgcHVibGljIGtleSBhbmQgcHJpdmF0ZSBrZXkgYXJlIHJlcXVpcmVkXG4gICAqIEBwYXJhbSBzaWdoYXNoVHlwZXNcbiAgICogQHBhcmFtIGRldGVybWluaXN0aWMgSWYgdHJ1ZSwgc2lnbiB0aGUgbXVzaWcgaW5wdXQgZGV0ZXJtaW5pc3RpY2FsbHlcbiAgICovXG4gIHNpZ25UYXByb290TXVzaWcySW5wdXQoXG4gICAgaW5wdXRJbmRleDogbnVtYmVyLFxuICAgIHNpZ25lcjogTXVzaWcyU2lnbmVyLFxuICAgIHsgc2lnaGFzaFR5cGVzID0gW1RyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVCwgVHJhbnNhY3Rpb24uU0lHSEFTSF9BTExdLCBkZXRlcm1pbmlzdGljID0gZmFsc2UgfSA9IHt9XG4gICk6IHRoaXMge1xuICAgIGlmICghdGhpcy5pc1RhcHJvb3RLZXlQYXRoSW5wdXQoaW5wdXRJbmRleCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGEgdGFwcm9vdCBtdXNpZzIgaW5wdXQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF07XG5cbiAgICBpZiAoIWlucHV0LnRhcEludGVybmFsS2V5IHx8ICFpbnB1dC50YXBNZXJrbGVSb290KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgaW5wdXQgZGF0YScpO1xuICAgIH1cblxuICAgIC8vIFJldHJpZXZlIGFuZCBjaGVjayB0aGF0IHdlIGhhdmUgdHdvIHBhcnRpY2lwYW50IG5vbmNlc1xuICAgIGNvbnN0IHBhcnRpY2lwYW50cyA9IHRoaXMuZ2V0TXVzaWcyUGFydGljaXBhbnRzKGlucHV0SW5kZXgsIGlucHV0LnRhcEludGVybmFsS2V5LCBpbnB1dC50YXBNZXJrbGVSb290KTtcbiAgICBjb25zdCB7IHRhcE91dHB1dEtleSwgcGFydGljaXBhbnRQdWJLZXlzIH0gPSBwYXJ0aWNpcGFudHM7XG4gICAgY29uc3Qgc2lnbmVyUHViS2V5ID0gcGFydGljaXBhbnRQdWJLZXlzLmZpbmQoKHB1YktleSkgPT4gZXF1YWxQdWJsaWNLZXlJZ25vcmVZKHB1YktleSwgc2lnbmVyLnB1YmxpY0tleSkpO1xuICAgIGlmICghc2lnbmVyUHViS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25lciBwdWIga2V5IHNob3VsZCBtYXRjaCBvbmUgb2YgcGFydGljaXBhbnQgcHViIGtleXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBub25jZXMgPSB0aGlzLmdldE11c2lnMk5vbmNlcyhpbnB1dEluZGV4LCBwYXJ0aWNpcGFudHMpO1xuICAgIGNvbnN0IHsgaGFzaCwgc2lnaGFzaFR5cGUgfSA9IHRoaXMuZ2V0VGFwcm9vdEhhc2hGb3JTaWcoaW5wdXRJbmRleCwgc2lnaGFzaFR5cGVzKTtcblxuICAgIGxldCBwYXJ0aWFsU2lnOiBCdWZmZXI7XG4gICAgaWYgKGRldGVybWluaXN0aWMpIHtcbiAgICAgIGlmICghZXF1YWxQdWJsaWNLZXlJZ25vcmVZKHNpZ25lclB1YktleSwgcGFydGljaXBhbnRQdWJLZXlzWzFdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbiBvbmx5IGFkZCBhIGRldGVybWluaXN0aWMgc2lnbmF0dXJlIG9uIHRoZSBjb3NpZ25lcicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaXJzdFNpZ25lck5vbmNlID0gbm9uY2VzLmZpbmQoKG4pID0+IGVxdWFsUHVibGljS2V5SWdub3JlWShuLnBhcnRpY2lwYW50UHViS2V5LCBwYXJ0aWNpcGFudFB1YktleXNbMF0pKTtcbiAgICAgIGlmICghZmlyc3RTaWduZXJOb25jZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCBmaW5kIHRoZSB1c2VyIG5vbmNlJyk7XG4gICAgICB9XG5cbiAgICAgIHBhcnRpYWxTaWcgPSBtdXNpZzJEZXRlcm1pbmlzdGljU2lnbih7XG4gICAgICAgIHByaXZhdGVLZXk6IHNpZ25lci5wcml2YXRlS2V5LFxuICAgICAgICBvdGhlck5vbmNlOiBmaXJzdFNpZ25lck5vbmNlLnB1Yk5vbmNlLFxuICAgICAgICBwdWJsaWNLZXlzOiBwYXJ0aWNpcGFudFB1YktleXMsXG4gICAgICAgIGludGVybmFsUHViS2V5OiBpbnB1dC50YXBJbnRlcm5hbEtleSxcbiAgICAgICAgdGFwVHJlZVJvb3Q6IGlucHV0LnRhcE1lcmtsZVJvb3QsXG4gICAgICAgIGhhc2gsXG4gICAgICB9KS5zaWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNlc3Npb25LZXkgPSBjcmVhdGVNdXNpZzJTaWduaW5nU2Vzc2lvbih7XG4gICAgICAgIHB1Yk5vbmNlczogW25vbmNlc1swXS5wdWJOb25jZSwgbm9uY2VzWzFdLnB1Yk5vbmNlXSxcbiAgICAgICAgcHViS2V5czogcGFydGljaXBhbnRQdWJLZXlzLFxuICAgICAgICB0eEhhc2g6IGhhc2gsXG4gICAgICAgIGludGVybmFsUHViS2V5OiBpbnB1dC50YXBJbnRlcm5hbEtleSxcbiAgICAgICAgdGFwVHJlZVJvb3Q6IGlucHV0LnRhcE1lcmtsZVJvb3QsXG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2lnbmVyTm9uY2UgPSBub25jZXMuZmluZCgoa3YpID0+IGVxdWFsUHVibGljS2V5SWdub3JlWShrdi5wYXJ0aWNpcGFudFB1YktleSwgc2lnbmVyUHViS2V5KSk7XG4gICAgICBpZiAoIXNpZ25lck5vbmNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHViTm9uY2UgaXMgbWlzc2luZy4gcmV0cnkgc2lnbmluZyBwcm9jZXNzJyk7XG4gICAgICB9XG4gICAgICBwYXJ0aWFsU2lnID0gbXVzaWcyUGFydGlhbFNpZ24oc2lnbmVyLnByaXZhdGVLZXksIHNpZ25lck5vbmNlLnB1Yk5vbmNlLCBzZXNzaW9uS2V5LCB0aGlzLm5vbmNlU3RvcmUpO1xuICAgIH1cblxuICAgIGlmIChzaWdoYXNoVHlwZSAhPT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxUKSB7XG4gICAgICBwYXJ0aWFsU2lnID0gQnVmZmVyLmNvbmNhdChbcGFydGlhbFNpZywgQnVmZmVyLm9mKHNpZ2hhc2hUeXBlKV0pO1xuICAgIH1cblxuICAgIGNvbnN0IHNpZyA9IGVuY29kZVBzYnRNdXNpZzJQYXJ0aWFsU2lnKHtcbiAgICAgIHBhcnRpY2lwYW50UHViS2V5OiBzaWduZXJQdWJLZXksXG4gICAgICB0YXBPdXRwdXRLZXksXG4gICAgICBwYXJ0aWFsU2lnOiBwYXJ0aWFsU2lnLFxuICAgIH0pO1xuICAgIHRoaXMuYWRkUHJvcHJpZXRhcnlLZXlWYWxUb0lucHV0KGlucHV0SW5kZXgsIHNpZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzaWduVGFwcm9vdElucHV0KFxuICAgIGlucHV0SW5kZXg6IG51bWJlcixcbiAgICBzaWduZXI6IFNjaG5vcnJTaWduZXIsXG4gICAgbGVhZkhhc2hlczogQnVmZmVyW10sXG4gICAgc2lnaGFzaFR5cGVzOiBudW1iZXJbXSA9IFtUcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFQsIFRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMXVxuICApOiB0aGlzIHtcbiAgICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgLy8gRmlndXJlIG91dCBpZiB0aGlzIGlzIHNjcmlwdCBwYXRoIG9yIG5vdCwgaWYgbm90LCB0d2VhayB0aGUgcHJpdmF0ZSBrZXlcbiAgICBpZiAoIWlucHV0LnRhcExlYWZTY3JpcHQ/Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXBMZWFmU2NyaXB0IGlzIHJlcXVpcmVkIGZvciBwMnRyIHNjcmlwdCBwYXRoJyk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmtleSA9IHRvWE9ubHlQdWJsaWNLZXkoc2lnbmVyLnB1YmxpY0tleSk7XG4gICAgaWYgKGlucHV0LnRhcExlYWZTY3JpcHQubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIGxlYWYgc2NyaXB0IHN1cHBvcnRlZCBmb3Igc2lnbmluZycpO1xuICAgIH1cbiAgICBjb25zdCBbdGFwTGVhZlNjcmlwdF0gPSBpbnB1dC50YXBMZWFmU2NyaXB0O1xuXG4gICAgaWYgKHRoaXMuaXNNdWx0aXNpZ1RhcHJvb3RTY3JpcHQodGFwTGVhZlNjcmlwdC5zY3JpcHQpKSB7XG4gICAgICBjb25zdCBwdWJLZXlzID0gcGFyc2VQdWJTY3JpcHQyT2YzKHRhcExlYWZTY3JpcHQuc2NyaXB0LCAndGFwcm9vdFNjcmlwdFBhdGhTcGVuZCcpLnB1YmxpY0tleXM7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHB1YktleXMuZmluZCgocGspID0+IHB1YmtleS5lcXVhbHMocGspKSxcbiAgICAgICAgJ3B1YmxpYyBrZXkgbm90IGZvdW5kIGluIHRhcCBsZWFmIHNjcmlwdCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkQ29udHJvbEJsb2NrID0gdGFwcm9vdC5wYXJzZUNvbnRyb2xCbG9jayhlY2NMaWIsIHRhcExlYWZTY3JpcHQuY29udHJvbEJsb2NrKTtcbiAgICBjb25zdCB7IGxlYWZWZXJzaW9uIH0gPSBwYXJzZWRDb250cm9sQmxvY2s7XG4gICAgaWYgKGxlYWZWZXJzaW9uICE9PSB0YXBMZWFmU2NyaXB0LmxlYWZWZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhcCBzY3JpcHQgbGVhZiB2ZXJzaW9uIG1pc21hdGNoIHdpdGggY29udHJvbCBibG9jaycpO1xuICAgIH1cbiAgICBjb25zdCBsZWFmSGFzaCA9IHRhcHJvb3QuZ2V0VGFwbGVhZkhhc2goZWNjTGliLCBwYXJzZWRDb250cm9sQmxvY2ssIHRhcExlYWZTY3JpcHQuc2NyaXB0KTtcbiAgICBpZiAoIWxlYWZIYXNoZXMuZmluZCgobCkgPT4gbC5lcXVhbHMobGVhZkhhc2gpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaWduZXIgY2Fubm90IHNpZ24gZm9yIGxlYWYgaGFzaCAke2xlYWZIYXNoLnRvU3RyaW5nKCdoZXgnKX1gKTtcbiAgICB9XG4gICAgY29uc3QgeyBoYXNoLCBzaWdoYXNoVHlwZSB9ID0gdGhpcy5nZXRUYXByb290SGFzaEZvclNpZyhpbnB1dEluZGV4LCBzaWdoYXNoVHlwZXMsIGxlYWZIYXNoKTtcbiAgICBsZXQgc2lnbmF0dXJlID0gc2lnbmVyLnNpZ25TY2hub3JyKGhhc2gpO1xuICAgIGlmIChzaWdoYXNoVHlwZSAhPT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxUKSB7XG4gICAgICBzaWduYXR1cmUgPSBCdWZmZXIuY29uY2F0KFtzaWduYXR1cmUsIEJ1ZmZlci5vZihzaWdoYXNoVHlwZSldKTtcbiAgICB9XG4gICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHtcbiAgICAgIHRhcFNjcmlwdFNpZzogW1xuICAgICAgICB7XG4gICAgICAgICAgcHVia2V5LFxuICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICBsZWFmSGFzaCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwcml2YXRlIGdldFRhcHJvb3RPdXRwdXRTY3JpcHQoaW5wdXRJbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3QgaW5wdXQgPSBjaGVja0ZvcklucHV0KHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgIGlmIChpbnB1dC50YXBMZWFmU2NyaXB0Py5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0YXByb290LmNyZWF0ZVRhcHJvb3RPdXRwdXRTY3JpcHQoe1xuICAgICAgICBjb250cm9sQmxvY2s6IGlucHV0LnRhcExlYWZTY3JpcHRbMF0uY29udHJvbEJsb2NrLFxuICAgICAgICBsZWFmU2NyaXB0OiBpbnB1dC50YXBMZWFmU2NyaXB0WzBdLnNjcmlwdCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQudGFwSW50ZXJuYWxLZXkgJiYgaW5wdXQudGFwTWVya2xlUm9vdCkge1xuICAgICAgcmV0dXJuIHRhcHJvb3QuY3JlYXRlVGFwcm9vdE91dHB1dFNjcmlwdCh7XG4gICAgICAgIGludGVybmFsUHViS2V5OiBpbnB1dC50YXBJbnRlcm5hbEtleSxcbiAgICAgICAgdGFwdHJlZVJvb3Q6IGlucHV0LnRhcE1lcmtsZVJvb3QsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgYSB0YXByb290IGlucHV0Jyk7XG4gIH1cblxuICBwcml2YXRlIGdldFRhcHJvb3RIYXNoRm9yU2lnKFxuICAgIGlucHV0SW5kZXg6IG51bWJlcixcbiAgICBzaWdoYXNoVHlwZXM/OiBudW1iZXJbXSxcbiAgICBsZWFmSGFzaD86IEJ1ZmZlclxuICApOiB7XG4gICAgaGFzaDogQnVmZmVyO1xuICAgIHNpZ2hhc2hUeXBlOiBudW1iZXI7XG4gIH0ge1xuICAgIGlmICghdGhpcy5pc1RhcHJvb3RJbnB1dChpbnB1dEluZGV4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgYSB0YXByb290IGlucHV0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ2hhc2hUeXBlID0gdGhpcy5kYXRhLmlucHV0c1tpbnB1dEluZGV4XS5zaWdoYXNoVHlwZSB8fCBUcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFQ7XG4gICAgaWYgKHNpZ2hhc2hUeXBlcyAmJiBzaWdoYXNoVHlwZXMuaW5kZXhPZihzaWdoYXNoVHlwZSkgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBTaWdoYXNoIHR5cGUgaXMgbm90IGFsbG93ZWQuIFJldHJ5IHRoZSBzaWduIG1ldGhvZCBwYXNzaW5nIHRoZSBgICtcbiAgICAgICAgICBgc2lnaGFzaFR5cGVzIGFycmF5IG9mIHdoaXRlbGlzdGVkIHR5cGVzLiBTaWdoYXNoIHR5cGU6ICR7c2lnaGFzaFR5cGV9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdHhJbnB1dHMgPSB0aGlzLnR4SW5wdXRzOyAvLyBUaGVzZSBhcmUgc29tZXdoYXQgY29zdGx5IHRvIGV4dHJhY3RcbiAgICBjb25zdCBwcmV2b3V0U2NyaXB0czogQnVmZmVyW10gPSBbXTtcbiAgICBjb25zdCBwcmV2b3V0VmFsdWVzOiBiaWdpbnRbXSA9IFtdO1xuXG4gICAgdGhpcy5kYXRhLmlucHV0cy5mb3JFYWNoKChpbnB1dCwgaSkgPT4ge1xuICAgICAgbGV0IHByZXZvdXQ7XG4gICAgICBpZiAoaW5wdXQubm9uV2l0bmVzc1V0eG8pIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjb3VsZCBiZSBjb3N0bHksIGVpdGhlciBjYWNoZSBpdCBoZXJlLCBvciBmaW5kIGEgd2F5IHRvIHNoYXJlIHdpdGggc3VwZXJcbiAgICAgICAgY29uc3Qgbm9uV2l0bmVzc1V0eG9UeCA9ICh0aGlzLmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBVdHhvUHNidCkudHJhbnNhY3Rpb25Gcm9tQnVmZmVyKFxuICAgICAgICAgIGlucHV0Lm5vbldpdG5lc3NVdHhvLFxuICAgICAgICAgIHRoaXMudHgubmV0d29ya1xuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHByZXZvdXRIYXNoID0gdHhJbnB1dHNbaV0uaGFzaDtcbiAgICAgICAgY29uc3QgdXR4b0hhc2ggPSBub25XaXRuZXNzVXR4b1R4LmdldEhhc2goKTtcblxuICAgICAgICAvLyBJZiBhIG5vbi13aXRuZXNzIFVUWE8gaXMgcHJvdmlkZWQsIGl0cyBoYXNoIG11c3QgbWF0Y2ggdGhlIGhhc2ggc3BlY2lmaWVkIGluIHRoZSBwcmV2b3V0XG4gICAgICAgIGlmICghcHJldm91dEhhc2guZXF1YWxzKHV0eG9IYXNoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uLXdpdG5lc3MgVVRYTyBoYXNoIGZvciBpbnB1dCAjJHtpfSBkb2Vzbid0IG1hdGNoIHRoZSBoYXNoIHNwZWNpZmllZCBpbiB0aGUgcHJldm91dGApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJldm91dEluZGV4ID0gdHhJbnB1dHNbaV0uaW5kZXg7XG4gICAgICAgIHByZXZvdXQgPSBub25XaXRuZXNzVXR4b1R4Lm91dHNbcHJldm91dEluZGV4XTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQud2l0bmVzc1V0eG8pIHtcbiAgICAgICAgcHJldm91dCA9IGlucHV0LndpdG5lc3NVdHhvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIGEgVXR4byBpbnB1dCBpdGVtIGZvciBzaWduaW5nJyk7XG4gICAgICB9XG4gICAgICBwcmV2b3V0U2NyaXB0cy5wdXNoKHByZXZvdXQuc2NyaXB0KTtcbiAgICAgIHByZXZvdXRWYWx1ZXMucHVzaChwcmV2b3V0LnZhbHVlKTtcbiAgICB9KTtcbiAgICBjb25zdCBvdXRwdXRTY3JpcHQgPSB0aGlzLmdldFRhcHJvb3RPdXRwdXRTY3JpcHQoaW5wdXRJbmRleCk7XG4gICAgaWYgKCFvdXRwdXRTY3JpcHQuZXF1YWxzKHByZXZvdXRTY3JpcHRzW2lucHV0SW5kZXhdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaXRuZXNzIHNjcmlwdCBmb3IgaW5wdXQgIyR7aW5wdXRJbmRleH0gZG9lc24ndCBtYXRjaCB0aGUgc2NyaXB0UHViS2V5IGluIHRoZSBwcmV2b3V0YCk7XG4gICAgfVxuICAgIGNvbnN0IGhhc2ggPSB0aGlzLnR4Lmhhc2hGb3JXaXRuZXNzVjEoaW5wdXRJbmRleCwgcHJldm91dFNjcmlwdHMsIHByZXZvdXRWYWx1ZXMsIHNpZ2hhc2hUeXBlLCBsZWFmSGFzaCk7XG4gICAgcmV0dXJuIHsgaGFzaCwgc2lnaGFzaFR5cGUgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHByb3ByaWV0YXJ5IGtleSB2YWx1ZSBwYWlyIHRvIFBTQlQgaW5wdXQuXG4gICAqIERlZmF1bHQgaWRlbnRpZmllckVuY29kaW5nIGlzIHV0Zi04IGZvciBpZGVudGlmaWVyLlxuICAgKi9cbiAgYWRkUHJvcHJpZXRhcnlLZXlWYWxUb0lucHV0KGlucHV0SW5kZXg6IG51bWJlciwga2V5VmFsdWVEYXRhOiBQcm9wcmlldGFyeUtleVZhbHVlKTogdGhpcyB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVW5rbm93bktleVZhbFRvSW5wdXQoaW5wdXRJbmRleCwge1xuICAgICAga2V5OiBlbmNvZGVQcm9wcmlldGFyeUtleShrZXlWYWx1ZURhdGEua2V5KSxcbiAgICAgIHZhbHVlOiBrZXlWYWx1ZURhdGEudmFsdWUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIChpZiBleGlzdHMpIHByb3ByaWV0YXJ5IGtleSB2YWx1ZSBwYWlyIHRvIFBTQlQgaW5wdXQuXG4gICAqIERlZmF1bHQgaWRlbnRpZmllckVuY29kaW5nIGlzIHV0Zi04IGZvciBpZGVudGlmaWVyLlxuICAgKi9cbiAgYWRkT3JVcGRhdGVQcm9wcmlldGFyeUtleVZhbFRvSW5wdXQoaW5wdXRJbmRleDogbnVtYmVyLCBrZXlWYWx1ZURhdGE6IFByb3ByaWV0YXJ5S2V5VmFsdWUpOiB0aGlzIHtcbiAgICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgY29uc3Qga2V5ID0gZW5jb2RlUHJvcHJpZXRhcnlLZXkoa2V5VmFsdWVEYXRhLmtleSk7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0ga2V5VmFsdWVEYXRhO1xuICAgIGlmIChpbnB1dC51bmtub3duS2V5VmFscz8ubGVuZ3RoKSB7XG4gICAgICBjb25zdCB1a3ZJbmRleCA9IGlucHV0LnVua25vd25LZXlWYWxzLmZpbmRJbmRleCgodWt2KSA9PiB1a3Yua2V5LmVxdWFscyhrZXkpKTtcbiAgICAgIGlmICh1a3ZJbmRleCA+IC0xKSB7XG4gICAgICAgIGlucHV0LnVua25vd25LZXlWYWxzW3VrdkluZGV4XSA9IHsga2V5LCB2YWx1ZSB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZGRVbmtub3duS2V5VmFsVG9JbnB1dChpbnB1dEluZGV4LCB7XG4gICAgICBrZXksXG4gICAgICB2YWx1ZSxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUbyBzZWFyY2ggYW55IGRhdGEgZnJvbSBwcm9wcmlldGFyeSBrZXkgdmFsdWUgYWdhaW5zdCBrZXlkYXRhLlxuICAgKiBEZWZhdWx0IGlkZW50aWZpZXJFbmNvZGluZyBpcyB1dGYtOCBmb3IgaWRlbnRpZmllci5cbiAgICovXG4gIGdldFByb3ByaWV0YXJ5S2V5VmFscyhpbnB1dEluZGV4OiBudW1iZXIsIGtleVNlYXJjaD86IFByb3ByaWV0YXJ5S2V5U2VhcmNoKTogUHJvcHJpZXRhcnlLZXlWYWx1ZVtdIHtcbiAgICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgcmV0dXJuIGdldFBzYnRJbnB1dFByb3ByaWV0YXJ5S2V5VmFscyhpbnB1dCwga2V5U2VhcmNoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUbyBkZWxldGUgYW55IGRhdGEgZnJvbSBwcm9wcmlldGFyeSBrZXkgdmFsdWUuXG4gICAqIERlZmF1bHQgaWRlbnRpZmllckVuY29kaW5nIGlzIHV0Zi04IGZvciBpZGVudGlmaWVyLlxuICAgKi9cbiAgZGVsZXRlUHJvcHJpZXRhcnlLZXlWYWxzKGlucHV0SW5kZXg6IG51bWJlciwga2V5c1RvRGVsZXRlPzogUHJvcHJpZXRhcnlLZXlTZWFyY2gpOiB0aGlzIHtcbiAgICBjb25zdCBpbnB1dCA9IGNoZWNrRm9ySW5wdXQodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgaWYgKCFpbnB1dC51bmtub3duS2V5VmFscz8ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKGtleXNUb0RlbGV0ZSAmJiBrZXlzVG9EZWxldGUuc3VidHlwZSA9PT0gdW5kZWZpbmVkICYmIEJ1ZmZlci5pc0J1ZmZlcihrZXlzVG9EZWxldGUua2V5ZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcm9wcmlldGFyeSBrZXkgc2VhcmNoIGZpbHRlciBjb21iaW5hdGlvbi4gc3VidHlwZSBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpbnB1dC51bmtub3duS2V5VmFscyA9IGlucHV0LnVua25vd25LZXlWYWxzLmZpbHRlcigoa2V5VmFsdWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGRlY29kZVByb3ByaWV0YXJ5S2V5KGtleVZhbHVlLmtleSk7XG4gICAgICByZXR1cm4gIShcbiAgICAgICAga2V5c1RvRGVsZXRlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKGtleXNUb0RlbGV0ZS5pZGVudGlmaWVyID09PSBrZXkuaWRlbnRpZmllciAmJlxuICAgICAgICAgIChrZXlzVG9EZWxldGUuc3VidHlwZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoa2V5c1RvRGVsZXRlLnN1YnR5cGUgPT09IGtleS5zdWJ0eXBlICYmXG4gICAgICAgICAgICAgICghQnVmZmVyLmlzQnVmZmVyKGtleXNUb0RlbGV0ZS5rZXlkYXRhKSB8fCBrZXlzVG9EZWxldGUua2V5ZGF0YS5lcXVhbHMoa2V5LmtleWRhdGEpKSkpKVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlTXVzaWcyTm9uY2VGb3JJbnB1dChcbiAgICBpbnB1dEluZGV4OiBudW1iZXIsXG4gICAga2V5UGFpcjogQklQMzJJbnRlcmZhY2UsXG4gICAga2V5VHlwZTogJ3Jvb3QnIHwgJ2Rlcml2ZWQnLFxuICAgIHBhcmFtczogeyBzZXNzaW9uSWQ/OiBCdWZmZXI7IGRldGVybWluaXN0aWM/OiBib29sZWFuIH0gPSB7IGRldGVybWluaXN0aWM6IGZhbHNlIH1cbiAgKTogUHNidE11c2lnMlB1Yk5vbmNlIHtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF07XG4gICAgaWYgKCFpbnB1dC50YXBJbnRlcm5hbEtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXBJbnRlcm5hbEtleSBpcyByZXF1aXJlZCB0byBjcmVhdGUgbm9uY2UnKTtcbiAgICB9XG4gICAgaWYgKCFpbnB1dC50YXBNZXJrbGVSb290KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcE1lcmtsZVJvb3QgaXMgcmVxdWlyZWQgdG8gY3JlYXRlIG5vbmNlJyk7XG4gICAgfVxuICAgIGNvbnN0IGdldERlcml2ZWRLZXlQYWlyID0gKCk6IEJJUDMySW50ZXJmYWNlID0+IHtcbiAgICAgIGlmICghaW5wdXQudGFwQmlwMzJEZXJpdmF0aW9uPy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXBCaXAzMkRlcml2YXRpb24gaXMgcmVxdWlyZWQgdG8gY3JlYXRlIG5vbmNlJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXJpdmVkID0gVXR4b1BzYnQuZGVyaXZlS2V5UGFpcihrZXlQYWlyLCBpbnB1dC50YXBCaXAzMkRlcml2YXRpb24sIHsgaWdub3JlWTogdHJ1ZSB9KTtcbiAgICAgIGlmICghZGVyaXZlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGJpcDMyRGVyaXZhdGlvbiBtYXN0ZXJGaW5nZXJwcmludCBtYXRjaGVkIHRoZSBIRCBrZXlQYWlyIGZpbmdlcnByaW50Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVyaXZlZDtcbiAgICB9O1xuICAgIGNvbnN0IGRlcml2ZWRLZXlQYWlyID0ga2V5VHlwZSA9PT0gJ3Jvb3QnID8gZ2V0RGVyaXZlZEtleVBhaXIoKSA6IGtleVBhaXI7XG4gICAgaWYgKCFkZXJpdmVkS2V5UGFpci5wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByaXZhdGVLZXkgaXMgcmVxdWlyZWQgdG8gY3JlYXRlIG5vbmNlJyk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRpY2lwYW50cyA9IHBhcnNlUHNidE11c2lnMlBhcnRpY2lwYW50cyhpbnB1dCk7XG4gICAgaWYgKCFwYXJ0aWNpcGFudHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRm91bmQgMCBtYXRjaGluZyBwYXJ0aWNpcGFudCBrZXkgdmFsdWUgaW5zdGVhZCBvZiAxYCk7XG4gICAgfVxuICAgIGFzc2VydFBzYnRNdXNpZzJQYXJ0aWNpcGFudHMocGFydGljaXBhbnRzLCBpbnB1dC50YXBJbnRlcm5hbEtleSwgaW5wdXQudGFwTWVya2xlUm9vdCk7XG4gICAgY29uc3QgeyB0YXBPdXRwdXRLZXksIHBhcnRpY2lwYW50UHViS2V5cyB9ID0gcGFydGljaXBhbnRzO1xuXG4gICAgY29uc3QgcGFydGljaXBhbnRQdWJLZXkgPSBwYXJ0aWNpcGFudFB1YktleXMuZmluZCgocHViS2V5KSA9PlxuICAgICAgZXF1YWxQdWJsaWNLZXlJZ25vcmVZKHB1YktleSwgZGVyaXZlZEtleVBhaXIucHVibGljS2V5KVxuICAgICk7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFydGljaXBhbnRQdWJLZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRpY2lwYW50IHBsYWluIHB1YiBrZXkgc2hvdWxkIG1hdGNoIG9uZSBiaXAzMkRlcml2YXRpb24gcGxhaW4gcHViIGtleScpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgaGFzaCB9ID0gdGhpcy5nZXRUYXByb290SGFzaEZvclNpZyhpbnB1dEluZGV4KTtcblxuICAgIGxldCBwdWJOb25jZTogQnVmZmVyO1xuICAgIGlmIChwYXJhbXMuZGV0ZXJtaW5pc3RpYykge1xuICAgICAgaWYgKHBhcmFtcy5zZXNzaW9uSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGV4dHJhIGVudHJvcHkgd2hlbiBnZW5lcmF0aW5nIGEgZGV0ZXJtaW5pc3RpYyBub25jZScpO1xuICAgICAgfVxuICAgICAgLy8gVGhlcmUgbXVzdCBiZSBvbmx5IDIgcGFydGljaXBhbnQgcHViS2V5cyBpZiBpdCBnb3QgdG8gdGhpcyBwb2ludFxuICAgICAgaWYgKCFlcXVhbFB1YmxpY0tleUlnbm9yZVkocGFydGljaXBhbnRQdWJLZXksIHBhcnRpY2lwYW50UHViS2V5c1sxXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPbmx5IHRoZSBjb3NpZ25lcidzIG5vbmNlIGNhbiBiZSBzZXQgZGV0ZXJtaW5pc3RpY2FsbHlgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vbmNlcyA9IHBhcnNlUHNidE11c2lnMk5vbmNlcyhpbnB1dCk7XG4gICAgICBpZiAoIW5vbmNlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG5vbmNlcyBmb3VuZCBvbiBpbnB1dCAjJHtpbnB1dEluZGV4fWApO1xuICAgICAgfVxuICAgICAgaWYgKG5vbmNlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGhhdmUgbW9yZSB0aGFuIDIgbm9uY2VzYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBmaXJzdFNpZ25lck5vbmNlID0gbm9uY2VzLmZpbmQoKGt2KSA9PiBlcXVhbFB1YmxpY0tleUlnbm9yZVkoa3YucGFydGljaXBhbnRQdWJLZXksIHBhcnRpY2lwYW50UHViS2V5c1swXSkpO1xuICAgICAgaWYgKCFmaXJzdFNpZ25lck5vbmNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbmVyIG5vbmNlIG11c3QgYmUgc2V0IGlmIGNvc2lnbmVyIG5vbmNlIGlzIHRvIGJlIGRlcml2ZWQgZGV0ZXJtaW5pc3RpY2FsbHknKTtcbiAgICAgIH1cblxuICAgICAgcHViTm9uY2UgPSBjcmVhdGVNdXNpZzJEZXRlcm1pbmlzdGljTm9uY2Uoe1xuICAgICAgICBwcml2YXRlS2V5OiBkZXJpdmVkS2V5UGFpci5wcml2YXRlS2V5LFxuICAgICAgICBvdGhlck5vbmNlOiBmaXJzdFNpZ25lck5vbmNlLnB1Yk5vbmNlLFxuICAgICAgICBwdWJsaWNLZXlzOiBwYXJ0aWNpcGFudFB1YktleXMsXG4gICAgICAgIGludGVybmFsUHViS2V5OiBpbnB1dC50YXBJbnRlcm5hbEtleSxcbiAgICAgICAgdGFwVHJlZVJvb3Q6IGlucHV0LnRhcE1lcmtsZVJvb3QsXG4gICAgICAgIGhhc2gsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHViTm9uY2UgPSBCdWZmZXIuZnJvbShcbiAgICAgICAgdGhpcy5ub25jZVN0b3JlLmNyZWF0ZU11c2lnMk5vbmNlKFxuICAgICAgICAgIGRlcml2ZWRLZXlQYWlyLnByaXZhdGVLZXksXG4gICAgICAgICAgcGFydGljaXBhbnRQdWJLZXksXG4gICAgICAgICAgdGFwT3V0cHV0S2V5LFxuICAgICAgICAgIGhhc2gsXG4gICAgICAgICAgcGFyYW1zLnNlc3Npb25JZFxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7IHRhcE91dHB1dEtleSwgcGFydGljaXBhbnRQdWJLZXksIHB1Yk5vbmNlIH07XG4gIH1cblxuICBwcml2YXRlIHNldE11c2lnMk5vbmNlc0lubmVyKFxuICAgIGtleVBhaXI6IEJJUDMySW50ZXJmYWNlLFxuICAgIGtleVR5cGU6ICdyb290JyB8ICdkZXJpdmVkJyxcbiAgICBpbnB1dEluZGV4PzogbnVtYmVyLFxuICAgIHBhcmFtczogeyBzZXNzaW9uSWQ/OiBCdWZmZXI7IGRldGVybWluaXN0aWM/OiBib29sZWFuIH0gPSB7IGRldGVybWluaXN0aWM6IGZhbHNlIH1cbiAgKTogdGhpcyB7XG4gICAgaWYgKGtleVBhaXIuaXNOZXV0ZXJlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByaXZhdGUga2V5IGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIG5vbmNlJyk7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIocGFyYW1zLnNlc3Npb25JZCkgJiYgcGFyYW1zLnNlc3Npb25JZC5sZW5ndGggIT09IDMyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2Vzc2lvbklkIHNpemUgJHtwYXJhbXMuc2Vzc2lvbklkLmxlbmd0aH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dEluZGV4ZXMgPSBpbnB1dEluZGV4ID09PSB1bmRlZmluZWQgPyBbLi4uQXJyYXkodGhpcy5pbnB1dENvdW50KS5rZXlzKCldIDogW2lucHV0SW5kZXhdO1xuICAgIGlucHV0SW5kZXhlcy5mb3JFYWNoKChpbmRleCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmlzVGFwcm9vdEtleVBhdGhJbnB1dChpbmRleCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9uY2UgPSB0aGlzLmNyZWF0ZU11c2lnMk5vbmNlRm9ySW5wdXQoaW5kZXgsIGtleVBhaXIsIGtleVR5cGUsIHBhcmFtcyk7XG4gICAgICB0aGlzLmFkZE9yVXBkYXRlUHJvcHJpZXRhcnlLZXlWYWxUb0lucHV0KGluZGV4LCBlbmNvZGVQc2J0TXVzaWcyUHViTm9uY2Uobm9uY2UpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW5kIHNldHMgTXVTaWcyIG5vbmNlIHRvIHRhcHJvb3Qga2V5IHBhdGggaW5wdXQgYXQgaW5wdXRJbmRleC5cbiAgICogSWYgaW5wdXQgaXMgbm90IGEgdGFwcm9vdCBrZXkgcGF0aCwgbm8gYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXRJbmRleCBpbnB1dCBpbmRleFxuICAgKiBAcGFyYW0ga2V5UGFpciBkZXJpdmVkIGtleSBwYWlyXG4gICAqIEBwYXJhbSBzZXNzaW9uSWQgT3B0aW9uYWwgZXh0cmEgZW50cm9weS4gSWYgcHJvdmlkZWQgaXQgbXVzdCBlaXRoZXIgYmUgYSBjb3VudGVyIHVuaXF1ZSB0byB0aGlzIHNlY3JldCBrZXksXG4gICAqIChjb252ZXJ0ZWQgdG8gYW4gYXJyYXkgb2YgMzIgYnl0ZXMpLCBvciAzMiB1bmlmb3JtbHkgcmFuZG9tIGJ5dGVzLlxuICAgKiBAcGFyYW0gZGV0ZXJtaW5pc3RpYyBJZiB0cnVlLCBzZXQgdGhlIGNvc2lnbmVyIG5vbmNlIGRldGVybWluaXN0aWNhbGx5XG4gICAqL1xuICBzZXRJbnB1dE11c2lnMk5vbmNlKFxuICAgIGlucHV0SW5kZXg6IG51bWJlcixcbiAgICBkZXJpdmVkS2V5UGFpcjogQklQMzJJbnRlcmZhY2UsXG4gICAgcGFyYW1zOiB7IHNlc3Npb25JZD86IEJ1ZmZlcjsgZGV0ZXJtaW5pc3RpYz86IGJvb2xlYW4gfSA9IHsgZGV0ZXJtaW5pc3RpYzogZmFsc2UgfVxuICApOiB0aGlzIHtcbiAgICByZXR1cm4gdGhpcy5zZXRNdXNpZzJOb25jZXNJbm5lcihkZXJpdmVkS2V5UGFpciwgJ2Rlcml2ZWQnLCBpbnB1dEluZGV4LCBwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbmQgc2V0cyBNdVNpZzIgbm9uY2UgdG8gdGFwcm9vdCBrZXkgcGF0aCBpbnB1dCBhdCBpbnB1dEluZGV4LlxuICAgKiBJZiBpbnB1dCBpcyBub3QgYSB0YXByb290IGtleSBwYXRoLCBubyBhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dEluZGV4IGlucHV0IGluZGV4XG4gICAqIEBwYXJhbSBrZXlQYWlyIEhEIHJvb3Qga2V5IHBhaXJcbiAgICogQHBhcmFtIHNlc3Npb25JZCBPcHRpb25hbCBleHRyYSBlbnRyb3B5LiBJZiBwcm92aWRlZCBpdCBtdXN0IGVpdGhlciBiZSBhIGNvdW50ZXIgdW5pcXVlIHRvIHRoaXMgc2VjcmV0IGtleSxcbiAgICogKGNvbnZlcnRlZCB0byBhbiBhcnJheSBvZiAzMiBieXRlcyksIG9yIDMyIHVuaWZvcm1seSByYW5kb20gYnl0ZXMuXG4gICAqIEBwYXJhbSBkZXRlcm1pbmlzdGljIElmIHRydWUsIHNldCB0aGUgY29zaWduZXIgbm9uY2UgZGV0ZXJtaW5pc3RpY2FsbHlcbiAgICovXG4gIHNldElucHV0TXVzaWcyTm9uY2VIRChcbiAgICBpbnB1dEluZGV4OiBudW1iZXIsXG4gICAga2V5UGFpcjogQklQMzJJbnRlcmZhY2UsXG4gICAgcGFyYW1zOiB7IHNlc3Npb25JZD86IEJ1ZmZlcjsgZGV0ZXJtaW5pc3RpYz86IGJvb2xlYW4gfSA9IHsgZGV0ZXJtaW5pc3RpYzogZmFsc2UgfVxuICApOiB0aGlzIHtcbiAgICBjaGVja0ZvcklucHV0KHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgIHJldHVybiB0aGlzLnNldE11c2lnMk5vbmNlc0lubmVyKGtleVBhaXIsICdyb290JywgaW5wdXRJbmRleCwgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW5kIHNldHMgTXVTaWcyIG5vbmNlIHRvIGFsbCB0YXByb290IGtleSBwYXRoIGlucHV0cy4gT3RoZXIgaW5wdXRzIHdpbGwgYmUgc2tpcHBlZC5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0SW5kZXggaW5wdXQgaW5kZXhcbiAgICogQHBhcmFtIGtleVBhaXIgZGVyaXZlZCBrZXkgcGFpclxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIE9wdGlvbmFsIGV4dHJhIGVudHJvcHkuIElmIHByb3ZpZGVkIGl0IG11c3QgZWl0aGVyIGJlIGEgY291bnRlciB1bmlxdWUgdG8gdGhpcyBzZWNyZXQga2V5LFxuICAgKiAoY29udmVydGVkIHRvIGFuIGFycmF5IG9mIDMyIGJ5dGVzKSwgb3IgMzIgdW5pZm9ybWx5IHJhbmRvbSBieXRlcy5cbiAgICovXG4gIHNldEFsbElucHV0c011c2lnMk5vbmNlKFxuICAgIGtleVBhaXI6IEJJUDMySW50ZXJmYWNlLFxuICAgIHBhcmFtczogeyBzZXNzaW9uSWQ/OiBCdWZmZXI7IGRldGVybWluaXN0aWM/OiBib29sZWFuIH0gPSB7IGRldGVybWluaXN0aWM6IGZhbHNlIH1cbiAgKTogdGhpcyB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TXVzaWcyTm9uY2VzSW5uZXIoa2V5UGFpciwgJ2Rlcml2ZWQnLCB1bmRlZmluZWQsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuZCBzZXRzIE11U2lnMiBub25jZSB0byBhbGwgdGFwcm9vdCBrZXkgcGF0aCBpbnB1dHMuIE90aGVyIGlucHV0cyB3aWxsIGJlIHNraXBwZWQuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dEluZGV4IGlucHV0IGluZGV4XG4gICAqIEBwYXJhbSBrZXlQYWlyIEhEIHJvb3Qga2V5IHBhaXJcbiAgICogQHBhcmFtIHNlc3Npb25JZCBPcHRpb25hbCBleHRyYSBlbnRyb3B5LiBJZiBwcm92aWRlZCBpdCBtdXN0IGVpdGhlciBiZSBhIGNvdW50ZXIgdW5pcXVlIHRvIHRoaXMgc2VjcmV0IGtleSxcbiAgICogKGNvbnZlcnRlZCB0byBhbiBhcnJheSBvZiAzMiBieXRlcyksIG9yIDMyIHVuaWZvcm1seSByYW5kb20gYnl0ZXMuXG4gICAqL1xuICBzZXRBbGxJbnB1dHNNdXNpZzJOb25jZUhEKFxuICAgIGtleVBhaXI6IEJJUDMySW50ZXJmYWNlLFxuICAgIHBhcmFtczogeyBzZXNzaW9uSWQ/OiBCdWZmZXI7IGRldGVybWluaXN0aWM/OiBib29sZWFuIH0gPSB7IGRldGVybWluaXN0aWM6IGZhbHNlIH1cbiAgKTogdGhpcyB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TXVzaWcyTm9uY2VzSW5uZXIoa2V5UGFpciwgJ3Jvb3QnLCB1bmRlZmluZWQsIHBhcmFtcyk7XG4gIH1cblxuICBjbG9uZSgpOiB0aGlzIHtcbiAgICByZXR1cm4gc3VwZXIuY2xvbmUoKSBhcyB0aGlzO1xuICB9XG5cbiAgZXh0cmFjdFRyYW5zYWN0aW9uKGRpc2FibGVGZWVDaGVjayA9IHRydWUpOiBVdHhvVHJhbnNhY3Rpb248YmlnaW50PiB7XG4gICAgY29uc3QgdHggPSBzdXBlci5leHRyYWN0VHJhbnNhY3Rpb24oZGlzYWJsZUZlZUNoZWNrKTtcbiAgICBpZiAodHggaW5zdGFuY2VvZiBVdHhvVHJhbnNhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHRyYWN0VHJhbnNhY3Rpb24gZGlkIG5vdCByZXR1cm4gaW5zdGFjZSBvZiBVdHhvVHJhbnNhY3Rpb24nKTtcbiAgfVxufVxuIl19