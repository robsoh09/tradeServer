"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultWalletKeys = exports.getDefaultCosigner = exports.getKeyName = exports.getUncompressedKeyTriple = exports.getKeyTriple = exports.getKey = void 0;
const bip32_1 = require("bip32");
const crypto = require("crypto");
const bitgo_1 = require("../bitgo");
const noble_ecc_1 = require("../noble_ecc");
const networks_1 = require("../networks");
const bip32 = (0, bip32_1.BIP32Factory)(noble_ecc_1.ecc);
function getKey(seed) {
    return bip32.fromSeed(crypto.createHash('sha256').update(seed).digest());
}
exports.getKey = getKey;
function getKeyTriple(seed) {
    return [getKey(seed + '.0'), getKey(seed + '.1'), getKey(seed + '.2')];
}
exports.getKeyTriple = getKeyTriple;
function getUncompressedKey(input) {
    // Using input for deterministic randomness
    return noble_ecc_1.ECPair.makeRandom({
        compressed: false,
        network: networks_1.networks.testnet,
        rng: () => {
            return Buffer.alloc(32, input);
        },
    });
}
function getUncompressedKeyTriple(inputs) {
    return [getUncompressedKey(inputs[0]), getUncompressedKey(inputs[1]), getUncompressedKey(inputs[2])];
}
exports.getUncompressedKeyTriple = getUncompressedKeyTriple;
function getKeyName(triple, k) {
    return ['user', 'backup', 'bitgo'][triple.indexOf(k)];
}
exports.getKeyName = getKeyName;
function getDefaultCosigner(keyset, signer) {
    const eq = (a, b) => a === b || (Buffer.isBuffer(a) && Buffer.isBuffer(b) && a.equals(b));
    const [user, backup, bitgo] = keyset;
    if (eq(signer, user)) {
        return bitgo;
    }
    if (eq(signer, backup)) {
        return bitgo;
    }
    if (eq(signer, bitgo)) {
        return user;
    }
    throw new Error(`signer not in pubkeys`);
}
exports.getDefaultCosigner = getDefaultCosigner;
function getDefaultWalletKeys() {
    return new bitgo_1.RootWalletKeys(getKeyTriple('default'));
}
exports.getDefaultWalletKeys = getDefaultWalletKeys;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90ZXN0dXRpbC9rZXlzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGlDQUErRDtBQUMvRCxpQ0FBaUM7QUFHakMsb0NBQTBDO0FBQzFDLDRDQUE0RDtBQUM1RCwwQ0FBdUM7QUFFdkMsTUFBTSxLQUFLLEdBQWEsSUFBQSxvQkFBWSxFQUFDLGVBQUcsQ0FBQyxDQUFDO0FBSzFDLFNBQWdCLE1BQU0sQ0FBQyxJQUFZO0lBQ2pDLE9BQU8sS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO0FBQzNFLENBQUM7QUFGRCx3QkFFQztBQUVELFNBQWdCLFlBQVksQ0FBQyxJQUFZO0lBQ3ZDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxFQUFFLE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEVBQUUsTUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3pFLENBQUM7QUFGRCxvQ0FFQztBQUVELFNBQVMsa0JBQWtCLENBQUMsS0FBSztJQUMvQiwyQ0FBMkM7SUFDM0MsT0FBTyxrQkFBTSxDQUFDLFVBQVUsQ0FBQztRQUN2QixVQUFVLEVBQUUsS0FBSztRQUNqQixPQUFPLEVBQUUsbUJBQVEsQ0FBQyxPQUFPO1FBQ3pCLEdBQUcsRUFBRSxHQUFXLEVBQUU7WUFDaEIsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNqQyxDQUFDO0tBQ0YsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELFNBQWdCLHdCQUF3QixDQUFDLE1BQXNCO0lBQzdELE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3ZHLENBQUM7QUFGRCw0REFFQztBQUVELFNBQWdCLFVBQVUsQ0FBQyxNQUE4QixFQUFFLENBQWlCO0lBQzFFLE9BQU8sQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN4RCxDQUFDO0FBRkQsZ0NBRUM7QUFFRCxTQUFnQixrQkFBa0IsQ0FBSSxNQUFpQixFQUFFLE1BQVM7SUFDaEUsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFJLEVBQUUsQ0FBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoRyxNQUFNLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsR0FBRyxNQUFNLENBQUM7SUFDckMsSUFBSSxFQUFFLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxFQUFFO1FBQ3BCLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxJQUFJLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLEVBQUU7UUFDdEIsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUNELElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsRUFBRTtRQUNyQixPQUFPLElBQUksQ0FBQztLQUNiO0lBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBQzNDLENBQUM7QUFiRCxnREFhQztBQUVELFNBQWdCLG9CQUFvQjtJQUNsQyxPQUFPLElBQUksc0JBQWMsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztBQUNyRCxDQUFDO0FBRkQsb0RBRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCSVAzMkFQSSwgQklQMzJGYWN0b3J5LCBCSVAzMkludGVyZmFjZSB9IGZyb20gJ2JpcDMyJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG5pbXBvcnQgeyBUcmlwbGUgfSBmcm9tICcuLi9iaXRnbyc7XG5pbXBvcnQgeyBSb290V2FsbGV0S2V5cyB9IGZyb20gJy4uL2JpdGdvJztcbmltcG9ydCB7IGVjYywgRUNQYWlyLCBFQ1BhaXJJbnRlcmZhY2UgfSBmcm9tICcuLi9ub2JsZV9lY2MnO1xuaW1wb3J0IHsgbmV0d29ya3MgfSBmcm9tICcuLi9uZXR3b3Jrcyc7XG5cbmNvbnN0IGJpcDMyOiBCSVAzMkFQSSA9IEJJUDMyRmFjdG9yeShlY2MpO1xuXG5leHBvcnQgdHlwZSBLZXlUcmlwbGUgPSBUcmlwbGU8QklQMzJJbnRlcmZhY2U+O1xuZXhwb3J0IHR5cGUgVW5jb21wcmVzc2VkS2V5VHJpcGxlID0gVHJpcGxlPEVDUGFpckludGVyZmFjZT47XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXkoc2VlZDogc3RyaW5nKTogQklQMzJJbnRlcmZhY2Uge1xuICByZXR1cm4gYmlwMzIuZnJvbVNlZWQoY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShzZWVkKS5kaWdlc3QoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlUcmlwbGUoc2VlZDogc3RyaW5nKTogS2V5VHJpcGxlIHtcbiAgcmV0dXJuIFtnZXRLZXkoc2VlZCArICcuMCcpLCBnZXRLZXkoc2VlZCArICcuMScpLCBnZXRLZXkoc2VlZCArICcuMicpXTtcbn1cblxuZnVuY3Rpb24gZ2V0VW5jb21wcmVzc2VkS2V5KGlucHV0KSB7XG4gIC8vIFVzaW5nIGlucHV0IGZvciBkZXRlcm1pbmlzdGljIHJhbmRvbW5lc3NcbiAgcmV0dXJuIEVDUGFpci5tYWtlUmFuZG9tKHtcbiAgICBjb21wcmVzc2VkOiBmYWxzZSxcbiAgICBuZXR3b3JrOiBuZXR3b3Jrcy50ZXN0bmV0LFxuICAgIHJuZzogKCk6IEJ1ZmZlciA9PiB7XG4gICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDMyLCBpbnB1dCk7XG4gICAgfSxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmNvbXByZXNzZWRLZXlUcmlwbGUoaW5wdXRzOiBUcmlwbGU8bnVtYmVyPik6IFVuY29tcHJlc3NlZEtleVRyaXBsZSB7XG4gIHJldHVybiBbZ2V0VW5jb21wcmVzc2VkS2V5KGlucHV0c1swXSksIGdldFVuY29tcHJlc3NlZEtleShpbnB1dHNbMV0pLCBnZXRVbmNvbXByZXNzZWRLZXkoaW5wdXRzWzJdKV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlOYW1lKHRyaXBsZTogVHJpcGxlPEJJUDMySW50ZXJmYWNlPiwgazogQklQMzJJbnRlcmZhY2UpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICByZXR1cm4gWyd1c2VyJywgJ2JhY2t1cCcsICdiaXRnbyddW3RyaXBsZS5pbmRleE9mKGspXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRDb3NpZ25lcjxUPihrZXlzZXQ6IFRyaXBsZTxUPiwgc2lnbmVyOiBUKTogVCB7XG4gIGNvbnN0IGVxID0gKGE6IFQsIGI6IFQpID0+IGEgPT09IGIgfHwgKEJ1ZmZlci5pc0J1ZmZlcihhKSAmJiBCdWZmZXIuaXNCdWZmZXIoYikgJiYgYS5lcXVhbHMoYikpO1xuICBjb25zdCBbdXNlciwgYmFja3VwLCBiaXRnb10gPSBrZXlzZXQ7XG4gIGlmIChlcShzaWduZXIsIHVzZXIpKSB7XG4gICAgcmV0dXJuIGJpdGdvO1xuICB9XG4gIGlmIChlcShzaWduZXIsIGJhY2t1cCkpIHtcbiAgICByZXR1cm4gYml0Z287XG4gIH1cbiAgaWYgKGVxKHNpZ25lciwgYml0Z28pKSB7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBzaWduZXIgbm90IGluIHB1YmtleXNgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRXYWxsZXRLZXlzKCk6IFJvb3RXYWxsZXRLZXlzIHtcbiAgcmV0dXJuIG5ldyBSb290V2FsbGV0S2V5cyhnZXRLZXlUcmlwbGUoJ2RlZmF1bHQnKSk7XG59XG4iXX0=