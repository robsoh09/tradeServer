import { BaseCoin, BitGoBase, FullySignedTransaction, HalfSignedTransaction, MPCAlgorithm, Recipient } from '@bitgo/sdk-core';
import { AbstractEthLikeNewCoins, BuildOptions, BuildTransactionParams, FeesUsed, GetBatchExecutionInfoRT, GetSendMethodArgsOptions, RecoveryInfo, RecoverOptions, SendMethodArgs, SignedTransaction, SignFinalOptions, SignTransactionOptions, TransactionPrebuild, OfflineVaultTxInfo, optionalDeps } from '@bitgo/abstract-eth';
import { BaseCoin as StaticsBaseCoin } from '@bitgo/statics';
import type * as EthTxLib from '@ethereumjs/tx';
import { TransactionBuilder } from './lib/transactionBuilder';
export { BuildTransactionParams, Recipient, HalfSignedTransaction, FeesUsed, FullySignedTransaction, GetBatchExecutionInfoRT, GetSendMethodArgsOptions, TransactionPrebuild, OfflineVaultTxInfo, optionalDeps, RecoverOptions, RecoveryInfo, SendMethodArgs, SignFinalOptions, SignedTransaction, SignTransactionOptions, };
export declare class Eth extends AbstractEthLikeNewCoins {
    protected constructor(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>);
    static createInstance(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>): BaseCoin;
    allowsAccountConsolidations(): boolean;
    /** @inheritDoc */
    supportsTss(): boolean;
    getMPCAlgorithm(): MPCAlgorithm;
    /**
     * Gets correct Eth Common object based on params from either recovery or tx building
     * @param eip1559 {EIP1559} configs that specify whether we should construct an eip1559 tx
     * @param replayProtectionOptions {ReplayProtectionOptions} check if chain id supports replay protection
     */
    private static getEthCommon;
    static buildTransaction(params: BuildTransactionParams): EthTxLib.FeeMarketEIP1559Transaction | EthTxLib.Transaction;
    /**
     * Make a query to Etherscan for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @returns {Object} response from Etherscan
     */
    recoveryBlockchainExplorerQuery(query: Record<string, string>): Promise<any>;
    /**
     * Recovers a tx with non-TSS keys
     * same expected arguments as recover method (original logic before adding TSS recover path)
     */
    protected recoverEthLike(params: RecoverOptions): Promise<RecoveryInfo | OfflineVaultTxInfo>;
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub: string): boolean;
    /**
     * Helper function for signTransaction for the rare case that SDK is doing the second signature
     * Note: we are expecting this to be called from the offline vault
     * @param params.txPrebuild
     * @param params.signingKeyNonce
     * @param params.walletContractAddress
     * @param params.prv
     * @returns {{txHex: *}}
     */
    signFinal(params: SignFinalOptions): FullySignedTransaction;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns {Promise<SignedTransaction>}
     */
    signTransaction(params: SignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Modify prebuild before sending it to the server. Add things like hop transaction params
     * @param buildParams The whitelisted parameters for this prebuild
     * @param buildParams.hop True if this should prebuild a hop tx, else false
     * @param buildParams.recipients The recipients array of this transaction
     * @param buildParams.wallet The wallet sending this tx
     * @param buildParams.walletPassphrase the passphrase for this wallet
     */
    getExtraPrebuildParams(buildParams: BuildOptions): Promise<BuildOptions>;
    /**
     * Create a new transaction builder for the current chain
     * @return a new transaction builder
     */
    protected getTransactionBuilder(): TransactionBuilder;
    /** @inheritDoc */
    supportsMessageSigning(): boolean;
    /** @inheritDoc */
    supportsSigningTypedData(): boolean;
}
//# sourceMappingURL=eth.d.ts.map