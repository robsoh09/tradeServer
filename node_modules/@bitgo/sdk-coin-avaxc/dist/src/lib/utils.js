"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getToken = exports.isValidEthPublicKey = exports.isValidEthPrivateKey = exports.isValidEthAddress = exports.getCommon = exports.sign = void 0;
const assert_1 = __importDefault(require("assert"));
const statics_1 = require("@bitgo/statics");
const ethereumjs_util_1 = require("ethereumjs-util");
const sdk_coin_eth_1 = require("@bitgo/sdk-coin-eth");
const sdk_core_1 = require("@bitgo/sdk-core");
const resources_1 = require("./resources");
/**
 * Signs the transaction using the appropriate algorithm
 *
 * @param {TxData} transactionData the transaction data to sign
 * @param {KeyPair} keyPair the signer's keypair
 * @returns {string} the transaction signed and encoded
 */
async function sign(transactionData, keyPair) {
    return sdk_coin_eth_1.Utils.signInternal(transactionData, keyPair, resources_1.testnetCommon);
}
exports.sign = sign;
const commons = new Map([
    [statics_1.NetworkType.MAINNET, resources_1.mainnetCommon],
    [statics_1.NetworkType.TESTNET, resources_1.testnetCommon],
]);
/**
 * @param {NetworkType} network either mainnet or testnet
 * @returns {EthereumCommon} Ethereum common configuration object
 */
function getCommon(network) {
    const common = commons.get(network);
    if (!common) {
        throw new sdk_core_1.InvalidTransactionError('Missing network common configuration');
    }
    return common;
}
exports.getCommon = getCommon;
/**
 * Returns whether or not the string is a valid C-Chain address in Eth format
 *
 * @param {string} address - the address string
 * @returns {boolean} - the validation result
 */
function isValidEthAddress(address) {
    return (0, ethereumjs_util_1.isValidAddress)(address);
}
exports.isValidEthAddress = isValidEthAddress;
/**
 * Returns whether or not the string is a valid C-Chain private key in Eth format
 *
 * @param {string} privateKey - the string formatted key
 * @returns {boolean} - the validation result
 */
function isValidEthPrivateKey(privateKey) {
    if (privateKey.length !== 64) {
        return false;
    }
    const privateKeyBuffer = Buffer.from(privateKey, 'hex');
    if (privateKeyBuffer.length !== 32) {
        return false;
    }
    return (0, ethereumjs_util_1.isValidPrivate)(privateKeyBuffer);
}
exports.isValidEthPrivateKey = isValidEthPrivateKey;
/**
 * Returns whether or not the string is a valid C-Chain public key in Eth format
 *
 * @param {string} publicKey - the uncompressed public key string
 * @returns {boolean} - the validation result
 */
function isValidEthPublicKey(publicKey) {
    // Uncompressed Eth Public Keys have a 04 prefix that needs to be removed in order to validate it.
    const publicKeyWithoutPrefix = publicKey.slice(2);
    const publicKeyBuffer = Buffer.from(publicKeyWithoutPrefix, 'hex');
    return (0, ethereumjs_util_1.isValidPublic)(publicKeyBuffer);
}
exports.isValidEthPublicKey = isValidEthPublicKey;
function getToken(tokenContractAddress, network) {
    const tokens = statics_1.coins.filter((coin) => {
        if (coin instanceof statics_1.AvaxERC20Token) {
            return (coin.network.type === network.type && coin.contractAddress.toLowerCase() === tokenContractAddress.toLowerCase());
        }
        return false;
    });
    // if length of tokens is 1, return the first, else return undefined
    // Can't directly index into tokens, or call `length`, so we use map to get an array
    const tokensArray = tokens.map((token) => token);
    if (tokensArray.length >= 1) {
        // there should never be two tokens with the same contract address, so we assert that here
        (0, assert_1.default)(tokensArray.length === 1, 'Found more than 1 token: ' + JSON.stringify(tokensArray));
        return tokensArray[0];
    }
    return undefined;
}
exports.getToken = getToken;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG9EQUE0QjtBQUU1Qiw0Q0FBMkY7QUFDM0YscURBQWdGO0FBRWhGLHNEQUE2RDtBQUM3RCw4Q0FBMEQ7QUFDMUQsMkNBQTJEO0FBRTNEOzs7Ozs7R0FNRztBQUNJLEtBQUssVUFBVSxJQUFJLENBQUMsZUFBdUIsRUFBRSxPQUFnQjtJQUNsRSxPQUFPLG9CQUFLLENBQUMsWUFBWSxDQUFDLGVBQWUsRUFBRSxPQUFPLEVBQUUseUJBQWEsQ0FBQyxDQUFDO0FBQ3JFLENBQUM7QUFGRCxvQkFFQztBQUVELE1BQU0sT0FBTyxHQUFxQyxJQUFJLEdBQUcsQ0FBOEI7SUFDckYsQ0FBQyxxQkFBVyxDQUFDLE9BQU8sRUFBRSx5QkFBYSxDQUFDO0lBQ3BDLENBQUMscUJBQVcsQ0FBQyxPQUFPLEVBQUUseUJBQWEsQ0FBQztDQUNyQyxDQUFDLENBQUM7QUFFSDs7O0dBR0c7QUFDSCxTQUFnQixTQUFTLENBQUMsT0FBb0I7SUFDNUMsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNwQyxJQUFJLENBQUMsTUFBTSxFQUFFO1FBQ1gsTUFBTSxJQUFJLGtDQUF1QixDQUFDLHNDQUFzQyxDQUFDLENBQUM7S0FDM0U7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBTkQsOEJBTUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLGlCQUFpQixDQUFDLE9BQWU7SUFDL0MsT0FBTyxJQUFBLGdDQUFjLEVBQUMsT0FBTyxDQUFDLENBQUM7QUFDakMsQ0FBQztBQUZELDhDQUVDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixvQkFBb0IsQ0FBQyxVQUFrQjtJQUNyRCxJQUFJLFVBQVUsQ0FBQyxNQUFNLEtBQUssRUFBRSxFQUFFO1FBQzVCLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxNQUFNLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBRXhELElBQUksZ0JBQWdCLENBQUMsTUFBTSxLQUFLLEVBQUUsRUFBRTtRQUNsQyxPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsT0FBTyxJQUFBLGdDQUFjLEVBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUMxQyxDQUFDO0FBVkQsb0RBVUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLG1CQUFtQixDQUFDLFNBQWlCO0lBQ25ELGtHQUFrRztJQUNsRyxNQUFNLHNCQUFzQixHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEQsTUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNuRSxPQUFPLElBQUEsK0JBQWEsRUFBQyxlQUFlLENBQUMsQ0FBQztBQUN4QyxDQUFDO0FBTEQsa0RBS0M7QUFFRCxTQUFnQixRQUFRLENBQUMsb0JBQTRCLEVBQUUsT0FBb0I7SUFDekUsTUFBTSxNQUFNLEdBQUcsZUFBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1FBQ25DLElBQUksSUFBSSxZQUFZLHdCQUFjLEVBQUU7WUFDbEMsT0FBTyxDQUNMLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLEVBQUUsS0FBSyxvQkFBb0IsQ0FBQyxXQUFXLEVBQUUsQ0FDaEgsQ0FBQztTQUNIO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDLENBQUMsQ0FBQztJQUVILG9FQUFvRTtJQUNwRSxvRkFBb0Y7SUFDcEYsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakQsSUFBSSxXQUFXLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtRQUMzQiwwRkFBMEY7UUFDMUYsSUFBQSxnQkFBTSxFQUFDLFdBQVcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLDJCQUEyQixHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztRQUM1RixPQUFPLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUN2QjtJQUNELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUFuQkQsNEJBbUJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5pbXBvcnQgeyBBdmF4RVJDMjBUb2tlbiwgQmFzZUNvaW4sIEJhc2VOZXR3b3JrLCBOZXR3b3JrVHlwZSwgY29pbnMgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBpc1ZhbGlkQWRkcmVzcywgaXNWYWxpZFByaXZhdGUsIGlzVmFsaWRQdWJsaWMgfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuaW1wb3J0IEV0aGVyZXVtQ29tbW9uIGZyb20gJ0BldGhlcmV1bWpzL2NvbW1vbic7XG5pbXBvcnQgeyBVdGlscywgS2V5UGFpciwgVHhEYXRhIH0gZnJvbSAnQGJpdGdvL3Nkay1jb2luLWV0aCc7XG5pbXBvcnQgeyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvciB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyB0ZXN0bmV0Q29tbW9uLCBtYWlubmV0Q29tbW9uIH0gZnJvbSAnLi9yZXNvdXJjZXMnO1xuXG4vKipcbiAqIFNpZ25zIHRoZSB0cmFuc2FjdGlvbiB1c2luZyB0aGUgYXBwcm9wcmlhdGUgYWxnb3JpdGhtXG4gKlxuICogQHBhcmFtIHtUeERhdGF9IHRyYW5zYWN0aW9uRGF0YSB0aGUgdHJhbnNhY3Rpb24gZGF0YSB0byBzaWduXG4gKiBAcGFyYW0ge0tleVBhaXJ9IGtleVBhaXIgdGhlIHNpZ25lcidzIGtleXBhaXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB0cmFuc2FjdGlvbiBzaWduZWQgYW5kIGVuY29kZWRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ24odHJhbnNhY3Rpb25EYXRhOiBUeERhdGEsIGtleVBhaXI6IEtleVBhaXIpOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gVXRpbHMuc2lnbkludGVybmFsKHRyYW5zYWN0aW9uRGF0YSwga2V5UGFpciwgdGVzdG5ldENvbW1vbik7XG59XG5cbmNvbnN0IGNvbW1vbnM6IE1hcDxOZXR3b3JrVHlwZSwgRXRoZXJldW1Db21tb24+ID0gbmV3IE1hcDxOZXR3b3JrVHlwZSwgRXRoZXJldW1Db21tb24+KFtcbiAgW05ldHdvcmtUeXBlLk1BSU5ORVQsIG1haW5uZXRDb21tb25dLFxuICBbTmV0d29ya1R5cGUuVEVTVE5FVCwgdGVzdG5ldENvbW1vbl0sXG5dKTtcblxuLyoqXG4gKiBAcGFyYW0ge05ldHdvcmtUeXBlfSBuZXR3b3JrIGVpdGhlciBtYWlubmV0IG9yIHRlc3RuZXRcbiAqIEByZXR1cm5zIHtFdGhlcmV1bUNvbW1vbn0gRXRoZXJldW0gY29tbW9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21tb24obmV0d29yazogTmV0d29ya1R5cGUpOiBFdGhlcmV1bUNvbW1vbiB7XG4gIGNvbnN0IGNvbW1vbiA9IGNvbW1vbnMuZ2V0KG5ldHdvcmspO1xuICBpZiAoIWNvbW1vbikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignTWlzc2luZyBuZXR3b3JrIGNvbW1vbiBjb25maWd1cmF0aW9uJyk7XG4gIH1cbiAgcmV0dXJuIGNvbW1vbjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBDLUNoYWluIGFkZHJlc3MgaW4gRXRoIGZvcm1hdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gdGhlIGFkZHJlc3Mgc3RyaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRFdGhBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNWYWxpZEFkZHJlc3MoYWRkcmVzcyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgQy1DaGFpbiBwcml2YXRlIGtleSBpbiBFdGggZm9ybWF0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHByaXZhdGVLZXkgLSB0aGUgc3RyaW5nIGZvcm1hdHRlZCBrZXlcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEV0aFByaXZhdGVLZXkocHJpdmF0ZUtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcHJpdmF0ZUtleUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHByaXZhdGVLZXksICdoZXgnKTtcblxuICBpZiAocHJpdmF0ZUtleUJ1ZmZlci5sZW5ndGggIT09IDMyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc1ZhbGlkUHJpdmF0ZShwcml2YXRlS2V5QnVmZmVyKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBDLUNoYWluIHB1YmxpYyBrZXkgaW4gRXRoIGZvcm1hdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNLZXkgLSB0aGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkgc3RyaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRFdGhQdWJsaWNLZXkocHVibGljS2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgLy8gVW5jb21wcmVzc2VkIEV0aCBQdWJsaWMgS2V5cyBoYXZlIGEgMDQgcHJlZml4IHRoYXQgbmVlZHMgdG8gYmUgcmVtb3ZlZCBpbiBvcmRlciB0byB2YWxpZGF0ZSBpdC5cbiAgY29uc3QgcHVibGljS2V5V2l0aG91dFByZWZpeCA9IHB1YmxpY0tleS5zbGljZSgyKTtcbiAgY29uc3QgcHVibGljS2V5QnVmZmVyID0gQnVmZmVyLmZyb20ocHVibGljS2V5V2l0aG91dFByZWZpeCwgJ2hleCcpO1xuICByZXR1cm4gaXNWYWxpZFB1YmxpYyhwdWJsaWNLZXlCdWZmZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9rZW4odG9rZW5Db250cmFjdEFkZHJlc3M6IHN0cmluZywgbmV0d29yazogQmFzZU5ldHdvcmspOiBSZWFkb25seTxCYXNlQ29pbj4gfCB1bmRlZmluZWQge1xuICBjb25zdCB0b2tlbnMgPSBjb2lucy5maWx0ZXIoKGNvaW4pID0+IHtcbiAgICBpZiAoY29pbiBpbnN0YW5jZW9mIEF2YXhFUkMyMFRva2VuKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjb2luLm5ldHdvcmsudHlwZSA9PT0gbmV0d29yay50eXBlICYmIGNvaW4uY29udHJhY3RBZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IHRva2VuQ29udHJhY3RBZGRyZXNzLnRvTG93ZXJDYXNlKClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG5cbiAgLy8gaWYgbGVuZ3RoIG9mIHRva2VucyBpcyAxLCByZXR1cm4gdGhlIGZpcnN0LCBlbHNlIHJldHVybiB1bmRlZmluZWRcbiAgLy8gQ2FuJ3QgZGlyZWN0bHkgaW5kZXggaW50byB0b2tlbnMsIG9yIGNhbGwgYGxlbmd0aGAsIHNvIHdlIHVzZSBtYXAgdG8gZ2V0IGFuIGFycmF5XG4gIGNvbnN0IHRva2Vuc0FycmF5ID0gdG9rZW5zLm1hcCgodG9rZW4pID0+IHRva2VuKTtcbiAgaWYgKHRva2Vuc0FycmF5Lmxlbmd0aCA+PSAxKSB7XG4gICAgLy8gdGhlcmUgc2hvdWxkIG5ldmVyIGJlIHR3byB0b2tlbnMgd2l0aCB0aGUgc2FtZSBjb250cmFjdCBhZGRyZXNzLCBzbyB3ZSBhc3NlcnQgdGhhdCBoZXJlXG4gICAgYXNzZXJ0KHRva2Vuc0FycmF5Lmxlbmd0aCA9PT0gMSwgJ0ZvdW5kIG1vcmUgdGhhbiAxIHRva2VuOiAnICsgSlNPTi5zdHJpbmdpZnkodG9rZW5zQXJyYXkpKTtcbiAgICByZXR1cm4gdG9rZW5zQXJyYXlbMF07XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbiJdfQ==