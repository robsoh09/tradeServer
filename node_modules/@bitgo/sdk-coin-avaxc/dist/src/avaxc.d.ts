/// <reference types="node" />
/// <reference types="bn.js" />
import { BaseCoin as StaticsBaseCoin, CoinFamily, BaseNetwork } from '@bitgo/statics';
import { BaseCoin, BitGoBase, FeeEstimateOptions, FullySignedTransaction, IWallet, KeyPair, ParsedTransaction, ParseTransactionOptions, Recipient, TransactionExplanation, VerifyAddressOptions } from '@bitgo/sdk-core';
import { GetSendMethodArgsOptions, RecoverOptions, RecoveryInfo, SendMethodArgs, TransactionBuilder as EthTransactionBuilder, TransactionPrebuild } from '@bitgo/sdk-coin-eth';
import { BN } from 'ethereumjs-util';
import { Buffer } from 'buffer';
import { AvaxSignTransactionOptions, BuildOptions, ExplainTransactionOptions, FeeEstimate, HopParams, HopPrebuild, HopTransactionBuildOptions, OfflineVaultTxInfo, PrecreateBitGoOptions, PresignTransactionOptions, SignedTransaction, SignFinalOptions, VerifyAvaxcTransactionOptions } from './iface';
import { AvaxpLib } from '@bitgo/sdk-coin-avaxp';
export declare class AvaxC extends BaseCoin {
    static hopTransactionSalt: string;
    protected readonly _staticsCoin: Readonly<StaticsBaseCoin>;
    protected constructor(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>);
    static createInstance(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>): BaseCoin;
    getBaseFactor(): number;
    getChain(): string;
    /**
     * Method to return the coin's network object
     * @returns {BaseNetwork}
     */
    getNetwork(): BaseNetwork;
    /**
     * Get the base chain that the coin exists on.
     */
    getBaseChain(): string;
    getFamily(): CoinFamily;
    getFullName(): string;
    valuelessTransferAllowed(): boolean;
    isValidAddress(address: string): boolean;
    isToken(): boolean;
    generateKeyPair(seed?: Buffer): KeyPair;
    parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
    verifyAddress({ address }: VerifyAddressOptions): Promise<boolean>;
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param params
     * @param params.txParams params object passed to send
     * @param params.txPrebuild prebuild object returned by server
     * @param params.wallet Wallet object to obtain keys to verify against
     * @returns {boolean}
     */
    verifyTransaction(params: VerifyAvaxcTransactionOptions): Promise<boolean>;
    private static isAVAXCAddress;
    verifyCoin(txPrebuild: TransactionPrebuild): boolean;
    isValidPub(pub: string): boolean;
    /**
     * Check whether gas limit passed in by user are within our max and min bounds
     * If they are not set, set them to the defaults
     * @param {number} userGasLimit - user defined gas limit
     * @returns {number} the gas limit to use for this transaction
     */
    setGasLimit(userGasLimit?: number): number;
    /**
     * Check whether the gas price passed in by user are within our max and min bounds
     * If they are not set, set them to the defaults
     * @param {number} userGasPrice - user defined gas price
     * @returns the gas price to use for this transaction
     */
    setGasPrice(userGasPrice?: number): number;
    /**
     * Make a query to avax.network for information such as balance, token balance, solidity calls
     * @param {Object} query — key-value pairs of parameters to append after /api
     * @returns {Promise<Object>} response from avax.network
     */
    recoveryBlockchainExplorerQuery(query: Record<string, any>): Promise<any>;
    /**
     * Queries public block explorer to get the next nonce that should be used for
     * the given AVAXC address
     * @param {string} address — address to fetch for
     * @returns {number} address nonce
     */
    getAddressNonce(address: string): Promise<number>;
    /**
     * Queries avax.network for the balance of an address
     * @param {string} address - the AVAXC address
     * @returns {Promise<BigNumber>} address balance
     */
    queryAddressBalance(address: string): Promise<BN>;
    /**
     * Queries avax.network for the token balance of an address
     * @param {string} address - the AVAXC address
     * @returns {Promise<BigNumber>} address balance
     */
    queryAddressTokenBalance(address: string, contractAddress: string): Promise<BN>;
    /**
     * Queries the contract (via avax.network) for the next sequence ID
     * @param {string} address - address of the contract
     * @returns {Promise<number>} sequence ID
     */
    querySequenceId(address: string): Promise<number>;
    /**
     * @param {Object} recipient - recipient info
     * @param {number} expireTime - expiry time
     * @param {number} contractSequenceId - sequence id
     * @returns {(string|Array)} operation array
     */
    getOperation(recipient: Recipient, expireTime: number, contractSequenceId: number): (string | Buffer)[][];
    /**
     * Calculate the operation hash in the same way solidity would
     * @param {Recipient[]} recipients - tx recipients
     * @param {number} expireTime - expiration time
     * @param {number} contractSequenceId - contract sequence id
     * @returns {string} operation hash
     */
    getOperationSha3ForExecuteAndConfirm(recipients: Recipient[], expireTime: number, contractSequenceId: number): string;
    /**
     * Default expire time for a contract call (1 week)
     * @returns {number} Time in seconds
     */
    getDefaultExpireTime(): number;
    /**
     * Build arguments to call the send method on the wallet contract
     * @param {Object} txInfo - data for send method args
     * @returns {SendMethodArgs[]}
     */
    getSendMethodArgs(txInfo: GetSendMethodArgsOptions): SendMethodArgs[];
    /**
     * Builds a funds recovery transaction without BitGo
     * Steps:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     * @param {Object} params The options with which to recover
     * @param {string} params.userKey - [encrypted] xprv
     * @param {string} params.backupKey - [encrypted] xprv or xpub if the xprv is held by a KRS provider
     * @param {string} params.walletPassphrase - used to decrypt userKey and backupKey
     * @param {string} params.walletContractAddress - the AVAXC address of the wallet contract
     * @param {string} params.recoveryDestination - target address to send recovered funds to
     * @returns {Promise<RecoveryInfo>} - recovery tx info
     */
    recover(params: RecoverOptions): Promise<RecoveryInfo | OfflineVaultTxInfo>;
    /**
     * Create a new transaction builder for the current chain
     * @return a new transaction builder
     */
    protected getTransactionBuilder(): EthTransactionBuilder;
    protected getAtomicBuilder(): AvaxpLib.TransactionBuilderFactory;
    /**
     * Explain a transaction from txHex, overriding BaseCoins
     * transaction can be either atomic or eth txn.
     * @param params The options with which to explain the transaction
     */
    explainTransaction(params: ExplainTransactionOptions): Promise<TransactionExplanation>;
    /**
     * Explains an atomic transaction using atomic builder.
     * @param txHex
     * @private
     */
    private explainAtomicTransaction;
    /**
     * Verify signature for an atomic transaction using atomic builder.
     * @param txHex
     * @return true if signature is from the input address
     * @private
     */
    private verifySignatureForAtomicTransaction;
    /**
     * Explains an EVM transaction using regular eth txn builder
     * @param tx
     * @private
     */
    private explainEVMTransaction;
    /**
     * Above is standard BaseCoins functions
     * ================================================================================================================
     * ================================================================================================================
     * Below is transaction functions
     */
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     * @param params
     */
    presignTransaction(params: PresignTransactionOptions): Promise<PresignTransactionOptions>;
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    postProcessPrebuild(params: TransactionPrebuild): Promise<TransactionPrebuild>;
    /**
     * Validates that the hop prebuild from the HSM is valid and correct
     * @param wallet The wallet that the prebuild is for
     * @param hopPrebuild The prebuild to validate
     * @param originalParams The original parameters passed to prebuildTransaction
     * @returns void
     * @throws Error if The prebuild is invalid
     */
    validateHopPrebuild(wallet: IWallet, hopPrebuild: HopPrebuild, originalParams?: {
        recipients: Recipient[];
    }): Promise<void>;
    /**
     * Helper function for signTransaction for the rare case that SDK is doing the second signature
     * Note: we are expecting this to be called from the offline vault
     * @param params.txPrebuild
     * @param params.prv
     * @returns {{txHex: string}}
     */
    signFinal(params: SignFinalOptions): Promise<FullySignedTransaction>;
    /**
     * Assemble half-sign prebuilt transaction
     * @param params
     */
    signTransaction(params: AvaxSignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Modify prebuild before sending it to the server. Add things like hop transaction params
     * @param buildParams The whitelisted parameters for this prebuild
     * @param buildParams.hop True if this should prebuild a hop tx, else false
     * @param buildParams.recipients The recipients array of this transaction
     * @param buildParams.wallet The wallet sending this tx
     * @param buildParams.walletPassphrase the passphrase for this wallet
     */
    getExtraPrebuildParams(buildParams: BuildOptions): Promise<BuildOptions>;
    /**
     * Creates the extra parameters needed to build a hop transaction
     * @param {HopTransactionBuildOptions} The original build parameters
     * @returns extra parameters object to merge with the original build parameters object and send to the platform
     */
    createHopTransactionParams({ recipients, type }: HopTransactionBuildOptions): Promise<HopParams>;
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Boolean} [params.hop] True if we should estimate fee for a hop transaction
     * @param {String} [params.recipient] The recipient of the transaction to estimate a send to
     * @param {String} [params.data] The ETH tx data to estimate a send for
     * @returns {Object} The fee info returned from the server
     */
    feeEstimate(params: FeeEstimateOptions): Promise<FeeEstimate>;
    /**
     * Gets the hop digest for the user to sign. This is validated in the HSM to prove that the user requested this tx
     * @param paramsArr The parameters to hash together for the digest
     */
    static getHopDigest(paramsArr: string[]): Buffer;
    /**
     * Calculate tx hash like evm from tx hex.
     * @param {string} tx
     * @returns {Buffer} tx hash
     */
    static getTxHash(tx: string): Buffer;
    isWalletAddress(params: VerifyAddressOptions): Promise<boolean>;
    /**
     * Ensure either enterprise or newFeeAddress is passed, to know whether to create new key or use enterprise key
     * @param params
     * @param params.enterprise {String} the enterprise id to associate with this key
     * @param params.newFeeAddress {Boolean} create a new fee address (enterprise not needed in this case)
     */
    preCreateBitGo(params: PrecreateBitGoOptions): void;
    getAvaxP(): string;
}
//# sourceMappingURL=avaxc.d.ts.map