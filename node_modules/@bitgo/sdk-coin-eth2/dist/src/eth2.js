"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Eth2 = void 0;
/**
 * @prettier
 */
const _ = __importStar(require("lodash"));
const ethUtil = __importStar(require("ethereumjs-util"));
const request = __importStar(require("superagent"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const sdk_core_1 = require("@bitgo/sdk-core");
const lib_1 = require("./lib");
class Eth2 extends sdk_core_1.BaseCoin {
    static createInstance(bitgo) {
        return new Eth2(bitgo);
    }
    /** @inheritDoc */
    supportsBlsDkg() {
        return true;
    }
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    getBaseFactor() {
        // 10^18
        return '1000000000000000000';
    }
    getChain() {
        return 'eth2';
    }
    getFamily() {
        return 'eth2';
    }
    getFullName() {
        return 'Ethereum 2.0';
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        // false until phase 2 of eth2.0 rolled out
        return false;
    }
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    transactionDataAllowed() {
        // false until phase 2 of eth2.0 rolled out
        return false;
    }
    /**
     * Evaluates whether a address string is valid for this coin
     * @param address
     */
    isValidAddress(address) {
        return this.isValidPub(address);
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub) {
        return lib_1.KeyPair.isValidPub(pub);
    }
    /**
     * Default gas price from platform
     * @returns {BigNumber}
     */
    getRecoveryGasPrice() {
        throw new Error('Method not yet implemented');
    }
    /**
     * Default gas limit from platform
     * @returns {BigNumber}
     */
    getRecoveryGasLimit() {
        throw new Error('Method not yet implemented');
    }
    /**
     * Specifies what key we will need for signing - ETH2 needs the backup, bitgo pubs.
     */
    keyIdsForSigning() {
        return [sdk_core_1.KeyIndices.USER, sdk_core_1.KeyIndices.BACKUP, sdk_core_1.KeyIndices.BITGO];
    }
    /**
     * Query Beaconscan for the balance of an address
     * @param address {String} the ETH address
     * @returns {BigNumber} address balance
     */
    async queryAddressBalance(address) {
        const result = await this.recoveryBlockchainExplorerQuery({
            module: 'account',
            action: 'balance',
            address: address,
        });
        return new bignumber_js_1.default(result.result, 10);
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns {Promise<SignedTransaction>}
     */
    async signTransaction(params) {
        throw new Error('Method not yet implemented');
    }
    /**
     * Ensure either enterprise or newFeeAddress is passed, to know whether to create new key or use enterprise key
     * @param params
     * @param params.enterprise {String} the enterprise id to associate with this key
     * @param params.newFeeAddress {Boolean} create a new fee address (enterprise not needed in this case)
     */
    preCreateBitGo(params) {
        // We always need params object, since either enterprise or newFeeAddress is required
        if (!_.isObject(params)) {
            throw new Error(`preCreateBitGo must be passed a params object. Got ${params} (type ${typeof params})`);
        }
        if (_.isUndefined(params.enterprise)) {
            throw new Error('expecting enterprise when adding BitGo key');
        }
        if (!_.isUndefined(params.enterprise) && !_.isString(params.enterprise)) {
            throw new Error(`enterprise should be a string - got ${params.enterprise} (type ${typeof params.enterprise})`);
        }
    }
    /**
     * Queries public block explorer to get the next ETH nonce that should be used for the given ETH address
     * @param address
     * @returns Promise<number>
     */
    async getAddressNonce(address) {
        // Get nonce for backup key (should be 0)
        let nonce = 0;
        const result = await this.recoveryBlockchainExplorerQuery({
            module: 'account',
            action: 'txlist',
            address,
        });
        const backupKeyTxList = result.result;
        if (backupKeyTxList.length > 0) {
            // Calculate last nonce used
            const outgoingTxs = backupKeyTxList.filter((tx) => tx.from === address);
            nonce = outgoingTxs.length;
        }
        return nonce;
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * @param params.userKey {String} [encrypted] xprv
     * @param params.backupKey {String} [encrypted] xprv or xpub if the xprv is held by a KRS provider
     * @param params.walletPassphrase {String} used to decrypt userKey and backupKey
     * @param params.walletContractAddress {String} the ETH address of the wallet contract
     * @param params.recoveryDestination {String} target address to send recovered funds to
     */
    recover(params) {
        throw new Error('recover not implemented');
    }
    /**
     * Make a query to Etherscan for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @returns {Object} response from Etherscan
     */
    async recoveryBlockchainExplorerQuery(query) {
        const response = await request.get(sdk_core_1.common.Environments[this.bitgo.getEnv()].eth2ExplorerBaseUrl).query(query);
        if (!response.ok) {
            throw new Error('could not reach BeaconScan');
        }
        return response.body;
    }
    /**
     * Generate BLS key pair
     *
     * @param seed - byte array to generate BLS key pair from
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed) {
        let keyPair = new lib_1.KeyPair();
        if (seed && lib_1.KeyPair.isValidPrv(seed)) {
            const seedStr = Buffer.from(seed).toString('hex');
            keyPair = new lib_1.KeyPair({ prv: seedStr });
        }
        else if (seed) {
            throw new Error('trying to generate keypair from invalid seed');
        }
        const keys = keyPair.getKeys();
        return {
            pub: keys.publicShare,
            prv: keys.prv || '',
            secretShares: keys.secretShares || [],
            seed: keys.seed,
            chaincode: keys.chaincode || '',
        };
    }
    async parseTransaction(params) {
        return {};
    }
    async isWalletAddress(params) {
        throw new sdk_core_1.MethodNotImplementedError();
    }
    async verifyTransaction(params) {
        return true;
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        const keyPair = new lib_1.KeyPair({ prv: key.prv });
        let messageToSign = Buffer.from(message);
        if (lib_1.KeyPair.isValidPub(message)) {
            // if we are doing a key signature, we should decode the message as a hex string
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore BG-34579: known compatibility issue with @types/ethereumjs-util
            messageToSign = Buffer.from(ethUtil.stripHexPrefix(message), 'hex');
        }
        const signedMessage = await keyPair.sign(messageToSign);
        return ethUtil.toBuffer(signedMessage);
    }
    aggregateShares(shares) {
        const commonPub = lib_1.KeyPair.aggregatePubkeys(shares.pubShares);
        const prv = lib_1.KeyPair.aggregatePrvkeys(shares.prvShares);
        const commonChaincode = lib_1.KeyPair.aggregateChaincodes(shares.chaincodes);
        return {
            pub: commonPub,
            prv,
            secretShares: shares.prvShares,
            chaincode: commonChaincode,
        };
    }
}
exports.Eth2 = Eth2;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXRoMi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ldGgyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0dBRUc7QUFDSCwwQ0FBNEI7QUFDNUIseURBQTJDO0FBQzNDLG9EQUFzQztBQUN0QyxnRUFBcUM7QUFFckMsOENBYXlCO0FBRXpCLCtCQUErQztBQXNGL0MsTUFBYSxJQUFLLFNBQVEsbUJBQVE7SUFDaEMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFnQjtRQUNwQyxPQUFPLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsY0FBYztRQUNaLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7T0FHRztJQUNILGFBQWE7UUFDWCxRQUFRO1FBQ1IsT0FBTyxxQkFBcUIsQ0FBQztJQUMvQixDQUFDO0lBRUQsUUFBUTtRQUNOLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxTQUFTO1FBQ1AsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVELFdBQVc7UUFDVCxPQUFPLGNBQWMsQ0FBQztJQUN4QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsd0JBQXdCO1FBQ3RCLDJDQUEyQztRQUMzQyxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7O09BR0c7SUFDSCxzQkFBc0I7UUFDcEIsMkNBQTJDO1FBQzNDLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOzs7T0FHRztJQUNILGNBQWMsQ0FBQyxPQUFlO1FBQzVCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxVQUFVLENBQUMsR0FBVztRQUNwQixPQUFPLGFBQVcsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7T0FHRztJ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Q0FBQztJQUNKLENBQUM7Q0FDRjtBQWhRRCxvQkFnUUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBldGhVdGlsIGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5pbXBvcnQgKiBhcyByZXF1ZXN0IGZyb20gJ3N1cGVyYWdlbnQnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuXG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgQml0R29CYXNlLFxuICBjb21tb24sXG4gIEhhbGZTaWduZWRBY2NvdW50VHJhbnNhY3Rpb24gYXMgQmFzZUhhbGZTaWduZWRUcmFuc2FjdGlvbixcbiAgSUJsc0tleVBhaXIsXG4gIEtleUluZGljZXMsXG4gIE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcblxuaW1wb3J0IHsgS2V5UGFpciBhcyBFdGgyS2V5UGFpciB9IGZyb20gJy4vbGliJztcblxuaW50ZXJmYWNlIFJlY2lwaWVudCB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgYW1vdW50OiBzdHJpbmc7XG4gIGRhdGE/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTaWduRmluYWxPcHRpb25zIHtcbiAgdHhQcmVidWlsZDoge1xuICAgIGdhc1ByaWNlOiBzdHJpbmc7XG4gICAgZ2FzTGltaXQ6IHN0cmluZztcbiAgICByZWNpcGllbnRzOiBSZWNpcGllbnRbXTtcbiAgICBoYWxmU2lnbmVkOiB7XG4gICAgICBleHBpcmVUaW1lOiBudW1iZXI7XG4gICAgICBjb250cmFjdFNlcXVlbmNlSWQ6IG51bWJlcjtcbiAgICAgIGJhY2t1cEtleU5vbmNlPzogbnVtYmVyO1xuICAgICAgc2lnbmF0dXJlOiBzdHJpbmc7XG4gICAgfTtcbiAgICBuZXh0Q29udHJhY3RTZXF1ZW5jZUlkPzogbnVtYmVyO1xuICAgIGJhY2t1cEtleU5vbmNlPzogbnVtYmVyO1xuICB9O1xuICBzaWduaW5nS2V5Tm9uY2U6IG51bWJlcjtcbiAgd2FsbGV0Q29udHJhY3RBZGRyZXNzOiBzdHJpbmc7XG4gIHBydjogc3RyaW5nO1xuICByZWNpcGllbnRzOiBSZWNpcGllbnRbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsIFNpZ25GaW5hbE9wdGlvbnMge1xuICBpc0xhc3RTaWduYXR1cmU/OiBib29sZWFuO1xuICBleHBpcmVUaW1lOiBudW1iZXI7XG4gIHNlcXVlbmNlSWQ6IG51bWJlcjtcbiAgZ2FzTGltaXQ6IG51bWJlcjtcbiAgZ2FzUHJpY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYWxmU2lnbmVkVHJhbnNhY3Rpb24gZXh0ZW5kcyBCYXNlSGFsZlNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgaGFsZlNpZ25lZDoge1xuICAgIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xuICAgIGV4cGlyZVRpbWU6IG51bWJlcjtcbiAgICBjb250cmFjdFNlcXVlbmNlSWQ6IG51bWJlcjtcbiAgICBzZXF1ZW5jZUlkOiBudW1iZXI7XG4gICAgdHhIZXg/OiBuZXZlcjtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdWxseVNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgdHhIZXg6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgU2lnbmVkVHJhbnNhY3Rpb24gPSBIYWxmU2lnbmVkVHJhbnNhY3Rpb24gfCBGdWxseVNpZ25lZFRyYW5zYWN0aW9uO1xuXG5pbnRlcmZhY2UgUHJlY3JlYXRlQml0R29PcHRpb25zIHtcbiAgZW50ZXJwcmlzZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIE9mZmxpbmVWYXVsdFR4SW5mbyB7XG4gIG5leHRDb250cmFjdFNlcXVlbmNlSWQ/OiBzdHJpbmc7XG4gIGNvbnRyYWN0U2VxdWVuY2VJZD86IHN0cmluZztcbiAgdHg6IHN0cmluZztcbiAgdXNlcktleTogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgY29pbjogc3RyaW5nO1xuICBnYXNQcmljZTogbnVtYmVyO1xuICBnYXNMaW1pdDogbnVtYmVyO1xuICByZWNpcGllbnRzOiBSZWNpcGllbnRbXTtcbiAgd2FsbGV0Q29udHJhY3RBZGRyZXNzOiBzdHJpbmc7XG4gIGFtb3VudDogc3RyaW5nO1xuICBiYWNrdXBLZXlOb25jZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJPcHRpb25zIHtcbiAgdXNlcktleTogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgd2FsbGV0Q29udHJhY3RBZGRyZXNzOiBzdHJpbmc7XG4gIHJlY292ZXJ5RGVzdGluYXRpb246IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyeUluZm8ge1xuICBpZDogc3RyaW5nO1xuICB0eDogc3RyaW5nO1xuICBiYWNrdXBLZXk/OiBzdHJpbmc7XG4gIGNvaW4/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBFdGgyIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvQmFzZSk6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IEV0aDIoYml0Z28pO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHN1cHBvcnRzQmxzRGtnKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZhY3RvciBiZXR3ZWVuIHRoZSBiYXNlIHVuaXQgYW5kIGl0cyBzbWFsbGVzdCBzdWJkaXZpc29uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldEJhc2VGYWN0b3IoKTogc3RyaW5nIHtcbiAgICAvLyAxMF4xOFxuICAgIHJldHVybiAnMTAwMDAwMDAwMDAwMDAwMDAwMCc7XG4gIH1cblxuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnZXRoMic7XG4gIH1cblxuICBnZXRGYW1pbHkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2V0aDInO1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ0V0aGVyZXVtIDIuMCc7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBmb3Igc2VuZGluZyB2YWx1ZSBvZiAwXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gc2VuZCAwIHZhbHVlLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHZhbHVlbGVzc1RyYW5zZmVyQWxsb3dlZCgpIHtcbiAgICAvLyBmYWxzZSB1bnRpbCBwaGFzZSAyIG9mIGV0aDIuMCByb2xsZWQgb3V0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgZGF0YSBhbG9uZyB3aXRoIHRyYW5zYWN0aW9uc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgdHggZGF0YSAoRVRIKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB0cmFuc2FjdGlvbkRhdGFBbGxvd2VkKCkge1xuICAgIC8vIGZhbHNlIHVudGlsIHBoYXNlIDIgb2YgZXRoMi4wIHJvbGxlZCBvdXRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRXZhbHVhdGVzIHdoZXRoZXIgYSBhZGRyZXNzIHN0cmluZyBpcyB2YWxpZCBmb3IgdGhpcyBjb2luXG4gICAqIEBwYXJhbSBhZGRyZXNzXG4gICAqL1xuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkUHViKGFkZHJlc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHB1YiB0aGUgcHViIHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBFdGgyS2V5UGFpci5pc1ZhbGlkUHViKHB1Yik7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBnYXMgcHJpY2UgZnJvbSBwbGF0Zm9ybVxuICAgKiBAcmV0dXJucyB7QmlnTnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVjb3ZlcnlHYXNQcmljZSgpOiBhbnkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGdhcyBsaW1pdCBmcm9tIHBsYXRmb3JtXG4gICAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9XG4gICAqL1xuICBnZXRSZWNvdmVyeUdhc0xpbWl0KCk6IGFueSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB3aGF0IGtleSB3ZSB3aWxsIG5lZWQgZm9yIHNpZ25pbmcgLSBFVEgyIG5lZWRzIHRoZSBiYWNrdXAsIGJpdGdvIHB1YnMuXG4gICAqL1xuICBrZXlJZHNGb3JTaWduaW5nKCk6IG51bWJlcltdIHtcbiAgICByZXR1cm4gW0tleUluZGljZXMuVVNFUiwgS2V5SW5kaWNlcy5CQUNLVVAsIEtleUluZGljZXMuQklUR09dO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJ5IEJlYWNvbnNjYW4gZm9yIHRoZSBiYWxhbmNlIG9mIGFuIGFkZHJlc3NcbiAgICogQHBhcmFtIGFkZHJlc3Mge1N0cmluZ30gdGhlIEVUSCBhZGRyZXNzXG4gICAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IGFkZHJlc3MgYmFsYW5jZVxuICAgKi9cbiAgYXN5bmMgcXVlcnlBZGRyZXNzQmFsYW5jZShhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPEJpZ051bWJlcj4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVjb3ZlcnlCbG9ja2NoYWluRXhwbG9yZXJRdWVyeSh7XG4gICAgICBtb2R1bGU6ICdhY2NvdW50JyxcbiAgICAgIGFjdGlvbjogJ2JhbGFuY2UnLFxuICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEJpZ051bWJlcihyZXN1bHQucmVzdWx0LCAxMCk7XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gdHhQcmVidWlsZFxuICAgKiAtIHBydlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTaWduZWRUcmFuc2FjdGlvbj59XG4gICAqL1xuICBhc3luYyBzaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgZWl0aGVyIGVudGVycHJpc2Ugb3IgbmV3RmVlQWRkcmVzcyBpcyBwYXNzZWQsIHRvIGtub3cgd2hldGhlciB0byBjcmVhdGUgbmV3IGtleSBvciB1c2UgZW50ZXJwcmlzZSBrZXlcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmVudGVycHJpc2Uge1N0cmluZ30gdGhlIGVudGVycHJpc2UgaWQgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBrZXlcbiAgICogQHBhcmFtIHBhcmFtcy5uZXdGZWVBZGRyZXNzIHtCb29sZWFufSBjcmVhdGUgYSBuZXcgZmVlIGFkZHJlc3MgKGVudGVycHJpc2Ugbm90IG5lZWRlZCBpbiB0aGlzIGNhc2UpXG4gICAqL1xuICBwcmVDcmVhdGVCaXRHbyhwYXJhbXM6IFByZWNyZWF0ZUJpdEdvT3B0aW9ucyk6IHZvaWQge1xuICAgIC8vIFdlIGFsd2F5cyBuZWVkIHBhcmFtcyBvYmplY3QsIHNpbmNlIGVpdGhlciBlbnRlcnByaXNlIG9yIG5ld0ZlZUFkZHJlc3MgaXMgcmVxdWlyZWRcbiAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcmVDcmVhdGVCaXRHbyBtdXN0IGJlIHBhc3NlZCBhIHBhcmFtcyBvYmplY3QuIEdvdCAke3BhcmFtc30gKHR5cGUgJHt0eXBlb2YgcGFyYW1zfSlgKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMuZW50ZXJwcmlzZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIGVudGVycHJpc2Ugd2hlbiBhZGRpbmcgQml0R28ga2V5Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5lbnRlcnByaXNlKSAmJiAhXy5pc1N0cmluZyhwYXJhbXMuZW50ZXJwcmlzZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZW50ZXJwcmlzZSBzaG91bGQgYmUgYSBzdHJpbmcgLSBnb3QgJHtwYXJhbXMuZW50ZXJwcmlzZX0gKHR5cGUgJHt0eXBlb2YgcGFyYW1zLmVudGVycHJpc2V9KWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyaWVzIHB1YmxpYyBibG9jayBleHBsb3JlciB0byBnZXQgdGhlIG5leHQgRVRIIG5vbmNlIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIHRoZSBnaXZlbiBFVEggYWRkcmVzc1xuICAgKiBAcGFyYW0gYWRkcmVzc1xuICAgKiBAcmV0dXJucyBQcm9taXNlPG51bWJlcj5cbiAgICovXG4gIGFzeW5jIGdldEFkZHJlc3NOb25jZShhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIC8vIEdldCBub25jZSBmb3IgYmFja3VwIGtleSAoc2hvdWxkIGJlIDApXG4gICAgbGV0IG5vbmNlID0gMDtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVjb3ZlcnlCbG9ja2NoYWluRXhwbG9yZXJRdWVyeSh7XG4gICAgICBtb2R1bGU6ICdhY2NvdW50JyxcbiAgICAgIGFjdGlvbjogJ3R4bGlzdCcsXG4gICAgICBhZGRyZXNzLFxuICAgIH0pO1xuICAgIGNvbnN0IGJhY2t1cEtleVR4TGlzdCA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgaWYgKGJhY2t1cEtleVR4TGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgbGFzdCBub25jZSB1c2VkXG4gICAgICBjb25zdCBvdXRnb2luZ1R4cyA9IGJhY2t1cEtleVR4TGlzdC5maWx0ZXIoKHR4KSA9PiB0eC5mcm9tID09PSBhZGRyZXNzKTtcbiAgICAgIG5vbmNlID0gb3V0Z29pbmdUeHMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gbm9uY2U7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHb1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcktleSB7U3RyaW5nfSBbZW5jcnlwdGVkXSB4cHJ2XG4gICAqIEBwYXJhbSBwYXJhbXMuYmFja3VwS2V5IHtTdHJpbmd9IFtlbmNyeXB0ZWRdIHhwcnYgb3IgeHB1YiBpZiB0aGUgeHBydiBpcyBoZWxkIGJ5IGEgS1JTIHByb3ZpZGVyXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSB7U3RyaW5nfSB1c2VkIHRvIGRlY3J5cHQgdXNlcktleSBhbmQgYmFja3VwS2V5XG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzIHtTdHJpbmd9IHRoZSBFVEggYWRkcmVzcyBvZiB0aGUgd2FsbGV0IGNvbnRyYWN0XG4gICAqIEBwYXJhbSBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbiB7U3RyaW5nfSB0YXJnZXQgYWRkcmVzcyB0byBzZW5kIHJlY292ZXJlZCBmdW5kcyB0b1xuICAgKi9cbiAgcmVjb3ZlcihwYXJhbXM6IFJlY292ZXJPcHRpb25zKTogUHJvbWlzZTxSZWNvdmVyeUluZm8gfCBPZmZsaW5lVmF1bHRUeEluZm8+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXIgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIHF1ZXJ5IHRvIEV0aGVyc2NhbiBmb3IgaW5mb3JtYXRpb24gc3VjaCBhcyBiYWxhbmNlLCB0b2tlbiBiYWxhbmNlLCBzb2xpZGl0eSBjYWxsc1xuICAgKiBAcGFyYW0gcXVlcnkge09iamVjdH0ga2V5LXZhbHVlIHBhaXJzIG9mIHBhcmFtZXRlcnMgdG8gYXBwZW5kIGFmdGVyIC9hcGlcbiAgICogQHJldHVybnMge09iamVjdH0gcmVzcG9uc2UgZnJvbSBFdGhlcnNjYW5cbiAgICovXG4gIGFzeW5jIHJlY292ZXJ5QmxvY2tjaGFpbkV4cGxvcmVyUXVlcnkocXVlcnk6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LmdldChjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZ2V0RW52KCldLmV0aDJFeHBsb3JlckJhc2VVcmwpLnF1ZXJ5KHF1ZXJ5KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWNoIEJlYWNvblNjYW4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLmJvZHk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgQkxTIGtleSBwYWlyXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkIC0gYnl0ZSBhcnJheSB0byBnZW5lcmF0ZSBCTFMga2V5IHBhaXIgZnJvbVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2l0aCBnZW5lcmF0ZWQgcHViIGFuZCBwcnZcbiAgICovXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkPzogQnVmZmVyKTogSUJsc0tleVBhaXIge1xuICAgIGxldCBrZXlQYWlyID0gbmV3IEV0aDJLZXlQYWlyKCk7XG4gICAgaWYgKHNlZWQgJiYgRXRoMktleVBhaXIuaXNWYWxpZFBydihzZWVkKSkge1xuICAgICAgY29uc3Qgc2VlZFN0ciA9IEJ1ZmZlci5mcm9tKHNlZWQpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIGtleVBhaXIgPSBuZXcgRXRoMktleVBhaXIoeyBwcnY6IHNlZWRTdHIgfSk7XG4gICAgfSBlbHNlIGlmIChzZWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBnZW5lcmF0ZSBrZXlwYWlyIGZyb20gaW52YWxpZCBzZWVkJyk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IGtleVBhaXIuZ2V0S2V5cygpO1xuICAgIHJldHVybiB7XG4gICAgICBwdWI6IGtleXMucHVibGljU2hhcmUsXG4gICAgICBwcnY6IGtleXMucHJ2IHx8ICcnLFxuICAgICAgc2VjcmV0U2hhcmVzOiBrZXlzLnNlY3JldFNoYXJlcyB8fCBbXSxcbiAgICAgIHNlZWQ6IGtleXMuc2VlZCxcbiAgICAgIGNoYWluY29kZToga2V5cy5jaGFpbmNvZGUgfHwgJycsXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIHBhcnNlVHJhbnNhY3Rpb24ocGFyYW1zOiBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8UGFyc2VkVHJhbnNhY3Rpb24+IHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBhc3luYyBpc1dhbGxldEFkZHJlc3MocGFyYW1zOiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRocm93IG5ldyBNZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gIH1cblxuICBhc3luYyB2ZXJpZnlUcmFuc2FjdGlvbihwYXJhbXM6IFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gbWVzc2FnZSB3aXRoIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICovXG4gIGFzeW5jIHNpZ25NZXNzYWdlKGtleTogeyBwcnY6IHN0cmluZyB9LCBtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGNvbnN0IGtleVBhaXIgPSBuZXcgRXRoMktleVBhaXIoeyBwcnY6IGtleS5wcnYgfSk7XG5cbiAgICBsZXQgbWVzc2FnZVRvU2lnbjogQnVmZmVyID0gQnVmZmVyLmZyb20obWVzc2FnZSk7XG4gICAgaWYgKEV0aDJLZXlQYWlyLmlzVmFsaWRQdWIobWVzc2FnZSkpIHtcbiAgICAgIC8vIGlmIHdlIGFyZSBkb2luZyBhIGtleSBzaWduYXR1cmUsIHdlIHNob3VsZCBkZWNvZGUgdGhlIG1lc3NhZ2UgYXMgYSBoZXggc3RyaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAvLyBAdHMtaWdub3JlIEJHLTM0NTc5OiBrbm93biBjb21wYXRpYmlsaXR5IGlzc3VlIHdpdGggQHR5cGVzL2V0aGVyZXVtanMtdXRpbFxuICAgICAgbWVzc2FnZVRvU2lnbiA9IEJ1ZmZlci5mcm9tKGV0aFV0aWwuc3RyaXBIZXhQcmVmaXgobWVzc2FnZSksICdoZXgnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaWduZWRNZXNzYWdlID0gYXdhaXQga2V5UGFpci5zaWduKG1lc3NhZ2VUb1NpZ24pO1xuICAgIHJldHVybiBldGhVdGlsLnRvQnVmZmVyKHNpZ25lZE1lc3NhZ2UpO1xuICB9XG5cbiAgYWdncmVnYXRlU2hhcmVzKHNoYXJlczogeyBwdWJTaGFyZXM6IHN0cmluZ1tdOyBwcnZTaGFyZXM6IHN0cmluZ1tdOyBjaGFpbmNvZGVzOiBzdHJpbmdbXSB9KTogSUJsc0tleVBhaXIge1xuICAgIGNvbnN0IGNvbW1vblB1YiA9IEV0aDJLZXlQYWlyLmFnZ3JlZ2F0ZVB1YmtleXMoc2hhcmVzLnB1YlNoYXJlcyk7XG4gICAgY29uc3QgcHJ2ID0gRXRoMktleVBhaXIuYWdncmVnYXRlUHJ2a2V5cyhzaGFyZXMucHJ2U2hhcmVzKTtcbiAgICBjb25zdCBjb21tb25DaGFpbmNvZGUgPSBFdGgyS2V5UGFpci5hZ2dyZWdhdGVDaGFpbmNvZGVzKHNoYXJlcy5jaGFpbmNvZGVzKTtcblxuICAgIHJldHVybiB7XG4gICAgICBwdWI6IGNvbW1vblB1YixcbiAgICAgIHBydixcbiAgICAgIHNlY3JldFNoYXJlczogc2hhcmVzLnBydlNoYXJlcyxcbiAgICAgIGNoYWluY29kZTogY29tbW9uQ2hhaW5jb2RlLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==