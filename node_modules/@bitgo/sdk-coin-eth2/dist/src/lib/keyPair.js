"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyPair = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
/**
 * Ethereum keys and address management.
 */
class KeyPair extends sdk_core_1.BlsKeyPair {
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     */
    constructor(source) {
        super(source);
    }
    /**
     * ETH2 default keys format is a pair of Uint8Array keys
     *
     * @returns { BlsKeys } The keys in the defined format
     */
    getKeys() {
        if (this.keyPair) {
            return this.keyPair;
        }
        throw new Error('Error getting keys. Check keyPair has been specified & private key is valid');
    }
    /**
     * Whether input is a valid BLS public key
     *
     * @param {string} pub the public key to validate
     * @returns {boolean} Whether input is a valid public key or not
     */
    static isValidPub(pub) {
        return (0, sdk_core_1.isValidBLSPublicKey)(pub);
    }
    /**
     * Whether the input is a valid BLS private key
     *
     * @param {string | Buffer | bigint} prv a private key to validate
     * @returns {boolean} Whether the input is a valid private key or not
     */
    static isValidPrv(prv) {
        if (typeof prv === 'string') {
            return (0, sdk_core_1.isValidBLSPrivateKey)(prv);
        }
        if (typeof prv === 'bigint') {
            return (0, sdk_core_1.isValidBLSPrivateKey)((0, sdk_core_1.bigIntToHex)(prv));
        }
        try {
            const hexPrv = Array.from(prv)
                .map(function (val) {
                const hex = val.toString(16);
                return '0'.slice(0, hex.length % 2) + hex;
            })
                .join('');
            return (0, sdk_core_1.isValidBLSPrivateKey)(hexPrv);
        }
        catch (e) {
            return false;
        }
    }
}
exports.KeyPair = KeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIva2V5UGFpci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw4Q0FPeUI7QUFFekI7O0dBRUc7QUFDSCxNQUFhLE9BQVEsU0FBUSxxQkFBVTtJQUNyQzs7O09BR0c7SUFDSCxZQUFZLE1BQXVCO1FBQ2pDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNoQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE9BQU87UUFDTCxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDaEIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO1NBQ3JCO1FBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyw2RUFBNkUsQ0FBQyxDQUFDO0lBQ2pHLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBVztRQUMzQixPQUFPLElBQUEsOEJBQW1CLEVBQUMsR0FBRyxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsTUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUE2QjtRQUM3QyxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRTtZQUMzQixPQUFPLElBQUEsK0JBQW9CLEVBQUMsR0FBRyxDQUFDLENBQUM7U0FDbEM7UUFDRCxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRTtZQUMzQixPQUFPLElBQUEsK0JBQW9CLEVBQUMsSUFBQSxzQkFBVyxFQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDL0M7UUFDRCxJQUFJO1lBQ0YsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7aUJBQzNCLEdBQUcsQ0FBQyxVQUFVLEdBQUc7Z0JBQ2hCLE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQzdCLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDNUMsQ0FBQyxDQUFDO2lCQUNELElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNaLE9BQU8sSUFBQSwrQkFBb0IsRUFBQyxNQUFNLENBQUMsQ0FBQztTQUNyQztRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxLQUFLLENBQUM7U0FDZDtJQUNILENBQUM7Q0FDRjtBQXhERCwwQkF3REMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBiaWdJbnRUb0hleCxcbiAgQmxzS2V5UGFpcixcbiAgQmxzS2V5cyxcbiAgaXNWYWxpZEJMU1ByaXZhdGVLZXksXG4gIGlzVmFsaWRCTFNQdWJsaWNLZXksXG4gIEtleVBhaXJPcHRpb25zLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuXG4vKipcbiAqIEV0aGVyZXVtIGtleXMgYW5kIGFkZHJlc3MgbWFuYWdlbWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIEtleVBhaXIgZXh0ZW5kcyBCbHNLZXlQYWlyIHtcbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci4gQnkgZGVmYXVsdCwgY3JlYXRlcyBhIGtleSBwYWlyIHdpdGggYSByYW5kb20gbWFzdGVyIHNlZWQuXG4gICAqXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2U/OiBLZXlQYWlyT3B0aW9ucykge1xuICAgIHN1cGVyKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogRVRIMiBkZWZhdWx0IGtleXMgZm9ybWF0IGlzIGEgcGFpciBvZiBVaW50OEFycmF5IGtleXNcbiAgICpcbiAgICogQHJldHVybnMgeyBCbHNLZXlzIH0gVGhlIGtleXMgaW4gdGhlIGRlZmluZWQgZm9ybWF0XG4gICAqL1xuICBnZXRLZXlzKCk6IEJsc0tleXMge1xuICAgIGlmICh0aGlzLmtleVBhaXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleVBhaXI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgZ2V0dGluZyBrZXlzLiBDaGVjayBrZXlQYWlyIGhhcyBiZWVuIHNwZWNpZmllZCAmIHByaXZhdGUga2V5IGlzIHZhbGlkJyk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBpbnB1dCBpcyBhIHZhbGlkIEJMUyBwdWJsaWMga2V5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwdWIgdGhlIHB1YmxpYyBrZXkgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgaW5wdXQgaXMgYSB2YWxpZCBwdWJsaWMga2V5IG9yIG5vdFxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNWYWxpZEJMU1B1YmxpY0tleShwdWIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGlucHV0IGlzIGEgdmFsaWQgQkxTIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgQnVmZmVyIHwgYmlnaW50fSBwcnYgYSBwcml2YXRlIGtleSB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgaW5wdXQgaXMgYSB2YWxpZCBwcml2YXRlIGtleSBvciBub3RcbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkUHJ2KHBydjogc3RyaW5nIHwgQnVmZmVyIHwgYmlnaW50KTogYm9vbGVhbiB7XG4gICAgaWYgKHR5cGVvZiBwcnYgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gaXNWYWxpZEJMU1ByaXZhdGVLZXkocHJ2KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcnYgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZXR1cm4gaXNWYWxpZEJMU1ByaXZhdGVLZXkoYmlnSW50VG9IZXgocHJ2KSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZXhQcnYgPSBBcnJheS5mcm9tKHBydilcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgY29uc3QgaGV4ID0gdmFsLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICByZXR1cm4gJzAnLnNsaWNlKDAsIGhleC5sZW5ndGggJSAyKSArIGhleDtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oJycpO1xuICAgICAgcmV0dXJuIGlzVmFsaWRCTFNQcml2YXRlS2V5KGhleFBydik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuIl19