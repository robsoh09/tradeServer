"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilder = void 0;
const ethereumjs_abi_1 = __importDefault(require("ethereumjs-abi"));
const sdk_coin_eth_1 = require("@bitgo/sdk-coin-eth");
const sdk_core_1 = require("@bitgo/sdk-core");
const utils_1 = require("./utils");
const transferBuilder_1 = require("./transferBuilder");
const _1 = require("./");
class TransactionBuilder extends sdk_coin_eth_1.TransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
        this._common = (0, utils_1.getCommon)(this._coinConfig.network.type);
        this.transaction = new _1.Transaction(this._coinConfig, this._common);
    }
    /**
     * Returns the smart contract encoded data
     *
     * @param {string[]} addresses - the contract signers
     * @returns {string} - the smart contract encoded data
     */
    getContractData(addresses) {
        const params = [addresses];
        const resultEncodedParameters = ethereumjs_abi_1.default.rawEncode(sdk_coin_eth_1.walletSimpleConstructor, params)
            .toString('hex')
            .replace('0x', '');
        return utils_1.walletSimpleByteCode + resultEncodedParameters;
    }
    /** @inheritdoc */
    transfer(data) {
        if (this._type !== sdk_core_1.TransactionType.Send) {
            throw new sdk_core_1.BuildTransactionError('Transfers can only be set for send transactions');
        }
        if (!this._transfer) {
            this._transfer = new transferBuilder_1.TransferBuilder(data);
        }
        return this._transfer;
    }
}
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi90cmFuc2FjdGlvbkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0Esb0VBQXlDO0FBQ3pDLHNEQUEyRztBQUMzRyw4Q0FBeUU7QUFDekUsbUNBQTBEO0FBQzFELHVEQUFvRDtBQUNwRCx5QkFBaUM7QUFFakMsTUFBYSxrQkFBbUIsU0FBUSxpQ0FBcUI7SUFHM0QsWUFBWSxXQUFpQztRQUMzQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDbkIsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFBLGlCQUFTLEVBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEQsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLGNBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDTyxlQUFlLENBQUMsU0FBbUI7UUFDM0MsTUFBTSxNQUFNLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMzQixNQUFNLHVCQUF1QixHQUFHLHdCQUFXLENBQUMsU0FBUyxDQUFDLHNDQUF1QixFQUFFLE1BQU0sQ0FBQzthQUNuRixRQUFRLENBQUMsS0FBSyxDQUFDO2FBQ2YsT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNyQixPQUFPLDRCQUFvQixHQUFHLHVCQUF1QixDQUFDO0lBQ3hELENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsUUFBUSxDQUFDLElBQWE7UUFDcEIsSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLDBCQUFlLENBQUMsSUFBSSxFQUFFO1lBQ3ZDLE1BQU0sSUFBSSxnQ0FBcUIsQ0FBQyxpREFBaUQsQ0FBQyxDQUFDO1NBQ3BGO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbkIsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLGlDQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDNUM7UUFDRCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDeEIsQ0FBQztDQUNGO0FBakNELGdEQWlDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgRXRoZXJldW1BYmkgZnJvbSAnZXRoZXJldW1qcy1hYmknO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25CdWlsZGVyIGFzIEV0aFRyYW5zYWN0aW9uQnVpbGRlciwgd2FsbGV0U2ltcGxlQ29uc3RydWN0b3IgfSBmcm9tICdAYml0Z28vc2RrLWNvaW4tZXRoJztcbmltcG9ydCB7IEJ1aWxkVHJhbnNhY3Rpb25FcnJvciwgVHJhbnNhY3Rpb25UeXBlIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IGdldENvbW1vbiwgd2FsbGV0U2ltcGxlQnl0ZUNvZGUgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IFRyYW5zZmVyQnVpbGRlciB9IGZyb20gJy4vdHJhbnNmZXJCdWlsZGVyJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi8nO1xuXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25CdWlsZGVyIGV4dGVuZHMgRXRoVHJhbnNhY3Rpb25CdWlsZGVyIHtcbiAgcHJvdGVjdGVkIF90cmFuc2ZlcjogVHJhbnNmZXJCdWlsZGVyO1xuXG4gIGNvbnN0cnVjdG9yKF9jb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xuICAgIHN1cGVyKF9jb2luQ29uZmlnKTtcbiAgICB0aGlzLl9jb21tb24gPSBnZXRDb21tb24odGhpcy5fY29pbkNvbmZpZy5uZXR3b3JrLnR5cGUpO1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24odGhpcy5fY29pbkNvbmZpZywgdGhpcy5fY29tbW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzbWFydCBjb250cmFjdCBlbmNvZGVkIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gYWRkcmVzc2VzIC0gdGhlIGNvbnRyYWN0IHNpZ25lcnNcbiAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgc21hcnQgY29udHJhY3QgZW5jb2RlZCBkYXRhXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0Q29udHJhY3REYXRhKGFkZHJlc3Nlczogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgIGNvbnN0IHBhcmFtcyA9IFthZGRyZXNzZXNdO1xuICAgIGNvbnN0IHJlc3VsdEVuY29kZWRQYXJhbWV0ZXJzID0gRXRoZXJldW1BYmkucmF3RW5jb2RlKHdhbGxldFNpbXBsZUNvbnN0cnVjdG9yLCBwYXJhbXMpXG4gICAgICAudG9TdHJpbmcoJ2hleCcpXG4gICAgICAucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgcmV0dXJuIHdhbGxldFNpbXBsZUJ5dGVDb2RlICsgcmVzdWx0RW5jb2RlZFBhcmFtZXRlcnM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdHJhbnNmZXIoZGF0YT86IHN0cmluZyk6IFRyYW5zZmVyQnVpbGRlciB7XG4gICAgaWYgKHRoaXMuX3R5cGUgIT09IFRyYW5zYWN0aW9uVHlwZS5TZW5kKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2ZlcnMgY2FuIG9ubHkgYmUgc2V0IGZvciBzZW5kIHRyYW5zYWN0aW9ucycpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3RyYW5zZmVyKSB7XG4gICAgICB0aGlzLl90cmFuc2ZlciA9IG5ldyBUcmFuc2ZlckJ1aWxkZXIoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90cmFuc2ZlcjtcbiAgfVxufVxuIl19