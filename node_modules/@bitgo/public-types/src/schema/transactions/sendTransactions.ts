import * as t from "io-ts";
import {
  Optional,
  optionalString,
  optionalBoolean,
  optionalNumber,
  optionalStringOrNumber,
  optionalUnknown,
} from "../../utils";
import { CoinSpecificBuildParams } from "./coinSpecific";

const recipient = t.partial({
  address: t.string,
  amount: t.union([t.string, t.number]),
  feeLimit: optionalString,
  data: optionalString,
  memo: optionalString,
  tokenName: optionalString,
});
export type TransactionRecipient = t.TypeOf<typeof recipient>;
const recipients = t.array(recipient);

const eip1559 = t.partial({
  maxPriorityFeePerGas: optionalString,
  maxFeePerGas: optionalString,
});

const lightningPaymentRequest = t.intersection([
  t.type({
    invoice: t.string,
  }),
  t.partial({
    amount: t.number,
    sequenceId: t.string,
    feeLimit: t.number,
    feeLimitRatio: t.number,
  }),
]);
export type LightningPaymentRequest = t.TypeOf<typeof lightningPaymentRequest>;

const halfSigned = t.partial({
  txHex: optionalString,
  recipients: Optional(recipients),
  eip1559: Optional(eip1559),
  isBatch: optionalBoolean,
  expireTime: optionalNumber,
  contractSequenceId: optionalNumber,
  nextContractSequenceId: optionalNumber,
  operationHash: optionalString,
  signedChildPsbt: optionalString,
  signature: optionalString,
  lightningPaymentRequest: Optional(lightningPaymentRequest),
});
export type HalfSignedTransaction = t.TypeOf<typeof halfSigned>;

export const memo = t.partial({
  type: optionalString,
  value: optionalString,
});

const feeOptions = {
  amount: optionalStringOrNumber,
  unit: Optional(
    t.union([t.literal("baseUnit"), t.literal("cpu"), t.literal("ram")]),
  ),
  formula: Optional(
    t.union([
      t.literal("fixed"),
      t.literal("feeRate"),
      t.literal("perKB"),
      t.literal("custom"),
    ]),
  ),
  type: Optional(
    t.union([t.literal("base"), t.literal("max"), t.literal("tip")]),
  ),
};

export const txSendBody = {
  comment: optionalString,
  consolidateId: optionalString,
  halfSigned: Optional(halfSigned),
  invoice: optionalString,
  memo: Optional(memo),
  otp: optionalString,
  recipients: Optional(recipients),
  suppressBroadcast: optionalBoolean,
  txHex: optionalString,
  txRequestId: optionalString,
  videoApprovers: Optional(t.array(t.string)),

  numBlocks: optionalNumber,
  feeRate: optionalNumber,
  maxFeeRate: optionalNumber,
  minConfirms: optionalNumber,
  enforceMinConfirmsForChange: optionalBoolean,
  targetWalletUnspents: optionalNumber,
  message: optionalString,
  minValue: optionalStringOrNumber,
  maxValue: optionalStringOrNumber,
  sequenceId: optionalStringOrNumber,
  lastLedgerSequence: optionalNumber,
  ledgerSequenceDelta: optionalNumber,
  gasPrice: optionalNumber,
  noSplitChange: optionalBoolean,
  unspents: t.array(t.string),
  changeAddress: optionalString,
  instant: optionalBoolean,
  transferId: optionalNumber,
  gasLimit: optionalNumber,
  custodianTransactionId: optionalString,

  cpfpTxIds: Optional(t.array(t.string)),
  cpfpFeeRate: optionalNumber,
  noCpfpFeeRate: optionalBoolean,
  maxFee: optionalNumber,
  noMaxFee: optionalBoolean,

  /// all other props from wp whitelist
  feeMultiplier: optionalNumber,
  addressType: optionalString,
  changeAddressType: optionalString,
  strategy: optionalString,
  strategyAllowFallback: optionalBoolean,
  fee: t.union([optionalString, t.partial(feeOptions)]),
  timeBounds: Optional(
    t.partial({
      minTime: optionalStringOrNumber,
      maxTime: optionalStringOrNumber,
    }),
  ),
  idfSignedTimestamp: optionalString,
  idfVersion: optionalNumber,
  idfUserId: optionalString,
  hopParams: t.partial({
    gasPriceMax: optionalNumber,
    paymentId: optionalString,
    userReqSig: optionalString,
  }),
  validFromBlock: optionalNumber,
  validToBlock: optionalNumber,
  type: optionalString,
  trustlines: t.partial({
    token: optionalString,
    action: optionalString,
    limit: optionalString,
  }),
  reservation: t.partial({
    expireTime: optionalString,
    pendingApprovalId: optionalString,
  }),
  delayMs: optionalNumber,
  messageKey: optionalString,
  senderAddress: optionalString,
  startTime: optionalString,
  nonParticipation: optionalBoolean,
  keyregTxBase64: optionalString,
  closeRemainderTo: optionalString,
  stateProofKey: optionalString,
  contractName: optionalString,
  functionName: optionalString,
  eip1559: Optional(eip1559),
  maxChangeOutputs: optionalNumber,
  smallestChangeSplitSize: optionalNumber,
  emergency: optionalBoolean,
  sourceChain: optionalString,
  destinationChain: optionalString,
  txFormat: optionalString,
  previewPendingTxs: optionalBoolean,
  pendingApprovalId: optionalString,
  stakingOptions: optionalUnknown,
  unstakingOptions: optionalUnknown,
  refundOptions: optionalUnknown,
  stakingParams: t.partial({
    actionType: optionalString,
    validator: optionalString,
    coin: optionalString,
    amount: optionalString,
  }),
  isReplaceableByFee: optionalBoolean,
  rbfTxIds: Optional(t.array(t.string)),
};

export const TxSendBody = t.exact(
  t.intersection([
    t.partial(txSendBody, "TxSendBody"),
    t.partial(CoinSpecificBuildParams.avaxp),
    t.partial(CoinSpecificBuildParams.dot),
    t.partial(CoinSpecificBuildParams.sol),
  ]),
);
export type TxSendBody = t.TypeOf<typeof TxSendBody>;

const entry = t.partial({
  address: t.string,
  wallet: t.string,
  value: t.number,
  valueString: t.string,
  isChange: t.boolean,
  isPayGo: t.boolean,
});
const historyItem = t.partial({
  date: t.string,
  action: t.string,
  user: t.string,
});

export const TxSendResponse = t.partial({
  baseValue: t.number,
  baseValueString: t.string,
  coin: t.string,
  coinSpecific: t.record(t.string, t.unknown),
  createdTime: t.string,
  date: t.string,
  enterprise: t.string,
  entries: t.array(entry),
  feeString: t.string,
  height: t.number,
  heightId: t.string,
  history: t.array(historyItem),
  id: t.string,
  instant: t.boolean,
  intendedValueString: t.string,
  isFee: t.boolean,
  isReward: t.boolean,
  metadata: t.record(t.string, t.unknown),
  payGoFee: t.number,
  payGoFeeString: t.string,
  signedDate: t.string,
  signedTime: t.string,
  state: t.string,
  tags: t.array(t.string),
  txid: t.string,
  txidType: t.string,
  txRequestId: t.string,
  type: t.string,
  usd: t.number,
  usdRate: t.number,
  value: t.number,
  valueString: t.string,
  vSize: t.number,
  wallet: t.string,
  walletType: t.string,
});
export type TxSendResponse = t.TypeOf<typeof TxSendResponse>;
