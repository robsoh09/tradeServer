import * as t from "io-ts";
export declare const MPCv2KeyGenRound1Request: t.TypeC<{
    userGpgPublicKey: import("io-ts-types").NonEmptyStringC;
    backupGpgPublicKey: import("io-ts-types").NonEmptyStringC;
    userMsg1: t.TypeC<{
        from: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        message: t.StringC;
        signature: t.StringC;
    }>;
    backupMsg1: t.TypeC<{
        from: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        message: t.StringC;
        signature: t.StringC;
    }>;
}>;
export type MPCv2KeyGenRound1Request = t.TypeOf<typeof MPCv2KeyGenRound1Request>;
export declare const MPCv2KeyGenRound1Response: t.TypeC<{
    walletGpgPubKeySigs: import("io-ts-types").NonEmptyStringC;
    sessionId: import("io-ts-types").NonEmptyStringC;
    bitgoMsg1: t.TypeC<{
        from: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        message: t.StringC;
        signature: t.StringC;
    }>;
    bitgoToUserMsg2: t.TypeC<{
        from: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        to: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        encryptedMessage: t.StringC;
        signature: t.StringC;
    }>;
    bitgoToBackupMsg2: t.TypeC<{
        from: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        to: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        encryptedMessage: t.StringC;
        signature: t.StringC;
    }>;
}>;
export type MPCv2KeyGenRound1Response = t.TypeOf<typeof MPCv2KeyGenRound1Response>;
export declare const MPCv2KeyGenRound2Request: t.TypeC<{
    sessionId: import("io-ts-types").NonEmptyStringC;
    userMsg2: t.TypeC<{
        from: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        to: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        encryptedMessage: t.StringC;
        signature: t.StringC;
    }>;
    userCommitment2: import("io-ts-types").NonEmptyStringC;
    backupMsg2: t.TypeC<{
        from: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        to: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        encryptedMessage: t.StringC;
        signature: t.StringC;
    }>;
    backupCommitment2: import("io-ts-types").NonEmptyStringC;
}>;
export type MPCv2KeyGenRound2Request = t.TypeOf<typeof MPCv2KeyGenRound2Request>;
export declare const MPCv2KeyGenRound2Response: t.TypeC<{
    sessionId: import("io-ts-types").NonEmptyStringC;
    bitgoCommitment2: import("io-ts-types").NonEmptyStringC;
    bitgoToUserMsg3: t.TypeC<{
        from: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        to: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        encryptedMessage: t.StringC;
        signature: t.StringC;
    }>;
    bitgoToBackupMsg3: t.TypeC<{
        from: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        to: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        encryptedMessage: t.StringC;
        signature: t.StringC;
    }>;
}>;
export type MPCv2KeyGenRound2Response = t.TypeOf<typeof MPCv2KeyGenRound2Response>;
export declare const MPCv2KeyGenRound3Request: t.TypeC<{
    sessionId: import("io-ts-types").NonEmptyStringC;
    userMsg3: t.TypeC<{
        from: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        to: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        encryptedMessage: t.StringC;
        signature: t.StringC;
    }>;
    backupMsg3: t.TypeC<{
        from: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        to: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        encryptedMessage: t.StringC;
        signature: t.StringC;
    }>;
    userMsg4: t.TypeC<{
        from: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        message: t.StringC;
        signature: t.StringC;
    }>;
    backupMsg4: t.TypeC<{
        from: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        message: t.StringC;
        signature: t.StringC;
    }>;
}>;
export type MPCv2KeyGenRound3Request = t.TypeOf<typeof MPCv2KeyGenRound3Request>;
export declare const MPCv2KeyGenRound3Response: t.TypeC<{
    sessionId: import("io-ts-types").NonEmptyStringC;
    commonKeychain: import("io-ts-types").NonEmptyStringC;
    bitgoMsg4: t.TypeC<{
        from: t.UnionC<[t.UnionC<[t.LiteralC<0>, t.LiteralC<1>, t.LiteralC<2>]>, t.Type<0 | 2 | 1, string, unknown>]>;
        message: t.StringC;
        signature: t.StringC;
    }>;
}>;
export type MPCv2KeyGenRound3Response = t.TypeOf<typeof MPCv2KeyGenRound3Response>;
