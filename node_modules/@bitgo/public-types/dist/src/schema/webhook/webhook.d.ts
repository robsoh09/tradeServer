import * as t from "io-ts";
export declare const Webhook: t.IntersectionC<[t.TypeC<{
    id: t.StringC;
    created: import("io-ts-types").DateFromISOStringC;
    coin: t.StringC;
    url: t.StringC;
    version: t.NumberC;
    state: t.KeyofC<typeof import("./webhookState").WebhookStateEnum>;
    successiveFailedAttempts: t.NumberC;
    listenToFailureStates: t.BooleanC;
}>, t.PartialC<{
    label: t.StringC;
    walletId: t.StringC;
    enterpriseId: t.StringC;
    organizationId: t.StringC;
    scope: t.KeyofC<typeof import("./webhookScope").WebhookScopeEnum>;
    userId: t.StringC;
    type: t.KeyofC<typeof import("./webhookType").WebhookTypeEnum>;
    numConfirmations: t.NumberC;
    lastAttempt: import("io-ts-types").DateFromISOStringC;
    failingSince: import("io-ts-types").DateFromISOStringC;
    allToken: t.BooleanC;
    txRequestStates: t.ArrayC<t.KeyofC<{
        pendingApproval: number;
        canceled: number;
        rejected: number;
        initialized: number;
        pendingDelivery: number;
        delivered: number;
        pendingUserSignature: number;
        pendingUserCommitment: number;
        pendingUserRShare: number;
        pendingUserGShare: number;
        readyToSend: number;
        signed: number;
        failed: number;
    }>>;
    txRequestTransactionStates: t.ArrayC<t.KeyofC<{
        initialized: number;
        pendingSignature: number;
        eddsaPendingCommitment: number;
        eddsaPendingRShare: number;
        eddsaPendingGShare: number;
        ecdsaMPCv2Round1: number;
        ecdsaMPCv2Round2: number;
        ecdsaMPCv2Round3: number;
        readyToCombineShares: number;
        signed: number;
        held: number;
        delivered: number;
        invalidSignature: number;
        rejected: number;
    }>>;
}>]>;
