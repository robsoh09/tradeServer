/// <reference types="node" />
import { CoinFamily, BaseCoin as StaticsBaseCoin } from '@bitgo/statics';
import { BaseCoin, BitGoBase, KeyPair, ParsedTransaction, ParseTransactionOptions, SignedTransaction, SignTransactionOptions, TransactionExplanation, TransactionFee, TransactionPrebuild as BaseTransactionPrebuild, TransactionRecipient as Recipient, VerifyAddressOptions, VerifyTransactionOptions, BaseTransaction } from '@bitgo/sdk-core';
import { Interface } from './lib';
import { TransactionReceipt } from './lib/iface';
export declare const MINIMUM_TRON_MSIG_TRANSACTION_FEE = 1000000;
export declare const SAFE_TRON_TRANSACTION_FEE: number;
export declare const SAFE_TRON_TOKEN_TRANSACTION_FEE: number;
export declare const RECOVER_TRANSACTION_EXPIRY = 86400000;
export declare const DEFAULT_SCAN_FACTOR = 20;
export interface TronSignTransactionOptions extends SignTransactionOptions {
    txPrebuild: TransactionPrebuild;
    prv: string;
}
export interface TxInfo {
    recipients: Recipient[];
    from: string;
    txid: string;
}
export interface AddressInfo {
    address: string;
    chain: number;
    index: number;
}
export interface TronTransactionExplanation extends TransactionExplanation {
    expiration: number;
    timestamp: number;
}
export interface TransactionPrebuild extends BaseTransactionPrebuild {
    txHex: string;
    txInfo: TxInfo;
    addressInfo?: AddressInfo;
    feeInfo: TransactionFee;
}
export interface ExplainTransactionOptions {
    txHex?: string;
    halfSigned?: {
        txHex: string;
    };
    feeInfo: TransactionFee;
}
export interface RecoveryOptions {
    userKey: string;
    backupKey: string;
    bitgoKey: string;
    recoveryDestination: string;
    krsProvider?: string;
    tokenContractAddress?: string;
    walletPassphrase?: string;
    startingScanIndex?: number;
    scan?: number;
}
export interface ConsolidationRecoveryOptions {
    userKey: string;
    backupKey: string;
    bitgoKey: string;
    tokenContractAddress?: string;
    startingScanIndex?: number;
    endingScanIndex?: number;
}
export interface ConsolidationRecoveryBatch {
    transactions: RecoveryTransaction[];
}
export interface FeeInfo {
    fee: string;
}
export interface RecoveryTransaction {
    txHex?: string;
    feeInfo?: FeeInfo;
    coin?: string;
    tx?: TransactionPrebuild;
    recoveryAmount?: number;
    tokenTxs?: TransactionReceipt[];
    addressInfo?: AddressInfo;
}
export declare enum NodeTypes {
    Full = 0,
    Solidity = 1
}
/**
 * This structure is not a complete model of the AccountResponse from a node.
 */
export interface AccountResponse {
    data: [Interface.AccountInfo];
}
export declare class Trx extends BaseCoin {
    protected readonly _staticsCoin: Readonly<StaticsBaseCoin>;
    constructor(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>);
    getChain(): string;
    getFamily(): CoinFamily;
    getFullName(): string;
    getBaseFactor(): number;
    /** @inheritdoc */
    transactionDataAllowed(): boolean;
    static createInstance(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>): BaseCoin;
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed(): boolean;
    /** @inheritDoc */
    allowsAccountConsolidations(): boolean;
    /**
     * Checks if this is a valid base58 or hex address
     * @param address
     */
    isValidAddress(address: string): boolean;
    /**
     * Checks if this is a valid hex address
     * @param address hex address
     */
    isValidHexAddress(address: string): boolean;
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    generateKeyPair(seed?: Buffer): KeyPair;
    isValidXpub(xpub: string): boolean;
    isValidPub(pub: string): boolean;
    parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
    isWalletAddress(params: VerifyAddressOptions): Promise<boolean>;
    verifyTransaction(params: VerifyTransactionOptions): Promise<boolean>;
    /**
     * Derive a user key using the chain path of the address
     * @param key
     * @param path
     * @returns {string} derived private key
     */
    deriveKeyWithPath({ key, path }: {
        key: string;
        path: string;
    }): string;
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param params.wallet.addressVersion {String} this is the version of the Algorand multisig address generation format
     * @returns Bluebird<SignedTransaction>
     */
    signTransaction(params: TronSignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Return boolean indicating whether input is valid seed for the coin
     *
     * @param prv - the prv to be checked
     */
    isValidXprv(prv: string): boolean;
    /**
     * Convert a message to string in hexadecimal format.
     *
     * @param message {Buffer|String} message to sign
     * @return the message as a hexadecimal string
     */
    toHexString(message: string | Buffer): string;
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    signMessage(key: KeyPair, message: string | Buffer): Promise<Buffer>;
    /**
     * Converts an xpub to a uncompressed pub
     * @param xpub
     */
    xpubToUncompressedPub(xpub: string): string;
    /**
     * Modify prebuild before sending it to the server.
     * @param buildParams The whitelisted parameters for this prebuild
     */
    getExtraPrebuildParams(buildParams: any): Promise<any>;
    pubToHexAddress(pub: string): string;
    xprvToCompressedPrv(xprv: string): string;
    private getNodeUrl;
    /**
     * Make a query to Trongrid for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @returns {Object} response from Trongrid
     */
    private recoveryPost;
    /**
     * Make a query to Trongrid for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @returns {Object} response from Trongrid
     */
    private recoveryGet;
    /**
     * Query our explorer for the balance of an address
     * @param address {String} the address encoded in hex
     * @returns {BigNumber} address balance
     */
    private getAccountBalancesFromNode;
    /**
     * Retrieves our build transaction from a node.
     * @param toAddr hex-encoded address
     * @param fromAddr hex-encoded address
     * @param amount
     */
    private getBuildTransaction;
    /**
     * Retrieves our build transaction from a node.
     * @param toAddr hex-encoded address
     * @param fromAddr hex-encoded address
     * @param amount
     */
    private getTriggerSmartContractTransaction;
    /**
     * Throws an error if any keys in the ownerKeys collection don't match the keys array we pass
     * @param ownerKeys
     * @param keys
     */
    checkPermissions(ownerKeys: {
        address: string;
        weight: number;
    }[], keys: string[]): void;
    /**
     * Format for offline vault signing
     * @param {BaseTransaction} tx
     * @param {number} fee
     * @param {number} recoveryAmount
     * @returns {RecoveryTransaction}
     */
    formatForOfflineVault(tx: BaseTransaction, fee: number, recoveryAmount: number, addressInfo?: AddressInfo): RecoveryTransaction;
    /**
     * Builds a funds recovery transaction without BitGo.
     * We need to do three queries during this:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     *
     * Note 1: for base address recoveries, fund will be recovered to recovery destination if base address balance is
     * more than 2.1 TRX for native TRX recovery and 100 TRX for token recover. For receive addresses, fund will be
     * recovered to base address first then swept to base address(decided as the universal pattern in team meeting).
     *
     * Note 2: the function supports token sweep from base address.
     * TODO: support token sweep from receive address.
     *
     * @param params
     */
    recover(params: RecoveryOptions): Promise<RecoveryTransaction>;
    /**
     * Builds native TRX recoveries of receive addresses in batch without BitGo.
     * Funds will be recovered to base address first. You need to initiate another sweep txn after that.
     * Note: there will be another recoverTokenConsolidations function to support token recover from receive addresses.
     *
     * @param {ConsolidationRecoveryOptions} params - options for consolidation recovery.
     * @param {string} [params.startingScanIndex] - receive address index to start scanning from. default to 1 (inclusive).
     * @param {string} [params.endingScanIndex] - receive address index to end scanning at. default to startingScanIndex + 20 (exclusive).
     */
    recoverConsolidations(params: ConsolidationRecoveryOptions): Promise<ConsolidationRecoveryBatch>;
    /**
     * Explain a Tron transaction from txHex
     * @param params
     */
    explainTransaction(params: ExplainTransactionOptions): Promise<TronTransactionExplanation>;
}
//# sourceMappingURL=trx.d.ts.map