"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeDataParams = exports.encodeDataParams = exports.toHex = exports.isValidRawTransactionFormat = exports.isValidTxJsonString = exports.decodeAccountPermissionUpdateContract = exports.decodeTriggerSmartContract = exports.decodeTransferContract = exports.isValidHex = exports.decodeRawTransaction = exports.decodeTransaction = exports.getRawAddressFromPubKey = exports.signString = exports.signTransaction = exports.getBase58AddressFromHex = exports.getBase58AddressFromByteArray = exports.getAddressFromPriKey = exports.getPubKeyFromPriKey = exports.getHexAddressFromBase58Address = exports.verifySignature = exports.getHexAddressFromByteArray = exports.getByteArrayFromHexAddress = exports.isBase58Address = exports.tokenTestnetContractAddresses = exports.tokenMainnetContractAddresses = void 0;
const assert_1 = __importDefault(require("assert"));
const hex = __importStar(require("@stablelib/hex"));
const tronweb = __importStar(require("tronweb"));
const tron_1 = require("../../resources/protobuf/tron");
const sdk_core_1 = require("@bitgo/sdk-core");
const statics_1 = require("@bitgo/statics");
const enum_1 = require("./enum");
const utils_1 = require("ethers/lib/utils");
const ADDRESS_PREFIX_REGEX = /^(41)/;
const ADDRESS_PREFIX = '41';
const getTronTokens = (network = 'mainnet') => {
    return statics_1.coins
        .filter((coin) => coin.family === 'trx')
        .filter((trx) => trx.network.type === network && trx.isToken).map((coins) => coins.contractAddress.toString());
};
exports.tokenMainnetContractAddresses = getTronTokens('mainnet');
exports.tokenTestnetContractAddresses = getTronTokens('testnet');
/**
 * @param address
 */
function isBase58Address(address) {
    return tronweb.utils.crypto.isAddressValid(address);
}
exports.isBase58Address = isBase58Address;
/**
 * @param str
 */
function getByteArrayFromHexAddress(str) {
    return tronweb.utils.code.hexStr2byteArray(str.replace('0x', ''));
}
exports.getByteArrayFromHexAddress = getByteArrayFromHexAddress;
/**
 * @param arr
 */
function getHexAddressFromByteArray(arr) {
    return tronweb.utils.code.byteArray2hexStr(arr);
}
exports.getHexAddressFromByteArray = getHexAddressFromByteArray;
/**
 * @param messageToVerify
 * @param base58Address
 * @param sigHex
 * @param useTronHeader
 */
function verifySignature(messageToVerify, base58Address, sigHex, useTronHeader = true) {
    if (!isValidHex(sigHex)) {
        throw new sdk_core_1.UtilsError('signature is not in a valid format, needs to be hexadecimal');
    }
    if (!isValidHex(messageToVerify)) {
        throw new sdk_core_1.UtilsError('message is not in a valid format, needs to be hexadecimal');
    }
    if (!isBase58Address(base58Address)) {
        throw new sdk_core_1.UtilsError('address needs to be base58 encoded');
    }
    return tronweb.Trx.verifySignature(messageToVerify, base58Address, sigHex, useTronHeader);
}
exports.verifySignature = verifySignature;
/**
 * @param base58
 */
function getHexAddressFromBase58Address(base58) {
    // pulled from: https://github.com/TRON-US/tronweb/blob/dcb8efa36a5ebb65c4dab3626e90256a453f3b0d/src/utils/help.js#L17
    // but they don't surface this call in index.js
    const bytes = tronweb.utils.crypto.decodeBase58Address(base58);
    return getHexAddressFromByteArray(bytes);
}
exports.getHexAddressFromBase58Address = getHexAddressFromBase58Address;
/**
 * @param privateKey
 */
function getPubKeyFromPriKey(privateKey) {
    return tronweb.utils.crypto.getPubKeyFromPriKey(privateKey);
}
exports.getPubKeyFromPriKey = getPubKeyFromPriKey;
/**
 * @param privateKey
 */
function getAddressFromPriKey(privateKey) {
    return tronweb.utils.crypto.getAddressFromPriKey(privateKey);
}
exports.getAddressFromPriKey = getAddressFromPriKey;
/**
 * @param address
 */
function getBase58AddressFromByteArray(address) {
    return tronweb.utils.crypto.getBase58CheckAddress(address);
}
exports.getBase58AddressFromByteArray = getBase58AddressFromByteArray;
/**
 * @param hex
 */
function getBase58AddressFromHex(hex) {
    const arr = getByteArrayFromHexAddress(hex);
    return getBase58AddressFromByteArray(arr);
}
exports.getBase58AddressFromHex = getBase58AddressFromHex;
/**
 * @param privateKey
 * @param transaction
 */
function signTransaction(privateKey, transaction) {
    return tronweb.utils.crypto.signTransaction(privateKey, transaction);
}
exports.signTransaction = signTransaction;
/**
 * @param message
 * @param privateKey
 * @param useTronHeader
 */
function signString(message, privateKey, useTronHeader = true) {
    return tronweb.Trx.signString(message, privateKey, useTronHeader);
}
exports.signString = signString;
/**
 * @param pubBytes
 */
function getRawAddressFromPubKey(pubBytes) {
    return tronweb.utils.crypto.computeAddress(pubBytes);
}
exports.getRawAddressFromPubKey = getRawAddressFromPubKey;
/**
 * Decodes a hex encoded transaction in its protobuf representation.
 *
 * @param hexString raw_data_hex field from tron transactions
 */
function decodeTransaction(hexString) {
    const rawTransaction = decodeRawTransaction(hexString);
    // there should not be multiple contracts in this data
    if (rawTransaction.contracts.length !== 1) {
        throw new sdk_core_1.UtilsError('Number of contracts is greater than 1.');
    }
    let contract;
    let contractType;
    // ensure the contract type is supported
    switch (rawTransaction.contracts[0].parameter.type_url) {
        case 'type.googleapis.com/protocol.TransferContract':
            contractType = enum_1.ContractType.Transfer;
            contract = exports.decodeTransferContract(rawTransaction.contracts[0].parameter.value);
            break;
        case 'type.googleapis.com/protocol.AccountPermissionUpdateContract':
            contractType = enum_1.ContractType.AccountPermissionUpdate;
            contract = exports.decodeAccountPermissionUpdateContract(rawTransaction.contracts[0].parameter.value);
            break;
        case 'type.googleapis.com/protocol.TriggerSmartContract':
            contractType = enum_1.ContractType.TriggerSmartContract;
            contract = exports.decodeTriggerSmartContract(rawTransaction.contracts[0].parameter.value);
            break;
        default:
            throw new sdk_core_1.UtilsError('Unsupported contract type');
    }
    return {
        contractType,
        contract,
        expiration: rawTransaction.expiration,
        timestamp: rawTransaction.timestamp,
        ref_block_bytes: rawTransaction.blockBytes,
        ref_block_hash: rawTransaction.blockHash,
        fee_limit: +rawTransaction.feeLimit,
    };
}
exports.decodeTransaction = decodeTransaction;
/**
 * Decodes a transaction's raw field from a base64 encoded string. This is a protobuf representation.
 *
 * @param hexString this is the raw hexadecimal encoded string. Doc found in the following link.
 * @example
 * @see {@link https://github.com/BitGo/bitgo-account-lib/blob/5f282588701778a4421c75fa61f42713f56e95b9/resources/protobuf/tron.proto#L319}
 */
function decodeRawTransaction(hexString) {
    const bytes = Buffer.from(hexString, 'hex');
    let raw;
    try {
        // we need to decode our raw_data_hex field first
        raw = tron_1.protocol.Transaction.raw.decode(bytes);
    }
    catch (e) {
        throw new sdk_core_1.UtilsError('There was an error decoding the initial raw_data_hex from the serialized tx.');
    }
    return {
        expiration: Number(raw.expiration),
        timestamp: Number(raw.timestamp),
        contracts: raw.contract,
        blockBytes: toHex(raw.refBlockBytes),
        feeLimit: raw.feeLimit,
        blockHash: toHex(raw.refBlockHash),
    };
}
exports.decodeRawTransaction = decodeRawTransaction;
/**
 * Indicates whether the passed string is a safe hex string for tron's purposes.
 *
 * @param hex A valid hex string must be a string made of numbers and characters and has an even length.
 */
function isValidHex(hex) {
    return /^(0x)?([0-9a-f]{2})+$/i.test(hex);
}
exports.isValidHex = isValidHex;
/** Deserialize the segment of the txHex which corresponds with the details of the transfer
 *
 * @param transferHex is the value property of the "parameter" field of contractList[0]
 * */
function decodeTransferContract(transferHex) {
    const contractBytes = Buffer.from(transferHex, 'base64');
    let transferContract;
    try {
        transferContract = tron_1.protocol.TransferContract.decode(contractBytes);
    }
    catch (e) {
        throw new sdk_core_1.UtilsError('There was an error decoding the transfer contract in the transaction.');
    }
    if (!transferContract.ownerAddress) {
        throw new sdk_core_1.UtilsError('Owner address does not exist in this transfer contract.');
    }
    if (!transferContract.toAddress) {
        throw new sdk_core_1.UtilsError('Destination address does not exist in this transfer contract.');
    }
    if (!transferContract.hasOwnProperty('amount')) {
        throw new sdk_core_1.UtilsError('Amount does not exist in this transfer contract.');
    }
    // deserialize attributes
    const owner_address = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(transferContract.ownerAddress, 'base64').toString('hex')));
    const to_address = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(transferContract.toAddress, 'base64').toString('hex')));
    const amount = transferContract.amount;
    return [
        {
            parameter: {
                value: {
                    amount: Number(amount),
                    owner_address,
                    to_address,
                },
            },
        },
    ];
}
exports.decodeTransferContract = decodeTransferContract;
/**
 * Deserialize the segment of the txHex corresponding with trigger smart contract
 *
 * @param {string} base64
 * @returns {AccountPermissionUpdateContract}
 */
function decodeTriggerSmartContract(base64) {
    let contractCallDecoded;
    try {
        contractCallDecoded = tron_1.protocol.TriggerSmartContract.decode(Buffer.from(base64, 'base64')).toJSON();
    }
    catch (e) {
        throw new sdk_core_1.UtilsError('There was an error decoding the contract call in the transaction.');
    }
    if (!contractCallDecoded.ownerAddress) {
        throw new sdk_core_1.UtilsError('Owner address does not exist in this contract call.');
    }
    if (!contractCallDecoded.contractAddress) {
        throw new sdk_core_1.UtilsError('Destination contract address does not exist in this contract call.');
    }
    if (!contractCallDecoded.data) {
        throw new sdk_core_1.UtilsError('Data does not exist in this contract call.');
    }
    // deserialize attributes
    const owner_address = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(contractCallDecoded.ownerAddress, 'base64').toString('hex')));
    const contract_address = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(contractCallDecoded.contractAddress, 'base64').toString('hex')));
    const data = contractCallDecoded.data;
    return [
        {
            parameter: {
                value: {
                    data: data,
                    owner_address,
                    contract_address,
                },
            },
        },
    ];
}
exports.decodeTriggerSmartContract = decodeTriggerSmartContract;
/**
 * Deserialize the segment of the txHex corresponding with the details of the contract which updates
 * account permission
 *
 * @param {string} base64
 * @returns {AccountPermissionUpdateContract}
 */
function decodeAccountPermissionUpdateContract(base64) {
    const accountUpdateContract = tron_1.protocol.AccountPermissionUpdateContract.decode(Buffer.from(base64, 'base64')).toJSON();
    (0, assert_1.default)(accountUpdateContract.ownerAddress);
    (0, assert_1.default)(accountUpdateContract.owner);
    (0, assert_1.default)(accountUpdateContract.hasOwnProperty('actives'));
    const ownerAddress = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(accountUpdateContract.ownerAddress, 'base64').toString('hex')));
    const owner = createPermission(accountUpdateContract.owner);
    let witness = undefined;
    if (accountUpdateContract.witness) {
        witness = createPermission(accountUpdateContract.witness);
    }
    const activeList = accountUpdateContract.actives.map((active) => createPermission(active));
    return {
        ownerAddress,
        owner,
        witness,
        actives: activeList,
    };
}
exports.decodeAccountPermissionUpdateContract = decodeAccountPermissionUpdateContract;
/**
 * @param raw
 */
function createPermission(raw) {
    let permissionType;
    const permission = raw.permissionName.toLowerCase().trim();
    if (permission === 'owner') {
        permissionType = enum_1.PermissionType.Owner;
    }
    else if (permission === 'witness') {
        permissionType = enum_1.PermissionType.Witness;
    }
    else if (permission.substr(0, 6) === 'active') {
        permissionType = enum_1.PermissionType.Active;
    }
    else {
        throw new sdk_core_1.UtilsError('Permission type not parseable.');
    }
    return { type: permissionType, threshold: raw.threshold };
}
/**
 * @param rawTransaction
 */
function isValidTxJsonString(rawTransaction) {
    const transaction = JSON.parse(rawTransaction);
    return transaction.hasOwnProperty('txID');
}
exports.isValidTxJsonString = isValidTxJsonString;
/**
 * Returns whether the provided raw transaction accommodates to bitgo's preferred format
 *
 * @param {any} rawTransaction - The raw transaction to be checked
 * @returns {boolean} the validation result
 */
function isValidRawTransactionFormat(rawTransaction) {
    if (typeof rawTransaction === 'string' && (isValidHex(rawTransaction) || isValidTxJsonString(rawTransaction))) {
        return true;
    }
    return false;
}
exports.isValidRawTransactionFormat = isValidRawTransactionFormat;
/**
 * Returns an hex string of the given buffer
 *
 * @param {Buffer | Uint8Array} buffer - the buffer to be converted to hex
 * @returns {string} - the hex value
 */
function toHex(buffer) {
    return hex.encode(buffer, true);
}
exports.toHex = toHex;
/**
 * Returns a Keccak-256 encoded string of the parameters
 *
 * @param types - strings describing the types of the values
 * @param values - value to encode
 * @param methodId - the first 4 bytes of the function selector
 */
function encodeDataParams(types, values, methodId) {
    types.forEach((type, index) => {
        if (type == 'address') {
            values[index] = values[index].replace(ADDRESS_PREFIX_REGEX, '0x');
        }
    });
    const abiCoder = new utils_1.AbiCoder();
    let data;
    try {
        data = abiCoder.encode(types, values);
    }
    catch (e) {
        throw new sdk_core_1.UtilsError(`There was an error encoding the data params. Error = ${JSON.stringify(e)}`);
    }
    if (methodId) {
        return (0, utils_1.hexConcat)([methodId, data]).replace(/^(0x)/, '');
    }
    else {
        return data.replace(/^(0x)/, '');
    }
}
exports.encodeDataParams = encodeDataParams;
/**
 * Returns the decoded values according to the array of types
 *
 * @param types - strings describing the types of the values
 * @param data - encoded string
 */
function decodeDataParams(types, data) {
    const abiCoder = new utils_1.AbiCoder();
    data = '0x' + data.substring(8);
    return abiCoder.decode(types, data).reduce((obj, arg, index) => {
        if (types[index] == 'address')
            arg = ADDRESS_PREFIX + arg.substr(2).toLowerCase();
        obj.push(arg);
        return obj;
    }, []);
}
exports.decodeDataParams = decodeDataParams;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0RBQTRCO0FBQzVCLG9EQUFzQztBQUN0QyxpREFBbUM7QUFDbkMsd0RBQXlEO0FBRXpELDhDQUE2QztBQUM3Qyw0Q0FBc0Q7QUFTdEQsaUNBQXNEO0FBQ3RELDRDQUF1RDtBQUV2RCxNQUFNLG9CQUFvQixHQUFHLE9BQU8sQ0FBQztBQUNyQyxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUM7QUFFNUIsTUFBTSxhQUFhLEdBQUcsQ0FBQyxPQUFPLEdBQUcsU0FBUyxFQUFFLEVBQUU7SUFDNUMsT0FDRSxlQUFLO1NBQ0YsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxLQUFLLEtBQUssQ0FBQztTQUN2QyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxLQUFLLE9BQU8sSUFBSSxHQUFHLENBQUMsT0FBTyxDQUMvRCxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0FBQ3JELENBQUMsQ0FBQztBQUVXLFFBQUEsNkJBQTZCLEdBQUcsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ3pELFFBQUEsNkJBQTZCLEdBQUcsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBT3RFOztHQUVHO0FBQ0gsU0FBZ0IsZUFBZSxDQUFDLE9BQWU7SUFDN0MsT0FBTyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDdEQsQ0FBQztBQUZELDBDQUVDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQiwwQkFBMEIsQ0FBQyxHQUFX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QUUsQ0FBQyxDQUFDO0tBQ25HO0lBQ0QsSUFBSSxRQUFRLEVBQUU7UUFDWixPQUFPLElBQUEsaUJBQVMsRUFBQyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7S0FDekQ7U0FBTTtRQUNMLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7S0FDbEM7QUFDSCxDQUFDO0FBbkJELDRDQW1CQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsZ0JBQWdCLENBQUMsS0FBZSxFQUFFLElBQVk7SUFDNUQsTUFBTSxRQUFRLEdBQUcsSUFBSSxnQkFBUSxFQUFFLENBQUM7SUFDaEMsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hDLE9BQU8sUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsRUFBRTtRQUM3RCxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxTQUFTO1lBQUUsR0FBRyxHQUFHLGNBQWMsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ2xGLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDZCxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNULENBQUM7QUFSRCw0Q0FRQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCAqIGFzIGhleCBmcm9tICdAc3RhYmxlbGliL2hleCc7XG5pbXBvcnQgKiBhcyB0cm9ud2ViIGZyb20gJ3Ryb253ZWInO1xuaW1wb3J0IHsgcHJvdG9jb2wgfSBmcm9tICcuLi8uLi9yZXNvdXJjZXMvcHJvdG9idWYvdHJvbic7XG5cbmltcG9ydCB7IFV0aWxzRXJyb3IgfSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgVHJvbkVyYzIwQ29pbiwgY29pbnMgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQge1xuICBUcmFuc2ZlckNvbnRyYWN0LFxuICBSYXdEYXRhLFxuICBBY2NvdW50UGVybWlzc2lvblVwZGF0ZUNvbnRyYWN0LFxuICBUcmFuc2FjdGlvblJlY2VpcHQsXG4gIFBlcm1pc3Npb24sXG4gIFRyaWdnZXJTbWFydENvbnRyYWN0LFxufSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IENvbnRyYWN0VHlwZSwgUGVybWlzc2lvblR5cGUgfSBmcm9tICcuL2VudW0nO1xuaW1wb3J0IHsgQWJpQ29kZXIsIGhleENvbmNhdCB9IGZyb20gJ2V0aGVycy9saWIvdXRpbHMnO1xuXG5jb25zdCBBRERSRVNTX1BSRUZJWF9SRUdFWCA9IC9eKDQxKS87XG5jb25zdCBBRERSRVNTX1BSRUZJWCA9ICc0MSc7XG5cbmNvbnN0IGdldFRyb25Ub2tlbnMgPSAobmV0d29yayA9ICdtYWlubmV0JykgPT4ge1xuICByZXR1cm4gKFxuICAgIGNvaW5zXG4gICAgICAuZmlsdGVyKChjb2luKSA9PiBjb2luLmZhbWlseSA9PT0gJ3RyeCcpXG4gICAgICAuZmlsdGVyKCh0cngpID0+IHRyeC5uZXR3b3JrLnR5cGUgPT09IG5ldHdvcmsgJiYgdHJ4LmlzVG9rZW4pIGFzIHVua25vd24gYXMgVHJvbkVyYzIwQ29pbltdXG4gICkubWFwKChjb2lucykgPT4gY29pbnMuY29udHJhY3RBZGRyZXNzLnRvU3RyaW5nKCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHRva2VuTWFpbm5ldENvbnRyYWN0QWRkcmVzc2VzID0gZ2V0VHJvblRva2VucygnbWFpbm5ldCcpO1xuZXhwb3J0IGNvbnN0IHRva2VuVGVzdG5ldENvbnRyYWN0QWRkcmVzc2VzID0gZ2V0VHJvblRva2VucygndGVzdG5ldCcpO1xuLyoqXG4gKiBUcm9uLXNwZWNpZmljIGhlbHBlciBmdW5jdGlvbnNcbiAqL1xuZXhwb3J0IHR5cGUgVHJvbkJpbmFyeUxpa2UgPSBCeXRlQXJyYXkgfCBCdWZmZXIgfCBVaW50OEFycmF5IHwgc3RyaW5nO1xuZXhwb3J0IHR5cGUgQnl0ZUFycmF5ID0gbnVtYmVyW107XG5cbi8qKlxuICogQHBhcmFtIGFkZHJlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmFzZTU4QWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIHRyb253ZWIudXRpbHMuY3J5cHRvLmlzQWRkcmVzc1ZhbGlkKGFkZHJlc3MpO1xufVxuXG4vKipcbiAqIEBwYXJhbSBzdHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ5dGVBcnJheUZyb21IZXhBZGRyZXNzKHN0cjogc3RyaW5nKTogQnl0ZUFycmF5IHtcbiAgcmV0dXJuIHRyb253ZWIudXRpbHMuY29kZS5oZXhTdHIyYnl0ZUFycmF5KHN0ci5yZXBsYWNlKCcweCcsICcnKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIGFyclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGV4QWRkcmVzc0Zyb21CeXRlQXJyYXkoYXJyOiBCeXRlQXJyYXkpOiBzdHJpbmcge1xuICByZXR1cm4gdHJvbndlYi51dGlscy5jb2RlLmJ5dGVBcnJheTJoZXhTdHIoYXJyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gbWVzc2FnZVRvVmVyaWZ5XG4gKiBAcGFyYW0gYmFzZTU4QWRkcmVzc1xuICogQHBhcmFtIHNpZ0hleFxuICogQHBhcmFtIHVzZVRyb25IZWFkZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZShcbiAgbWVzc2FnZVRvVmVyaWZ5OiBzdHJpbmcsXG4gIGJhc2U1OEFkZHJlc3M6IHN0cmluZyxcbiAgc2lnSGV4OiBzdHJpbmcsXG4gIHVzZVRyb25IZWFkZXIgPSB0cnVlXG4pOiBib29sZWFuIHtcbiAgaWYgKCFpc1ZhbGlkSGV4KHNpZ0hleCkpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignc2lnbmF0dXJlIGlzIG5vdCBpbiBhIHZhbGlkIGZvcm1hdCwgbmVlZHMgdG8gYmUgaGV4YWRlY2ltYWwnKTtcbiAgfVxuXG4gIGlmICghaXNWYWxpZEhleChtZXNzYWdlVG9WZXJpZnkpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ21lc3NhZ2UgaXMgbm90IGluIGEgdmFsaWQgZm9ybWF0LCBuZWVkcyB0byBiZSBoZXhhZGVjaW1hbCcpO1xuICB9XG5cbiAgaWYgKCFpc0Jhc2U1OEFkZHJlc3MoYmFzZTU4QWRkcmVzcykpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignYWRkcmVzcyBuZWVkcyB0byBiZSBiYXNlNTggZW5jb2RlZCcpO1xuICB9XG5cbiAgcmV0dXJuIHRyb253ZWIuVHJ4LnZlcmlmeVNpZ25hdHVyZShtZXNzYWdlVG9WZXJpZnksIGJhc2U1OEFkZHJlc3MsIHNpZ0hleCwgdXNlVHJvbkhlYWRlcik7XG59XG5cbi8qKlxuICogQHBhcmFtIGJhc2U1OFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGV4QWRkcmVzc0Zyb21CYXNlNThBZGRyZXNzKGJhc2U1ODogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gcHVsbGVkIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9UUk9OLVVTL3Ryb253ZWIvYmxvYi9kY2I4ZWZhMzZhNWViYjY1YzRkYWIzNjI2ZTkwMjU2YTQ1M2YzYjBkL3NyYy91dGlscy9oZWxwLmpzI0wxN1xuICAvLyBidXQgdGhleSBkb24ndCBzdXJmYWNlIHRoaXMgY2FsbCBpbiBpbmRleC5qc1xuICBjb25zdCBieXRlcyA9IHRyb253ZWIudXRpbHMuY3J5cHRvLmRlY29kZUJhc2U1OEFkZHJlc3MoYmFzZTU4KTtcbiAgcmV0dXJuIGdldEhleEFkZHJlc3NGcm9tQnl0ZUFycmF5KGJ5dGVzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gcHJpdmF0ZUtleVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHViS2V5RnJvbVByaUtleShwcml2YXRlS2V5OiBUcm9uQmluYXJ5TGlrZSk6IEJ5dGVBcnJheSB7XG4gIHJldHVybiB0cm9ud2ViLnV0aWxzLmNyeXB0by5nZXRQdWJLZXlGcm9tUHJpS2V5KHByaXZhdGVLZXkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSBwcml2YXRlS2V5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRyZXNzRnJvbVByaUtleShwcml2YXRlS2V5OiBUcm9uQmluYXJ5TGlrZSk6IEJ5dGVBcnJheSB7XG4gIHJldHVybiB0cm9ud2ViLnV0aWxzLmNyeXB0by5nZXRBZGRyZXNzRnJvbVByaUtleShwcml2YXRlS2V5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gYWRkcmVzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmFzZTU4QWRkcmVzc0Zyb21CeXRlQXJyYXkoYWRkcmVzczogQnl0ZUFycmF5KTogc3RyaW5nIHtcbiAgcmV0dXJuIHRyb253ZWIudXRpbHMuY3J5cHRvLmdldEJhc2U1OENoZWNrQWRkcmVzcyhhZGRyZXNzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gaGV4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCYXNlNThBZGRyZXNzRnJvbUhleChoZXg6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGFyciA9IGdldEJ5dGVBcnJheUZyb21IZXhBZGRyZXNzKGhleCk7XG4gIHJldHVybiBnZXRCYXNlNThBZGRyZXNzRnJvbUJ5dGVBcnJheShhcnIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSBwcml2YXRlS2V5XG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ25UcmFuc2FjdGlvbihwcml2YXRlS2V5OiBzdHJpbmcgfCBCeXRlQXJyYXksIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblJlY2VpcHQpOiBUcmFuc2FjdGlvblJlY2VpcHQge1xuICByZXR1cm4gdHJvbndlYi51dGlscy5jcnlwdG8uc2lnblRyYW5zYWN0aW9uKHByaXZhdGVLZXksIHRyYW5zYWN0aW9uKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gbWVzc2FnZVxuICogQHBhcmFtIHByaXZhdGVLZXlcbiAqIEBwYXJhbSB1c2VUcm9uSGVhZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWduU3RyaW5nKG1lc3NhZ2U6IHN0cmluZywgcHJpdmF0ZUtleTogc3RyaW5nIHwgQnl0ZUFycmF5LCB1c2VUcm9uSGVhZGVyID0gdHJ1ZSk6IHN0cmluZyB7XG4gIHJldHVybiB0cm9ud2ViLlRyeC5zaWduU3RyaW5nKG1lc3NhZ2UsIHByaXZhdGVLZXksIHVzZVRyb25IZWFkZXIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSBwdWJCeXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmF3QWRkcmVzc0Zyb21QdWJLZXkocHViQnl0ZXM6IFRyb25CaW5hcnlMaWtlKTogQnl0ZUFycmF5IHtcbiAgcmV0dXJuIHRyb253ZWIudXRpbHMuY3J5cHRvLmNvbXB1dGVBZGRyZXNzKHB1YkJ5dGVzKTtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgaGV4IGVuY29kZWQgdHJhbnNhY3Rpb24gaW4gaXRzIHByb3RvYnVmIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBwYXJhbSBoZXhTdHJpbmcgcmF3X2RhdGFfaGV4IGZpZWxkIGZyb20gdHJvbiB0cmFuc2FjdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRyYW5zYWN0aW9uKGhleFN0cmluZzogc3RyaW5nKTogUmF3RGF0YSB7XG4gIGNvbnN0IHJhd1RyYW5zYWN0aW9uID0gZGVjb2RlUmF3VHJhbnNhY3Rpb24oaGV4U3RyaW5nKTtcblxuICAvLyB0aGVyZSBzaG91bGQgbm90IGJlIG11bHRpcGxlIGNvbnRyYWN0cyBpbiB0aGlzIGRhdGFcbiAgaWYgKHJhd1RyYW5zYWN0aW9uLmNvbnRyYWN0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignTnVtYmVyIG9mIGNvbnRyYWN0cyBpcyBncmVhdGVyIHRoYW4gMS4nKTtcbiAgfVxuXG4gIGxldCBjb250cmFjdDogVHJhbnNmZXJDb250cmFjdFtdIHwgQWNjb3VudFBlcm1pc3Npb25VcGRhdGVDb250cmFjdFtdIHwgVHJpZ2dlclNtYXJ0Q29udHJhY3RbXTtcbiAgbGV0IGNvbnRyYWN0VHlwZTogQ29udHJhY3RUeXBlO1xuICAvLyBlbnN1cmUgdGhlIGNvbnRyYWN0IHR5cGUgaXMgc3VwcG9ydGVkXG4gIHN3aXRjaCAocmF3VHJhbnNhY3Rpb24uY29udHJhY3RzWzBdLnBhcmFtZXRlci50eXBlX3VybCkge1xuICAgIGNhc2UgJ3R5cGUuZ29vZ2xlYXBpcy5jb20vcHJvdG9jb2wuVHJhbnNmZXJDb250cmFjdCc6XG4gICAgICBjb250cmFjdFR5cGUgPSBDb250cmFjdFR5cGUuVHJhbnNmZXI7XG4gICAgICBjb250cmFjdCA9IGV4cG9ydHMuZGVjb2RlVHJhbnNmZXJDb250cmFjdChyYXdUcmFuc2FjdGlvbi5jb250cmFjdHNbMF0ucGFyYW1ldGVyLnZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3R5cGUuZ29vZ2xlYXBpcy5jb20vcHJvdG9jb2wuQWNjb3VudFBlcm1pc3Npb25VcGRhdGVDb250cmFjdCc6XG4gICAgICBjb250cmFjdFR5cGUgPSBDb250cmFjdFR5cGUuQWNjb3VudFBlcm1pc3Npb25VcGRhdGU7XG4gICAgICBjb250cmFjdCA9IGV4cG9ydHMuZGVjb2RlQWNjb3VudFBlcm1pc3Npb25VcGRhdGVDb250cmFjdChyYXdUcmFuc2FjdGlvbi5jb250cmFjdHNbMF0ucGFyYW1ldGVyLnZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3R5cGUuZ29vZ2xlYXBpcy5jb20vcHJvdG9jb2wuVHJpZ2dlclNtYXJ0Q29udHJhY3QnOlxuICAgICAgY29udHJhY3RUeXBlID0gQ29udHJhY3RUeXBlLlRyaWdnZXJTbWFydENvbnRyYWN0O1xuICAgICAgY29udHJhY3QgPSBleHBvcnRzLmRlY29kZVRyaWdnZXJTbWFydENvbnRyYWN0KHJhd1RyYW5zYWN0aW9uLmNvbnRyYWN0c1swXS5wYXJhbWV0ZXIudmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdVbnN1cHBvcnRlZCBjb250cmFjdCB0eXBlJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbnRyYWN0VHlwZSxcbiAgICBjb250cmFjdCxcbiAgICBleHBpcmF0aW9uOiByYXdUcmFuc2FjdGlvbi5leHBpcmF0aW9uLFxuICAgIHRpbWVzdGFtcDogcmF3VHJhbnNhY3Rpb24udGltZXN0YW1wLFxuICAgIHJlZl9ibG9ja19ieXRlczogcmF3VHJhbnNhY3Rpb24uYmxvY2tCeXRlcyxcbiAgICByZWZfYmxvY2tfaGFzaDogcmF3VHJhbnNhY3Rpb24uYmxvY2tIYXNoLFxuICAgIGZlZV9saW1pdDogK3Jhd1RyYW5zYWN0aW9uLmZlZUxpbWl0LFxuICB9O1xufVxuXG4vKipcbiAqIERlY29kZXMgYSB0cmFuc2FjdGlvbidzIHJhdyBmaWVsZCBmcm9tIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLiBUaGlzIGlzIGEgcHJvdG9idWYgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQHBhcmFtIGhleFN0cmluZyB0aGlzIGlzIHRoZSByYXcgaGV4YWRlY2ltYWwgZW5jb2RlZCBzdHJpbmcuIERvYyBmb3VuZCBpbiB0aGUgZm9sbG93aW5nIGxpbmsuXG4gKiBAZXhhbXBsZVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0JpdEdvL2JpdGdvLWFjY291bnQtbGliL2Jsb2IvNWYyODI1ODg3MDE3NzhhNDQyMWM3NWZhNjFmNDI3MTNmNTZlOTViOS9yZXNvdXJjZXMvcHJvdG9idWYvdHJvbi5wcm90byNMMzE5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUmF3VHJhbnNhY3Rpb24oaGV4U3RyaW5nOiBzdHJpbmcpOiB7XG4gIGV4cGlyYXRpb246IG51bWJlcjtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG4gIGNvbnRyYWN0czogQXJyYXk8YW55PjtcbiAgYmxvY2tCeXRlczogc3RyaW5nO1xuICBibG9ja0hhc2g6IHN0cmluZztcbiAgZmVlTGltaXQ6IHN0cmluZztcbn0ge1xuICBjb25zdCBieXRlcyA9IEJ1ZmZlci5mcm9tKGhleFN0cmluZywgJ2hleCcpO1xuXG4gIGxldCByYXc7XG4gIHRyeSB7XG4gICAgLy8gd2UgbmVlZCB0byBkZWNvZGUgb3VyIHJhd19kYXRhX2hleCBmaWVsZCBmaXJzdFxuICAgIHJhdyA9IHByb3RvY29sLlRyYW5zYWN0aW9uLnJhdy5kZWNvZGUoYnl0ZXMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciBkZWNvZGluZyB0aGUgaW5pdGlhbCByYXdfZGF0YV9oZXggZnJvbSB0aGUgc2VyaWFsaXplZCB0eC4nKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwaXJhdGlvbjogTnVtYmVyKHJhdy5leHBpcmF0aW9uKSxcbiAgICB0aW1lc3RhbXA6IE51bWJlcihyYXcudGltZXN0YW1wKSxcbiAgICBjb250cmFjdHM6IHJhdy5jb250cmFjdCxcbiAgICBibG9ja0J5dGVzOiB0b0hleChyYXcucmVmQmxvY2tCeXRlcyksXG4gICAgZmVlTGltaXQ6IHJhdy5mZWVMaW1pdCxcbiAgICBibG9ja0hhc2g6IHRvSGV4KHJhdy5yZWZCbG9ja0hhc2gpLFxuICB9O1xufVxuXG4vKipcbiAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBwYXNzZWQgc3RyaW5nIGlzIGEgc2FmZSBoZXggc3RyaW5nIGZvciB0cm9uJ3MgcHVycG9zZXMuXG4gKlxuICogQHBhcmFtIGhleCBBIHZhbGlkIGhleCBzdHJpbmcgbXVzdCBiZSBhIHN0cmluZyBtYWRlIG9mIG51bWJlcnMgYW5kIGNoYXJhY3RlcnMgYW5kIGhhcyBhbiBldmVuIGxlbmd0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRIZXgoaGV4OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIC9eKDB4KT8oWzAtOWEtZl17Mn0pKyQvaS50ZXN0KGhleCk7XG59XG5cbi8qKiBEZXNlcmlhbGl6ZSB0aGUgc2VnbWVudCBvZiB0aGUgdHhIZXggd2hpY2ggY29ycmVzcG9uZHMgd2l0aCB0aGUgZGV0YWlscyBvZiB0aGUgdHJhbnNmZXJcbiAqXG4gKiBAcGFyYW0gdHJhbnNmZXJIZXggaXMgdGhlIHZhbHVlIHByb3BlcnR5IG9mIHRoZSBcInBhcmFtZXRlclwiIGZpZWxkIG9mIGNvbnRyYWN0TGlzdFswXVxuICogKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUcmFuc2ZlckNvbnRyYWN0KHRyYW5zZmVySGV4OiBzdHJpbmcpOiBUcmFuc2ZlckNvbnRyYWN0W10ge1xuICBjb25zdCBjb250cmFjdEJ5dGVzID0gQnVmZmVyLmZyb20odHJhbnNmZXJIZXgsICdiYXNlNjQnKTtcbiAgbGV0IHRyYW5zZmVyQ29udHJhY3Q7XG5cbiAgdHJ5IHtcbiAgICB0cmFuc2ZlckNvbnRyYWN0ID0gcHJvdG9jb2wuVHJhbnNmZXJDb250cmFjdC5kZWNvZGUoY29udHJhY3RCeXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignVGhlcmUgd2FzIGFuIGVycm9yIGRlY29kaW5nIHRoZSB0cmFuc2ZlciBjb250cmFjdCBpbiB0aGUgdHJhbnNhY3Rpb24uJyk7XG4gIH1cblxuICBpZiAoIXRyYW5zZmVyQ29udHJhY3Qub3duZXJBZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ093bmVyIGFkZHJlc3MgZG9lcyBub3QgZXhpc3QgaW4gdGhpcyB0cmFuc2ZlciBjb250cmFjdC4nKTtcbiAgfVxuXG4gIGlmICghdHJhbnNmZXJDb250cmFjdC50b0FkZHJlc3MpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignRGVzdGluYXRpb24gYWRkcmVzcyBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIHRyYW5zZmVyIGNvbnRyYWN0LicpO1xuICB9XG5cbiAgaWYgKCF0cmFuc2ZlckNvbnRyYWN0Lmhhc093blByb3BlcnR5KCdhbW91bnQnKSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdBbW91bnQgZG9lcyBub3QgZXhpc3QgaW4gdGhpcyB0cmFuc2ZlciBjb250cmFjdC4nKTtcbiAgfVxuXG4gIC8vIGRlc2VyaWFsaXplIGF0dHJpYnV0ZXNcbiAgY29uc3Qgb3duZXJfYWRkcmVzcyA9IGdldEJhc2U1OEFkZHJlc3NGcm9tQnl0ZUFycmF5KFxuICAgIGdldEJ5dGVBcnJheUZyb21IZXhBZGRyZXNzKEJ1ZmZlci5mcm9tKHRyYW5zZmVyQ29udHJhY3Qub3duZXJBZGRyZXNzLCAnYmFzZTY0JykudG9TdHJpbmcoJ2hleCcpKVxuICApO1xuICBjb25zdCB0b19hZGRyZXNzID0gZ2V0QmFzZTU4QWRkcmVzc0Zyb21CeXRlQXJyYXkoXG4gICAgZ2V0Qnl0ZUFycmF5RnJvbUhleEFkZHJlc3MoQnVmZmVyLmZyb20odHJhbnNmZXJDb250cmFjdC50b0FkZHJlc3MsICdiYXNlNjQnKS50b1N0cmluZygnaGV4JykpXG4gICk7XG4gIGNvbnN0IGFtb3VudCA9IHRyYW5zZmVyQ29udHJhY3QuYW1vdW50O1xuXG4gIHJldHVybiBbXG4gICAge1xuICAgICAgcGFyYW1ldGVyOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgYW1vdW50OiBOdW1iZXIoYW1vdW50KSxcbiAgICAgICAgICBvd25lcl9hZGRyZXNzLFxuICAgICAgICAgIHRvX2FkZHJlc3MsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gIF07XG59XG5cbi8qKlxuICogRGVzZXJpYWxpemUgdGhlIHNlZ21lbnQgb2YgdGhlIHR4SGV4IGNvcnJlc3BvbmRpbmcgd2l0aCB0cmlnZ2VyIHNtYXJ0IGNvbnRyYWN0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFxuICogQHJldHVybnMge0FjY291bnRQZXJtaXNzaW9uVXBkYXRlQ29udHJhY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUcmlnZ2VyU21hcnRDb250cmFjdChiYXNlNjQ6IHN0cmluZyk6IFRyaWdnZXJTbWFydENvbnRyYWN0W10ge1xuICBsZXQgY29udHJhY3RDYWxsRGVjb2RlZDtcbiAgdHJ5IHtcbiAgICBjb250cmFjdENhbGxEZWNvZGVkID0gcHJvdG9jb2wuVHJpZ2dlclNtYXJ0Q29udHJhY3QuZGVjb2RlKEJ1ZmZlci5mcm9tKGJhc2U2NCwgJ2Jhc2U2NCcpKS50b0pTT04oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3IgZGVjb2RpbmcgdGhlIGNvbnRyYWN0IGNhbGwgaW4gdGhlIHRyYW5zYWN0aW9uLicpO1xuICB9XG5cbiAgaWYgKCFjb250cmFjdENhbGxEZWNvZGVkLm93bmVyQWRkcmVzcykge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdPd25lciBhZGRyZXNzIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgY29udHJhY3QgY2FsbC4nKTtcbiAgfVxuXG4gIGlmICghY29udHJhY3RDYWxsRGVjb2RlZC5jb250cmFjdEFkZHJlc3MpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignRGVzdGluYXRpb24gY29udHJhY3QgYWRkcmVzcyBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIGNvbnRyYWN0IGNhbGwuJyk7XG4gIH1cblxuICBpZiAoIWNvbnRyYWN0Q2FsbERlY29kZWQuZGF0YSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdEYXRhIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgY29udHJhY3QgY2FsbC4nKTtcbiAgfVxuXG4gIC8vIGRlc2VyaWFsaXplIGF0dHJpYnV0ZXNcbiAgY29uc3Qgb3duZXJfYWRkcmVzcyA9IGdldEJhc2U1OEFkZHJlc3NGcm9tQnl0ZUFycmF5KFxuICAgIGdldEJ5dGVBcnJheUZyb21IZXhBZGRyZXNzKEJ1ZmZlci5mcm9tKGNvbnRyYWN0Q2FsbERlY29kZWQub3duZXJBZGRyZXNzLCAnYmFzZTY0JykudG9TdHJpbmcoJ2hleCcpKVxuICApO1xuICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gZ2V0QmFzZTU4QWRkcmVzc0Zyb21CeXRlQXJyYXkoXG4gICAgZ2V0Qnl0ZUFycmF5RnJvbUhleEFkZHJlc3MoQnVmZmVyLmZyb20oY29udHJhY3RDYWxsRGVjb2RlZC5jb250cmFjdEFkZHJlc3MsICdiYXNlNjQnKS50b1N0cmluZygnaGV4JykpXG4gICk7XG4gIGNvbnN0IGRhdGEgPSBjb250cmFjdENhbGxEZWNvZGVkLmRhdGE7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgcGFyYW1ldGVyOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBvd25lcl9hZGRyZXNzLFxuICAgICAgICAgIGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gIF07XG59XG5cbi8qKlxuICogRGVzZXJpYWxpemUgdGhlIHNlZ21lbnQgb2YgdGhlIHR4SGV4IGNvcnJlc3BvbmRpbmcgd2l0aCB0aGUgZGV0YWlscyBvZiB0aGUgY29udHJhY3Qgd2hpY2ggdXBkYXRlc1xuICogYWNjb3VudCBwZXJtaXNzaW9uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFxuICogQHJldHVybnMge0FjY291bnRQZXJtaXNzaW9uVXBkYXRlQ29udHJhY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVBY2NvdW50UGVybWlzc2lvblVwZGF0ZUNvbnRyYWN0KGJhc2U2NDogc3RyaW5nKTogQWNjb3VudFBlcm1pc3Npb25VcGRhdGVDb250cmFjdCB7XG4gIGNvbnN0IGFjY291bnRVcGRhdGVDb250cmFjdCA9IHByb3RvY29sLkFjY291bnRQZXJtaXNzaW9uVXBkYXRlQ29udHJhY3QuZGVjb2RlKEJ1ZmZlci5mcm9tKGJhc2U2NCwgJ2Jhc2U2NCcpKS50b0pTT04oKTtcbiAgYXNzZXJ0KGFjY291bnRVcGRhdGVDb250cmFjdC5vd25lckFkZHJlc3MpO1xuICBhc3NlcnQoYWNjb3VudFVwZGF0ZUNvbnRyYWN0Lm93bmVyKTtcbiAgYXNzZXJ0KGFjY291bnRVcGRhdGVDb250cmFjdC5oYXNPd25Qcm9wZXJ0eSgnYWN0aXZlcycpKTtcblxuICBjb25zdCBvd25lckFkZHJlc3MgPSBnZXRCYXNlNThBZGRyZXNzRnJvbUJ5dGVBcnJheShcbiAgICBnZXRCeXRlQXJyYXlGcm9tSGV4QWRkcmVzcyhCdWZmZXIuZnJvbShhY2NvdW50VXBkYXRlQ29udHJhY3Qub3duZXJBZGRyZXNzLCAnYmFzZTY0JykudG9TdHJpbmcoJ2hleCcpKVxuICApO1xuICBjb25zdCBvd25lcjogUGVybWlzc2lvbiA9IGNyZWF0ZVBlcm1pc3Npb24oYWNjb3VudFVwZGF0ZUNvbnRyYWN0Lm93bmVyKTtcbiAgbGV0IHdpdG5lc3M6IFBlcm1pc3Npb24gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGlmIChhY2NvdW50VXBkYXRlQ29udHJhY3Qud2l0bmVzcykge1xuICAgIHdpdG5lc3MgPSBjcmVhdGVQZXJtaXNzaW9uKGFjY291bnRVcGRhdGVDb250cmFjdC53aXRuZXNzKTtcbiAgfVxuICBjb25zdCBhY3RpdmVMaXN0ID0gYWNjb3VudFVwZGF0ZUNvbnRyYWN0LmFjdGl2ZXMubWFwKChhY3RpdmUpID0+IGNyZWF0ZVBlcm1pc3Npb24oYWN0aXZlKSk7XG5cbiAgcmV0dXJuIHtcbiAgICBvd25lckFkZHJlc3MsXG4gICAgb3duZXIsXG4gICAgd2l0bmVzcyxcbiAgICBhY3RpdmVzOiBhY3RpdmVMaXN0LFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSByYXdcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGVybWlzc2lvbihyYXc6IHsgcGVybWlzc2lvbk5hbWU6IHN0cmluZzsgdGhyZXNob2xkOiBudW1iZXIgfSk6IFBlcm1pc3Npb24ge1xuICBsZXQgcGVybWlzc2lvblR5cGU6IFBlcm1pc3Npb25UeXBlO1xuICBjb25zdCBwZXJtaXNzaW9uID0gcmF3LnBlcm1pc3Npb25OYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICBpZiAocGVybWlzc2lvbiA9PT0gJ293bmVyJykge1xuICAgIHBlcm1pc3Npb25UeXBlID0gUGVybWlzc2lvblR5cGUuT3duZXI7XG4gIH0gZWxzZSBpZiAocGVybWlzc2lvbiA9PT0gJ3dpdG5lc3MnKSB7XG4gICAgcGVybWlzc2lvblR5cGUgPSBQZXJtaXNzaW9uVHlwZS5XaXRuZXNzO1xuICB9IGVsc2UgaWYgKHBlcm1pc3Npb24uc3Vic3RyKDAsIDYpID09PSAnYWN0aXZlJykge1xuICAgIHBlcm1pc3Npb25UeXBlID0gUGVybWlzc2lvblR5cGUuQWN0aXZlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdQZXJtaXNzaW9uIHR5cGUgbm90IHBhcnNlYWJsZS4nKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwZXJtaXNzaW9uVHlwZSwgdGhyZXNob2xkOiByYXcudGhyZXNob2xkIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHJhd1RyYW5zYWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkVHhKc29uU3RyaW5nKHJhd1RyYW5zYWN0aW9uOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgdHJhbnNhY3Rpb24gPSBKU09OLnBhcnNlKHJhd1RyYW5zYWN0aW9uKTtcbiAgcmV0dXJuIHRyYW5zYWN0aW9uLmhhc093blByb3BlcnR5KCd0eElEJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCByYXcgdHJhbnNhY3Rpb24gYWNjb21tb2RhdGVzIHRvIGJpdGdvJ3MgcHJlZmVycmVkIGZvcm1hdFxuICpcbiAqIEBwYXJhbSB7YW55fSByYXdUcmFuc2FjdGlvbiAtIFRoZSByYXcgdHJhbnNhY3Rpb24gdG8gYmUgY2hlY2tlZFxuICogQHJldHVybnMge2Jvb2xlYW59IHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFJhd1RyYW5zYWN0aW9uRm9ybWF0KHJhd1RyYW5zYWN0aW9uOiBhbnkpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiByYXdUcmFuc2FjdGlvbiA9PT0gJ3N0cmluZycgJiYgKGlzVmFsaWRIZXgocmF3VHJhbnNhY3Rpb24pIHx8IGlzVmFsaWRUeEpzb25TdHJpbmcocmF3VHJhbnNhY3Rpb24pKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGhleCBzdHJpbmcgb2YgdGhlIGdpdmVuIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7QnVmZmVyIHwgVWludDhBcnJheX0gYnVmZmVyIC0gdGhlIGJ1ZmZlciB0byBiZSBjb252ZXJ0ZWQgdG8gaGV4XG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBoZXggdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KGJ1ZmZlcjogQnVmZmVyIHwgVWludDhBcnJheSk6IHN0cmluZyB7XG4gIHJldHVybiBoZXguZW5jb2RlKGJ1ZmZlciwgdHJ1ZSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIEtlY2Nhay0yNTYgZW5jb2RlZCBzdHJpbmcgb2YgdGhlIHBhcmFtZXRlcnNcbiAqXG4gKiBAcGFyYW0gdHlwZXMgLSBzdHJpbmdzIGRlc2NyaWJpbmcgdGhlIHR5cGVzIG9mIHRoZSB2YWx1ZXNcbiAqIEBwYXJhbSB2YWx1ZXMgLSB2YWx1ZSB0byBlbmNvZGVcbiAqIEBwYXJhbSBtZXRob2RJZCAtIHRoZSBmaXJzdCA0IGJ5dGVzIG9mIHRoZSBmdW5jdGlvbiBzZWxlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlRGF0YVBhcmFtcyh0eXBlczogc3RyaW5nW10sIHZhbHVlczogYW55W10sIG1ldGhvZElkPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgdHlwZXMuZm9yRWFjaCgodHlwZSwgaW5kZXgpID0+IHtcbiAgICBpZiAodHlwZSA9PSAnYWRkcmVzcycpIHtcbiAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZXNbaW5kZXhdLnJlcGxhY2UoQUREUkVTU19QUkVGSVhfUkVHRVgsICcweCcpO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgYWJpQ29kZXIgPSBuZXcgQWJpQ29kZXIoKTtcbiAgbGV0IGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IGFiaUNvZGVyLmVuY29kZSh0eXBlcywgdmFsdWVzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKGBUaGVyZSB3YXMgYW4gZXJyb3IgZW5jb2RpbmcgdGhlIGRhdGEgcGFyYW1zLiBFcnJvciA9ICR7SlNPTi5zdHJpbmdpZnkoZSl9YCk7XG4gIH1cbiAgaWYgKG1ldGhvZElkKSB7XG4gICAgcmV0dXJuIGhleENvbmNhdChbbWV0aG9kSWQsIGRhdGFdKS5yZXBsYWNlKC9eKDB4KS8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGF0YS5yZXBsYWNlKC9eKDB4KS8sICcnKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRlY29kZWQgdmFsdWVzIGFjY29yZGluZyB0byB0aGUgYXJyYXkgb2YgdHlwZXNcbiAqXG4gKiBAcGFyYW0gdHlwZXMgLSBzdHJpbmdzIGRlc2NyaWJpbmcgdGhlIHR5cGVzIG9mIHRoZSB2YWx1ZXNcbiAqIEBwYXJhbSBkYXRhIC0gZW5jb2RlZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZURhdGFQYXJhbXModHlwZXM6IHN0cmluZ1tdLCBkYXRhOiBzdHJpbmcpOiBhbnlbXSB7XG4gIGNvbnN0IGFiaUNvZGVyID0gbmV3IEFiaUNvZGVyKCk7XG4gIGRhdGEgPSAnMHgnICsgZGF0YS5zdWJzdHJpbmcoOCk7XG4gIHJldHVybiBhYmlDb2Rlci5kZWNvZGUodHlwZXMsIGRhdGEpLnJlZHVjZSgob2JqLCBhcmcsIGluZGV4KSA9PiB7XG4gICAgaWYgKHR5cGVzW2luZGV4XSA9PSAnYWRkcmVzcycpIGFyZyA9IEFERFJFU1NfUFJFRklYICsgYXJnLnN1YnN0cigyKS50b0xvd2VyQ2FzZSgpO1xuICAgIG9iai5wdXNoKGFyZyk7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwgW10pO1xufVxuIl19