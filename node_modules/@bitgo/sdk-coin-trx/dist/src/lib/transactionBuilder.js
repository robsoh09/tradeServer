"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilder = void 0;
const crypto_1 = require("crypto");
const _ = __importStar(require("lodash"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const sdk_core_1 = require("@bitgo/sdk-core");
const utils_1 = require("./utils");
const transaction_1 = require("./transaction");
const keyPair_1 = require("./keyPair");
/**
 * Tron transaction builder.
 */
class TransactionBuilder extends sdk_core_1.BaseTransactionBuilder {
    /**
     * Public constructor.
     *
     * @param {CoinConfig} _coinConfig Configuration object
     */
    constructor(_coinConfig) {
        super(_coinConfig);
    }
    /**
     * Parse transaction takes in raw JSON directly from the node.
     *
     * @param {TransactionReceipt} rawTransaction The Tron transaction in JSON format as returned by the Tron lib or a stringifyed version of such JSON.
     * @returns {Transaction} Tron transaction
     */
    fromImplementation(rawTransaction) {
        let tx;
        if (typeof rawTransaction === 'string') {
            const transaction = JSON.parse(rawTransaction);
            tx = new transaction_1.Transaction(this._coinConfig, transaction);
        }
        else {
            tx = new transaction_1.Transaction(this._coinConfig, rawTransaction);
        }
        return tx;
    }
    /** @inheritdoc */
    signImplementation(key) {
        if (!this.transaction.inputs) {
            throw new sdk_core_1.SigningError('Transaction has no sender');
        }
        if (!this.transaction.outputs) {
            throw new sdk_core_1.SigningError('Transaction has no receiver');
        }
        return this.applySignature(key);
    }
    applySignature(key) {
        const oldTransaction = this.transaction.toJson();
        // Store the original signatures to compare them with the new ones in a later step. Signatures
        // can be undefined if this is the first time the transaction is being signed
        const oldSignatureCount = oldTransaction.signature ? oldTransaction.signature.length : 0;
        let signedTransaction;
        try {
            const keyPair = new keyPair_1.KeyPair({ prv: key.key });
            // Since the key pair was generated using a private key, it will always have a prv attribute,
            // hence it is safe to use non-null operator
            signedTransaction = (0, utils_1.signTransaction)(keyPair.getKeys().prv, this.transaction.toJson());
        }
        catch (e) {
            throw new sdk_core_1.SigningError('Failed to sign transaction via helper.');
        }
        // Ensure that we have more signatures than what we started with
        if (!signedTransaction.signature || oldSignatureCount >= signedTransaction.signature.length) {
            throw new sdk_core_1.SigningError('Transaction signing did not return an additional signature.');
        }
        return new transaction_1.Transaction(this._coinConfig, signedTransaction);
    }
    /** @inheritdoc */
    async buildImplementation() {
        // This is a no-op since Tron transactions are built from
        if (!this.transaction.id) {
            throw new sdk_core_1.BuildTransactionError('A valid transaction must have an id');
        }
        return Promise.resolve(this.transaction);
    }
    initBuilder(tx) {
        this.transaction = this.fromImplementation(tx);
    }
    /**
     * Extend the validity of this transaction by the given amount of time
     *
     * @param {number} extensionMs The number of milliseconds to extend the validTo time
     * @returns {undefined}
     */
    extendValidTo(extensionMs) {
        this.transaction.extendExpiration(extensionMs);
    }
    /** @inheritdoc */
    validateValue(value) {
        if (value.isLessThanOrEqualTo(0)) {
            throw new Error('Value cannot be below zero.');
        }
        // max long in Java - assumed upper limit for a TRX transaction
        if (value.isGreaterThan(new bignumber_js_1.default('9223372036854775807'))) {
            throw new Error('Value cannot be greater than handled by the javatron node.');
        }
    }
    /** @inheritdoc */
    validateAddress(address) {
        // assumes a base 58 address for our addresses
        if (!(0, utils_1.isBase58Address)(address.address)) {
            throw new Error(address.address + ' is not a valid base58 address.');
        }
    }
    /** @inheritdoc */
    validateKey(key) {
        try {
            new keyPair_1.KeyPair({ prv: key.key });
        }
        catch (err) {
            throw new Error('The provided key is not valid');
        }
    }
    /**
     * Validate the contents of a raw transaction. The validation
     * phase is to compare the raw-data-hex to the raw-data of the
     * transaction.
     *
     * The contents to be validated are
     * 1. The transaction id
     * 2. The expiration date
     * 3. The timestamp
     * 4. The contract
     *
     * @param {TransactionReceipt | string} rawTransaction The raw transaction to be validated
     */
    validateRawTransaction(rawTransaction) {
        // TODO: Validation of signature
        if (!rawTransaction) {
            throw new sdk_core_1.InvalidTransactionError('Raw transaction is empty');
        }
        let currTransaction;
        // rawTransaction can be either Stringified JSON OR
        // it can be a regular JSON object (not stringified).
        if (typeof rawTransaction === 'string') {
            try {
                currTransaction = JSON.parse(rawTransaction);
            }
            catch (e) {
                throw new sdk_core_1.ParseTransactionError('There was error in parsing the JSON string');
            }
        }
        else if (_.isObject(rawTransaction)) {
            currTransaction = rawTransaction;
        }
        else {
            throw new sdk_core_1.InvalidTransactionError('Transaction is not an object or stringified json');
        }
        const decodedRawDataHex = (0, utils_1.decodeTransaction)(currTransaction.raw_data_hex);
        if (!currTransaction.txID) {
            throw new sdk_core_1.InvalidTransactionError('Transaction ID is empty');
        }
        // Validate the transaction ID from the raw data hex
        const hexBuffer = Buffer.from(currTransaction.raw_data_hex, 'hex');
        const currTxID = (0, crypto_1.createHash)('sha256').update(hexBuffer).digest('hex');
        if (currTransaction.txID !== currTxID) {
            throw new sdk_core_1.InvalidTransactionError('Transaction has not have a valid id');
        }
        // Validate the expiration time from the raw-data-hex
        if (currTransaction.raw_data.expiration !== decodedRawDataHex.expiration) {
            throw new sdk_core_1.InvalidTransactionError('Transaction has not have a valid expiration');
        }
        // Validate the timestamp from the raw-data-hex
        if (currTransaction.raw_data.timestamp !== decodedRawDataHex.timestamp) {
            throw new sdk_core_1.InvalidTransactionError('Transaction has not have a valid timetamp');
        }
        // Transaction contract must exist
        if (!currTransaction.raw_data.contract) {
            throw new sdk_core_1.InvalidTransactionError('Transaction contracts are empty');
        }
    }
    /** @inheritdoc */
    validateTransaction(transaction) {
        const hexBuffer = Buffer.from(transaction.toJson().raw_data_hex, 'hex');
        const txId = (0, crypto_1.createHash)('sha256').update(hexBuffer).digest('hex');
        if (transaction.id !== txId) {
            throw new sdk_core_1.InvalidTransactionError(transaction.id + ' is not a valid transaction id. Expecting: ' + txId);
        }
    }
    /** @inheritdoc */
    get transaction() {
        return this._transaction;
    }
    /** @inheritdoc */
    set transaction(transaction) {
        this._transaction = transaction;
    }
}
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi90cmFuc2FjdGlvbkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtQ0FBb0M7QUFDcEMsMENBQTRCO0FBQzVCLGdFQUFxQztBQUVyQyw4Q0FPeUI7QUFHekIsbUNBQThFO0FBQzlFLCtDQUE0QztBQUM1Qyx1Q0FBb0M7QUFFcEM7O0dBRUc7QUFDSCxNQUFhLGtCQUFtQixTQUFRLGlDQUFzQjtJQUc1RDs7OztPQUlHO0lBQ0gsWUFBWSxXQUFpQztRQUMzQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ08sa0JBQWtCLENBQUMsY0FBMkM7UUFDdEUsSUFBSSxFQUFFLENBQUM7UUFDUCxJQUFJLE9BQU8sY0FBYyxLQUFLLFFBQVEsRUFBRTtZQUN0QyxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQy9DLEVBQUUsR0FBRyxJQUFJLHlCQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsQ0FBQztTQUNyRDthQUFNO1lBQ0wsRUFBRSxHQUFHLElBQUkseUJBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1NBQ3hEO1FBQ0QsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQsa0JBQWtCO0lBQ1Isa0JBQWtCLENBQUMsR0FBWTtRQUN2QyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUU7WUFDNUIsTUFBTSxJQUFJLHVCQUFZLENBQUMsMkJBQTJCLENBQUMsQ0FBQztTQUNyRDtRQUVELElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRTtZQUM3QixNQUFNLElBQUksdUJBQVksQ0FBQyw2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LENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsSUFBYyxXQUFXLENBQUMsV0FBd0I7UUFDaEQsSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7SUFDbEMsQ0FBQztDQUNGO0FBOUxELGdEQThMQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUhhc2ggfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7XG4gIEJhc2VLZXksXG4gIEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXIsXG4gIEJ1aWxkVHJhbnNhY3Rpb25FcnJvcixcbiAgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IsXG4gIFBhcnNlVHJhbnNhY3Rpb25FcnJvcixcbiAgU2lnbmluZ0Vycm9yLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25SZWNlaXB0IH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnLi9hZGRyZXNzJztcbmltcG9ydCB7IHNpZ25UcmFuc2FjdGlvbiwgaXNCYXNlNThBZGRyZXNzLCBkZWNvZGVUcmFuc2FjdGlvbiB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IEtleVBhaXIgfSBmcm9tICcuL2tleVBhaXInO1xuXG4vKipcbiAqIFRyb24gdHJhbnNhY3Rpb24gYnVpbGRlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uQnVpbGRlciBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXIge1xuICAvLyB0cmFuc2FjdGlvbiBiZWluZyBidWlsdFxuICBwcml2YXRlIF90cmFuc2FjdGlvbjogVHJhbnNhY3Rpb247XG4gIC8qKlxuICAgKiBQdWJsaWMgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29pbkNvbmZpZ30gX2NvaW5Db25maWcgQ29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yKF9jb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xuICAgIHN1cGVyKF9jb2luQ29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSB0cmFuc2FjdGlvbiB0YWtlcyBpbiByYXcgSlNPTiBkaXJlY3RseSBmcm9tIHRoZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uUmVjZWlwdH0gcmF3VHJhbnNhY3Rpb24gVGhlIFRyb24gdHJhbnNhY3Rpb24gaW4gSlNPTiBmb3JtYXQgYXMgcmV0dXJuZWQgYnkgdGhlIFRyb24gbGliIG9yIGEgc3RyaW5naWZ5ZWQgdmVyc2lvbiBvZiBzdWNoIEpTT04uXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn0gVHJvbiB0cmFuc2FjdGlvblxuICAgKi9cbiAgcHJvdGVjdGVkIGZyb21JbXBsZW1lbnRhdGlvbihyYXdUcmFuc2FjdGlvbjogVHJhbnNhY3Rpb25SZWNlaXB0IHwgc3RyaW5nKTogVHJhbnNhY3Rpb24ge1xuICAgIGxldCB0eDtcbiAgICBpZiAodHlwZW9mIHJhd1RyYW5zYWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBKU09OLnBhcnNlKHJhd1RyYW5zYWN0aW9uKTtcbiAgICAgIHR4ID0gbmV3IFRyYW5zYWN0aW9uKHRoaXMuX2NvaW5Db25maWcsIHRyYW5zYWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHggPSBuZXcgVHJhbnNhY3Rpb24odGhpcy5fY29pbkNvbmZpZywgcmF3VHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdHg7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIHNpZ25JbXBsZW1lbnRhdGlvbihrZXk6IEJhc2VLZXkpOiBUcmFuc2FjdGlvbiB7XG4gICAgaWYgKCF0aGlzLnRyYW5zYWN0aW9uLmlucHV0cykge1xuICAgICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignVHJhbnNhY3Rpb24gaGFzIG5vIHNlbmRlcicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy50cmFuc2FjdGlvbi5vdXRwdXRzKSB7XG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdUcmFuc2FjdGlvbiBoYXMgbm8gcmVjZWl2ZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlTaWduYXR1cmUoa2V5KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcHBseVNpZ25hdHVyZShrZXk6IEJhc2VLZXkpOiBUcmFuc2FjdGlvbiB7XG4gICAgY29uc3Qgb2xkVHJhbnNhY3Rpb24gPSB0aGlzLnRyYW5zYWN0aW9uLnRvSnNvbigpO1xuICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBzaWduYXR1cmVzIHRvIGNvbXBhcmUgdGhlbSB3aXRoIHRoZSBuZXcgb25lcyBpbiBhIGxhdGVyIHN0ZXAuIFNpZ25hdHVyZXNcbiAgICAvLyBjYW4gYmUgdW5kZWZpbmVkIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgdGhlIHRyYW5zYWN0aW9uIGlzIGJlaW5nIHNpZ25lZFxuICAgIGNvbnN0IG9sZFNpZ25hdHVyZUNvdW50ID0gb2xkVHJhbnNhY3Rpb24uc2lnbmF0dXJlID8gb2xkVHJhbnNhY3Rpb24uc2lnbmF0dXJlLmxlbmd0aCA6IDA7XG4gICAgbGV0IHNpZ25lZFRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblJlY2VpcHQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleVBhaXIgPSBuZXcgS2V5UGFpcih7IHBydjoga2V5LmtleSB9KTtcbiAgICAgIC8vIFNpbmNlIHRoZSBrZXkgcGFpciB3YXMgZ2VuZXJhdGVkIHVzaW5nIGEgcHJpdmF0ZSBrZXksIGl0IHdpbGwgYWx3YXlzIGhhdmUgYSBwcnYgYXR0cmlidXRlLFxuICAgICAgLy8gaGVuY2UgaXQgaXMgc2FmZSB0byB1c2Ugbm9uLW51bGwgb3BlcmF0b3JcbiAgICAgIHNpZ25lZFRyYW5zYWN0aW9uID0gc2lnblRyYW5zYWN0aW9uKGtleVBhaXIuZ2V0S2V5cygpLnBydiEsIHRoaXMudHJhbnNhY3Rpb24udG9Kc29uKCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ0ZhaWxlZCB0byBzaWduIHRyYW5zYWN0aW9uIHZpYSBoZWxwZXIuJyk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSBtb3JlIHNpZ25hdHVyZXMgdGhhbiB3aGF0IHdlIHN0YXJ0ZWQgd2l0aFxuICAgIGlmICghc2lnbmVkVHJhbnNhY3Rpb24uc2lnbmF0dXJlIHx8IG9sZFNpZ25hdHVyZUNvdW50ID49IHNpZ25lZFRyYW5zYWN0aW9uLnNpZ25hdHVyZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ1RyYW5zYWN0aW9uIHNpZ25pbmcgZGlkIG5vdCByZXR1cm4gYW4gYWRkaXRpb25hbCBzaWduYXR1cmUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbih0aGlzLl9jb2luQ29uZmlnLCBzaWduZWRUcmFuc2FjdGlvbik7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGJ1aWxkSW1wbGVtZW50YXRpb24oKTogUHJvbWlzZTxUcmFuc2FjdGlvbj4ge1xuICAgIC8vIFRoaXMgaXMgYSBuby1vcCBzaW5jZSBUcm9uIHRyYW5zYWN0aW9ucyBhcmUgYnVpbHQgZnJvbVxuICAgIGlmICghdGhpcy50cmFuc2FjdGlvbi5pZCkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignQSB2YWxpZCB0cmFuc2FjdGlvbiBtdXN0IGhhdmUgYW4gaWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnRyYW5zYWN0aW9uKTtcbiAgfVxuXG4gIGluaXRCdWlsZGVyKHR4OiBUcmFuc2FjdGlvblJlY2VpcHQgfCBzdHJpbmcpIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gdGhpcy5mcm9tSW1wbGVtZW50YXRpb24odHgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dGVuZCB0aGUgdmFsaWRpdHkgb2YgdGhpcyB0cmFuc2FjdGlvbiBieSB0aGUgZ2l2ZW4gYW1vdW50IG9mIHRpbWVcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGV4dGVuc2lvbk1zIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGV4dGVuZCB0aGUgdmFsaWRUbyB0aW1lXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBleHRlbmRWYWxpZFRvKGV4dGVuc2lvbk1zOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLmV4dGVuZEV4cGlyYXRpb24oZXh0ZW5zaW9uTXMpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlVmFsdWUodmFsdWU6IEJpZ051bWJlcik6IHZvaWQge1xuICAgIGlmICh2YWx1ZS5pc0xlc3NUaGFuT3JFcXVhbFRvKDApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIGNhbm5vdCBiZSBiZWxvdyB6ZXJvLicpO1xuICAgIH1cblxuICAgIC8vIG1heCBsb25nIGluIEphdmEgLSBhc3N1bWVkIHVwcGVyIGxpbWl0IGZvciBhIFRSWCB0cmFuc2FjdGlvblxuICAgIGlmICh2YWx1ZS5pc0dyZWF0ZXJUaGFuKG5ldyBCaWdOdW1iZXIoJzkyMjMzNzIwMzY4NTQ3NzU4MDcnKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiBoYW5kbGVkIGJ5IHRoZSBqYXZhdHJvbiBub2RlLicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZUFkZHJlc3MoYWRkcmVzczogQWRkcmVzcyk6IHZvaWQge1xuICAgIC8vIGFzc3VtZXMgYSBiYXNlIDU4IGFkZHJlc3MgZm9yIG91ciBhZGRyZXNzZXNcbiAgICBpZiAoIWlzQmFzZTU4QWRkcmVzcyhhZGRyZXNzLmFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYWRkcmVzcy5hZGRyZXNzICsgJyBpcyBub3QgYSB2YWxpZCBiYXNlNTggYWRkcmVzcy4nKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdmFsaWRhdGVLZXkoa2V5OiBCYXNlS2V5KTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBLZXlQYWlyKHsgcHJ2OiBrZXkua2V5IH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIG5vdCB2YWxpZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGUgY29udGVudHMgb2YgYSByYXcgdHJhbnNhY3Rpb24uIFRoZSB2YWxpZGF0aW9uXG4gICAqIHBoYXNlIGlzIHRvIGNvbXBhcmUgdGhlIHJhdy1kYXRhLWhleCB0byB0aGUgcmF3LWRhdGEgb2YgdGhlXG4gICAqIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBUaGUgY29udGVudHMgdG8gYmUgdmFsaWRhdGVkIGFyZVxuICAgKiAxLiBUaGUgdHJhbnNhY3Rpb24gaWRcbiAgICogMi4gVGhlIGV4cGlyYXRpb24gZGF0ZVxuICAgKiAzLiBUaGUgdGltZXN0YW1wXG4gICAqIDQuIFRoZSBjb250cmFjdFxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uUmVjZWlwdCB8IHN0cmluZ30gcmF3VHJhbnNhY3Rpb24gVGhlIHJhdyB0cmFuc2FjdGlvbiB0byBiZSB2YWxpZGF0ZWRcbiAgICovXG4gIHZhbGlkYXRlUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uUmVjZWlwdCB8IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIFRPRE86IFZhbGlkYXRpb24gb2Ygc2lnbmF0dXJlXG4gICAgaWYgKCFyYXdUcmFuc2FjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdSYXcgdHJhbnNhY3Rpb24gaXMgZW1wdHknKTtcbiAgICB9XG4gICAgbGV0IGN1cnJUcmFuc2FjdGlvbjogVHJhbnNhY3Rpb25SZWNlaXB0O1xuICAgIC8vIHJhd1RyYW5zYWN0aW9uIGNhbiBiZSBlaXRoZXIgU3RyaW5naWZpZWQgSlNPTiBPUlxuICAgIC8vIGl0IGNhbiBiZSBhIHJlZ3VsYXIgSlNPTiBvYmplY3QgKG5vdCBzdHJpbmdpZmllZCkuXG4gICAgaWYgKHR5cGVvZiByYXdUcmFuc2FjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGN1cnJUcmFuc2FjdGlvbiA9IEpTT04ucGFyc2UocmF3VHJhbnNhY3Rpb24pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VUcmFuc2FjdGlvbkVycm9yKCdUaGVyZSB3YXMgZXJyb3IgaW4gcGFyc2luZyB0aGUgSlNPTiBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QocmF3VHJhbnNhY3Rpb24pKSB7XG4gICAgICBjdXJyVHJhbnNhY3Rpb24gPSByYXdUcmFuc2FjdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBpcyBub3QgYW4gb2JqZWN0IG9yIHN0cmluZ2lmaWVkIGpzb24nKTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlZFJhd0RhdGFIZXggPSBkZWNvZGVUcmFuc2FjdGlvbihjdXJyVHJhbnNhY3Rpb24ucmF3X2RhdGFfaGV4KTtcbiAgICBpZiAoIWN1cnJUcmFuc2FjdGlvbi50eElEKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ1RyYW5zYWN0aW9uIElEIGlzIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHRoZSB0cmFuc2FjdGlvbiBJRCBmcm9tIHRoZSByYXcgZGF0YSBoZXhcbiAgICBjb25zdCBoZXhCdWZmZXIgPSBCdWZmZXIuZnJvbShjdXJyVHJhbnNhY3Rpb24ucmF3X2RhdGFfaGV4LCAnaGV4Jyk7XG4gICAgY29uc3QgY3VyclR4SUQgPSBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoaGV4QnVmZmVyKS5kaWdlc3QoJ2hleCcpO1xuICAgIGlmIChjdXJyVHJhbnNhY3Rpb24udHhJRCAhPT0gY3VyclR4SUQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gaGFzIG5vdCBoYXZlIGEgdmFsaWQgaWQnKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgdGhlIGV4cGlyYXRpb24gdGltZSBmcm9tIHRoZSByYXctZGF0YS1oZXhcbiAgICBpZiAoY3VyclRyYW5zYWN0aW9uLnJhd19kYXRhLmV4cGlyYXRpb24gIT09IGRlY29kZWRSYXdEYXRhSGV4LmV4cGlyYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gaGFzIG5vdCBoYXZlIGEgdmFsaWQgZXhwaXJhdGlvbicpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB0aGUgdGltZXN0YW1wIGZyb20gdGhlIHJhdy1kYXRhLWhleFxuICAgIGlmIChjdXJyVHJhbnNhY3Rpb24ucmF3X2RhdGEudGltZXN0YW1wICE9PSBkZWNvZGVkUmF3RGF0YUhleC50aW1lc3RhbXApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gaGFzIG5vdCBoYXZlIGEgdmFsaWQgdGltZXRhbXAnKTtcbiAgICB9XG4gICAgLy8gVHJhbnNhY3Rpb24gY29udHJhY3QgbXVzdCBleGlzdFxuICAgIGlmICghY3VyclRyYW5zYWN0aW9uLnJhd19kYXRhLmNvbnRyYWN0KSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ1RyYW5zYWN0aW9uIGNvbnRyYWN0cyBhcmUgZW1wdHknKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdmFsaWRhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24pOiB2b2lkIHtcbiAgICBjb25zdCBoZXhCdWZmZXIgPSBCdWZmZXIuZnJvbSh0cmFuc2FjdGlvbi50b0pzb24oKS5yYXdfZGF0YV9oZXgsICdoZXgnKTtcbiAgICBjb25zdCB0eElkID0gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGhleEJ1ZmZlcikuZGlnZXN0KCdoZXgnKTtcbiAgICBpZiAodHJhbnNhY3Rpb24uaWQgIT09IHR4SWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcih0cmFuc2FjdGlvbi5pZCArICcgaXMgbm90IGEgdmFsaWQgdHJhbnNhY3Rpb24gaWQuIEV4cGVjdGluZzogJyArIHR4SWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgZ2V0IHRyYW5zYWN0aW9uKCk6IFRyYW5zYWN0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIHNldCB0cmFuc2FjdGlvbih0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24pIHtcbiAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICB9XG59XG4iXX0=