"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
const crypto_1 = require("crypto");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const tron_1 = require("../../resources/protobuf/tron");
const sdk_core_1 = require("@bitgo/sdk-core");
const enum_1 = require("./enum");
const utils_1 = require("./utils");
/**
 * Tron transaction model.
 */
class Transaction extends sdk_core_1.BaseTransaction {
    /**
     * Public constructor.
     *
     * @param coinConfig
     * @param rawTransaction
     */
    constructor(coinConfig, rawTransaction) {
        super(coinConfig);
        if (rawTransaction) {
            if (!rawTransaction.txID) {
                throw new sdk_core_1.ParseTransactionError('Transaction has no id');
            }
            this._id = rawTransaction.txID;
            this._transaction = rawTransaction;
            this._decodedRawDataHex = (0, utils_1.decodeTransaction)(rawTransaction.raw_data_hex);
            // Destination depends on the contract type
            this.recordRawDataFields(this._decodedRawDataHex);
        }
    }
    /**
     * Parse the transaction raw data and record the most important fields.
     *
     * @param rawData Object from a tron transaction
     */
    recordRawDataFields(rawData) {
        // Contract-agnostic fields
        this._validFrom = rawData.timestamp;
        this._validTo = rawData.expiration;
        let output, input;
        // Contract-specific fields
        switch (rawData.contractType) {
            case enum_1.ContractType.Transfer:
                this._type = sdk_core_1.TransactionType.Send;
                const value = new bignumber_js_1.default(rawData.contract[0].parameter.value.amount).toFixed(0);
                output = {
                    address: rawData.contract[0].parameter.value.to_address,
                    value,
                };
                input = {
                    address: rawData.contract[0].parameter.value.owner_address,
                    value,
                };
                break;
            case enum_1.ContractType.AccountPermissionUpdate:
                this._type = sdk_core_1.TransactionType.WalletInitialization;
                output = {
                    address: rawData.contract.owner_address,
                    value: '0',
                };
                input = {
                    address: rawData.contract.owner_address,
                    value: '0',
                };
                break;
            case enum_1.ContractType.TriggerSmartContract:
                this._type = sdk_core_1.TransactionType.ContractCall;
                const contractCallValues = rawData.contract[0].parameter.value;
                const contractAddress = contractCallValues.contract_address;
                if (utils_1.tokenMainnetContractAddresses.includes(contractAddress) ||
                    utils_1.tokenTestnetContractAddresses.includes(contractAddress)) {
                    // this is then a token smart contract transaction and the data must be decoded
                    const types = ['address', 'uint256'];
                    const data = Buffer.from(contractCallValues.data, 'base64').toString('hex');
                    const decodedData = (0, utils_1.decodeDataParams)(types, data);
                    const recipient_address = (0, utils_1.getBase58AddressFromHex)(decodedData[0]);
                    const value = decodedData[1].toString();
                    output = {
                        address: recipient_address,
                        value,
                    };
                    input = {
                        address: contractCallValues.owner_address,
                        contractAddress,
                        data,
                        value,
                    };
                    break;
                }
                output = {
                    address: contractCallValues.owner_address,
                    value: '0',
                };
                input = {
                    address: contractCallValues.owner_address,
                    contractAddress,
                    data: contractCallValues.data,
                    value: '0',
                };
                break;
            default:
                throw new sdk_core_1.ParseTransactionError('Unsupported contract type');
        }
        this._inputs = [input];
        this._outputs = [output];
    }
    /**
     * Recalculate and update the transaction id. This should be done after changing any transaction
     * field since the the id is a hash of the transaction body.
     */
    updateId() {
        if (!this._transaction) {
            throw new sdk_core_1.ParseTransactionError('Empty transaction');
        }
        const hexBuffer = Buffer.from(this._transaction.raw_data_hex, 'hex');
        const newTxid = (0, crypto_1.createHash)('sha256').update(hexBuffer).digest('hex');
        this._transaction.txID = newTxid;
        this._id = newTxid;
    }
    /**
     * Extend the expiration date by the given number of milliseconds.
     *
     * @param extensionMs The number of milliseconds to extend the expiration by
     */
    extendExpiration(extensionMs) {
        if (extensionMs < 0) {
            throw new sdk_core_1.ExtendTransactionError('Invalid extension range. Must be positive a integer');
        }
        if (!this._transaction) {
            throw new sdk_core_1.ExtendTransactionError('Empty transaction');
        }
        if (this._transaction.signature && this._transaction.signature.length > 0) {
            throw new sdk_core_1.ExtendTransactionError('Cannot extend a signed transaction');
        }
        const rawDataHex = this._transaction.raw_data_hex;
        const bytes = Buffer.from(rawDataHex, 'hex');
        let raw;
        try {
            raw = tron_1.protocol.Transaction.raw.decode(bytes);
            const newExpiration = new bignumber_js_1.default(raw.expiration).plus(extensionMs).toNumber();
            raw.expiration = newExpiration;
            const newRawDataHex = Buffer.from(tron_1.protocol.Transaction.raw.encode(raw).finish()).toString('hex');
            // Set the internal variables to account for the new expiration date
            this._transaction.raw_data_hex = newRawDataHex;
            this._transaction.raw_data.expiration = newExpiration;
            this._decodedRawDataHex = (0, utils_1.decodeTransaction)(newRawDataHex);
            this.recordRawDataFields(this._decodedRawDataHex);
            this.updateId();
        }
        catch (e) {
            throw new sdk_core_1.ExtendTransactionError('There was an error decoding the initial raw_data_hex from the serialized tx.');
        }
    }
    /**
     * Get the signatures associated with this transaction.
     */
    get signature() {
        if (this._transaction && this._transaction.signature) {
            return this._transaction.signature;
        }
        return [];
    }
    /**
     * Get the time in milliseconds this transaction becomes valid and can be broadcasted to the
     * network.
     */
    get validFrom() {
        return this._validFrom;
    }
    /**
     * Get the expiration time in milliseconds.
     */
    get validTo() {
        return this._validTo;
    }
    /** @inheritdoc */
    get outputs() {
        return this._outputs;
    }
    /** @inheritdoc */
    get inputs() {
        return this._inputs;
    }
    /** @inheritdoc */
    canSign(key) {
        // Tron transaction do not contain the owners account address so it is not possible to check the
        // private key with any but the account main address. This is not enough to fail this check, so
        // it is a no-op.
        return true;
    }
    /**
     * Sets this transaction
     *
     * @param {Transaction} tx transaction
     */
    setTransactionReceipt(tx) {
        this._transaction = tx;
        this.updateId();
    }
    /**
     * Set the transaction type
     *
     * @param {TransactionType} transactionType The transaction type to be set
     */
    setTransactionType(transactionType) {
        this._type = transactionType;
    }
    /** @inheritdoc */
    toJson() {
        if (!this._transaction) {
            throw new sdk_core_1.ParseTransactionError('Empty transaction');
        }
        return this._transaction;
    }
    /** @inheritdoc */
    toBroadcastFormat() {
        return JSON.stringify(this.toJson());
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3RyYW5zYWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG1DQUFvQztBQUVwQyxnRUFBcUM7QUFDckMsd0RBQXlEO0FBQ3pELDhDQU15QjtBQUN6QixpQ0FBc0M7QUFDdEMsbUNBTWlCO0FBR2pCOztHQUVHO0FBQ0gsTUFBYSxXQUFZLFNBQVEsMEJBQWU7SUFVOUM7Ozs7O09BS0c7SUFDSCxZQUFZLFVBQWdDLEVBQUUsY0FBbUM7UUFDL0UsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xCLElBQUksY0FBYyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFO2dCQUN4QixNQUFNLElBQUksZ0NBQXFCLENBQUMsdUJBQXVCLENBQUMsQ0FBQzthQUMxRDtZQUNELElBQUksQ0FBQyxHQUFHLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQztZQUMvQixJQUFJLENBQUMsWUFBWSxHQUFHLGNBQWMsQ0FBQztZQUNuQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBQSx5QkFBaUIsRUFBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUM7WUFFekUsMkNBQTJDO1lBQzNDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztTQUNuRDtJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssbUJBQW1CLENBQUMsT0FBZ0I7UUFDMUMsMkJBQTJCO1FBQzNCLElBQUksQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQztRQUNwQyxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUM7UUFFbkMsSUFBSSxNQUFxQixFQUFFLEtBQW9CLENBQUM7UUFDaEQsMkJBQTJCO1FBQzNCLFFBQVEsT0FBTyxDQUFDLFlBQVksRUFBRTtZQUM1QixLQUFLLG1CQUFZLENBQUMs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dGVudCI6WyJpbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBwcm90b2NvbCB9IGZyb20gJy4uLy4uL3Jlc291cmNlcy9wcm90b2J1Zi90cm9uJztcbmltcG9ydCB7XG4gIEJhc2VLZXksXG4gIEJhc2VUcmFuc2FjdGlvbixcbiAgRXh0ZW5kVHJhbnNhY3Rpb25FcnJvcixcbiAgUGFyc2VUcmFuc2FjdGlvbkVycm9yLFxuICBUcmFuc2FjdGlvblR5cGUsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBDb250cmFjdFR5cGUgfSBmcm9tICcuL2VudW0nO1xuaW1wb3J0IHtcbiAgZGVjb2RlVHJhbnNhY3Rpb24sXG4gIGRlY29kZURhdGFQYXJhbXMsXG4gIGdldEJhc2U1OEFkZHJlc3NGcm9tSGV4LFxuICB0b2tlbk1haW5uZXRDb250cmFjdEFkZHJlc3NlcyxcbiAgdG9rZW5UZXN0bmV0Q29udHJhY3RBZGRyZXNzZXMsXG59IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgQ29udHJhY3RFbnRyeSwgUmF3RGF0YSwgVHJhbnNhY3Rpb25SZWNlaXB0LCBUcmFuc2ZlckNvbnRyYWN0LCBUcmlnZ2VyU21hcnRDb250cmFjdCB9IGZyb20gJy4vaWZhY2UnO1xuXG4vKipcbiAqIFRyb24gdHJhbnNhY3Rpb24gbW9kZWwuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbiBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbiB7XG4gIC8vIFRyb24gc3BlY2lmaWMgZmllbGRzXG4gIHByb3RlY3RlZCBfdmFsaWRGcm9tOiBudW1iZXI7XG4gIHByb3RlY3RlZCBfdmFsaWRUbzogbnVtYmVyO1xuICBwcm90ZWN0ZWQgX2lucHV0czogQ29udHJhY3RFbnRyeVtdO1xuICBwcm90ZWN0ZWQgX291dHB1dHM6IENvbnRyYWN0RW50cnlbXTtcblxuICBwcml2YXRlIF9kZWNvZGVkUmF3RGF0YUhleDogUmF3RGF0YTtcbiAgcHJpdmF0ZSBfdHJhbnNhY3Rpb24/OiBUcmFuc2FjdGlvblJlY2VpcHQ7XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIGNvaW5Db25maWdcbiAgICogQHBhcmFtIHJhd1RyYW5zYWN0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPiwgcmF3VHJhbnNhY3Rpb24/OiBUcmFuc2FjdGlvblJlY2VpcHQpIHtcbiAgICBzdXBlcihjb2luQ29uZmlnKTtcbiAgICBpZiAocmF3VHJhbnNhY3Rpb24pIHtcbiAgICAgIGlmICghcmF3VHJhbnNhY3Rpb24udHhJRCkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBoYXMgbm8gaWQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lkID0gcmF3VHJhbnNhY3Rpb24udHhJRDtcbiAgICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gcmF3VHJhbnNhY3Rpb247XG4gICAgICB0aGlzLl9kZWNvZGVkUmF3RGF0YUhleCA9IGRlY29kZVRyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uLnJhd19kYXRhX2hleCk7XG5cbiAgICAgIC8vIERlc3RpbmF0aW9uIGRlcGVuZHMgb24gdGhlIGNvbnRyYWN0IHR5cGVcbiAgICAgIHRoaXMucmVjb3JkUmF3RGF0YUZpZWxkcyh0aGlzLl9kZWNvZGVkUmF3RGF0YUhleCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSB0cmFuc2FjdGlvbiByYXcgZGF0YSBhbmQgcmVjb3JkIHRoZSBtb3N0IGltcG9ydGFudCBmaWVsZHMuXG4gICAqXG4gICAqIEBwYXJhbSByYXdEYXRhIE9iamVjdCBmcm9tIGEgdHJvbiB0cmFuc2FjdGlvblxuICAgKi9cbiAgcHJpdmF0ZSByZWNvcmRSYXdEYXRhRmllbGRzKHJhd0RhdGE6IFJhd0RhdGEpIHtcbiAgICAvLyBDb250cmFjdC1hZ25vc3RpYyBmaWVsZHNcbiAgICB0aGlzLl92YWxpZEZyb20gPSByYXdEYXRhLnRpbWVzdGFtcDtcbiAgICB0aGlzLl92YWxpZFRvID0gcmF3RGF0YS5leHBpcmF0aW9uO1xuXG4gICAgbGV0IG91dHB1dDogQ29udHJhY3RFbnRyeSwgaW5wdXQ6IENvbnRyYWN0RW50cnk7XG4gICAgLy8gQ29udHJhY3Qtc3BlY2lmaWMgZmllbGRzXG4gICAgc3dpdGNoIChyYXdEYXRhLmNvbnRyYWN0VHlwZSkge1xuICAgICAgY2FzZSBDb250cmFjdFR5cGUuVHJhbnNmZXI6XG4gICAgICAgIHRoaXMuX3R5cGUgPSBUcmFuc2FjdGlvblR5cGUuU2VuZDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXcgQmlnTnVtYmVyKChyYXdEYXRhLmNvbnRyYWN0WzBdIGFzIFRyYW5zZmVyQ29udHJhY3QpLnBhcmFtZXRlci52YWx1ZS5hbW91bnQpLnRvRml4ZWQoMCk7XG4gICAgICAgIG91dHB1dCA9IHtcbiAgICAgICAgICBhZGRyZXNzOiAocmF3RGF0YS5jb250cmFjdFswXSBhcyBUcmFuc2ZlckNvbnRyYWN0KS5wYXJhbWV0ZXIudmFsdWUudG9fYWRkcmVzcyxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgaW5wdXQgPSB7XG4gICAgICAgICAgYWRkcmVzczogKHJhd0RhdGEuY29udHJhY3RbMF0gYXMgVHJhbnNmZXJDb250cmFjdCkucGFyYW1ldGVyLnZhbHVlLm93bmVyX2FkZHJlc3MsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb250cmFjdFR5cGUuQWNjb3VudFBlcm1pc3Npb25VcGRhdGU6XG4gICAgICAgIHRoaXMuX3R5cGUgPSBUcmFuc2FjdGlvblR5cGUuV2FsbGV0SW5pdGlhbGl6YXRpb247XG4gICAgICAgIG91dHB1dCA9IHtcbiAgICAgICAgICBhZGRyZXNzOiAocmF3RGF0YS5jb250cmFjdCBhcyBhbnkpLm93bmVyX2FkZHJlc3MsXG4gICAgICAgICAgdmFsdWU6ICcwJyxcbiAgICAgICAgfTtcbiAgICAgICAgaW5wdXQgPSB7XG4gICAgICAgICAgYWRkcmVzczogKHJhd0RhdGEuY29udHJhY3QgYXMgYW55KS5vd25lcl9hZGRyZXNzLFxuICAgICAgICAgIHZhbHVlOiAnMCcsXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb250cmFjdFR5cGUuVHJpZ2dlclNtYXJ0Q29udHJhY3Q6XG4gICAgICAgIHRoaXMuX3R5cGUgPSBUcmFuc2FjdGlvblR5cGUuQ29udHJhY3RDYWxsO1xuICAgICAgICBjb25zdCBjb250cmFjdENhbGxWYWx1ZXMgPSAocmF3RGF0YS5jb250cmFjdFswXSBhcyBUcmlnZ2VyU21hcnRDb250cmFjdCkucGFyYW1ldGVyLnZhbHVlO1xuICAgICAgICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBjb250cmFjdENhbGxWYWx1ZXMuY29udHJhY3RfYWRkcmVzcztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRva2VuTWFpbm5ldENvbnRyYWN0QWRkcmVzc2VzLmluY2x1ZGVzKGNvbnRyYWN0QWRkcmVzcykgfHxcbiAgICAgICAgICB0b2tlblRlc3RuZXRDb250cmFjdEFkZHJlc3Nlcy5pbmNsdWRlcyhjb250cmFjdEFkZHJlc3MpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgdGhlbiBhIHRva2VuIHNtYXJ0IGNvbnRyYWN0IHRyYW5zYWN0aW9uIGFuZCB0aGUgZGF0YSBtdXN0IGJlIGRlY29kZWRcbiAgICAgICAgICBjb25zdCB0eXBlcyA9IFsnYWRkcmVzcycsICd1aW50MjU2J107XG4gICAgICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5mcm9tKGNvbnRyYWN0Q2FsbFZhbHVlcy5kYXRhLCAnYmFzZTY0JykudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgIGNvbnN0IGRlY29kZWREYXRhID0gZGVjb2RlRGF0YVBhcmFtcyh0eXBlcywgZGF0YSk7XG4gICAgICAgICAgY29uc3QgcmVjaXBpZW50X2FkZHJlc3MgPSBnZXRCYXNlNThBZGRyZXNzRnJvbUhleChkZWNvZGVkRGF0YVswXSk7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBkZWNvZGVkRGF0YVsxXS50b1N0cmluZygpO1xuICAgICAgICAgIG91dHB1dCA9IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHJlY2lwaWVudF9hZGRyZXNzLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpbnB1dCA9IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGNvbnRyYWN0Q2FsbFZhbHVlcy5vd25lcl9hZGRyZXNzLFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ID0ge1xuICAgICAgICAgIGFkZHJlc3M6IGNvbnRyYWN0Q2FsbFZhbHVlcy5vd25lcl9hZGRyZXNzLFxuICAgICAgICAgIHZhbHVlOiAnMCcsXG4gICAgICAgIH07XG4gICAgICAgIGlucHV0ID0ge1xuICAgICAgICAgIGFkZHJlc3M6IGNvbnRyYWN0Q2FsbFZhbHVlcy5vd25lcl9hZGRyZXNzLFxuICAgICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICBkYXRhOiBjb250cmFjdENhbGxWYWx1ZXMuZGF0YSxcbiAgICAgICAgICB2YWx1ZTogJzAnLFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBQYXJzZVRyYW5zYWN0aW9uRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbnRyYWN0IHR5cGUnKTtcbiAgICB9XG4gICAgdGhpcy5faW5wdXRzID0gW2lucHV0XTtcbiAgICB0aGlzLl9vdXRwdXRzID0gW291dHB1dF07XG4gIH1cblxuICAvKipcbiAgICogUmVjYWxjdWxhdGUgYW5kIHVwZGF0ZSB0aGUgdHJhbnNhY3Rpb24gaWQuIFRoaXMgc2hvdWxkIGJlIGRvbmUgYWZ0ZXIgY2hhbmdpbmcgYW55IHRyYW5zYWN0aW9uXG4gICAqIGZpZWxkIHNpbmNlIHRoZSB0aGUgaWQgaXMgYSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBib2R5LlxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVJZCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX3RyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VUcmFuc2FjdGlvbkVycm9yKCdFbXB0eSB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBoZXhCdWZmZXIgPSBCdWZmZXIuZnJvbSh0aGlzLl90cmFuc2FjdGlvbi5yYXdfZGF0YV9oZXgsICdoZXgnKTtcbiAgICBjb25zdCBuZXdUeGlkID0gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGhleEJ1ZmZlcikuZGlnZXN0KCdoZXgnKTtcbiAgICB0aGlzLl90cmFuc2FjdGlvbi50eElEID0gbmV3VHhpZDtcbiAgICB0aGlzLl9pZCA9IG5ld1R4aWQ7XG4gIH1cblxuICAvKipcbiAgICogRXh0ZW5kIHRoZSBleHBpcmF0aW9uIGRhdGUgYnkgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gICAqXG4gICAqIEBwYXJhbSBleHRlbnNpb25NcyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBleHRlbmQgdGhlIGV4cGlyYXRpb24gYnlcbiAgICovXG4gIGV4dGVuZEV4cGlyYXRpb24oZXh0ZW5zaW9uTXM6IG51bWJlcik6IHZvaWQge1xuICAgIGlmIChleHRlbnNpb25NcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFeHRlbmRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIGV4dGVuc2lvbiByYW5nZS4gTXVzdCBiZSBwb3NpdGl2ZSBhIGludGVnZXInKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3RyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXh0ZW5kVHJhbnNhY3Rpb25FcnJvcignRW1wdHkgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24uc2lnbmF0dXJlICYmIHRoaXMuX3RyYW5zYWN0aW9uLnNpZ25hdHVyZS5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXh0ZW5kVHJhbnNhY3Rpb25FcnJvcignQ2Fubm90IGV4dGVuZCBhIHNpZ25lZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IHJhd0RhdGFIZXggPSB0aGlzLl90cmFuc2FjdGlvbi5yYXdfZGF0YV9oZXg7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuZnJvbShyYXdEYXRhSGV4LCAnaGV4Jyk7XG4gICAgbGV0IHJhdztcbiAgICB0cnkge1xuICAgICAgcmF3ID0gcHJvdG9jb2wuVHJhbnNhY3Rpb24ucmF3LmRlY29kZShieXRlcyk7XG4gICAgICBjb25zdCBuZXdFeHBpcmF0aW9uID0gbmV3IEJpZ051bWJlcihyYXcuZXhwaXJhdGlvbikucGx1cyhleHRlbnNpb25NcykudG9OdW1iZXIoKTtcbiAgICAgIHJhdy5leHBpcmF0aW9uID0gbmV3RXhwaXJhdGlvbjtcbiAgICAgIGNvbnN0IG5ld1Jhd0RhdGFIZXggPSBCdWZmZXIuZnJvbShwcm90b2NvbC5UcmFuc2FjdGlvbi5yYXcuZW5jb2RlKHJhdykuZmluaXNoKCkpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIC8vIFNldCB0aGUgaW50ZXJuYWwgdmFyaWFibGVzIHRvIGFjY291bnQgZm9yIHRoZSBuZXcgZXhwaXJhdGlvbiBkYXRlXG4gICAgICB0aGlzLl90cmFuc2FjdGlvbi5yYXdfZGF0YV9oZXggPSBuZXdSYXdEYXRhSGV4O1xuICAgICAgdGhpcy5fdHJhbnNhY3Rpb24ucmF3X2RhdGEuZXhwaXJhdGlvbiA9IG5ld0V4cGlyYXRpb247XG4gICAgICB0aGlzLl9kZWNvZGVkUmF3RGF0YUhleCA9IGRlY29kZVRyYW5zYWN0aW9uKG5ld1Jhd0RhdGFIZXgpO1xuICAgICAgdGhpcy5yZWNvcmRSYXdEYXRhRmllbGRzKHRoaXMuX2RlY29kZWRSYXdEYXRhSGV4KTtcbiAgICAgIHRoaXMudXBkYXRlSWQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXh0ZW5kVHJhbnNhY3Rpb25FcnJvcignVGhlcmUgd2FzIGFuIGVycm9yIGRlY29kaW5nIHRoZSBpbml0aWFsIHJhd19kYXRhX2hleCBmcm9tIHRoZSBzZXJpYWxpemVkIHR4LicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNpZ25hdHVyZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAqL1xuICBnZXQgc2lnbmF0dXJlKCk6IHN0cmluZ1tdIHtcbiAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24gJiYgdGhpcy5fdHJhbnNhY3Rpb24uc2lnbmF0dXJlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb24uc2lnbmF0dXJlO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdGhpcyB0cmFuc2FjdGlvbiBiZWNvbWVzIHZhbGlkIGFuZCBjYW4gYmUgYnJvYWRjYXN0ZWQgdG8gdGhlXG4gICAqIG5ldHdvcmsuXG4gICAqL1xuICBnZXQgdmFsaWRGcm9tKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkRnJvbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4cGlyYXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gICAqL1xuICBnZXQgdmFsaWRUbygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl92YWxpZFRvO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGdldCBvdXRwdXRzKCk6IENvbnRyYWN0RW50cnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuX291dHB1dHM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgZ2V0IGlucHV0cygpOiBDb250cmFjdEVudHJ5W10ge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dHM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgY2FuU2lnbihrZXk6IEJhc2VLZXkpOiBib29sZWFuIHtcbiAgICAvLyBUcm9uIHRyYW5zYWN0aW9uIGRvIG5vdCBjb250YWluIHRoZSBvd25lcnMgYWNjb3VudCBhZGRyZXNzIHNvIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBjaGVjayB0aGVcbiAgICAvLyBwcml2YXRlIGtleSB3aXRoIGFueSBidXQgdGhlIGFjY291bnQgbWFpbiBhZGRyZXNzLiBUaGlzIGlzIG5vdCBlbm91Z2ggdG8gZmFpbCB0aGlzIGNoZWNrLCBzb1xuICAgIC8vIGl0IGlzIGEgbm8tb3AuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHR4IHRyYW5zYWN0aW9uXG4gICAqL1xuICBzZXRUcmFuc2FjdGlvblJlY2VpcHQodHg6IFRyYW5zYWN0aW9uUmVjZWlwdCkge1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gdHg7XG4gICAgdGhpcy51cGRhdGVJZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdHJhbnNhY3Rpb24gdHlwZVxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uVHlwZX0gdHJhbnNhY3Rpb25UeXBlIFRoZSB0cmFuc2FjdGlvbiB0eXBlIHRvIGJlIHNldFxuICAgKi9cbiAgc2V0VHJhbnNhY3Rpb25UeXBlKHRyYW5zYWN0aW9uVHlwZTogVHJhbnNhY3Rpb25UeXBlKTogdm9pZCB7XG4gICAgdGhpcy5fdHlwZSA9IHRyYW5zYWN0aW9uVHlwZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB0b0pzb24oKTogVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICBpZiAoIXRoaXMuX3RyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VUcmFuc2FjdGlvbkVycm9yKCdFbXB0eSB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdG9Ccm9hZGNhc3RGb3JtYXQoKTogYW55IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pzb24oKSk7XG4gIH1cbn1cbiJdfQ==