"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyPair = void 0;
const utxo_lib_1 = require("@bitgo/utxo-lib");
const crypto_1 = require("crypto");
const sdk_core_1 = require("@bitgo/sdk-core");
const Utils = __importStar(require("./utils"));
const DEFAULT_SEED_SIZE_BYTES = 16;
/**
 * Tron keys and address management.
 */
class KeyPair extends sdk_core_1.Secp256k1ExtendedKeyPair {
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param {KeyPairOptions} source Either a master seed, a private key (extended or raw), or a public key
     *     (extended, compressed, or uncompressed)
     */
    constructor(source) {
        super(source);
        if (!source) {
            const seed = (0, crypto_1.randomBytes)(DEFAULT_SEED_SIZE_BYTES);
            this.hdNode = utxo_lib_1.bip32.fromSeed(seed);
        }
        else if ((0, sdk_core_1.isSeed)(source)) {
            this.hdNode = utxo_lib_1.bip32.fromSeed(source.seed);
        }
        else if ((0, sdk_core_1.isPrivateKey)(source)) {
            super.recordKeysFromPrivateKey(source.prv);
        }
        else if ((0, sdk_core_1.isPublicKey)(source)) {
            super.recordKeysFromPublicKey(source.pub);
        }
        else {
            throw new Error('Invalid key pair options');
        }
        if (this.hdNode) {
            this.keyPair = sdk_core_1.Secp256k1ExtendedKeyPair.toKeyPair(this.hdNode);
        }
    }
    /**
     * Tron default keys format is raw private and uncompressed public key
     *
     * @returns {DefaultKeys} The keys in the protocol default key format
     */
    getKeys() {
        var _a;
        return {
            pub: this.getPublicKey({ compressed: false }).toString('hex').toUpperCase(),
            prv: (_a = this.getPrivateKey()) === null || _a === void 0 ? void 0 : _a.toString('hex').toUpperCase(),
        };
    }
    /**
     * Get a public address in the specified format, or in base58 if none is provided.
     *
     * @param {AddressFormat} format The address specified format
     * @returns {string} The public address in the specified format
     */
    getAddress(format) {
        const { pub } = this.getKeys();
        // These are custom Tron methods. They can probably be replaced with other methods or libraries
        const addressBytes = Utils.getRawAddressFromPubKey(Buffer.from(pub, 'hex'));
        if (!format || format === sdk_core_1.AddressFormat.base58) {
            // Default address are in hex
            return Utils.getBase58AddressFromByteArray(addressBytes);
        }
        else if (format === sdk_core_1.AddressFormat.hex) {
            return Utils.getHexAddressFromByteArray(addressBytes);
        }
        throw new Error('Unsupported address format');
    }
    /**
     * Generates a signature for an arbitrary string with the current private key using keccak256
     * hashing algorithm. Throws if there is no private key.
     *
     * @param {string} message to produce a signature for
     * @returns {Buffer} The signature as a buffer
     */
    signMessage(message) {
        const messageToSign = Buffer.from(message).toString('hex');
        const { prv } = this.getKeys();
        if (!prv) {
            throw new Error('Missing private key');
        }
        const signature = Utils.signString(messageToSign, prv, true).replace(/^0x/, '');
        return Buffer.from(signature, 'hex');
    }
    /**
     * Verifies a message signature using the current public key.
     *
     * @param {string} message signed
     * @param {Buffer} signature to verify
     * @returns {boolean} True if the message was signed with the current key pair
     */
    verifySignature(message, signature) {
        const messageToVerify = Buffer.from(message).toString('hex');
        const address = this.getAddress(sdk_core_1.AddressFormat.base58);
        return Utils.verifySignature(messageToVerify, address, signature.toString('hex'), true);
    }
}
exports.KeyPair = KeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIva2V5UGFpci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDhDQUF3QztBQUN4QyxtQ0FBcUM7QUFDckMsOENBUXlCO0FBQ3pCLCtDQUFpQztBQUVqQyxNQUFNLHVCQUF1QixHQUFHLEVBQUUsQ0FBQztBQUVuQzs7R0FFRztBQUNILE1BQWEsT0FBUSxTQUFRLG1DQUF3QjtJQUNuRDs7Ozs7T0FLRztJQUNILFlBQVksTUFBdUI7UUFDakMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2QsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLE1BQU0sSUFBSSxHQUFHLElBQUEsb0JBQVcsRUFBQyx1QkFBdUIsQ0FBQyxDQUFDO1lBQ2xELElBQUksQ0FBQyxNQUFNLEdBQUcsZ0JBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDcEM7YUFBTSxJQUFJLElBQUEsaUJBQU0sRUFBQyxNQUFNLENBQUMsRUFBRTtZQUN6QixJQUFJLENBQUMsTUFBTSxHQUFHLGdCQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUMzQzthQUFNLElBQUksSUFBQSx1QkFBWSxFQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQy9CLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDNUM7YUFBTSxJQUFJLElBQUEsc0JBQVcsRUFBQyxNQUFNLENBQUMsRUFBRTtZQUM5QixLQUFLLENBQUMsdUJBQXVCLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNDO2FBQU07WUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUM7U0FDN0M7UUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDZixJQUFJLENBQUMsT0FBTyxHQUFHLG1DQUF3QixDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDaEU7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE9BQU87O1FBQ0wsT0FBTztZQUNMLEdBQUcsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLFdBQVcsRUFBRTtZQUMzRSxHQUFHLEVBQUUsTUFBQSxJQUFJLENBQUMsYUFBYSxFQUFFLDBDQUFFLFFBQVEsQ0FBQyxLQUFLLEVBQUUsV0FBVyxFQUFFO1NBQ3pELENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxVQUFVLENBQUMsTUFBc0I7UUFDL0IsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUMvQiwrRkFBK0Y7UUFDL0YsTUFBTSxZQUFZLEdBQUcsS0FBSyxDQUFDLHVCQUF1QixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFFNUUsSUFBSSxDQUFDLE1BQU0sSUFBSSxNQUFNLEtBQUssd0JBQWEsQ0FBQyxNQUFNLEVBQUU7WUFDOUMsNkJBQTZCO1lBQzdCLE9BQU8sS0FBSyxDQUFDLDZCQUE2QixDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQzFEO2FBQU0sSUFBSSxNQUFNLEtBQUssd0JBQWEsQ0FBQyxHQUFHLEVBQUU7WUFDdkMsT0FBTyxLQUFLLENBQUMsMEJBQTBCLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDdkQ7UUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILFdBQVcsQ0FBQyxPQUFlO1FBQ3pCLE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzNELE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDL0IsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNSLE1BQU0sSUFBSSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztTQUN4QztRQUNELE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsYUFBYSxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ2hGLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILGVBQWUsQ0FBQyxPQUFlLEVBQUUsU0FBaUI7UUFDaEQsTUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDN0QsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyx3QkFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RELE9BQU8sS0FBSyxDQUFDLGVBQWUsQ0FBQyxlQUFlLEVBQUUsT0FBTyxFQUFFLFNBQVMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDMUYsQ0FBQztDQUNGO0FBeEZELDBCQXdGQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJpcDMyIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7XG4gIEFkZHJlc3NGb3JtYXQsXG4gIERlZmF1bHRLZXlzLFxuICBpc1ByaXZhdGVLZXksXG4gIGlzUHVibGljS2V5LFxuICBpc1NlZWQsXG4gIEtleVBhaXJPcHRpb25zLFxuICBTZWNwMjU2azFFeHRlbmRlZEtleVBhaXIsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgREVGQVVMVF9TRUVEX1NJWkVfQllURVMgPSAxNjtcblxuLyoqXG4gKiBUcm9uIGtleXMgYW5kIGFkZHJlc3MgbWFuYWdlbWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIEtleVBhaXIgZXh0ZW5kcyBTZWNwMjU2azFFeHRlbmRlZEtleVBhaXIge1xuICAvKipcbiAgICogUHVibGljIGNvbnN0cnVjdG9yLiBCeSBkZWZhdWx0LCBjcmVhdGVzIGEga2V5IHBhaXIgd2l0aCBhIHJhbmRvbSBtYXN0ZXIgc2VlZC5cbiAgICpcbiAgICogQHBhcmFtIHtLZXlQYWlyT3B0aW9uc30gc291cmNlIEVpdGhlciBhIG1hc3RlciBzZWVkLCBhIHByaXZhdGUga2V5IChleHRlbmRlZCBvciByYXcpLCBvciBhIHB1YmxpYyBrZXlcbiAgICogICAgIChleHRlbmRlZCwgY29tcHJlc3NlZCwgb3IgdW5jb21wcmVzc2VkKVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlPzogS2V5UGFpck9wdGlvbnMpIHtcbiAgICBzdXBlcihzb3VyY2UpO1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICBjb25zdCBzZWVkID0gcmFuZG9tQnl0ZXMoREVGQVVMVF9TRUVEX1NJWkVfQllURVMpO1xuICAgICAgdGhpcy5oZE5vZGUgPSBiaXAzMi5mcm9tU2VlZChzZWVkKTtcbiAgICB9IGVsc2UgaWYgKGlzU2VlZChzb3VyY2UpKSB7XG4gICAgICB0aGlzLmhkTm9kZSA9IGJpcDMyLmZyb21TZWVkKHNvdXJjZS5zZWVkKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJpdmF0ZUtleShzb3VyY2UpKSB7XG4gICAgICBzdXBlci5yZWNvcmRLZXlzRnJvbVByaXZhdGVLZXkoc291cmNlLnBydik7XG4gICAgfSBlbHNlIGlmIChpc1B1YmxpY0tleShzb3VyY2UpKSB7XG4gICAgICBzdXBlci5yZWNvcmRLZXlzRnJvbVB1YmxpY0tleShzb3VyY2UucHViKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSBwYWlyIG9wdGlvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oZE5vZGUpIHtcbiAgICAgIHRoaXMua2V5UGFpciA9IFNlY3AyNTZrMUV4dGVuZGVkS2V5UGFpci50b0tleVBhaXIodGhpcy5oZE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcm9uIGRlZmF1bHQga2V5cyBmb3JtYXQgaXMgcmF3IHByaXZhdGUgYW5kIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5XG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZhdWx0S2V5c30gVGhlIGtleXMgaW4gdGhlIHByb3RvY29sIGRlZmF1bHQga2V5IGZvcm1hdFxuICAgKi9cbiAgZ2V0S2V5cygpOiBEZWZhdWx0S2V5cyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YjogdGhpcy5nZXRQdWJsaWNLZXkoeyBjb21wcmVzc2VkOiBmYWxzZSB9KS50b1N0cmluZygnaGV4JykudG9VcHBlckNhc2UoKSxcbiAgICAgIHBydjogdGhpcy5nZXRQcml2YXRlS2V5KCk/LnRvU3RyaW5nKCdoZXgnKS50b1VwcGVyQ2FzZSgpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcHVibGljIGFkZHJlc3MgaW4gdGhlIHNwZWNpZmllZCBmb3JtYXQsIG9yIGluIGJhc2U1OCBpZiBub25lIGlzIHByb3ZpZGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0FkZHJlc3NGb3JtYXR9IGZvcm1hdCBUaGUgYWRkcmVzcyBzcGVjaWZpZWQgZm9ybWF0XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBwdWJsaWMgYWRkcmVzcyBpbiB0aGUgc3BlY2lmaWVkIGZvcm1hdFxuICAgKi9cbiAgZ2V0QWRkcmVzcyhmb3JtYXQ/OiBBZGRyZXNzRm9ybWF0KTogc3RyaW5nIHtcbiAgICBjb25zdCB7IHB1YiB9ID0gdGhpcy5nZXRLZXlzKCk7XG4gICAgLy8gVGhlc2UgYXJlIGN1c3RvbSBUcm9uIG1ldGhvZHMuIFRoZXkgY2FuIHByb2JhYmx5IGJlIHJlcGxhY2VkIHdpdGggb3RoZXIgbWV0aG9kcyBvciBsaWJyYXJpZXNcbiAgICBjb25zdCBhZGRyZXNzQnl0ZXMgPSBVdGlscy5nZXRSYXdBZGRyZXNzRnJvbVB1YktleShCdWZmZXIuZnJvbShwdWIsICdoZXgnKSk7XG5cbiAgICBpZiAoIWZvcm1hdCB8fCBmb3JtYXQgPT09IEFkZHJlc3NGb3JtYXQuYmFzZTU4KSB7XG4gICAgICAvLyBEZWZhdWx0IGFkZHJlc3MgYXJlIGluIGhleFxuICAgICAgcmV0dXJuIFV0aWxzLmdldEJhc2U1OEFkZHJlc3NGcm9tQnl0ZUFycmF5KGFkZHJlc3NCeXRlcyk7XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IEFkZHJlc3NGb3JtYXQuaGV4KSB7XG4gICAgICByZXR1cm4gVXRpbHMuZ2V0SGV4QWRkcmVzc0Zyb21CeXRlQXJyYXkoYWRkcmVzc0J5dGVzKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBhZGRyZXNzIGZvcm1hdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHNpZ25hdHVyZSBmb3IgYW4gYXJiaXRyYXJ5IHN0cmluZyB3aXRoIHRoZSBjdXJyZW50IHByaXZhdGUga2V5IHVzaW5nIGtlY2NhazI1NlxuICAgKiBoYXNoaW5nIGFsZ29yaXRobS4gVGhyb3dzIGlmIHRoZXJlIGlzIG5vIHByaXZhdGUga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSB0byBwcm9kdWNlIGEgc2lnbmF0dXJlIGZvclxuICAgKiBAcmV0dXJucyB7QnVmZmVyfSBUaGUgc2lnbmF0dXJlIGFzIGEgYnVmZmVyXG4gICAqL1xuICBzaWduTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpOiBCdWZmZXIge1xuICAgIGNvbnN0IG1lc3NhZ2VUb1NpZ24gPSBCdWZmZXIuZnJvbShtZXNzYWdlKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgeyBwcnYgfSA9IHRoaXMuZ2V0S2V5cygpO1xuICAgIGlmICghcHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gVXRpbHMuc2lnblN0cmluZyhtZXNzYWdlVG9TaWduLCBwcnYsIHRydWUpLnJlcGxhY2UoL14weC8sICcnKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2lnbmF0dXJlLCAnaGV4Jyk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpZXMgYSBtZXNzYWdlIHNpZ25hdHVyZSB1c2luZyB0aGUgY3VycmVudCBwdWJsaWMga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBzaWduZWRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZSB0byB2ZXJpZnlcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIG1lc3NhZ2Ugd2FzIHNpZ25lZCB3aXRoIHRoZSBjdXJyZW50IGtleSBwYWlyXG4gICAqL1xuICB2ZXJpZnlTaWduYXR1cmUobWVzc2FnZTogc3RyaW5nLCBzaWduYXR1cmU6IEJ1ZmZlcik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG1lc3NhZ2VUb1ZlcmlmeSA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5nZXRBZGRyZXNzKEFkZHJlc3NGb3JtYXQuYmFzZTU4KTtcbiAgICByZXR1cm4gVXRpbHMudmVyaWZ5U2lnbmF0dXJlKG1lc3NhZ2VUb1ZlcmlmeSwgYWRkcmVzcywgc2lnbmF0dXJlLnRvU3RyaW5nKCdoZXgnKSwgdHJ1ZSk7XG4gIH1cbn1cbiJdfQ==