"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenTransferBuilder = void 0;
const contractCallBuilder_1 = require("./contractCallBuilder");
const utils_1 = require("./utils");
// the first 4 bytes of the Keccak-256 encoded function selector used in token transfers, 'transfer(address,uint256)'
// this must be concatenated with the encoded parameters, recipientAddress and amount
const methodId = '0xa9059cbb';
class TokenTransferBuilder extends contractCallBuilder_1.ContractCallBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
    }
    /** @inheritdoc */
    async buildImplementation() {
        return await super.buildImplementation();
    }
    /**
     * Set the data with the transfer method call and parameters
     *
     * @param recipientAddress - recipient of token transfer
     * @param amount - token amount
     */
    tokenTransferData(recipientAddress, amount) {
        this.validateAddress({ address: recipientAddress });
        const recipientHex = (0, utils_1.getHexAddressFromBase58Address)(recipientAddress);
        const types = ['address', 'uint256'];
        const values = [recipientHex, amount];
        const tokenTransferData = (0, utils_1.encodeDataParams)(types, values, methodId);
        this.data(tokenTransferData);
        return this;
    }
    /** @inheritdoc */
    fromImplementation(rawTransaction) {
        return super.fromImplementation(rawTransaction);
    }
    /** @inheritdoc */
    signImplementation(key) {
        return super.signImplementation(key);
    }
}
exports.TokenTransferBuilder = TokenTransferBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW5UcmFuc2ZlckJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3Rva2VuVHJhbnNmZXJCdWlsZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUVBLCtEQUE0RDtBQUU1RCxtQ0FBMkU7QUFFM0UscUhBQXFIO0FBQ3JILHFGQUFxRjtBQUNyRixNQUFNLFFBQVEsR0FBRyxZQUFZLENBQUM7QUFFOUIsTUFBYSxvQkFBcUIsU0FBUSx5Q0FBbUI7SUFJM0QsWUFBWSxXQUFpQztRQUMzQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDckIsQ0FBQztJQUVELGtCQUFrQjtJQUNSLEtBQUssQ0FBQyxtQkFBbUI7UUFDakMsT0FBTyxNQUFNLEtBQUssQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO0lBQzNDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGlCQUFpQixDQUFDLGdCQUF3QixFQUFFLE1BQWM7UUFDeEQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7UUFDcEQsTUFBTSxZQUFZLEdBQUcsSUFBQSxzQ0FBOEIsRUFBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBRXRFLE1BQU0sS0FBSyxHQUFHLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ3JDLE1BQU0sTUFBTSxHQUFHLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3RDLE1BQU0saUJBQWlCLEdBQUcsSUFBQSx3QkFBZ0IsRUFBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ3BFLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUM3QixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxrQkFBa0I7SUFDUixrQkFBa0IsQ0FBQyxjQUFtQjtRQUM5QyxPQUFPLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRUQsa0JBQWtCO0lBQ1Isa0JBQWtCLENBQUMsR0FBWTtRQUN2QyxPQUFPLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN2QyxDQUFDO0NBQ0Y7QUF2Q0Qsb0RBdUNDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IEJhc2VLZXkgfSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgQ29udHJhY3RDYWxsQnVpbGRlciB9IGZyb20gJy4vY29udHJhY3RDYWxsQnVpbGRlcic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgZ2V0SGV4QWRkcmVzc0Zyb21CYXNlNThBZGRyZXNzLCBlbmNvZGVEYXRhUGFyYW1zIH0gZnJvbSAnLi91dGlscyc7XG5cbi8vIHRoZSBmaXJzdCA0IGJ5dGVzIG9mIHRoZSBLZWNjYWstMjU2IGVuY29kZWQgZnVuY3Rpb24gc2VsZWN0b3IgdXNlZCBpbiB0b2tlbiB0cmFuc2ZlcnMsICd0cmFuc2ZlcihhZGRyZXNzLHVpbnQyNTYpJ1xuLy8gdGhpcyBtdXN0IGJlIGNvbmNhdGVuYXRlZCB3aXRoIHRoZSBlbmNvZGVkIHBhcmFtZXRlcnMsIHJlY2lwaWVudEFkZHJlc3MgYW5kIGFtb3VudFxuY29uc3QgbWV0aG9kSWQgPSAnMHhhOTA1OWNiYic7XG5cbmV4cG9ydCBjbGFzcyBUb2tlblRyYW5zZmVyQnVpbGRlciBleHRlbmRzIENvbnRyYWN0Q2FsbEJ1aWxkZXIge1xuICBwcml2YXRlIF9yZWNpcGllbnRBZGRyZXNzOyAvLyBjdXJyZW50bHkgb25seSBzdXBwb3J0IDEgdG9rZW4vdHJhbnNmZXJcbiAgcHJpdmF0ZSBfYW1vdW50O1xuXG4gIGNvbnN0cnVjdG9yKF9jb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xuICAgIHN1cGVyKF9jb2luQ29uZmlnKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgYnVpbGRJbXBsZW1lbnRhdGlvbigpOiBQcm9taXNlPFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIGF3YWl0IHN1cGVyLmJ1aWxkSW1wbGVtZW50YXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRhdGEgd2l0aCB0aGUgdHJhbnNmZXIgbWV0aG9kIGNhbGwgYW5kIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIHJlY2lwaWVudEFkZHJlc3MgLSByZWNpcGllbnQgb2YgdG9rZW4gdHJhbnNmZXJcbiAgICogQHBhcmFtIGFtb3VudCAtIHRva2VuIGFtb3VudFxuICAgKi9cbiAgdG9rZW5UcmFuc2ZlckRhdGEocmVjaXBpZW50QWRkcmVzczogc3RyaW5nLCBhbW91bnQ6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMudmFsaWRhdGVBZGRyZXNzKHsgYWRkcmVzczogcmVjaXBpZW50QWRkcmVzcyB9KTtcbiAgICBjb25zdCByZWNpcGllbnRIZXggPSBnZXRIZXhBZGRyZXNzRnJvbUJhc2U1OEFkZHJlc3MocmVjaXBpZW50QWRkcmVzcyk7XG5cbiAgICBjb25zdCB0eXBlcyA9IFsnYWRkcmVzcycsICd1aW50MjU2J107XG4gICAgY29uc3QgdmFsdWVzID0gW3JlY2lwaWVudEhleCwgYW1vdW50XTtcbiAgICBjb25zdCB0b2tlblRyYW5zZmVyRGF0YSA9IGVuY29kZURhdGFQYXJhbXModHlwZXMsIHZhbHVlcywgbWV0aG9kSWQpO1xuICAgIHRoaXMuZGF0YSh0b2tlblRyYW5zZmVyRGF0YSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGZyb21JbXBsZW1lbnRhdGlvbihyYXdUcmFuc2FjdGlvbjogYW55KTogVHJhbnNhY3Rpb24ge1xuICAgIHJldHVybiBzdXBlci5mcm9tSW1wbGVtZW50YXRpb24ocmF3VHJhbnNhY3Rpb24pO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBzaWduSW1wbGVtZW50YXRpb24oa2V5OiBCYXNlS2V5KTogVHJhbnNhY3Rpb24ge1xuICAgIHJldHVybiBzdXBlci5zaWduSW1wbGVtZW50YXRpb24oa2V5KTtcbiAgfVxufVxuIl19