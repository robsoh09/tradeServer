"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Trx = exports.NodeTypes = exports.DEFAULT_SCAN_FACTOR = exports.RECOVER_TRANSACTION_EXPIRY = exports.SAFE_TRON_TOKEN_TRANSACTION_FEE = exports.SAFE_TRON_TRANSACTION_FEE = exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE = void 0;
/**
 * @prettier
 */
const secp256k1 = __importStar(require("secp256k1"));
const crypto_1 = require("crypto");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const request = __importStar(require("superagent"));
const sdk_core_1 = require("@bitgo/sdk-core");
const lib_1 = require("./lib");
const builder_1 = require("./lib/builder");
const lodash_1 = require("lodash");
exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE = 1e6;
exports.SAFE_TRON_TRANSACTION_FEE = 2.1 * 1e6; // TRON foundation recommends 2.1 TRX as fees for guaranteed transaction
exports.SAFE_TRON_TOKEN_TRANSACTION_FEE = 100 * 1e6; // TRON foundation recommends 100 TRX as fees for guaranteed transaction
exports.RECOVER_TRANSACTION_EXPIRY = 86400000; // 24 hour
exports.DEFAULT_SCAN_FACTOR = 20; // default number of receive addresses to scan for funds
var NodeTypes;
(function (NodeTypes) {
    NodeTypes[NodeTypes["Full"] = 0] = "Full";
    NodeTypes[NodeTypes["Solidity"] = 1] = "Solidity";
})(NodeTypes = exports.NodeTypes || (exports.NodeTypes = {}));
class Trx extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    getChain() {
        return this._staticsCoin.name;
    }
    getFamily() {
        return this._staticsCoin.family;
    }
    getFullName() {
        return this._staticsCoin.fullName;
    }
    getBaseFactor() {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    }
    /** @inheritdoc */
    transactionDataAllowed() {
        return true;
    }
    static createInstance(bitgo, staticsCoin) {
        return new Trx(bitgo, staticsCoin);
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return true;
    }
    /** @inheritDoc */
    allowsAccountConsolidations() {
        return true;
    }
    /**
     * Checks if this is a valid base58 or hex address
     * @param address
     */
    isValidAddress(address) {
        if (!address) {
            return false;
        }
        return this.isValidHexAddress(address) || lib_1.Utils.isBase58Address(address);
    }
    /**
     * Checks if this is a valid hex address
     * @param address hex address
     */
    isValidHexAddress(address) {
        return /^41[0-9a-f]{40}$/i.test(address);
    }
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    generateKeyPair(seed) {
        // TODO: move this and address creation logic to account-lib
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256 bit chain code, both of which must be
            // random. 512 bits is therefore the maximum entropy and gives us maximum security against cracking.
            seed = (0, crypto_1.randomBytes)(512 / 8);
        }
        const hd = utxo_lib_1.bip32.fromSeed(seed);
        return {
            pub: hd.neutered().toBase58(),
            prv: hd.toBase58(),
        };
    }
    isValidXpub(xpub) {
        try {
            return utxo_lib_1.bip32.fromBase58(xpub).isNeutered();
        }
        catch (e) {
            return false;
        }
    }
    isValidPub(pub) {
        if (this.isValidXpub(pub)) {
            // xpubs can be converted into regular pubs, so technically it is a valid pub
            return true;
        }
        return new RegExp('^04[a-zA-Z0-9]{128}$').test(pub);
    }
    async parseTransaction(params) {
        return {};
    }
    async isWalletAddress(params) {
        throw new sdk_core_1.MethodNotImplementedError();
    }
    async verifyTransaction(params) {
        return true;
    }
    /**
     * Derive a user key using the chain path of the address
     * @param key
     * @param path
     * @returns {string} derived private key
     */
    deriveKeyWithPath({ key, path }) {
        const keychain = utxo_lib_1.bip32.fromBase58(key);
        const derivedKeyNode = keychain.derivePath(path);
        return derivedKeyNode.toBase58();
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param params.wallet.addressVersion {String} this is the version of the Algorand multisig address generation format
     * @returns Bluebird<SignedTransaction>
     */
    async signTransaction(params) {
        var _a, _b;
        const txBuilder = (0, builder_1.getBuilder)(this.getChain()).from(params.txPrebuild.txHex);
        let key;
        const { chain, index } = (_b = (_a = params.txPrebuild) === null || _a === void 0 ? void 0 : _a.addressInfo) !== null && _b !== void 0 ? _b : { chain: 0, index: 0 };
        if (chain === 0 && index === 0) {
            key = params.prv;
        }
        else {
            const derivationPath = `0/0/${chain}/${index}`;
            key = this.deriveKeyWithPath({ key: params.prv, path: derivationPath });
        }
        txBuilder.sign({ key });
        const transaction = await txBuilder.build();
        const response = {
            txHex: JSON.stringify(transaction.toJson()),
        };
        if (transaction.toJson().signature.length >= 2) {
            return response;
        }
        // Half signed transaction
        return {
            halfSigned: response,
        };
    }
    /**
     * Return boolean indicating whether input is valid seed for the coin
     *
     * @param prv - the prv to be checked
     */
    isValidXprv(prv) {
        try {
            return !utxo_lib_1.bip32.fromBase58(prv).isNeutered();
        }
        catch {
            return false;
        }
    }
    /**
     * Convert a message to string in hexadecimal format.
     *
     * @param message {Buffer|String} message to sign
     * @return the message as a hexadecimal string
     */
    toHexString(message) {
        if (typeof message === 'string') {
            return Buffer.from(message).toString('hex');
        }
        else if (Buffer.isBuffer(message)) {
            return message.toString('hex');
        }
        else {
            throw new Error('Invalid messaged passed to signMessage');
        }
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        var _a;
        const toSign = this.toHexString(message);
        let prv = key.prv;
        if (this.isValidXprv(prv)) {
            prv = (_a = utxo_lib_1.bip32.fromBase58(prv).privateKey) === null || _a === void 0 ? void 0 : _a.toString('hex');
        }
        if (!prv) {
            throw new Error('no privateKey');
        }
        let sig = lib_1.Utils.signString(toSign, prv, true);
        // remove the preceding 0x
        sig = sig.replace(/^0x/, '');
        return Buffer.from(sig, 'hex');
    }
    /**
     * Converts an xpub to a uncompressed pub
     * @param xpub
     */
    xpubToUncompressedPub(xpub) {
        if (!this.isValidXpub(xpub)) {
            throw new Error('invalid xpub');
        }
        const publicKey = utxo_lib_1.bip32.fromBase58(xpub, utxo_lib_1.networks.bitcoin).publicKey;
        return Buffer.from(secp256k1.publicKeyConvert(publicKey, false /* compressed */)).toString('hex');
    }
    /**
     * Modify prebuild before sending it to the server.
     * @param buildParams The whitelisted parameters for this prebuild
     */
    async getExtraPrebuildParams(buildParams) {
        if (buildParams.recipients[0].data && buildParams.feeLimit) {
            buildParams.recipients[0].feeLimit = buildParams.feeLimit;
        }
    }
    pubToHexAddress(pub) {
        const byteArrayAddr = lib_1.Utils.getByteArrayFromHexAddress(pub);
        const rawAddress = lib_1.Utils.getRawAddressFromPubKey(byteArrayAddr);
        return lib_1.Utils.getHexAddressFromByteArray(rawAddress);
    }
    xprvToCompressedPrv(xprv) {
        if (!this.isValidXprv(xprv)) {
            throw new Error('invalid xprv');
        }
        const hdNode = utxo_lib_1.bip32.fromBase58(xprv, utxo_lib_1.networks.bitcoin);
        if (!hdNode.privateKey) {
            throw new Error('no privateKey');
        }
        return hdNode.privateKey.toString('hex');
    }
    getNodeUrl(node) {
        switch (node) {
            case NodeTypes.Full:
                return sdk_core_1.common.Environments[this.bitgo.getEnv()].tronNodes.full;
            case NodeTypes.Solidity:
                return sdk_core_1.common.Environments[this.bitgo.getEnv()].tronNodes.solidity;
            default:
                throw new Error('node type not found');
        }
    }
    /**
     * Make a query to Trongrid for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @returns {Object} response from Trongrid
     */
    async recoveryPost(query) {
        const nodeUri = this.getNodeUrl(query.node);
        const response = await request
            .post(nodeUri + query.path)
            .type('json')
            .send(query.jsonObj);
        if (!response.ok) {
            throw new Error('could not reach Tron node');
        }
        // unfortunately, it doesn't look like most TRON nodes return valid json as body
        return JSON.parse(response.text);
    }
    /**
     * Make a query to Trongrid for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @returns {Object} response from Trongrid
     */
    async recoveryGet(query) {
        const nodeUri = this.getNodeUrl(query.node);
        const response = await request
            .get(nodeUri + query.path)
            .type('json')
            .send(query.jsonObj);
        if (!response.ok) {
            throw new Error('could not reach Tron node');
        }
        // unfortunately, it doesn't look like most TRON nodes return valid json as body
        return JSON.parse(response.text);
    }
    /**
     * Query our explorer for the balance of an address
     * @param address {String} the address encoded in hex
     * @returns {BigNumber} address balance
     */
    async getAccountBalancesFromNode(address) {
        return await this.recoveryGet({
            path: '/v1/accounts/' + address,
            jsonObj: {},
            node: NodeTypes.Full,
        });
    }
    /**
     * Retrieves our build transaction from a node.
     * @param toAddr hex-encoded address
     * @param fromAddr hex-encoded address
     * @param amount
     */
    async getBuildTransaction(toAddr, fromAddr, amount) {
        // our addresses should be base58, we'll have to encode to hex
        return await this.recoveryPost({
            path: '/wallet/createtransaction',
            jsonObj: {
                to_address: toAddr,
                owner_address: fromAddr,
                amount,
            },
            node: NodeTypes.Full,
        });
    }
    /**
     * Retrieves our build transaction from a node.
     * @param toAddr hex-encoded address
     * @param fromAddr hex-encoded address
     * @param amount
     */
    async getTriggerSmartContractTransaction(toAddr, fromAddr, amount, contractAddr) {
        const functionSelector = 'transfer(address,uint256)';
        const types = ['address', 'uint256'];
        const values = [toAddr, amount];
        const parameter = lib_1.Utils.encodeDataParams(types, values, '');
        return await this.recoveryPost({
            path: '/wallet/triggersmartcontract',
            jsonObj: {
                owner_address: fromAddr,
                contract_address: contractAddr,
                function_selector: functionSelector,
                parameter: parameter,
                fee_limit: 100000000,
            },
            node: NodeTypes.Full,
        });
    }
    /**
     * Throws an error if any keys in the ownerKeys collection don't match the keys array we pass
     * @param ownerKeys
     * @param keys
     */
    checkPermissions(ownerKeys, keys) {
        keys = keys.map((k) => k.toUpperCase());
        ownerKeys.map((key) => {
            const hexKey = key.address.toUpperCase();
            if (!keys.includes(hexKey)) {
                throw new Error(`pub address ${hexKey} not found in account`);
            }
            if (key.weight !== 1) {
                throw new Error('owner permission is invalid for this structure');
            }
        });
    }
    /**
     * Format for offline vault signing
     * @param {BaseTransaction} tx
     * @param {number} fee
     * @param {number} recoveryAmount
     * @returns {RecoveryTransaction}
     */
    formatForOfflineVault(tx, fee, recoveryAmount, addressInfo) {
        const txJSON = tx.toJson();
        const format = {
            txHex: JSON.stringify(txJSON),
            recoveryAmount,
            feeInfo: {
                fee: `${fee}`,
            },
            tx: txJSON,
            coin: this.getChain(),
        };
        return addressInfo ? { ...format, addressInfo } : format;
    }
    /**
     * Builds a funds recovery transaction without BitGo.
     * We need to do three queries during this:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     *
     * Note 1: for base address recoveries, fund will be recovered to recovery destination if base address balance is
     * more than 2.1 TRX for native TRX recovery and 100 TRX for token recover. For receive addresses, fund will be
     * recovered to base address first then swept to base address(decided as the universal pattern in team meeting).
     *
     * Note 2: the function supports token sweep from base address.
     * TODO: support token sweep from receive address.
     *
     * @param params
     */
    async recover(params) {
        const isKrsRecovery = (0, sdk_core_1.getIsKrsRecovery)(params);
        const isUnsignedSweep = (0, sdk_core_1.getIsUnsignedSweep)(params);
        if (!this.isValidAddress(params.recoveryDestination)) {
            throw new Error('Invalid destination address!');
        }
        let startIdx = params.startingScanIndex;
        if ((0, lodash_1.isUndefined)(startIdx)) {
            startIdx = 1;
        }
        else if (!(0, lodash_1.isInteger)(startIdx) || startIdx < 0) {
            throw new Error('Invalid starting index to scan for addresses');
        }
        let numIteration = params.scan;
        if ((0, lodash_1.isUndefined)(numIteration)) {
            numIteration = 20;
        }
        else if (!(0, lodash_1.isInteger)(numIteration) || numIteration <= 0) {
            throw new Error('Invalid scanning factor');
        }
        // get our user, backup keys
        const keys = (0, sdk_core_1.getBip32Keys)(this.bitgo, params, { requireBitGoXpub: false });
        // we need to decode our bitgoKey to a base58 address
        const bitgoHexAddr = this.pubToHexAddress(this.xpubToUncompressedPub(params.bitgoKey));
        let recoveryFromAddrHex = bitgoHexAddr;
        let recoveryToAddressHex = lib_1.Utils.getHexAddressFromBase58Address(params.recoveryDestination);
        // call the node to get our account balance for base address
        let account = await this.getAccountBalancesFromNode(lib_1.Utils.getBase58AddressFromHex(recoveryFromAddrHex));
        let recoveryAmount = account.data[0].balance;
        let userXPrv = keys[0].toBase58();
        let isReceiveAddress = false;
        let addressInfo;
        const tokenContractAddr = params.tokenContractAddress;
        // check for possible token recovery, recover the token provide by user
        if (tokenContractAddr) {
            let rawTokenTxn;
            for (const token of account.data[0].trc20) {
                if (token[tokenContractAddr]) {
                    const amount = token[tokenContractAddr];
                    const tokenContractAddrHex = lib_1.Utils.getHexAddressFromBase58Address(tokenContractAddr);
                    rawTokenTxn = (await this.getTriggerSmartContractTransaction(recoveryToAddressHex, recoveryFromAddrHex, amount, tokenContractAddrHex)).transaction;
                    recoveryAmount = parseInt(amount, 10);
                    break;
                }
            }
            // build and sign token txns
            if (rawTokenTxn) {
                // Check there is sufficient of the native asset to cover fees
                const trxBalance = account.data[0].balance;
                if (trxBalance < exports.SAFE_TRON_TOKEN_TRANSACTION_FEE) {
                    throw new Error(`Amount of funds to recover ${trxBalance} is less than ${exports.SAFE_TRON_TOKEN_TRANSACTION_FEE} and wouldn't be able to fund a trc20 send`);
                }
                const txBuilder = (0, builder_1.getBuilder)(this.getChain()).from(rawTokenTxn);
                // Default expiry is 1 minute which is too short for recovery purposes
                // extend the expiry to 1 day
                txBuilder.extendValidTo(exports.RECOVER_TRANSACTION_EXPIRY);
                // this tx should be enough to drop into a node
                if (isUnsignedSweep) {
                    return this.formatForOfflineVault(await txBuilder.build(), exports.SAFE_TRON_TOKEN_TRANSACTION_FEE, recoveryAmount);
                }
                const userPrv = this.xprvToCompressedPrv(userXPrv);
                txBuilder.sign({ key: userPrv });
                // krs recoveries don't get signed
                if (!isKrsRecovery && !isReceiveAddress) {
                    const backupXPrv = keys[1].toBase58();
                    const backupPrv = this.xprvToCompressedPrv(backupXPrv);
                    txBuilder.sign({ key: backupPrv });
                }
                return this.formatForOfflineVault(await txBuilder.build(), exports.SAFE_TRON_TOKEN_TRANSACTION_FEE, recoveryAmount);
            }
            else {
                throw Error('Not found token to recover, please check token balance');
            }
        }
        // let us recover the native Tron
        if (recoveryAmount > exports.SAFE_TRON_TRANSACTION_FEE) {
            const userXPub = keys[0].neutered().toBase58();
            const backupXPub = keys[1].neutered().toBase58();
            // check multisig permissions
            const keyHexAddresses = [
                this.pubToHexAddress(this.xpubToUncompressedPub(userXPub)),
                this.pubToHexAddress(this.xpubToUncompressedPub(backupXPub)),
                bitgoHexAddr,
            ];
            // run checks to ensure this is a valid tx - permissions match our signer keys
            const ownerKeys = [];
            for (const key of account.data[0].owner_permission.keys) {
                const address = lib_1.Utils.getHexAddressFromBase58Address(key.address);
                const weight = key.weight;
                ownerKeys.push({ address, weight });
            }
            const activePermissionKeys = [];
            for (const key of account.data[0].active_permission[0].keys) {
                const address = lib_1.Utils.getHexAddressFromBase58Address(key.address);
                const weight = key.weight;
                activePermissionKeys.push({ address, weight });
            }
            this.checkPermissions(ownerKeys, keyHexAddresses);
            this.checkPermissions(activePermissionKeys, keyHexAddresses);
        }
        else {
            // Check receive addresses for funds
            // Check for first derived wallet with funds
            // Receive addresses are derived from the user key
            for (let i = startIdx; i < numIteration + startIdx; i++) {
                const derivationPath = `0/0/0/${i}`;
                const userKey = keys[0].derivePath(derivationPath);
                const xpub = userKey.neutered();
                const receiveAddress = this.pubToHexAddress(this.xpubToUncompressedPub(xpub.toBase58()));
                const address = lib_1.Utils.getBase58AddressFromHex(receiveAddress);
                // call the node to get our account balance
                const accountInfo = await this.getAccountBalancesFromNode(address);
                if (accountInfo.data[0] && accountInfo.data[0].balance > exports.SAFE_TRON_TRANSACTION_FEE) {
                    account = accountInfo;
                    recoveryAmount = accountInfo.data[0].balance;
                    userXPrv = userKey.toBase58(); // assign derived userXPrx
                    isReceiveAddress = true;
                    recoveryFromAddrHex = receiveAddress;
                    recoveryToAddressHex = bitgoHexAddr;
                    addressInfo = {
                        address,
                        chain: 0,
                        index: i,
                    };
                    break;
                }
            }
        }
        // a sweep potentially needs to pay for multi-sig transfer, destination account activation and bandwidth
        // TRON foundation recommends 2.1 TRX for guaranteed confirmation
        if (!recoveryAmount || exports.SAFE_TRON_TRANSACTION_FEE >= recoveryAmount) {
            throw new Error(`Amount of funds to recover ${recoveryAmount} is less than ${exports.SAFE_TRON_TRANSACTION_FEE} and wouldn't be able to fund a send`);
        }
        const recoveryAmountMinusFees = recoveryAmount - exports.SAFE_TRON_TRANSACTION_FEE;
        const buildTx = await this.getBuildTransaction(recoveryToAddressHex, recoveryFromAddrHex, recoveryAmountMinusFees);
        // construct our tx
        const txBuilder = (0, builder_1.getBuilder)(this.getChain()).from(buildTx);
        // Default expiry is 1 minute which is too short for recovery purposes
        // extend the expiry to 1 day
        txBuilder.extendValidTo(exports.RECOVER_TRANSACTION_EXPIRY);
        const tx = await txBuilder.build();
        // this tx should be enough to drop into a node
        if (isUnsignedSweep) {
            return this.formatForOfflineVault(tx, exports.SAFE_TRON_TRANSACTION_FEE, recoveryAmountMinusFees, addressInfo);
        }
        const userPrv = this.xprvToCompressedPrv(userXPrv);
        txBuilder.sign({ key: userPrv });
        // krs recoveries don't get signed
        if (!isKrsRecovery && !isReceiveAddress) {
            const backupXPrv = keys[1].toBase58();
            const backupPrv = this.xprvToCompressedPrv(backupXPrv);
            txBuilder.sign({ key: backupPrv });
        }
        const txSigned = await txBuilder.build();
        return this.formatForOfflineVault(txSigned, exports.SAFE_TRON_TRANSACTION_FEE, recoveryAmountMinusFees, addressInfo);
    }
    /**
     * Builds native TRX recoveries of receive addresses in batch without BitGo.
     * Funds will be recovered to base address first. You need to initiate another sweep txn after that.
     * Note: there will be another recoverTokenConsolidations function to support token recover from receive addresses.
     *
     * @param {ConsolidationRecoveryOptions} params - options for consolidation recovery.
     * @param {string} [params.startingScanIndex] - receive address index to start scanning from. default to 1 (inclusive).
     * @param {string} [params.endingScanIndex] - receive address index to end scanning at. default to startingScanIndex + 20 (exclusive).
     */
    async recoverConsolidations(params) {
        const isUnsignedConsolidations = (0, sdk_core_1.getIsUnsignedSweep)(params);
        const startIdx = params.startingScanIndex || 1;
        const endIdx = params.endingScanIndex || startIdx + exports.DEFAULT_SCAN_FACTOR;
        if (startIdx < 1 || endIdx <= startIdx || endIdx - startIdx > 10 * exports.DEFAULT_SCAN_FACTOR) {
            throw new Error(`Invalid starting or ending index to scan for addresses. startingScanIndex: ${startIdx}, endingScanIndex: ${endIdx}.`);
        }
        const keys = (0, sdk_core_1.getBip32Keys)(this.bitgo, params, { requireBitGoXpub: false });
        const baseAddrHex = this.pubToHexAddress(this.xpubToUncompressedPub(params.bitgoKey));
        const txnsBatch = [];
        for (let i = startIdx; i < endIdx; i++) {
            const derivationPath = `0/0/0/${i}`;
            const userKey = keys[0].derivePath(derivationPath);
            const userKeyXPub = userKey.neutered();
            const receiveAddressHex = this.pubToHexAddress(this.xpubToUncompressedPub(userKeyXPub.toBase58()));
            const receiveAddress = lib_1.Utils.getBase58AddressFromHex(receiveAddressHex);
            // call the node to get our account balance
            const accountInfo = await this.getAccountBalancesFromNode(receiveAddress);
            if (accountInfo.data[0] && accountInfo.data[0].balance > exports.SAFE_TRON_TRANSACTION_FEE) {
                let recoveryAmount = 0;
                // Tokens must be consolidate before the native asset. First construct token txns
                let rawTokenTxn;
                // check for possible token recovery, recover the token provide by user
                if (params.tokenContractAddress) {
                    if (accountInfo.data[0].balance > exports.SAFE_TRON_TOKEN_TRANSACTION_FEE && accountInfo.data[0].trc20[0]) {
                        const tokenDataArray = accountInfo.data[0].trc20;
                        for (const tokenData of tokenDataArray) {
                            const contractAddress = Object.keys(tokenData);
                            if (params.tokenContractAddress === contractAddress[0]) {
                                const amount = tokenData[contractAddress[0]];
                                const tokenContractAddrHex = lib_1.Utils.getHexAddressFromBase58Address(contractAddress[0]);
                                rawTokenTxn = (await this.getTriggerSmartContractTransaction(baseAddrHex, receiveAddressHex, amount, tokenContractAddrHex)).transaction;
                                recoveryAmount = parseInt(amount, 10);
                                break;
                            }
                        }
                    }
                    // build and sign token txns
                    if (rawTokenTxn) {
                        const addressInfo = {
                            address: receiveAddress,
                            chain: 0,
                            index: i,
                        };
                        const txBuilder = (0, builder_1.getBuilder)(this.getChain()).from(rawTokenTxn);
                        // Default expiry is 1 minute which is too short for recovery purposes
                        // extend the expiry to 1 day
                        txBuilder.extendValidTo(exports.RECOVER_TRANSACTION_EXPIRY);
                        // this tx should be enough to drop into a node
                        if (!isUnsignedConsolidations) {
                            const userPrv = this.xprvToCompressedPrv(userKey.toBase58());
                            // receive address only needs to be signed by user key
                            txBuilder.sign({ key: userPrv });
                        }
                        const tx = await txBuilder.build();
                        txnsBatch.push(this.formatForOfflineVault(tx, exports.SAFE_TRON_TOKEN_TRANSACTION_FEE, recoveryAmount, addressInfo));
                    }
                }
                else {
                    const addressBalance = accountInfo.data[0].balance;
                    const addressInfo = {
                        address: receiveAddress,
                        chain: 0,
                        index: i,
                    };
                    const recoveryAmount = addressBalance - exports.SAFE_TRON_TRANSACTION_FEE;
                    const buildTx = await this.getBuildTransaction(baseAddrHex, receiveAddressHex, recoveryAmount);
                    // construct our tx
                    const txBuilder = (0, builder_1.getBuilder)(this.getChain()).from(buildTx);
                    // Default expiry is 1 minute which is too short for recovery purposes
                    // extend the expiry to 1 day
                    txBuilder.extendValidTo(exports.RECOVER_TRANSACTION_EXPIRY);
                    if (!isUnsignedConsolidations) {
                        const userPrv = this.xprvToCompressedPrv(userKey.toBase58());
                        // receive address only needs to be signed by user key
                        txBuilder.sign({ key: userPrv });
                    }
                    const tx = await txBuilder.build();
                    txnsBatch.push(this.formatForOfflineVault(tx, exports.SAFE_TRON_TRANSACTION_FEE, recoveryAmount, addressInfo));
                }
            }
        }
        return {
            transactions: txnsBatch,
        };
    }
    /**
     * Explain a Tron transaction from txHex
     * @param params
     */
    async explainTransaction(params) {
        const txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
        if (!txHex || !params.feeInfo) {
            throw new Error('missing explain tx parameters');
        }
        const txBuilder = (0, builder_1.getBuilder)(this.getChain()).from(txHex);
        const tx = await txBuilder.build();
        const outputs = [
            {
                amount: tx.outputs[0].value.toString(),
                address: tx.outputs[0].address, // Should turn it into a readable format, aka base58
            },
        ];
        const displayOrder = [
            'id',
            'outputAmount',
            'changeAmount',
            'outputs',
            'changeOutputs',
            'fee',
            'timestamp',
            'expiration',
        ];
        return {
            displayOrder,
            id: tx.id,
            outputs,
            outputAmount: outputs[0].amount,
            changeOutputs: [],
            changeAmount: '0',
            fee: params.feeInfo,
            timestamp: tx.validFrom,
            expiration: tx.validTo,
        };
    }
}
exports.Trx = Trx;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJ4LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3RyeC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0gscURBQXVDO0FBQ3ZDLG1DQUFxQztBQUVyQyw4Q0FBa0Q7QUFDbEQsb0RBQXNDO0FBQ3RDLDhDQW9CeUI7QUFDekIsK0JBQXlEO0FBQ3pELDJDQUEyQztBQUUzQyxtQ0FBZ0Q7QUFFbkMsUUFBQSxpQ0FBaUMsR0FBRyxHQUFHLENBQUM7QUFDeEMsUUFBQSx5QkFBeUIsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsd0VBQXdFO0FBQy9HLFFBQUEsK0JBQStCLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLHdFQUF3RTtBQUNySCxRQUFBLDBCQUEwQixHQUFHLFFBQVEsQ0FBQyxDQUFDLFVBQVU7QUFDakQsUUFBQSxtQkFBbUIsR0FBRyxFQUFFLENBQUMsQ0FBQyx3REFBd0Q7QUE4RS9GLElBQVksU0FHWDtBQUhELFdBQVksU0FBUztJQUNuQix5Q0FBSSxDQUFBO0lBQ0osaURBQVEsQ0FBQTtBQUNWLENBQUMsRUFIVyxTQUFTLEdBQVQsaUJBQVMsS0FBVCxpQkFBUyxRQUdwQjtBQVNELE1BQWEsR0FBSSxTQUFRLG1CQUFRO0lBRy9CLFlBQVksS0FBZ0IsRUFBRSxXQUF1QztRQUNuRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFYixJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztTQUN2RTtRQUVELElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO0lBQ2xDLENBQUM7SUFFRCxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQztJQUNoQyxDQUFDO0lBRUQsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUM7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QU0sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUU7Z0JBQ3RDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxvREFBb0Q7YUFDckY7U0FDRixDQUFDO1FBRUYsTUFBTSxZQUFZLEdBQUc7WUFDbkIsSUFBSTtZQUNKLGNBQWM7WUFDZCxjQUFjO1lBQ2QsU0FBUztZQUNULGVBQWU7WUFDZixLQUFLO1lBQ0wsV0FBVztZQUNYLFlBQVk7U0FDYixDQUFDO1FBRUYsT0FBTztZQUNMLFlBQVk7WUFDWixFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUU7WUFDVCxPQUFPO1lBQ1AsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNO1lBQy9CLGFBQWEsRUFBRSxFQUFFO1lBQ2pCLFlBQVksRUFBRSxHQUFHO1lBQ2pCLEdBQUcsRUFBRSxNQUFNLENBQUMsT0FBTztZQUNuQixTQUFTLEVBQUUsRUFBRSxDQUFDLFNBQVM7WUFDdkIsVUFBVSxFQUFFLEVBQUUsQ0FBQyxPQUFPO1NBQ3ZCLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUE1d0JELGtCQTR3QkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgKiBhcyBzZWNwMjU2azEgZnJvbSAnc2VjcDI1NmsxJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IENvaW5GYW1pbHksIEJhc2VDb2luIGFzIFN0YXRpY3NCYXNlQ29pbiB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IGJpcDMyLCBuZXR3b3JrcyB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgKiBhcyByZXF1ZXN0IGZyb20gJ3N1cGVyYWdlbnQnO1xuaW1wb3J0IHtcbiAgQmFzZUNvaW4sXG4gIEJpdEdvQmFzZSxcbiAgY29tbW9uLFxuICBnZXRCaXAzMktleXMsXG4gIGdldElzS3JzUmVjb3ZlcnksXG4gIGdldElzVW5zaWduZWRTd2VlcCxcbiAgS2V5UGFpcixcbiAgTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvcixcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBTaWduZWRUcmFuc2FjdGlvbixcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbixcbiAgVHJhbnNhY3Rpb25GZWUsXG4gIFRyYW5zYWN0aW9uUHJlYnVpbGQgYXMgQmFzZVRyYW5zYWN0aW9uUHJlYnVpbGQsXG4gIFRyYW5zYWN0aW9uUmVjaXBpZW50IGFzIFJlY2lwaWVudCxcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgQmFzZVRyYW5zYWN0aW9uLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgSW50ZXJmYWNlLCBVdGlscywgV3JhcHBlZEJ1aWxkZXIgfSBmcm9tICcuL2xpYic7XG5pbXBvcnQgeyBnZXRCdWlsZGVyIH0gZnJvbSAnLi9saWIvYnVpbGRlcic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblJlY2VpcHQgfSBmcm9tICcuL2xpYi9pZmFjZSc7XG5pbXBvcnQgeyBpc0ludGVnZXIsIGlzVW5kZWZpbmVkIH0gZnJvbSAnbG9kYXNoJztcblxuZXhwb3J0IGNvbnN0IE1JTklNVU1fVFJPTl9NU0lHX1RSQU5TQUNUSU9OX0ZFRSA9IDFlNjtcbmV4cG9ydCBjb25zdCBTQUZFX1RST05fVFJBTlNBQ1RJT05fRkVFID0gMi4xICogMWU2OyAvLyBUUk9OIGZvdW5kYXRpb24gcmVjb21tZW5kcyAyLjEgVFJYIGFzIGZlZXMgZm9yIGd1YXJhbnRlZWQgdHJhbnNhY3Rpb25cbmV4cG9ydCBjb25zdCBTQUZFX1RST05fVE9LRU5fVFJBTlNBQ1RJT05fRkVFID0gMTAwICogMWU2OyAvLyBUUk9OIGZvdW5kYXRpb24gcmVjb21tZW5kcyAxMDAgVFJYIGFzIGZlZXMgZm9yIGd1YXJhbnRlZWQgdHJhbnNhY3Rpb25cbmV4cG9ydCBjb25zdCBSRUNPVkVSX1RSQU5TQUNUSU9OX0VYUElSWSA9IDg2NDAwMDAwOyAvLyAyNCBob3VyXG5leHBvcnQgY29uc3QgREVGQVVMVF9TQ0FOX0ZBQ1RPUiA9IDIwOyAvLyBkZWZhdWx0IG51bWJlciBvZiByZWNlaXZlIGFkZHJlc3NlcyB0byBzY2FuIGZvciBmdW5kc1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyb25TaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHBydjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFR4SW5mbyB7XG4gIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xuICBmcm9tOiBzdHJpbmc7XG4gIHR4aWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBZGRyZXNzSW5mbyB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgY2hhaW46IG51bWJlcjtcbiAgaW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcm9uVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiBleHRlbmRzIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24ge1xuICBleHBpcmF0aW9uOiBudW1iZXI7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHR4SGV4OiBzdHJpbmc7XG4gIHR4SW5mbzogVHhJbmZvO1xuICBhZGRyZXNzSW5mbz86IEFkZHJlc3NJbmZvO1xuICBmZWVJbmZvOiBUcmFuc2FjdGlvbkZlZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhIZXg/OiBzdHJpbmc7IC8vIHR4SGV4IGlzIHBvb3JseSBuYW1lZCBoZXJlOyBpdCBpcyBqdXN0IGEgd3JhcHBlZCBKU09OIG9iamVjdFxuICBoYWxmU2lnbmVkPzoge1xuICAgIHR4SGV4OiBzdHJpbmc7IC8vIHR4SGV4IGlzIHBvb3JseSBuYW1lZCBoZXJlOyBpdCBpcyBqdXN0IGEgd3JhcHBlZCBKU09OIG9iamVjdFxuICB9O1xuICBmZWVJbmZvOiBUcmFuc2FjdGlvbkZlZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyeU9wdGlvbnMge1xuICB1c2VyS2V5OiBzdHJpbmc7IC8vIEJveCBBXG4gIGJhY2t1cEtleTogc3RyaW5nOyAvLyBCb3ggQlxuICBiaXRnb0tleTogc3RyaW5nOyAvLyBCb3ggQyAtIHRoaXMgaXMgYml0Z28ncyB4cHViIGFuZCB3aWxsIGJlIHVzZWQgdG8gZGVyaXZlIHRoZWlyIHJvb3QgYWRkcmVzc1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7IC8vIGJhc2U1OCBhZGRyZXNzXG4gIGtyc1Byb3ZpZGVyPzogc3RyaW5nO1xuICB0b2tlbkNvbnRyYWN0QWRkcmVzcz86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgc3RhcnRpbmdTY2FuSW5kZXg/OiBudW1iZXI7XG4gIHNjYW4/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29uc29saWRhdGlvblJlY292ZXJ5T3B0aW9ucyB7XG4gIHVzZXJLZXk6IHN0cmluZztcbiAgYmFja3VwS2V5OiBzdHJpbmc7XG4gIGJpdGdvS2V5OiBzdHJpbmc7XG4gIHRva2VuQ29udHJhY3RBZGRyZXNzPzogc3RyaW5nO1xuICBzdGFydGluZ1NjYW5JbmRleD86IG51bWJlcjsgLy8gZGVmYXVsdCB0byAxIChpbmNsdXNpdmUpXG4gIGVuZGluZ1NjYW5JbmRleD86IG51bWJlcjsgLy8gZGVmYXVsdCB0byBzdGFydGluZ1NjYW5JbmRleCArIDIwIChleGNsdXNpdmUpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29uc29saWRhdGlvblJlY292ZXJ5QmF0Y2gge1xuICB0cmFuc2FjdGlvbnM6IFJlY292ZXJ5VHJhbnNhY3Rpb25bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGZWVJbmZvIHtcbiAgZmVlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjb3ZlcnlUcmFuc2FjdGlvbiB7XG4gIHR4SGV4Pzogc3RyaW5nO1xuICBmZWVJbmZvPzogRmVlSW5mbztcbiAgY29pbj86IHN0cmluZztcbiAgdHg/OiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICByZWNvdmVyeUFtb3VudD86IG51bWJlcjtcbiAgdG9rZW5UeHM/OiBUcmFuc2FjdGlvblJlY2VpcHRbXTtcbiAgYWRkcmVzc0luZm8/OiBBZGRyZXNzSW5mbztcbn1cblxuZXhwb3J0IGVudW0gTm9kZVR5cGVzIHtcbiAgRnVsbCxcbiAgU29saWRpdHksXG59XG5cbi8qKlxuICogVGhpcyBzdHJ1Y3R1cmUgaXMgbm90IGEgY29tcGxldGUgbW9kZWwgb2YgdGhlIEFjY291bnRSZXNwb25zZSBmcm9tIGEgbm9kZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY2NvdW50UmVzcG9uc2Uge1xuICBkYXRhOiBbSW50ZXJmYWNlLkFjY291bnRJbmZvXTtcbn1cblxuZXhwb3J0IGNsYXNzIFRyeCBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9zdGF0aWNzQ29pbjogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPjtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pIHtcbiAgICBzdXBlcihiaXRnbyk7XG5cbiAgICBpZiAoIXN0YXRpY3NDb2luKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgY29uc3RydWN0b3IgcGFyYW1ldGVyIHN0YXRpY3NDb2luJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGljc0NvaW4gPSBzdGF0aWNzQ29pbjtcbiAgfVxuXG4gIGdldENoYWluKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5uYW1lO1xuICB9XG5cbiAgZ2V0RmFtaWx5KCk6IENvaW5GYW1pbHkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5mYW1pbHk7XG4gIH1cblxuICBnZXRGdWxsTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZnVsbE5hbWU7XG4gIH1cblxuICBnZXRCYXNlRmFjdG9yKCkge1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhdGljc0NvaW4uZGVjaW1hbFBsYWNlcyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdHJhbnNhY3Rpb25EYXRhQWxsb3dlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R29CYXNlLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBUcngoYml0Z28sIHN0YXRpY3NDb2luKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBzZW5kaW5nIHZhbHVlIG9mIDBcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIDAgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGFsbG93c0FjY291bnRDb25zb2xpZGF0aW9ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBpcyBhIHZhbGlkIGJhc2U1OCBvciBoZXggYWRkcmVzc1xuICAgKiBAcGFyYW0gYWRkcmVzc1xuICAgKi9cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZEhleEFkZHJlc3MoYWRkcmVzcykgfHwgVXRpbHMuaXNCYXNlNThBZGRyZXNzKGFkZHJlc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGlzIGEgdmFsaWQgaGV4IGFkZHJlc3NcbiAgICogQHBhcmFtIGFkZHJlc3MgaGV4IGFkZHJlc3NcbiAgICovXG4gIGlzVmFsaWRIZXhBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAvXjQxWzAtOWEtZl17NDB9JC9pLnRlc3QoYWRkcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgZWQyNTUxOSBrZXkgcGFpclxuICAgKlxuICAgKiBAcGFyYW0gc2VlZFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2l0aCBnZW5lcmF0ZWQgcHViLCBwcnZcbiAgICovXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkPzogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgLy8gVE9ETzogbW92ZSB0aGlzIGFuZCBhZGRyZXNzIGNyZWF0aW9uIGxvZ2ljIHRvIGFjY291bnQtbGliXG4gICAgaWYgKCFzZWVkKSB7XG4gICAgICAvLyBBbiBleHRlbmRlZCBwcml2YXRlIGtleSBoYXMgYm90aCBhIG5vcm1hbCAyNTYgYml0IHByaXZhdGUga2V5IGFuZCBhIDI1NiBiaXQgY2hhaW4gY29kZSwgYm90aCBvZiB3aGljaCBtdXN0IGJlXG4gICAgICAvLyByYW5kb20uIDUxMiBiaXRzIGlzIHRoZXJlZm9yZSB0aGUgbWF4aW11bSBlbnRyb3B5IGFuZCBnaXZlcyB1cyBtYXhpbXVtIHNlY3VyaXR5IGFnYWluc3QgY3JhY2tpbmcuXG4gICAgICBzZWVkID0gcmFuZG9tQnl0ZXMoNTEyIC8gOCk7XG4gICAgfVxuICAgIGNvbnN0IGhkID0gYmlwMzIuZnJvbVNlZWQoc2VlZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YjogaGQubmV1dGVyZWQoKS50b0Jhc2U1OCgpLFxuICAgICAgcHJ2OiBoZC50b0Jhc2U1OCgpLFxuICAgIH07XG4gIH1cblxuICBpc1ZhbGlkWHB1Yih4cHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJpcDMyLmZyb21CYXNlNTgoeHB1YikuaXNOZXV0ZXJlZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZFhwdWIocHViKSkge1xuICAgICAgLy8geHB1YnMgY2FuIGJlIGNvbnZlcnRlZCBpbnRvIHJlZ3VsYXIgcHVicywgc28gdGVjaG5pY2FsbHkgaXQgaXMgYSB2YWxpZCBwdWJcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXjA0W2EtekEtWjAtOV17MTI4fSQnKS50ZXN0KHB1Yik7XG4gIH1cblxuICBhc3luYyBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgYXN5bmMgaXNXYWxsZXRBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0aHJvdyBuZXcgTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvcigpO1xuICB9XG5cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJpdmUgYSB1c2VyIGtleSB1c2luZyB0aGUgY2hhaW4gcGF0aCBvZiB0aGUgYWRkcmVzc1xuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGRlcml2ZWQgcHJpdmF0ZSBrZXlcbiAgICovXG4gIGRlcml2ZUtleVdpdGhQYXRoKHsga2V5LCBwYXRoIH06IHsga2V5OiBzdHJpbmc7IHBhdGg6IHN0cmluZyB9KTogc3RyaW5nIHtcbiAgICBjb25zdCBrZXljaGFpbiA9IGJpcDMyLmZyb21CYXNlNTgoa2V5KTtcbiAgICBjb25zdCBkZXJpdmVkS2V5Tm9kZSA9IGtleWNoYWluLmRlcml2ZVBhdGgocGF0aCk7XG4gICAgcmV0dXJuIGRlcml2ZWRLZXlOb2RlLnRvQmFzZTU4KCk7XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZCB7T2JqZWN0fSBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgcGxhdGZvcm1cbiAgICogQHBhcmFtIHBhcmFtcy5wcnYge1N0cmluZ30gdXNlciBwcnZcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXQuYWRkcmVzc1ZlcnNpb24ge1N0cmluZ30gdGhpcyBpcyB0aGUgdmVyc2lvbiBvZiB0aGUgQWxnb3JhbmQgbXVsdGlzaWcgYWRkcmVzcyBnZW5lcmF0aW9uIGZvcm1hdFxuICAgKiBAcmV0dXJucyBCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj5cbiAgICovXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFRyb25TaWduVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHR4QnVpbGRlciA9IGdldEJ1aWxkZXIodGhpcy5nZXRDaGFpbigpKS5mcm9tKHBhcmFtcy50eFByZWJ1aWxkLnR4SGV4KTtcblxuICAgIGxldCBrZXk7XG4gICAgY29uc3QgeyBjaGFpbiwgaW5kZXggfSA9IHBhcmFtcy50eFByZWJ1aWxkPy5hZGRyZXNzSW5mbyA/PyB7IGNoYWluOiAwLCBpbmRleDogMCB9O1xuICAgIGlmIChjaGFpbiA9PT0gMCAmJiBpbmRleCA9PT0gMCkge1xuICAgICAga2V5ID0gcGFyYW1zLnBydjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGVyaXZhdGlvblBhdGggPSBgMC8wLyR7Y2hhaW59LyR7aW5kZXh9YDtcbiAgICAgIGtleSA9IHRoaXMuZGVyaXZlS2V5V2l0aFBhdGgoeyBrZXk6IHBhcmFtcy5wcnYsIHBhdGg6IGRlcml2YXRpb25QYXRoIH0pO1xuICAgIH1cbiAgICB0eEJ1aWxkZXIuc2lnbih7IGtleSB9KTtcblxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICB0eEhleDogSlNPTi5zdHJpbmdpZnkodHJhbnNhY3Rpb24udG9Kc29uKCkpLFxuICAgIH07XG4gICAgaWYgKHRyYW5zYWN0aW9uLnRvSnNvbigpLnNpZ25hdHVyZS5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvLyBIYWxmIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgIHJldHVybiB7XG4gICAgICBoYWxmU2lnbmVkOiByZXNwb25zZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBzZWVkIGZvciB0aGUgY29pblxuICAgKlxuICAgKiBAcGFyYW0gcHJ2IC0gdGhlIHBydiB0byBiZSBjaGVja2VkXG4gICAqL1xuICBpc1ZhbGlkWHBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gIWJpcDMyLmZyb21CYXNlNTgocHJ2KS5pc05ldXRlcmVkKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBtZXNzYWdlIHRvIHN0cmluZyBpbiBoZXhhZGVjaW1hbCBmb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSBtZXNzYWdlIHtCdWZmZXJ8U3RyaW5nfSBtZXNzYWdlIHRvIHNpZ25cbiAgICogQHJldHVybiB0aGUgbWVzc2FnZSBhcyBhIGhleGFkZWNpbWFsIHN0cmluZ1xuICAgKi9cbiAgdG9IZXhTdHJpbmcobWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyKTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20obWVzc2FnZSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZS50b1N0cmluZygnaGV4Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlZCBwYXNzZWQgdG8gc2lnbk1lc3NhZ2UnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBtZXNzYWdlIHdpdGggcHJpdmF0ZSBrZXlcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKi9cbiAgYXN5bmMgc2lnbk1lc3NhZ2Uoa2V5OiBLZXlQYWlyLCBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGNvbnN0IHRvU2lnbiA9IHRoaXMudG9IZXhTdHJpbmcobWVzc2FnZSk7XG5cbiAgICBsZXQgcHJ2OiBzdHJpbmcgfCB1bmRlZmluZWQgPSBrZXkucHJ2O1xuICAgIGlmICh0aGlzLmlzVmFsaWRYcHJ2KHBydikpIHtcbiAgICAgIHBydiA9IGJpcDMyLmZyb21CYXNlNTgocHJ2KS5wcml2YXRlS2V5Py50b1N0cmluZygnaGV4Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFwcnYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gcHJpdmF0ZUtleScpO1xuICAgIH1cbiAgICBsZXQgc2lnID0gVXRpbHMuc2lnblN0cmluZyh0b1NpZ24sIHBydiwgdHJ1ZSk7XG5cbiAgICAvLyByZW1vdmUgdGhlIHByZWNlZGluZyAweFxuICAgIHNpZyA9IHNpZy5yZXBsYWNlKC9eMHgvLCAnJyk7XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2lnLCAnaGV4Jyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4geHB1YiB0byBhIHVuY29tcHJlc3NlZCBwdWJcbiAgICogQHBhcmFtIHhwdWJcbiAgICovXG4gIHhwdWJUb1VuY29tcHJlc3NlZFB1Yih4cHViOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkWHB1Yih4cHViKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHhwdWInKTtcbiAgICB9XG5cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBiaXAzMi5mcm9tQmFzZTU4KHhwdWIsIG5ldHdvcmtzLmJpdGNvaW4pLnB1YmxpY0tleTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHVibGljS2V5LCBmYWxzZSAvKiBjb21wcmVzc2VkICovKSkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmeSBwcmVidWlsZCBiZWZvcmUgc2VuZGluZyBpdCB0byB0aGUgc2VydmVyLlxuICAgKiBAcGFyYW0gYnVpbGRQYXJhbXMgVGhlIHdoaXRlbGlzdGVkIHBhcmFtZXRlcnMgZm9yIHRoaXMgcHJlYnVpbGRcbiAgICovXG4gIGFzeW5jIGdldEV4dHJhUHJlYnVpbGRQYXJhbXMoYnVpbGRQYXJhbXM6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKGJ1aWxkUGFyYW1zLnJlY2lwaWVudHNbMF0uZGF0YSAmJiBidWlsZFBhcmFtcy5mZWVMaW1pdCkge1xuICAgICAgYnVpbGRQYXJhbXMucmVjaXBpZW50c1swXS5mZWVMaW1pdCA9IGJ1aWxkUGFyYW1zLmZlZUxpbWl0O1xuICAgIH1cbiAgfVxuXG4gIHB1YlRvSGV4QWRkcmVzcyhwdWI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgYnl0ZUFycmF5QWRkciA9IFV0aWxzLmdldEJ5dGVBcnJheUZyb21IZXhBZGRyZXNzKHB1Yik7XG4gICAgY29uc3QgcmF3QWRkcmVzcyA9IFV0aWxzLmdldFJhd0FkZHJlc3NGcm9tUHViS2V5KGJ5dGVBcnJheUFkZHIpO1xuICAgIHJldHVybiBVdGlscy5nZXRIZXhBZGRyZXNzRnJvbUJ5dGVBcnJheShyYXdBZGRyZXNzKTtcbiAgfVxuXG4gIHhwcnZUb0NvbXByZXNzZWRQcnYoeHBydjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZFhwcnYoeHBydikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB4cHJ2Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgaGROb2RlID0gYmlwMzIuZnJvbUJhc2U1OCh4cHJ2LCBuZXR3b3Jrcy5iaXRjb2luKTtcbiAgICBpZiAoIWhkTm9kZS5wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHByaXZhdGVLZXknKTtcbiAgICB9XG4gICAgcmV0dXJuIGhkTm9kZS5wcml2YXRlS2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Tm9kZVVybChub2RlOiBOb2RlVHlwZXMpOiBzdHJpbmcge1xuICAgIHN3aXRjaCAobm9kZSkge1xuICAgICAgY2FzZSBOb2RlVHlwZXMuRnVsbDpcbiAgICAgICAgcmV0dXJuIGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5iaXRnby5nZXRFbnYoKV0udHJvbk5vZGVzLmZ1bGw7XG4gICAgICBjYXNlIE5vZGVUeXBlcy5Tb2xpZGl0eTpcbiAgICAgICAgcmV0dXJuIGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5iaXRnby5nZXRFbnYoKV0udHJvbk5vZGVzLnNvbGlkaXR5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub2RlIHR5cGUgbm90IGZvdW5kJyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBNYWtlIGEgcXVlcnkgdG8gVHJvbmdyaWQgZm9yIGluZm9ybWF0aW9uIHN1Y2ggYXMgYmFsYW5jZSwgdG9rZW4gYmFsYW5jZSwgc29saWRpdHkgY2FsbHNcbiAgICogQHBhcmFtIHF1ZXJ5IHtPYmplY3R9IGtleS12YWx1ZSBwYWlycyBvZiBwYXJhbWV0ZXJzIHRvIGFwcGVuZCBhZnRlciAvYXBpXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHJlc3BvbnNlIGZyb20gVHJvbmdyaWRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcmVjb3ZlcnlQb3N0KHF1ZXJ5OiB7IHBhdGg6IHN0cmluZzsganNvbk9iajogYW55OyBub2RlOiBOb2RlVHlwZXMgfSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3Qgbm9kZVVyaSA9IHRoaXMuZ2V0Tm9kZVVybChxdWVyeS5ub2RlKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFxuICAgICAgLnBvc3Qobm9kZVVyaSArIHF1ZXJ5LnBhdGgpXG4gICAgICAudHlwZSgnanNvbicpXG4gICAgICAuc2VuZChxdWVyeS5qc29uT2JqKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWNoIFRyb24gbm9kZScpO1xuICAgIH1cblxuICAgIC8vIHVuZm9ydHVuYXRlbHksIGl0IGRvZXNuJ3QgbG9vayBsaWtlIG1vc3QgVFJPTiBub2RlcyByZXR1cm4gdmFsaWQganNvbiBhcyBib2R5XG4gICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2UudGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIHF1ZXJ5IHRvIFRyb25ncmlkIGZvciBpbmZvcm1hdGlvbiBzdWNoIGFzIGJhbGFuY2UsIHRva2VuIGJhbGFuY2UsIHNvbGlkaXR5IGNhbGxzXG4gICAqIEBwYXJhbSBxdWVyeSB7T2JqZWN0fSBrZXktdmFsdWUgcGFpcnMgb2YgcGFyYW1ldGVycyB0byBhcHBlbmQgYWZ0ZXIgL2FwaVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZXNwb25zZSBmcm9tIFRyb25ncmlkXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJlY292ZXJ5R2V0KHF1ZXJ5OiB7IHBhdGg6IHN0cmluZzsganNvbk9iajogYW55OyBub2RlOiBOb2RlVHlwZXMgfSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3Qgbm9kZVVyaSA9IHRoaXMuZ2V0Tm9kZVVybChxdWVyeS5ub2RlKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFxuICAgICAgLmdldChub2RlVXJpICsgcXVlcnkucGF0aClcbiAgICAgIC50eXBlKCdqc29uJylcbiAgICAgIC5zZW5kKHF1ZXJ5Lmpzb25PYmopO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhY2ggVHJvbiBub2RlJyk7XG4gICAgfVxuXG4gICAgLy8gdW5mb3J0dW5hdGVseSwgaXQgZG9lc24ndCBsb29rIGxpa2UgbW9zdCBUUk9OIG5vZGVzIHJldHVybiB2YWxpZCBqc29uIGFzIGJvZHlcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwb25zZS50ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyeSBvdXIgZXhwbG9yZXIgZm9yIHRoZSBiYWxhbmNlIG9mIGFuIGFkZHJlc3NcbiAgICogQHBhcmFtIGFkZHJlc3Mge1N0cmluZ30gdGhlIGFkZHJlc3MgZW5jb2RlZCBpbiBoZXhcbiAgICogQHJldHVybnMge0JpZ051bWJlcn0gYWRkcmVzcyBiYWxhbmNlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldEFjY291bnRCYWxhbmNlc0Zyb21Ob2RlKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8QWNjb3VudFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVjb3ZlcnlHZXQoe1xuICAgICAgcGF0aDogJy92MS9hY2NvdW50cy8nICsgYWRkcmVzcyxcbiAgICAgIGpzb25PYmo6IHt9LFxuICAgICAgbm9kZTogTm9kZVR5cGVzLkZ1bGwsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIG91ciBidWlsZCB0cmFuc2FjdGlvbiBmcm9tIGEgbm9kZS5cbiAgICogQHBhcmFtIHRvQWRkciBoZXgtZW5jb2RlZCBhZGRyZXNzXG4gICAqIEBwYXJhbSBmcm9tQWRkciBoZXgtZW5jb2RlZCBhZGRyZXNzXG4gICAqIEBwYXJhbSBhbW91bnRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZ2V0QnVpbGRUcmFuc2FjdGlvbihcbiAgICB0b0FkZHI6IHN0cmluZyxcbiAgICBmcm9tQWRkcjogc3RyaW5nLFxuICAgIGFtb3VudDogbnVtYmVyXG4gICk6IFByb21pc2U8SW50ZXJmYWNlLlRyYW5zYWN0aW9uUmVjZWlwdD4ge1xuICAgIC8vIG91ciBhZGRyZXNzZXMgc2hvdWxkIGJlIGJhc2U1OCwgd2UnbGwgaGF2ZSB0byBlbmNvZGUgdG8gaGV4XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVjb3ZlcnlQb3N0KHtcbiAgICAgIHBhdGg6ICcvd2FsbGV0L2NyZWF0ZXRyYW5zYWN0aW9uJyxcbiAgICAgIGpzb25PYmo6IHtcbiAgICAgICAgdG9fYWRkcmVzczogdG9BZGRyLFxuICAgICAgICBvd25lcl9hZGRyZXNzOiBmcm9tQWRkcixcbiAgICAgICAgYW1vdW50LFxuICAgICAgfSxcbiAgICAgIG5vZGU6IE5vZGVUeXBlcy5GdWxsLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBvdXIgYnVpbGQgdHJhbnNhY3Rpb24gZnJvbSBhIG5vZGUuXG4gICAqIEBwYXJhbSB0b0FkZHIgaGV4LWVuY29kZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gZnJvbUFkZHIgaGV4LWVuY29kZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gYW1vdW50XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldFRyaWdnZXJTbWFydENvbnRyYWN0VHJhbnNhY3Rpb24oXG4gICAgdG9BZGRyOiBzdHJpbmcsXG4gICAgZnJvbUFkZHI6IHN0cmluZyxcbiAgICBhbW91bnQ6IHN0cmluZyxcbiAgICBjb250cmFjdEFkZHI6IHN0cmluZ1xuICApOiBQcm9taXNlPHsgdHJhbnNhY3Rpb246IEludGVyZmFjZS5UcmFuc2FjdGlvblJlY2VpcHQgfT4ge1xuICAgIGNvbnN0IGZ1bmN0aW9uU2VsZWN0b3IgPSAndHJhbnNmZXIoYWRkcmVzcyx1aW50MjU2KSc7XG4gICAgY29uc3QgdHlwZXMgPSBbJ2FkZHJlc3MnLCAndWludDI1NiddO1xuICAgIGNvbnN0IHZhbHVlcyA9IFt0b0FkZHIsIGFtb3VudF07XG4gICAgY29uc3QgcGFyYW1ldGVyID0gVXRpbHMuZW5jb2RlRGF0YVBhcmFtcyh0eXBlcywgdmFsdWVzLCAnJyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVjb3ZlcnlQb3N0KHtcbiAgICAgIHBhdGg6ICcvd2FsbGV0L3RyaWdnZXJzbWFydGNvbnRyYWN0JyxcbiAgICAgIGpzb25PYmo6IHtcbiAgICAgICAgb3duZXJfYWRkcmVzczogZnJvbUFkZHIsXG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGNvbnRyYWN0QWRkcixcbiAgICAgICAgZnVuY3Rpb25fc2VsZWN0b3I6IGZ1bmN0aW9uU2VsZWN0b3IsXG4gICAgICAgIHBhcmFtZXRlcjogcGFyYW1ldGVyLFxuICAgICAgICBmZWVfbGltaXQ6IDEwMDAwMDAwMCxcbiAgICAgIH0sXG4gICAgICBub2RlOiBOb2RlVHlwZXMuRnVsbCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IGtleXMgaW4gdGhlIG93bmVyS2V5cyBjb2xsZWN0aW9uIGRvbid0IG1hdGNoIHRoZSBrZXlzIGFycmF5IHdlIHBhc3NcbiAgICogQHBhcmFtIG93bmVyS2V5c1xuICAgKiBAcGFyYW0ga2V5c1xuICAgKi9cbiAgY2hlY2tQZXJtaXNzaW9ucyhvd25lcktleXM6IHsgYWRkcmVzczogc3RyaW5nOyB3ZWlnaHQ6IG51bWJlciB9W10sIGtleXM6IHN0cmluZ1tdKSB7XG4gICAga2V5cyA9IGtleXMubWFwKChrKSA9PiBrLnRvVXBwZXJDYXNlKCkpO1xuXG4gICAgb3duZXJLZXlzLm1hcCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBoZXhLZXkgPSBrZXkuYWRkcmVzcy50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKCFrZXlzLmluY2x1ZGVzKGhleEtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwdWIgYWRkcmVzcyAke2hleEtleX0gbm90IGZvdW5kIGluIGFjY291bnRgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleS53ZWlnaHQgIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvd25lciBwZXJtaXNzaW9uIGlzIGludmFsaWQgZm9yIHRoaXMgc3RydWN0dXJlJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRm9ybWF0IGZvciBvZmZsaW5lIHZhdWx0IHNpZ25pbmdcbiAgICogQHBhcmFtIHtCYXNlVHJhbnNhY3Rpb259IHR4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmZWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlY292ZXJ5QW1vdW50XG4gICAqIEByZXR1cm5zIHtSZWNvdmVyeVRyYW5zYWN0aW9ufVxuICAgKi9cbiAgZm9ybWF0Rm9yT2ZmbGluZVZhdWx0KFxuICAgIHR4OiBCYXNlVHJhbnNhY3Rpb24sXG4gICAgZmVlOiBudW1iZXIsXG4gICAgcmVjb3ZlcnlBbW91bnQ6IG51bWJlcixcbiAgICBhZGRyZXNzSW5mbz86IEFkZHJlc3NJbmZvXG4gICk6IFJlY292ZXJ5VHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0IHR4SlNPTiA9IHR4LnRvSnNvbigpO1xuICAgIGNvbnN0IGZvcm1hdCA9IHtcbiAgICAgIHR4SGV4OiBKU09OLnN0cmluZ2lmeSh0eEpTT04pLFxuICAgICAgcmVjb3ZlcnlBbW91bnQsXG4gICAgICBmZWVJbmZvOiB7XG4gICAgICAgIGZlZTogYCR7ZmVlfWAsXG4gICAgICB9LFxuICAgICAgdHg6IHR4SlNPTiwgLy8gTGVhdmluZyBpdCBhcyB0eEpTT04gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICBjb2luOiB0aGlzLmdldENoYWluKCksXG4gICAgfTtcbiAgICByZXR1cm4gYWRkcmVzc0luZm8gPyB7IC4uLmZvcm1hdCwgYWRkcmVzc0luZm8gfSA6IGZvcm1hdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBmdW5kcyByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRob3V0IEJpdEdvLlxuICAgKiBXZSBuZWVkIHRvIGRvIHRocmVlIHF1ZXJpZXMgZHVyaW5nIHRoaXM6XG4gICAqIDEpIE5vZGUgcXVlcnkgLSBob3cgbXVjaCBtb25leSBpcyBpbiB0aGUgYWNjb3VudFxuICAgKiAyKSBCdWlsZCB0cmFuc2FjdGlvbiAtIGJ1aWxkIG91ciB0cmFuc2FjdGlvbiBmb3IgdGhlIGFtb3VudFxuICAgKiAzKSBTZW5kIHNpZ25lZCBidWlsZCAtIHNlbmQgb3VyIHNpZ25lZCBidWlsZCB0byBhIHB1YmxpYyBub2RlXG4gICAqXG4gICAqIE5vdGUgMTogZm9yIGJhc2UgYWRkcmVzcyByZWNvdmVyaWVzLCBmdW5kIHdpbGwgYmUgcmVjb3ZlcmVkIHRvIHJlY292ZXJ5IGRlc3RpbmF0aW9uIGlmIGJhc2UgYWRkcmVzcyBiYWxhbmNlIGlzXG4gICAqIG1vcmUgdGhhbiAyLjEgVFJYIGZvciBuYXRpdmUgVFJYIHJlY292ZXJ5IGFuZCAxMDAgVFJYIGZvciB0b2tlbiByZWNvdmVyLiBGb3IgcmVjZWl2ZSBhZGRyZXNzZXMsIGZ1bmQgd2lsbCBiZVxuICAgKiByZWNvdmVyZWQgdG8gYmFzZSBhZGRyZXNzIGZpcnN0IHRoZW4gc3dlcHQgdG8gYmFzZSBhZGRyZXNzKGRlY2lkZWQgYXMgdGhlIHVuaXZlcnNhbCBwYXR0ZXJuIGluIHRlYW0gbWVldGluZykuXG4gICAqXG4gICAqIE5vdGUgMjogdGhlIGZ1bmN0aW9uIHN1cHBvcnRzIHRva2VuIHN3ZWVwIGZyb20gYmFzZSBhZGRyZXNzLlxuICAgKiBUT0RPOiBzdXBwb3J0IHRva2VuIHN3ZWVwIGZyb20gcmVjZWl2ZSBhZGRyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyByZWNvdmVyKHBhcmFtczogUmVjb3ZlcnlPcHRpb25zKTogUHJvbWlzZTxSZWNvdmVyeVRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IGdldElzS3JzUmVjb3ZlcnkocGFyYW1zKTtcbiAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBnZXRJc1Vuc2lnbmVkU3dlZXAocGFyYW1zKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkZXN0aW5hdGlvbiBhZGRyZXNzIScpO1xuICAgIH1cblxuICAgIGxldCBzdGFydElkeCA9IHBhcmFtcy5zdGFydGluZ1NjYW5JbmRleDtcbiAgICBpZiAoaXNVbmRlZmluZWQoc3RhcnRJZHgpKSB7XG4gICAgICBzdGFydElkeCA9IDE7XG4gICAgfSBlbHNlIGlmICghaXNJbnRlZ2VyKHN0YXJ0SWR4KSB8fCBzdGFydElkeCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGFydGluZyBpbmRleCB0byBzY2FuIGZvciBhZGRyZXNzZXMnKTtcbiAgICB9XG4gICAgbGV0IG51bUl0ZXJhdGlvbiA9IHBhcmFtcy5zY2FuO1xuICAgIGlmIChpc1VuZGVmaW5lZChudW1JdGVyYXRpb24pKSB7XG4gICAgICBudW1JdGVyYXRpb24gPSAyMDtcbiAgICB9IGVsc2UgaWYgKCFpc0ludGVnZXIobnVtSXRlcmF0aW9uKSB8fCBudW1JdGVyYXRpb24gPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNjYW5uaW5nIGZhY3RvcicpO1xuICAgIH1cblxuICAgIC8vIGdldCBvdXIgdXNlciwgYmFja3VwIGtleXNcbiAgICBjb25zdCBrZXlzID0gZ2V0QmlwMzJLZXlzKHRoaXMuYml0Z28sIHBhcmFtcywgeyByZXF1aXJlQml0R29YcHViOiBmYWxzZSB9KTtcblxuICAgIC8vIHdlIG5lZWQgdG8gZGVjb2RlIG91ciBiaXRnb0tleSB0byBhIGJhc2U1OCBhZGRyZXNzXG4gICAgY29uc3QgYml0Z29IZXhBZGRyID0gdGhpcy5wdWJUb0hleEFkZHJlc3ModGhpcy54cHViVG9VbmNvbXByZXNzZWRQdWIocGFyYW1zLmJpdGdvS2V5KSk7XG4gICAgbGV0IHJlY292ZXJ5RnJvbUFkZHJIZXggPSBiaXRnb0hleEFkZHI7XG4gICAgbGV0IHJlY292ZXJ5VG9BZGRyZXNzSGV4ID0gVXRpbHMuZ2V0SGV4QWRkcmVzc0Zyb21CYXNlNThBZGRyZXNzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKTtcblxuICAgIC8vIGNhbGwgdGhlIG5vZGUgdG8gZ2V0IG91ciBhY2NvdW50IGJhbGFuY2UgZm9yIGJhc2UgYWRkcmVzc1xuICAgIGxldCBhY2NvdW50ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50QmFsYW5jZXNGcm9tTm9kZShVdGlscy5nZXRCYXNlNThBZGRyZXNzRnJvbUhleChyZWNvdmVyeUZyb21BZGRySGV4KSk7XG4gICAgbGV0IHJlY292ZXJ5QW1vdW50ID0gYWNjb3VudC5kYXRhWzBdLmJhbGFuY2U7XG5cbiAgICBsZXQgdXNlclhQcnYgPSBrZXlzWzBdLnRvQmFzZTU4KCk7XG4gICAgbGV0IGlzUmVjZWl2ZUFkZHJlc3MgPSBmYWxzZTtcbiAgICBsZXQgYWRkcmVzc0luZm86IEFkZHJlc3NJbmZvIHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IHRva2VuQ29udHJhY3RBZGRyID0gcGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzO1xuICAgIC8vIGNoZWNrIGZvciBwb3NzaWJsZSB0b2tlbiByZWNvdmVyeSwgcmVjb3ZlciB0aGUgdG9rZW4gcHJvdmlkZSBieSB1c2VyXG4gICAgaWYgKHRva2VuQ29udHJhY3RBZGRyKSB7XG4gICAgICBsZXQgcmF3VG9rZW5UeG46IGFueSB8IHVuZGVmaW5lZDtcbiAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgYWNjb3VudC5kYXRhWzBdLnRyYzIwKSB7XG4gICAgICAgIGlmICh0b2tlblt0b2tlbkNvbnRyYWN0QWRkcl0pIHtcbiAgICAgICAgICBjb25zdCBhbW91bnQgPSB0b2tlblt0b2tlbkNvbnRyYWN0QWRkcl07XG4gICAgICAgICAgY29uc3QgdG9rZW5Db250cmFjdEFkZHJIZXggPSBVdGlscy5nZXRIZXhBZGRyZXNzRnJvbUJhc2U1OEFkZHJlc3ModG9rZW5Db250cmFjdEFkZHIpO1xuICAgICAgICAgIHJhd1Rva2VuVHhuID0gKFxuICAgICAgICAgICAgYXdhaXQgdGhpcy5nZXRUcmlnZ2VyU21hcnRDb250cmFjdFRyYW5zYWN0aW9uKFxuICAgICAgICAgICAgICByZWNvdmVyeVRvQWRkcmVzc0hleCxcbiAgICAgICAgICAgICAgcmVjb3ZlcnlGcm9tQWRkckhleCxcbiAgICAgICAgICAgICAgYW1vdW50LFxuICAgICAgICAgICAgICB0b2tlbkNvbnRyYWN0QWRkckhleFxuICAgICAgICAgICAgKVxuICAgICAgICAgICkudHJhbnNhY3Rpb247XG4gICAgICAgICAgcmVjb3ZlcnlBbW91bnQgPSBwYXJzZUludChhbW91bnQsIDEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBidWlsZCBhbmQgc2lnbiB0b2tlbiB0eG5zXG4gICAgICBpZiAocmF3VG9rZW5UeG4pIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhlcmUgaXMgc3VmZmljaWVudCBvZiB0aGUgbmF0aXZlIGFzc2V0IHRvIGNvdmVyIGZlZXNcbiAgICAgICAgY29uc3QgdHJ4QmFsYW5jZSA9IGFjY291bnQuZGF0YVswXS5iYWxhbmNlO1xuICAgICAgICBpZiAodHJ4QmFsYW5jZSA8IFNBRkVfVFJPTl9UT0tFTl9UUkFOU0FDVElPTl9GRUUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQW1vdW50IG9mIGZ1bmRzIHRvIHJlY292ZXIgJHt0cnhCYWxhbmNlfSBpcyBsZXNzIHRoYW4gJHtTQUZFX1RST05fVE9LRU5fVFJBTlNBQ1RJT05fRkVFfSBhbmQgd291bGRuJ3QgYmUgYWJsZSB0byBmdW5kIGEgdHJjMjAgc2VuZGBcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHhCdWlsZGVyID0gZ2V0QnVpbGRlcih0aGlzLmdldENoYWluKCkpLmZyb20ocmF3VG9rZW5UeG4pO1xuICAgICAgICAvLyBEZWZhdWx0IGV4cGlyeSBpcyAxIG1pbnV0ZSB3aGljaCBpcyB0b28gc2hvcnQgZm9yIHJlY292ZXJ5IHB1cnBvc2VzXG4gICAgICAgIC8vIGV4dGVuZCB0aGUgZXhwaXJ5IHRvIDEgZGF5XG4gICAgICAgIHR4QnVpbGRlci5leHRlbmRWYWxpZFRvKFJFQ09WRVJfVFJBTlNBQ1RJT05fRVhQSVJZKTtcbiAgICAgICAgLy8gdGhpcyB0eCBzaG91bGQgYmUgZW5vdWdoIHRvIGRyb3AgaW50byBhIG5vZGVcbiAgICAgICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdEZvck9mZmxpbmVWYXVsdChhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKSwgU0FGRV9UUk9OX1RPS0VOX1RSQU5TQUNUSU9OX0ZFRSwgcmVjb3ZlcnlBbW91bnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXNlclBydiA9IHRoaXMueHBydlRvQ29tcHJlc3NlZFBydih1c2VyWFBydik7XG5cbiAgICAgICAgdHhCdWlsZGVyLnNpZ24oeyBrZXk6IHVzZXJQcnYgfSk7XG5cbiAgICAgICAgLy8ga3JzIHJlY292ZXJpZXMgZG9uJ3QgZ2V0IHNpZ25lZFxuICAgICAgICBpZiAoIWlzS3JzUmVjb3ZlcnkgJiYgIWlzUmVjZWl2ZUFkZHJlc3MpIHtcbiAgICAgICAgICBjb25zdCBiYWNrdXBYUHJ2ID0ga2V5c1sxXS50b0Jhc2U1OCgpO1xuICAgICAgICAgIGNvbnN0IGJhY2t1cFBydiA9IHRoaXMueHBydlRvQ29tcHJlc3NlZFBydihiYWNrdXBYUHJ2KTtcblxuICAgICAgICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiBiYWNrdXBQcnYgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0Rm9yT2ZmbGluZVZhdWx0KGF3YWl0IHR4QnVpbGRlci5idWlsZCgpLCBTQUZFX1RST05fVE9LRU5fVFJBTlNBQ1RJT05fRkVFLCByZWNvdmVyeUFtb3VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcignTm90IGZvdW5kIHRva2VuIHRvIHJlY292ZXIsIHBsZWFzZSBjaGVjayB0b2tlbiBiYWxhbmNlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGxldCB1cyByZWNvdmVyIHRoZSBuYXRpdmUgVHJvblxuICAgIGlmIChyZWNvdmVyeUFtb3VudCA+IFNBRkVfVFJPTl9UUkFOU0FDVElPTl9GRUUpIHtcbiAgICAgIGNvbnN0IHVzZXJYUHViID0ga2V5c1swXS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCk7XG4gICAgICBjb25zdCBiYWNrdXBYUHViID0ga2V5c1sxXS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCk7XG5cbiAgICAgIC8vIGNoZWNrIG11bHRpc2lnIHBlcm1pc3Npb25zXG4gICAgICBjb25zdCBrZXlIZXhBZGRyZXNzZXMgPSBbXG4gICAgICAgIHRoaXMucHViVG9IZXhBZGRyZXNzKHRoaXMueHB1YlRvVW5jb21wcmVzc2VkUHViKHVzZXJYUHViKSksXG4gICAgICAgIHRoaXMucHViVG9IZXhBZGRyZXNzKHRoaXMueHB1YlRvVW5jb21wcmVzc2VkUHViKGJhY2t1cFhQdWIpKSxcbiAgICAgICAgYml0Z29IZXhBZGRyLFxuICAgICAgXTtcbiAgICAgIC8vIHJ1biBjaGVja3MgdG8gZW5zdXJlIHRoaXMgaXMgYSB2YWxpZCB0eCAtIHBlcm1pc3Npb25zIG1hdGNoIG91ciBzaWduZXIga2V5c1xuICAgICAgY29uc3Qgb3duZXJLZXlzOiB7IGFkZHJlc3M6IHN0cmluZzsgd2VpZ2h0OiBudW1iZXIgfVtdID0gW107XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBhY2NvdW50LmRhdGFbMF0ub3duZXJfcGVybWlzc2lvbi5rZXlzKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBVdGlscy5nZXRIZXhBZGRyZXNzRnJvbUJhc2U1OEFkZHJlc3Moa2V5LmFkZHJlc3MpO1xuICAgICAgICBjb25zdCB3ZWlnaHQgPSBrZXkud2VpZ2h0O1xuICAgICAgICBvd25lcktleXMucHVzaCh7IGFkZHJlc3MsIHdlaWdodCB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdGl2ZVBlcm1pc3Npb25LZXlzOiB7IGFkZHJlc3M6IHN0cmluZzsgd2VpZ2h0OiBudW1iZXIgfVtdID0gW107XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBhY2NvdW50LmRhdGFbMF0uYWN0aXZlX3Blcm1pc3Npb25bMF0ua2V5cykge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gVXRpbHMuZ2V0SGV4QWRkcmVzc0Zyb21CYXNlNThBZGRyZXNzKGtleS5hZGRyZXNzKTtcbiAgICAgICAgY29uc3Qgd2VpZ2h0ID0ga2V5LndlaWdodDtcbiAgICAgICAgYWN0aXZlUGVybWlzc2lvbktleXMucHVzaCh7IGFkZHJlc3MsIHdlaWdodCB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tQZXJtaXNzaW9ucyhvd25lcktleXMsIGtleUhleEFkZHJlc3Nlcyk7XG4gICAgICB0aGlzLmNoZWNrUGVybWlzc2lvbnMoYWN0aXZlUGVybWlzc2lvbktleXMsIGtleUhleEFkZHJlc3Nlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENoZWNrIHJlY2VpdmUgYWRkcmVzc2VzIGZvciBmdW5kc1xuICAgICAgLy8gQ2hlY2sgZm9yIGZpcnN0IGRlcml2ZWQgd2FsbGV0IHdpdGggZnVuZHNcbiAgICAgIC8vIFJlY2VpdmUgYWRkcmVzc2VzIGFyZSBkZXJpdmVkIGZyb20gdGhlIHVzZXIga2V5XG4gICAgICBmb3IgKGxldCBpID0gc3RhcnRJZHg7IGkgPCBudW1JdGVyYXRpb24gKyBzdGFydElkeDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRlcml2YXRpb25QYXRoID0gYDAvMC8wLyR7aX1gO1xuICAgICAgICBjb25zdCB1c2VyS2V5ID0ga2V5c1swXS5kZXJpdmVQYXRoKGRlcml2YXRpb25QYXRoKTtcbiAgICAgICAgY29uc3QgeHB1YiA9IHVzZXJLZXkubmV1dGVyZWQoKTtcbiAgICAgICAgY29uc3QgcmVjZWl2ZUFkZHJlc3MgPSB0aGlzLnB1YlRvSGV4QWRkcmVzcyh0aGlzLnhwdWJUb1VuY29tcHJlc3NlZFB1Yih4cHViLnRvQmFzZTU4KCkpKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IFV0aWxzLmdldEJhc2U1OEFkZHJlc3NGcm9tSGV4KHJlY2VpdmVBZGRyZXNzKTtcbiAgICAgICAgLy8gY2FsbCB0aGUgbm9kZSB0byBnZXQgb3VyIGFjY291bnQgYmFsYW5jZVxuICAgICAgICBjb25zdCBhY2NvdW50SW5mbyA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEJhbGFuY2VzRnJvbU5vZGUoYWRkcmVzcyk7XG5cbiAgICAgICAgaWYgKGFjY291bnRJbmZvLmRhdGFbMF0gJiYgYWNjb3VudEluZm8uZGF0YVswXS5iYWxhbmNlID4gU0FGRV9UUk9OX1RSQU5TQUNUSU9OX0ZFRSkge1xuICAgICAgICAgIGFjY291bnQgPSBhY2NvdW50SW5mbztcbiAgICAgICAgICByZWNvdmVyeUFtb3VudCA9IGFjY291bnRJbmZvLmRhdGFbMF0uYmFsYW5jZTtcbiAgICAgICAgICB1c2VyWFBydiA9IHVzZXJLZXkudG9CYXNlNTgoKTsgLy8gYXNzaWduIGRlcml2ZWQgdXNlclhQcnhcbiAgICAgICAgICBpc1JlY2VpdmVBZGRyZXNzID0gdHJ1ZTtcbiAgICAgICAgICByZWNvdmVyeUZyb21BZGRySGV4ID0gcmVjZWl2ZUFkZHJlc3M7XG4gICAgICAgICAgcmVjb3ZlcnlUb0FkZHJlc3NIZXggPSBiaXRnb0hleEFkZHI7XG4gICAgICAgICAgYWRkcmVzc0luZm8gPSB7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgY2hhaW46IDAsXG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYSBzd2VlcCBwb3RlbnRpYWxseSBuZWVkcyB0byBwYXkgZm9yIG11bHRpLXNpZyB0cmFuc2ZlciwgZGVzdGluYXRpb24gYWNjb3VudCBhY3RpdmF0aW9uIGFuZCBiYW5kd2lkdGhcbiAgICAvLyBUUk9OIGZvdW5kYXRpb24gcmVjb21tZW5kcyAyLjEgVFJYIGZvciBndWFyYW50ZWVkIGNvbmZpcm1hdGlvblxuICAgIGlmICghcmVjb3ZlcnlBbW91bnQgfHwgU0FGRV9UUk9OX1RSQU5TQUNUSU9OX0ZFRSA+PSByZWNvdmVyeUFtb3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQW1vdW50IG9mIGZ1bmRzIHRvIHJlY292ZXIgJHtyZWNvdmVyeUFtb3VudH0gaXMgbGVzcyB0aGFuICR7U0FGRV9UUk9OX1RSQU5TQUNUSU9OX0ZFRX0gYW5kIHdvdWxkbid0IGJlIGFibGUgdG8gZnVuZCBhIHNlbmRgXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHJlY292ZXJ5QW1vdW50TWludXNGZWVzID0gcmVjb3ZlcnlBbW91bnQgLSBTQUZFX1RST05fVFJBTlNBQ1RJT05fRkVFO1xuICAgIGNvbnN0IGJ1aWxkVHggPSBhd2FpdCB0aGlzLmdldEJ1aWxkVHJhbnNhY3Rpb24ocmVjb3ZlcnlUb0FkZHJlc3NIZXgsIHJlY292ZXJ5RnJvbUFkZHJIZXgsIHJlY292ZXJ5QW1vdW50TWludXNGZWVzKTtcblxuICAgIC8vIGNvbnN0cnVjdCBvdXIgdHhcbiAgICBjb25zdCB0eEJ1aWxkZXIgPSAoZ2V0QnVpbGRlcih0aGlzLmdldENoYWluKCkpIGFzIFdyYXBwZWRCdWlsZGVyKS5mcm9tKGJ1aWxkVHgpO1xuICAgIC8vIERlZmF1bHQgZXhwaXJ5IGlzIDEgbWludXRlIHdoaWNoIGlzIHRvbyBzaG9ydCBmb3IgcmVjb3ZlcnkgcHVycG9zZXNcbiAgICAvLyBleHRlbmQgdGhlIGV4cGlyeSB0byAxIGRheVxuICAgIHR4QnVpbGRlci5leHRlbmRWYWxpZFRvKFJFQ09WRVJfVFJBTlNBQ1RJT05fRVhQSVJZKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuXG4gICAgLy8gdGhpcyB0eCBzaG91bGQgYmUgZW5vdWdoIHRvIGRyb3AgaW50byBhIG5vZGVcbiAgICBpZiAoaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXRGb3JPZmZsaW5lVmF1bHQodHgsIFNBRkVfVFJPTl9UUkFOU0FDVElPTl9GRUUsIHJlY292ZXJ5QW1vdW50TWludXNGZWVzLCBhZGRyZXNzSW5mbyk7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlclBydiA9IHRoaXMueHBydlRvQ29tcHJlc3NlZFBydih1c2VyWFBydik7XG5cbiAgICB0eEJ1aWxkZXIuc2lnbih7IGtleTogdXNlclBydiB9KTtcblxuICAgIC8vIGtycyByZWNvdmVyaWVzIGRvbid0IGdldCBzaWduZWRcbiAgICBpZiAoIWlzS3JzUmVjb3ZlcnkgJiYgIWlzUmVjZWl2ZUFkZHJlc3MpIHtcbiAgICAgIGNvbnN0IGJhY2t1cFhQcnYgPSBrZXlzWzFdLnRvQmFzZTU4KCk7XG4gICAgICBjb25zdCBiYWNrdXBQcnYgPSB0aGlzLnhwcnZUb0NvbXByZXNzZWRQcnYoYmFja3VwWFBydik7XG5cbiAgICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiBiYWNrdXBQcnYgfSk7XG4gICAgfVxuICAgIGNvbnN0IHR4U2lnbmVkID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0Rm9yT2ZmbGluZVZhdWx0KHR4U2lnbmVkLCBTQUZFX1RST05fVFJBTlNBQ1RJT05fRkVFLCByZWNvdmVyeUFtb3VudE1pbnVzRmVlcywgYWRkcmVzc0luZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBuYXRpdmUgVFJYIHJlY292ZXJpZXMgb2YgcmVjZWl2ZSBhZGRyZXNzZXMgaW4gYmF0Y2ggd2l0aG91dCBCaXRHby5cbiAgICogRnVuZHMgd2lsbCBiZSByZWNvdmVyZWQgdG8gYmFzZSBhZGRyZXNzIGZpcnN0LiBZb3UgbmVlZCB0byBpbml0aWF0ZSBhbm90aGVyIHN3ZWVwIHR4biBhZnRlciB0aGF0LlxuICAgKiBOb3RlOiB0aGVyZSB3aWxsIGJlIGFub3RoZXIgcmVjb3ZlclRva2VuQ29uc29saWRhdGlvbnMgZnVuY3Rpb24gdG8gc3VwcG9ydCB0b2tlbiByZWNvdmVyIGZyb20gcmVjZWl2ZSBhZGRyZXNzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29uc29saWRhdGlvblJlY292ZXJ5T3B0aW9uc30gcGFyYW1zIC0gb3B0aW9ucyBmb3IgY29uc29saWRhdGlvbiByZWNvdmVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuc3RhcnRpbmdTY2FuSW5kZXhdIC0gcmVjZWl2ZSBhZGRyZXNzIGluZGV4IHRvIHN0YXJ0IHNjYW5uaW5nIGZyb20uIGRlZmF1bHQgdG8gMSAoaW5jbHVzaXZlKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuZW5kaW5nU2NhbkluZGV4XSAtIHJlY2VpdmUgYWRkcmVzcyBpbmRleCB0byBlbmQgc2Nhbm5pbmcgYXQuIGRlZmF1bHQgdG8gc3RhcnRpbmdTY2FuSW5kZXggKyAyMCAoZXhjbHVzaXZlKS5cbiAgICovXG4gIGFzeW5jIHJlY292ZXJDb25zb2xpZGF0aW9ucyhwYXJhbXM6IENvbnNvbGlkYXRpb25SZWNvdmVyeU9wdGlvbnMpOiBQcm9taXNlPENvbnNvbGlkYXRpb25SZWNvdmVyeUJhdGNoPiB7XG4gICAgY29uc3QgaXNVbnNpZ25lZENvbnNvbGlkYXRpb25zID0gZ2V0SXNVbnNpZ25lZFN3ZWVwKHBhcmFtcyk7XG4gICAgY29uc3Qgc3RhcnRJZHggPSBwYXJhbXMuc3RhcnRpbmdTY2FuSW5kZXggfHwgMTtcbiAgICBjb25zdCBlbmRJZHggPSBwYXJhbXMuZW5kaW5nU2NhbkluZGV4IHx8IHN0YXJ0SWR4ICsgREVGQVVMVF9TQ0FOX0ZBQ1RPUjtcblxuICAgIGlmIChzdGFydElkeCA8IDEgfHwgZW5kSWR4IDw9IHN0YXJ0SWR4IHx8IGVuZElkeCAtIHN0YXJ0SWR4ID4gMTAgKiBERUZBVUxUX1NDQU5fRkFDVE9SKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHN0YXJ0aW5nIG9yIGVuZGluZyBpbmRleCB0byBzY2FuIGZvciBhZGRyZXNzZXMuIHN0YXJ0aW5nU2NhbkluZGV4OiAke3N0YXJ0SWR4fSwgZW5kaW5nU2NhbkluZGV4OiAke2VuZElkeH0uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gZ2V0QmlwMzJLZXlzKHRoaXMuYml0Z28sIHBhcmFtcywgeyByZXF1aXJlQml0R29YcHViOiBmYWxzZSB9KTtcbiAgICBjb25zdCBiYXNlQWRkckhleCA9IHRoaXMucHViVG9IZXhBZGRyZXNzKHRoaXMueHB1YlRvVW5jb21wcmVzc2VkUHViKHBhcmFtcy5iaXRnb0tleSkpO1xuXG4gICAgY29uc3QgdHhuc0JhdGNoOiBSZWNvdmVyeVRyYW5zYWN0aW9uW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJZHg7IGkgPCBlbmRJZHg7IGkrKykge1xuICAgICAgY29uc3QgZGVyaXZhdGlvblBhdGggPSBgMC8wLzAvJHtpfWA7XG4gICAgICBjb25zdCB1c2VyS2V5ID0ga2V5c1swXS5kZXJpdmVQYXRoKGRlcml2YXRpb25QYXRoKTtcbiAgICAgIGNvbnN0IHVzZXJLZXlYUHViID0gdXNlcktleS5uZXV0ZXJlZCgpO1xuICAgICAgY29uc3QgcmVjZWl2ZUFkZHJlc3NIZXggPSB0aGlzLnB1YlRvSGV4QWRkcmVzcyh0aGlzLnhwdWJUb1VuY29tcHJlc3NlZFB1Yih1c2VyS2V5WFB1Yi50b0Jhc2U1OCgpKSk7XG4gICAgICBjb25zdCByZWNlaXZlQWRkcmVzcyA9IFV0aWxzLmdldEJhc2U1OEFkZHJlc3NGcm9tSGV4KHJlY2VpdmVBZGRyZXNzSGV4KTtcbiAgICAgIC8vIGNhbGwgdGhlIG5vZGUgdG8gZ2V0IG91ciBhY2NvdW50IGJhbGFuY2VcbiAgICAgIGNvbnN0IGFjY291bnRJbmZvID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50QmFsYW5jZXNGcm9tTm9kZShyZWNlaXZlQWRkcmVzcyk7XG5cbiAgICAgIGlmIChhY2NvdW50SW5mby5kYXRhWzBdICYmIGFjY291bnRJbmZvLmRhdGFbMF0uYmFsYW5jZSA+IFNBRkVfVFJPTl9UUkFOU0FDVElPTl9GRUUpIHtcbiAgICAgICAgbGV0IHJlY292ZXJ5QW1vdW50ID0gMDtcbiAgICAgICAgLy8gVG9rZW5zIG11c3QgYmUgY29uc29saWRhdGUgYmVmb3JlIHRoZSBuYXRpdmUgYXNzZXQuIEZpcnN0IGNvbnN0cnVjdCB0b2tlbiB0eG5zXG4gICAgICAgIGxldCByYXdUb2tlblR4bjogYW55IHwgdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBwb3NzaWJsZSB0b2tlbiByZWNvdmVyeSwgcmVjb3ZlciB0aGUgdG9rZW4gcHJvdmlkZSBieSB1c2VyXG4gICAgICAgIGlmIChwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MpIHtcbiAgICAgICAgICBpZiAoYWNjb3VudEluZm8uZGF0YVswXS5iYWxhbmNlID4gU0FGRV9UUk9OX1RPS0VOX1RSQU5TQUNUSU9OX0ZFRSAmJiBhY2NvdW50SW5mby5kYXRhWzBdLnRyYzIwWzBdKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkRhdGFBcnJheSA9IGFjY291bnRJbmZvLmRhdGFbMF0udHJjMjA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuRGF0YSBvZiB0b2tlbkRhdGFBcnJheSkge1xuICAgICAgICAgICAgICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBPYmplY3Qua2V5cyh0b2tlbkRhdGEpIGFzIEFycmF5PHN0cmluZz47XG4gICAgICAgICAgICAgIGlmIChwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MgPT09IGNvbnRyYWN0QWRkcmVzc1swXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFtb3VudCA9IHRva2VuRGF0YVtjb250cmFjdEFkZHJlc3NbMF1dO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuQ29udHJhY3RBZGRySGV4ID0gVXRpbHMuZ2V0SGV4QWRkcmVzc0Zyb21CYXNlNThBZGRyZXNzKGNvbnRyYWN0QWRkcmVzc1swXSk7XG4gICAgICAgICAgICAgICAgcmF3VG9rZW5UeG4gPSAoXG4gICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmdldFRyaWdnZXJTbWFydENvbnRyYWN0VHJhbnNhY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIGJhc2VBZGRySGV4LFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlQWRkcmVzc0hleCxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50LFxuICAgICAgICAgICAgICAgICAgICB0b2tlbkNvbnRyYWN0QWRkckhleFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkudHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgcmVjb3ZlcnlBbW91bnQgPSBwYXJzZUludChhbW91bnQsIDEwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBidWlsZCBhbmQgc2lnbiB0b2tlbiB0eG5zXG4gICAgICAgICAgaWYgKHJhd1Rva2VuVHhuKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzSW5mbyA9IHtcbiAgICAgICAgICAgICAgYWRkcmVzczogcmVjZWl2ZUFkZHJlc3MsXG4gICAgICAgICAgICAgIGNoYWluOiAwLFxuICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB0eEJ1aWxkZXIgPSBnZXRCdWlsZGVyKHRoaXMuZ2V0Q2hhaW4oKSkuZnJvbShyYXdUb2tlblR4bik7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGV4cGlyeSBpcyAxIG1pbnV0ZSB3aGljaCBpcyB0b28gc2hvcnQgZm9yIHJlY292ZXJ5IHB1cnBvc2VzXG4gICAgICAgICAgICAvLyBleHRlbmQgdGhlIGV4cGlyeSB0byAxIGRheVxuICAgICAgICAgICAgdHhCdWlsZGVyLmV4dGVuZFZhbGlkVG8oUkVDT1ZFUl9UUkFOU0FDVElPTl9FWFBJUlkpO1xuICAgICAgICAgICAgLy8gdGhpcyB0eCBzaG91bGQgYmUgZW5vdWdoIHRvIGRyb3AgaW50byBhIG5vZGVcbiAgICAgICAgICAgIGlmICghaXNVbnNpZ25lZENvbnNvbGlkYXRpb25zKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHVzZXJQcnYgPSB0aGlzLnhwcnZUb0NvbXByZXNzZWRQcnYodXNlcktleS50b0Jhc2U1OCgpKTtcbiAgICAgICAgICAgICAgLy8gcmVjZWl2ZSBhZGRyZXNzIG9ubHkgbmVlZHMgdG8gYmUgc2lnbmVkIGJ5IHVzZXIga2V5XG4gICAgICAgICAgICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiB1c2VyUHJ2IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICAgICAgICAgIHR4bnNCYXRjaC5wdXNoKFxuICAgICAgICAgICAgICB0aGlzLmZvcm1hdEZvck9mZmxpbmVWYXVsdCh0eCwgU0FGRV9UUk9OX1RPS0VOX1RSQU5TQUNUSU9OX0ZFRSwgcmVjb3ZlcnlBbW91bnQsIGFkZHJlc3NJbmZvKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYWRkcmVzc0JhbGFuY2UgPSBhY2NvdW50SW5mby5kYXRhWzBdLmJhbGFuY2U7XG4gICAgICAgICAgY29uc3QgYWRkcmVzc0luZm8gPSB7XG4gICAgICAgICAgICBhZGRyZXNzOiByZWNlaXZlQWRkcmVzcyxcbiAgICAgICAgICAgIGNoYWluOiAwLFxuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCByZWNvdmVyeUFtb3VudCA9IGFkZHJlc3NCYWxhbmNlIC0gU0FGRV9UUk9OX1RSQU5TQUNUSU9OX0ZFRTtcbiAgICAgICAgICBjb25zdCBidWlsZFR4ID0gYXdhaXQgdGhpcy5nZXRCdWlsZFRyYW5zYWN0aW9uKGJhc2VBZGRySGV4LCByZWNlaXZlQWRkcmVzc0hleCwgcmVjb3ZlcnlBbW91bnQpO1xuICAgICAgICAgIC8vIGNvbnN0cnVjdCBvdXIgdHhcbiAgICAgICAgICBjb25zdCB0eEJ1aWxkZXIgPSAoZ2V0QnVpbGRlcih0aGlzLmdldENoYWluKCkpIGFzIFdyYXBwZWRCdWlsZGVyKS5mcm9tKGJ1aWxkVHgpO1xuICAgICAgICAgIC8vIERlZmF1bHQgZXhwaXJ5IGlzIDEgbWludXRlIHdoaWNoIGlzIHRvbyBzaG9ydCBmb3IgcmVjb3ZlcnkgcHVycG9zZXNcbiAgICAgICAgICAvLyBleHRlbmQgdGhlIGV4cGlyeSB0byAxIGRheVxuICAgICAgICAgIHR4QnVpbGRlci5leHRlbmRWYWxpZFRvKFJFQ09WRVJfVFJBTlNBQ1RJT05fRVhQSVJZKTtcblxuICAgICAgICAgIGlmICghaXNVbnNpZ25lZENvbnNvbGlkYXRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyUHJ2ID0gdGhpcy54cHJ2VG9Db21wcmVzc2VkUHJ2KHVzZXJLZXkudG9CYXNlNTgoKSk7XG4gICAgICAgICAgICAvLyByZWNlaXZlIGFkZHJlc3Mgb25seSBuZWVkcyB0byBiZSBzaWduZWQgYnkgdXNlciBrZXlcbiAgICAgICAgICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiB1c2VyUHJ2IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgICAgICAgIHR4bnNCYXRjaC5wdXNoKHRoaXMuZm9ybWF0Rm9yT2ZmbGluZVZhdWx0KHR4LCBTQUZFX1RST05fVFJBTlNBQ1RJT05fRkVFLCByZWNvdmVyeUFtb3VudCwgYWRkcmVzc0luZm8pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2FjdGlvbnM6IHR4bnNCYXRjaCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGxhaW4gYSBUcm9uIHRyYW5zYWN0aW9uIGZyb20gdHhIZXhcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgZXhwbGFpblRyYW5zYWN0aW9uKHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8VHJvblRyYW5zYWN0aW9uRXhwbGFuYXRpb24+IHtcbiAgICBjb25zdCB0eEhleCA9IHBhcmFtcy50eEhleCB8fCAocGFyYW1zLmhhbGZTaWduZWQgJiYgcGFyYW1zLmhhbGZTaWduZWQudHhIZXgpO1xuICAgIGlmICghdHhIZXggfHwgIXBhcmFtcy5mZWVJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgZXhwbGFpbiB0eCBwYXJhbWV0ZXJzJyk7XG4gICAgfVxuICAgIGNvbnN0IHR4QnVpbGRlciA9IGdldEJ1aWxkZXIodGhpcy5nZXRDaGFpbigpKS5mcm9tKHR4SGV4KTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgIGNvbnN0IG91dHB1dHMgPSBbXG4gICAgICB7XG4gICAgICAgIGFtb3VudDogdHgub3V0cHV0c1swXS52YWx1ZS50b1N0cmluZygpLFxuICAgICAgICBhZGRyZXNzOiB0eC5vdXRwdXRzWzBdLmFkZHJlc3MsIC8vIFNob3VsZCB0dXJuIGl0IGludG8gYSByZWFkYWJsZSBmb3JtYXQsIGFrYSBiYXNlNThcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIGNvbnN0IGRpc3BsYXlPcmRlciA9IFtcbiAgICAgICdpZCcsXG4gICAgICAnb3V0cHV0QW1vdW50JyxcbiAgICAgICdjaGFuZ2VBbW91bnQnLFxuICAgICAgJ291dHB1dHMnLFxuICAgICAgJ2NoYW5nZU91dHB1dHMnLFxuICAgICAgJ2ZlZScsXG4gICAgICAndGltZXN0YW1wJyxcbiAgICAgICdleHBpcmF0aW9uJyxcbiAgICBdO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc3BsYXlPcmRlcixcbiAgICAgIGlkOiB0eC5pZCxcbiAgICAgIG91dHB1dHMsXG4gICAgICBvdXRwdXRBbW91bnQ6IG91dHB1dHNbMF0uYW1vdW50LFxuICAgICAgY2hhbmdlT3V0cHV0czogW10sIC8vIGFjY291bnQgYmFzZWQgZG9lcyBub3QgdXNlIGNoYW5nZSBvdXRwdXRzXG4gICAgICBjaGFuZ2VBbW91bnQ6ICcwJywgLy8gYWNjb3VudCBiYXNlIGRvZXMgbm90IG1ha2UgY2hhbmdlXG4gICAgICBmZWU6IHBhcmFtcy5mZWVJbmZvLFxuICAgICAgdGltZXN0YW1wOiB0eC52YWxpZEZyb20sXG4gICAgICBleHBpcmF0aW9uOiB0eC52YWxpZFRvLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==