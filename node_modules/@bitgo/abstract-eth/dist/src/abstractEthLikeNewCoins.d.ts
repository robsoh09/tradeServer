/// <reference types="node" />
/**
 * @prettier
 */
import { AddressCoinSpecific, BitGoBase, BuildNftTransferDataOptions, FeeEstimateOptions, FullySignedTransaction, HalfSignedTransaction, IWallet, KeyPair, ParsedTransaction, ParseTransactionOptions, PrebuildTransactionResult, PresignTransactionOptions as BasePresignTransactionOptions, Recipient, SignTransactionOptions as BaseSignTransactionOptions, TransactionParams, TransactionPrebuild as BaseTransactionPrebuild, TransactionRecipient, TypedData, VerifyAddressOptions as BaseVerifyAddressOptions, VerifyTransactionOptions, Wallet } from '@bitgo/sdk-core';
import { BaseCoin as StaticsBaseCoin, EthereumNetwork as EthLikeNetwork } from '@bitgo/statics';
import type * as EthLikeCommon from '@ethereumjs/common';
import type * as EthLikeTxLib from '@ethereumjs/tx';
import BN from 'bn.js';
import { AbstractEthLikeCoin } from './abstractEthLikeCoin';
/**
 * The prebuilt hop transaction returned from the HSM
 */
interface HopPrebuild {
    tx: string;
    id: string;
    signature: string;
    paymentId: string;
    gasPrice: number;
    gasLimit: number;
    amount: number;
    recipient: string;
    nonce: number;
    userReqSig: string;
    gasPriceMax: number;
}
/**
 * The extra parameters to send to platform build route for hop transactions
 */
interface HopParams {
    hopParams: {
        gasPriceMax: number;
        userReqSig: string;
        paymentId: string;
    };
    gasLimit: number;
}
export interface EIP1559 {
    maxPriorityFeePerGas: number;
    maxFeePerGas: number;
}
export interface ReplayProtectionOptions {
    chain: string | number;
    hardfork: string;
}
export interface TransactionPrebuild extends BaseTransactionPrebuild {
    hopTransaction?: HopPrebuild;
    buildParams: {
        recipients: Recipient[];
    };
    recipients: TransactionRecipient[];
    nextContractSequenceId: number;
    gasPrice: number;
    gasLimit: number;
    isBatch: boolean;
    coin: string;
    token?: string;
}
export interface SignFinalOptions {
    txPrebuild: {
        eip1559?: EIP1559;
        replayProtectionOptions?: ReplayProtectionOptions;
        gasPrice?: string;
        gasLimit?: string;
        recipients?: Recipient[];
        halfSigned?: {
            expireTime: number;
            contractSequenceId: number;
            backupKeyNonce?: number;
            signature: string;
            txHex?: string;
        };
        nextContractSequenceId?: number;
        hopTransaction?: string;
        backupKeyNonce?: number;
        isBatch?: boolean;
        txHex?: string;
        expireTime?: number;
    };
    signingKeyNonce?: number;
    walletContractAddress?: string;
    prv: string;
    recipients?: Recipient[];
    common?: EthLikeCommon.default;
}
export interface SignTransactionOptions extends BaseSignTransactionOptions, SignFinalOptions {
    isLastSignature?: boolean;
    expireTime?: number;
    sequenceId?: number;
    gasLimit?: number;
    gasPrice?: number;
    custodianTransactionId?: string;
    common?: EthLikeCommon.default;
}
export declare type SignedTransaction = HalfSignedTransaction | FullySignedTransaction;
export interface FeesUsed {
    gasPrice: number;
    gasLimit: number;
}
interface PrecreateBitGoOptions {
    enterprise?: string;
    newFeeAddress?: string;
}
export interface OfflineVaultTxInfo {
    nextContractSequenceId?: string;
    contractSequenceId?: string;
    tx?: string;
    txHex?: string;
    userKey?: string;
    backupKey?: string;
    coin: string;
    gasPrice: number;
    gasLimit: number;
    recipients: Recipient[];
    walletContractAddress: string;
    amount: string;
    backupKeyNonce: number;
    eip1559?: EIP1559;
    replayProtectionOptions?: ReplayProtectionOptions;
    halfSigned?: HalfSignedTransaction;
    feesUsed?: FeesUsed;
    isEvmBasedCrossChainRecovery?: boolean;
}
interface UnformattedTxInfo {
    recipient: Recipient;
}
export interface RecoverOptions {
    userKey: string;
    backupKey: string;
    walletPassphrase?: string;
    walletContractAddress: string;
    recoveryDestination: string;
    krsProvider?: string;
    gasPrice?: number;
    gasLimit?: number;
    eip1559?: EIP1559;
    replayProtectionOptions?: ReplayProtectionOptions;
    isTss?: boolean;
    bitgoFeeAddress?: string;
    bitgoDestinationAddress?: string;
    tokenContractAddress?: string;
    intendedChain?: string;
    common?: EthLikeCommon.default;
}
export declare type GetBatchExecutionInfoRT = {
    values: [string[], string[]];
    totalAmount: string;
};
export interface BuildTransactionParams {
    to: string;
    nonce?: number;
    value: number;
    data?: Buffer;
    gasPrice?: number;
    gasLimit?: number;
    eip1559?: EIP1559;
    replayProtectionOptions?: ReplayProtectionOptions;
}
export interface RecoveryInfo {
    id: string;
    tx: string;
    backupKey?: string;
    coin?: string;
}
export interface RecoverTokenTransaction {
    halfSigned: {
        recipient: Recipient;
        expireTime: number;
        contractSequenceId: number;
        operationHash: string;
        signature: string;
        gasLimit: number;
        gasPrice: number;
        tokenContractAddress: string;
        walletId: string;
    };
}
export interface RecoverTokenOptions {
    tokenContractAddress: string;
    wallet: Wallet;
    recipient: string;
    broadcast?: boolean;
    walletPassphrase?: string;
    prv?: string;
}
export interface GetSendMethodArgsOptions {
    recipient: Recipient;
    expireTime: number;
    contractSequenceId: number;
    signature: string;
}
export interface SendMethodArgs {
    name: string;
    type: string;
    value: any;
}
interface HopTransactionBuildOptions {
    wallet: Wallet;
    recipients: Recipient[];
    walletPassphrase: string;
}
export interface BuildOptions {
    hop?: boolean;
    wallet?: Wallet;
    recipients?: Recipient[];
    walletPassphrase?: string;
    [index: string]: unknown;
}
interface FeeEstimate {
    gasLimitEstimate: number;
    feeEstimate: number;
}
interface EthTransactionParams extends TransactionParams {
    gasPrice?: number;
    gasLimit?: number;
    hopParams?: HopParams;
    hop?: boolean;
    prebuildTx?: PrebuildTransactionResult;
}
interface VerifyEthTransactionOptions extends VerifyTransactionOptions {
    txPrebuild: TransactionPrebuild;
    txParams: EthTransactionParams;
}
interface PresignTransactionOptions extends TransactionPrebuild, BasePresignTransactionOptions {
    wallet: Wallet;
}
interface EthAddressCoinSpecifics extends AddressCoinSpecific {
    forwarderVersion: number;
    salt?: string;
}
export interface VerifyEthAddressOptions extends BaseVerifyAddressOptions {
    baseAddress: string;
    coinSpecific: EthAddressCoinSpecifics;
    forwarderVersion: number;
}
export declare const optionalDeps: {
    readonly ethAbi: any;
    readonly ethUtil: any;
    readonly EthTx: typeof EthLikeTxLib;
    readonly EthCommon: typeof EthLikeCommon;
};
export declare abstract class AbstractEthLikeNewCoins extends AbstractEthLikeCoin {
    static hopTransactionSalt: string;
    protected readonly sendMethodName: 'sendMultiSig' | 'sendMultiSigToken';
    readonly staticsCoin?: Readonly<StaticsBaseCoin>;
    protected constructor(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>);
    /**
     * Method to return the coin's network object
     * @returns {EthLikeNetwork | undefined}
     */
    getNetwork(): EthLikeNetwork | undefined;
    /**
     * Evaluates whether an address string is valid for this coin
     * @param {string} address
     * @returns {boolean} True if address is the valid ethlike adderss
     */
    isValidAddress(address: string): boolean;
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    transactionDataAllowed(): boolean;
    /**
     * Default expire time for a contract call (1 week)
     * @returns {number} Time in seconds
     */
    getDefaultExpireTime(): number;
    /**
     * Method to get the custom chain common object based on params from recovery
     * @param {number} chainId - the chain id of the custom chain
     * @returns {EthLikeCommon.default}
     */
    static getCustomChainCommon(chainId: number): EthLikeCommon.default;
    /**
     * Gets correct Eth Common object based on params from either recovery or tx building
     * @param {EIP1559} eip1559 - configs that specify whether we should construct an eip1559 tx
     * @param {ReplayProtectionOptions} replayProtectionOptions - check if chain id supports replay protection
     * @returns {EthLikeCommon.default}
     */
    private static getEthLikeCommon;
    /**
     * Method to build the tx object
     * @param {BuildTransactionParams} params - params to build transaction
     * @returns {EthLikeTxLib.FeeMarketEIP1559Transaction | EthLikeTxLib.Transaction}
     */
    static buildTransaction(params: BuildTransactionParams): EthLikeTxLib.FeeMarketEIP1559Transaction | EthLikeTxLib.Transaction;
    /**
     * Query explorer for the balance of an address
     * @param {String} address - the ETHLike address
     * @returns {BigNumber} address balance
     */
    queryAddressBalance(address: string): Promise<any>;
    /**
     * @param {Recipient[]} recipients - the recipients of the transaction
     * @param {number} expireTime - the expire time of the transaction
     * @param {number} contractSequenceId - the contract sequence id of the transaction
     * @returns {string}
     */
    getOperationSha3ForExecuteAndConfirm(recipients: Recipient[], expireTime: number, contractSequenceId: number): string;
    /**
     * Get transfer operation for coin
     * @param {Recipient} recipient - recipient info
     * @param {number} expireTime - expiry time
     * @param {number} contractSequenceId - sequence id
     * @returns {Array} operation array
     */
    getOperation(recipient: Recipient, expireTime: number, contractSequenceId: number): (string | Buffer)[][];
    /**
     * Queries the contract (via explorer API) for the next sequence ID
     * @param {String} address - address of the contract
     * @returns {Promise<Number>} sequence ID
     */
    querySequenceId(address: string): Promise<number>;
    /**
     * Recover an unsupported token from a BitGo multisig wallet
     * This builds a half-signed transaction, for which there will be an admin route to co-sign and broadcast. Optionally
     * the user can set params.broadcast = true and the half-signed tx will be sent to BitGo for cosigning and broadcasting
     * @param {RecoverTokenOptions} params
     * @param {Wallet} params.wallet - the wallet to recover the token from
     * @param {string} params.tokenContractAddress - the contract address of the unsupported token
     * @param {string} params.recipient - the destination address recovered tokens should be sent to
     * @param {string} params.walletPassphrase - the wallet passphrase
     * @param {string} params.prv - the xprv
     * @param {boolean} params.broadcast - if true, we will automatically submit the half-signed tx to BitGo for cosigning and broadcasting
     * @returns {Promise<RecoverTokenTransaction>}
     */
    recoverToken(params: RecoverTokenOptions): Promise<RecoverTokenTransaction>;
    /**
     * Ensure either enterprise or newFeeAddress is passed, to know whether to create new key or use enterprise key
     * @param {PrecreateBitGoOptions} params
     * @param {string} params.enterprise {String} the enterprise id to associate with this key
     * @param {string} params.newFeeAddress {Boolean} create a new fee address (enterprise not needed in this case)
     * @returns {void}
     */
    preCreateBitGo(params: PrecreateBitGoOptions): void;
    /**
     * Queries public block explorer to get the next ETHLike coin's nonce that should be used for the given ETH address
     * @param {string} address
     * @returns {Promise<number>}
     */
    getAddressNonce(address: string): Promise<number>;
    /**
     * Helper function for recover()
     * This transforms the unsigned transaction information into a format the BitGo offline vault expects
     * @param {UnformattedTxInfo} txInfo - tx info
     * @param {EthLikeTxLib.Transaction | EthLikeTxLib.FeeMarketEIP1559Transaction} ethTx - the ethereumjs tx object
     * @param {string} userKey - the user's key
     * @param {string} backupKey - the backup key
     * @param {Buffer} gasPrice - gas price for the tx
     * @param {number} gasLimit - gas limit for the tx
     * @param {EIP1559} eip1559 - eip1559 params
     * @param {ReplayProtectionOptions} replayProtectionOptions - replay protection options
     * @returns {Promise<OfflineVaultTxInfo>}
     */
    formatForOfflineVault(txInfo: UnformattedTxInfo, ethTx: EthLikeTxLib.Transaction | EthLikeTxLib.FeeMarketEIP1559Transaction, userKey: string, backupKey: string, gasPrice: Buffer, gasLimit: number, eip1559?: EIP1559, replayProtectionOptions?: ReplayProtectionOptions): Promise<OfflineVaultTxInfo>;
    /**
     * Helper function for recover()
     * This transforms the unsigned transaction information into a format the BitGo offline vault expects
     * @param {UnformattedTxInfo} txInfo - tx info
     * @param {EthLikeTxLib.Transaction | EthLikeTxLib.FeeMarketEIP1559Transaction} ethTx - the ethereumjs tx object
     * @param {string} userKey - the user's key
     * @param {string} backupKey - the backup key
     * @param {Buffer} gasPrice - gas price for the tx
     * @param {number} gasLimit - gas limit for the tx
     * @param {number} backupKeyNonce - the nonce of the backup key address
     * @param {EIP1559} eip1559 - eip1559 params
     * @param {ReplayProtectionOptions} replayProtectionOptions - replay protection options
     * @returns {Promise<OfflineVaultTxInfo>}
     */
    formatForOfflineVaultTSS(txInfo: UnformattedTxInfo, ethTx: EthLikeTxLib.Transaction | EthLikeTxLib.FeeMarketEIP1559Transaction, userKey: string, backupKey: string, gasPrice: Buffer, gasLimit: number, backupKeyNonce: number, eip1559?: EIP1559, replayProtectionOptions?: ReplayProtectionOptions): OfflineVaultTxInfo;
    /**
     * Check whether the gas price passed in by user are within our max and min bounds
     * If they are not set, set them to the defaults
     * @param {number} userGasPrice - user defined gas price
     * @returns {number} the gas price to use for this transaction
     */
    setGasPrice(userGasPrice?: number): number;
    /**
     * Check whether gas limit passed in by user are within our max and min bounds
     * If they are not set, set them to the defaults
     * @param {number} userGasLimit user defined gas limit
     * @returns {number} the gas limit to use for this transaction
     */
    setGasLimit(userGasLimit?: number): number;
    /**
     * Helper function for signTransaction for the rare case that SDK is doing the second signature
     * Note: we are expecting this to be called from the offline vault
     * @param {SignFinalOptions.txPrebuild} params.txPrebuild
     * @param {string} params.prv
     * @returns {{txHex: string}}
     */
    signFinalEthLike(params: SignFinalOptions): Promise<FullySignedTransaction>;
    /**
     * Assemble half-sign prebuilt transaction
     * @param {SignTransactionOptions} params
     */
    signTransaction(params: SignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Method to validate recovery params
     * @param {RecoverOptions} params
     * @returns {void}
     */
    validateRecoveryParams(params: RecoverOptions): void;
    /**
     * Method to sign tss recovery transaction
     * @param {ECDSA.KeyCombined} userKeyCombined
     * @param {ECDSA.KeyCombined} backupKeyCombined
     * @param {string} txHex
     * @param {Object} options
     * @param {EcdsaTypes.SerializedNtilde} options.rangeProofChallenge
     * @returns {Promise<ECDSAMethodTypes.Signature>}
     */
    private signRecoveryTSS;
    /**
     * Helper which combines key shares of user and backup
     * @param {string} userPublicOrPrivateKeyShare
     * @param {string} backupPrivateOrPublicKeyShare
     * @param {string} walletPassphrase
     * @returns {[ECDSAMethodTypes.KeyCombined, ECDSAMethodTypes.KeyCombined]}
     */
    private getKeyCombinedFromTssKeyShares;
    /**
     * Helper which Adds signatures to tx object and re-serializes tx
     * @param {EthLikeCommon.default} ethCommon
     * @param {EthLikeTxLib.FeeMarketEIP1559Transaction | EthLikeTxLib.Transaction} tx
     * @param {ECDSAMethodTypes.Signature} signature
     * @returns {EthLikeTxLib.FeeMarketEIP1559Transaction | EthLikeTxLib.Transaction}
     */
    private getSignedTxFromSignature;
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * @param {string} params.userKey - [encrypted] xprv
     * @param {string} params.backupKey - [encrypted] xprv or xpub if the xprv is held by a KRS provider
     * @param {string} params.walletPassphrase - used to decrypt userKey and backupKey
     * @param {string} params.walletContractAddress - the ETH address of the wallet contract
     * @param {string} params.krsProvider - necessary if backup key is held by KRS
     * @param {string} params.recoveryDestination - target address to send recovered funds to
     * @param {string} params.bitgoFeeAddress - wrong chain wallet fee address for evm based cross chain recovery txn
     * @param {string} params.bitgoDestinationAddress - target bitgo address where fee will be sent for evm based cross chain recovery txn
     */
    recover(params: RecoverOptions): Promise<RecoveryInfo | OfflineVaultTxInfo>;
    /**
     * Builds a funds recovery transaction without BitGo for non-TSS transaction
     * @param params
     * @param {string} params.userKey [encrypted] xprv or xpub
     * @param {string} params.backupKey [encrypted] xprv or xpub if the xprv is held by a KRS provider
     * @param {string} params.walletPassphrase used to decrypt userKey and backupKey
     * @param {string} params.walletContractAddress the EthLike address of the wallet contract
     * @param {string} params.krsProvider necessary if backup key is held by KRS
     * @param {string} params.recoveryDestination target address to send recovered funds to
     * @param {string} params.bitgoFeeAddress wrong chain wallet fee address for evm based cross chain recovery txn
     * @param {string} params.bitgoDestinationAddress target bitgo address where fee will be sent for evm based cross chain recovery txn
     * @returns {Promise<RecoveryInfo | OfflineVaultTxInfo>}
     */
    protected recoverEthLike(params: RecoverOptions): Promise<RecoveryInfo | OfflineVaultTxInfo>;
    /**
     * Builds a unsigned (for cold, custody wallet) or
     * half-signed (for hot wallet) evm cross chain recovery transaction with
     * same expected arguments as recover method.
     * This helps recover funds from evm based wrong chain.
     * @param {RecoverOptions} params
     * @returns {Promise<RecoveryInfo | OfflineVaultTxInfo>}
     */
    protected recoverEthLikeforEvmBasedRecovery(params: RecoverOptions): Promise<RecoveryInfo | OfflineVaultTxInfo>;
    /**
     * Query explorer for the balance of an address for a token
     * @param {string} tokenContractAddress - address where the token smart contract is hosted
     * @param {string} walletContractAddress - address of the wallet
     * @returns {BigNumber} token balaance in base units
     */
    queryAddressTokenBalance(tokenContractAddress: string, walletContractAddress: string): Promise<any>;
    recoverEthLikeTokenforEvmBasedRecovery(params: RecoverOptions, bitgoFeeAddressNonce: number, gasLimit: any, gasPrice: any, userKey: any, userSigningKey: any): Promise<OfflineVaultTxInfo>;
    /**
     * Validate evm based cross chain recovery params
     * @param params {RecoverOptions}
     * @returns {void}
     */
    validateEvmBasedRecoveryParams(params: RecoverOptions): void;
    /**
     * Return types, values, and total amount in wei to send in a batch transaction, using the method signature
     * `distributeBatch(address[], uint256[])`
     * @param {Recipient[]} recipients - transaction recipients
     * @returns {GetBatchExecutionInfoRT} information needed to execute the batch transaction
     */
    getBatchExecutionInfo(recipients: Recipient[]): GetBatchExecutionInfoRT;
    /**
     * Get the data required to make an ETH function call defined by the given types and values
     *
     * @param {string} functionName - The name of the function being called, e.g. transfer
     * @param types The types of the function call in order
     * @param values The values of the function call in order
     * @return {Buffer} The combined data for the function call
     */
    getMethodCallData: (functionName: any, types: any, values: any) => Buffer;
    /**
     * Build arguments to call the send method on the wallet contract
     * @param txInfo
     */
    getSendMethodArgs(txInfo: GetSendMethodArgsOptions): SendMethodArgs[];
    /**
     * Recovers a tx with TSS key shares
     * same expected arguments as recover method, but with TSS key shares
     */
    protected recoverTSS(params: RecoverOptions): Promise<RecoveryInfo | OfflineVaultTxInfo>;
    private static signRecoveryMpcV2;
    private getMpcV2RecoveryKeyShares;
    private isGG18SigningMaterial;
    private buildTssRecoveryTxn;
    validateBalanceAndGetTxAmount(baseAddress: string, gasPrice: BN, gasLimit: BN): Promise<any>;
    recoveryBlockchainExplorerQuery(query: Record<string, string>): Promise<any>;
    /**
     * Creates the extra parameters needed to build a hop transaction
     * @param buildParams The original build parameters
     * @returns extra parameters object to merge with the original build parameters object and send to the platform
     */
    createHopTransactionParams(buildParams: HopTransactionBuildOptions): Promise<HopParams>;
    /**
     * Validates that the hop prebuild from the HSM is valid and correct
     * @param {IWallet} wallet - The wallet that the prebuild is for
     * @param {HopPrebuild} hopPrebuild - The prebuild to validate
     * @param {Object} originalParams - The original parameters passed to prebuildTransaction
     * @param {Recipient[]} originalParams.recipients - The original recipients array
     * @returns {void}
     * @throws Error if The prebuild is invalid
     */
    validateHopPrebuild(wallet: IWallet, hopPrebuild: HopPrebuild, originalParams?: {
        recipients: Recipient[];
    }): Promise<void>;
    /**
     * Gets the hop digest for the user to sign. This is validated in the HSM to prove that the user requested this tx
     * @param {string[]} paramsArr - The parameters to hash together for the digest
     * @returns {Buffer}
     */
    private static getHopDigest;
    /**
     * Modify prebuild before sending it to the server. Add things like hop transaction params
     * @param {BuildOptions} buildParams - The whitelisted parameters for this prebuild
     * @param {boolean} buildParams.hop - True if this should prebuild a hop tx, else false
     * @param {Recipient[]} buildParams.recipients - The recipients array of this transaction
     * @param {Wallet} buildParams.wallet - The wallet sending this tx
     * @param {string} buildParams.walletPassphrase - the passphrase for this wallet
     * @returns {Promise<BuildOptions>}
     */
    getExtraPrebuildParams(buildParams: BuildOptions): Promise<BuildOptions>;
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     * @param {TransactionPrebuild} params - The prebuild to modify
     * @returns {TransactionPrebuild} The modified prebuild
     */
    postProcessPrebuild(params: TransactionPrebuild): Promise<TransactionPrebuild>;
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     * @param {PresignTransactionOptions} params
     * @returns {Promise<PresignTransactionOptions>}
     */
    presignTransaction(params: PresignTransactionOptions): Promise<PresignTransactionOptions>;
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params - The params passed into the function
     * @param {boolean} [params.hop] - True if we should estimate fee for a hop transaction
     * @param {string} [params.recipient] - The recipient of the transaction to estimate a send to
     * @param {string} [params.data] - The ETH tx data to estimate a send for
     * @returns {Object} The fee info returned from the server
     */
    feeEstimate(params: FeeEstimateOptions): Promise<FeeEstimate>;
    /**
     * Generate secp256k1 key pair
     *
     * @param {Buffer} seed
     * @returns {KeyPair} object with generated pub and prv
     */
    generateKeyPair(seed: Buffer): KeyPair;
    parseTransaction(params: ParseTransactionOptions): Promise<ParsedTransaction>;
    /**
     * Make sure an address is a wallet address and throw an error if it's not.
     * @param {Object} params
     * @param {string} params.address - The derived address string on the network
     * @param {Object} params.coinSpecific - Coin-specific details for the address such as a forwarderVersion
     * @param {string} params.baseAddress - The base address of the wallet on the network
     * @throws {InvalidAddressError}
     * @throws {InvalidAddressVerificationObjectPropertyError}
     * @throws {UnexpectedAddressError}
     * @returns {boolean} True iff address is a wallet address
     */
    isWalletAddress(params: VerifyEthAddressOptions): Promise<boolean>;
    /**
     *
     * @param {TransactionPrebuild} txPrebuild
     * @returns {boolean}
     */
    verifyCoin(txPrebuild: TransactionPrebuild): boolean;
    /**
     * Verify if a tss transaction is valid
     *
     * @param {VerifyEthTransactionOptions} params
     * @param {TransactionParams} params.txParams - params object passed to send
     * @param {TransactionPrebuild} params.txPrebuild - prebuild object returned by server
     * @param {Wallet} params.wallet - Wallet object to obtain keys to verify against
     * @returns {boolean}
     */
    verifyTssTransaction(params: VerifyEthTransactionOptions): boolean;
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param {VerifyEthTransactionOptions} params
     * @param {TransactionParams} params.txParams - params object passed to send
     * @param {TransactionPrebuild} params.txPrebuild - prebuild object returned by server
     * @param {Wallet} params.wallet - Wallet object to obtain keys to verify against
     * @returns {boolean}
     */
    verifyTransaction(params: VerifyEthTransactionOptions): Promise<boolean>;
    /**
     * Check if address is valid eth address
     * @param address
     * @returns {boolean}
     */
    private isETHAddress;
    /**
     * Transform message to accommodate specific blockchain requirements.
     * @param {string} message - the message to prepare
     * @return {string} the prepared message.
     */
    encodeMessage(message: string): string;
    /**
     * Transform the Typed data to accomodate the blockchain requirements (EIP-712)
     * @param {TypedData} typedData - the typed data to prepare
     * @return {Buffer} a buffer of the result
     */
    encodeTypedData(typedData: TypedData): Buffer;
    /**
     * Build the data to transfer an ERC-721 or ERC-1155 token to another address
     * @param params
     */
    buildNftTransferData(params: BuildNftTransferDataOptions): string;
}
export {};
//# sourceMappingURL=abstractEthLikeNewCoins.d.ts.map