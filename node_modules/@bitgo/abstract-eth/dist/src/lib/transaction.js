"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const types_1 = require("./types");
const utils_1 = require("./utils");
const UNSUPPORTED_COIN_NAME = 'unsupported';
class Transaction extends sdk_core_1.BaseTransaction {
    /**
     * Public constructor.
     *
     * @param {Readonly<CoinConfig>} coinConfig
     * @param common the network commons
     * @param {TxData} txData The object transaction data or encoded transaction data
     */
    constructor(coinConfig, common, txData) {
        super(coinConfig);
        this._common = common;
        if (txData) {
            this.setTransactionData(txData);
        }
    }
    /**
     * return a new Transaction initialized with the serialized tx string
     *
     * @param coinConfig The coin configuration object
     * @param common network commons
     * @param serializedTx The serialized tx string with which to initialize the transaction
     * @returns a new transaction object
     */
    static fromSerialized(coinConfig, common, serializedTx) {
        return new Transaction(coinConfig, common, types_1.EthTransactionData.fromSerialized(serializedTx, common).toJson());
    }
    /**
     * Set the transaction data
     *
     * @param {TxData} txData The transaction data to set
     */
    setTransactionData(txData) {
        this._transactionData = types_1.EthTransactionData.fromJson(txData, this._common);
        this.updateFields();
    }
    /**
     * Update the internal fields based on the currently set transaction data, if there is any
     */
    updateFields() {
        if (!this._transactionData) {
            return;
        }
        const txData = this._transactionData.toJson();
        if (txData.id) {
            this._id = txData.id;
        }
        this._type = (0, utils_1.classifyTransaction)(txData.data);
        // reset arrays to empty to ensure that they are only set with one set of fresh values
        this._inputs = [];
        this._outputs = [];
        this._signatures = [];
        if ((0, utils_1.hasSignature)(txData)) {
            this._signatures.push((0, utils_1.toStringSig)({ v: txData.v, r: txData.r, s: txData.s }));
        }
        // only send transactions have inputs / outputs / signatures to parse
        if (this._type === sdk_core_1.TransactionType.Send ||
            this._type === sdk_core_1.TransactionType.SendERC721 ||
            this._type === sdk_core_1.TransactionType.SendERC1155) {
            const { to, amount, tokenContractAddress, signature } = (0, utils_1.decodeTransferData)(txData.data);
            let coinName;
            if (tokenContractAddress) {
                const token = (0, utils_1.getToken)(tokenContractAddress, this._coinConfig.network, this._coinConfig.family);
                coinName = token ? token.name : UNSUPPORTED_COIN_NAME;
            }
            else {
                coinName = this._coinConfig.name;
            }
            this.outputs.push({
                address: to,
                value: amount,
                coin: coinName,
            });
            this.inputs.push({
                address: txData.to,
                value: amount,
                coin: coinName,
            });
            this._signatures.push(signature);
        }
    }
    /**
     * Set the transaction type
     *
     * @param {TransactionType} transactionType The transaction type to be set
     */
    setTransactionType(transactionType) {
        this._type = transactionType;
    }
    /** @inheritdoc */
    canSign(key) {
        // TODO: implement this validation for the ethereum network
        return true;
    }
    /**
     * Sign the transaction with the provided key. It does not check if the signer is allowed to sign
     * it or not.
     *
     * @param {KeyPair} keyPair The key to sign the transaction with
     */
    async sign(keyPair) {
        if (!this._transactionData) {
            throw new sdk_core_1.InvalidTransactionError('No transaction data to sign');
        }
        if (!keyPair.getKeys().prv) {
            throw new sdk_core_1.SigningError('Missing private key');
        }
        await this._transactionData.sign(keyPair);
        const txData = this._transactionData.toJson();
        if (txData.id) {
            this._id = txData.id;
        }
        this._signatures.push((0, utils_1.toStringSig)({ v: txData.v, r: txData.r, s: txData.s }));
    }
    /** @inheritdoc */
    toBroadcastFormat() {
        if (this._transactionData) {
            return this._transactionData.toSerialized();
        }
        throw new sdk_core_1.InvalidTransactionError('No transaction data to format');
    }
    /** @inheritdoc */
    toJson() {
        if (this._transactionData) {
            return this._transactionData.toJson();
        }
        throw new sdk_core_1.InvalidTransactionError('Empty transaction');
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3RyYW5zYWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUtBLDhDQU95QjtBQUd6QixtQ0FBNkM7QUFDN0MsbUNBQXVHO0FBRXZHLE1BQU0scUJBQXFCLEdBQUcsYUFBYSxDQUFDO0FBRTVDLE1BQWEsV0FBWSxTQUFRLDBCQUFlO0lBMEI5Qzs7Ozs7O09BTUc7SUFDSCxZQUFZLFVBQWdDLEVBQUUsTUFBc0IsRUFBRSxNQUFlO1FBQ25GLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNsQixJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUN0QixJQUFJLE1BQU0sRUFBRTtZQUNWLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNqQztJQUNILENBQUM7SUE3QkQ7Ozs7Ozs7T0FPRztJQUNJLE1BQU0sQ0FBQyxjQUFjLENBQzFCLFVBQWdDLEVBQ2hDLE1BQXNCLEVBQ3RCLFlBQW9CO1FBRXBCLE9BQU8sSUFBSSxXQUFXLENBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSwwQkFBa0IsQ0FBQyxjQUFjLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFDL0csQ0FBQztJQWlCRDs7OztPQUlHO0lBQ0gsa0JBQWtCLENBQUMsTUFBYztRQUMvQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsMEJBQWtCLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDMUUsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7T0FFRztJQUNPLFlBQVk7UUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUMxQixPQUFPO1NBQ1I7UUFFRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMs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LENBQUM7UUFDMUMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzlDLElBQUksTUFBTSxDQUFDLEVBQUUsRUFBRTtZQUNiLElBQUksQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQztTQUN0QjtRQUNELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUEsbUJBQVcsRUFBQyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBRSxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBRSxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ25GLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsaUJBQWlCO1FBQ2YsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7WUFDekIsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxFQUFFLENBQUM7U0FDN0M7UUFDRCxNQUFNLElBQUksa0NBQXVCLENBQUMsK0JBQStCLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLE1BQU07UUFDSixJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUN6QixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUN2QztRQUNELE1BQU0sSUFBSSxrQ0FBdUIsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0lBQ3pELENBQUM7Q0FDRjtBQTVKRCxrQ0E0SkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV0aGVyZXVtIHRyYW5zYWN0aW9uIG1vZGVsLiBUaGlzIGlzIHRoZSBiYXNlIG1vZGVsIGZvciBhbGwgZXRoZXJldW0gYmFzZWQgY29pbnMgKENlbG8sIEVUQywgUlNLLCBFVEgpXG4gKi9cbmltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgRXRoZXJldW1Db21tb24gZnJvbSAnQGV0aGVyZXVtanMvY29tbW9uJztcbmltcG9ydCB7XG4gIEJhc2VLZXksXG4gIEVudHJ5LFxuICBCYXNlVHJhbnNhY3Rpb24sXG4gIFRyYW5zYWN0aW9uVHlwZSxcbiAgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IsXG4gIFNpZ25pbmdFcnJvcixcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IEtleVBhaXIgfSBmcm9tICcuL2tleVBhaXInO1xuaW1wb3J0IHsgRXRoTGlrZVRyYW5zYWN0aW9uRGF0YSwgVHhEYXRhIH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBFdGhUcmFuc2FjdGlvbkRhdGEgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGNsYXNzaWZ5VHJhbnNhY3Rpb24sIGRlY29kZVRyYW5zZmVyRGF0YSwgZ2V0VG9rZW4sIGhhc1NpZ25hdHVyZSwgdG9TdHJpbmdTaWcgfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgVU5TVVBQT1JURURfQ09JTl9OQU1FID0gJ3Vuc3VwcG9ydGVkJztcblxuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uIHtcbiAgcHJvdGVjdGVkIF9pZDogc3RyaW5nOyAvLyBUaGUgdHJhbnNhY3Rpb24gaWQgYXMgc2VlbiBpbiB0aGUgYmxvY2tjaGFpblxuICBwcm90ZWN0ZWQgX2lucHV0czogRW50cnlbXTtcbiAgcHJvdGVjdGVkIF9vdXRwdXRzOiBFbnRyeVtdO1xuICBwcm90ZWN0ZWQgX3NpZ25hdHVyZXM6IHN0cmluZ1tdO1xuICBwcm90ZWN0ZWQgX3R5cGU6IFRyYW5zYWN0aW9uVHlwZTtcbiAgcHJvdGVjdGVkIF9jb21tb246IEV0aGVyZXVtQ29tbW9uO1xuXG4gIHByb3RlY3RlZCBfdHJhbnNhY3Rpb25EYXRhPzogRXRoTGlrZVRyYW5zYWN0aW9uRGF0YTtcblxuICAvKipcbiAgICogcmV0dXJuIGEgbmV3IFRyYW5zYWN0aW9uIGluaXRpYWxpemVkIHdpdGggdGhlIHNlcmlhbGl6ZWQgdHggc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSBjb2luQ29uZmlnIFRoZSBjb2luIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqIEBwYXJhbSBjb21tb24gbmV0d29yayBjb21tb25zXG4gICAqIEBwYXJhbSBzZXJpYWxpemVkVHggVGhlIHNlcmlhbGl6ZWQgdHggc3RyaW5nIHdpdGggd2hpY2ggdG8gaW5pdGlhbGl6ZSB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMgYSBuZXcgdHJhbnNhY3Rpb24gb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21TZXJpYWxpemVkKFxuICAgIGNvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+LFxuICAgIGNvbW1vbjogRXRoZXJldW1Db21tb24sXG4gICAgc2VyaWFsaXplZFR4OiBzdHJpbmdcbiAgKTogVHJhbnNhY3Rpb24ge1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oY29pbkNvbmZpZywgY29tbW9uLCBFdGhUcmFuc2FjdGlvbkRhdGEuZnJvbVNlcmlhbGl6ZWQoc2VyaWFsaXplZFR4LCBjb21tb24pLnRvSnNvbigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhZG9ubHk8Q29pbkNvbmZpZz59IGNvaW5Db25maWdcbiAgICogQHBhcmFtIGNvbW1vbiB0aGUgbmV0d29yayBjb21tb25zXG4gICAqIEBwYXJhbSB7VHhEYXRhfSB0eERhdGEgVGhlIG9iamVjdCB0cmFuc2FjdGlvbiBkYXRhIG9yIGVuY29kZWQgdHJhbnNhY3Rpb24gZGF0YVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4sIGNvbW1vbjogRXRoZXJldW1Db21tb24sIHR4RGF0YT86IFR4RGF0YSkge1xuICAgIHN1cGVyKGNvaW5Db25maWcpO1xuICAgIHRoaXMuX2NvbW1vbiA9IGNvbW1vbjtcbiAgICBpZiAodHhEYXRhKSB7XG4gICAgICB0aGlzLnNldFRyYW5zYWN0aW9uRGF0YSh0eERhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtUeERhdGF9IHR4RGF0YSBUaGUgdHJhbnNhY3Rpb24gZGF0YSB0byBzZXRcbiAgICovXG4gIHNldFRyYW5zYWN0aW9uRGF0YSh0eERhdGE6IFR4RGF0YSk6IHZvaWQge1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uRGF0YSA9IEV0aFRyYW5zYWN0aW9uRGF0YS5mcm9tSnNvbih0eERhdGEsIHRoaXMuX2NvbW1vbik7XG4gICAgdGhpcy51cGRhdGVGaWVsZHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGludGVybmFsIGZpZWxkcyBiYXNlZCBvbiB0aGUgY3VycmVudGx5IHNldCB0cmFuc2FjdGlvbiBkYXRhLCBpZiB0aGVyZSBpcyBhbnlcbiAgICovXG4gIHByb3RlY3RlZCB1cGRhdGVGaWVsZHMoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLl90cmFuc2FjdGlvbkRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0eERhdGEgPSB0aGlzLl90cmFuc2FjdGlvbkRhdGEudG9Kc29uKCk7XG4gICAgaWYgKHR4RGF0YS5pZCkge1xuICAgICAgdGhpcy5faWQgPSB0eERhdGEuaWQ7XG4gICAgfVxuICAgIHRoaXMuX3R5cGUgPSBjbGFzc2lmeVRyYW5zYWN0aW9uKHR4RGF0YS5kYXRhKTtcblxuICAgIC8vIHJlc2V0IGFycmF5cyB0byBlbXB0eSB0byBlbnN1cmUgdGhhdCB0aGV5IGFyZSBvbmx5IHNldCB3aXRoIG9uZSBzZXQgb2YgZnJlc2ggdmFsdWVzXG4gICAgdGhpcy5faW5wdXRzID0gW107XG4gICAgdGhpcy5fb3V0cHV0cyA9IFtdO1xuICAgIHRoaXMuX3NpZ25hdHVyZXMgPSBbXTtcblxuICAgIGlmIChoYXNTaWduYXR1cmUodHhEYXRhKSkge1xuICAgICAgdGhpcy5fc2lnbmF0dXJlcy5wdXNoKHRvU3RyaW5nU2lnKHsgdjogdHhEYXRhLnYhLCByOiB0eERhdGEuciEsIHM6IHR4RGF0YS5zISB9KSk7XG4gICAgfVxuXG4gICAgLy8gb25seSBzZW5kIHRyYW5zYWN0aW9ucyBoYXZlIGlucHV0cyAvIG91dHB1dHMgLyBzaWduYXR1cmVzIHRvIHBhcnNlXG4gICAgaWYgKFxuICAgICAgdGhpcy5fdHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLlNlbmQgfHxcbiAgICAgIHRoaXMuX3R5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5TZW5kRVJDNzIxIHx8XG4gICAgICB0aGlzLl90eXBlID09PSBUcmFuc2FjdGlvblR5cGUuU2VuZEVSQzExNTVcbiAgICApIHtcbiAgICAgIGNvbnN0IHsgdG8sIGFtb3VudCwgdG9rZW5Db250cmFjdEFkZHJlc3MsIHNpZ25hdHVyZSB9ID0gZGVjb2RlVHJhbnNmZXJEYXRhKHR4RGF0YS5kYXRhKTtcbiAgICAgIGxldCBjb2luTmFtZTogc3RyaW5nO1xuICAgICAgaWYgKHRva2VuQ29udHJhY3RBZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4odG9rZW5Db250cmFjdEFkZHJlc3MsIHRoaXMuX2NvaW5Db25maWcubmV0d29yaywgdGhpcy5fY29pbkNvbmZpZy5mYW1pbHkpO1xuICAgICAgICBjb2luTmFtZSA9IHRva2VuID8gdG9rZW4ubmFtZSA6IFVOU1VQUE9SVEVEX0NPSU5fTkFNRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvaW5OYW1lID0gdGhpcy5fY29pbkNvbmZpZy5uYW1lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm91dHB1dHMucHVzaCh7XG4gICAgICAgIGFkZHJlc3M6IHRvLFxuICAgICAgICB2YWx1ZTogYW1vdW50LFxuICAgICAgICBjb2luOiBjb2luTmFtZSxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmlucHV0cy5wdXNoKHtcbiAgICAgICAgYWRkcmVzczogdHhEYXRhLnRvISwgLy8gdGhlIHNlbmRpbmcgd2FsbGV0IGNvbnRyYWN0IGlzIHRoZSByZWNpcGllbnQgb2YgdGhlIG91dGVyIHRyYW5zYWN0aW9uXG4gICAgICAgIHZhbHVlOiBhbW91bnQsXG4gICAgICAgIGNvaW46IGNvaW5OYW1lLFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3NpZ25hdHVyZXMucHVzaChzaWduYXR1cmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRyYW5zYWN0aW9uIHR5cGVcbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvblR5cGV9IHRyYW5zYWN0aW9uVHlwZSBUaGUgdHJhbnNhY3Rpb24gdHlwZSB0byBiZSBzZXRcbiAgICovXG4gIHNldFRyYW5zYWN0aW9uVHlwZSh0cmFuc2FjdGlvblR5cGU6IFRyYW5zYWN0aW9uVHlwZSk6IHZvaWQge1xuICAgIHRoaXMuX3R5cGUgPSB0cmFuc2FjdGlvblR5cGU7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgY2FuU2lnbihrZXk6IEJhc2VLZXkpOiBib29sZWFuIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdGhpcyB2YWxpZGF0aW9uIGZvciB0aGUgZXRoZXJldW0gbmV0d29ya1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gdGhlIHRyYW5zYWN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGtleS4gSXQgZG9lcyBub3QgY2hlY2sgaWYgdGhlIHNpZ25lciBpcyBhbGxvd2VkIHRvIHNpZ25cbiAgICogaXQgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge0tleVBhaXJ9IGtleVBhaXIgVGhlIGtleSB0byBzaWduIHRoZSB0cmFuc2FjdGlvbiB3aXRoXG4gICAqL1xuICBhc3luYyBzaWduKGtleVBhaXI6IEtleVBhaXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuX3RyYW5zYWN0aW9uRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdObyB0cmFuc2FjdGlvbiBkYXRhIHRvIHNpZ24nKTtcbiAgICB9XG4gICAgaWYgKCFrZXlQYWlyLmdldEtleXMoKS5wcnYpIHtcbiAgICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5fdHJhbnNhY3Rpb25EYXRhLnNpZ24oa2V5UGFpcik7XG4gICAgY29uc3QgdHhEYXRhID0gdGhpcy5fdHJhbnNhY3Rpb25EYXRhLnRvSnNvbigpO1xuICAgIGlmICh0eERhdGEuaWQpIHtcbiAgICAgIHRoaXMuX2lkID0gdHhEYXRhLmlkO1xuICAgIH1cbiAgICB0aGlzLl9zaWduYXR1cmVzLnB1c2godG9TdHJpbmdTaWcoeyB2OiB0eERhdGEudiEsIHI6IHR4RGF0YS5yISwgczogdHhEYXRhLnMhIH0pKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB0b0Jyb2FkY2FzdEZvcm1hdCgpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbkRhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbkRhdGEudG9TZXJpYWxpemVkKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignTm8gdHJhbnNhY3Rpb24gZGF0YSB0byBmb3JtYXQnKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB0b0pzb24oKTogVHhEYXRhIHtcbiAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb25EYXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25EYXRhLnRvSnNvbigpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ0VtcHR5IHRyYW5zYWN0aW9uJyk7XG4gIH1cbn1cbiJdfQ==