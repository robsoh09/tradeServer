"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.recoveryBlockchainExplorerQuery = exports.decodeForwarderCreationData = exports.getCreateForwarderParamsAndTypes = exports.getAddressInitDataAllForwarderVersions = exports.getV1AddressInitializationData = exports.getV1WalletInitializationData = exports.getToken = exports.getBufferedByteCode = exports.getRawDecoded = exports.hasSignature = exports.toStringSig = exports.getProxyInitcode = exports.calculateForwarderV1Address = exports.calculateForwarderAddress = exports.hexStringToNumber = exports.numberToHexString = exports.classifyTransaction = exports.decodeFlushTokensData = exports.decodeNativeTransferData = exports.decodeERC1155TransferData = exports.decodeERC721TransferData = exports.decodeTokenTransferData = exports.decodeTransferData = exports.decodeWalletCreationData = exports.isValidAmount = exports.isValidEthAddress = exports.getAddressInitializationData = exports.flushCoinsData = exports.flushTokensData = exports.sendMultiSigTokenData = exports.sendMultiSigData = exports.sign = exports.signInternal = exports.getCommon = void 0;
const buffer_1 = require("buffer");
const superagent_1 = __importDefault(require("superagent"));
const assert_1 = __importDefault(require("assert"));
const ethereumjs_util_1 = require("ethereumjs-util");
const statics_1 = require("@bitgo/statics");
const ethereumjs_abi_1 = __importDefault(require("ethereumjs-abi"));
const common_1 = __importDefault(require("@ethereumjs/common"));
const bn_js_1 = __importDefault(require("bn.js"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const sdk_core_1 = require("@bitgo/sdk-core");
const walletUtil_1 = require("./walletUtil");
const types_1 = require("./types");
/**
 * @param network
 */
function getCommon(network) {
    return common_1.default.forCustomChain(
    // use the mainnet config as a base, override chain ids and network name
    'mainnet', {
        name: network.type,
        networkId: network.chainId,
        chainId: network.chainId,
    }, 'london');
}
exports.getCommon = getCommon;
/**
 * Signs the transaction using the appropriate algorithm
 * and the provided common for the blockchain
 *
 * @param {TxData} transactionData the transaction data to sign
 * @param {KeyPair} keyPair the signer's keypair
 * @param {EthereumCommon} customCommon the network's custom common
 * @returns {string} the transaction signed and encoded
 */
async function signInternal(transactionData, keyPair, customCommon) {
    if (!keyPair.getKeys().prv) {
        throw new sdk_core_1.SigningError('Missing private key');
    }
    const ethTx = types_1.EthTransactionData.fromJson(transactionData, customCommon);
    ethTx.sign(keyPair);
    return ethTx.toSerialized();
}
exports.signInternal = signInternal;
/**
 * Signs the transaction using the appropriate algorithm
 *
 * @param {TxData} transactionData the transaction data to sign
 * @param {KeyPair} keyPair the signer's keypair
 * @returns {string} the transaction signed and encoded
 */
async function sign(transactionData, keyPair) {
    return signInternal(transactionData, keyPair, getCommon(statics_1.coins.get('teth').network));
}
exports.sign = sign;
/**
 * Returns the contract method encoded data
 *
 * @param {string} to destination address
 * @param {number} value Amount to tranfer
 * @param {string} data aditional method call data
 * @param {number} expireTime expiration time for the transaction in seconds
 * @param {number} sequenceId sequence id
 * @param {string} signature signature of the call
 * @returns {string} -- the contract method encoded data
 */
function sendMultiSigData(to, value, data, expireTime, sequenceId, signature) {
    const params = [to, value, (0, ethereumjs_util_1.toBuffer)(data), expireTime, sequenceId, (0, ethereumjs_util_1.toBuffer)(signature)];
    const method = ethereumjs_abi_1.default.methodID('sendMultiSig', walletUtil_1.sendMultiSigTypes);
    const args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.sendMultiSigTypes, params);
    return (0, ethereumjs_util_1.addHexPrefix)(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.sendMultiSigData = sendMultiSigData;
/**
 * Returns the contract method encoded data
 *
 * @param {string} to destination address
 * @param {number} value Amount to tranfer
 * @param {string} tokenContractAddress the address of the erc20 token contract
 * @param {number} expireTime expiration time for the transaction in seconds
 * @param {number} sequenceId sequence id
 * @param {string} signature signature of the call
 * @returns {string} -- the contract method encoded data
 */
function sendMultiSigTokenData(to, value, tokenContractAddress, expireTime, sequenceId, signature) {
    const params = [to, value, tokenContractAddress, expireTime, sequenceId, (0, ethereumjs_util_1.toBuffer)(signature)];
    const method = ethereumjs_abi_1.default.methodID('sendMultiSigToken', walletUtil_1.sendMultiSigTokenTypes);
    const args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.sendMultiSigTokenTypes, params);
    return (0, ethereumjs_util_1.addHexPrefix)(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.sendMultiSigTokenData = sendMultiSigTokenData;
/**
 * Get the data required to make a flush tokens contract call
 *
 * @param forwarderAddress The forwarder address to flush
 * @param tokenAddress The token address to flush from
 */
function flushTokensData(forwarderAddress, tokenAddress, forwarderVersion) {
    let params;
    let method;
    let args;
    if (forwarderVersion >= 4) {
        params = [tokenAddress];
        method = ethereumjs_abi_1.default.methodID('flushTokens', walletUtil_1.flushTokensTypesv4);
        args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.flushTokensTypesv4, params);
    }
    else {
        params = [forwarderAddress, tokenAddress];
        method = ethereumjs_abi_1.default.methodID('flushForwarderTokens', walletUtil_1.flushTokensTypes);
        args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.flushTokensTypes, params);
    }
    return (0, ethereumjs_util_1.addHexPrefix)(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.flushTokensData = flushTokensData;
/**
 * Get the data required to make a flush native coins contract call
 */
function flushCoinsData() {
    const params = [];
    const method = ethereumjs_abi_1.default.methodID('flush', walletUtil_1.flushCoinsTypes);
    const args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.flushCoinsTypes, params);
    return (0, ethereumjs_util_1.addHexPrefix)(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.flushCoinsData = flushCoinsData;
/**
 * Returns the create forwarder method calling data
 *
 * @returns {string} - the createForwarder method encoded
 */
function getAddressInitializationData() {
    return walletUtil_1.createForwarderMethodId;
}
exports.getAddressInitializationData = getAddressInitializationData;
/**
 * Returns whether or not the string is a valid Eth address
 *
 * @param {string} address - the tx hash to validate
 * @returns {boolean} - the validation result
 */
function isValidEthAddress(address) {
    return (0, ethereumjs_util_1.isValidAddress)(address);
}
exports.isValidEthAddress = isValidEthAddress;
/**
 * Returns whether or not the string is a valid amount number
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
function isValidAmount(amount) {
    const bigNumberAmount = new bignumber_js_1.default(amount);
    return bigNumberAmount.isInteger() && bigNumberAmount.isGreaterThanOrEqualTo(0);
}
exports.isValidAmount = isValidAmount;
/**
 * Returns the smart contract encoded data
 *
 * @param {string} data The wallet creation data to decode
 * @returns {string[]} - The list of signer addresses
 */
function decodeWalletCreationData(data) {
    if (!(data.startsWith(walletUtil_1.walletInitializationFirstBytes) || data.startsWith(walletUtil_1.v1CreateWalletMethodId))) {
        throw new sdk_core_1.BuildTransactionError(`Invalid wallet bytecode: ${data}`);
    }
    if (data.startsWith(walletUtil_1.walletInitializationFirstBytes)) {
        const dataBuffer = buffer_1.Buffer.from(data.slice(2), 'hex');
        // the last 160 bytes contain the serialized address array
        const serializedSigners = dataBuffer.slice(-160);
        const resultEncodedParameters = ethereumjs_abi_1.default.rawDecode(walletUtil_1.walletSimpleConstructor, serializedSigners);
        if (resultEncodedParameters.length !== 1) {
            throw new sdk_core_1.BuildTransactionError(`Could not decode wallet constructor bytecode: ${resultEncodedParameters}`);
        }
        const addresses = resultEncodedParameters[0];
        if (addresses.length !== 3) {
            throw new sdk_core_1.BuildTransactionError(`invalid number of addresses in parsed constructor: ${addresses}`);
        }
        // sometimes ethereumjs-abi removes 0 padding at the start of addresses,
        // so we should pad until they are the standard 20 bytes
        const paddedAddresses = addresses.map((address) => (0, ethereumjs_util_1.stripHexPrefix)(address.toString('hex')).padStart(40, '0'));
        return { owners: paddedAddresses.map((address) => (0, ethereumjs_util_1.addHexPrefix)(address)) };
    }
    else {
        const decodedDataForWalletCreation = getRawDecoded(walletUtil_1.createV1WalletTypes, getBufferedByteCode(walletUtil_1.v1CreateWalletMethodId, data));
        const addresses = decodedDataForWalletCreation[0];
        const saltBuffer = decodedDataForWalletCreation[1];
        const salt = (0, ethereumjs_util_1.bufferToHex)(saltBuffer);
        const paddedAddresses = addresses.map((address) => (0, ethereumjs_util_1.stripHexPrefix)(address.toString()).padStart(40, '0'));
        const owners = paddedAddresses.map((address) => (0, ethereumjs_util_1.addHexPrefix)(address));
        return {
            owners,
            salt,
        };
    }
}
exports.decodeWalletCreationData = decodeWalletCreationData;
/**
 * Decode the given ABI-encoded transfer data and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
function decodeTransferData(data) {
    if (data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        return decodeNativeTransferData(data);
    }
    else if (data.startsWith(walletUtil_1.sendMultisigTokenMethodId)) {
        return decodeTokenTransferData(data);
    }
    else {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
}
exports.decodeTransferData = decodeTransferData;
/**
 * Decode the given ABI-encoded transfer data for the sendMultisigToken function and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed token transfer data
 */
function decodeTokenTransferData(data) {
    if (!data.startsWith(walletUtil_1.sendMultisigTokenMethodId)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    const [to, amount, tokenContractAddress, expireTime, sequenceId, signature] = getRawDecoded(walletUtil_1.sendMultiSigTokenTypes, getBufferedByteCode(walletUtil_1.sendMultisigTokenMethodId, data));
    return {
        to: (0, ethereumjs_util_1.addHexPrefix)(to),
        amount: new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(amount)).toFixed(),
        expireTime: (0, ethereumjs_util_1.bufferToInt)(expireTime),
        sequenceId: (0, ethereumjs_util_1.bufferToInt)(sequenceId),
        signature: (0, ethereumjs_util_1.bufferToHex)(signature),
        tokenContractAddress: (0, ethereumjs_util_1.addHexPrefix)(tokenContractAddress),
    };
}
exports.decodeTokenTransferData = decodeTokenTransferData;
function decodeERC721TransferData(data) {
    if (!data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    const [to, amount, internalData, expireTime, sequenceId, signature] = getRawDecoded(walletUtil_1.sendMultiSigTypes, getBufferedByteCode(walletUtil_1.sendMultisigMethodId, data));
    const internalDataHex = (0, ethereumjs_util_1.bufferToHex)(internalData);
    if (!internalDataHex.startsWith(walletUtil_1.ERC721SafeTransferTypeMethodId)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    const [from, receiver, tokenId, userSentData] = getRawDecoded(walletUtil_1.ERC721SafeTransferTypes, getBufferedByteCode(walletUtil_1.ERC721SafeTransferTypeMethodId, internalDataHex));
    return {
        to: (0, ethereumjs_util_1.addHexPrefix)(receiver),
        from: (0, ethereumjs_util_1.addHexPrefix)(from),
        expireTime: (0, ethereumjs_util_1.bufferToInt)(expireTime),
        amount: new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(amount)).toFixed(),
        tokenId: new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(tokenId)).toFixed(),
        sequenceId: (0, ethereumjs_util_1.bufferToInt)(sequenceId),
        signature: (0, ethereumjs_util_1.bufferToHex)(signature),
        tokenContractAddress: (0, ethereumjs_util_1.addHexPrefix)(to),
        userData: (0, ethereumjs_util_1.bufferToHex)(userSentData),
    };
}
exports.decodeERC721TransferData = decodeERC721TransferData;
function decodeERC1155TransferData(data) {
    let from, receiver, userSentData;
    let tokenIds;
    let values;
    if (!data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    const [to, amount, internalData, expireTime, sequenceId, signature] = getRawDecoded(walletUtil_1.sendMultiSigTypes, getBufferedByteCode(walletUtil_1.sendMultisigMethodId, data));
    const internalDataHex = (0, ethereumjs_util_1.bufferToHex)(internalData);
    if (internalDataHex.startsWith(walletUtil_1.ERC1155SafeTransferTypeMethodId)) {
        let tokenId;
        let value;
        [from, receiver, tokenId, value, userSentData] = getRawDecoded(walletUtil_1.ERC1155SafeTransferTypes, getBufferedByteCode(walletUtil_1.ERC1155SafeTransferTypeMethodId, internalDataHex));
        tokenIds = [new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(tokenId)).toFixed()];
        values = [new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(value)).toFixed()];
    }
    else if ((0, ethereumjs_util_1.bufferToHex)(internalData).startsWith(walletUtil_1.ERC1155BatchTransferTypeMethodId)) {
        let tempTokenIds, tempValues;
        [from, receiver, tempTokenIds, tempValues, userSentData] = getRawDecoded(walletUtil_1.ERC1155BatchTransferTypes, getBufferedByteCode(walletUtil_1.ERC1155BatchTransferTypeMethodId, internalDataHex));
        tokenIds = tempTokenIds.map((x) => new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(x)).toFixed());
        values = tempValues.map((x) => new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(x)).toFixed());
    }
    else {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    return {
        to: (0, ethereumjs_util_1.addHexPrefix)(receiver),
        from: (0, ethereumjs_util_1.addHexPrefix)(from),
        expireTime: (0, ethereumjs_util_1.bufferToInt)(expireTime),
        amount: new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(amount)).toFixed(),
        tokenIds,
        values,
        sequenceId: (0, ethereumjs_util_1.bufferToInt)(sequenceId),
        signature: (0, ethereumjs_util_1.bufferToHex)(signature),
        tokenContractAddress: (0, ethereumjs_util_1.addHexPrefix)(to),
        userData: userSentData,
    };
}
exports.decodeERC1155TransferData = decodeERC1155TransferData;
/**
 * Decode the given ABI-encoded transfer data for the sendMultisig function and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
function decodeNativeTransferData(data) {
    if (!data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    const [to, amount, internalData, expireTime, sequenceId, signature] = getRawDecoded(walletUtil_1.sendMultiSigTypes, getBufferedByteCode(walletUtil_1.sendMultisigMethodId, data));
    return {
        to: (0, ethereumjs_util_1.addHexPrefix)(to),
        amount: new bignumber_js_1.default((0, ethereumjs_util_1.bufferToHex)(amount)).toFixed(),
        expireTime: (0, ethereumjs_util_1.bufferToInt)(expireTime),
        sequenceId: (0, ethereumjs_util_1.bufferToInt)(sequenceId),
        signature: (0, ethereumjs_util_1.bufferToHex)(signature),
        data: (0, ethereumjs_util_1.bufferToHex)(internalData),
    };
}
exports.decodeNativeTransferData = decodeNativeTransferData;
/**
 * Decode the given ABI-encoded flush tokens data and return parsed fields
 *
 * @param data The data to decode
 * @param to Optional to parameter of tx
 * @returns parsed transfer data
 */
function decodeFlushTokensData(data, to) {
    if (data.startsWith(walletUtil_1.flushForwarderTokensMethodId)) {
        const [forwarderAddress, tokenAddress] = getRawDecoded(walletUtil_1.flushTokensTypes, getBufferedByteCode(walletUtil_1.flushForwarderTokensMethodId, data));
        return {
            forwarderAddress: (0, ethereumjs_util_1.addHexPrefix)(forwarderAddress),
            tokenAddress: (0, ethereumjs_util_1.addHexPrefix)(tokenAddress),
        };
    }
    else if (data.startsWith(walletUtil_1.flushForwarderTokensMethodIdV4)) {
        const [tokenAddress] = getRawDecoded(walletUtil_1.flushTokensTypesv4, getBufferedByteCode(walletUtil_1.flushForwarderTokensMethodIdV4, data));
        if (!to) {
            throw new sdk_core_1.BuildTransactionError(`Missing to address: ${to}`);
        }
        return {
            forwarderAddress: to,
            tokenAddress: (0, ethereumjs_util_1.addHexPrefix)(tokenAddress),
            forwarderVersion: 4,
        };
    }
    else {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
}
exports.decodeFlushTokensData = decodeFlushTokensData;
/**
 * Classify the given transaction data based as a transaction type.
 * ETH transactions are defined by the first 8 bytes of the transaction data, also known as the method id
 *
 * @param {string} data The data to classify the transaction with
 * @returns {TransactionType} The classified transaction type
 */
function classifyTransaction(data) {
    if (data.length < 10) {
        // contract calls must have at least 4 bytes (method id) and '0x'
        // if it doesn't have enough data to be a contract call it must be a single sig send
        return sdk_core_1.TransactionType.SingleSigSend;
    }
    // TODO(STLX-1970): validate if we are going to constraint to some methods allowed
    let transactionType = transactionTypesMap[data.slice(0, 10).toLowerCase()];
    if (transactionType === undefined) {
        transactionType = sdk_core_1.TransactionType.ContractCall;
    }
    return transactionType;
}
exports.classifyTransaction = classifyTransaction;
/**
 * A transaction types map according to the starting part of the encoded data
 */
const transactionTypesMap = {
    [walletUtil_1.walletInitializationFirstBytes]: sdk_core_1.TransactionType.WalletInitialization,
    [walletUtil_1.recoveryWalletInitializationFirstBytes]: sdk_core_1.TransactionType.RecoveryWalletDeployment,
    [walletUtil_1.v1CreateWalletMethodId]: sdk_core_1.TransactionType.WalletInitialization,
    [walletUtil_1.createForwarderMethodId]: sdk_core_1.TransactionType.AddressInitialization,
    [walletUtil_1.v1CreateForwarderMethodId]: sdk_core_1.TransactionType.AddressInitialization,
    [walletUtil_1.v4CreateForwarderMethodId]: sdk_core_1.TransactionType.AddressInitialization,
    [walletUtil_1.sendMultisigMethodId]: sdk_core_1.TransactionType.Send,
    [walletUtil_1.flushForwarderTokensMethodId]: sdk_core_1.TransactionType.FlushTokens,
    [walletUtil_1.flushForwarderTokensMethodIdV4]: sdk_core_1.TransactionType.FlushTokens,
    [walletUtil_1.flushCoinsMethodId]: sdk_core_1.TransactionType.FlushCoins,
    [walletUtil_1.sendMultisigTokenMethodId]: sdk_core_1.TransactionType.Send,
    [sdk_core_1.LockMethodId]: sdk_core_1.TransactionType.StakingLock,
    [sdk_core_1.VoteMethodId]: sdk_core_1.TransactionType.StakingVote,
    [sdk_core_1.ActivateMethodId]: sdk_core_1.TransactionType.StakingActivate,
    [sdk_core_1.UnvoteMethodId]: sdk_core_1.TransactionType.StakingUnvote,
    [sdk_core_1.UnlockMethodId]: sdk_core_1.TransactionType.StakingUnlock,
    [sdk_core_1.WithdrawMethodId]: sdk_core_1.TransactionType.StakingWithdraw,
};
/**
 *
 * @param {number} num number to be converted to hex
 * @returns {string} the hex number
 */
function numberToHexString(num) {
    const hex = num.toString(16);
    return hex.length % 2 === 0 ? '0x' + hex : '0x0' + hex;
}
exports.numberToHexString = numberToHexString;
/**
 *
 * @param {string} hex The hex string to be converted
 * @returns {number} the resulting number
 */
function hexStringToNumber(hex) {
    return parseInt(hex.slice(2), 16);
}
exports.hexStringToNumber = hexStringToNumber;
/**
 * Generates an address of the forwarder address to be deployed
 *
 * @param {string} contractAddress the address which is creating this new address
 * @param {number} contractCounter the nonce of the contract address
 * @returns {string} the calculated forwarder contract address
 */
function calculateForwarderAddress(contractAddress, contractCounter) {
    const forwarderAddress = (0, ethereumjs_util_1.generateAddress)(buffer_1.Buffer.from((0, ethereumjs_util_1.stripHexPrefix)(contractAddress), 'hex'), buffer_1.Buffer.from((0, ethereumjs_util_1.padToEven)((0, ethereumjs_util_1.stripHexPrefix)(numberToHexString(contractCounter))), 'hex'));
    return (0, ethereumjs_util_1.addHexPrefix)(forwarderAddress.toString('hex'));
}
exports.calculateForwarderAddress = calculateForwarderAddress;
/**
 * Calculate the forwarder v1 address that will be generated if `creatorAddress` creates it with salt `salt`
 * and initcode `inicode using the create2 opcode
 * @param {string} creatorAddress The address that is sending the tx to create a new address, hex string
 * @param {string} salt The salt to create the address with using create2, hex string
 * @param {string} initcode The initcode that will be deployed to the address, hex string
 * @return {string} The calculated address
 */
function calculateForwarderV1Address(creatorAddress, salt, initcode) {
    const forwarderV1Address = (0, ethereumjs_util_1.generateAddress2)(buffer_1.Buffer.from((0, ethereumjs_util_1.stripHexPrefix)(creatorAddress), 'hex'), buffer_1.Buffer.from((0, ethereumjs_util_1.stripHexPrefix)(salt), 'hex'), buffer_1.Buffer.from((0, ethereumjs_util_1.padToEven)((0, ethereumjs_util_1.stripHexPrefix)(initcode)), 'hex'));
    return (0, ethereumjs_util_1.addHexPrefix)(forwarderV1Address.toString('hex'));
}
exports.calculateForwarderV1Address = calculateForwarderV1Address;
/**
 * Take the implementation address for the proxy contract, and get the binary initcode for the associated proxy
 * @param {string} implementationAddress The address of the implementation contract for the proxy
 * @return {string} Binary hex string of the proxy
 */
function getProxyInitcode(implementationAddress) {
    const target = (0, ethereumjs_util_1.stripHexPrefix)(implementationAddress.toLowerCase()).padStart(40, '0');
    // bytecode of the proxy, from:
    // https://github.com/BitGo/eth-multisig-v4/blob/d546a937f90f93e83b3423a5bf933d1d77c677c3/contracts/CloneFactory.sol#L42-L56
    return `0x3d602d80600a3d3981f3363d3d373d3d3d363d73${target}5af43d82803e903d91602b57fd5bf3`;
}
exports.getProxyInitcode = getProxyInitcode;
/**
 * Convert the given signature parts to a string representation
 *
 * @param {SignatureParts} sig The signature to convert to string
 * @returns {string} String representation of the signature
 */
function toStringSig(sig) {
    return (0, ethereumjs_util_1.bufferToHex)(buffer_1.Buffer.concat([
        (0, ethereumjs_util_1.setLengthLeft)(buffer_1.Buffer.from((0, ethereumjs_util_1.stripHexPrefix)(sig.r), 'hex'), 32),
        (0, ethereumjs_util_1.setLengthLeft)(buffer_1.Buffer.from((0, ethereumjs_util_1.stripHexPrefix)(sig.s), 'hex'), 32),
        (0, ethereumjs_util_1.toBuffer)(sig.v),
    ]));
}
exports.toStringSig = toStringSig;
/**
 * Return whether or not the given tx data has a signature
 *
 * @param {TxData} txData The transaction data to check for signature
 * @returns {boolean} true if the tx has a signature, else false
 */
function hasSignature(txData) {
    return (txData.v !== undefined &&
        txData.r !== undefined &&
        txData.s !== undefined &&
        txData.v.length > 0 &&
        txData.r.length > 0 &&
        txData.s.length > 0);
}
exports.hasSignature = hasSignature;
/**
 * Get the raw data decoded for some types
 *
 * @param {string[]} types ABI types definition
 * @param {Buffer} serializedArgs encoded args
 * @returns {Buffer[]} the decoded raw
 */
function getRawDecoded(types, serializedArgs) {
    function normalize(v, i) {
        if (bn_js_1.default.isBN(v)) {
            return v;
        }
        else if (typeof v === 'string' || buffer_1.Buffer.isBuffer(v)) {
            return v;
        }
        else if (Array.isArray(v)) {
            return v.map(normalize);
        }
        else {
            throw new Error(`For ${types}[${i}] got ${typeof v}`);
        }
    }
    return ethereumjs_abi_1.default.rawDecode(types, serializedArgs).map(normalize);
}
exports.getRawDecoded = getRawDecoded;
/**
 * Get the buffered bytecode from rawData using a methodId as delimiter
 *
 * @param {string} methodId the hex encoded method Id
 * @param {string} rawData the hex encoded raw data
 * @returns {Buffer} data buffered bytecode
 */
function getBufferedByteCode(methodId, rawData) {
    const splitBytecode = rawData.split(methodId);
    if (splitBytecode.length !== 2) {
        throw new sdk_core_1.BuildTransactionError(`Invalid send bytecode: ${rawData}`);
    }
    if (splitBytecode[1].length % 2 !== 0) {
        throw new sdk_core_1.BuildTransactionError(`Invalid send bytecode: ${rawData} (wrong lenght)`);
    }
    return buffer_1.Buffer.from(splitBytecode[1], 'hex');
}
exports.getBufferedByteCode = getBufferedByteCode;
/**
 * Get the statics coin object matching a given contract address if it exists
 *
 * @param tokenContractAddress The contract address to match against
 * @param network - the coin network
 * @param family - the coin family
 * @returns statics BaseCoin object for the matching token
 */
function getToken(tokenContractAddress, network, family) {
    // filter the coins array to find the token with the matching contract address, network and coin family
    // coin family is needed to avoid causing issues when a token has same contract address on two different chains
    const tokens = statics_1.coins.filter((coin) => {
        if (coin instanceof statics_1.ContractAddressDefinedToken) {
            return (coin.network.type === network.type &&
                coin.family === family &&
                coin.contractAddress.toLowerCase() === tokenContractAddress.toLowerCase());
        }
        return false;
    });
    // if length of tokens is 1, return the first, else return undefined
    // Can't directly index into tokens, or call `length`, so we use map to get an array
    const tokensArray = tokens.map((token) => token);
    if (tokensArray.length >= 1) {
        // there should never be two tokens with the same contract address, so we assert that here
        (0, assert_1.default)(tokensArray.length === 1);
        return tokensArray[0];
    }
    return undefined;
}
exports.getToken = getToken;
/**
 * Returns the create wallet method calling data for v1 wallets
 *
 * @param {string[]} walletOwners - wallet owner addresses for wallet initialization transactions
 * @param {string} salt - The salt for wallet initialization transactions
 * @returns {string} - the createWallet method encoded
 */
function getV1WalletInitializationData(walletOwners, salt) {
    const saltBuffer = (0, ethereumjs_util_1.setLengthLeft)((0, ethereumjs_util_1.toBuffer)(salt), 32);
    const params = [walletOwners, saltBuffer];
    const method = ethereumjs_abi_1.default.methodID('createWallet', walletUtil_1.createV1WalletTypes);
    const args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.createV1WalletTypes, params);
    return (0, ethereumjs_util_1.addHexPrefix)(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.getV1WalletInitializationData = getV1WalletInitializationData;
/**
 * Returns the create address method calling data for v1, v2, v4 forwarders
 *
 * @param {string} baseAddress - The address of the wallet contract
 * @param {string} salt - The salt for address initialization transactions
 * @param {string} feeAddress - The fee address for the enterprise
 * @returns {string} - the createForwarder method encoded
 */
function getV1AddressInitializationData(baseAddress, salt, feeAddress) {
    const saltBuffer = (0, ethereumjs_util_1.setLengthLeft)((0, ethereumjs_util_1.toBuffer)(salt), 32);
    const { createForwarderParams, createForwarderTypes } = getCreateForwarderParamsAndTypes(baseAddress, saltBuffer, feeAddress);
    const method = ethereumjs_abi_1.default.methodID('createForwarder', createForwarderTypes);
    const args = ethereumjs_abi_1.default.rawEncode(createForwarderTypes, createForwarderParams);
    return (0, ethereumjs_util_1.addHexPrefix)(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.getV1AddressInitializationData = getV1AddressInitializationData;
/**
 * Returns the create address method calling data for all forwarder versions
 *
 * @param {number} forwarderVersion - The version of the forwarder to create
 * @param {string} baseAddress - The address of the wallet contract
 * @param {string} salt - The salt for address initialization transactions
 * @param {string} feeAddress - The fee address for the enterprise
 * @returns {string} - the createForwarder method encoded
 *
 */
function getAddressInitDataAllForwarderVersions(forwarderVersion, baseAddress, salt, feeAddress) {
    if (forwarderVersion === walletUtil_1.defaultForwarderVersion) {
        return getAddressInitializationData();
    }
    else {
        return getV1AddressInitializationData(baseAddress, salt, feeAddress);
    }
}
exports.getAddressInitDataAllForwarderVersions = getAddressInitDataAllForwarderVersions;
/**
 * Returns the createForwarderTypes and createForwarderParams for all forwarder versions
 *
 * @param {string} baseAddress - The address of the wallet contract
 * @param {Buffer} saltBuffer - The salt for address initialization transaction
 * @param {string} feeAddress - The fee address for the enterprise
 * @returns {createForwarderParams: (string | Buffer)[], createForwarderTypes: string[]}
 */
function getCreateForwarderParamsAndTypes(baseAddress, saltBuffer, feeAddress) {
    let createForwarderParams = [baseAddress, saltBuffer];
    let createForwarderTypes = walletUtil_1.createV1ForwarderTypes;
    if (feeAddress) {
        createForwarderParams = [baseAddress, feeAddress, saltBuffer];
        createForwarderTypes = walletUtil_1.createV4ForwarderTypes;
    }
    return { createForwarderParams, createForwarderTypes };
}
exports.getCreateForwarderParamsAndTypes = getCreateForwarderParamsAndTypes;
/**
 * Decode the given ABI-encoded create forwarder data and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
function decodeForwarderCreationData(data) {
    if (!(data.startsWith(walletUtil_1.v4CreateForwarderMethodId) ||
        data.startsWith(walletUtil_1.v1CreateForwarderMethodId) ||
        data.startsWith(walletUtil_1.createForwarderMethodId))) {
        throw new sdk_core_1.BuildTransactionError(`Invalid address bytecode: ${data}`);
    }
    if (data.startsWith(walletUtil_1.createForwarderMethodId)) {
        return {
            baseAddress: undefined,
            addressCreationSalt: undefined,
            feeAddress: undefined,
        };
    }
    else if (data.startsWith(walletUtil_1.v1CreateForwarderMethodId)) {
        const [baseAddress, saltBuffer] = getRawDecoded(walletUtil_1.createV1ForwarderTypes, getBufferedByteCode(walletUtil_1.v1CreateForwarderMethodId, data));
        return {
            baseAddress: (0, ethereumjs_util_1.addHexPrefix)(baseAddress),
            addressCreationSalt: (0, ethereumjs_util_1.bufferToHex)(saltBuffer),
            feeAddress: undefined,
        };
    }
    else {
        const [baseAddress, feeAddress, saltBuffer] = getRawDecoded(walletUtil_1.createV4ForwarderTypes, getBufferedByteCode(walletUtil_1.v4CreateForwarderMethodId, data));
        return {
            baseAddress: (0, ethereumjs_util_1.addHexPrefix)(baseAddress),
            addressCreationSalt: (0, ethereumjs_util_1.bufferToHex)(saltBuffer),
            feeAddress: (0, ethereumjs_util_1.addHexPrefix)(feeAddress),
        };
    }
}
exports.decodeForwarderCreationData = decodeForwarderCreationData;
/**
 * Make a query to explorer for information such as balance, token balance, solidity calls
 * @param {Object} query key-value pairs of parameters to append after /api
 * @param {string} token the API token to use for the request
 * @param {string} explorerUrl the URL of the explorer
 * @returns {Promise<Object>} response from explorer
 */
async function recoveryBlockchainExplorerQuery(query, explorerUrl, token) {
    if (token) {
        query.apikey = token;
    }
    const response = await superagent_1.default.get(`${explorerUrl}/api`).query(query);
    if (!response.ok) {
        throw new Error('could not reach explorer');
    }
    if (response.body.status === '0' && response.body.message === 'NOTOK') {
        throw new Error('Explorer rate limit reached');
    }
    return response.body;
}
exports.recoveryBlockchainExplorerQuery = recoveryBlockchainExplorerQuery;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG1DQUFnQztBQUNoQyw0REFBaUM7QUFDakMsb0RBQTRCO0FBQzVCLHFEQVd5QjtBQUN6Qiw0Q0FBNEc7QUFDNUcsb0VBQXlDO0FBQ3pDLGdFQUFnRDtBQUNoRCxrREFBdUI7QUFDdkIsZ0VBQXFDO0FBQ3JDLDhDQVV5QjtBQWV6Qiw2Q0E0QnNCO0FBQ3RCLG1DQUE2QztBQUU3Qzs7R0FFRztBQUNILFNBQWdCLFNBQVMsQ0FBQyxPQUF3QjtJQUNoRCxPQUFPLGdCQUFjLENBQUMsY0FBYztJQUNsQyx3RUFBd0U7SUFDeEUsU0FBUyxFQUNUO1FBQ0UsSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJO1FBQ2xCLFNBQVMsRUFBRSxPQUFPLENBQUMsT0FBTztRQUMxQixPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU87S0FDekIsRUFDRCxRQUFRLENBQ1QsQ0FBQztBQUNKLENBQUM7QUFYRCw4QkFXQztBQUVEOzs7Ozs7OztHQVFHO0FBQ0ksS0FBSyxVQUFVLFlBQVksQ0FDaEMsZUFBdUIsRUFDdkIsT0FBZ0IsRUFDaEIsWUFBNEI7SUFFNUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLEVBQUU7UUFDMUIsTUFBTSxJQUFJLHVCQUFZLENBQUMscUJBQXFCLENBQUMsQ0FBQztLQUMvQztJQUNELE1BQU0sS0FBSyxHQUFHLDBCQUFrQixDQUFDLFFBQVEsQ0FBQyxlQUFlLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDekUsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNwQixPQUFPLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQztBQUM5QixDQUFDO0FBWEQsb0NBV0M7QUFFRDs7Ozs7O0dBTUc7QUFDSSxLQUFLLFVBQVUsSUFBSSxDQUFDLGVBQXVCLEVBQUUsT0FB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O1FBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQztLQUM3QztJQUVELElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLEtBQUssR0FBRyxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxLQUFLLE9BQU8sRUFBRTtRQUNyRSxNQUFNLElBQUksS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7S0FDaEQ7SUFDRCxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUM7QUFDdkIsQ0FBQztBQWxCRCwwRUFrQkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuaW1wb3J0IHJlcXVlc3QgZnJvbSAnc3VwZXJhZ2VudCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge1xuICBhZGRIZXhQcmVmaXgsXG4gIGJ1ZmZlclRvSGV4LFxuICBidWZmZXJUb0ludCxcbiAgZ2VuZXJhdGVBZGRyZXNzLFxuICBpc1ZhbGlkQWRkcmVzcyxcbiAgc2V0TGVuZ3RoTGVmdCxcbiAgc3RyaXBIZXhQcmVmaXgsXG4gIHRvQnVmZmVyLFxuICBnZW5lcmF0ZUFkZHJlc3MyLFxuICBwYWRUb0V2ZW4sXG59IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5pbXBvcnQgeyBCYXNlQ29pbiwgQmFzZU5ldHdvcmssIGNvaW5zLCBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4sIEV0aGVyZXVtTmV0d29yayB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCBFdGhlcmV1bUFiaSBmcm9tICdldGhlcmV1bWpzLWFiaSc7XG5pbXBvcnQgRXRoZXJldW1Db21tb24gZnJvbSAnQGV0aGVyZXVtanMvY29tbW9uJztcbmltcG9ydCBCTiBmcm9tICdibi5qcyc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQge1xuICBBY3RpdmF0ZU1ldGhvZElkLFxuICBCdWlsZFRyYW5zYWN0aW9uRXJyb3IsXG4gIExvY2tNZXRob2RJZCxcbiAgU2lnbmluZ0Vycm9yLFxuICBUcmFuc2FjdGlvblR5cGUsXG4gIFVubG9ja01ldGhvZElkLFxuICBVbnZvdGVNZXRob2RJZCxcbiAgVm90ZU1ldGhvZElkLFxuICBXaXRoZHJhd01ldGhvZElkLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuXG5pbXBvcnQge1xuICBFUkMxMTU1VHJhbnNmZXJEYXRhLFxuICBFUkM3MjFUcmFuc2ZlckRhdGEsXG4gIEZsdXNoVG9rZW5zRGF0YSxcbiAgTmF0aXZlVHJhbnNmZXJEYXRhLFxuICBTaWduYXR1cmVQYXJ0cyxcbiAgVG9rZW5UcmFuc2ZlckRhdGEsXG4gIFRyYW5zZmVyRGF0YSxcbiAgVHhEYXRhLFxuICBXYWxsZXRJbml0aWFsaXphdGlvbkRhdGEsXG4gIEZvcndhcmRlckluaXRpYWxpemF0aW9uRGF0YSxcbn0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLi9rZXlQYWlyJztcbmltcG9ydCB7XG4gIGNyZWF0ZUZvcndhcmRlck1ldGhvZElkLFxuICBFUkMxMTU1QmF0Y2hUcmFuc2ZlclR5cGVNZXRob2RJZCxcbiAgRVJDMTE1NUJhdGNoVHJhbnNmZXJUeXBlcyxcbiAgRVJDMTE1NVNhZmVUcmFuc2ZlclR5cGVNZXRob2RJZCxcbiAgRVJDMTE1NVNhZmVUcmFuc2ZlclR5cGVzLFxuICBFUkM3MjFTYWZlVHJhbnNmZXJUeXBlTWV0aG9kSWQsXG4gIEVSQzcyMVNhZmVUcmFuc2ZlclR5cGVzLFxuICBmbHVzaENvaW5zTWV0aG9kSWQsXG4gIGZsdXNoQ29pbnNUeXBlcyxcbiAgZmx1c2hGb3J3YXJkZXJUb2tlbnNNZXRob2RJZCxcbiAgZmx1c2hUb2tlbnNUeXBlcyxcbiAgc2VuZE11bHRpc2lnTWV0aG9kSWQsXG4gIHNlbmRNdWx0aXNpZ1Rva2VuTWV0aG9kSWQsXG4gIHNlbmRNdWx0aVNpZ1Rva2VuVHlwZXMsXG4gIHNlbmRNdWx0aVNpZ1R5cGVzLFxuICB3YWxsZXRJbml0aWFsaXphdGlvbkZpcnN0Qnl0ZXMsXG4gIHYxQ3JlYXRlRm9yd2FyZGVyTWV0aG9kSWQsXG4gIHdhbGxldFNpbXBsZUNvbnN0cnVjdG9yLFxuICBjcmVhdGVWMVdhbGxldFR5cGVzLFxuICB2MUNyZWF0ZVdhbGxldE1ldGhvZElkLFxuICBjcmVhdGVWMUZvcndhcmRlclR5cGVzLFxuICByZWNvdmVyeVdhbGxldEluaXRpYWxpemF0aW9uRmlyc3RCeXRlcyxcbiAgZGVmYXVsdEZvcndhcmRlclZlcnNpb24sXG4gIGNyZWF0ZVY0Rm9yd2FyZGVyVHlwZXMsXG4gIHY0Q3JlYXRlRm9yd2FyZGVyTWV0aG9kSWQsXG4gIGZsdXNoVG9rZW5zVHlwZXN2NCxcbiAgZmx1c2hGb3J3YXJkZXJUb2tlbnNNZXRob2RJZFY0LFxufSBmcm9tICcuL3dhbGxldFV0aWwnO1xuaW1wb3J0IHsgRXRoVHJhbnNhY3Rpb25EYXRhIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogQHBhcmFtIG5ldHdvcmtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbW1vbihuZXR3b3JrOiBFdGhlcmV1bU5ldHdvcmspOiBFdGhlcmV1bUNvbW1vbiB7XG4gIHJldHVybiBFdGhlcmV1bUNvbW1vbi5mb3JDdXN0b21DaGFpbihcbiAgICAvLyB1c2UgdGhlIG1haW5uZXQgY29uZmlnIGFzIGEgYmFzZSwgb3ZlcnJpZGUgY2hhaW4gaWRzIGFuZCBuZXR3b3JrIG5hbWVcbiAgICAnbWFpbm5ldCcsXG4gICAge1xuICAgICAgbmFtZTogbmV0d29yay50eXBlLFxuICAgICAgbmV0d29ya0lkOiBuZXR3b3JrLmNoYWluSWQsXG4gICAgICBjaGFpbklkOiBuZXR3b3JrLmNoYWluSWQsXG4gICAgfSxcbiAgICAnbG9uZG9uJ1xuICApO1xufVxuXG4vKipcbiAqIFNpZ25zIHRoZSB0cmFuc2FjdGlvbiB1c2luZyB0aGUgYXBwcm9wcmlhdGUgYWxnb3JpdGhtXG4gKiBhbmQgdGhlIHByb3ZpZGVkIGNvbW1vbiBmb3IgdGhlIGJsb2NrY2hhaW5cbiAqXG4gKiBAcGFyYW0ge1R4RGF0YX0gdHJhbnNhY3Rpb25EYXRhIHRoZSB0cmFuc2FjdGlvbiBkYXRhIHRvIHNpZ25cbiAqIEBwYXJhbSB7S2V5UGFpcn0ga2V5UGFpciB0aGUgc2lnbmVyJ3Mga2V5cGFpclxuICogQHBhcmFtIHtFdGhlcmV1bUNvbW1vbn0gY3VzdG9tQ29tbW9uIHRoZSBuZXR3b3JrJ3MgY3VzdG9tIGNvbW1vblxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHRyYW5zYWN0aW9uIHNpZ25lZCBhbmQgZW5jb2RlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbkludGVybmFsKFxuICB0cmFuc2FjdGlvbkRhdGE6IFR4RGF0YSxcbiAga2V5UGFpcjogS2V5UGFpcixcbiAgY3VzdG9tQ29tbW9uOiBFdGhlcmV1bUNvbW1vblxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgaWYgKCFrZXlQYWlyLmdldEtleXMoKS5wcnYpIHtcbiAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdNaXNzaW5nIHByaXZhdGUga2V5Jyk7XG4gIH1cbiAgY29uc3QgZXRoVHggPSBFdGhUcmFuc2FjdGlvbkRhdGEuZnJvbUpzb24odHJhbnNhY3Rpb25EYXRhLCBjdXN0b21Db21tb24pO1xuICBldGhUeC5zaWduKGtleVBhaXIpO1xuICByZXR1cm4gZXRoVHgudG9TZXJpYWxpemVkKCk7XG59XG5cbi8qKlxuICogU2lnbnMgdGhlIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBhbGdvcml0aG1cbiAqXG4gKiBAcGFyYW0ge1R4RGF0YX0gdHJhbnNhY3Rpb25EYXRhIHRoZSB0cmFuc2FjdGlvbiBkYXRhIHRvIHNpZ25cbiAqIEBwYXJhbSB7S2V5UGFpcn0ga2V5UGFpciB0aGUgc2lnbmVyJ3Mga2V5cGFpclxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHRyYW5zYWN0aW9uIHNpZ25lZCBhbmQgZW5jb2RlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbih0cmFuc2FjdGlvbkRhdGE6IFR4RGF0YSwga2V5UGFpcjogS2V5UGFpcik6IFByb21pc2U8c3RyaW5nPiB7XG4gIHJldHVybiBzaWduSW50ZXJuYWwodHJhbnNhY3Rpb25EYXRhLCBrZXlQYWlyLCBnZXRDb21tb24oY29pbnMuZ2V0KCd0ZXRoJykubmV0d29yayBhcyBFdGhlcmV1bU5ldHdvcmspKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250cmFjdCBtZXRob2QgZW5jb2RlZCBkYXRhXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvIGRlc3RpbmF0aW9uIGFkZHJlc3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBBbW91bnQgdG8gdHJhbmZlclxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgYWRpdGlvbmFsIG1ldGhvZCBjYWxsIGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBpcmVUaW1lIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIHRyYW5zYWN0aW9uIGluIHNlY29uZHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZXF1ZW5jZUlkIHNlcXVlbmNlIGlkXG4gKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlIHNpZ25hdHVyZSBvZiB0aGUgY2FsbFxuICogQHJldHVybnMge3N0cmluZ30gLS0gdGhlIGNvbnRyYWN0IG1ldGhvZCBlbmNvZGVkIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbmRNdWx0aVNpZ0RhdGEoXG4gIHRvOiBzdHJpbmcsXG4gIHZhbHVlOiBzdHJpbmcsXG4gIGRhdGE6IHN0cmluZyxcbiAgZXhwaXJlVGltZTogbnVtYmVyLFxuICBzZXF1ZW5jZUlkOiBudW1iZXIsXG4gIHNpZ25hdHVyZTogc3RyaW5nXG4pOiBzdHJpbmcge1xuICBjb25zdCBwYXJhbXMgPSBbdG8sIHZhbHVlLCB0b0J1ZmZlcihkYXRhKSwgZXhwaXJlVGltZSwgc2VxdWVuY2VJZCwgdG9CdWZmZXIoc2lnbmF0dXJlKV07XG4gIGNvbnN0IG1ldGhvZCA9IEV0aGVyZXVtQWJpLm1ldGhvZElEKCdzZW5kTXVsdGlTaWcnLCBzZW5kTXVsdGlTaWdUeXBlcyk7XG4gIGNvbnN0IGFyZ3MgPSBFdGhlcmV1bUFiaS5yYXdFbmNvZGUoc2VuZE11bHRpU2lnVHlwZXMsIHBhcmFtcyk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoQnVmZmVyLmNvbmNhdChbbWV0aG9kLCBhcmdzXSkudG9TdHJpbmcoJ2hleCcpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250cmFjdCBtZXRob2QgZW5jb2RlZCBkYXRhXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvIGRlc3RpbmF0aW9uIGFkZHJlc3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBBbW91bnQgdG8gdHJhbmZlclxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuQ29udHJhY3RBZGRyZXNzIHRoZSBhZGRyZXNzIG9mIHRoZSBlcmMyMCB0b2tlbiBjb250cmFjdFxuICogQHBhcmFtIHtudW1iZXJ9IGV4cGlyZVRpbWUgZXhwaXJhdGlvbiB0aW1lIGZvciB0aGUgdHJhbnNhY3Rpb24gaW4gc2Vjb25kc1xuICogQHBhcmFtIHtudW1iZXJ9IHNlcXVlbmNlSWQgc2VxdWVuY2UgaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaWduYXR1cmUgc2lnbmF0dXJlIG9mIHRoZSBjYWxsXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtLSB0aGUgY29udHJhY3QgbWV0aG9kIGVuY29kZWQgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VuZE11bHRpU2lnVG9rZW5EYXRhKFxuICB0bzogc3RyaW5nLFxuICB2YWx1ZTogc3RyaW5nLFxuICB0b2tlbkNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBleHBpcmVUaW1lOiBudW1iZXIsXG4gIHNlcXVlbmNlSWQ6IG51bWJlcixcbiAgc2lnbmF0dXJlOiBzdHJpbmdcbik6IHN0cmluZyB7XG4gIGNvbnN0IHBhcmFtcyA9IFt0bywgdmFsdWUsIHRva2VuQ29udHJhY3RBZGRyZXNzLCBleHBpcmVUaW1lLCBzZXF1ZW5jZUlkLCB0b0J1ZmZlcihzaWduYXR1cmUpXTtcblxuICBjb25zdCBtZXRob2QgPSBFdGhlcmV1bUFiaS5tZXRob2RJRCgnc2VuZE11bHRpU2lnVG9rZW4nLCBzZW5kTXVsdGlTaWdUb2tlblR5cGVzKTtcbiAgY29uc3QgYXJncyA9IEV0aGVyZXVtQWJpLnJhd0VuY29kZShzZW5kTXVsdGlTaWdUb2tlblR5cGVzLCBwYXJhbXMpO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KEJ1ZmZlci5jb25jYXQoW21ldGhvZCwgYXJnc10pLnRvU3RyaW5nKCdoZXgnKSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBkYXRhIHJlcXVpcmVkIHRvIG1ha2UgYSBmbHVzaCB0b2tlbnMgY29udHJhY3QgY2FsbFxuICpcbiAqIEBwYXJhbSBmb3J3YXJkZXJBZGRyZXNzIFRoZSBmb3J3YXJkZXIgYWRkcmVzcyB0byBmbHVzaFxuICogQHBhcmFtIHRva2VuQWRkcmVzcyBUaGUgdG9rZW4gYWRkcmVzcyB0byBmbHVzaCBmcm9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaFRva2Vuc0RhdGEoZm9yd2FyZGVyQWRkcmVzczogc3RyaW5nLCB0b2tlbkFkZHJlc3M6IHN0cmluZywgZm9yd2FyZGVyVmVyc2lvbjogbnVtYmVyKTogc3RyaW5nIHtcbiAgbGV0IHBhcmFtczogc3RyaW5nW107XG4gIGxldCBtZXRob2Q6IFVpbnQ4QXJyYXk7XG4gIGxldCBhcmdzOiBVaW50OEFycmF5O1xuXG4gIGlmIChmb3J3YXJkZXJWZXJzaW9uID49IDQpIHtcbiAgICBwYXJhbXMgPSBbdG9rZW5BZGRyZXNzXTtcbiAgICBtZXRob2QgPSBFdGhlcmV1bUFiaS5tZXRob2RJRCgnZmx1c2hUb2tlbnMnLCBmbHVzaFRva2Vuc1R5cGVzdjQpO1xuICAgIGFyZ3MgPSBFdGhlcmV1bUFiaS5yYXdFbmNvZGUoZmx1c2hUb2tlbnNUeXBlc3Y0LCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIHBhcmFtcyA9IFtmb3J3YXJkZXJBZGRyZXNzLCB0b2tlbkFkZHJlc3NdO1xuICAgIG1ldGhvZCA9IEV0aGVyZXVtQWJpLm1ldGhvZElEKCdmbHVzaEZvcndhcmRlclRva2VucycsIGZsdXNoVG9rZW5zVHlwZXMpO1xuICAgIGFyZ3MgPSBFdGhlcmV1bUFiaS5yYXdFbmNvZGUoZmx1c2hUb2tlbnNUeXBlcywgcGFyYW1zKTtcbiAgfVxuICByZXR1cm4gYWRkSGV4UHJlZml4KEJ1ZmZlci5jb25jYXQoW21ldGhvZCwgYXJnc10pLnRvU3RyaW5nKCdoZXgnKSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBkYXRhIHJlcXVpcmVkIHRvIG1ha2UgYSBmbHVzaCBuYXRpdmUgY29pbnMgY29udHJhY3QgY2FsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hDb2luc0RhdGEoKTogc3RyaW5nIHtcbiAgY29uc3QgcGFyYW1zID0gW107XG4gIGNvbnN0IG1ldGhvZCA9IEV0aGVyZXVtQWJpLm1ldGhvZElEKCdmbHVzaCcsIGZsdXNoQ29pbnNUeXBlcyk7XG4gIGNvbnN0IGFyZ3MgPSBFdGhlcmV1bUFiaS5yYXdFbmNvZGUoZmx1c2hDb2luc1R5cGVzLCBwYXJhbXMpO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KEJ1ZmZlci5jb25jYXQoW21ldGhvZCwgYXJnc10pLnRvU3RyaW5nKCdoZXgnKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3JlYXRlIGZvcndhcmRlciBtZXRob2QgY2FsbGluZyBkYXRhXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgY3JlYXRlRm9yd2FyZGVyIG1ldGhvZCBlbmNvZGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRyZXNzSW5pdGlhbGl6YXRpb25EYXRhKCk6IHN0cmluZyB7XG4gIHJldHVybiBjcmVhdGVGb3J3YXJkZXJNZXRob2RJZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBFdGggYWRkcmVzc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gdGhlIHR4IGhhc2ggdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEV0aEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBhbW91bnQgbnVtYmVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFtb3VudCAtIHRoZSBzdHJpbmcgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEFtb3VudChhbW91bnQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBiaWdOdW1iZXJBbW91bnQgPSBuZXcgQmlnTnVtYmVyKGFtb3VudCk7XG4gIHJldHVybiBiaWdOdW1iZXJBbW91bnQuaXNJbnRlZ2VyKCkgJiYgYmlnTnVtYmVyQW1vdW50LmlzR3JlYXRlclRoYW5PckVxdWFsVG8oMCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc21hcnQgY29udHJhY3QgZW5jb2RlZCBkYXRhXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgVGhlIHdhbGxldCBjcmVhdGlvbiBkYXRhIHRvIGRlY29kZVxuICogQHJldHVybnMge3N0cmluZ1tdfSAtIFRoZSBsaXN0IG9mIHNpZ25lciBhZGRyZXNzZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVdhbGxldENyZWF0aW9uRGF0YShkYXRhOiBzdHJpbmcpOiBXYWxsZXRJbml0aWFsaXphdGlvbkRhdGEge1xuICBpZiAoIShkYXRhLnN0YXJ0c1dpdGgod2FsbGV0SW5pdGlhbGl6YXRpb25GaXJzdEJ5dGVzKSB8fCBkYXRhLnN0YXJ0c1dpdGgodjFDcmVhdGVXYWxsZXRNZXRob2RJZCkpKSB7XG4gICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCB3YWxsZXQgYnl0ZWNvZGU6ICR7ZGF0YX1gKTtcbiAgfVxuXG4gIGlmIChkYXRhLnN0YXJ0c1dpdGgod2FsbGV0SW5pdGlhbGl6YXRpb25GaXJzdEJ5dGVzKSkge1xuICAgIGNvbnN0IGRhdGFCdWZmZXIgPSBCdWZmZXIuZnJvbShkYXRhLnNsaWNlKDIpLCAnaGV4Jyk7XG5cbiAgICAvLyB0aGUgbGFzdCAxNjAgYnl0ZXMgY29udGFpbiB0aGUgc2VyaWFsaXplZCBhZGRyZXNzIGFycmF5XG4gICAgY29uc3Qgc2VyaWFsaXplZFNpZ25lcnMgPSBkYXRhQnVmZmVyLnNsaWNlKC0xNjApO1xuXG4gICAgY29uc3QgcmVzdWx0RW5jb2RlZFBhcmFtZXRlcnMgPSBFdGhlcmV1bUFiaS5yYXdEZWNvZGUod2FsbGV0U2ltcGxlQ29uc3RydWN0b3IsIHNlcmlhbGl6ZWRTaWduZXJzKTtcbiAgICBpZiAocmVzdWx0RW5jb2RlZFBhcmFtZXRlcnMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBDb3VsZCBub3QgZGVjb2RlIHdhbGxldCBjb25zdHJ1Y3RvciBieXRlY29kZTogJHtyZXN1bHRFbmNvZGVkUGFyYW1ldGVyc31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBhZGRyZXNzZXM6IEJOW10gPSByZXN1bHRFbmNvZGVkUGFyYW1ldGVyc1swXTtcbiAgICBpZiAoYWRkcmVzc2VzLmxlbmd0aCAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgaW52YWxpZCBudW1iZXIgb2YgYWRkcmVzc2VzIGluIHBhcnNlZCBjb25zdHJ1Y3RvcjogJHthZGRyZXNzZXN9YCk7XG4gICAgfVxuXG4gICAgLy8gc29tZXRpbWVzIGV0aGVyZXVtanMtYWJpIHJlbW92ZXMgMCBwYWRkaW5nIGF0IHRoZSBzdGFydCBvZiBhZGRyZXNzZXMsXG4gICAgLy8gc28gd2Ugc2hvdWxkIHBhZCB1bnRpbCB0aGV5IGFyZSB0aGUgc3RhbmRhcmQgMjAgYnl0ZXNcbiAgICBjb25zdCBwYWRkZWRBZGRyZXNzZXMgPSBhZGRyZXNzZXMubWFwKChhZGRyZXNzKSA9PiBzdHJpcEhleFByZWZpeChhZGRyZXNzLnRvU3RyaW5nKCdoZXgnKSkucGFkU3RhcnQoNDAsICcwJykpO1xuXG4gICAgcmV0dXJuIHsgb3duZXJzOiBwYWRkZWRBZGRyZXNzZXMubWFwKChhZGRyZXNzKSA9PiBhZGRIZXhQcmVmaXgoYWRkcmVzcykpIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGVjb2RlZERhdGFGb3JXYWxsZXRDcmVhdGlvbiA9IGdldFJhd0RlY29kZWQoXG4gICAgICBjcmVhdGVWMVdhbGxldFR5cGVzLFxuICAgICAgZ2V0QnVmZmVyZWRCeXRlQ29kZSh2MUNyZWF0ZVdhbGxldE1ldGhvZElkLCBkYXRhKVxuICAgICk7XG4gICAgY29uc3QgYWRkcmVzc2VzID0gZGVjb2RlZERhdGFGb3JXYWxsZXRDcmVhdGlvblswXSBhcyBzdHJpbmdbXTtcbiAgICBjb25zdCBzYWx0QnVmZmVyID0gZGVjb2RlZERhdGFGb3JXYWxsZXRDcmVhdGlvblsxXTtcbiAgICBjb25zdCBzYWx0ID0gYnVmZmVyVG9IZXgoc2FsdEJ1ZmZlciBhcyBCdWZmZXIpO1xuICAgIGNvbnN0IHBhZGRlZEFkZHJlc3NlcyA9IGFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MpID0+IHN0cmlwSGV4UHJlZml4KGFkZHJlc3MudG9TdHJpbmcoKSkucGFkU3RhcnQoNDAsICcwJykpO1xuICAgIGNvbnN0IG93bmVycyA9IHBhZGRlZEFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MpID0+IGFkZEhleFByZWZpeChhZGRyZXNzKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG93bmVycyxcbiAgICAgIHNhbHQsXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIERlY29kZSB0aGUgZ2l2ZW4gQUJJLWVuY29kZWQgdHJhbnNmZXIgZGF0YSBhbmQgcmV0dXJuIHBhcnNlZCBmaWVsZHNcbiAqXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvZGVcbiAqIEByZXR1cm5zIHBhcnNlZCB0cmFuc2ZlciBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUcmFuc2ZlckRhdGEoZGF0YTogc3RyaW5nKTogVHJhbnNmZXJEYXRhIHtcbiAgaWYgKGRhdGEuc3RhcnRzV2l0aChzZW5kTXVsdGlzaWdNZXRob2RJZCkpIHtcbiAgICByZXR1cm4gZGVjb2RlTmF0aXZlVHJhbnNmZXJEYXRhKGRhdGEpO1xuICB9IGVsc2UgaWYgKGRhdGEuc3RhcnRzV2l0aChzZW5kTXVsdGlzaWdUb2tlbk1ldGhvZElkKSkge1xuICAgIHJldHVybiBkZWNvZGVUb2tlblRyYW5zZmVyRGF0YShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHRyYW5zZmVyIGJ5dGVjb2RlOiAke2RhdGF9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWNvZGUgdGhlIGdpdmVuIEFCSS1lbmNvZGVkIHRyYW5zZmVyIGRhdGEgZm9yIHRoZSBzZW5kTXVsdGlzaWdUb2tlbiBmdW5jdGlvbiBhbmQgcmV0dXJuIHBhcnNlZCBmaWVsZHNcbiAqXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvZGVcbiAqIEByZXR1cm5zIHBhcnNlZCB0b2tlbiB0cmFuc2ZlciBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUb2tlblRyYW5zZmVyRGF0YShkYXRhOiBzdHJpbmcpOiBUb2tlblRyYW5zZmVyRGF0YSB7XG4gIGlmICghZGF0YS5zdGFydHNXaXRoKHNlbmRNdWx0aXNpZ1Rva2VuTWV0aG9kSWQpKSB7XG4gICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCB0cmFuc2ZlciBieXRlY29kZTogJHtkYXRhfWApO1xuICB9XG5cbiAgY29uc3QgW3RvLCBhbW91bnQsIHRva2VuQ29udHJhY3RBZGRyZXNzLCBleHBpcmVUaW1lLCBzZXF1ZW5jZUlkLCBzaWduYXR1cmVdID0gZ2V0UmF3RGVjb2RlZChcbiAgICBzZW5kTXVsdGlTaWdUb2tlblR5cGVzLFxuICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUoc2VuZE11bHRpc2lnVG9rZW5NZXRob2RJZCwgZGF0YSlcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHRvOiBhZGRIZXhQcmVmaXgodG8gYXMgc3RyaW5nKSxcbiAgICBhbW91bnQ6IG5ldyBCaWdOdW1iZXIoYnVmZmVyVG9IZXgoYW1vdW50IGFzIEJ1ZmZlcikpLnRvRml4ZWQoKSxcbiAgICBleHBpcmVUaW1lOiBidWZmZXJUb0ludChleHBpcmVUaW1lIGFzIEJ1ZmZlciksXG4gICAgc2VxdWVuY2VJZDogYnVmZmVyVG9JbnQoc2VxdWVuY2VJZCBhcyBCdWZmZXIpLFxuICAgIHNpZ25hdHVyZTogYnVmZmVyVG9IZXgoc2lnbmF0dXJlIGFzIEJ1ZmZlciksXG4gICAgdG9rZW5Db250cmFjdEFkZHJlc3M6IGFkZEhleFByZWZpeCh0b2tlbkNvbnRyYWN0QWRkcmVzcyBhcyBzdHJpbmcpLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRVJDNzIxVHJhbnNmZXJEYXRhKGRhdGE6IHN0cmluZyk6IEVSQzcyMVRyYW5zZmVyRGF0YSB7XG4gIGlmICghZGF0YS5zdGFydHNXaXRoKHNlbmRNdWx0aXNpZ01ldGhvZElkKSkge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgdHJhbnNmZXIgYnl0ZWNvZGU6ICR7ZGF0YX1gKTtcbiAgfVxuXG4gIGNvbnN0IFt0bywgYW1vdW50LCBpbnRlcm5hbERhdGEsIGV4cGlyZVRpbWUsIHNlcXVlbmNlSWQsIHNpZ25hdHVyZV0gPSBnZXRSYXdEZWNvZGVkKFxuICAgIHNlbmRNdWx0aVNpZ1R5cGVzLFxuICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUoc2VuZE11bHRpc2lnTWV0aG9kSWQsIGRhdGEpXG4gICk7XG5cbiAgY29uc3QgaW50ZXJuYWxEYXRhSGV4ID0gYnVmZmVyVG9IZXgoaW50ZXJuYWxEYXRhIGFzIEJ1ZmZlcik7XG4gIGlmICghaW50ZXJuYWxEYXRhSGV4LnN0YXJ0c1dpdGgoRVJDNzIxU2FmZVRyYW5zZmVyVHlwZU1ldGhvZElkKSkge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgdHJhbnNmZXIgYnl0ZWNvZGU6ICR7ZGF0YX1gKTtcbiAgfVxuXG4gIGNvbnN0IFtmcm9tLCByZWNlaXZlciwgdG9rZW5JZCwgdXNlclNlbnREYXRhXSA9IGdldFJhd0RlY29kZWQoXG4gICAgRVJDNzIxU2FmZVRyYW5zZmVyVHlwZXMsXG4gICAgZ2V0QnVmZmVyZWRCeXRlQ29kZShFUkM3MjFTYWZlVHJhbnNmZXJUeXBlTWV0aG9kSWQsIGludGVybmFsRGF0YUhleClcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHRvOiBhZGRIZXhQcmVmaXgocmVjZWl2ZXIgYXMgc3RyaW5nKSxcbiAgICBmcm9tOiBhZGRIZXhQcmVmaXgoZnJvbSBhcyBzdHJpbmcpLFxuICAgIGV4cGlyZVRpbWU6IGJ1ZmZlclRvSW50KGV4cGlyZVRpbWUgYXMgQnVmZmVyKSxcbiAgICBhbW91bnQ6IG5ldyBCaWdOdW1iZXIoYnVmZmVyVG9IZXgoYW1vdW50IGFzIEJ1ZmZlcikpLnRvRml4ZWQoKSxcbiAgICB0b2tlbklkOiBuZXcgQmlnTnVtYmVyKGJ1ZmZlclRvSGV4KHRva2VuSWQgYXMgQnVmZmVyKSkudG9GaXhlZCgpLFxuICAgIHNlcXVlbmNlSWQ6IGJ1ZmZlclRvSW50KHNlcXVlbmNlSWQgYXMgQnVmZmVyKSxcbiAgICBzaWduYXR1cmU6IGJ1ZmZlclRvSGV4KHNpZ25hdHVyZSBhcyBCdWZmZXIpLFxuICAgIHRva2VuQ29udHJhY3RBZGRyZXNzOiBhZGRIZXhQcmVmaXgodG8gYXMgc3RyaW5nKSxcbiAgICB1c2VyRGF0YTogYnVmZmVyVG9IZXgodXNlclNlbnREYXRhIGFzIEJ1ZmZlciksXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVFUkMxMTU1VHJhbnNmZXJEYXRhKGRhdGE6IHN0cmluZyk6IEVSQzExNTVUcmFuc2ZlckRhdGEge1xuICBsZXQgZnJvbSwgcmVjZWl2ZXIsIHVzZXJTZW50RGF0YTtcbiAgbGV0IHRva2VuSWRzOiBzdHJpbmdbXTtcbiAgbGV0IHZhbHVlczogc3RyaW5nW107XG5cbiAgaWYgKCFkYXRhLnN0YXJ0c1dpdGgoc2VuZE11bHRpc2lnTWV0aG9kSWQpKSB7XG4gICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCB0cmFuc2ZlciBieXRlY29kZTogJHtkYXRhfWApO1xuICB9XG5cbiAgY29uc3QgW3RvLCBhbW91bnQsIGludGVybmFsRGF0YSwgZXhwaXJlVGltZSwgc2VxdWVuY2VJZCwgc2lnbmF0dXJlXSA9IGdldFJhd0RlY29kZWQoXG4gICAgc2VuZE11bHRpU2lnVHlwZXMsXG4gICAgZ2V0QnVmZmVyZWRCeXRlQ29kZShzZW5kTXVsdGlzaWdNZXRob2RJZCwgZGF0YSlcbiAgKTtcblxuICBjb25zdCBpbnRlcm5hbERhdGFIZXggPSBidWZmZXJUb0hleChpbnRlcm5hbERhdGEgYXMgQnVmZmVyKTtcbiAgaWYgKGludGVybmFsRGF0YUhleC5zdGFydHNXaXRoKEVSQzExNTVTYWZlVHJhbnNmZXJUeXBlTWV0aG9kSWQpKSB7XG4gICAgbGV0IHRva2VuSWQ7XG4gICAgbGV0IHZhbHVlO1xuXG4gICAgW2Zyb20sIHJlY2VpdmVyLCB0b2tlbklkLCB2YWx1ZSwgdXNlclNlbnREYXRhXSA9IGdldFJhd0RlY29kZWQoXG4gICAgICBFUkMxMTU1U2FmZVRyYW5zZmVyVHlwZXMsXG4gICAgICBnZXRCdWZmZXJlZEJ5dGVDb2RlKEVSQzExNTVTYWZlVHJhbnNmZXJUeXBlTWV0aG9kSWQsIGludGVybmFsRGF0YUhleClcbiAgICApO1xuXG4gICAgdG9rZW5JZHMgPSBbbmV3IEJpZ051bWJlcihidWZmZXJUb0hleCh0b2tlbklkKSkudG9GaXhlZCgpXTtcbiAgICB2YWx1ZXMgPSBbbmV3IEJpZ051bWJlcihidWZmZXJUb0hleCh2YWx1ZSkpLnRvRml4ZWQoKV07XG4gIH0gZWxzZSBpZiAoYnVmZmVyVG9IZXgoaW50ZXJuYWxEYXRhIGFzIEJ1ZmZlcikuc3RhcnRzV2l0aChFUkMxMTU1QmF0Y2hUcmFuc2ZlclR5cGVNZXRob2RJZCkpIHtcbiAgICBsZXQgdGVtcFRva2VuSWRzLCB0ZW1wVmFsdWVzO1xuICAgIFtmcm9tLCByZWNlaXZlciwgdGVtcFRva2VuSWRzLCB0ZW1wVmFsdWVzLCB1c2VyU2VudERhdGFdID0gZ2V0UmF3RGVjb2RlZChcbiAgICAgIEVSQzExNTVCYXRjaFRyYW5zZmVyVHlwZXMsXG4gICAgICBnZXRCdWZmZXJlZEJ5dGVDb2RlKEVSQzExNTVCYXRjaFRyYW5zZmVyVHlwZU1ldGhvZElkLCBpbnRlcm5hbERhdGFIZXgpXG4gICAgKTtcbiAgICB0b2tlbklkcyA9IHRlbXBUb2tlbklkcy5tYXAoKHgpID0+IG5ldyBCaWdOdW1iZXIoYnVmZmVyVG9IZXgoeCkpLnRvRml4ZWQoKSk7XG4gICAgdmFsdWVzID0gdGVtcFZhbHVlcy5tYXAoKHgpID0+IG5ldyBCaWdOdW1iZXIoYnVmZmVyVG9IZXgoeCkpLnRvRml4ZWQoKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCB0cmFuc2ZlciBieXRlY29kZTogJHtkYXRhfWApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0bzogYWRkSGV4UHJlZml4KHJlY2VpdmVyKSxcbiAgICBmcm9tOiBhZGRIZXhQcmVmaXgoZnJvbSksXG4gICAgZXhwaXJlVGltZTogYnVmZmVyVG9JbnQoZXhwaXJlVGltZSBhcyBCdWZmZXIpLFxuICAgIGFtb3VudDogbmV3IEJpZ051bWJlcihidWZmZXJUb0hleChhbW91bnQgYXMgQnVmZmVyKSkudG9GaXhlZCgpLFxuICAgIHRva2VuSWRzLFxuICAgIHZhbHVlcyxcbiAgICBzZXF1ZW5jZUlkOiBidWZmZXJUb0ludChzZXF1ZW5jZUlkIGFzIEJ1ZmZlciksXG4gICAgc2lnbmF0dXJlOiBidWZmZXJUb0hleChzaWduYXR1cmUgYXMgQnVmZmVyKSxcbiAgICB0b2tlbkNvbnRyYWN0QWRkcmVzczogYWRkSGV4UHJlZml4KHRvIGFzIHN0cmluZyksXG4gICAgdXNlckRhdGE6IHVzZXJTZW50RGF0YSxcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgdGhlIGdpdmVuIEFCSS1lbmNvZGVkIHRyYW5zZmVyIGRhdGEgZm9yIHRoZSBzZW5kTXVsdGlzaWcgZnVuY3Rpb24gYW5kIHJldHVybiBwYXJzZWQgZmllbGRzXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb2RlXG4gKiBAcmV0dXJucyBwYXJzZWQgdHJhbnNmZXIgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTmF0aXZlVHJhbnNmZXJEYXRhKGRhdGE6IHN0cmluZyk6IE5hdGl2ZVRyYW5zZmVyRGF0YSB7XG4gIGlmICghZGF0YS5zdGFydHNXaXRoKHNlbmRNdWx0aXNpZ01ldGhvZElkKSkge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgdHJhbnNmZXIgYnl0ZWNvZGU6ICR7ZGF0YX1gKTtcbiAgfVxuXG4gIGNvbnN0IFt0bywgYW1vdW50LCBpbnRlcm5hbERhdGEsIGV4cGlyZVRpbWUsIHNlcXVlbmNlSWQsIHNpZ25hdHVyZV0gPSBnZXRSYXdEZWNvZGVkKFxuICAgIHNlbmRNdWx0aVNpZ1R5cGVzLFxuICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUoc2VuZE11bHRpc2lnTWV0aG9kSWQsIGRhdGEpXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICB0bzogYWRkSGV4UHJlZml4KHRvIGFzIHN0cmluZyksXG4gICAgYW1vdW50OiBuZXcgQmlnTnVtYmVyKGJ1ZmZlclRvSGV4KGFtb3VudCBhcyBCdWZmZXIpKS50b0ZpeGVkKCksXG4gICAgZXhwaXJlVGltZTogYnVmZmVyVG9JbnQoZXhwaXJlVGltZSBhcyBCdWZmZXIpLFxuICAgIHNlcXVlbmNlSWQ6IGJ1ZmZlclRvSW50KHNlcXVlbmNlSWQgYXMgQnVmZmVyKSxcbiAgICBzaWduYXR1cmU6IGJ1ZmZlclRvSGV4KHNpZ25hdHVyZSBhcyBCdWZmZXIpLFxuICAgIGRhdGE6IGJ1ZmZlclRvSGV4KGludGVybmFsRGF0YSBhcyBCdWZmZXIpLFxuICB9O1xufVxuXG4vKipcbiAqIERlY29kZSB0aGUgZ2l2ZW4gQUJJLWVuY29kZWQgZmx1c2ggdG9rZW5zIGRhdGEgYW5kIHJldHVybiBwYXJzZWQgZmllbGRzXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb2RlXG4gKiBAcGFyYW0gdG8gT3B0aW9uYWwgdG8gcGFyYW1ldGVyIG9mIHR4XG4gKiBAcmV0dXJucyBwYXJzZWQgdHJhbnNmZXIgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRmx1c2hUb2tlbnNEYXRhKGRhdGE6IHN0cmluZywgdG8/OiBzdHJpbmcpOiBGbHVzaFRva2Vuc0RhdGEge1xuICBpZiAoZGF0YS5zdGFydHNXaXRoKGZsdXNoRm9yd2FyZGVyVG9rZW5zTWV0aG9kSWQpKSB7XG4gICAgY29uc3QgW2ZvcndhcmRlckFkZHJlc3MsIHRva2VuQWRkcmVzc10gPSBnZXRSYXdEZWNvZGVkKFxuICAgICAgZmx1c2hUb2tlbnNUeXBlcyxcbiAgICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUoZmx1c2hGb3J3YXJkZXJUb2tlbnNNZXRob2RJZCwgZGF0YSlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBmb3J3YXJkZXJBZGRyZXNzOiBhZGRIZXhQcmVmaXgoZm9yd2FyZGVyQWRkcmVzcyBhcyBzdHJpbmcpLFxuICAgICAgdG9rZW5BZGRyZXNzOiBhZGRIZXhQcmVmaXgodG9rZW5BZGRyZXNzIGFzIHN0cmluZyksXG4gICAgfTtcbiAgfSBlbHNlIGlmIChkYXRhLnN0YXJ0c1dpdGgoZmx1c2hGb3J3YXJkZXJUb2tlbnNNZXRob2RJZFY0KSkge1xuICAgIGNvbnN0IFt0b2tlbkFkZHJlc3NdID0gZ2V0UmF3RGVjb2RlZChmbHVzaFRva2Vuc1R5cGVzdjQsIGdldEJ1ZmZlcmVkQnl0ZUNvZGUoZmx1c2hGb3J3YXJkZXJUb2tlbnNNZXRob2RJZFY0LCBkYXRhKSk7XG4gICAgaWYgKCF0bykge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgTWlzc2luZyB0byBhZGRyZXNzOiAke3RvfWApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZm9yd2FyZGVyQWRkcmVzczogdG8sXG4gICAgICB0b2tlbkFkZHJlc3M6IGFkZEhleFByZWZpeCh0b2tlbkFkZHJlc3MgYXMgc3RyaW5nKSxcbiAgICAgIGZvcndhcmRlclZlcnNpb246IDQsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHRyYW5zZmVyIGJ5dGVjb2RlOiAke2RhdGF9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzc2lmeSB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24gZGF0YSBiYXNlZCBhcyBhIHRyYW5zYWN0aW9uIHR5cGUuXG4gKiBFVEggdHJhbnNhY3Rpb25zIGFyZSBkZWZpbmVkIGJ5IHRoZSBmaXJzdCA4IGJ5dGVzIG9mIHRoZSB0cmFuc2FjdGlvbiBkYXRhLCBhbHNvIGtub3duIGFzIHRoZSBtZXRob2QgaWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBjbGFzc2lmeSB0aGUgdHJhbnNhY3Rpb24gd2l0aFxuICogQHJldHVybnMge1RyYW5zYWN0aW9uVHlwZX0gVGhlIGNsYXNzaWZpZWQgdHJhbnNhY3Rpb24gdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhc3NpZnlUcmFuc2FjdGlvbihkYXRhOiBzdHJpbmcpOiBUcmFuc2FjdGlvblR5cGUge1xuICBpZiAoZGF0YS5sZW5ndGggPCAxMCkge1xuICAgIC8vIGNvbnRyYWN0IGNhbGxzIG11c3QgaGF2ZSBhdCBsZWFzdCA0IGJ5dGVzIChtZXRob2QgaWQpIGFuZCAnMHgnXG4gICAgLy8gaWYgaXQgZG9lc24ndCBoYXZlIGVub3VnaCBkYXRhIHRvIGJlIGEgY29udHJhY3QgY2FsbCBpdCBtdXN0IGJlIGEgc2luZ2xlIHNpZyBzZW5kXG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZS5TaW5nbGVTaWdTZW5kO1xuICB9XG5cbiAgLy8gVE9ETyhTVExYLTE5NzApOiB2YWxpZGF0ZSBpZiB3ZSBhcmUgZ29pbmcgdG8gY29uc3RyYWludCB0byBzb21lIG1ldGhvZHMgYWxsb3dlZFxuICBsZXQgdHJhbnNhY3Rpb25UeXBlID0gdHJhbnNhY3Rpb25UeXBlc01hcFtkYXRhLnNsaWNlKDAsIDEwKS50b0xvd2VyQ2FzZSgpXTtcbiAgaWYgKHRyYW5zYWN0aW9uVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdHJhbnNhY3Rpb25UeXBlID0gVHJhbnNhY3Rpb25UeXBlLkNvbnRyYWN0Q2FsbDtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2FjdGlvblR5cGU7XG59XG5cbi8qKlxuICogQSB0cmFuc2FjdGlvbiB0eXBlcyBtYXAgYWNjb3JkaW5nIHRvIHRoZSBzdGFydGluZyBwYXJ0IG9mIHRoZSBlbmNvZGVkIGRhdGFcbiAqL1xuY29uc3QgdHJhbnNhY3Rpb25UeXBlc01hcCA9IHtcbiAgW3dhbGxldEluaXRpYWxpemF0aW9uRmlyc3RCeXRlc106IFRyYW5zYWN0aW9uVHlwZS5XYWxsZXRJbml0aWFsaXphdGlvbixcbiAgW3JlY292ZXJ5V2FsbGV0SW5pdGlhbGl6YXRpb25GaXJzdEJ5dGVzXTogVHJhbnNhY3Rpb25UeXBlLlJlY292ZXJ5V2FsbGV0RGVwbG95bWVudCxcbiAgW3YxQ3JlYXRlV2FsbGV0TWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuV2FsbGV0SW5pdGlhbGl6YXRpb24sXG4gIFtjcmVhdGVGb3J3YXJkZXJNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5BZGRyZXNzSW5pdGlhbGl6YXRpb24sXG4gIFt2MUNyZWF0ZUZvcndhcmRlck1ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLkFkZHJlc3NJbml0aWFsaXphdGlvbixcbiAgW3Y0Q3JlYXRlRm9yd2FyZGVyTWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuQWRkcmVzc0luaXRpYWxpemF0aW9uLFxuICBbc2VuZE11bHRpc2lnTWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuU2VuZCxcbiAgW2ZsdXNoRm9yd2FyZGVyVG9rZW5zTWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuRmx1c2hUb2tlbnMsXG4gIFtmbHVzaEZvcndhcmRlclRva2Vuc01ldGhvZElkVjRdOiBUcmFuc2FjdGlvblR5cGUuRmx1c2hUb2tlbnMsXG4gIFtmbHVzaENvaW5zTWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuRmx1c2hDb2lucyxcbiAgW3NlbmRNdWx0aXNpZ1Rva2VuTWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuU2VuZCxcbiAgW0xvY2tNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nTG9jayxcbiAgW1ZvdGVNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nVm90ZSxcbiAgW0FjdGl2YXRlTWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0FjdGl2YXRlLFxuICBbVW52b3RlTWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ1Vudm90ZSxcbiAgW1VubG9ja01ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdVbmxvY2ssXG4gIFtXaXRoZHJhd01ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdXaXRoZHJhdyxcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gbnVtYmVyIHRvIGJlIGNvbnZlcnRlZCB0byBoZXhcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBoZXggbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFN0cmluZyhudW06IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gIHJldHVybiBoZXgubGVuZ3RoICUgMiA9PT0gMCA/ICcweCcgKyBoZXggOiAnMHgwJyArIGhleDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhleCBUaGUgaGV4IHN0cmluZyB0byBiZSBjb252ZXJ0ZWRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSByZXN1bHRpbmcgbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhTdHJpbmdUb051bWJlcihoZXg6IHN0cmluZyk6IG51bWJlciB7XG4gIHJldHVybiBwYXJzZUludChoZXguc2xpY2UoMiksIDE2KTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBvZiB0aGUgZm9yd2FyZGVyIGFkZHJlc3MgdG8gYmUgZGVwbG95ZWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIHRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb250cmFjdENvdW50ZXIgdGhlIG5vbmNlIG9mIHRoZSBjb250cmFjdCBhZGRyZXNzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgY2FsY3VsYXRlZCBmb3J3YXJkZXIgY29udHJhY3QgYWRkcmVzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRm9yd2FyZGVyQWRkcmVzcyhjb250cmFjdEFkZHJlc3M6IHN0cmluZywgY29udHJhY3RDb3VudGVyOiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBmb3J3YXJkZXJBZGRyZXNzID0gZ2VuZXJhdGVBZGRyZXNzKFxuICAgIEJ1ZmZlci5mcm9tKHN0cmlwSGV4UHJlZml4KGNvbnRyYWN0QWRkcmVzcyksICdoZXgnKSxcbiAgICBCdWZmZXIuZnJvbShwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgobnVtYmVyVG9IZXhTdHJpbmcoY29udHJhY3RDb3VudGVyKSkpLCAnaGV4JylcbiAgKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChmb3J3YXJkZXJBZGRyZXNzLnRvU3RyaW5nKCdoZXgnKSk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBmb3J3YXJkZXIgdjEgYWRkcmVzcyB0aGF0IHdpbGwgYmUgZ2VuZXJhdGVkIGlmIGBjcmVhdG9yQWRkcmVzc2AgY3JlYXRlcyBpdCB3aXRoIHNhbHQgYHNhbHRgXG4gKiBhbmQgaW5pdGNvZGUgYGluaWNvZGUgdXNpbmcgdGhlIGNyZWF0ZTIgb3Bjb2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gY3JlYXRvckFkZHJlc3MgVGhlIGFkZHJlc3MgdGhhdCBpcyBzZW5kaW5nIHRoZSB0eCB0byBjcmVhdGUgYSBuZXcgYWRkcmVzcywgaGV4IHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHNhbHQgVGhlIHNhbHQgdG8gY3JlYXRlIHRoZSBhZGRyZXNzIHdpdGggdXNpbmcgY3JlYXRlMiwgaGV4IHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGluaXRjb2RlIFRoZSBpbml0Y29kZSB0aGF0IHdpbGwgYmUgZGVwbG95ZWQgdG8gdGhlIGFkZHJlc3MsIGhleCBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNhbGN1bGF0ZWQgYWRkcmVzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRm9yd2FyZGVyVjFBZGRyZXNzKGNyZWF0b3JBZGRyZXNzOiBzdHJpbmcsIHNhbHQ6IHN0cmluZywgaW5pdGNvZGU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGZvcndhcmRlclYxQWRkcmVzcyA9IGdlbmVyYXRlQWRkcmVzczIoXG4gICAgQnVmZmVyLmZyb20oc3RyaXBIZXhQcmVmaXgoY3JlYXRvckFkZHJlc3MpLCAnaGV4JyksXG4gICAgQnVmZmVyLmZyb20oc3RyaXBIZXhQcmVmaXgoc2FsdCksICdoZXgnKSxcbiAgICBCdWZmZXIuZnJvbShwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgoaW5pdGNvZGUpKSwgJ2hleCcpXG4gICk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoZm9yd2FyZGVyVjFBZGRyZXNzLnRvU3RyaW5nKCdoZXgnKSk7XG59XG5cbi8qKlxuICogVGFrZSB0aGUgaW1wbGVtZW50YXRpb24gYWRkcmVzcyBmb3IgdGhlIHByb3h5IGNvbnRyYWN0LCBhbmQgZ2V0IHRoZSBiaW5hcnkgaW5pdGNvZGUgZm9yIHRoZSBhc3NvY2lhdGVkIHByb3h5XG4gKiBAcGFyYW0ge3N0cmluZ30gaW1wbGVtZW50YXRpb25BZGRyZXNzIFRoZSBhZGRyZXNzIG9mIHRoZSBpbXBsZW1lbnRhdGlvbiBjb250cmFjdCBmb3IgdGhlIHByb3h5XG4gKiBAcmV0dXJuIHtzdHJpbmd9IEJpbmFyeSBoZXggc3RyaW5nIG9mIHRoZSBwcm94eVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJveHlJbml0Y29kZShpbXBsZW1lbnRhdGlvbkFkZHJlc3M6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHRhcmdldCA9IHN0cmlwSGV4UHJlZml4KGltcGxlbWVudGF0aW9uQWRkcmVzcy50b0xvd2VyQ2FzZSgpKS5wYWRTdGFydCg0MCwgJzAnKTtcblxuICAvLyBieXRlY29kZSBvZiB0aGUgcHJveHksIGZyb206XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9CaXRHby9ldGgtbXVsdGlzaWctdjQvYmxvYi9kNTQ2YTkzN2Y5MGY5M2U4M2IzNDIzYTViZjkzM2QxZDc3YzY3N2MzL2NvbnRyYWN0cy9DbG9uZUZhY3Rvcnkuc29sI0w0Mi1MNTZcbiAgcmV0dXJuIGAweDNkNjAyZDgwNjAwYTNkMzk4MWYzMzYzZDNkMzczZDNkM2QzNjNkNzMke3RhcmdldH01YWY0M2Q4MjgwM2U5MDNkOTE2MDJiNTdmZDViZjNgO1xufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIHNpZ25hdHVyZSBwYXJ0cyB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7U2lnbmF0dXJlUGFydHN9IHNpZyBUaGUgc2lnbmF0dXJlIHRvIGNvbnZlcnQgdG8gc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNpZ25hdHVyZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmdTaWcoc2lnOiBTaWduYXR1cmVQYXJ0cyk6IHN0cmluZyB7XG4gIHJldHVybiBidWZmZXJUb0hleChcbiAgICBCdWZmZXIuY29uY2F0KFtcbiAgICAgIHNldExlbmd0aExlZnQoQnVmZmVyLmZyb20oc3RyaXBIZXhQcmVmaXgoc2lnLnIpLCAnaGV4JyksIDMyKSxcbiAgICAgIHNldExlbmd0aExlZnQoQnVmZmVyLmZyb20oc3RyaXBIZXhQcmVmaXgoc2lnLnMpLCAnaGV4JyksIDMyKSxcbiAgICAgIHRvQnVmZmVyKHNpZy52KSxcbiAgICBdKVxuICApO1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gdHggZGF0YSBoYXMgYSBzaWduYXR1cmVcbiAqXG4gKiBAcGFyYW0ge1R4RGF0YX0gdHhEYXRhIFRoZSB0cmFuc2FjdGlvbiBkYXRhIHRvIGNoZWNrIGZvciBzaWduYXR1cmVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0eCBoYXMgYSBzaWduYXR1cmUsIGVsc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc1NpZ25hdHVyZSh0eERhdGE6IFR4RGF0YSk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIHR4RGF0YS52ICE9PSB1bmRlZmluZWQgJiZcbiAgICB0eERhdGEuciAhPT0gdW5kZWZpbmVkICYmXG4gICAgdHhEYXRhLnMgIT09IHVuZGVmaW5lZCAmJlxuICAgIHR4RGF0YS52Lmxlbmd0aCA+IDAgJiZcbiAgICB0eERhdGEuci5sZW5ndGggPiAwICYmXG4gICAgdHhEYXRhLnMubGVuZ3RoID4gMFxuICApO1xufVxuXG50eXBlIFJlY3Vyc2l2ZUJ1ZmZlck9yU3RyaW5nID0gc3RyaW5nIHwgQnVmZmVyIHwgQk4gfCBSZWN1cnNpdmVCdWZmZXJPclN0cmluZ1tdO1xuXG4vKipcbiAqIEdldCB0aGUgcmF3IGRhdGEgZGVjb2RlZCBmb3Igc29tZSB0eXBlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IHR5cGVzIEFCSSB0eXBlcyBkZWZpbml0aW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2VyaWFsaXplZEFyZ3MgZW5jb2RlZCBhcmdzXG4gKiBAcmV0dXJucyB7QnVmZmVyW119IHRoZSBkZWNvZGVkIHJhd1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmF3RGVjb2RlZCh0eXBlczogc3RyaW5nW10sIHNlcmlhbGl6ZWRBcmdzOiBCdWZmZXIpOiBSZWN1cnNpdmVCdWZmZXJPclN0cmluZ1tdIHtcbiAgZnVuY3Rpb24gbm9ybWFsaXplKHY6IHVua25vd24sIGk6IG51bWJlcik6IHVua25vd24ge1xuICAgIGlmIChCTi5pc0JOKHYpKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCBCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgcmV0dXJuIHYubWFwKG5vcm1hbGl6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRm9yICR7dHlwZXN9WyR7aX1dIGdvdCAke3R5cGVvZiB2fWApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBFdGhlcmV1bUFiaS5yYXdEZWNvZGUodHlwZXMsIHNlcmlhbGl6ZWRBcmdzKS5tYXAobm9ybWFsaXplKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJ1ZmZlcmVkIGJ5dGVjb2RlIGZyb20gcmF3RGF0YSB1c2luZyBhIG1ldGhvZElkIGFzIGRlbGltaXRlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RJZCB0aGUgaGV4IGVuY29kZWQgbWV0aG9kIElkXG4gKiBAcGFyYW0ge3N0cmluZ30gcmF3RGF0YSB0aGUgaGV4IGVuY29kZWQgcmF3IGRhdGFcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IGRhdGEgYnVmZmVyZWQgYnl0ZWNvZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ1ZmZlcmVkQnl0ZUNvZGUobWV0aG9kSWQ6IHN0cmluZywgcmF3RGF0YTogc3RyaW5nKTogQnVmZmVyIHtcbiAgY29uc3Qgc3BsaXRCeXRlY29kZSA9IHJhd0RhdGEuc3BsaXQobWV0aG9kSWQpO1xuICBpZiAoc3BsaXRCeXRlY29kZS5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHNlbmQgYnl0ZWNvZGU6ICR7cmF3RGF0YX1gKTtcbiAgfVxuICBpZiAoc3BsaXRCeXRlY29kZVsxXS5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBzZW5kIGJ5dGVjb2RlOiAke3Jhd0RhdGF9ICh3cm9uZyBsZW5naHQpYCk7XG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNwbGl0Qnl0ZWNvZGVbMV0sICdoZXgnKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHN0YXRpY3MgY29pbiBvYmplY3QgbWF0Y2hpbmcgYSBnaXZlbiBjb250cmFjdCBhZGRyZXNzIGlmIGl0IGV4aXN0c1xuICpcbiAqIEBwYXJhbSB0b2tlbkNvbnRyYWN0QWRkcmVzcyBUaGUgY29udHJhY3QgYWRkcmVzcyB0byBtYXRjaCBhZ2FpbnN0XG4gKiBAcGFyYW0gbmV0d29yayAtIHRoZSBjb2luIG5ldHdvcmtcbiAqIEBwYXJhbSBmYW1pbHkgLSB0aGUgY29pbiBmYW1pbHlcbiAqIEByZXR1cm5zIHN0YXRpY3MgQmFzZUNvaW4gb2JqZWN0IGZvciB0aGUgbWF0Y2hpbmcgdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRva2VuKFxuICB0b2tlbkNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBuZXR3b3JrOiBCYXNlTmV0d29yayxcbiAgZmFtaWx5OiBzdHJpbmdcbik6IFJlYWRvbmx5PEJhc2VDb2luPiB8IHVuZGVmaW5lZCB7XG4gIC8vIGZpbHRlciB0aGUgY29pbnMgYXJyYXkgdG8gZmluZCB0aGUgdG9rZW4gd2l0aCB0aGUgbWF0Y2hpbmcgY29udHJhY3QgYWRkcmVzcywgbmV0d29yayBhbmQgY29pbiBmYW1pbHlcbiAgLy8gY29pbiBmYW1pbHkgaXMgbmVlZGVkIHRvIGF2b2lkIGNhdXNpbmcgaXNzdWVzIHdoZW4gYSB0b2tlbiBoYXMgc2FtZSBjb250cmFjdCBhZGRyZXNzIG9uIHR3byBkaWZmZXJlbnQgY2hhaW5zXG4gIGNvbnN0IHRva2VucyA9IGNvaW5zLmZpbHRlcigoY29pbikgPT4ge1xuICAgIGlmIChjb2luIGluc3RhbmNlb2YgQ29udHJhY3RBZGRyZXNzRGVmaW5lZFRva2VuKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjb2luLm5ldHdvcmsudHlwZSA9PT0gbmV0d29yay50eXBlICYmXG4gICAgICAgIGNvaW4uZmFtaWx5ID09PSBmYW1pbHkgJiZcbiAgICAgICAgY29pbi5jb250cmFjdEFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gdG9rZW5Db250cmFjdEFkZHJlc3MudG9Mb3dlckNhc2UoKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcblxuICAvLyBpZiBsZW5ndGggb2YgdG9rZW5zIGlzIDEsIHJldHVybiB0aGUgZmlyc3QsIGVsc2UgcmV0dXJuIHVuZGVmaW5lZFxuICAvLyBDYW4ndCBkaXJlY3RseSBpbmRleCBpbnRvIHRva2Vucywgb3IgY2FsbCBgbGVuZ3RoYCwgc28gd2UgdXNlIG1hcCB0byBnZXQgYW4gYXJyYXlcbiAgY29uc3QgdG9rZW5zQXJyYXkgPSB0b2tlbnMubWFwKCh0b2tlbikgPT4gdG9rZW4pO1xuICBpZiAodG9rZW5zQXJyYXkubGVuZ3RoID49IDEpIHtcbiAgICAvLyB0aGVyZSBzaG91bGQgbmV2ZXIgYmUgdHdvIHRva2VucyB3aXRoIHRoZSBzYW1lIGNvbnRyYWN0IGFkZHJlc3MsIHNvIHdlIGFzc2VydCB0aGF0IGhlcmVcbiAgICBhc3NlcnQodG9rZW5zQXJyYXkubGVuZ3RoID09PSAxKTtcbiAgICByZXR1cm4gdG9rZW5zQXJyYXlbMF07XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjcmVhdGUgd2FsbGV0IG1ldGhvZCBjYWxsaW5nIGRhdGEgZm9yIHYxIHdhbGxldHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSB3YWxsZXRPd25lcnMgLSB3YWxsZXQgb3duZXIgYWRkcmVzc2VzIGZvciB3YWxsZXQgaW5pdGlhbGl6YXRpb24gdHJhbnNhY3Rpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gc2FsdCAtIFRoZSBzYWx0IGZvciB3YWxsZXQgaW5pdGlhbGl6YXRpb24gdHJhbnNhY3Rpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBjcmVhdGVXYWxsZXQgbWV0aG9kIGVuY29kZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFYxV2FsbGV0SW5pdGlhbGl6YXRpb25EYXRhKHdhbGxldE93bmVyczogc3RyaW5nW10sIHNhbHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHNhbHRCdWZmZXIgPSBzZXRMZW5ndGhMZWZ0KHRvQnVmZmVyKHNhbHQpLCAzMik7XG4gIGNvbnN0IHBhcmFtcyA9IFt3YWxsZXRPd25lcnMsIHNhbHRCdWZmZXJdO1xuICBjb25zdCBtZXRob2QgPSBFdGhlcmV1bUFiaS5tZXRob2RJRCgnY3JlYXRlV2FsbGV0JywgY3JlYXRlVjFXYWxsZXRUeXBlcyk7XG4gIGNvbnN0IGFyZ3MgPSBFdGhlcmV1bUFiaS5yYXdFbmNvZGUoY3JlYXRlVjFXYWxsZXRUeXBlcywgcGFyYW1zKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChCdWZmZXIuY29uY2F0KFttZXRob2QsIGFyZ3NdKS50b1N0cmluZygnaGV4JykpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNyZWF0ZSBhZGRyZXNzIG1ldGhvZCBjYWxsaW5nIGRhdGEgZm9yIHYxLCB2MiwgdjQgZm9yd2FyZGVyc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlQWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSB3YWxsZXQgY29udHJhY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBzYWx0IC0gVGhlIHNhbHQgZm9yIGFkZHJlc3MgaW5pdGlhbGl6YXRpb24gdHJhbnNhY3Rpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVlQWRkcmVzcyAtIFRoZSBmZWUgYWRkcmVzcyBmb3IgdGhlIGVudGVycHJpc2VcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGNyZWF0ZUZvcndhcmRlciBtZXRob2QgZW5jb2RlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VjFBZGRyZXNzSW5pdGlhbGl6YXRpb25EYXRhKGJhc2VBZGRyZXNzOiBzdHJpbmcsIHNhbHQ6IHN0cmluZywgZmVlQWRkcmVzcz86IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHNhbHRCdWZmZXIgPSBzZXRMZW5ndGhMZWZ0KHRvQnVmZmVyKHNhbHQpLCAzMik7XG4gIGNvbnN0IHsgY3JlYXRlRm9yd2FyZGVyUGFyYW1zLCBjcmVhdGVGb3J3YXJkZXJUeXBlcyB9ID0gZ2V0Q3JlYXRlRm9yd2FyZGVyUGFyYW1zQW5kVHlwZXMoXG4gICAgYmFzZUFkZHJlc3MsXG4gICAgc2FsdEJ1ZmZlcixcbiAgICBmZWVBZGRyZXNzXG4gICk7XG5cbiAgY29uc3QgbWV0aG9kID0gRXRoZXJldW1BYmkubWV0aG9kSUQoJ2NyZWF0ZUZvcndhcmRlcicsIGNyZWF0ZUZvcndhcmRlclR5cGVzKTtcbiAgY29uc3QgYXJncyA9IEV0aGVyZXVtQWJpLnJhd0VuY29kZShjcmVhdGVGb3J3YXJkZXJUeXBlcywgY3JlYXRlRm9yd2FyZGVyUGFyYW1zKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChCdWZmZXIuY29uY2F0KFttZXRob2QsIGFyZ3NdKS50b1N0cmluZygnaGV4JykpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNyZWF0ZSBhZGRyZXNzIG1ldGhvZCBjYWxsaW5nIGRhdGEgZm9yIGFsbCBmb3J3YXJkZXIgdmVyc2lvbnNcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZm9yd2FyZGVyVmVyc2lvbiAtIFRoZSB2ZXJzaW9uIG9mIHRoZSBmb3J3YXJkZXIgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZUFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgd2FsbGV0IGNvbnRyYWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2FsdCAtIFRoZSBzYWx0IGZvciBhZGRyZXNzIGluaXRpYWxpemF0aW9uIHRyYW5zYWN0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IGZlZUFkZHJlc3MgLSBUaGUgZmVlIGFkZHJlc3MgZm9yIHRoZSBlbnRlcnByaXNlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBjcmVhdGVGb3J3YXJkZXIgbWV0aG9kIGVuY29kZWRcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRyZXNzSW5pdERhdGFBbGxGb3J3YXJkZXJWZXJzaW9ucyhcbiAgZm9yd2FyZGVyVmVyc2lvbjogbnVtYmVyLFxuICBiYXNlQWRkcmVzczogc3RyaW5nLFxuICBzYWx0OiBzdHJpbmcsXG4gIGZlZUFkZHJlc3M/OiBzdHJpbmdcbik6IHN0cmluZyB7XG4gIGlmIChmb3J3YXJkZXJWZXJzaW9uID09PSBkZWZhdWx0Rm9yd2FyZGVyVmVyc2lvbikge1xuICAgIHJldHVybiBnZXRBZGRyZXNzSW5pdGlhbGl6YXRpb25EYXRhKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldFYxQWRkcmVzc0luaXRpYWxpemF0aW9uRGF0YShiYXNlQWRkcmVzcywgc2FsdCwgZmVlQWRkcmVzcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjcmVhdGVGb3J3YXJkZXJUeXBlcyBhbmQgY3JlYXRlRm9yd2FyZGVyUGFyYW1zIGZvciBhbGwgZm9yd2FyZGVyIHZlcnNpb25zXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VBZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHdhbGxldCBjb250cmFjdFxuICogQHBhcmFtIHtCdWZmZXJ9IHNhbHRCdWZmZXIgLSBUaGUgc2FsdCBmb3IgYWRkcmVzcyBpbml0aWFsaXphdGlvbiB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGZlZUFkZHJlc3MgLSBUaGUgZmVlIGFkZHJlc3MgZm9yIHRoZSBlbnRlcnByaXNlXG4gKiBAcmV0dXJucyB7Y3JlYXRlRm9yd2FyZGVyUGFyYW1zOiAoc3RyaW5nIHwgQnVmZmVyKVtdLCBjcmVhdGVGb3J3YXJkZXJUeXBlczogc3RyaW5nW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGVGb3J3YXJkZXJQYXJhbXNBbmRUeXBlcyhcbiAgYmFzZUFkZHJlc3M6IHN0cmluZyxcbiAgc2FsdEJ1ZmZlcjogQnVmZmVyLFxuICBmZWVBZGRyZXNzPzogc3RyaW5nXG4pOiB7IGNyZWF0ZUZvcndhcmRlclBhcmFtczogKHN0cmluZyB8IEJ1ZmZlcilbXTsgY3JlYXRlRm9yd2FyZGVyVHlwZXM6IHN0cmluZ1tdIH0ge1xuICBsZXQgY3JlYXRlRm9yd2FyZGVyUGFyYW1zID0gW2Jhc2VBZGRyZXNzLCBzYWx0QnVmZmVyXTtcbiAgbGV0IGNyZWF0ZUZvcndhcmRlclR5cGVzID0gY3JlYXRlVjFGb3J3YXJkZXJUeXBlcztcbiAgaWYgKGZlZUFkZHJlc3MpIHtcbiAgICBjcmVhdGVGb3J3YXJkZXJQYXJhbXMgPSBbYmFzZUFkZHJlc3MsIGZlZUFkZHJlc3MsIHNhbHRCdWZmZXJdO1xuICAgIGNyZWF0ZUZvcndhcmRlclR5cGVzID0gY3JlYXRlVjRGb3J3YXJkZXJUeXBlcztcbiAgfVxuICByZXR1cm4geyBjcmVhdGVGb3J3YXJkZXJQYXJhbXMsIGNyZWF0ZUZvcndhcmRlclR5cGVzIH07XG59XG5cbi8qKlxuICogRGVjb2RlIHRoZSBnaXZlbiBBQkktZW5jb2RlZCBjcmVhdGUgZm9yd2FyZGVyIGRhdGEgYW5kIHJldHVybiBwYXJzZWQgZmllbGRzXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb2RlXG4gKiBAcmV0dXJucyBwYXJzZWQgdHJhbnNmZXIgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRm9yd2FyZGVyQ3JlYXRpb25EYXRhKGRhdGE6IHN0cmluZyk6IEZvcndhcmRlckluaXRpYWxpemF0aW9uRGF0YSB7XG4gIGlmIChcbiAgICAhKFxuICAgICAgZGF0YS5zdGFydHNXaXRoKHY0Q3JlYXRlRm9yd2FyZGVyTWV0aG9kSWQpIHx8XG4gICAgICBkYXRhLnN0YXJ0c1dpdGgodjFDcmVhdGVGb3J3YXJkZXJNZXRob2RJZCkgfHxcbiAgICAgIGRhdGEuc3RhcnRzV2l0aChjcmVhdGVGb3J3YXJkZXJNZXRob2RJZClcbiAgICApXG4gICkge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgYWRkcmVzcyBieXRlY29kZTogJHtkYXRhfWApO1xuICB9XG5cbiAgaWYgKGRhdGEuc3RhcnRzV2l0aChjcmVhdGVGb3J3YXJkZXJNZXRob2RJZCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmFzZUFkZHJlc3M6IHVuZGVmaW5lZCxcbiAgICAgIGFkZHJlc3NDcmVhdGlvblNhbHQ6IHVuZGVmaW5lZCxcbiAgICAgIGZlZUFkZHJlc3M6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9IGVsc2UgaWYgKGRhdGEuc3RhcnRzV2l0aCh2MUNyZWF0ZUZvcndhcmRlck1ldGhvZElkKSkge1xuICAgIGNvbnN0IFtiYXNlQWRkcmVzcywgc2FsdEJ1ZmZlcl0gPSBnZXRSYXdEZWNvZGVkKFxuICAgICAgY3JlYXRlVjFGb3J3YXJkZXJUeXBlcyxcbiAgICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUodjFDcmVhdGVGb3J3YXJkZXJNZXRob2RJZCwgZGF0YSlcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2VBZGRyZXNzOiBhZGRIZXhQcmVmaXgoYmFzZUFkZHJlc3MgYXMgc3RyaW5nKSxcbiAgICAgIGFkZHJlc3NDcmVhdGlvblNhbHQ6IGJ1ZmZlclRvSGV4KHNhbHRCdWZmZXIgYXMgQnVmZmVyKSxcbiAgICAgIGZlZUFkZHJlc3M6IHVuZGVmaW5lZCxcbiAgICB9IGFzIGNvbnN0O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtiYXNlQWRkcmVzcywgZmVlQWRkcmVzcywgc2FsdEJ1ZmZlcl0gPSBnZXRSYXdEZWNvZGVkKFxuICAgICAgY3JlYXRlVjRGb3J3YXJkZXJUeXBlcyxcbiAgICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUodjRDcmVhdGVGb3J3YXJkZXJNZXRob2RJZCwgZGF0YSlcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2VBZGRyZXNzOiBhZGRIZXhQcmVmaXgoYmFzZUFkZHJlc3MgYXMgc3RyaW5nKSxcbiAgICAgIGFkZHJlc3NDcmVhdGlvblNhbHQ6IGJ1ZmZlclRvSGV4KHNhbHRCdWZmZXIgYXMgQnVmZmVyKSxcbiAgICAgIGZlZUFkZHJlc3M6IGFkZEhleFByZWZpeChmZWVBZGRyZXNzIGFzIHN0cmluZyksXG4gICAgfSBhcyBjb25zdDtcbiAgfVxufVxuXG4vKipcbiAqIE1ha2UgYSBxdWVyeSB0byBleHBsb3JlciBmb3IgaW5mb3JtYXRpb24gc3VjaCBhcyBiYWxhbmNlLCB0b2tlbiBiYWxhbmNlLCBzb2xpZGl0eSBjYWxsc1xuICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5IGtleS12YWx1ZSBwYWlycyBvZiBwYXJhbWV0ZXJzIHRvIGFwcGVuZCBhZnRlciAvYXBpXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gdGhlIEFQSSB0b2tlbiB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwbG9yZXJVcmwgdGhlIFVSTCBvZiB0aGUgZXhwbG9yZXJcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IHJlc3BvbnNlIGZyb20gZXhwbG9yZXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlY292ZXJ5QmxvY2tjaGFpbkV4cGxvcmVyUXVlcnkoXG4gIHF1ZXJ5OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICBleHBsb3JlclVybDogc3RyaW5nLFxuICB0b2tlbj86IHN0cmluZ1xuKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4ge1xuICBpZiAodG9rZW4pIHtcbiAgICBxdWVyeS5hcGlrZXkgPSB0b2tlbjtcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QuZ2V0KGAke2V4cGxvcmVyVXJsfS9hcGlgKS5xdWVyeShxdWVyeSk7XG5cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWNoIGV4cGxvcmVyJyk7XG4gIH1cblxuICBpZiAocmVzcG9uc2UuYm9keS5zdGF0dXMgPT09ICcwJyAmJiByZXNwb25zZS5ib2R5Lm1lc3NhZ2UgPT09ICdOT1RPSycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGxvcmVyIHJhdGUgbGltaXQgcmVhY2hlZCcpO1xuICB9XG4gIHJldHVybiByZXNwb25zZS5ib2R5O1xufVxuIl19