"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = exports.MIN_ADA_FOR_ONE_ASSET = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const cardano_serialization_lib_nodejs_1 = require("@emurgo/cardano-serialization-lib-nodejs");
const keyPair_1 = require("./keyPair");
const bech32_1 = require("bech32");
exports.MIN_ADA_FOR_ONE_ASSET = '1500000';
class Utils {
    createBaseAddressWithStakeAndPaymentKey(stakeKeyPair, paymentKeyPair, network) {
        let baseAddr;
        if (network === sdk_core_1.AddressFormat.mainnet) {
            // 1. create stake pubKey
            const key = stakeKeyPair.getKeys().pub;
            const stakePub = cardano_serialization_lib_nodejs_1.PublicKey.from_bytes(Buffer.from(key, 'hex'));
            // 2. create payment pubKey
            const paymentPub = cardano_serialization_lib_nodejs_1.PublicKey.from_bytes(Buffer.from(paymentKeyPair.getKeys().pub, 'hex'));
            // 3. create full base address for staking
            baseAddr = cardano_serialization_lib_nodejs_1.BaseAddress.new(cardano_serialization_lib_nodejs_1.NetworkInfo.mainnet().network_id(), cardano_serialization_lib_nodejs_1.StakeCredential.from_keyhash(paymentPub.hash()), cardano_serialization_lib_nodejs_1.StakeCredential.from_keyhash(stakePub.hash()));
            return baseAddr.to_address().to_bech32();
        }
        else if (network === sdk_core_1.AddressFormat.testnet) {
            // 1. create stake pubKey
            const stakePub = cardano_serialization_lib_nodejs_1.PublicKey.from_bytes(Buffer.from(stakeKeyPair.getKeys().pub, 'hex'));
            // 2. create payment pubKey
            const paymentPub = cardano_serialization_lib_nodejs_1.PublicKey.from_bytes(Buffer.from(paymentKeyPair.getKeys().pub, 'hex'));
            // 3. create full base address for staking
            const baseAddr = cardano_serialization_lib_nodejs_1.BaseAddress.new(cardano_serialization_lib_nodejs_1.NetworkInfo.testnet().network_id(), cardano_serialization_lib_nodejs_1.StakeCredential.from_keyhash(paymentPub.hash()), cardano_serialization_lib_nodejs_1.StakeCredential.from_keyhash(stakePub.hash()));
            return baseAddr.to_address().to_bech32();
        }
        else {
            throw new Error('Improper Network Type!');
        }
    }
    validateBlake2b(hash) {
        if (!hash) {
            return false;
        }
        if (hash.length !== 64) {
            return false;
        }
        return hash.match(/^[a-zA-Z0-9]+$/) !== null;
    }
    getRewardAddress(stakingPubKey, coinName) {
        const stakePub = cardano_serialization_lib_nodejs_1.PublicKey.from_bytes(Buffer.from(stakingPubKey, 'hex'));
        let rewardAddress;
        if (coinName === 'ada') {
            rewardAddress = cardano_serialization_lib_nodejs_1.RewardAddress.new(cardano_serialization_lib_nodejs_1.NetworkInfo.mainnet().network_id(), cardano_serialization_lib_nodejs_1.StakeCredential.from_keyhash(stakePub.hash()));
        }
        else {
            rewardAddress = cardano_serialization_lib_nodejs_1.RewardAddress.new(cardano_serialization_lib_nodejs_1.NetworkInfo.testnet().network_id(), cardano_serialization_lib_nodejs_1.StakeCredential.from_keyhash(stakePub.hash()));
        }
        return rewardAddress.to_address().to_bech32();
    }
    /** @inheritdoc */
    // this will validate both stake and payment addresses
    isValidAddress(address) {
        const bech32PrefixList = ['addr', 'addr_test', 'stake', 'stake_test'];
        const BASE_ADDR_LEN = 92;
        const REWARD_AND_ENTERPRISE_ADDR_LEN = 47;
        const POINTER_ADDR_LEN = 52;
        const VALIDATOR_ADDR_LEN = 56;
        // test if this is a bech32 address first
        if (new RegExp(bech32PrefixList.join('|')).test(address)) {
            try {
                const decodedBech = bech32_1.bech32.decode(address, 108);
                const wordLength = decodedBech.words.length;
                if (!bech32PrefixList.includes(decodedBech.prefix)) {
                    return false;
                }
                return (wordLength === BASE_ADDR_LEN ||
                    wordLength === REWARD_AND_ENTERPRISE_ADDR_LEN ||
                    wordLength === POINTER_ADDR_LEN);
            }
            catch (err) {
                return false;
            }
        }
        else {
            // maybe this is a validator address
            return new RegExp(`^(?!pool)[a-z0-9]\{${VALIDATOR_ADDR_LEN}\}$`).test(address);
        }
    }
    /** @inheritdoc */
    isValidBlockId(hash) {
        return this.validateBlake2b(hash);
    }
    /** @inheritdoc */
    isValidPrivateKey(key) {
        // this will return true for both extended and non-extended ED25519 keys
        return this.isValidKey(key);
    }
    isValidKey(key) {
        try {
            new keyPair_1.KeyPair({ prv: key });
            return true;
        }
        catch {
            return false;
        }
    }
    /** @inheritdoc */
    isValidPublicKey(pubKey) {
        try {
            new keyPair_1.KeyPair({ pub: pubKey });
            return true;
        }
        catch {
            return false;
        }
    }
    /** @inheritdoc */
    isValidSignature(signature) {
        try {
            cardano_serialization_lib_nodejs_1.Ed25519Signature.from_hex(signature);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    /** @inheritdoc */
    isValidTransactionId(txId) {
        return this.validateBlake2b(txId);
    }
    /**
     * Get the transaction body from a serialized transaction
     * @param {string} serializedTx - serialized transaction in hex or base64 format
     * @returns {string} transaction body in hex format
     */
    getTransactionBody(serializedTx) {
        const HEX_REGEX = /^[0-9a-fA-F]+$/;
        const bufferRawTransaction = HEX_REGEX.test(serializedTx)
            ? Buffer.from(serializedTx, 'hex')
            : Buffer.from(serializedTx, 'base64');
        return Buffer.from(cardano_serialization_lib_nodejs_1.Transaction.from_bytes(bufferRawTransaction).body().to_bytes()).toString('hex');
    }
}
exports.Utils = Utils;
const utils = new Utils();
exports.default = utils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDhDQUEyRDtBQUMzRCwrRkFRa0Q7QUFDbEQsdUNBQW9DO0FBQ3BDLG1DQUFnQztBQUVuQixRQUFBLHFCQUFxQixHQUFHLFNBQVMsQ0FBQztBQUUvQyxNQUFhLEtBQUs7SUFDaEIsdUNBQXVDLENBQ3JDLFlBQXFCLEVBQ3JCLGNBQXVCLEVBQ3ZCLE9BQXNCO1FBRXRCLElBQUksUUFBUSxDQUFDO1FBQ2IsSUFBSSxPQUFPLEtBQUssd0JBQWEsQ0FBQyxPQUFPLEVBQUU7WUFDckMseUJBQXlCO1lBQ3pCLE1BQU0sR0FBRyxHQUFHLFlBQVksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUM7WUFFdkMsTUFBTSxRQUFRLEdBQUcsNENBQVMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUMvRCwyQkFBMkI7WUFDM0IsTUFBTSxVQUFVLEdBQUcsNENBQVMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDMUYsMENBQTBDO1lBQzFDLFFBQVEsR0FBRyw4Q0FBVyxDQUFDLEdBQUcsQ0FDeEIsOENBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxVQUFVLEVBQUUsRUFDbEMsa0RBQWUsQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQy9DLGtEQUFlLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUM5QyxDQUFDO1lBQ0YsT0FBTyxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUMsU0FBUyxFQUFFLENBQUM7U0FDMUM7YUFBTSxJQUFJLE9BQU8sS0FBSyx3QkFBYSxD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QUFrQjtJQUNsQixnQkFBZ0IsQ0FBQyxTQUFpQjtRQUNoQyxJQUFJO1lBQ0YsbURBQWdCLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3JDLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNaLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7SUFDSCxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLG9CQUFvQixDQUFDLElBQVk7UUFDL0IsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsa0JBQWtCLENBQUMsWUFBb0I7UUFDckMsTUFBTSxTQUFTLEdBQUcsZ0JBQWdCLENBQUM7UUFDbkMsTUFBTSxvQkFBb0IsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQztZQUN2RCxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsS0FBSyxDQUFDO1lBQ2xDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxRQUFRLENBQUMsQ0FBQztRQUN4QyxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsOENBQWtCLENBQUMsVUFBVSxDQUFDLG9CQUFvQixDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDNUcsQ0FBQztDQUNGO0FBekpELHNCQXlKQztBQUVELE1BQU0sS0FBSyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7QUFFMUIsa0JBQWUsS0FBSyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWRkcmVzc0Zvcm1hdCwgQmFzZVV0aWxzIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7XG4gIEJhc2VBZGRyZXNzLFxuICBQdWJsaWNLZXksXG4gIEVkMjU1MTlTaWduYXR1cmUsXG4gIE5ldHdvcmtJbmZvLFxuICBTdGFrZUNyZWRlbnRpYWwsXG4gIFJld2FyZEFkZHJlc3MsXG4gIFRyYW5zYWN0aW9uIGFzIENhcmRhbm9UcmFuc2FjdGlvbixcbn0gZnJvbSAnQGVtdXJnby9jYXJkYW5vLXNlcmlhbGl6YXRpb24tbGliLW5vZGVqcyc7XG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLi9rZXlQYWlyJztcbmltcG9ydCB7IGJlY2gzMiB9IGZyb20gJ2JlY2gzMic7XG5cbmV4cG9ydCBjb25zdCBNSU5fQURBX0ZPUl9PTkVfQVNTRVQgPSAnMTUwMDAwMCc7XG5cbmV4cG9ydCBjbGFzcyBVdGlscyBpbXBsZW1lbnRzIEJhc2VVdGlscyB7XG4gIGNyZWF0ZUJhc2VBZGRyZXNzV2l0aFN0YWtlQW5kUGF5bWVudEtleShcbiAgICBzdGFrZUtleVBhaXI6IEtleVBhaXIsXG4gICAgcGF5bWVudEtleVBhaXI6IEtleVBhaXIsXG4gICAgbmV0d29yazogQWRkcmVzc0Zvcm1hdFxuICApOiBzdHJpbmcge1xuICAgIGxldCBiYXNlQWRkcjtcbiAgICBpZiAobmV0d29yayA9PT0gQWRkcmVzc0Zvcm1hdC5tYWlubmV0KSB7XG4gICAgICAvLyAxLiBjcmVhdGUgc3Rha2UgcHViS2V5XG4gICAgICBjb25zdCBrZXkgPSBzdGFrZUtleVBhaXIuZ2V0S2V5cygpLnB1YjtcblxuICAgICAgY29uc3Qgc3Rha2VQdWIgPSBQdWJsaWNLZXkuZnJvbV9ieXRlcyhCdWZmZXIuZnJvbShrZXksICdoZXgnKSk7XG4gICAgICAvLyAyLiBjcmVhdGUgcGF5bWVudCBwdWJLZXlcbiAgICAgIGNvbnN0IHBheW1lbnRQdWIgPSBQdWJsaWNLZXkuZnJvbV9ieXRlcyhCdWZmZXIuZnJvbShwYXltZW50S2V5UGFpci5nZXRLZXlzKCkucHViLCAnaGV4JykpO1xuICAgICAgLy8gMy4gY3JlYXRlIGZ1bGwgYmFzZSBhZGRyZXNzIGZvciBzdGFraW5nXG4gICAgICBiYXNlQWRkciA9IEJhc2VBZGRyZXNzLm5ldyhcbiAgICAgICAgTmV0d29ya0luZm8ubWFpbm5ldCgpLm5ldHdvcmtfaWQoKSxcbiAgICAgICAgU3Rha2VDcmVkZW50aWFsLmZyb21fa2V5aGFzaChwYXltZW50UHViLmhhc2goKSksXG4gICAgICAgIFN0YWtlQ3JlZGVudGlhbC5mcm9tX2tleWhhc2goc3Rha2VQdWIuaGFzaCgpKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBiYXNlQWRkci50b19hZGRyZXNzKCkudG9fYmVjaDMyKCk7XG4gICAgfSBlbHNlIGlmIChuZXR3b3JrID09PSBBZGRyZXNzRm9ybWF0LnRlc3RuZXQpIHtcbiAgICAgIC8vIDEuIGNyZWF0ZSBzdGFrZSBwdWJLZXlcbiAgICAgIGNvbnN0IHN0YWtlUHViID0gUHVibGljS2V5LmZyb21fYnl0ZXMoQnVmZmVyLmZyb20oc3Rha2VLZXlQYWlyLmdldEtleXMoKS5wdWIsICdoZXgnKSk7XG4gICAgICAvLyAyLiBjcmVhdGUgcGF5bWVudCBwdWJLZXlcbiAgICAgIGNvbnN0IHBheW1lbnRQdWIgPSBQdWJsaWNLZXkuZnJvbV9ieXRlcyhCdWZmZXIuZnJvbShwYXltZW50S2V5UGFpci5nZXRLZXlzKCkucHViLCAnaGV4JykpO1xuICAgICAgLy8gMy4gY3JlYXRlIGZ1bGwgYmFzZSBhZGRyZXNzIGZvciBzdGFraW5nXG4gICAgICBjb25zdCBiYXNlQWRkciA9IEJhc2VBZGRyZXNzLm5ldyhcbiAgICAgICAgTmV0d29ya0luZm8udGVzdG5ldCgpLm5ldHdvcmtfaWQoKSxcbiAgICAgICAgU3Rha2VDcmVkZW50aWFsLmZyb21fa2V5aGFzaChwYXltZW50UHViLmhhc2goKSksXG4gICAgICAgIFN0YWtlQ3JlZGVudGlhbC5mcm9tX2tleWhhc2goc3Rha2VQdWIuaGFzaCgpKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBiYXNlQWRkci50b19hZGRyZXNzKCkudG9fYmVjaDMyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW1wcm9wZXIgTmV0d29yayBUeXBlIScpO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlQmxha2UyYihoYXNoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIWhhc2gpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGhhc2gubGVuZ3RoICE9PSA2NCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaC5tYXRjaCgvXlthLXpBLVowLTldKyQvKSAhPT0gbnVsbDtcbiAgfVxuXG4gIGdldFJld2FyZEFkZHJlc3Moc3Rha2luZ1B1YktleTogc3RyaW5nLCBjb2luTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBzdGFrZVB1YiA9IFB1YmxpY0tleS5mcm9tX2J5dGVzKEJ1ZmZlci5mcm9tKHN0YWtpbmdQdWJLZXksICdoZXgnKSk7XG4gICAgbGV0IHJld2FyZEFkZHJlc3M7XG4gICAgaWYgKGNvaW5OYW1lID09PSAnYWRhJykge1xuICAgICAgcmV3YXJkQWRkcmVzcyA9IFJld2FyZEFkZHJlc3MubmV3KFxuICAgICAgICBOZXR3b3JrSW5mby5tYWlubmV0KCkubmV0d29ya19pZCgpLFxuICAgICAgICBTdGFrZUNyZWRlbnRpYWwuZnJvbV9rZXloYXNoKHN0YWtlUHViLmhhc2goKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJld2FyZEFkZHJlc3MgPSBSZXdhcmRBZGRyZXNzLm5ldyhcbiAgICAgICAgTmV0d29ya0luZm8udGVzdG5ldCgpLm5ldHdvcmtfaWQoKSxcbiAgICAgICAgU3Rha2VDcmVkZW50aWFsLmZyb21fa2V5aGFzaChzdGFrZVB1Yi5oYXNoKCkpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmV3YXJkQWRkcmVzcy50b19hZGRyZXNzKCkudG9fYmVjaDMyKCk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgLy8gdGhpcyB3aWxsIHZhbGlkYXRlIGJvdGggc3Rha2UgYW5kIHBheW1lbnQgYWRkcmVzc2VzXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGJlY2gzMlByZWZpeExpc3QgPSBbJ2FkZHInLCAnYWRkcl90ZXN0JywgJ3N0YWtlJywgJ3N0YWtlX3Rlc3QnXTtcbiAgICBjb25zdCBCQVNFX0FERFJfTEVOID0gOTI7XG4gICAgY29uc3QgUkVXQVJEX0FORF9FTlRFUlBSSVNFX0FERFJfTEVOID0gNDc7XG4gICAgY29uc3QgUE9JTlRFUl9BRERSX0xFTiA9IDUyO1xuICAgIGNvbnN0IFZBTElEQVRPUl9BRERSX0xFTiA9IDU2O1xuXG4gICAgLy8gdGVzdCBpZiB0aGlzIGlzIGEgYmVjaDMyIGFkZHJlc3MgZmlyc3RcbiAgICBpZiAobmV3IFJlZ0V4cChiZWNoMzJQcmVmaXhMaXN0LmpvaW4oJ3wnKSkudGVzdChhZGRyZXNzKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlZEJlY2ggPSBiZWNoMzIuZGVjb2RlKGFkZHJlc3MsIDEwOCk7XG4gICAgICAgIGNvbnN0IHdvcmRMZW5ndGggPSBkZWNvZGVkQmVjaC53b3Jkcy5sZW5ndGg7XG4gICAgICAgIGlmICghYmVjaDMyUHJlZml4TGlzdC5pbmNsdWRlcyhkZWNvZGVkQmVjaC5wcmVmaXgpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgd29yZExlbmd0aCA9PT0gQkFTRV9BRERSX0xFTiB8fFxuICAgICAgICAgIHdvcmRMZW5ndGggPT09IFJFV0FSRF9BTkRfRU5URVJQUklTRV9BRERSX0xFTiB8fFxuICAgICAgICAgIHdvcmRMZW5ndGggPT09IFBPSU5URVJfQUREUl9MRU5cbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG1heWJlIHRoaXMgaXMgYSB2YWxpZGF0b3IgYWRkcmVzc1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4oPyFwb29sKVthLXowLTldXFx7JHtWQUxJREFUT1JfQUREUl9MRU59XFx9JGApLnRlc3QoYWRkcmVzcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRCbG9ja0lkKGhhc2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlQmxha2UyYihoYXNoKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkUHJpdmF0ZUtleShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIC8vIHRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBmb3IgYm90aCBleHRlbmRlZCBhbmQgbm9uLWV4dGVuZGVkIEVEMjU1MTkga2V5c1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRLZXkoa2V5KTtcbiAgfVxuXG4gIGlzVmFsaWRLZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEtleVBhaXIoeyBwcnY6IGtleSB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkUHVibGljS2V5KHB1YktleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBLZXlQYWlyKHsgcHViOiBwdWJLZXkgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZFNpZ25hdHVyZShzaWduYXR1cmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBFZDI1NTE5U2lnbmF0dXJlLmZyb21faGV4KHNpZ25hdHVyZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZFRyYW5zYWN0aW9uSWQodHhJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGVCbGFrZTJiKHR4SWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHJhbnNhY3Rpb24gYm9keSBmcm9tIGEgc2VyaWFsaXplZCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VyaWFsaXplZFR4IC0gc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBpbiBoZXggb3IgYmFzZTY0IGZvcm1hdFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0cmFuc2FjdGlvbiBib2R5IGluIGhleCBmb3JtYXRcbiAgICovXG4gIGdldFRyYW5zYWN0aW9uQm9keShzZXJpYWxpemVkVHg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgSEVYX1JFR0VYID0gL15bMC05YS1mQS1GXSskLztcbiAgICBjb25zdCBidWZmZXJSYXdUcmFuc2FjdGlvbiA9IEhFWF9SRUdFWC50ZXN0KHNlcmlhbGl6ZWRUeClcbiAgICAgID8gQnVmZmVyLmZyb20oc2VyaWFsaXplZFR4LCAnaGV4JylcbiAgICAgIDogQnVmZmVyLmZyb20oc2VyaWFsaXplZFR4LCAnYmFzZTY0Jyk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKENhcmRhbm9UcmFuc2FjdGlvbi5mcm9tX2J5dGVzKGJ1ZmZlclJhd1RyYW5zYWN0aW9uKS5ib2R5KCkudG9fYnl0ZXMoKSkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG59XG5cbmNvbnN0IHV0aWxzID0gbmV3IFV0aWxzKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHV0aWxzO1xuIl19