"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdaToken = void 0;
const ada_1 = require("./ada");
const statics_1 = require("@bitgo/statics");
class AdaToken extends ada_1.Ada {
    constructor(bitgo, tokenConfig) {
        const staticsCoin = tokenConfig.network === 'Mainnet' ? statics_1.coins.get('ada') : statics_1.coins.get('tada');
        super(bitgo, staticsCoin);
        this.tokenConfig = tokenConfig;
    }
    static createTokenConstructor(config) {
        return (bitgo) => new AdaToken(bitgo, config);
    }
    static createTokenConstructors() {
        const tokensCtors = [];
        for (const token of [...statics_1.tokens.bitcoin.ada.tokens, ...statics_1.tokens.testnet.ada.tokens]) {
            const tokenConstructor = AdaToken.createTokenConstructor(token);
            tokensCtors.push({ name: token.type, coinConstructor: tokenConstructor });
        }
        return tokensCtors;
    }
    get name() {
        return this.tokenConfig.name;
    }
    get coin() {
        return this.tokenConfig.coin;
    }
    get network() {
        return this.tokenConfig.network;
    }
    get policyId() {
        return this.tokenConfig.policyId;
    }
    get assetName() {
        return this.tokenConfig.assetName;
    }
    get decimalPlaces() {
        return this.tokenConfig.decimalPlaces;
    }
    getChain() {
        return this.tokenConfig.type;
    }
    getBaseChain() {
        return this.coin;
    }
    getFullName() {
        return 'Cardano Token';
    }
    getBaseFactor() {
        return Math.pow(10, this.tokenConfig.decimalPlaces);
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return false;
    }
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (CELO), false otherwise
     */
    transactionDataAllowed() {
        return false;
    }
}
exports.AdaToken = AdaToken;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRhVG9rZW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYWRhVG9rZW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsK0JBQTRCO0FBRTVCLDRDQUErQztBQVkvQyxNQUFhLFFBQVMsU0FBUSxTQUFHO0lBRy9CLFlBQVksS0FBZ0IsRUFBRSxXQUEyQjtRQUN2RCxNQUFNLFdBQVcsR0FBRyxXQUFXLENBQUMsT0FBTyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsZUFBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsZUFBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM3RixLQUFLLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQzFCLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0lBQ2pDLENBQUM7SUFFRCxNQUFNLENBQUMsc0JBQXNCLENBQUMsTUFBc0I7UUFDbEQsT0FBTyxDQUFDLEtBQWdCLEVBQUUsRUFBRSxDQUFDLElBQUksUUFBUSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRUQsTUFBTSxDQUFDLHVCQUF1QjtRQUM1QixNQUFNLFdBQVcsR0FBMkIsRUFBRSxDQUFDO1FBQy9DLEtBQUssTUFBTSxLQUFLLElBQUksQ0FBQyxHQUFHLGdCQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxnQkFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDaEYsTUFBTSxnQkFBZ0IsR0FBRyxRQUFRLENBQUMsc0JBQXNCLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDaEUsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsSUFBSSxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7U0FDM0U7UUFDRCxPQUFPLFdBQVcsQ0FBQztJQUNyQixDQUFDO0lBRUQsSUFBSSxJQUFJO1FBQ04sT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztJQUMvQixDQUFDO0lBRUQsSUFBSSxJQUFJO1FBQ04sT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztJQUMvQixDQUFDO0lBRUQsSUFBSSxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQztJQUNsQyxDQUFDO0lBRUQsSUFBSSxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQztJQUNuQyxDQUFDO0lBRUQsSUFBSSxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQztJQUNwQyxDQUFDO0lBRUQsSUFBSSxhQUFhO1FBQ2YsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQztJQUN4QyxDQUFDO0lBRUQsUUFBUTtRQUNOLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7SUFDL0IsQ0FBQztJQUVELFlBQVk7UUFDVixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDbkIsQ0FBQztJQUVELFdBQVc7UUFDVCxPQUFPLGVBQWUsQ0FBQztJQUN6QixDQUFDO0lBRUQsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsd0JBQXdCO1FBQ3RCLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOzs7T0FHRztJQUNILHNCQUFzQjtRQUNwQixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7Q0FDRjtBQTdFRCw0QkE2RUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZGEgfSBmcm9tICcuL2FkYSc7XG5pbXBvcnQgeyBCaXRHb0Jhc2UsIENvaW5Db25zdHJ1Y3RvciwgTmFtZWRDb2luQ29uc3RydWN0b3IgfSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgY29pbnMsIHRva2VucyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcblxuZXhwb3J0IGludGVyZmFjZSBBZGFUb2tlbkNvbmZpZyB7XG4gIG5hbWU6IHN0cmluZztcbiAgdHlwZTogc3RyaW5nO1xuICBjb2luOiBzdHJpbmc7XG4gIG5ldHdvcms6IHN0cmluZztcbiAgcG9saWN5SWQ6IHN0cmluZztcbiAgYXNzZXROYW1lOiBzdHJpbmc7XG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEFkYVRva2VuIGV4dGVuZHMgQWRhIHtcbiAgcHVibGljIHJlYWRvbmx5IHRva2VuQ29uZmlnOiBBZGFUb2tlbkNvbmZpZztcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlLCB0b2tlbkNvbmZpZzogQWRhVG9rZW5Db25maWcpIHtcbiAgICBjb25zdCBzdGF0aWNzQ29pbiA9IHRva2VuQ29uZmlnLm5ldHdvcmsgPT09ICdNYWlubmV0JyA/IGNvaW5zLmdldCgnYWRhJykgOiBjb2lucy5nZXQoJ3RhZGEnKTtcbiAgICBzdXBlcihiaXRnbywgc3RhdGljc0NvaW4pO1xuICAgIHRoaXMudG9rZW5Db25maWcgPSB0b2tlbkNvbmZpZztcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVUb2tlbkNvbnN0cnVjdG9yKGNvbmZpZzogQWRhVG9rZW5Db25maWcpOiBDb2luQ29uc3RydWN0b3Ige1xuICAgIHJldHVybiAoYml0Z286IEJpdEdvQmFzZSkgPT4gbmV3IEFkYVRva2VuKGJpdGdvLCBjb25maWcpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZVRva2VuQ29uc3RydWN0b3JzKCk6IE5hbWVkQ29pbkNvbnN0cnVjdG9yW10ge1xuICAgIGNvbnN0IHRva2Vuc0N0b3JzOiBOYW1lZENvaW5Db25zdHJ1Y3RvcltdID0gW107XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiBbLi4udG9rZW5zLmJpdGNvaW4uYWRhLnRva2VucywgLi4udG9rZW5zLnRlc3RuZXQuYWRhLnRva2Vuc10pIHtcbiAgICAgIGNvbnN0IHRva2VuQ29uc3RydWN0b3IgPSBBZGFUb2tlbi5jcmVhdGVUb2tlbkNvbnN0cnVjdG9yKHRva2VuKTtcbiAgICAgIHRva2Vuc0N0b3JzLnB1c2goeyBuYW1lOiB0b2tlbi50eXBlLCBjb2luQ29uc3RydWN0b3I6IHRva2VuQ29uc3RydWN0b3IgfSk7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnNDdG9ycztcbiAgfVxuXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VuQ29uZmlnLm5hbWU7XG4gIH1cblxuICBnZXQgY29pbigpIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbkNvbmZpZy5jb2luO1xuICB9XG5cbiAgZ2V0IG5ldHdvcmsoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5Db25maWcubmV0d29yaztcbiAgfVxuXG4gIGdldCBwb2xpY3lJZCgpIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbkNvbmZpZy5wb2xpY3lJZDtcbiAgfVxuXG4gIGdldCBhc3NldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5Db25maWcuYXNzZXROYW1lO1xuICB9XG5cbiAgZ2V0IGRlY2ltYWxQbGFjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5Db25maWcuZGVjaW1hbFBsYWNlcztcbiAgfVxuXG4gIGdldENoYWluKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VuQ29uZmlnLnR5cGU7XG4gIH1cblxuICBnZXRCYXNlQ2hhaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29pbjtcbiAgfVxuXG4gIGdldEZ1bGxOYW1lKCkge1xuICAgIHJldHVybiAnQ2FyZGFubyBUb2tlbic7XG4gIH1cblxuICBnZXRCYXNlRmFjdG9yKCkge1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy50b2tlbkNvbmZpZy5kZWNpbWFsUGxhY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBzZW5kaW5nIHZhbHVlIG9mIDBcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIDAgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBzZW5kaW5nIGRhdGEgYWxvbmcgd2l0aCB0cmFuc2FjdGlvbnNcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIHR4IGRhdGEgKENFTE8pLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHRyYW5zYWN0aW9uRGF0YUFsbG93ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iXX0=