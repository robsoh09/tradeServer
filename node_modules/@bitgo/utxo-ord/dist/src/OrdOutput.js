"use strict";
/*

Classes used for tracking sats across transactions.

https://github.com/casey/ord/blob/master/bip.mediawiki#design

> The ordinal numbers of sats in transaction inputs are transferred to output sats in
> first-in-first-out order, according to the size and order of the transactions inputs and outputs.


Sample scenario:
   inputs         i0, i1, i2
   outputs        u0, u1
   inscriptions   r0, r1, r2, r3, r4


createOutputs(
  [i0, i1],
  [
    [u0, [r0, r1]],
    [u1, [r2, r3]],
  ]
);

  r4 is donated to the miner

  ┌────────┬────────┐
  │ i0     │ u0     │
  │        │        │
  │     r0 ┼        │
  │        │        │
  ├────────┤        │
  │ i1     │        │
  │     r1 ┼        │
  │        │        │
  │        ├────────┤
  │        │ u1     │
  │     r2 ┼        │
  │        │        │
  ├────────┤        │
  │ i2     │        │
  │     r3 ┼        │
  │        │        │
  │        │        │
  │        ├────────┘
  │        │
  │     r4 ┼
  │        │
  └────────┘

 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrdOutput = exports.InvalidOrdOutput = void 0;
const SatRange_1 = require("./SatRange");
class InvalidOrdOutput extends Error {
    constructor(message, value, ordinals) {
        super(message);
        this.value = value;
        this.ordinals = ordinals;
    }
}
exports.InvalidOrdOutput = InvalidOrdOutput;
/**
 * The ordinal metadata for an output
 */
class OrdOutput {
    /**
     * @param value - the input value
     * @param ordinals - The ordinal ranges of an output, relative to the first satoshi.
     *                   Required to be ordered and non-overlapping.
     *                   Not required to be exhaustive.
     */
    constructor(value, ordinals = []) {
        this.value = value;
        this.ordinals = ordinals;
        const maxRange = this.asSatRange();
        ordinals.forEach((r, i) => {
            if (!maxRange.isSupersetOf(r)) {
                throw new InvalidOrdOutput(`range ${r} outside output maxRange ${maxRange}`, value, ordinals);
            }
            if (0 < i) {
                const prevRange = ordinals[i - 1];
                if (r.start <= prevRange.end) {
                    throw new InvalidOrdOutput(`SatRange #${i - 1} ${prevRange} overlaps SatRange #${i} ${r}`, value, ordinals);
                }
            }
        });
    }
    /**
     * @param other
     * @return OrdOutput extended by other.value and SatRanges shifted by this.value
     */
    joinedWith(other) {
        return new OrdOutput(this.value + other.value, [
            ...this.ordinals,
            ...other.ordinals.map((r) => r.shiftedBy(this.value)),
        ]);
    }
    /**
     * @param ords
     * @return single OrdOutput containing all SatRanges, shifted by preceding output values
     */
    static joinAll(ords) {
        if (ords.length === 0) {
            throw new TypeError(`empty input`);
        }
        return ords.reduce((a, b) => a.joinedWith(b));
    }
    asSatRange() {
        return new SatRange_1.SatRange(BigInt(0), this.value - BigInt(1));
    }
    /**
     * @param r
     * @return new OrdOutput with all ranges fully contained in _r_. SatRanges are aligned to new start.
     */
    fromSatRange(r) {
        return new OrdOutput(r.size(), this.ordinals.flatMap((s) => {
            if (r.intersectsWith(s)) {
                if (!r.isSupersetOf(s)) {
                    throw new Error(`partial overlap in ${r} and ${s}`);
                }
                return s.shiftedBy(-r.start);
            }
            return [];
        }));
    }
    /**
     * @param value
     * @return first OrdOutput with value `value`, second OrdOutput with remaining value.
     *         With respective SatRanges
     */
    splitAt(value) {
        if (this.value < value) {
            throw new Error(`must split at value inside range`);
        }
        return [
            this.fromSatRange(new SatRange_1.SatRange(BigInt(0), value - BigInt(1))),
            this.fromSatRange(new SatRange_1.SatRange(value, this.value - BigInt(1))),
        ];
    }
    /**
     * Like splitAt but returns _null_ where a zero-sized OrdOutput would be
     * @param value
     */
    splitAtAllowZero(value) {
        if (value === BigInt(0)) {
            return [null, this.fromSatRange(this.asSatRange())];
        }
        if (value === this.value) {
            return [this.fromSatRange(this.asSatRange()), null];
        }
        return this.splitAt(value);
    }
    /**
     * Split output successively at values.
     * @param values
     * @param exact - when set, ensure that value sum matches _this.value_
     * @param allowZero - when set, return _null_ for zero-sized values
     * @return (OrdOutput | null)[]. Zero-sized outputs are substituted with _null_.
     */
    splitAllWithParams(values, { exact = false, allowZero = false }) {
        if (values.length === 0) {
            throw new Error(`invalid argument`);
        }
        if (exact) {
            const valueSum = values.reduce((a, b) => a + b, BigInt(0));
            if (this.value !== valueSum) {
                throw new Error(`value sum ${valueSum} does not match this.value ${this.value}`);
            }
            return this.splitAllWithParams(values.slice(0, -1), { allowZero, exact: false });
        }
        const [v, ...rest] = values;
        const [a, b] = allowZero ? this.splitAtAllowZero(v) : this.splitAt(v);
        if (rest.length) {
            if (b === null) {
                throw new Error(`invalid remainder`);
            }
            else {
                return [a, ...b.splitAllWithParams(rest, { exact, allowZero })];
            }
        }
        else {
            return [a, b];
        }
    }
    /**
     * Split output successively at values.
     * @param values
     * @return OrdOutput[] with length _values.length + 1_
     */
    splitAll(values) {
        return this.splitAllWithParams(values, { exact: false, allowZero: false });
    }
}
exports.OrdOutput = OrdOutput;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT3JkT3V0cHV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL09yZE91dHB1dC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0RHOzs7QUFFSCx5Q0FBc0M7QUFFdEMsTUFBYSxnQkFBaUIsU0FBUSxLQUFLO0lBQ3pDLFlBQVksT0FBZSxFQUFTLEtBQWEsRUFBUyxRQUFvQjtRQUM1RSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFEbUIsVUFBSyxHQUFMLEtBQUssQ0FBUTtRQUFTLGFBQVEsR0FBUixRQUFRLENBQVk7SUFFOUUsQ0FBQztDQUNGO0FBSkQsNENBSUM7QUFFRDs7R0FFRztBQUNILE1BQWEsU0FBUztJQUNwQjs7Ozs7T0FLRztJQUNILFlBQW1CLEtBQWEsRUFBUyxXQUF1QixFQUFFO1FBQS9DLFVBQUssR0FBTCxLQUFLLENBQVE7UUFBUyxhQUFRLEdBQVIsUUFBUSxDQUFpQjtRQUNoRSxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDbkMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN4QixJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRTtnQkFDN0IsTUFBTSxJQUFJLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyw0QkFBNEIsUUFBUSxFQUFFLEVBQUUsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO2FBQy9GO1lBQ0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNULE1BQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQ2xDLElBQUksQ0FBQyxDQUFDLEtBQUssSUFBSSxTQUFTLENBQUMsR0FBRyxFQUFFO29CQUM1QixNQUFNLElBQUksZ0JBQWdCLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxJQUFJLFNBQVMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7aUJBQzdHO2FBQ0Y7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSCxVQUFVLENBQUMsS0FBZ0I7UUFDekIsT0FBTyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUU7WUFDN0MsR0FBRyxJQUFJLENBQUMsUUFBUTtZQUNoQixHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN0RCxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFpQjtRQUM5QixJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3JCLE1BQU0sSUFBSSxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDcEM7UUFDRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVELFVBQVU7UUFDUixPQUFPLElBQUksbUJBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsWUFBWSxDQUFDLENBQVc7UUFDdEIsT0FBTyxJQUFJLFNBQVMsQ0FDbEIsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUNSLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDMUIsSUFBSSxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUN2QixJQUFJLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRTtvQkFDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7aUJBQ3JEO2dCQUNELE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUM5QjtZQUNELE9BQU8sRUFBRSxDQUFDO1FBQ1osQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsT0FBTyxDQUFDLEtBQWE7UUFDbkIsSUFBSSxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssRUFBRTtZQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLGtDQUFrQyxDQUFDLENBQUM7U0FDckQ7UUFDRCxPQUFPO1lBQ0wsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLG1CQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM3RCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksbUJBQVEsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMvRCxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7T0FHRztJQUNILGdCQUFnQixDQUFDLEtBQWE7UUFDNUIsSUFBSSxLQUFLLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ3ZCLE9BQU8sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ3JEO1FBQ0QsSUFBSSxLQUFLLEtBQUssSUFBSSxDQUFDLEtBQUssRUFBRTtZQUN4QixPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNyRDtRQUNELE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsa0JBQWtCLENBQ2hCLE1BQWdCLEVBQ2hCLEVBQUUsS0FBSyxHQUFHLEtBQUssRUFBRSxTQUFTLEdBQUcsS0FBSyxFQUE0QztRQUU5RSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQztTQUNyQztRQUNELElBQUksS0FBSyxFQUFFO1lBQ1QsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDM0QsSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLFFBQVEsRUFBRTtnQkFDM0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxhQUFhLFFBQVEsOEJBQThCLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO2FBQ2xGO1lBQ0QsT0FBTyxJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztTQUNsRjtRQUNELE1BQU0sQ0FBQyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUM7UUFDNUIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0RSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDZixJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUU7Z0JBQ2QsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO2FBQ3RDO2lCQUFNO2dCQUNMLE9BQU8sQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsa0JBQWtCLENBQUMsSUFBSSxFQUFFLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQzthQUNqRTtTQUNGO2FBQU07WUFDTCxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ2Y7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFFBQVEsQ0FBQyxNQUFnQjtRQUN2QixPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsQ0FBZ0IsQ0FBQztJQUM1RixDQUFDO0NBQ0Y7QUExSUQsOEJBMElDIiwic291cmNlc0NvbnRlbnQiOlsiLypcblxuQ2xhc3NlcyB1c2VkIGZvciB0cmFja2luZyBzYXRzIGFjcm9zcyB0cmFuc2FjdGlvbnMuXG5cbmh0dHBzOi8vZ2l0aHViLmNvbS9jYXNleS9vcmQvYmxvYi9tYXN0ZXIvYmlwLm1lZGlhd2lraSNkZXNpZ25cblxuPiBUaGUgb3JkaW5hbCBudW1iZXJzIG9mIHNhdHMgaW4gdHJhbnNhY3Rpb24gaW5wdXRzIGFyZSB0cmFuc2ZlcnJlZCB0byBvdXRwdXQgc2F0cyBpblxuPiBmaXJzdC1pbi1maXJzdC1vdXQgb3JkZXIsIGFjY29yZGluZyB0byB0aGUgc2l6ZSBhbmQgb3JkZXIgb2YgdGhlIHRyYW5zYWN0aW9ucyBpbnB1dHMgYW5kIG91dHB1dHMuXG5cblxuU2FtcGxlIHNjZW5hcmlvOlxuICAgaW5wdXRzICAgICAgICAgaTAsIGkxLCBpMlxuICAgb3V0cHV0cyAgICAgICAgdTAsIHUxXG4gICBpbnNjcmlwdGlvbnMgICByMCwgcjEsIHIyLCByMywgcjRcblxuXG5jcmVhdGVPdXRwdXRzKFxuICBbaTAsIGkxXSxcbiAgW1xuICAgIFt1MCwgW3IwLCByMV1dLFxuICAgIFt1MSwgW3IyLCByM11dLFxuICBdXG4pO1xuXG4gIHI0IGlzIGRvbmF0ZWQgdG8gdGhlIG1pbmVyXG5cbiAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gIOKUgiBpMCAgICAg4pSCIHUwICAgICDilIJcbiAg4pSCICAgICAgICDilIIgICAgICAgIOKUglxuICDilIIgICAgIHIwIOKUvCAgICAgICAg4pSCXG4gIOKUgiAgICAgICAg4pSCICAgICAgICDilIJcbiAg4pSc4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkICAgICAgICDilIJcbiAg4pSCIGkxICAgICDilIIgICAgICAgIOKUglxuICDilIIgICAgIHIxIOKUvCAgICAgICAg4pSCXG4gIOKUgiAgICAgICAg4pSCICAgICAgICDilIJcbiAg4pSCICAgICAgICDilJzilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAg4pSCICAgICAgICDilIIgdTEgICAgIOKUglxuICDilIIgICAgIHIyIOKUvCAgICAgICAg4pSCXG4gIOKUgiAgICAgICAg4pSCICAgICAgICDilIJcbiAg4pSc4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkICAgICAgICDilIJcbiAg4pSCIGkyICAgICDilIIgICAgICAgIOKUglxuICDilIIgICAgIHIzIOKUvCAgICAgICAg4pSCXG4gIOKUgiAgICAgICAg4pSCICAgICAgICDilIJcbiAg4pSCICAgICAgICDilIIgICAgICAgIOKUglxuICDilIIgICAgICAgIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICDilIIgICAgICAgIOKUglxuICDilIIgICAgIHI0IOKUvFxuICDilIIgICAgICAgIOKUglxuICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilJhcblxuICovXG5cbmltcG9ydCB7IFNhdFJhbmdlIH0gZnJvbSAnLi9TYXRSYW5nZSc7XG5cbmV4cG9ydCBjbGFzcyBJbnZhbGlkT3JkT3V0cHV0IGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHB1YmxpYyB2YWx1ZTogYmlnaW50LCBwdWJsaWMgb3JkaW5hbHM6IFNhdFJhbmdlW10pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBvcmRpbmFsIG1ldGFkYXRhIGZvciBhbiBvdXRwdXRcbiAqL1xuZXhwb3J0IGNsYXNzIE9yZE91dHB1dCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgaW5wdXQgdmFsdWVcbiAgICogQHBhcmFtIG9yZGluYWxzIC0gVGhlIG9yZGluYWwgcmFuZ2VzIG9mIGFuIG91dHB1dCwgcmVsYXRpdmUgdG8gdGhlIGZpcnN0IHNhdG9zaGkuXG4gICAqICAgICAgICAgICAgICAgICAgIFJlcXVpcmVkIHRvIGJlIG9yZGVyZWQgYW5kIG5vbi1vdmVybGFwcGluZy5cbiAgICogICAgICAgICAgICAgICAgICAgTm90IHJlcXVpcmVkIHRvIGJlIGV4aGF1c3RpdmUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgdmFsdWU6IGJpZ2ludCwgcHVibGljIG9yZGluYWxzOiBTYXRSYW5nZVtdID0gW10pIHtcbiAgICBjb25zdCBtYXhSYW5nZSA9IHRoaXMuYXNTYXRSYW5nZSgpO1xuICAgIG9yZGluYWxzLmZvckVhY2goKHIsIGkpID0+IHtcbiAgICAgIGlmICghbWF4UmFuZ2UuaXNTdXBlcnNldE9mKHIpKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkT3JkT3V0cHV0KGByYW5nZSAke3J9IG91dHNpZGUgb3V0cHV0IG1heFJhbmdlICR7bWF4UmFuZ2V9YCwgdmFsdWUsIG9yZGluYWxzKTtcbiAgICAgIH1cbiAgICAgIGlmICgwIDwgaSkge1xuICAgICAgICBjb25zdCBwcmV2UmFuZ2UgPSBvcmRpbmFsc1tpIC0gMV07XG4gICAgICAgIGlmIChyLnN0YXJ0IDw9IHByZXZSYW5nZS5lbmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9yZE91dHB1dChgU2F0UmFuZ2UgIyR7aSAtIDF9ICR7cHJldlJhbmdlfSBvdmVybGFwcyBTYXRSYW5nZSAjJHtpfSAke3J9YCwgdmFsdWUsIG9yZGluYWxzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBvdGhlclxuICAgKiBAcmV0dXJuIE9yZE91dHB1dCBleHRlbmRlZCBieSBvdGhlci52YWx1ZSBhbmQgU2F0UmFuZ2VzIHNoaWZ0ZWQgYnkgdGhpcy52YWx1ZVxuICAgKi9cbiAgam9pbmVkV2l0aChvdGhlcjogT3JkT3V0cHV0KTogT3JkT3V0cHV0IHtcbiAgICByZXR1cm4gbmV3IE9yZE91dHB1dCh0aGlzLnZhbHVlICsgb3RoZXIudmFsdWUsIFtcbiAgICAgIC4uLnRoaXMub3JkaW5hbHMsXG4gICAgICAuLi5vdGhlci5vcmRpbmFscy5tYXAoKHIpID0+IHIuc2hpZnRlZEJ5KHRoaXMudmFsdWUpKSxcbiAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gb3Jkc1xuICAgKiBAcmV0dXJuIHNpbmdsZSBPcmRPdXRwdXQgY29udGFpbmluZyBhbGwgU2F0UmFuZ2VzLCBzaGlmdGVkIGJ5IHByZWNlZGluZyBvdXRwdXQgdmFsdWVzXG4gICAqL1xuICBzdGF0aWMgam9pbkFsbChvcmRzOiBPcmRPdXRwdXRbXSk6IE9yZE91dHB1dCB7XG4gICAgaWYgKG9yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBlbXB0eSBpbnB1dGApO1xuICAgIH1cbiAgICByZXR1cm4gb3Jkcy5yZWR1Y2UoKGEsIGIpID0+IGEuam9pbmVkV2l0aChiKSk7XG4gIH1cblxuICBhc1NhdFJhbmdlKCk6IFNhdFJhbmdlIHtcbiAgICByZXR1cm4gbmV3IFNhdFJhbmdlKEJpZ0ludCgwKSwgdGhpcy52YWx1ZSAtIEJpZ0ludCgxKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHJcbiAgICogQHJldHVybiBuZXcgT3JkT3V0cHV0IHdpdGggYWxsIHJhbmdlcyBmdWxseSBjb250YWluZWQgaW4gX3JfLiBTYXRSYW5nZXMgYXJlIGFsaWduZWQgdG8gbmV3IHN0YXJ0LlxuICAgKi9cbiAgZnJvbVNhdFJhbmdlKHI6IFNhdFJhbmdlKTogT3JkT3V0cHV0IHtcbiAgICByZXR1cm4gbmV3IE9yZE91dHB1dChcbiAgICAgIHIuc2l6ZSgpLFxuICAgICAgdGhpcy5vcmRpbmFscy5mbGF0TWFwKChzKSA9PiB7XG4gICAgICAgIGlmIChyLmludGVyc2VjdHNXaXRoKHMpKSB7XG4gICAgICAgICAgaWYgKCFyLmlzU3VwZXJzZXRPZihzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJ0aWFsIG92ZXJsYXAgaW4gJHtyfSBhbmQgJHtzfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcy5zaGlmdGVkQnkoLXIuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHJldHVybiBmaXJzdCBPcmRPdXRwdXQgd2l0aCB2YWx1ZSBgdmFsdWVgLCBzZWNvbmQgT3JkT3V0cHV0IHdpdGggcmVtYWluaW5nIHZhbHVlLlxuICAgKiAgICAgICAgIFdpdGggcmVzcGVjdGl2ZSBTYXRSYW5nZXNcbiAgICovXG4gIHNwbGl0QXQodmFsdWU6IGJpZ2ludCk6IFtPcmRPdXRwdXQsIE9yZE91dHB1dF0ge1xuICAgIGlmICh0aGlzLnZhbHVlIDwgdmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbXVzdCBzcGxpdCBhdCB2YWx1ZSBpbnNpZGUgcmFuZ2VgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMuZnJvbVNhdFJhbmdlKG5ldyBTYXRSYW5nZShCaWdJbnQoMCksIHZhbHVlIC0gQmlnSW50KDEpKSksXG4gICAgICB0aGlzLmZyb21TYXRSYW5nZShuZXcgU2F0UmFuZ2UodmFsdWUsIHRoaXMudmFsdWUgLSBCaWdJbnQoMSkpKSxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIExpa2Ugc3BsaXRBdCBidXQgcmV0dXJucyBfbnVsbF8gd2hlcmUgYSB6ZXJvLXNpemVkIE9yZE91dHB1dCB3b3VsZCBiZVxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIHNwbGl0QXRBbGxvd1plcm8odmFsdWU6IGJpZ2ludCk6IFtPcmRPdXRwdXQgfCBudWxsLCBPcmRPdXRwdXQgfCBudWxsXSB7XG4gICAgaWYgKHZhbHVlID09PSBCaWdJbnQoMCkpIHtcbiAgICAgIHJldHVybiBbbnVsbCwgdGhpcy5mcm9tU2F0UmFuZ2UodGhpcy5hc1NhdFJhbmdlKCkpXTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB0aGlzLnZhbHVlKSB7XG4gICAgICByZXR1cm4gW3RoaXMuZnJvbVNhdFJhbmdlKHRoaXMuYXNTYXRSYW5nZSgpKSwgbnVsbF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwbGl0QXQodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IG91dHB1dCBzdWNjZXNzaXZlbHkgYXQgdmFsdWVzLlxuICAgKiBAcGFyYW0gdmFsdWVzXG4gICAqIEBwYXJhbSBleGFjdCAtIHdoZW4gc2V0LCBlbnN1cmUgdGhhdCB2YWx1ZSBzdW0gbWF0Y2hlcyBfdGhpcy52YWx1ZV9cbiAgICogQHBhcmFtIGFsbG93WmVybyAtIHdoZW4gc2V0LCByZXR1cm4gX251bGxfIGZvciB6ZXJvLXNpemVkIHZhbHVlc1xuICAgKiBAcmV0dXJuIChPcmRPdXRwdXQgfCBudWxsKVtdLiBaZXJvLXNpemVkIG91dHB1dHMgYXJlIHN1YnN0aXR1dGVkIHdpdGggX251bGxfLlxuICAgKi9cbiAgc3BsaXRBbGxXaXRoUGFyYW1zKFxuICAgIHZhbHVlczogYmlnaW50W10sXG4gICAgeyBleGFjdCA9IGZhbHNlLCBhbGxvd1plcm8gPSBmYWxzZSB9OiB7IGFsbG93WmVybz86IGJvb2xlYW47IGV4YWN0PzogYm9vbGVhbiB9XG4gICk6IChPcmRPdXRwdXQgfCBudWxsKVtdIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFyZ3VtZW50YCk7XG4gICAgfVxuICAgIGlmIChleGFjdCkge1xuICAgICAgY29uc3QgdmFsdWVTdW0gPSB2YWx1ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgQmlnSW50KDApKTtcbiAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB2YWx1ZVN1bSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbHVlIHN1bSAke3ZhbHVlU3VtfSBkb2VzIG5vdCBtYXRjaCB0aGlzLnZhbHVlICR7dGhpcy52YWx1ZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNwbGl0QWxsV2l0aFBhcmFtcyh2YWx1ZXMuc2xpY2UoMCwgLTEpLCB7IGFsbG93WmVybywgZXhhY3Q6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBjb25zdCBbdiwgLi4ucmVzdF0gPSB2YWx1ZXM7XG4gICAgY29uc3QgW2EsIGJdID0gYWxsb3daZXJvID8gdGhpcy5zcGxpdEF0QWxsb3daZXJvKHYpIDogdGhpcy5zcGxpdEF0KHYpO1xuICAgIGlmIChyZXN0Lmxlbmd0aCkge1xuICAgICAgaWYgKGIgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHJlbWFpbmRlcmApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFthLCAuLi5iLnNwbGl0QWxsV2l0aFBhcmFtcyhyZXN0LCB7IGV4YWN0LCBhbGxvd1plcm8gfSldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW2EsIGJdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCBvdXRwdXQgc3VjY2Vzc2l2ZWx5IGF0IHZhbHVlcy5cbiAgICogQHBhcmFtIHZhbHVlc1xuICAgKiBAcmV0dXJuIE9yZE91dHB1dFtdIHdpdGggbGVuZ3RoIF92YWx1ZXMubGVuZ3RoICsgMV9cbiAgICovXG4gIHNwbGl0QWxsKHZhbHVlczogYmlnaW50W10pOiBPcmRPdXRwdXRbXSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaXRBbGxXaXRoUGFyYW1zKHZhbHVlcywgeyBleGFjdDogZmFsc2UsIGFsbG93WmVybzogZmFsc2UgfSkgYXMgT3JkT3V0cHV0W107XG4gIH1cbn1cbiJdfQ==