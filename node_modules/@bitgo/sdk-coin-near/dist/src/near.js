"use strict";
/**
 * @prettier
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Near = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const _ = __importStar(require("lodash"));
const base58 = __importStar(require("bs58"));
const statics_1 = require("@bitgo/statics");
const sdk_core_1 = require("@bitgo/sdk-core");
const nearAPI = __importStar(require("near-api-js"));
const request = __importStar(require("superagent"));
const lib_1 = require("./lib");
const utils_1 = __importDefault(require("./lib/utils"));
class Near extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        this.network = this.bitgo.getEnv() === 'prod' ? 'main' : 'test';
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new Near(bitgo, staticsCoin);
    }
    allowsAccountConsolidations() {
        return true;
    }
    /**
     * Flag indicating if this coin supports TSS wallets.
     * @returns {boolean} True if TSS Wallets can be created for this coin
     */
    supportsTss() {
        return true;
    }
    getMPCAlgorithm() {
        return 'eddsa';
    }
    getChain() {
        return this._staticsCoin.name;
    }
    getBaseChain() {
        return this.getChain();
    }
    getFamily() {
        return this._staticsCoin.family;
    }
    getFullName() {
        return this._staticsCoin.fullName;
    }
    getBaseFactor() {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return false;
    }
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    generateKeyPair(seed) {
        const keyPair = seed ? new lib_1.KeyPair({ seed }) : new lib_1.KeyPair();
        const keys = keyPair.getKeys();
        if (!keys.prv) {
            throw new Error('Missing prv in key generation.');
        }
        return {
            pub: keys.pub,
            prv: keys.prv,
        };
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub) {
        return utils_1.default.isValidPublicKey(pub);
    }
    /**
     * Return boolean indicating whether the supplied private key is a valid near private key
     *
     * @param {String} prv the prv to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPrv(prv) {
        return utils_1.default.isValidPrivateKey(prv);
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {String} address the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidAddress(address) {
        return utils_1.default.isValidAddress(address);
    }
    /** @inheritDoc */
    async signMessage(key, message) {
        const nearKeypair = new lib_1.KeyPair({ prv: key.prv });
        if (Buffer.isBuffer(message)) {
            message = base58.encode(message);
        }
        return Buffer.from(nearKeypair.signMessage(message));
    }
    /**
     * Explain/parse transaction
     * @param params
     */
    async explainTransaction(params) {
        const factory = this.getBuilder();
        let rebuiltTransaction;
        const txRaw = params.txPrebuild.txHex;
        try {
            const transactionBuilder = factory.from(txRaw);
            rebuiltTransaction = await transactionBuilder.build();
        }
        catch {
            throw new Error('Invalid transaction');
        }
        return rebuiltTransaction.explainTransaction();
    }
    verifySignTransactionParams(params) {
        const prv = params.prv;
        const txHex = params.txPrebuild.txHex;
        if (_.isUndefined(txHex)) {
            throw new Error('missing txPrebuild parameter');
        }
        if (!_.isString(txHex)) {
            throw new Error(`txPrebuild must be an object, got type ${typeof txHex}`);
        }
        if (_.isUndefined(prv)) {
            throw new Error('missing prv parameter to sign transaction');
        }
        if (!_.isString(prv)) {
            throw new Error(`prv must be a string, got type ${typeof prv}`);
        }
        if (!_.has(params.txPrebuild, 'key')) {
            throw new Error('missing public key parameter to sign transaction');
        }
        // if we are receiving addresses do not try to convert them
        const signer = !utils_1.default.isValidAddress(params.txPrebuild.key)
            ? new lib_1.KeyPair({ pub: params.txPrebuild.key }).getAddress()
            : params.txPrebuild.key;
        return { txHex, prv, signer };
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {TransactionPrebuild} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param callback
     * @returns {Bluebird<SignedTransaction>}
     */
    async signTransaction(params) {
        const factory = this.getBuilder();
        const txBuilder = factory.from(params.txPrebuild.txHex);
        txBuilder.sign({ key: params.prv });
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new Error('Invalid transaction');
        }
        const serializedTx = transaction.toBroadcastFormat();
        return {
            txHex: serializedTx,
        };
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     */
    async recover(params) {
        if (!params.bitgoKey) {
            throw new Error('missing bitgoKey');
        }
        if (!params.recoveryDestination || !this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination');
        }
        let startIdx = params.startingScanIndex;
        if (startIdx === undefined) {
            startIdx = 0;
        }
        else if (!Number.isInteger(startIdx) || startIdx < 0) {
            throw new Error('Invalid starting index to scan for addresses');
        }
        let numIteration = params.scan;
        if (numIteration === undefined) {
            numIteration = 20;
        }
        else if (!Number.isInteger(numIteration) || numIteration <= 0) {
            throw new Error('Invalid scanning factor');
        }
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        const isUnsignedSweep = !params.userKey && !params.backupKey && !params.walletPassphrase;
        const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
        const { storageAmountPerByte, transferCost, receiptConfig } = await this.getProtocolConfig();
        for (let i = startIdx; i < numIteration + startIdx; i++) {
            const currPath = `m/${i}`;
            const accountId = MPC.deriveUnhardened(bitgoKey, currPath).slice(0, 64);
            let availableBalance = new bignumber_js_1.default(0);
            try {
                availableBalance = new bignumber_js_1.default(await this.getAccountBalance(accountId, storageAmountPerByte));
            }
            catch (e) {
                // UNKNOWN_ACCOUNT error indicates that the address has not partake in any transaction so far, so we will
                // treat it as a zero balance address
                if (e.message !== 'UNKNOWN_ACCOUNT') {
                    throw e;
                }
            }
            if (availableBalance.toNumber() <= 0) {
                continue;
            }
            // first build the unsigned txn
            const bs58EncodedPublicKey = nearAPI.utils.serialize.base_encode(new Uint8Array(Buffer.from(accountId, 'hex')));
            const { nonce, blockHash } = await this.getAccessKey({ accountId, bs58EncodedPublicKey });
            const gasPrice = await this.getGasPrice(blockHash);
            const gasPriceFirstBlock = new bignumber_js_1.default(gasPrice);
            const gasPriceSecondBlock = gasPriceFirstBlock.multipliedBy(1.05);
            const totalGasRequired = new bignumber_js_1.default(transferCost.sendSir)
                .plus(receiptConfig.sendSir)
                .multipliedBy(gasPriceFirstBlock)
                .plus(new bignumber_js_1.default(transferCost.execution).plus(receiptConfig.execution).multipliedBy(gasPriceSecondBlock));
            // adding some padding to make sure the gas doesn't go below required gas by network
            const totalGasWithPadding = totalGasRequired.multipliedBy(1.5);
            const feeReserve = (0, bignumber_js_1.default)(statics_1.Networks[this.network].near.feeReserve);
            const storageReserve = (0, bignumber_js_1.default)(statics_1.Networks[this.network].near.storageReserve);
            const netAmount = availableBalance.minus(totalGasWithPadding).minus(feeReserve).minus(storageReserve);
            if (netAmount.toNumber() <= 0) {
                throw new Error(`Found address ${i} with non-zero fund but fund is insufficient to support a recover ` +
                    `transaction. Please start the next scan at address index ${i + 1}.`);
            }
            const factory = new lib_1.TransactionBuilderFactory(statics_1.coins.get(this.getChain()));
            const txBuilder = factory
                .getTransferBuilder()
                .sender(accountId, accountId)
                .nonce(nonce)
                .receiverId(params.recoveryDestination)
                .recentBlockHash(blockHash)
                .amount(netAmount.toFixed());
            if (!isUnsignedSweep) {
                const unsignedTransaction = (await txBuilder.build());
                // Sign the txn
                /* ***************** START **************************************/
                // TODO(BG-51092): This looks like a common part which can be extracted out too
                if (!params.userKey) {
                    throw new Error('missing userKey');
                }
                if (!params.backupKey) {
                    throw new Error('missing backupKey');
                }
                if (!params.walletPassphrase) {
                    throw new Error('missing wallet passphrase');
                }
                // Clean up whitespace from entered values
                const userKey = params.userKey.replace(/\s/g, '');
                const backupKey = params.backupKey.replace(/\s/g, '');
                // Decrypt private keys from KeyCard values
                let userPrv;
                try {
                    userPrv = this.bitgo.decrypt({
                        input: userKey,
                        password: params.walletPassphrase,
                    });
                }
                catch (e) {
                    throw new Error(`Error decrypting user keychain: ${e.message}`);
                }
                /** TODO BG-52419 Implement Codec for parsing */
                const userSigningMaterial = JSON.parse(userPrv);
                let backupPrv;
                try {
                    backupPrv = this.bitgo.decrypt({
                        input: backupKey,
                        password: params.walletPassphrase,
                    });
                }
                catch (e) {
                    throw new Error(`Error decrypting backup keychain: ${e.message}`);
                }
                const backupSigningMaterial = JSON.parse(backupPrv);
                /* ********************** END ***********************************/
                // add signature
                const signatureHex = await sdk_core_1.EDDSAMethods.getTSSSignature(userSigningMaterial, backupSigningMaterial, currPath, unsignedTransaction);
                const publicKeyObj = { pub: accountId };
                txBuilder.addSignature(publicKeyObj, signatureHex);
            }
            const completedTransaction = await txBuilder.build();
            const serializedTx = completedTransaction.toBroadcastFormat();
            return { serializedTx: serializedTx, scanIndex: i };
        }
        throw new Error('Did not find an address with funds to recover');
    }
    /**
     * Make a request to one of the public EOS nodes available
     * @param params.payload
     */
    async getDataFromNode(params) {
        const nodeUrls = this.getPublicNodeUrls();
        for (const nodeUrl of nodeUrls) {
            try {
                return await request.post(nodeUrl).send(params.payload);
            }
            catch (e) {
                console.debug(e);
            }
        }
        throw new Error(`Unable to call endpoint: '/' from nodes: ${_.join(nodeUrls, ', ')}`);
    }
    async getAccessKey({ accountId, bs58EncodedPublicKey, }) {
        const response = await this.getDataFromNode({
            payload: {
                jsonrpc: '2.0',
                id: 'dontcare',
                method: 'query',
                params: {
                    request_type: 'view_access_key',
                    finality: 'final',
                    account_id: accountId,
                    public_key: bs58EncodedPublicKey,
                },
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        const accessKey = response.body.result;
        return { nonce: accessKey.nonce + 1, blockHash: accessKey.block_hash };
    }
    async getAccountBalance(accountId, storageAmountPerByte) {
        var _a;
        const response = await this.getDataFromNode({
            payload: {
                jsonrpc: '2.0',
                id: 'dontcare',
                method: 'query',
                params: {
                    request_type: 'view_account',
                    finality: 'final',
                    account_id: accountId,
                },
            },
        });
        if (response.status !== 200) {
            throw new Error('Failed to query account information');
        }
        const errorCause = (_a = response.body.error) === null || _a === void 0 ? void 0 : _a.cause.name;
        if (errorCause !== undefined) {
            throw new Error(errorCause);
        }
        const account = response.body.result;
        const costPerByte = new bignumber_js_1.default(storageAmountPerByte);
        const stateStaked = new bignumber_js_1.default(account.storage_usage).multipliedBy(costPerByte);
        const staked = new bignumber_js_1.default(account.locked);
        const totalBalance = new bignumber_js_1.default(account.amount).plus(staked);
        const availableBalance = totalBalance.minus(bignumber_js_1.default.max(staked, stateStaked));
        return availableBalance.toString();
    }
    async getProtocolConfig() {
        const response = await this.getDataFromNode({
            payload: {
                jsonrpc: '2.0',
                id: 'dontcare',
                method: 'EXPERIMENTAL_protocol_config',
                params: {
                    finality: 'final',
                },
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        const config = response.body.result;
        const storageAmountPerByte = config.runtime_config.storage_amount_per_byte;
        const transferCostFromNetwork = config.runtime_config.transaction_costs.action_creation_config.transfer_cost;
        const transferCost = {
            sendSir: transferCostFromNetwork.send_sir,
            sendNotSir: transferCostFromNetwork.send_not_sir,
            execution: transferCostFromNetwork.execution,
        };
        const receiptConfigFromNetwork = config.runtime_config.transaction_costs.action_receipt_creation_config;
        const receiptConfig = {
            sendSir: receiptConfigFromNetwork.send_sir,
            sendNotSir: receiptConfigFromNetwork.send_not_sir,
            execution: receiptConfigFromNetwork.execution,
        };
        return { storageAmountPerByte, transferCost, receiptConfig };
    }
    async getGasPrice(blockHash) {
        const response = await this.getDataFromNode({
            payload: {
                jsonrpc: '2.0',
                id: 'dontcare',
                method: 'gas_price',
                params: [blockHash],
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return response.body.result.gas_price;
    }
    getPublicNodeUrls() {
        return sdk_core_1.Environments[this.bitgo.getEnv()].nearNodeUrls;
    }
    async parseTransaction(params) {
        const transactionExplanation = await this.explainTransaction({
            txPrebuild: params.txPrebuild,
            publicKey: params.publicKey,
            feeInfo: params.feeInfo,
        });
        if (!transactionExplanation) {
            throw new Error('Invalid transaction');
        }
        const nearTransaction = transactionExplanation;
        if (nearTransaction.outputs.length <= 0) {
            return {
                inputs: [],
                outputs: [],
            };
        }
        const senderAddress = nearTransaction.outputs[0].address;
        const feeAmount = new bignumber_js_1.default(nearTransaction.fee.fee === '' ? '0' : nearTransaction.fee.fee);
        // assume 1 sender, who is also the fee payer
        const inputs = [
            {
                address: senderAddress,
                amount: new bignumber_js_1.default(nearTransaction.outputAmount).plus(feeAmount).toFixed(),
            },
        ];
        const outputs = nearTransaction.outputs.map((output) => {
            return {
                address: output.address,
                amount: new bignumber_js_1.default(output.amount).toFixed(),
            };
        });
        return {
            inputs,
            outputs,
        };
    }
    async isWalletAddress(params) {
        throw new sdk_core_1.MethodNotImplementedError();
    }
    async verifyTransaction(params) {
        var _a;
        let totalAmount = new bignumber_js_1.default(0);
        const coinConfig = statics_1.coins.get(this.getChain());
        const { txPrebuild: txPrebuild, txParams: txParams } = params;
        const transaction = new lib_1.Transaction(coinConfig);
        const rawTx = txPrebuild.txHex;
        if (!rawTx) {
            throw new Error('missing required tx prebuild property txHex');
        }
        transaction.fromRawTransaction(rawTx);
        const explainedTx = transaction.explainTransaction();
        // users do not input recipients for consolidation requests as they are generated by the server
        if (txParams.recipients !== undefined) {
            const filteredRecipients = (_a = txParams.recipients) === null || _a === void 0 ? void 0 : _a.map((recipient) => _.pick(recipient, ['address', 'amount']));
            const filteredOutputs = explainedTx.outputs.map((output) => _.pick(output, ['address', 'amount']));
            if (!_.isEqual(filteredOutputs, filteredRecipients)) {
                throw new Error('Tx outputs does not match with expected txParams recipients');
            }
            for (const recipients of txParams.recipients) {
                totalAmount = totalAmount.plus(recipients.amount);
            }
            if (!totalAmount.isEqualTo(explainedTx.outputAmount)) {
                throw new Error('Tx total amount does not match with expected total amount field');
            }
        }
        return true;
    }
    getBuilder() {
        return new lib_1.TransactionBuilderFactory(statics_1.coins.get(this.getBaseChain()));
    }
}
exports.Near = Near;
Near.initialized = false;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmVhci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9uZWFyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7R0FFRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFSCxnRUFBcUM7QUFDckMsMENBQTRCO0FBQzVCLDZDQUErQjtBQUMvQiw0Q0FBMEY7QUFFMUYsOENBbUJ5QjtBQUN6QixxREFBdUM7QUFDdkMsb0RBQXNDO0FBRXRDLCtCQUF1RjtBQUN2Rix3REFBb0M7QUFzRnBDLE1BQWEsSUFBSyxTQUFRLG1CQUFRO0lBR2hDLFlBQVksS0FBZ0IsRUFBRSxXQUF1QztRQUNuRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFVTCxZQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO1FBVG5FLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvREFBb0QsQ0FBQyxDQUFDO1NBQ3ZFO1FBRUQsSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7SUFDbEMsQ0FBQztJQU1ELE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBZ0IsRUFBRSxXQUF1QztRQUM3RSxPQUFPLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQsMkJBQTJCO1FBQ3pCLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7T0FHRztJQUNILFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxlQUFlO1FBQ2IsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQUVELFFBQVE7UUFDTixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDO0lBQ2hDLENBQUM7SUFFRCxZQUFZO1FBQ1YsT0FBTyxJQUFJLENBQUMsUUFB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eUIsQ0FBQyxlQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdkUsQ0FBQzs7QUE3aEJILG9CQThoQkM7QUFsaEJrQixnQkFBVyxHQUFHLEtBQUssQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cblxuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgYmFzZTU4IGZyb20gJ2JzNTgnO1xuaW1wb3J0IHsgTmV0d29ya3MsIEJhc2VDb2luIGFzIFN0YXRpY3NCYXNlQ29pbiwgQ29pbkZhbWlseSwgY29pbnMgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5cbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBCaXRHb0Jhc2UsXG4gIEJhc2VUcmFuc2FjdGlvbixcbiAgS2V5UGFpcixcbiAgTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvcixcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgU2lnbmVkVHJhbnNhY3Rpb24sXG4gIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgYXMgQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24sXG4gIFZlcmlmeUFkZHJlc3NPcHRpb25zLFxuICBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIEVkZHNhLFxuICBQdWJsaWNLZXksXG4gIEVudmlyb25tZW50cyxcbiAgTVBDQWxnb3JpdGhtLFxuICBFRERTQU1ldGhvZHMsXG4gIEVERFNBTWV0aG9kVHlwZXMsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgKiBhcyBuZWFyQVBJIGZyb20gJ25lYXItYXBpLWpzJztcbmltcG9ydCAqIGFzIHJlcXVlc3QgZnJvbSAnc3VwZXJhZ2VudCc7XG5cbmltcG9ydCB7IEtleVBhaXIgYXMgTmVhcktleVBhaXIsIFRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5IH0gZnJvbSAnLi9saWInO1xuaW1wb3J0IG5lYXJVdGlscyBmcm9tICcuL2xpYi91dGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcHJ2OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHR4SGV4OiBzdHJpbmc7XG4gIGtleTogc3RyaW5nO1xuICBibG9ja0hhc2g6IHN0cmluZztcbiAgbm9uY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcHVibGljS2V5OiBzdHJpbmc7XG4gIGZlZUluZm86IHtcbiAgICBmZWU6IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZmllZFRyYW5zYWN0aW9uUGFyYW1ldGVycyB7XG4gIHR4SGV4OiBzdHJpbmc7XG4gIHBydjogc3RyaW5nO1xuICBzaWduZXI6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOZWFyUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBCYXNlUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwdWJsaWNLZXk6IHN0cmluZztcbiAgZmVlSW5mbzoge1xuICAgIGZlZTogc3RyaW5nO1xuICB9O1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25PdXRwdXQge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGFtb3VudDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUmVjb3ZlcnlPcHRpb25zIHtcbiAgdXNlcktleTogc3RyaW5nOyAvLyBCb3ggQVxuICBiYWNrdXBLZXk6IHN0cmluZzsgLy8gQm94IEJcbiAgYml0Z29LZXk6IHN0cmluZzsgLy8gQm94IENcbiAgcmVjb3ZlcnlEZXN0aW5hdGlvbjogc3RyaW5nO1xuICBrcnNQcm92aWRlcj86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZTogc3RyaW5nO1xuICBzdGFydGluZ1NjYW5JbmRleD86IG51bWJlcjtcbiAgc2Nhbj86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIE5lYXJUeCB7XG4gIHNlcmlhbGl6ZWRUeDogc3RyaW5nO1xuICBzY2FuSW5kZXg6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIE5lYXJUeEJ1aWxkZXJQYXJhbXNGcm9tTm9kZSB7XG4gIG5vbmNlOiBudW1iZXI7XG4gIGJsb2NrSGFzaDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgTmVhckZlZUNvbmZpZyB7XG4gIHNlbmRTaXI6IG51bWJlcjtcbiAgc2VuZE5vdFNpcjogbnVtYmVyO1xuICBleGVjdXRpb246IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFByb3RvY29sQ29uZmlnT3V0cHV0IHtcbiAgc3RvcmFnZUFtb3VudFBlckJ5dGU6IG51bWJlcjtcbiAgdHJhbnNmZXJDb3N0OiBOZWFyRmVlQ29uZmlnO1xuICByZWNlaXB0Q29uZmlnOiBOZWFyRmVlQ29uZmlnO1xufVxuXG50eXBlIFRyYW5zYWN0aW9uSW5wdXQgPSBUcmFuc2FjdGlvbk91dHB1dDtcblxuZXhwb3J0IGludGVyZmFjZSBOZWFyUGFyc2VkVHJhbnNhY3Rpb24gZXh0ZW5kcyBQYXJzZWRUcmFuc2FjdGlvbiB7XG4gIC8vIHRvdGFsIGFzc2V0cyBiZWluZyBtb3ZlZCwgaW5jbHVkaW5nIGZlZXNcbiAgaW5wdXRzOiBUcmFuc2FjdGlvbklucHV0W107XG5cbiAgLy8gd2hlcmUgYXNzZXRzIGFyZSBtb3ZlZCB0b1xuICBvdXRwdXRzOiBUcmFuc2FjdGlvbk91dHB1dFtdO1xufVxuXG5leHBvcnQgdHlwZSBOZWFyVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiA9IFRyYW5zYWN0aW9uRXhwbGFuYXRpb247XG5cbmV4cG9ydCBjbGFzcyBOZWFyIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3N0YXRpY3NDb2luOiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+O1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHb0Jhc2UsIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPikge1xuICAgIHN1cGVyKGJpdGdvKTtcbiAgICBpZiAoIXN0YXRpY3NDb2luKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgY29uc3RydWN0b3IgcGFyYW1ldGVyIHN0YXRpY3NDb2luJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGljc0NvaW4gPSBzdGF0aWNzQ29pbjtcbiAgfVxuXG4gIHByb3RlY3RlZCBzdGF0aWMgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgcHJvdGVjdGVkIHN0YXRpYyBNUEM6IEVkZHNhO1xuICBwcm90ZWN0ZWQgbmV0d29yayA9IHRoaXMuYml0Z28uZ2V0RW52KCkgPT09ICdwcm9kJyA/ICdtYWluJyA6ICd0ZXN0JztcblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvQmFzZSwgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgTmVhcihiaXRnbywgc3RhdGljc0NvaW4pO1xuICB9XG5cbiAgYWxsb3dzQWNjb3VudENvbnNvbGlkYXRpb25zKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIGNvaW4gc3VwcG9ydHMgVFNTIHdhbGxldHMuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFRTUyBXYWxsZXRzIGNhbiBiZSBjcmVhdGVkIGZvciB0aGlzIGNvaW5cbiAgICovXG4gIHN1cHBvcnRzVHNzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZ2V0TVBDQWxnb3JpdGhtKCk6IE1QQ0FsZ29yaXRobSB7XG4gICAgcmV0dXJuICdlZGRzYSc7XG4gIH1cblxuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5uYW1lO1xuICB9XG5cbiAgZ2V0QmFzZUNoYWluKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hhaW4oKTtcbiAgfVxuXG4gIGdldEZhbWlseSgpOiBDb2luRmFtaWx5IHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZmFtaWx5O1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZnVsbE5hbWU7XG4gIH1cblxuICBnZXRCYXNlRmFjdG9yKCk6IGFueSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGF0aWNzQ29pbi5kZWNpbWFsUGxhY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBzZW5kaW5nIHZhbHVlIG9mIDBcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIDAgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBlZDI1NTE5IGtleSBwYWlyXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGdlbmVyYXRlZCBwdWIsIHBydlxuICAgKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBjb25zdCBrZXlQYWlyID0gc2VlZCA/IG5ldyBOZWFyS2V5UGFpcih7IHNlZWQgfSkgOiBuZXcgTmVhcktleVBhaXIoKTtcbiAgICBjb25zdCBrZXlzID0ga2V5UGFpci5nZXRLZXlzKCk7XG4gICAgaWYgKCFrZXlzLnBydikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHBydiBpbiBrZXkgZ2VuZXJhdGlvbi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1Yjoga2V5cy5wdWIsXG4gICAgICBwcnY6IGtleXMucHJ2LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHViIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG5lYXJVdGlscy5pc1ZhbGlkUHVibGljS2V5KHB1Yik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzdXBwbGllZCBwcml2YXRlIGtleSBpcyBhIHZhbGlkIG5lYXIgcHJpdmF0ZSBrZXlcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBydiB0aGUgcHJ2IHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBuZWFyVXRpbHMuaXNWYWxpZFByaXZhdGVLZXkocHJ2KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBuZWFyVXRpbHMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcyk7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgYXN5bmMgc2lnbk1lc3NhZ2Uoa2V5OiBLZXlQYWlyLCBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGNvbnN0IG5lYXJLZXlwYWlyID0gbmV3IE5lYXJLZXlQYWlyKHsgcHJ2OiBrZXkucHJ2IH0pO1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkpIHtcbiAgICAgIG1lc3NhZ2UgPSBiYXNlNTguZW5jb2RlKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBCdWZmZXIuZnJvbShuZWFyS2V5cGFpci5zaWduTWVzc2FnZShtZXNzYWdlKSk7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGFpbi9wYXJzZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBleHBsYWluVHJhbnNhY3Rpb24ocGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxOZWFyVHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmdldEJ1aWxkZXIoKTtcbiAgICBsZXQgcmVidWlsdFRyYW5zYWN0aW9uOiBCYXNlVHJhbnNhY3Rpb247XG4gICAgY29uc3QgdHhSYXcgPSBwYXJhbXMudHhQcmVidWlsZC50eEhleDtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkJ1aWxkZXIgPSBmYWN0b3J5LmZyb20odHhSYXcpO1xuICAgICAgcmVidWlsdFRyYW5zYWN0aW9uID0gYXdhaXQgdHJhbnNhY3Rpb25CdWlsZGVyLmJ1aWxkKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVidWlsdFRyYW5zYWN0aW9uLmV4cGxhaW5UcmFuc2FjdGlvbigpO1xuICB9XG5cbiAgdmVyaWZ5U2lnblRyYW5zYWN0aW9uUGFyYW1zKHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFZlcmlmaWVkVHJhbnNhY3Rpb25QYXJhbWV0ZXJzIHtcbiAgICBjb25zdCBwcnYgPSBwYXJhbXMucHJ2O1xuXG4gICAgY29uc3QgdHhIZXggPSBwYXJhbXMudHhQcmVidWlsZC50eEhleDtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHR4SGV4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHR4UHJlYnVpbGQgcGFyYW1ldGVyJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHR4SGV4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eFByZWJ1aWxkIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgdHlwZSAke3R5cGVvZiB0eEhleH1gKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHJ2IHBhcmFtZXRlciB0byBzaWduIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBydikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcHJ2IG11c3QgYmUgYSBzdHJpbmcsIGdvdCB0eXBlICR7dHlwZW9mIHBydn1gKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaGFzKHBhcmFtcy50eFByZWJ1aWxkLCAna2V5JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwdWJsaWMga2V5IHBhcmFtZXRlciB0byBzaWduIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgYXJlIHJlY2VpdmluZyBhZGRyZXNzZXMgZG8gbm90IHRyeSB0byBjb252ZXJ0IHRoZW1cbiAgICBjb25zdCBzaWduZXIgPSAhbmVhclV0aWxzLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy50eFByZWJ1aWxkLmtleSlcbiAgICAgID8gbmV3IE5lYXJLZXlQYWlyKHsgcHViOiBwYXJhbXMudHhQcmVidWlsZC5rZXkgfSkuZ2V0QWRkcmVzcygpXG4gICAgICA6IHBhcmFtcy50eFByZWJ1aWxkLmtleTtcbiAgICByZXR1cm4geyB0eEhleCwgcHJ2LCBzaWduZXIgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50eFByZWJ1aWxkIHtUcmFuc2FjdGlvblByZWJ1aWxkfSBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgcGxhdGZvcm1cbiAgICogQHBhcmFtIHBhcmFtcy5wcnYge1N0cmluZ30gdXNlciBwcnZcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj59XG4gICAqL1xuICBhc3luYyBzaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmdldEJ1aWxkZXIoKTtcbiAgICBjb25zdCB0eEJ1aWxkZXIgPSBmYWN0b3J5LmZyb20ocGFyYW1zLnR4UHJlYnVpbGQudHhIZXgpO1xuICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiBwYXJhbXMucHJ2IH0pO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uOiBCYXNlVHJhbnNhY3Rpb24gPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcblxuICAgIGlmICghdHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcmlhbGl6ZWRUeCA9ICh0cmFuc2FjdGlvbiBhcyBCYXNlVHJhbnNhY3Rpb24pLnRvQnJvYWRjYXN0Rm9ybWF0KCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHhIZXg6IHNlcmlhbGl6ZWRUeCxcbiAgICB9IGFzIGFueTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBmdW5kcyByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRob3V0IEJpdEdvXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIHJlY292ZXIocGFyYW1zOiBSZWNvdmVyeU9wdGlvbnMpOiBQcm9taXNlPE5lYXJUeD4ge1xuICAgIGlmICghcGFyYW1zLmJpdGdvS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYml0Z29LZXknKTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbiB8fCAhdGhpcy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZWNvdmVyeURlc3RpbmF0aW9uJyk7XG4gICAgfVxuICAgIGxldCBzdGFydElkeCA9IHBhcmFtcy5zdGFydGluZ1NjYW5JbmRleDtcbiAgICBpZiAoc3RhcnRJZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhcnRJZHggPSAwO1xuICAgIH0gZWxzZSBpZiAoIU51bWJlci5pc0ludGVnZXIoc3RhcnRJZHgpIHx8IHN0YXJ0SWR4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXJ0aW5nIGluZGV4IHRvIHNjYW4gZm9yIGFkZHJlc3NlcycpO1xuICAgIH1cbiAgICBsZXQgbnVtSXRlcmF0aW9uID0gcGFyYW1zLnNjYW47XG4gICAgaWYgKG51bUl0ZXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBudW1JdGVyYXRpb24gPSAyMDtcbiAgICB9IGVsc2UgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bUl0ZXJhdGlvbikgfHwgbnVtSXRlcmF0aW9uIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzY2FubmluZyBmYWN0b3InKTtcbiAgICB9XG4gICAgY29uc3QgYml0Z29LZXkgPSBwYXJhbXMuYml0Z29LZXkucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSAhcGFyYW1zLnVzZXJLZXkgJiYgIXBhcmFtcy5iYWNrdXBLZXkgJiYgIXBhcmFtcy53YWxsZXRQYXNzcGhyYXNlO1xuICAgIGNvbnN0IE1QQyA9IGF3YWl0IEVERFNBTWV0aG9kcy5nZXRJbml0aWFsaXplZE1wY0luc3RhbmNlKCk7XG4gICAgY29uc3QgeyBzdG9yYWdlQW1vdW50UGVyQnl0ZSwgdHJhbnNmZXJDb3N0LCByZWNlaXB0Q29uZmlnIH0gPSBhd2FpdCB0aGlzLmdldFByb3RvY29sQ29uZmlnKCk7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnRJZHg7IGkgPCBudW1JdGVyYXRpb24gKyBzdGFydElkeDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyUGF0aCA9IGBtLyR7aX1gO1xuICAgICAgY29uc3QgYWNjb3VudElkID0gTVBDLmRlcml2ZVVuaGFyZGVuZWQoYml0Z29LZXksIGN1cnJQYXRoKS5zbGljZSgwLCA2NCk7XG4gICAgICBsZXQgYXZhaWxhYmxlQmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoMCk7XG4gICAgICB0cnkge1xuICAgICAgICBhdmFpbGFibGVCYWxhbmNlID0gbmV3IEJpZ051bWJlcihhd2FpdCB0aGlzLmdldEFjY291bnRCYWxhbmNlKGFjY291bnRJZCwgc3RvcmFnZUFtb3VudFBlckJ5dGUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gVU5LTk9XTl9BQ0NPVU5UIGVycm9yIGluZGljYXRlcyB0aGF0IHRoZSBhZGRyZXNzIGhhcyBub3QgcGFydGFrZSBpbiBhbnkgdHJhbnNhY3Rpb24gc28gZmFyLCBzbyB3ZSB3aWxsXG4gICAgICAgIC8vIHRyZWF0IGl0IGFzIGEgemVybyBiYWxhbmNlIGFkZHJlc3NcbiAgICAgICAgaWYgKGUubWVzc2FnZSAhPT0gJ1VOS05PV05fQUNDT1VOVCcpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXZhaWxhYmxlQmFsYW5jZS50b051bWJlcigpIDw9IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGZpcnN0IGJ1aWxkIHRoZSB1bnNpZ25lZCB0eG5cbiAgICAgIGNvbnN0IGJzNThFbmNvZGVkUHVibGljS2V5ID0gbmVhckFQSS51dGlscy5zZXJpYWxpemUuYmFzZV9lbmNvZGUobmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20oYWNjb3VudElkLCAnaGV4JykpKTtcbiAgICAgIGNvbnN0IHsgbm9uY2UsIGJsb2NrSGFzaCB9ID0gYXdhaXQgdGhpcy5nZXRBY2Nlc3NLZXkoeyBhY2NvdW50SWQsIGJzNThFbmNvZGVkUHVibGljS2V5IH0pO1xuICAgICAgY29uc3QgZ2FzUHJpY2UgPSBhd2FpdCB0aGlzLmdldEdhc1ByaWNlKGJsb2NrSGFzaCk7XG4gICAgICBjb25zdCBnYXNQcmljZUZpcnN0QmxvY2sgPSBuZXcgQmlnTnVtYmVyKGdhc1ByaWNlKTtcbiAgICAgIGNvbnN0IGdhc1ByaWNlU2Vjb25kQmxvY2sgPSBnYXNQcmljZUZpcnN0QmxvY2subXVsdGlwbGllZEJ5KDEuMDUpO1xuICAgICAgY29uc3QgdG90YWxHYXNSZXF1aXJlZCA9IG5ldyBCaWdOdW1iZXIodHJhbnNmZXJDb3N0LnNlbmRTaXIpXG4gICAgICAgIC5wbHVzKHJlY2VpcHRDb25maWcuc2VuZFNpcilcbiAgICAgICAgLm11bHRpcGxpZWRCeShnYXNQcmljZUZpcnN0QmxvY2spXG4gICAgICAgIC5wbHVzKG5ldyBCaWdOdW1iZXIodHJhbnNmZXJDb3N0LmV4ZWN1dGlvbikucGx1cyhyZWNlaXB0Q29uZmlnLmV4ZWN1dGlvbikubXVsdGlwbGllZEJ5KGdhc1ByaWNlU2Vjb25kQmxvY2spKTtcbiAgICAgIC8vIGFkZGluZyBzb21lIHBhZGRpbmcgdG8gbWFrZSBzdXJlIHRoZSBnYXMgZG9lc24ndCBnbyBiZWxvdyByZXF1aXJlZCBnYXMgYnkgbmV0d29ya1xuICAgICAgY29uc3QgdG90YWxHYXNXaXRoUGFkZGluZyA9IHRvdGFsR2FzUmVxdWlyZWQubXVsdGlwbGllZEJ5KDEuNSk7XG4gICAgICBjb25zdCBmZWVSZXNlcnZlID0gQmlnTnVtYmVyKE5ldHdvcmtzW3RoaXMubmV0d29ya10ubmVhci5mZWVSZXNlcnZlKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VSZXNlcnZlID0gQmlnTnVtYmVyKE5ldHdvcmtzW3RoaXMubmV0d29ya10ubmVhci5zdG9yYWdlUmVzZXJ2ZSk7XG4gICAgICBjb25zdCBuZXRBbW91bnQgPSBhdmFpbGFibGVCYWxhbmNlLm1pbnVzKHRvdGFsR2FzV2l0aFBhZGRpbmcpLm1pbnVzKGZlZVJlc2VydmUpLm1pbnVzKHN0b3JhZ2VSZXNlcnZlKTtcbiAgICAgIGlmIChuZXRBbW91bnQudG9OdW1iZXIoKSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRm91bmQgYWRkcmVzcyAke2l9IHdpdGggbm9uLXplcm8gZnVuZCBidXQgZnVuZCBpcyBpbnN1ZmZpY2llbnQgdG8gc3VwcG9ydCBhIHJlY292ZXIgYCArXG4gICAgICAgICAgICBgdHJhbnNhY3Rpb24uIFBsZWFzZSBzdGFydCB0aGUgbmV4dCBzY2FuIGF0IGFkZHJlc3MgaW5kZXggJHtpICsgMX0uYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgZmFjdG9yeSA9IG5ldyBUcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5KGNvaW5zLmdldCh0aGlzLmdldENoYWluKCkpKTtcbiAgICAgIGNvbnN0IHR4QnVpbGRlciA9IGZhY3RvcnlcbiAgICAgICAgLmdldFRyYW5zZmVyQnVpbGRlcigpXG4gICAgICAgIC5zZW5kZXIoYWNjb3VudElkLCBhY2NvdW50SWQpXG4gICAgICAgIC5ub25jZShub25jZSlcbiAgICAgICAgLnJlY2VpdmVySWQocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pXG4gICAgICAgIC5yZWNlbnRCbG9ja0hhc2goYmxvY2tIYXNoKVxuICAgICAgICAuYW1vdW50KG5ldEFtb3VudC50b0ZpeGVkKCkpO1xuXG4gICAgICBpZiAoIWlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICBjb25zdCB1bnNpZ25lZFRyYW5zYWN0aW9uID0gKGF3YWl0IHR4QnVpbGRlci5idWlsZCgpKSBhcyBUcmFuc2FjdGlvbjtcbiAgICAgICAgLy8gU2lnbiB0aGUgdHhuXG4gICAgICAgIC8qICoqKioqKioqKioqKioqKioqIFNUQVJUICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICAvLyBUT0RPKEJHLTUxMDkyKTogVGhpcyBsb29rcyBsaWtlIGEgY29tbW9uIHBhcnQgd2hpY2ggY2FuIGJlIGV4dHJhY3RlZCBvdXQgdG9vXG4gICAgICAgIGlmICghcGFyYW1zLnVzZXJLZXkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdXNlcktleScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1zLmJhY2t1cEtleSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBiYWNrdXBLZXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHdhbGxldCBwYXNzcGhyYXNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhbiB1cCB3aGl0ZXNwYWNlIGZyb20gZW50ZXJlZCB2YWx1ZXNcbiAgICAgICAgY29uc3QgdXNlcktleSA9IHBhcmFtcy51c2VyS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICAgIGNvbnN0IGJhY2t1cEtleSA9IHBhcmFtcy5iYWNrdXBLZXkucmVwbGFjZSgvXFxzL2csICcnKTtcblxuICAgICAgICAvLyBEZWNyeXB0IHByaXZhdGUga2V5cyBmcm9tIEtleUNhcmQgdmFsdWVzXG4gICAgICAgIGxldCB1c2VyUHJ2O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVzZXJQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICAgICAgaW5wdXQ6IHVzZXJLZXksXG4gICAgICAgICAgICBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY3J5cHRpbmcgdXNlciBrZXljaGFpbjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIFRPRE8gQkctNTI0MTkgSW1wbGVtZW50IENvZGVjIGZvciBwYXJzaW5nICovXG4gICAgICAgIGNvbnN0IHVzZXJTaWduaW5nTWF0ZXJpYWwgPSBKU09OLnBhcnNlKHVzZXJQcnYpIGFzIEVERFNBTWV0aG9kVHlwZXMuVXNlclNpZ25pbmdNYXRlcmlhbDtcblxuICAgICAgICBsZXQgYmFja3VwUHJ2O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGJhY2t1cFBydiA9IHRoaXMuYml0Z28uZGVjcnlwdCh7XG4gICAgICAgICAgICBpbnB1dDogYmFja3VwS2V5LFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBkZWNyeXB0aW5nIGJhY2t1cCBrZXljaGFpbjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFja3VwU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZShiYWNrdXBQcnYpIGFzIEVERFNBTWV0aG9kVHlwZXMuQmFja3VwU2lnbmluZ01hdGVyaWFsO1xuICAgICAgICAvKiAqKioqKioqKioqKioqKioqKioqKioqIEVORCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvLyBhZGQgc2lnbmF0dXJlXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZUhleCA9IGF3YWl0IEVERFNBTWV0aG9kcy5nZXRUU1NTaWduYXR1cmUoXG4gICAgICAgICAgdXNlclNpZ25pbmdNYXRlcmlhbCxcbiAgICAgICAgICBiYWNrdXBTaWduaW5nTWF0ZXJpYWwsXG4gICAgICAgICAgY3VyclBhdGgsXG4gICAgICAgICAgdW5zaWduZWRUcmFuc2FjdGlvblxuICAgICAgICApO1xuICAgICAgICBjb25zdCBwdWJsaWNLZXlPYmogPSB7IHB1YjogYWNjb3VudElkIH07XG4gICAgICAgIHR4QnVpbGRlci5hZGRTaWduYXR1cmUocHVibGljS2V5T2JqIGFzIFB1YmxpY0tleSwgc2lnbmF0dXJlSGV4KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29tcGxldGVkVHJhbnNhY3Rpb24gPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRUeCA9IGNvbXBsZXRlZFRyYW5zYWN0aW9uLnRvQnJvYWRjYXN0Rm9ybWF0KCk7XG4gICAgICByZXR1cm4geyBzZXJpYWxpemVkVHg6IHNlcmlhbGl6ZWRUeCwgc2NhbkluZGV4OiBpIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCBmaW5kIGFuIGFkZHJlc3Mgd2l0aCBmdW5kcyB0byByZWNvdmVyJyk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIHJlcXVlc3QgdG8gb25lIG9mIHRoZSBwdWJsaWMgRU9TIG5vZGVzIGF2YWlsYWJsZVxuICAgKiBAcGFyYW0gcGFyYW1zLnBheWxvYWRcbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBnZXREYXRhRnJvbU5vZGUocGFyYW1zOiB7IHBheWxvYWQ/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB9KTogUHJvbWlzZTxyZXF1ZXN0LlJlc3BvbnNlPiB7XG4gICAgY29uc3Qgbm9kZVVybHMgPSB0aGlzLmdldFB1YmxpY05vZGVVcmxzKCk7XG4gICAgZm9yIChjb25zdCBub2RlVXJsIG9mIG5vZGVVcmxzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVxdWVzdC5wb3N0KG5vZGVVcmwpLnNlbmQocGFyYW1zLnBheWxvYWQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBjYWxsIGVuZHBvaW50OiAnLycgZnJvbSBub2RlczogJHtfLmpvaW4obm9kZVVybHMsICcsICcpfWApO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGdldEFjY2Vzc0tleSh7XG4gICAgYWNjb3VudElkLFxuICAgIGJzNThFbmNvZGVkUHVibGljS2V5LFxuICB9OiB7XG4gICAgYWNjb3VudElkOiBzdHJpbmc7XG4gICAgYnM1OEVuY29kZWRQdWJsaWNLZXk6IHN0cmluZztcbiAgfSk6IFByb21pc2U8TmVhclR4QnVpbGRlclBhcmFtc0Zyb21Ob2RlPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldERhdGFGcm9tTm9kZSh7XG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBpZDogJ2RvbnRjYXJlJyxcbiAgICAgICAgbWV0aG9kOiAncXVlcnknLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICByZXF1ZXN0X3R5cGU6ICd2aWV3X2FjY2Vzc19rZXknLFxuICAgICAgICAgIGZpbmFsaXR5OiAnZmluYWwnLFxuICAgICAgICAgIGFjY291bnRfaWQ6IGFjY291bnRJZCxcbiAgICAgICAgICBwdWJsaWNfa2V5OiBiczU4RW5jb2RlZFB1YmxpY0tleSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IGFjY2Vzc0tleSA9IHJlc3BvbnNlLmJvZHkucmVzdWx0O1xuICAgIHJldHVybiB7IG5vbmNlOiBhY2Nlc3NLZXkubm9uY2UgKyAxLCBibG9ja0hhc2g6IGFjY2Vzc0tleS5ibG9ja19oYXNoIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0QWNjb3VudEJhbGFuY2UoYWNjb3VudElkOiBzdHJpbmcsIHN0b3JhZ2VBbW91bnRQZXJCeXRlOiBudW1iZXIpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXREYXRhRnJvbU5vZGUoe1xuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgaWQ6ICdkb250Y2FyZScsXG4gICAgICAgIG1ldGhvZDogJ3F1ZXJ5JyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgcmVxdWVzdF90eXBlOiAndmlld19hY2NvdW50JyxcbiAgICAgICAgICBmaW5hbGl0eTogJ2ZpbmFsJyxcbiAgICAgICAgICBhY2NvdW50X2lkOiBhY2NvdW50SWQsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcXVlcnkgYWNjb3VudCBpbmZvcm1hdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBlcnJvckNhdXNlID0gcmVzcG9uc2UuYm9keS5lcnJvcj8uY2F1c2UubmFtZTtcbiAgICBpZiAoZXJyb3JDYXVzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JDYXVzZSk7XG4gICAgfVxuXG4gICAgY29uc3QgYWNjb3VudCA9IHJlc3BvbnNlLmJvZHkucmVzdWx0O1xuICAgIGNvbnN0IGNvc3RQZXJCeXRlID0gbmV3IEJpZ051bWJlcihzdG9yYWdlQW1vdW50UGVyQnl0ZSk7XG4gICAgY29uc3Qgc3RhdGVTdGFrZWQgPSBuZXcgQmlnTnVtYmVyKGFjY291bnQuc3RvcmFnZV91c2FnZSkubXVsdGlwbGllZEJ5KGNvc3RQZXJCeXRlKTtcbiAgICBjb25zdCBzdGFrZWQgPSBuZXcgQmlnTnVtYmVyKGFjY291bnQubG9ja2VkKTtcbiAgICBjb25zdCB0b3RhbEJhbGFuY2UgPSBuZXcgQmlnTnVtYmVyKGFjY291bnQuYW1vdW50KS5wbHVzKHN0YWtlZCk7XG4gICAgY29uc3QgYXZhaWxhYmxlQmFsYW5jZSA9IHRvdGFsQmFsYW5jZS5taW51cyhCaWdOdW1iZXIubWF4KHN0YWtlZCwgc3RhdGVTdGFrZWQpKTtcbiAgICByZXR1cm4gYXZhaWxhYmxlQmFsYW5jZS50b1N0cmluZygpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGdldFByb3RvY29sQ29uZmlnKCk6IFByb21pc2U8UHJvdG9jb2xDb25maWdPdXRwdXQ+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKHtcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIGlkOiAnZG9udGNhcmUnLFxuICAgICAgICBtZXRob2Q6ICdFWFBFUklNRU5UQUxfcHJvdG9jb2xfY29uZmlnJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgZmluYWxpdHk6ICdmaW5hbCcsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbmZpZyA9IHJlc3BvbnNlLmJvZHkucmVzdWx0O1xuICAgIGNvbnN0IHN0b3JhZ2VBbW91bnRQZXJCeXRlID0gY29uZmlnLnJ1bnRpbWVfY29uZmlnLnN0b3JhZ2VfYW1vdW50X3Blcl9ieXRlO1xuICAgIGNvbnN0IHRyYW5zZmVyQ29zdEZyb21OZXR3b3JrID0gY29uZmlnLnJ1bnRpbWVfY29uZmlnLnRyYW5zYWN0aW9uX2Nvc3RzLmFjdGlvbl9jcmVhdGlvbl9jb25maWcudHJhbnNmZXJfY29zdDtcbiAgICBjb25zdCB0cmFuc2ZlckNvc3Q6IE5lYXJGZWVDb25maWcgPSB7XG4gICAgICBzZW5kU2lyOiB0cmFuc2ZlckNvc3RGcm9tTmV0d29yay5zZW5kX3NpcixcbiAgICAgIHNlbmROb3RTaXI6IHRyYW5zZmVyQ29zdEZyb21OZXR3b3JrLnNlbmRfbm90X3NpcixcbiAgICAgIGV4ZWN1dGlvbjogdHJhbnNmZXJDb3N0RnJvbU5ldHdvcmsuZXhlY3V0aW9uLFxuICAgIH07XG5cbiAgICBjb25zdCByZWNlaXB0Q29uZmlnRnJvbU5ldHdvcmsgPSBjb25maWcucnVudGltZV9jb25maWcudHJhbnNhY3Rpb25fY29zdHMuYWN0aW9uX3JlY2VpcHRfY3JlYXRpb25fY29uZmlnO1xuICAgIGNvbnN0IHJlY2VpcHRDb25maWc6IE5lYXJGZWVDb25maWcgPSB7XG4gICAgICBzZW5kU2lyOiByZWNlaXB0Q29uZmlnRnJvbU5ldHdvcmsuc2VuZF9zaXIsXG4gICAgICBzZW5kTm90U2lyOiByZWNlaXB0Q29uZmlnRnJvbU5ldHdvcmsuc2VuZF9ub3Rfc2lyLFxuICAgICAgZXhlY3V0aW9uOiByZWNlaXB0Q29uZmlnRnJvbU5ldHdvcmsuZXhlY3V0aW9uLFxuICAgIH07XG4gICAgcmV0dXJuIHsgc3RvcmFnZUFtb3VudFBlckJ5dGUsIHRyYW5zZmVyQ29zdCwgcmVjZWlwdENvbmZpZyB9O1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGdldEdhc1ByaWNlKGJsb2NrSGFzaDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKHtcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIGlkOiAnZG9udGNhcmUnLFxuICAgICAgICBtZXRob2Q6ICdnYXNfcHJpY2UnLFxuICAgICAgICBwYXJhbXM6IFtibG9ja0hhc2hdLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWNjb3VudCBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLmJvZHkucmVzdWx0Lmdhc19wcmljZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRQdWJsaWNOb2RlVXJscygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIEVudmlyb25tZW50c1t0aGlzLmJpdGdvLmdldEVudigpXS5uZWFyTm9kZVVybHM7XG4gIH1cblxuICBhc3luYyBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogTmVhclBhcnNlVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxOZWFyUGFyc2VkVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkV4cGxhbmF0aW9uID0gYXdhaXQgdGhpcy5leHBsYWluVHJhbnNhY3Rpb24oe1xuICAgICAgdHhQcmVidWlsZDogcGFyYW1zLnR4UHJlYnVpbGQsXG4gICAgICBwdWJsaWNLZXk6IHBhcmFtcy5wdWJsaWNLZXksXG4gICAgICBmZWVJbmZvOiBwYXJhbXMuZmVlSW5mbyxcbiAgICB9KTtcblxuICAgIGlmICghdHJhbnNhY3Rpb25FeHBsYW5hdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbmVhclRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25FeHBsYW5hdGlvbiBhcyBOZWFyVHJhbnNhY3Rpb25FeHBsYW5hdGlvbjtcbiAgICBpZiAobmVhclRyYW5zYWN0aW9uLm91dHB1dHMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBzZW5kZXJBZGRyZXNzID0gbmVhclRyYW5zYWN0aW9uLm91dHB1dHNbMF0uYWRkcmVzcztcbiAgICBjb25zdCBmZWVBbW91bnQgPSBuZXcgQmlnTnVtYmVyKG5lYXJUcmFuc2FjdGlvbi5mZWUuZmVlID09PSAnJyA/ICcwJyA6IG5lYXJUcmFuc2FjdGlvbi5mZWUuZmVlKTtcblxuICAgIC8vIGFzc3VtZSAxIHNlbmRlciwgd2hvIGlzIGFsc28gdGhlIGZlZSBwYXllclxuICAgIGNvbnN0IGlucHV0cyA9IFtcbiAgICAgIHtcbiAgICAgICAgYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBuZXcgQmlnTnVtYmVyKG5lYXJUcmFuc2FjdGlvbi5vdXRwdXRBbW91bnQpLnBsdXMoZmVlQW1vdW50KS50b0ZpeGVkKCksXG4gICAgICB9LFxuICAgIF07XG5cbiAgICBjb25zdCBvdXRwdXRzOiBUcmFuc2FjdGlvbk91dHB1dFtdID0gbmVhclRyYW5zYWN0aW9uLm91dHB1dHMubWFwKChvdXRwdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IG91dHB1dC5hZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IG5ldyBCaWdOdW1iZXIob3V0cHV0LmFtb3VudCkudG9GaXhlZCgpLFxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBpbnB1dHMsXG4gICAgICBvdXRwdXRzLFxuICAgIH07XG4gIH1cblxuICBhc3luYyBpc1dhbGxldEFkZHJlc3MocGFyYW1zOiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRocm93IG5ldyBNZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gIH1cblxuICBhc3luYyB2ZXJpZnlUcmFuc2FjdGlvbihwYXJhbXM6IFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGxldCB0b3RhbEFtb3VudCA9IG5ldyBCaWdOdW1iZXIoMCk7XG4gICAgY29uc3QgY29pbkNvbmZpZyA9IGNvaW5zLmdldCh0aGlzLmdldENoYWluKCkpO1xuICAgIGNvbnN0IHsgdHhQcmVidWlsZDogdHhQcmVidWlsZCwgdHhQYXJhbXM6IHR4UGFyYW1zIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oY29pbkNvbmZpZyk7XG4gICAgY29uc3QgcmF3VHggPSB0eFByZWJ1aWxkLnR4SGV4O1xuICAgIGlmICghcmF3VHgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCB0eCBwcmVidWlsZCBwcm9wZXJ0eSB0eEhleCcpO1xuICAgIH1cblxuICAgIHRyYW5zYWN0aW9uLmZyb21SYXdUcmFuc2FjdGlvbihyYXdUeCk7XG4gICAgY29uc3QgZXhwbGFpbmVkVHggPSB0cmFuc2FjdGlvbi5leHBsYWluVHJhbnNhY3Rpb24oKTtcblxuICAgIC8vIHVzZXJzIGRvIG5vdCBpbnB1dCByZWNpcGllbnRzIGZvciBjb25zb2xpZGF0aW9uIHJlcXVlc3RzIGFzIHRoZXkgYXJlIGdlbmVyYXRlZCBieSB0aGUgc2VydmVyXG4gICAgaWYgKHR4UGFyYW1zLnJlY2lwaWVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZmlsdGVyZWRSZWNpcGllbnRzID0gdHhQYXJhbXMucmVjaXBpZW50cz8ubWFwKChyZWNpcGllbnQpID0+IF8ucGljayhyZWNpcGllbnQsIFsnYWRkcmVzcycsICdhbW91bnQnXSkpO1xuICAgICAgY29uc3QgZmlsdGVyZWRPdXRwdXRzID0gZXhwbGFpbmVkVHgub3V0cHV0cy5tYXAoKG91dHB1dCkgPT4gXy5waWNrKG91dHB1dCwgWydhZGRyZXNzJywgJ2Ftb3VudCddKSk7XG5cbiAgICAgIGlmICghXy5pc0VxdWFsKGZpbHRlcmVkT3V0cHV0cywgZmlsdGVyZWRSZWNpcGllbnRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R4IG91dHB1dHMgZG9lcyBub3QgbWF0Y2ggd2l0aCBleHBlY3RlZCB0eFBhcmFtcyByZWNpcGllbnRzJyk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHJlY2lwaWVudHMgb2YgdHhQYXJhbXMucmVjaXBpZW50cykge1xuICAgICAgICB0b3RhbEFtb3VudCA9IHRvdGFsQW1vdW50LnBsdXMocmVjaXBpZW50cy5hbW91bnQpO1xuICAgICAgfVxuICAgICAgaWYgKCF0b3RhbEFtb3VudC5pc0VxdWFsVG8oZXhwbGFpbmVkVHgub3V0cHV0QW1vdW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R4IHRvdGFsIGFtb3VudCBkb2VzIG5vdCBtYXRjaCB3aXRoIGV4cGVjdGVkIHRvdGFsIGFtb3VudCBmaWVsZCcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0QnVpbGRlcigpOiBUcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5IHtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uQnVpbGRlckZhY3RvcnkoY29pbnMuZ2V0KHRoaXMuZ2V0QmFzZUNoYWluKCkpKTtcbiAgfVxufVxuIl19