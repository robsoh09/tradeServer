"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilder = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const transaction_1 = require("./transaction");
const nearAPI = __importStar(require("near-api-js"));
const errors_1 = require("./errors");
const utils_1 = __importDefault(require("./utils"));
const assert_1 = __importDefault(require("assert"));
const keyPair_1 = require("./keyPair");
const hex = __importStar(require("@stablelib/hex"));
class TransactionBuilder extends sdk_core_1.BaseTransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
        this._signatures = []; // only support single sig for now
        this._transaction = new transaction_1.Transaction(_coinConfig);
    }
    /**
     * Initialize the transaction builder fields using the decoded transaction data
     *
     * @param {Transaction} tx the transaction data
     */
    initBuilder(tx) {
        this._transaction = tx;
        const nearTransaction = tx.nearTransaction;
        this._sender = nearTransaction.signerId;
        this._nonce = nearTransaction.nonce;
        this._receiverId = nearTransaction.receiverId;
        this._publicKey = hex.encode(nearTransaction.publicKey.data);
        this._recentBlockHash = nearAPI.utils.serialize.base_encode(nearTransaction.blockHash);
        this._actions = nearTransaction.actions;
    }
    /** @inheritdoc */
    fromImplementation(rawTransaction) {
        this.validateRawTransaction(rawTransaction);
        this.buildImplementation();
        return this.transaction;
    }
    /** @inheritdoc */
    async buildImplementation() {
        var _a;
        this.transaction.nearTransaction = this.buildNearTransaction();
        if (this._signer) {
            this.transaction.sign(this._signer);
        }
        if (((_a = this._signatures) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            this.transaction.constructSignedPayload(this._signatures[0].signature);
        }
        this.transaction.loadInputsAndOutputs();
        return this.transaction;
    }
    /** @inheritdoc */
    signImplementation(key) {
        this._signer = new keyPair_1.KeyPair({ prv: key.key });
        return this._transaction;
    }
    // region Getters and Setters
    /** @inheritdoc */
    get transaction() {
        return this._transaction;
    }
    /** @inheritdoc */
    set transaction(transaction) {
        this._transaction = transaction;
    }
    // endregion
    // region Validators
    /** @inheritdoc */
    validateAddress(address, addressFormat) {
        if (!utils_1.default.isValidAddress(address.address)) {
            throw new errors_1.AddressValidationError(address.address);
        }
    }
    /** @inheritdoc */
    validateKey(key) {
        try {
            new keyPair_1.KeyPair({ prv: key.key });
        }
        catch {
            throw new sdk_core_1.BuildTransactionError(`Key validation failed`);
        }
    }
    /** @inheritdoc */
    validateRawTransaction(rawTransaction) {
        try {
            nearAPI.utils.serialize.deserialize(nearAPI.transactions.SCHEMA, nearAPI.transactions.SignedTransaction, rawTransaction);
        }
        catch {
            try {
                nearAPI.utils.serialize.deserialize(nearAPI.transactions.SCHEMA, nearAPI.transactions.Transaction, rawTransaction);
            }
            catch {
                throw new sdk_core_1.BuildTransactionError('invalid raw transaction');
            }
        }
    }
    /** @inheritdoc */
    validateTransaction(transaction) {
        if (!transaction.nearTransaction) {
            return;
        }
        this.validateAddress({ address: transaction.nearTransaction.signerId });
        this.validateAddress({ address: transaction.nearTransaction.receiverId });
    }
    /** @inheritdoc */
    validateValue(value) {
        if (value.isLessThan(0)) {
            throw new sdk_core_1.BuildTransactionError('Value cannot be less than zero');
        }
    }
    // endregion
    /**
     * Sets the public key and the address of the sender of this transaction.
     *
     * @param {string} address the account that is sending this transaction
     * @param {string} pubKey the public key that is sending this transaction
     * @returns {TransactionBuilder} This transaction builder
     */
    sender(address, pubKey) {
        if (!address || !utils_1.default.isValidAddress(address.toString())) {
            throw new sdk_core_1.BuildTransactionError('Invalid or missing address, got: ' + address);
        }
        if (!pubKey || !utils_1.default.isValidPublicKey(pubKey)) {
            throw new sdk_core_1.BuildTransactionError('Invalid or missing pubKey, got: ' + pubKey);
        }
        this._sender = address;
        this._publicKey = pubKey;
        return this;
    }
    /**
     * Sets the account Id of the receiver of this transaction.
     *
     * @param {string} accountId the account id of the account that is receiving this transaction
     * @returns {TransactionBuilder} This transaction builder
     */
    receiverId(accountId) {
        utils_1.default.isValidAddress(accountId);
        this._receiverId = accountId;
        return this;
    }
    /**
     * Set the nonce
     *
     * @param {number} nonce - number that can be only used once
     * @returns {TransactionBuilder} This transaction builder
     */
    nonce(nonce) {
        if (nonce < 0) {
            throw new sdk_core_1.BuildTransactionError(`Invalid nonce: ${nonce}`);
        }
        this._nonce = nonce;
        return this;
    }
    /**
     * Sets the blockHash of this transaction.
     *
     * @param {string} blockHash the blockHash of this transaction
     * @returns {TransactionBuilder} This transaction builder
     */
    recentBlockHash(blockHash) {
        if (!utils_1.default.isValidBlockId(blockHash)) {
            throw new sdk_core_1.BuildTransactionError(`Invalid blockHash ${blockHash}`);
        }
        this._recentBlockHash = blockHash;
        return this;
    }
    /**
     * Sets the list of actions of this transaction.
     *
     * @param {nearAPI.transactions.Action[]} value the the list of actions
     * @returns {TransactionBuilder} This transaction builder
     */
    actions(value) {
        this._actions = value;
        return this;
    }
    /**
     * Builds the NEAR transaction.
     *
     * @return {Transaction} near sdk transaction
     */
    buildNearTransaction() {
        (0, assert_1.default)(this._sender, new sdk_core_1.BuildTransactionError('sender is required before building'));
        (0, assert_1.default)(this._recentBlockHash, new sdk_core_1.BuildTransactionError('recent blockhash is required before building'));
        const tx = nearAPI.transactions.createTransaction(this._sender, nearAPI.utils.PublicKey.fromString(nearAPI.utils.serialize.base_encode(hex.decode(this._publicKey))), this._receiverId, this._nonce, this._actions, nearAPI.utils.serialize.base_decode(this._recentBlockHash));
        return tx;
    }
    /** @inheritDoc */
    addSignature(publicKey, signature) {
        this._signatures.push({ publicKey, signature });
    }
}
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi90cmFuc2FjdGlvbkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSw4Q0FPeUI7QUFDekIsK0NBQTRDO0FBQzVDLHFEQUF1QztBQUN2QyxxQ0FBa0Q7QUFDbEQsb0RBQTRCO0FBQzVCLG9EQUE0QjtBQUM1Qix1Q0FBb0M7QUFDcEMsb0RBQXNDO0FBQ3RDLE1BQXNCLGtCQUFtQixTQUFRLGlDQUFzQjtJQVlyRSxZQUFZLFdBQWlDO1FBQzNDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUpiLGdCQUFXLEdBQWdCLEVBQUUsQ0FBQyxDQUFDLGtDQUFrQztRQUt2RSxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUkseUJBQVcsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFdBQVcsQ0FBQyxFQUFlO1FBQ3pCLElBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO1FBQ3ZCLE1BQU0sZUFBZSxHQUFHLEVBQUUsQ0FBQyxlQUFlLENBQUM7UUFDM0MsSUFBSSxDQUFDLE9BQU8sR0FBRyxlQUFlLENBQUMsUUFBUSxDQUFDO1FBQ3hDLElBQUksQ0FBQyxNQUFNLEdBQUcsZUFBZSxDQUFDLEtBQUssQ0FBQztRQUNwQyxJQUFJLENBQUMsV0FBVyxHQUFHLGVBQWUsQ0FBQyxVQUFVLENBQUM7UUFDOUMsSUFBSSxDQUFDLFVBQVUsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDN0QsSUFBSSxDQUFDLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDdkYsSUFBSSxDQUFDLFFBQVEsR0FB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LENBQUMsQ0FBQyxFQUNwRyxJQUFJLENBQUMsV0FBVyxFQUNoQixJQUFJLENBQUMsTUFBTSxFQUNYLElBQUksQ0FBQyxRQUFRLEVBQ2IsT0FBTyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUMzRCxDQUFDO1FBRUYsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLFlBQVksQ0FBQyxTQUF3QixFQUFFLFNBQWlCO1FBQ3RELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUM7SUFDbEQsQ0FBQztDQUNGO0FBOU5ELGdEQThOQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQge1xuICBCYXNlQWRkcmVzcyxcbiAgQmFzZUtleSxcbiAgQmFzZVRyYW5zYWN0aW9uQnVpbGRlcixcbiAgQnVpbGRUcmFuc2FjdGlvbkVycm9yLFxuICBQdWJsaWNLZXkgYXMgQmFzZVB1YmxpY0tleSxcbiAgU2lnbmF0dXJlLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuL3RyYW5zYWN0aW9uJztcbmltcG9ydCAqIGFzIG5lYXJBUEkgZnJvbSAnbmVhci1hcGktanMnO1xuaW1wb3J0IHsgQWRkcmVzc1ZhbGlkYXRpb25FcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7IEtleVBhaXIgfSBmcm9tICcuL2tleVBhaXInO1xuaW1wb3J0ICogYXMgaGV4IGZyb20gJ0BzdGFibGVsaWIvaGV4JztcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUcmFuc2FjdGlvbkJ1aWxkZXIgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25CdWlsZGVyIHtcbiAgcHJpdmF0ZSBfdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uO1xuXG4gIHByaXZhdGUgX3NlbmRlcjogc3RyaW5nO1xuICBwcml2YXRlIF9wdWJsaWNLZXk6IHN0cmluZztcbiAgcHJpdmF0ZSBfcmVjZWl2ZXJJZDogc3RyaW5nO1xuICBwcml2YXRlIF9ub25jZTogbnVtYmVyO1xuICBwcml2YXRlIF9yZWNlbnRCbG9ja0hhc2g6IHN0cmluZztcbiAgcHJpdmF0ZSBfc2lnbmVyOiBLZXlQYWlyO1xuICBwcml2YXRlIF9zaWduYXR1cmVzOiBTaWduYXR1cmVbXSA9IFtdOyAvLyBvbmx5IHN1cHBvcnQgc2luZ2xlIHNpZyBmb3Igbm93XG4gIHByb3RlY3RlZCBfYWN0aW9uczogbmVhckFQSS50cmFuc2FjdGlvbnMuQWN0aW9uW107XG5cbiAgY29uc3RydWN0b3IoX2NvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+KSB7XG4gICAgc3VwZXIoX2NvaW5Db25maWcpO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKF9jb2luQ29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSB0cmFuc2FjdGlvbiBidWlsZGVyIGZpZWxkcyB1c2luZyB0aGUgZGVjb2RlZCB0cmFuc2FjdGlvbiBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHR4IHRoZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAqL1xuICBpbml0QnVpbGRlcih0eDogVHJhbnNhY3Rpb24pOiB2b2lkIHtcbiAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHR4O1xuICAgIGNvbnN0IG5lYXJUcmFuc2FjdGlvbiA9IHR4Lm5lYXJUcmFuc2FjdGlvbjtcbiAgICB0aGlzLl9zZW5kZXIgPSBuZWFyVHJhbnNhY3Rpb24uc2lnbmVySWQ7XG4gICAgdGhpcy5fbm9uY2UgPSBuZWFyVHJhbnNhY3Rpb24ubm9uY2U7XG4gICAgdGhpcy5fcmVjZWl2ZXJJZCA9IG5lYXJUcmFuc2FjdGlvbi5yZWNlaXZlcklkO1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IGhleC5lbmNvZGUobmVhclRyYW5zYWN0aW9uLnB1YmxpY0tleS5kYXRhKTtcbiAgICB0aGlzLl9yZWNlbnRCbG9ja0hhc2ggPSBuZWFyQVBJLnV0aWxzLnNlcmlhbGl6ZS5iYXNlX2VuY29kZShuZWFyVHJhbnNhY3Rpb24uYmxvY2tIYXNoKTtcbiAgICB0aGlzLl9hY3Rpb25zID0gbmVhclRyYW5zYWN0aW9uLmFjdGlvbnM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGZyb21JbXBsZW1lbnRhdGlvbihyYXdUcmFuc2FjdGlvbjogc3RyaW5nKTogVHJhbnNhY3Rpb24ge1xuICAgIHRoaXMudmFsaWRhdGVSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbik7XG4gICAgdGhpcy5idWlsZEltcGxlbWVudGF0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb247XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGJ1aWxkSW1wbGVtZW50YXRpb24oKTogUHJvbWlzZTxUcmFuc2FjdGlvbj4ge1xuICAgIHRoaXMudHJhbnNhY3Rpb24ubmVhclRyYW5zYWN0aW9uID0gdGhpcy5idWlsZE5lYXJUcmFuc2FjdGlvbigpO1xuICAgIGlmICh0aGlzLl9zaWduZXIpIHtcbiAgICAgIHRoaXMudHJhbnNhY3Rpb24uc2lnbih0aGlzLl9zaWduZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc2lnbmF0dXJlcz8ubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy50cmFuc2FjdGlvbi5jb25zdHJ1Y3RTaWduZWRQYXlsb2FkKHRoaXMuX3NpZ25hdHVyZXNbMF0uc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgdGhpcy50cmFuc2FjdGlvbi5sb2FkSW5wdXRzQW5kT3V0cHV0cygpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBzaWduSW1wbGVtZW50YXRpb24oa2V5OiBCYXNlS2V5KTogVHJhbnNhY3Rpb24ge1xuICAgIHRoaXMuX3NpZ25lciA9IG5ldyBLZXlQYWlyKHsgcHJ2OiBrZXkua2V5IH0pO1xuICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8vIHJlZ2lvbiBHZXR0ZXJzIGFuZCBTZXR0ZXJzXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgZ2V0IHRyYW5zYWN0aW9uKCk6IFRyYW5zYWN0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIHNldCB0cmFuc2FjdGlvbih0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24pIHtcbiAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIFZhbGlkYXRvcnNcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzOiBCYXNlQWRkcmVzcywgYWRkcmVzc0Zvcm1hdD86IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghdXRpbHMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcy5hZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEFkZHJlc3NWYWxpZGF0aW9uRXJyb3IoYWRkcmVzcy5hZGRyZXNzKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdmFsaWRhdGVLZXkoa2V5OiBCYXNlS2V5KTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBLZXlQYWlyKHsgcHJ2OiBrZXkua2V5IH0pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgS2V5IHZhbGlkYXRpb24gZmFpbGVkYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb246IGFueSk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBuZWFyQVBJLnV0aWxzLnNlcmlhbGl6ZS5kZXNlcmlhbGl6ZShcbiAgICAgICAgbmVhckFQSS50cmFuc2FjdGlvbnMuU0NIRU1BLFxuICAgICAgICBuZWFyQVBJLnRyYW5zYWN0aW9ucy5TaWduZWRUcmFuc2FjdGlvbixcbiAgICAgICAgcmF3VHJhbnNhY3Rpb25cbiAgICAgICk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0cnkge1xuICAgICAgICBuZWFyQVBJLnV0aWxzLnNlcmlhbGl6ZS5kZXNlcmlhbGl6ZShcbiAgICAgICAgICBuZWFyQVBJLnRyYW5zYWN0aW9ucy5TQ0hFTUEsXG4gICAgICAgICAgbmVhckFQSS50cmFuc2FjdGlvbnMuVHJhbnNhY3Rpb24sXG4gICAgICAgICAgcmF3VHJhbnNhY3Rpb25cbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdpbnZhbGlkIHJhdyB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbik6IHZvaWQge1xuICAgIGlmICghdHJhbnNhY3Rpb24ubmVhclRyYW5zYWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGVBZGRyZXNzKHsgYWRkcmVzczogdHJhbnNhY3Rpb24ubmVhclRyYW5zYWN0aW9uLnNpZ25lcklkIH0pO1xuICAgIHRoaXMudmFsaWRhdGVBZGRyZXNzKHsgYWRkcmVzczogdHJhbnNhY3Rpb24ubmVhclRyYW5zYWN0aW9uLnJlY2VpdmVySWQgfSk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdmFsaWRhdGVWYWx1ZSh2YWx1ZTogQmlnTnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHZhbHVlLmlzTGVzc1RoYW4oMCkpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ1ZhbHVlIGNhbm5vdCBiZSBsZXNzIHRoYW4gemVybycpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVuZHJlZ2lvblxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwdWJsaWMga2V5IGFuZCB0aGUgYWRkcmVzcyBvZiB0aGUgc2VuZGVyIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIHRoZSBhY2NvdW50IHRoYXQgaXMgc2VuZGluZyB0aGlzIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJLZXkgdGhlIHB1YmxpYyBrZXkgdGhhdCBpcyBzZW5kaW5nIHRoaXMgdHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uQnVpbGRlcn0gVGhpcyB0cmFuc2FjdGlvbiBidWlsZGVyXG4gICAqL1xuICBwdWJsaWMgc2VuZGVyKGFkZHJlc3M6IHN0cmluZywgcHViS2V5OiBzdHJpbmcpOiB0aGlzIHtcbiAgICBpZiAoIWFkZHJlc3MgfHwgIXV0aWxzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MudG9TdHJpbmcoKSkpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgb3IgbWlzc2luZyBhZGRyZXNzLCBnb3Q6ICcgKyBhZGRyZXNzKTtcbiAgICB9XG4gICAgaWYgKCFwdWJLZXkgfHwgIXV0aWxzLmlzVmFsaWRQdWJsaWNLZXkocHViS2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBvciBtaXNzaW5nIHB1YktleSwgZ290OiAnICsgcHViS2V5KTtcbiAgICB9XG4gICAgdGhpcy5fc2VuZGVyID0gYWRkcmVzcztcbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBwdWJLZXk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYWNjb3VudCBJZCBvZiB0aGUgcmVjZWl2ZXIgb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRJZCB0aGUgYWNjb3VudCBpZCBvZiB0aGUgYWNjb3VudCB0aGF0IGlzIHJlY2VpdmluZyB0aGlzIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbkJ1aWxkZXJ9IFRoaXMgdHJhbnNhY3Rpb24gYnVpbGRlclxuICAgKi9cbiAgcHVibGljIHJlY2VpdmVySWQoYWNjb3VudElkOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB1dGlscy5pc1ZhbGlkQWRkcmVzcyhhY2NvdW50SWQpO1xuICAgIHRoaXMuX3JlY2VpdmVySWQgPSBhY2NvdW50SWQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBub25jZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbm9uY2UgLSBudW1iZXIgdGhhdCBjYW4gYmUgb25seSB1c2VkIG9uY2VcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uQnVpbGRlcn0gVGhpcyB0cmFuc2FjdGlvbiBidWlsZGVyXG4gICAqL1xuICBwdWJsaWMgbm9uY2Uobm9uY2U6IG51bWJlcik6IHRoaXMge1xuICAgIGlmIChub25jZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgbm9uY2U6ICR7bm9uY2V9YCk7XG4gICAgfVxuICAgIHRoaXMuX25vbmNlID0gbm9uY2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYmxvY2tIYXNoIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja0hhc2ggdGhlIGJsb2NrSGFzaCBvZiB0aGlzIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbkJ1aWxkZXJ9IFRoaXMgdHJhbnNhY3Rpb24gYnVpbGRlclxuICAgKi9cbiAgcHVibGljIHJlY2VudEJsb2NrSGFzaChibG9ja0hhc2g6IHN0cmluZyk6IHRoaXMge1xuICAgIGlmICghdXRpbHMuaXNWYWxpZEJsb2NrSWQoYmxvY2tIYXNoKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBibG9ja0hhc2ggJHtibG9ja0hhc2h9YCk7XG4gICAgfVxuICAgIHRoaXMuX3JlY2VudEJsb2NrSGFzaCA9IGJsb2NrSGFzaDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsaXN0IG9mIGFjdGlvbnMgb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtuZWFyQVBJLnRyYW5zYWN0aW9ucy5BY3Rpb25bXX0gdmFsdWUgdGhlIHRoZSBsaXN0IG9mIGFjdGlvbnNcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uQnVpbGRlcn0gVGhpcyB0cmFuc2FjdGlvbiBidWlsZGVyXG4gICAqL1xuICBwcm90ZWN0ZWQgYWN0aW9ucyh2YWx1ZTogbmVhckFQSS50cmFuc2FjdGlvbnMuQWN0aW9uW10pOiB0aGlzIHtcbiAgICB0aGlzLl9hY3Rpb25zID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgTkVBUiB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7VHJhbnNhY3Rpb259IG5lYXIgc2RrIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwcm90ZWN0ZWQgYnVpbGROZWFyVHJhbnNhY3Rpb24oKTogbmVhckFQSS50cmFuc2FjdGlvbnMuVHJhbnNhY3Rpb24ge1xuICAgIGFzc2VydCh0aGlzLl9zZW5kZXIsIG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ3NlbmRlciBpcyByZXF1aXJlZCBiZWZvcmUgYnVpbGRpbmcnKSk7XG4gICAgYXNzZXJ0KHRoaXMuX3JlY2VudEJsb2NrSGFzaCwgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcigncmVjZW50IGJsb2NraGFzaCBpcyByZXF1aXJlZCBiZWZvcmUgYnVpbGRpbmcnKSk7XG5cbiAgICBjb25zdCB0eCA9IG5lYXJBUEkudHJhbnNhY3Rpb25zLmNyZWF0ZVRyYW5zYWN0aW9uKFxuICAgICAgdGhpcy5fc2VuZGVyLFxuICAgICAgbmVhckFQSS51dGlscy5QdWJsaWNLZXkuZnJvbVN0cmluZyhuZWFyQVBJLnV0aWxzLnNlcmlhbGl6ZS5iYXNlX2VuY29kZShoZXguZGVjb2RlKHRoaXMuX3B1YmxpY0tleSkpKSxcbiAgICAgIHRoaXMuX3JlY2VpdmVySWQsXG4gICAgICB0aGlzLl9ub25jZSxcbiAgICAgIHRoaXMuX2FjdGlvbnMsXG4gICAgICBuZWFyQVBJLnV0aWxzLnNlcmlhbGl6ZS5iYXNlX2RlY29kZSh0aGlzLl9yZWNlbnRCbG9ja0hhc2gpXG4gICAgKTtcblxuICAgIHJldHVybiB0eDtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBhZGRTaWduYXR1cmUocHVibGljS2V5OiBCYXNlUHVibGljS2V5LCBzaWduYXR1cmU6IEJ1ZmZlcik6IHZvaWQge1xuICAgIHRoaXMuX3NpZ25hdHVyZXMucHVzaCh7IHB1YmxpY0tleSwgc2lnbmF0dXJlIH0pO1xuICB9XG59XG4iXX0=