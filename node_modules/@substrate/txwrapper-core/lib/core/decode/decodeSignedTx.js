"use strict";
/**
 * @ignore
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeSignedTx = void 0;
const util_1 = require("@polkadot/util");
const __1 = require("..");
/**
 * Parse the transaction information from a signed transaction offline.
 *
 * @param signedTx - The JSON representing the signed transaction.
 * @param options - Runtime-specific data used for decoding the transaction.
 */
function decodeSignedTx(signedTx, options) {
    const { metadataRpc, registry, asCallsOnlyArg, asSpecifiedCallsOnlyV14 } = options;
    registry.setMetadata((0, __1.createMetadata)(registry, metadataRpc, asCallsOnlyArg, asSpecifiedCallsOnlyV14));
    const tx = registry.createType('Extrinsic', (0, util_1.hexToU8a)(signedTx), {
        isSigned: true,
    });
    const methodCall = registry.createType('Call', tx.method);
    const method = (0, __1.toTxMethod)(registry, methodCall);
    let tip;
    try {
        tip = tx.tip.toNumber();
    }
    catch (_error) {
        tip = tx.tip.toString();
    }
    return {
        address: tx.signer.toString(),
        eraPeriod: tx.era.asMortalEra.period.toNumber(),
        metadataRpc,
        method,
        nonce: tx.nonce.toNumber(),
        tip,
    };
}
exports.decodeSignedTx = decodeSignedTx;
//# sourceMappingURL=decodeSignedTx.js.map