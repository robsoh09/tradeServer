"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeSigningPayload = void 0;
/**
 * @ignore
 */ /** */
const create_1 = require("@polkadot/types/create");
const Extrinsic_1 = require("@polkadot/types/extrinsic/v4/Extrinsic");
const __1 = require("..");
/**
 * Parse the transaction information from a signing payload.
 *
 * @param signingPayload - The signing payload, in hex.
 * @param options - Runtime-specific data used for decoding the transaction.
 */
function decodeSigningPayload(signingPayload, options) {
    const { metadataRpc, registry, asCallsOnlyArg, asSpecifiedCallsOnlyV14 } = options;
    registry.setMetadata((0, __1.createMetadata)(registry, metadataRpc, asCallsOnlyArg, asSpecifiedCallsOnlyV14));
    // We use `createTypeUnsafe` here because it allows us to specify `withoutLog: true`,
    // which silences an internal error message from polkadot-js. This is helpful in `decode`
    // which takes in just a string. We determine if the string is a signing payload or a
    // signed tx by first attempting to decode it as a signing payload with this function.
    // If that fails we catch, knowing through process of elimination it should be a
    // signed tx. `withoutLog: true` prevents an alarming error message from bubbling up
    // to the user when we catch.
    const payload = (0, create_1.createTypeUnsafe)(registry, 'ExtrinsicPayload', [
        signingPayload,
        {
            version: Extrinsic_1.EXTRINSIC_VERSION,
        },
    ]);
    const methodCall = (0, create_1.createTypeUnsafe)(registry, 'Call', [payload.method]);
    const method = (0, __1.toTxMethod)(registry, methodCall);
    // Immortal eras should return a period of 0
    const eraPeriod = payload.era.isMortalEra
        ? payload.era.asMortalEra.period.toNumber()
        : 0;
    let assetId;
    if (payload.inner.assetId) {
        assetId = payload.inner.assetId.isSome ? payload.inner.assetId : undefined;
    }
    let tip;
    try {
        tip = payload.tip.toNumber();
    }
    catch (_error) {
        tip = payload.tip.toString();
    }
    let metadataHash;
    if (payload.inner.metadataHash) {
        metadataHash = payload.inner.metadataHash.isSome
            ? payload.inner.metadataHash.toString()
            : undefined;
    }
    return {
        assetId,
        blockHash: payload.blockHash.toHex(),
        eraPeriod,
        genesisHash: payload.genesisHash.toHex(),
        metadataHash,
        metadataRpc,
        method,
        nonce: payload.nonce.toNumber(),
        specVersion: payload.specVersion.toNumber(),
        tip,
        transactionVersion: payload.transactionVersion.toNumber(),
    };
}
exports.decodeSigningPayload = decodeSigningPayload;
//# sourceMappingURL=decodeSigningPayload.js.map