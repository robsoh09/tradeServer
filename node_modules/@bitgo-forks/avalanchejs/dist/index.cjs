"use strict";var t=require("@scure/base"),e=require("@noble/hashes/utils"),r=require("@noble/hashes/sha256"),s=require("@noble/hashes/ripemd160"),n=require("util");function o(t,e,r,s){var n,o=arguments.length,a=o<3?e:null===s?s=Object.getOwnPropertyDescriptor(e,r):s;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(t,e,r,s);else for(var i=t.length-1;i>=0;i--)(n=t[i])&&(a=(o<3?n(a):o>3?n(e,r,a):n(e,r))||a);return o>3&&a&&Object.defineProperty(e,r,a),a}function a(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)}const i=Symbol.for("nodejs.util.inspect.custom"),c="-";function u(t){const e=t.split(c);if(e.length<2)throw new Error(`Invalid address: ${t}`);const r=e[0],s=e[1],[n,o]=f(s);return[r,n,o]}function d(t){return u(t)[2]}function f(e){const{prefix:r,words:s}=t.bech32.decode(e);return[r,t.bech32.fromWords(s)]}function p(e,r){const s=t.bech32.toWords(r);return t.bech32.encode(e,s)}function l(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function h(t,...e){if(!((r=t)instanceof Uint8Array||null!=r&&"object"==typeof r&&"Uint8Array"===r.constructor.name))throw new Error("Expected Uint8Array");var r;if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function x(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}const m=BigInt(2**32-1),b=BigInt(32);function g(t,e=!1){return e?{h:Number(t&m),l:Number(t>>b&m)}:{h:0|Number(t>>b&m),l:0|Number(t&m)}}function y(t,e=!1){let r=new Uint32Array(t.length),s=new Uint32Array(t.length);for(let n=0;n<t.length;n++){const{h:o,l:a}=g(t[n],e);[r[n],s[n]]=[o,a]}return[r,s]}if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");function w(t){if("string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),!((e=t)instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name))throw new Error("expected Uint8Array, got "+typeof t);var e;return t}class I{clone(){return this._cloneInto()}}const[B,T,S]=[[],[],[]],O=BigInt(0),v=BigInt(1),E=BigInt(2),A=BigInt(7),k=BigInt(256),P=BigInt(113);for(let t=0,e=v,r=1,s=0;t<24;t++){[r,s]=[s,(2*r+3*s)%5],B.push(2*(5*s+r)),T.push((t+1)*(t+2)/2%64);let n=O;for(let t=0;t<7;t++)e=(e<<v^(e>>A)*P)%k,e&E&&(n^=v<<(v<<BigInt(t))-v);S.push(n)}const[D,R]=y(S,!0),N=(t,e,r)=>r>32?((t,e,r)=>e<<r-32|t>>>64-r)(t,e,r):((t,e,r)=>t<<r|e>>>32-r)(t,e,r),_=(t,e,r)=>r>32?((t,e,r)=>t<<r-32|e>>>64-r)
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */(t,e,r):((t,e,r)=>e<<r|t>>>32-r)(t,e,r);class F extends I{constructor(t,e,r,s=!1,n=24){if(super(),this.blockLen=t,this.suffix=e,this.outputLen=r,this.enableXOF=s,this.rounds=n,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,l(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var o;this.state=new Uint8Array(200),this.state32=(o=this.state,new Uint32Array(o.buffer,o.byteOffset,Math.floor(o.byteLength/4)))}keccak(){!function(t,e=24){const r=new Uint32Array(10);for(let s=24-e;s<24;s++){for(let e=0;e<10;e++)r[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const s=(e+8)%10,n=(e+2)%10,o=r[n],a=r[n+1],i=N(o,a,1)^r[s],c=_(o,a,1)^r[s+1];for(let r=0;r<50;r+=10)t[e+r]^=i,t[e+r+1]^=c}let e=t[2],n=t[3];for(let r=0;r<24;r++){const s=T[r],o=N(e,n,s),a=_(e,n,s),i=B[r];e=t[i],n=t[i+1],t[i]=o,t[i+1]=a}for(let e=0;e<50;e+=10){for(let s=0;s<10;s++)r[s]=t[e+s];for(let s=0;s<10;s++)t[e+s]^=~r[(s+2)%10]&r[(s+4)%10]}t[0]^=D[s],t[1]^=R[s]}r.fill(0)}(this.state32,this.rounds),this.posOut=0,this.pos=0}update(t){x(this);const{blockLen:e,state:r}=this,s=(t=w(t)).length;for(let n=0;n<s;){const o=Math.min(e-this.pos,s-n);for(let e=0;e<o;e++)r[this.pos++]^=t[n++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:r,blockLen:s}=this;t[r]^=e,0!=(128&e)&&r===s-1&&this.keccak(),t[s-1]^=128,this.keccak()}writeInto(t){x(this,!1),h(t),this.finish();const e=this.state,{blockLen:r}=this;for(let s=0,n=t.length;s<n;){this.posOut>=r&&this.keccak();const o=Math.min(r-this.posOut,n-s);t.set(e.subarray(this.posOut,this.posOut+o),s),this.posOut+=o,s+=o}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return l(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(function(t,e){h(t);const r=e.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:e,suffix:r,outputLen:s,rounds:n,enableXOF:o}=this;return t||(t=new F(e,r,s,o,n)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=n,t.suffix=r,t.outputLen=s,t.enableXOF=o,t.destroyed=this.destroyed,t}}const V=((t,e,r)=>function(t){const e=e=>t().update(w(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}((()=>new F(e,t,r))))(1,136,32),U=BigInt(0),M=BigInt(1),C=BigInt(2);function q(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}const L=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function j(t){if(!q(t))throw new Error("Uint8Array expected");let e="";for(let r=0;r<t.length;r++)e+=L[t[r]];return e}function H(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function Z(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}const X={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function G(t){return t>=X._0&&t<=X._9?t-X._0:t>=X._A&&t<=X._F?t-(X._A-10):t>=X._a&&t<=X._f?t-(X._a-10):void 0}function K(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,r=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const s=new Uint8Array(r);for(let e=0,n=0;e<r;e++,n+=2){const r=G(t.charCodeAt(n)),o=G(t.charCodeAt(n+1));if(void 0===r||void 0===o){const e=t[n]+t[n+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+n)}s[e]=16*r+o}return s}function $(t){return Z(j(t))}function z(t){if(!q(t))throw new Error("Uint8Array expected");return Z(j(Uint8Array.from(t).reverse()))}function Y(t,e){return K(t.toString(16).padStart(2*e,"0"))}function J(t,e){return Y(t,e).reverse()}function W(t,e,r){let s;if("string"==typeof e)try{s=K(e)}catch(r){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${r}`)}else{if(!q(e))throw new Error(`${t} must be hex string or Uint8Array`);s=Uint8Array.from(e)}const n=s.length;if("number"==typeof r&&n!==r)throw new Error(`${t} expected ${r} bytes, got ${n}`);return s}function Q(...t){let e=0;for(let r=0;r<t.length;r++){const s=t[r];if(!q(s))throw new Error("Uint8Array expected");e+=s.length}let r=new Uint8Array(e),s=0;for(let e=0;e<t.length;e++){const n=t[e];r.set(n,s),s+=n.length}return r}function tt(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}function et(t){let e;for(e=0;t>U;t>>=M,e+=1);return e}function rt(t,e){return t>>BigInt(e)&M}const st=t=>(C<<BigInt(t-1))-M,nt=t=>new Uint8Array(t),ot=t=>Uint8Array.from(t);function at(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let s=nt(t),n=nt(t),o=0;const a=()=>{s.fill(1),n.fill(0),o=0},i=(...t)=>r(n,s,...t),c=(t=nt())=>{n=i(ot([0]),t),s=i(),0!==t.length&&(n=i(ot([1]),t),s=i())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){s=i();const e=s.slice();r.push(e),t+=s.length}return Q(...r)};return(t,e)=>{let r;for(a(),c(t);!(r=e(u()));)c();return a(),r}}const it={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||q(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function ct(t,e,r={}){const s=(e,r,s)=>{const n=it[r];if("function"!=typeof n)throw new Error(`Invalid validator "${r}", expected function`);const o=t[e];if(!(s&&void 0===o||n(o,t)))throw new Error(`Invalid param ${String(e)}=${o} (${typeof o}), expected ${r}`)};for(const[t,r]of Object.entries(e))s(t,r,!1);for(const[t,e]of Object.entries(r))s(t,e,!0);return t}var ut=Object.freeze({__proto__:null,bitGet:rt,bitLen:et,bitMask:st,bitSet:(t,e,r)=>t|(r?M:U)<<BigInt(e),bytesToHex:j,bytesToNumberBE:$,bytesToNumberLE:z,concatBytes:Q,createHmacDrbg:at,ensureBytes:W,equalBytes:function(t,e){if(t.length!==e.length)return!1;let r=0;for(let s=0;s<t.length;s++)r|=t[s]^e[s];return 0===r},hexToBytes:K,hexToNumber:Z,isBytes:q,numberToBytesBE:Y,numberToBytesLE:J,numberToHexUnpadded:H,numberToVarBytesBE:function(t){return K(H(t))},utf8ToBytes:tt,validateObject:ct});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const dt=BigInt(0),ft=BigInt(1),pt=BigInt(2),lt=BigInt(3),ht=BigInt(4),xt=BigInt(5),mt=BigInt(8);function bt(t,e){const r=t%e;return r>=dt?r:e+r}function gt(t,e,r){if(r<=dt||e<dt)throw new Error("Expected power/modulo > 0");if(r===ft)return dt;let s=ft;for(;e>dt;)e&ft&&(s=s*t%r),t=t*t%r,e>>=ft;return s}function yt(t,e,r){let s=t;for(;e-- >dt;)s*=s,s%=r;return s}function wt(t,e){if(t===dt||e<=dt)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=bt(t,e),s=e,n=dt,o=ft;for(;r!==dt;){const t=s%r,e=n-o*(s/r);s=r,r=t,n=o,o=e}if(s!==ft)throw new Error("invert: does not exist");return bt(n,e)}function It(t){if(t%ht===lt){const e=(t+ft)/ht;return function(t,r){const s=t.pow(r,e);if(!t.eql(t.sqr(s),r))throw new Error("Cannot find square root");return s}}if(t%mt===xt){const e=(t-xt)/mt;return function(t,r){const s=t.mul(r,pt),n=t.pow(s,e),o=t.mul(r,n),a=t.mul(t.mul(o,pt),n),i=t.mul(o,t.sub(a,t.ONE));if(!t.eql(t.sqr(i),r))throw new Error("Cannot find square root");return i}}return function(t){const e=(t-ft)/pt;let r,s,n;for(r=t-ft,s=0;r%pt===dt;r/=pt,s++);for(n=pt;n<t&&gt(n,e,t)!==t-ft;n++);if(1===s){const e=(t+ft)/ht;return function(t,r){const s=t.pow(r,e);if(!t.eql(t.sqr(s),r))throw new Error("Cannot find square root");return s}}const o=(r+ft)/pt;return function(t,a){if(t.pow(a,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let i=s,c=t.pow(t.mul(t.ONE,n),r),u=t.pow(a,o),d=t.pow(a,r);for(;!t.eql(d,t.ONE);){if(t.eql(d,t.ZERO))return t.ZERO;let e=1;for(let r=t.sqr(d);e<i&&!t.eql(r,t.ONE);e++)r=t.sqr(r);const r=t.pow(c,ft<<BigInt(i-e-1));c=t.sqr(r),u=t.mul(u,r),d=t.mul(d,c),i=e}return u}}(t)}BigInt(9),BigInt(16);const Bt=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Tt(t){return ct(t,Bt.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}function St(t,e,r){if(r<dt)throw new Error("Expected power > 0");if(r===dt)return t.ONE;if(r===ft)return e;let s=t.ONE,n=e;for(;r>dt;)r&ft&&(s=t.mul(s,n)),n=t.sqr(n),r>>=ft;return s}function Ot(t,e){const r=new Array(e.length),s=e.reduce(((e,s,n)=>t.is0(s)?e:(r[n]=e,t.mul(e,s))),t.ONE),n=t.inv(s);return e.reduceRight(((e,s,n)=>t.is0(s)?e:(r[n]=t.mul(e,r[n]),t.mul(e,s))),n),r}function vt(t,e){const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Et(t,e,r=!1,s={}){if(t<=dt)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:n,nByteLength:o}=vt(t,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const a=It(t),i=Object.freeze({ORDER:t,BITS:n,BYTES:o,MASK:st(n),ZERO:dt,ONE:ft,create:e=>bt(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("Invalid field element: expected bigint, got "+typeof e);return dt<=e&&e<t},is0:t=>t===dt,isOdd:t=>(t&ft)===ft,neg:e=>bt(-e,t),eql:(t,e)=>t===e,sqr:e=>bt(e*e,t),add:(e,r)=>bt(e+r,t),sub:(e,r)=>bt(e-r,t),mul:(e,r)=>bt(e*r,t),pow:(t,e)=>St(i,t,e),div:(e,r)=>bt(e*wt(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>wt(e,t),sqrt:s.sqrt||(t=>a(i,t)),invertBatch:t=>Ot(i,t),cmov:(t,e,r)=>r?e:t,toBytes:t=>r?J(t,o):Y(t,o),fromBytes:t=>{if(t.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${t.length}`);return r?z(t):$(t)}});return Object.freeze(i)}function At(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function kt(t){const e=At(t);return e+Math.ceil(e/2)}function Pt(t,e,r=!1){const s=t.length,n=At(e),o=kt(e);if(s<16||s<o||s>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${s}`);const a=bt(r?$(t):z(t),e-ft)+ft;return r?J(a,n):Y(a,n)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Dt=BigInt(0),Rt=BigInt(1);function Nt(t){return Tt(t.Fp),ct(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...vt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const{bytesToNumberBE:_t,hexToBytes:Ft}=ut,Vt={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(t){const{Err:e}=Vt;if(t.length<2||2!==t[0])throw new e("Invalid signature integer tag");const r=t[1],s=t.subarray(2,r+2);if(!r||s.length!==r)throw new e("Invalid signature integer: wrong length");if(128&s[0])throw new e("Invalid signature integer: negative");if(0===s[0]&&!(128&s[1]))throw new e("Invalid signature integer: unnecessary leading zero");return{d:_t(s),l:t.subarray(r+2)}},toSig(t){const{Err:e}=Vt,r="string"==typeof t?Ft(t):t;if(!q(r))throw new Error("ui8a expected");let s=r.length;if(s<2||48!=r[0])throw new e("Invalid signature tag");if(r[1]!==s-2)throw new e("Invalid signature: incorrect length");const{d:n,l:o}=Vt._parseInt(r.subarray(2)),{d:a,l:i}=Vt._parseInt(o);if(i.length)throw new e("Invalid signature: left bytes after parsing");return{r:n,s:a}},hexFromSig(t){const e=t=>8&Number.parseInt(t[0],16)?"00"+t:t,r=t=>{const e=t.toString(16);return 1&e.length?`0${e}`:e},s=e(r(t.s)),n=e(r(t.r)),o=s.length/2,a=n.length/2,i=r(o),c=r(a);return`30${r(a+o+4)}02${c}${n}02${i}${s}`}},Ut=BigInt(0),Mt=BigInt(1),Ct=BigInt(2),qt=BigInt(3),Lt=BigInt(4);function jt(t){const e=function(t){const e=Nt(t);ct(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:s,a:n}=e;if(r){if(!s.eql(n,s.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,s=e.toBytes||((t,e,s)=>{const n=e.toAffine();return Q(Uint8Array.from([4]),r.toBytes(n.x),r.toBytes(n.y))}),n=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function o(t){const{a:s,b:n}=e,o=r.sqr(t),a=r.mul(o,t);return r.add(r.add(a,r.mul(t,s)),n)}if(!r.eql(r.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function a(t){return"bigint"==typeof t&&Ut<t&&t<e.n}function i(t){if(!a(t))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(t){const{allowedPrivateKeyLengths:r,nByteLength:s,wrapPrivateKey:n,n:o}=e;if(r&&"bigint"!=typeof t){if(q(t)&&(t=j(t)),"string"!=typeof t||!r.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*s,"0")}let a;try{a="bigint"==typeof t?t:$(W("private key",t,s))}catch(e){throw new Error(`private key must be ${s} bytes, hex or bigint, not ${typeof t}`)}return n&&(a=bt(a,o)),i(a),a}const u=new Map;function d(t){if(!(t instanceof f))throw new Error("ProjectivePoint expected")}class f{constructor(t,e,s){if(this.px=t,this.py=e,this.pz=s,null==t||!r.isValid(t))throw new Error("x required");if(null==e||!r.isValid(e))throw new Error("y required");if(null==s||!r.isValid(s))throw new Error("z required")}static fromAffine(t){const{x:e,y:s}=t||{};if(!t||!r.isValid(e)||!r.isValid(s))throw new Error("invalid affine point");if(t instanceof f)throw new Error("projective point not allowed");const n=t=>r.eql(t,r.ZERO);return n(e)&&n(s)?f.ZERO:new f(e,s,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(f.fromAffine)}static fromHex(t){const e=f.fromAffine(n(W("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return f.BASE.multiply(c(t))}_setWindowSize(t){this._WINDOW_SIZE=t,u.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:t,y:s}=this.toAffine();if(!r.isValid(t)||!r.isValid(s))throw new Error("bad point: x or y not FE");const n=r.sqr(s),a=o(t);if(!r.eql(n,a))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){d(t);const{px:e,py:s,pz:n}=this,{px:o,py:a,pz:i}=t,c=r.eql(r.mul(e,i),r.mul(o,n)),u=r.eql(r.mul(s,i),r.mul(a,n));return c&&u}negate(){return new f(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:s}=e,n=r.mul(s,qt),{px:o,py:a,pz:i}=this;let c=r.ZERO,u=r.ZERO,d=r.ZERO,p=r.mul(o,o),l=r.mul(a,a),h=r.mul(i,i),x=r.mul(o,a);return x=r.add(x,x),d=r.mul(o,i),d=r.add(d,d),c=r.mul(t,d),u=r.mul(n,h),u=r.add(c,u),c=r.sub(l,u),u=r.add(l,u),u=r.mul(c,u),c=r.mul(x,c),d=r.mul(n,d),h=r.mul(t,h),x=r.sub(p,h),x=r.mul(t,x),x=r.add(x,d),d=r.add(p,p),p=r.add(d,p),p=r.add(p,h),p=r.mul(p,x),u=r.add(u,p),h=r.mul(a,i),h=r.add(h,h),p=r.mul(h,x),c=r.sub(c,p),d=r.mul(h,l),d=r.add(d,d),d=r.add(d,d),new f(c,u,d)}add(t){d(t);const{px:s,py:n,pz:o}=this,{px:a,py:i,pz:c}=t;let u=r.ZERO,p=r.ZERO,l=r.ZERO;const h=e.a,x=r.mul(e.b,qt);let m=r.mul(s,a),b=r.mul(n,i),g=r.mul(o,c),y=r.add(s,n),w=r.add(a,i);y=r.mul(y,w),w=r.add(m,b),y=r.sub(y,w),w=r.add(s,o);let I=r.add(a,c);return w=r.mul(w,I),I=r.add(m,g),w=r.sub(w,I),I=r.add(n,o),u=r.add(i,c),I=r.mul(I,u),u=r.add(b,g),I=r.sub(I,u),l=r.mul(h,w),u=r.mul(x,g),l=r.add(u,l),u=r.sub(b,l),l=r.add(b,l),p=r.mul(u,l),b=r.add(m,m),b=r.add(b,m),g=r.mul(h,g),w=r.mul(x,w),b=r.add(b,g),g=r.sub(m,g),g=r.mul(h,g),w=r.add(w,g),m=r.mul(b,w),p=r.add(p,m),m=r.mul(I,w),u=r.mul(y,u),u=r.sub(u,m),m=r.mul(y,b),l=r.mul(I,l),l=r.add(l,m),new f(u,p,l)}subtract(t){return this.add(t.negate())}is0(){return this.equals(f.ZERO)}wNAF(t){return l.wNAFCached(this,u,t,(t=>{const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(f.fromAffine)}))}multiplyUnsafe(t){const s=f.ZERO;if(t===Ut)return s;if(i(t),t===Mt)return this;const{endo:n}=e;if(!n)return l.unsafeLadder(this,t);let{k1neg:o,k1:a,k2neg:c,k2:u}=n.splitScalar(t),d=s,p=s,h=this;for(;a>Ut||u>Ut;)a&Mt&&(d=d.add(h)),u&Mt&&(p=p.add(h)),h=h.double(),a>>=Mt,u>>=Mt;return o&&(d=d.negate()),c&&(p=p.negate()),p=new f(r.mul(p.px,n.beta),p.py,p.pz),d.add(p)}multiply(t){i(t);let s,n,o=t;const{endo:a}=e;if(a){const{k1neg:t,k1:e,k2neg:i,k2:c}=a.splitScalar(o);let{p:u,f:d}=this.wNAF(e),{p:p,f:h}=this.wNAF(c);u=l.constTimeNegate(t,u),p=l.constTimeNegate(i,p),p=new f(r.mul(p.px,a.beta),p.py,p.pz),s=u.add(p),n=d.add(h)}else{const{p:t,f:e}=this.wNAF(o);s=t,n=e}return f.normalizeZ([s,n])[0]}multiplyAndAddUnsafe(t,e,r){const s=f.BASE,n=(t,e)=>e!==Ut&&e!==Mt&&t.equals(s)?t.multiply(e):t.multiplyUnsafe(e),o=n(this,e).add(n(t,r));return o.is0()?void 0:o}toAffine(t){const{px:e,py:s,pz:n}=this,o=this.is0();null==t&&(t=o?r.ONE:r.inv(n));const a=r.mul(e,t),i=r.mul(s,t),c=r.mul(n,t);if(o)return{x:r.ZERO,y:r.ZERO};if(!r.eql(c,r.ONE))throw new Error("invZ was invalid");return{x:a,y:i}}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===Mt)return!0;if(r)return r(f,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===Mt?this:r?r(f,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return this.assertValidity(),s(f,this,t)}toHex(t=!0){return j(this.toRawBytes(t))}}f.BASE=new f(e.Gx,e.Gy,r.ONE),f.ZERO=new f(r.ZERO,r.ONE,r.ZERO);const p=e.nBitLength,l=function(t,e){const r=(t,e)=>{const r=e.negate();return t?r:e},s=t=>({windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate:r,unsafeLadder(e,r){let s=t.ZERO,n=e;for(;r>Dt;)r&Rt&&(s=s.add(n)),n=n.double(),r>>=Rt;return s},precomputeWindow(t,e){const{windows:r,windowSize:n}=s(e),o=[];let a=t,i=a;for(let t=0;t<r;t++){i=a,o.push(i);for(let t=1;t<n;t++)i=i.add(a),o.push(i);a=i.double()}return o},wNAF(e,n,o){const{windows:a,windowSize:i}=s(e);let c=t.ZERO,u=t.BASE;const d=BigInt(2**e-1),f=2**e,p=BigInt(e);for(let t=0;t<a;t++){const e=t*i;let s=Number(o&d);o>>=p,s>i&&(s-=f,o+=Rt);const a=e,l=e+Math.abs(s)-1,h=t%2!=0,x=s<0;0===s?u=u.add(r(h,n[a])):c=c.add(r(x,n[l]))}return{p:c,f:u}},wNAFCached(t,e,r,s){const n=t._WINDOW_SIZE||1;let o=e.get(t);return o||(o=this.precomputeWindow(t,n),1!==n&&e.set(t,s(o))),this.wNAF(n,o,r)}}}(f,e.endo?Math.ceil(p/2):p);return{CURVE:e,ProjectivePoint:f,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:a}}function Ht(t){const e=function(t){const e=Nt(t);return ct(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:r,n:s}=e,n=r.BYTES+1,o=2*r.BYTES+1;function a(t){return bt(t,s)}function i(t){return wt(t,s)}const{ProjectivePoint:c,normPrivateKeyToScalar:u,weierstrassEquation:d,isWithinCurveOrder:f}=jt({...e,toBytes(t,e,s){const n=e.toAffine(),o=r.toBytes(n.x),a=Q;return s?a(Uint8Array.from([e.hasEvenY()?2:3]),o):a(Uint8Array.from([4]),o,r.toBytes(n.y))},fromBytes(t){const e=t.length,s=t[0],a=t.subarray(1);if(e!==n||2!==s&&3!==s){if(e===o&&4===s){return{x:r.fromBytes(a.subarray(0,r.BYTES)),y:r.fromBytes(a.subarray(r.BYTES,2*r.BYTES))}}throw new Error(`Point of length ${e} was invalid. Expected ${n} compressed bytes or ${o} uncompressed bytes`)}{const t=$(a);if(!(Ut<(i=t)&&i<r.ORDER))throw new Error("Point is not on curve");const e=d(t);let n=r.sqrt(e);return 1==(1&s)!==((n&Mt)===Mt)&&(n=r.neg(n)),{x:t,y:n}}var i}}),p=t=>j(Y(t,e.nByteLength));function l(t){return t>s>>Mt}const h=(t,e,r)=>$(t.slice(e,r));class x{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){const r=e.nByteLength;return t=W("compactSignature",t,2*r),new x(h(t,0,r),h(t,r,2*r))}static fromDER(t){const{r:e,s:r}=Vt.toSig(W("DER",t));return new x(e,r)}assertValidity(){if(!f(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!f(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new x(this.r,this.s,t)}recoverPublicKey(t){const{r:s,s:n,recovery:o}=this,u=y(W("msgHash",t));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const d=2===o||3===o?s+e.n:s;if(d>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const f=0==(1&o)?"02":"03",l=c.fromHex(f+p(d)),h=i(d),x=a(-u*h),m=a(n*h),b=c.BASE.multiplyAndAddUnsafe(l,x,m);if(!b)throw new Error("point at infinify");return b.assertValidity(),b}hasHighS(){return l(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return K(this.toDERHex())}toDERHex(){return Vt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return K(this.toCompactHex())}toCompactHex(){return p(this.r)+p(this.s)}}const m={isValidPrivateKey(t){try{return u(t),!0}catch(t){return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const t=kt(e.n);return Pt(e.randomBytes(t),e.n)},precompute:(t=8,e=c.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function b(t){const e=q(t),r="string"==typeof t,s=(e||r)&&t.length;return e?s===n||s===o:r?s===2*n||s===2*o:t instanceof c}const g=e.bits2int||function(t){const r=$(t),s=8*t.length-e.nBitLength;return s>0?r>>BigInt(s):r},y=e.bits2int_modN||function(t){return a(g(t))},w=st(e.nBitLength);function I(t){if("bigint"!=typeof t)throw new Error("bigint expected");if(!(Ut<=t&&t<w))throw new Error(`bigint expected < 2^${e.nBitLength}`);return Y(t,e.nByteLength)}function B(t,s,n=T){if(["recovered","canonical"].some((t=>t in n)))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:d}=e;let{lowS:p,prehash:h,extraEntropy:m}=n;null==p&&(p=!0),t=W("msgHash",t),h&&(t=W("prehashed msgHash",o(t)));const b=y(t),w=u(s),B=[I(w),I(b)];if(null!=m){const t=!0===m?d(r.BYTES):m;B.push(W("extraEntropy",t))}const S=Q(...B),O=b;return{seed:S,k2sig:function(t){const e=g(t);if(!f(e))return;const r=i(e),s=c.BASE.multiply(e).toAffine(),n=a(s.x);if(n===Ut)return;const o=a(r*a(O+n*w));if(o===Ut)return;let u=(s.x===n?0:2)|Number(s.y&Mt),d=o;return p&&l(o)&&(d=function(t){return l(t)?a(-t):t}(o),u^=1),new x(n,d,u)}}}const T={lowS:e.lowS,prehash:!1},S={lowS:e.lowS,prehash:!1};return c.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return c.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(b(t))throw new Error("first arg must be private key");if(!b(e))throw new Error("second arg must be public key");return c.fromHex(e).multiply(u(t)).toRawBytes(r)},sign:function(t,r,s=T){const{seed:n,k2sig:o}=B(t,r,s),a=e;return at(a.hash.outputLen,a.nByteLength,a.hmac)(n,o)},verify:function(t,r,s,n=S){const o=t;if(r=W("msgHash",r),s=W("publicKey",s),"strict"in n)throw new Error("options.strict was renamed to lowS");const{lowS:u,prehash:d}=n;let f,p;try{if("string"==typeof o||q(o))try{f=x.fromDER(o)}catch(t){if(!(t instanceof Vt.Err))throw t;f=x.fromCompact(o)}else{if("object"!=typeof o||"bigint"!=typeof o.r||"bigint"!=typeof o.s)throw new Error("PARSE");{const{r:t,s:e}=o;f=new x(t,e)}}p=c.fromHex(s)}catch(t){if("PARSE"===t.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(u&&f.hasHighS())return!1;d&&(r=e.hash(r));const{r:l,s:h}=f,m=y(r),b=i(h),g=a(m*b),w=a(l*b),I=c.BASE.multiplyAndAddUnsafe(p,g,w)?.toAffine();return!!I&&a(I.x)===l},ProjectivePoint:c,Signature:x,utils:m}}function Zt(t,e){if(Tt(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const r=function(t,e){const r=t.ORDER;let s=Ut;for(let t=r-Mt;t%Ct===Ut;t/=Ct)s+=Mt;const n=s,o=Ct<<n-Mt-Mt,a=o*Ct,i=(r-Mt)/a,c=(i-Mt)/Ct,u=a-Mt,d=o,f=t.pow(e,i),p=t.pow(e,(i+Mt)/Ct);let l=(e,r)=>{let s=f,o=t.pow(r,u),a=t.sqr(o);a=t.mul(a,r);let i=t.mul(e,a);i=t.pow(i,c),i=t.mul(i,o),o=t.mul(i,r),a=t.mul(i,e);let l=t.mul(a,o);i=t.pow(l,d);let h=t.eql(i,t.ONE);o=t.mul(a,p),i=t.mul(l,s),a=t.cmov(o,a,h),l=t.cmov(i,l,h);for(let e=n;e>Mt;e--){let r=e-Ct;r=Ct<<r-Mt;let n=t.pow(l,r);const i=t.eql(n,t.ONE);o=t.mul(a,s),s=t.mul(s,s),n=t.mul(l,s),a=t.cmov(o,a,i),l=t.cmov(n,l,i)}return{isValid:h,value:a}};if(t.ORDER%Lt===qt){const r=(t.ORDER-qt)/Lt,s=t.sqrt(t.neg(e));l=(e,n)=>{let o=t.sqr(n);const a=t.mul(e,n);o=t.mul(o,a);let i=t.pow(o,r);i=t.mul(i,a);const c=t.mul(i,s),u=t.mul(t.sqr(i),n),d=t.eql(u,e);return{isValid:d,value:t.cmov(c,i,d)}}}return l}(t,e.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return s=>{let n,o,a,i,c,u,d,f;n=t.sqr(s),n=t.mul(n,e.Z),o=t.sqr(n),o=t.add(o,n),a=t.add(o,t.ONE),a=t.mul(a,e.B),i=t.cmov(e.Z,t.neg(o),!t.eql(o,t.ZERO)),i=t.mul(i,e.A),o=t.sqr(a),u=t.sqr(i),c=t.mul(u,e.A),o=t.add(o,c),o=t.mul(o,a),u=t.mul(u,i),c=t.mul(u,e.B),o=t.add(o,c),d=t.mul(n,a);const{isValid:p,value:l}=r(o,u);f=t.mul(n,s),f=t.mul(f,l),d=t.cmov(d,a,p),f=t.cmov(f,l,p);const h=t.isOdd(s)===t.isOdd(f);return f=t.cmov(t.neg(f),f,h),d=t.div(d,i),{x:d,y:f}}}const Xt=$;function Gt(t,e){if(t<0||t>=1<<8*e)throw new Error(`bad I2OSP call: value=${t} length=${e}`);const r=Array.from({length:e}).fill(0);for(let s=e-1;s>=0;s--)r[s]=255&t,t>>>=8;return new Uint8Array(r)}function Kt(t,e){const r=new Uint8Array(t.length);for(let s=0;s<t.length;s++)r[s]=t[s]^e[s];return r}function $t(t){if(!q(t))throw new Error("Uint8Array expected")}function zt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Yt(t,e,r){ct(r,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:s,k:n,m:o,hash:a,expand:i,DST:c}=r;$t(t),zt(e);const u=function(t){if(q(t))return t;if("string"==typeof t)return tt(t);throw new Error("DST must be Uint8Array or string")}(c),d=s.toString(2).length,f=Math.ceil((d+n)/8),p=e*o*f;let l;if("xmd"===i)l=function(t,e,r,s){$t(t),$t(e),zt(r),e.length>255&&(e=s(Q(tt("H2C-OVERSIZE-DST-"),e)));const{outputLen:n,blockLen:o}=s,a=Math.ceil(r/n);if(a>255)throw new Error("Invalid xmd length");const i=Q(e,Gt(e.length,1)),c=Gt(0,o),u=Gt(r,2),d=new Array(a),f=s(Q(c,t,u,Gt(0,1),i));d[0]=s(Q(f,Gt(1,1),i));for(let t=1;t<=a;t++){const e=[Kt(f,d[t-1]),Gt(t+1,1),i];d[t]=s(Q(...e))}return Q(...d).slice(0,r)}(t,u,p,a);else if("xof"===i)l=function(t,e,r,s,n){if($t(t),$t(e),zt(r),e.length>255){const t=Math.ceil(2*s/8);e=n.create({dkLen:t}).update(tt("H2C-OVERSIZE-DST-")).update(e).digest()}if(r>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return n.create({dkLen:r}).update(t).update(Gt(r,2)).update(e).update(Gt(e.length,1)).digest()}(t,u,p,n,a);else{if("_internal_pass"!==i)throw new Error('expand must be "xmd" or "xof"');l=t}const h=new Array(e);for(let t=0;t<e;t++){const e=new Array(o);for(let r=0;r<o;r++){const n=f*(r+t*o),a=l.subarray(n,n+f);e[r]=bt(Xt(a),s)}h[t]=e}return h}function Jt(t,e){const r=e.map((t=>Array.from(t).reverse()));return(e,s)=>{const[n,o,a,i]=r.map((r=>r.reduce(((r,s)=>t.add(t.mul(r,e),s)))));return e=t.div(n,o),s=t.mul(s,t.div(a,i)),{x:e,y:s}}}function Wt(t,e,r){if("function"!=typeof e)throw new Error("mapToCurve() must be defined");return{hashToCurve(s,n){const o=Yt(s,2,{...r,DST:r.DST,...n}),a=t.fromAffine(e(o[0])),i=t.fromAffine(e(o[1])),c=a.add(i).clearCofactor();return c.assertValidity(),c},encodeToCurve(s,n){const o=Yt(s,1,{...r,DST:r.encodeDST,...n}),a=t.fromAffine(e(o[0])).clearCofactor();return a.assertValidity(),a}}}class Qt extends I{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");l(t.outputLen),l(t.blockLen)}(t);const r=w(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,n=new Uint8Array(s);n.set(r.length>s?t.create().update(r).digest():r);for(let t=0;t<n.length;t++)n[t]^=54;this.iHash.update(n),this.oHash=t.create();for(let t=0;t<n.length;t++)n[t]^=106;this.oHash.update(n),n.fill(0)}update(t){return x(this),this.iHash.update(t),this}digestInto(t){x(this),h(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:n,blockLen:o,outputLen:a}=this;return t.finished=s,t.destroyed=n,t.blockLen=o,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const te=(t,e,r)=>new Qt(t,e).update(r).digest();
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function ee(t){return{hash:t,hmac:(r,...s)=>te(t,r,e.concatBytes(...s)),randomBytes:e.randomBytes}}te.create=(t,e)=>new Qt(t,e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const re=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),se=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ne=BigInt(1),oe=BigInt(2),ae=(t,e)=>(t+e/oe)/e;const ie=Et(re,void 0,void 0,{sqrt:function(t){const e=re,r=BigInt(3),s=BigInt(6),n=BigInt(11),o=BigInt(22),a=BigInt(23),i=BigInt(44),c=BigInt(88),u=t*t*t%e,d=u*u*t%e,f=yt(d,r,e)*d%e,p=yt(f,r,e)*d%e,l=yt(p,oe,e)*u%e,h=yt(l,n,e)*l%e,x=yt(h,o,e)*h%e,m=yt(x,i,e)*x%e,b=yt(m,c,e)*m%e,g=yt(b,i,e)*x%e,y=yt(g,r,e)*d%e,w=yt(y,a,e)*h%e,I=yt(w,s,e)*u%e,B=yt(I,oe,e);if(!ie.eql(ie.sqr(B),t))throw new Error("Cannot find square root");return B}}),ce=function(t,e){const r=e=>Ht({...t,...ee(e)});return Object.freeze({...r(e),create:r})}({a:BigInt(0),b:BigInt(7),Fp:ie,n:se,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=se,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),s=-ne*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),n=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=r,a=BigInt("0x100000000000000000000000000000000"),i=ae(o*t,e),c=ae(-s*t,e);let u=bt(t-i*r-c*n,e),d=bt(-i*s-c*o,e);const f=u>a,p=d>a;if(f&&(u=e-u),p&&(d=e-d),u>a||d>a)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:f,k1:u,k2neg:p,k2:d}}}},r.sha256);BigInt(0),ce.ProjectivePoint,Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));
/*! micro-eth-signer - MIT License (c) 2021 Paul Miller (paulmillr.com) */
const ue=t=>ce.getPublicKey(t,!1),de=t=>ce.ProjectivePoint.fromHex(t).toRawBytes(!1);function fe(t){return/^0x/i.test(t)?t:`0x${t}`}function pe(t){return t.replace(/^0x/i,"")}function le(t){return e.hexToBytes(pe(t))}const he={fromPrivateKey:t=>("string"==typeof t&&(t=le(t)),he.fromPublicKey(ue(t))),fromPublicKey(t){const r=de(t),s=e.bytesToHex(V(r.subarray(1,65))).slice(24);return he.checksum(s)},checksum(t){const r=pe(t.toLowerCase());if(40!==r.length)throw new Error("Invalid address, must have 40 chars");const s=pe(e.bytesToHex(V(r)));let n="";for(let t=0;t<r.length;t++){const e=Number.parseInt(s[t],16);let o=r[t];e>7&&(o=o.toUpperCase()),n+=o}return fe(n)},verifyChecksum(t){const r=pe(t);if(40!==r.length)throw new Error("Invalid address, must have 40 chars");if(r===r.toLowerCase()||r===r.toUpperCase())return!0;const s=e.bytesToHex(V(r.toLowerCase()));for(let t=0;t<40;t++){const e=r[t],n=Number.parseInt(s[t],16);if(n>7&&e.toUpperCase()!==e)return!1;if(n<=7&&e.toLowerCase()!==e)return!1}return!0}};function xe(t){return BigInt(be(t))}function me(t){return Number.parseInt(e.bytesToHex(t),16)}function be(t){return fe(e.bytesToHex(t))}function ge(t){return 1&(t=pe(t)).length&&(t="0"+t),e.hexToBytes(t)}function ye(t,e){const r=e-t.length;if(r<=0)return t;const s=new Uint8Array(e);return s.set(t,r),s}class we{}const Ie="AVM",Be="EVM",Te="PVM",Se=[Ie,Be,Te];var Oe,ve;exports.TypeSymbols=void 0,(Oe=exports.TypeSymbols||(exports.TypeSymbols={})).Codec="codec",Oe.BaseTx="avax.BaseTx",Oe.TransferableOutput="avax.TransferableOutput",Oe.TransferableInput="avax.TransferableInput",Oe.TransferableOp="avax.TransferableOp",Oe.UTXOID="avax.UTXOID",Oe.UTXO="avax.Utxo",Oe.Id="common.Id",Oe.Address="common.Address",Oe.NodeId="common.NodeId",Oe.Int="primitives.Int",Oe.BigIntPr="primitives.BigInt",Oe.StringPr="primitives.String",Oe.Byte="primitives.Byte",Oe.Bytes="primitives.Bytes",Oe.Short="primitives.Short",Oe.Input="secp256k1fx.Input",Oe.TransferInput="secp256k1fx.TransferInput",Oe.TransferOutput="secp256k1fx.TransferOutput",Oe.OutputOwners="secp256k1fx.OutputOwners",Oe.OutputOwnersList="secp256k1fx.OutputOwnersList",Oe.Credential="secp256k1fx.Credential",Oe.Signature="secp256k1fx.Signature",Oe.SecpMintOperation="secp256k1fx.MintOperation",Oe.SecpMintOutput="secp256k1fx.MintOutput",Oe.NftFxMintOperation="nftfx.MintOperation",Oe.NftFxMintOutput="nftfx.MintOutput",Oe.NftFxTransferOperation="nftfx.TransferOperation",Oe.NftFxTransferOutput="nftfx.TransferOutput",Oe.NftFxCredential="nftfx.Credential",Oe.AvmBaseTx="avm.BaseTx",Oe.AvmExportTx="avm.ExportTx",Oe.AvmImportTx="avm.ImportTx",Oe.CreateAssetTx="avm.CreateAssetTx",Oe.OperationTx="avm.OperationTx",Oe.InitialState="avm.InitialState",Oe.AvmSignedTx="avm.SignedTx",Oe.PvmBaseTx="pvm.BaseTx",Oe.StakeableLockIn="pvm.StakeableLockIn",Oe.StakeableLockOut="pvm.StakeableLockOut",Oe.AddDelegatorTx="pvm.AddDelegatorTx",Oe.AddValidatorTx="pvm.AddValidatorTx",Oe.AddPermissionlessDelegatorTx="pvm.AddPermissionlessDelegator",Oe.AddPermissionlessValidatorTx="pvm.AddPermissionlessValidator",Oe.Validator="pvm.Validator",Oe.SubnetValidator="pvm.SubnetValidator",Oe.Signer="pvm.signer",Oe.SignerEmpty="pvm.signerEmpty",Oe.ProofOfPossession="pvm.proofOfPossession",Oe.AddSubnetValidatorTx="pvm.AddSubnetValidator",Oe.AdvanceTimeTx="pvm.AdvanceTimeTx",Oe.CreateChainTx="pvm.CreateChainTx",Oe.CreateSubnetTx="pvm.CreateSubnetTx",Oe.PvmExportTx="pvm.ExportTx",Oe.PvmImportTx="pvm.ImportTx",Oe.RewardValidatorTx="pvm.RewardValidatorTx",Oe.RemoveSubnetValidatorTx="pvm.RemoveSubnetValidator",Oe.TransformSubnetTx="pvm.TransformSubnetTx",Oe.TransferSubnetOwnershipTx="pvm.TransferSubnetOwnershipTx",Oe.EvmExportTx="evm.ExportTx",Oe.EvmInput="evm.Input",Oe.EvmOutput="evm.Output",Oe.EvmImportTx="evm.ImportTx",exports.Address=ve=class extends we{address;_type=exports.TypeSymbols.Address;constructor(t){super(),this.address=t}static fromBytes(t){return[new ve(t.slice(0,20)),t.slice(20)]}[i](t,e){return e.stylize(this.toJSON(),"string")}toJSON(t="avax"){return this.toString(t)}static fromString(t){return new ve(d(t))}static fromHex(t){return new ve(ge(t))}toHex(){return be(this.address)}toBytes(){return ye(this.address,20)}toString(t="avax"){return p(t,this.address)}value(){return this.toString()}},exports.Address=ve=o([t=>{},a("design:paramtypes",[Uint8Array])],exports.Address);const Ee={encode:s=>t.base58.encode(e.concatBytes(s,r.sha256(s).subarray(-4))),decode:e=>t.base58.decode(e).subarray(0,-4)},Ae=(t,e)=>{let r;for(r=0;r<t.length&&r<e.length;r++){const s=t[r],n=e[r];if(s!==n)return s-n}return r===t.length&&r===e.length?0:r===t.length?-1:1};var ke,Pe;exports.Id=ke=class extends we{idVal;_type=exports.TypeSymbols.Id;constructor(t){super(),this.idVal=t}static fromBytes(t){return[new ke(t.slice(0,32)),t.slice(32)]}static compare(t,e){return Ae(t.toBytes(),e.toBytes())}[i](t,e){return e.stylize(this.toString(),"string")}toBytes(){return ye(this.idVal,32)}toJSON(){return this.toString()}toString(){return Ee.encode(this.toBytes())}static fromString(t){return ke.fromBytes(Ee.decode(t))[0]}static fromHex(t){return new ke(ge(t))}value(){return this.toString()}},exports.Id=ke=o([t=>{},a("design:paramtypes",[Uint8Array])],exports.Id);const De="NodeID-";exports.NodeId=Pe=class extends we{idVal;_type=exports.TypeSymbols.NodeId;constructor(t){super(),this.idVal=t}static fromBytes(t){return[new Pe(t.slice(0,20)),t.slice(20)]}[i](t,e){return e.stylize(this.toString(),"string")}toBytes(){return ye(this.idVal,20)}toJSON(){return this.toString()}toString(){return De+Ee.encode(this.toBytes())}static fromString(t){if(!t.includes(De))throw new Error("ID is missing prefix");return this.fromBytes(Ee.decode(t.replace(De,"")))[0]}static fromHex(t){return new Pe(ge(t))}value(){return this.toString()}},exports.NodeId=Pe=o([t=>{},a("design:paramtypes",[Uint8Array])],exports.NodeId);const Re=new exports.Id(new Uint8Array(32)),Ne=new exports.Id(new Uint8Array(32)),_e="avax",Fe="cascade",Ve="denali",Ue="everest",Me="fuji",Ce="testing",qe="local",Le="custom",je={1:_e,2:Fe,3:Ve,4:Ue,5:Me,10:Ce,12345:qe},He=t=>je[t]??Le;var Ze,Xe=Object.freeze({__proto__:null,CascadeHRP:Fe,CascadeID:2,CascadeName:"cascade",DenaliHRP:Ve,DenaliID:3,DenaliName:"denali",EverestHRP:Ue,EverestID:4,EverestName:"everest",FallbackHRP:Le,FujiHRP:Me,FujiID:5,FujiName:"fuji",LocalHRP:qe,LocalID:12345,LocalName:"local",MainnetHRP:_e,MainnetID:1,MainnetName:"mainnet",NetworkIDToHRP:je,PlatformChainID:Ne,PrimaryNetworkID:Re,TestnetID:5,TestnetName:"testnet",UnitTestHRP:Ce,UnitTestID:10,UnitTestName:"testing",getHRP:He});class Ge{getVM(){return this.vm}}class Ke extends Ge{getInputs(){return this.baseTx?.inputs??[]}getBlockchainId(){return this.baseTx?.BlockchainId.toString()??""}getSigIndices(){return this.getInputs().map((t=>t.sigIndicies())).filter((t=>void 0!==t))}}exports.Int=Ze=class extends we{int;_type=exports.TypeSymbols.Int;constructor(t){super(),this.int=t}static fromBytes(t){return[new Ze(me(t.slice(0,4))),t.slice(4)]}[i](){return this.value()}toJSON(){return this.int}toBytes(){return ye(ge(this.int.toString(16)),4)}value(){return this.int}},exports.Int=Ze=o([t=>{},a("design:paramtypes",[Number])],exports.Int);const $e=t=>new exports.Int(t).toBytes(),ze=(t,e,r)=>Ye(t,e.fromBytes,r),Ye=(t,e,r)=>{let s;[s,t]=exports.Int.fromBytes(t);const n=[];for(let o=0;o<s.value();o++){if(0===t.length)throw new Error("not enough bytes");let s;[s,t]=e(t,r),n.push(s)}return[n,t]},Je=t=>({fromBytes:(e,r)=>ze(e,t,r)}),We={fromBytes:(t,e)=>{if(!e)throw new Error("codec required when using unpackCodecList");return Ye(t,e.UnpackPrefix,e)}},Qe=(t,r)=>e.concatBytes($e(t.length),...t.map((t=>t.toBytes(r))));function tr(t,e,r){return[...e.map((e=>{let s;if(!t.length)throw new Error("not enough bytes");return[s,t]=e.fromBytes(t,r),s})),t]}function er(t,r){return e.concatBytes(...t.map((t=>Array.isArray(t)?Qe(t,r):t.toBytes(r))))}function rr(t,...e){return er(e,t)}var sr,nr,or,ar,ir,cr;function ur(t){return t._type===exports.TypeSymbols.TransferOutput}function dr(t){return t._type===exports.TypeSymbols.StakeableLockOut}function fr(t){return t._type===exports.TypeSymbols.OutputOwners}function pr(t){return t._type===exports.TypeSymbols.StakeableLockIn}function lr(t){return t._type===exports.TypeSymbols.TransferInput}exports.BigIntPr=sr=class extends we{bigint;_type=exports.TypeSymbols.BigIntPr;constructor(t){super(),this.bigint=t}[i](){return this.bigint}static fromBytes(t){return[new sr(xe(t.slice(0,8))),t.slice(8)]}toJSON(){return this.bigint.toString()}toBytes(){return ye(ge(this.bigint.toString(16)),8)}value(){return this.bigint}},exports.BigIntPr=sr=o([t=>{},a("design:paramtypes",[BigInt])],exports.BigIntPr),exports.Byte=nr=class extends we{byte;_type=exports.TypeSymbols.Byte;constructor(t){super(),this.byte=t}static fromBytes(t){return[new nr(t.slice(0,1)),t.slice(1)]}toJSON(){return be(this.byte)}toBytes(){return this.byte}},exports.Byte=nr=o([t=>{},a("design:paramtypes",[Uint8Array])],exports.Byte),exports.Bytes=or=class extends we{bytes;_type=exports.TypeSymbols.Bytes;constructor(t){super(),this.bytes=t}toString(e="utf8"){return t.bytesToString(e,this.bytes)}toJSON(){return be(this.bytes)}static fromBytes(t){const[e,r]=exports.Int.fromBytes(t);return[new or(r.slice(0,e.value())),r.slice(e.value())]}toBytes(){return e.concatBytes($e(this.bytes.length),this.bytes)}},exports.Bytes=or=o([t=>{},a("design:paramtypes",[Uint8Array])],exports.Bytes),exports.Short=ar=class extends we{short;_type=exports.TypeSymbols.Short;constructor(t){super(),this.short=t}static fromBytes(t){return[new ar(me(t.slice(0,2))),t.slice(2)]}toJSON(){return this.short.toString()}toBytes(){return ye(ge(this.short.toString(16)),2)}value(){return this.short}},exports.Short=ar=o([t=>{},a("design:paramtypes",[Number])],exports.Short),exports.Stringpr=ir=class extends we{string;_type=exports.TypeSymbols.StringPr;constructor(t){super(),this.string=t}static fromBytes(t){const[e,r]=exports.Short.fromBytes(t);return[new ir((new TextDecoder).decode(r.slice(0,e.value()))),r.slice(e.value())]}toJSON(){return this.string}toBytes(){return e.concatBytes(ye(ge(this.string.length.toString(16)),2),(new TextEncoder).encode(this.string))}value(){return this.string}},exports.Stringpr=ir=o([t=>{},a("design:paramtypes",[String])],exports.Stringpr);var hr,xr,mr,br,gr,yr,wr,Ir;function Br(t){return t.map((t=>new exports.Address(t)))}exports.Signature=cr=class{sig;_type=exports.TypeSymbols.Signature;constructor(t){if(this.sig=t,65!==t.length)throw new Error("incorrect number of bytes for signature")}toJSON(){return e.bytesToHex(this.sig)}static fromJSON(t){return new cr(le(t))}static fromBytes(t){return[new cr(t.slice(0,65)),t.slice(65)]}[i](t,e){return e.stylize(this.toString(),"string")}toString(){return be(this.sig)}toBytes(){return ye(this.sig,65)}},exports.Signature=cr=o([t=>{},a("design:paramtypes",[Uint8Array])],exports.Signature),exports.Credential=hr=class{signatures;_type=exports.TypeSymbols.Credential;constructor(t){this.signatures=t}static fromBytes(t,e){const[r,s]=ze(t,exports.Signature,e);return[new hr(r),s]}toJSON(){return this.signatures}static fromJSON(t){return new hr(t.map((t=>exports.Signature.fromJSON(t))))}setSignature(t,e){if(t>=this.signatures.length)throw new Error(`index ${t} is out of bounds for credential`);this.signatures[t]=new exports.Signature(e)}getSignatures(){return this.signatures.map((t=>t.toString()))}toBytes(t){return Qe(this.signatures,t)}},exports.Credential=hr=o([t=>{},a("design:paramtypes",[Array])],exports.Credential),exports.Input=xr=class{sigIndices;_type=exports.TypeSymbols.Input;constructor(t){this.sigIndices=t}static fromNative(t){return new xr(t.map((t=>new exports.Int(t))))}static fromBytes(t){const[e,r]=tr(t,[Je(exports.Int)]);return[new xr(e),r]}values(){return this.sigIndices.map((t=>t.value()))}toBytes(t){return Qe(this.sigIndices,t)}},exports.Input=xr=o([t=>{},a("design:paramtypes",[Array])],exports.Input),exports.OutputOwners=mr=class{locktime;threshold;addrs;_type=exports.TypeSymbols.OutputOwners;constructor(t,e,r){this.locktime=t,this.threshold=e,this.addrs=r}static fromNative(t,e=0n,r=1){return new mr(new exports.BigIntPr(e),new exports.Int(r),Br(t))}static fromBytes(t,e){const[r,s,n,o]=tr(t,[exports.BigIntPr,exports.Int,Je(exports.Address)],e);return[new mr(r,s,n),o]}toBytes(t){return e.concatBytes(er([this.locktime,this.threshold],t),Qe(this.addrs,t))}equals(t){return this.locktime.value()===t.locktime.value()&&this.threshold.value()===t.threshold.value()&&this.addrs.length===t.addrs.length&&this.addrs.every(((e,r)=>e.value()===t.addrs[r].value()))}},exports.OutputOwners=mr=o([t=>{},a("design:paramtypes",[exports.BigIntPr,exports.Int,Array])],exports.OutputOwners),exports.MintOutput=br=class{outputOwners;_type=exports.TypeSymbols.SecpMintOutput;constructor(t){this.outputOwners=t}static fromBytes(t,e){let r;return[r,t]=exports.OutputOwners.fromBytes(t,e),[new br(r),t]}toBytes(t){return this.outputOwners.toBytes(t)}},exports.MintOutput=br=o([t=>{},a("design:paramtypes",[exports.OutputOwners])],exports.MintOutput),exports.TransferOutput=gr=class{amt;outputOwners;_type=exports.TypeSymbols.TransferOutput;constructor(t,e){this.amt=t,this.outputOwners=e}amount(){return this.amt.value()}getLocktime(){return this.outputOwners.locktime.value()}getOwners(){return this.outputOwners.addrs.map((t=>t.toBytes()))}getThreshold(){return this.outputOwners.threshold.value()}static fromBytes(t){const[e,r,s]=tr(t,[exports.BigIntPr,exports.OutputOwners]);return[new gr(e,r),s]}toBytes(t){return er([this.amt,this.outputOwners],t)}},exports.TransferOutput=gr=o([t=>{},a("design:paramtypes",[exports.BigIntPr,exports.OutputOwners])],exports.TransferOutput),exports.MintOperation=yr=class{input;mintOutput;transferOutput;_type=exports.TypeSymbols.SecpMintOperation;constructor(t,e,r){this.input=t,this.mintOutput=e,this.transferOutput=r}static fromBytes(t){const[e,r,s,n]=tr(t,[exports.Input,exports.MintOutput,exports.TransferOutput]);return[new yr(e,r,s),n]}toBytes(t){return e.concatBytes(this.input.toBytes(t),this.mintOutput.toBytes(t),this.transferOutput.toBytes(t))}},exports.MintOperation=yr=o([t=>{},a("design:paramtypes",[exports.Input,exports.MintOutput,exports.TransferOutput])],exports.MintOperation),exports.OutputOwnersList=wr=class{outputOwners;_type=exports.TypeSymbols.OutputOwnersList;constructor(t){this.outputOwners=t}static fromBytes(t,e){const[r,s]=ze(t,exports.OutputOwners,e);return[new wr(r),s]}toBytes(t){return Qe(this.outputOwners,t)}},exports.OutputOwnersList=wr=o([t=>{},a("design:paramtypes",[Array])],exports.OutputOwnersList),exports.TransferInput=Ir=class{amt;input;_type=exports.TypeSymbols.TransferInput;constructor(t,e){this.amt=t,this.input=e}static fromBytes(t){const[e,r,s]=tr(t,[exports.BigIntPr,exports.Input]);return[new Ir(e,r),s]}static fromNative(t,e){return new Ir(new exports.BigIntPr(t),exports.Input.fromNative(e))}sigIndicies(){return this.input.values()}amount(){return this.amt.value()}toBytes(t){return er([this.amt,this.input],t)}},exports.TransferInput=Ir=o([t=>{},a("design:paramtypes",[exports.BigIntPr,exports.Input])],exports.TransferInput);const Tr=Object.freeze([exports.TransferInput,exports.MintOutput,exports.TransferOutput,exports.MintOperation,exports.Credential]);var Sr;let Or=Sr=class{txID;outputIdx;_type=exports.TypeSymbols.UTXOID;constructor(t,e){this.txID=t,this.outputIdx=e}static fromBytes(t,e){const[r,s,n]=tr(t,[exports.Id,exports.Int],e);return[new Sr(r,s),n]}static fromNative(t,e){return new Sr(exports.Id.fromString(t),new exports.Int(e))}static compare(t,e){const r=exports.Id.compare(t.txID,e.txID);return 0!==r?r:t.outputIdx.value()-e.outputIdx.value()}toBytes(t){return er([this.txID,this.outputIdx],t)}ID(){return Ee.encode(r.sha256(e.concatBytes(new exports.BigIntPr(BigInt(this.outputIdx.value())).toBytes(),this.txID.toBytes())))}};var vr,Er,Ar;Or=Sr=o([t=>{},a("design:paramtypes",[exports.Id,exports.Int])],Or),exports.TransferableInput=vr=class{utxoID;assetId;input;_type=exports.TypeSymbols.TransferableInput;constructor(t,e,r){this.utxoID=t,this.assetId=e,this.input=r}static fromBytes(t,e){const[r,s,n]=tr(t,[Or,exports.Id]),[o,a]=e.UnpackPrefix(n);return[new vr(r,s,o),a]}static fromNative(t,e,r,s,n){return new vr(Or.fromNative(t,e),exports.Id.fromString(r),new exports.TransferInput(new exports.BigIntPr(s),new exports.Input(n.map((t=>new exports.Int(t))))))}static fromUtxoAndSigindicies(t,e){const r=t.output;if(!ur(r))throw new Error("utxo.output must be Transferout");return new vr(t.utxoId,t.assetId,exports.TransferInput.fromNative(r.amount(),e))}sigIndicies(){const t=this.input;if(lr(t))return t.sigIndicies();if(pr(t)){const e=t.transferableInput;if(lr(e))return e.sigIndicies()}throw new Error("Input must be TransferInput or StakeableLockIn")}static compare(t,e){return Or.compare(t.utxoID,e.utxoID)}amount(){return this.input.amount()}getAssetId(){return this.assetId.toString()}toBytes(t){return e.concatBytes(er([this.utxoID,this.assetId],t),t.PackPrefix(this.input))}},exports.TransferableInput=vr=o([t=>{},a("design:paramtypes",[Or,exports.Id,Object])],exports.TransferableInput),exports.TransferableOutput=Er=class{assetId;output;_type=exports.TypeSymbols.TransferableOutput;constructor(t,e){this.assetId=t,this.output=e}static fromNative(t,e,r,s,n){return new Er(exports.Id.fromString(t),new exports.TransferOutput(new exports.BigIntPr(e),exports.OutputOwners.fromNative(r,s,n)))}static fromBytes(t,e){const[r,s]=tr(t,[exports.Id],e),[n,o]=e.UnpackPrefix(s);return[new Er(r,n),o]}getAssetId(){return this.assetId.toString()}amount(){return this.output.amount()}toBytes(t){return e.concatBytes(er([this.assetId],t),t.PackPrefix(this.output))}},exports.TransferableOutput=Er=o([t=>{},a("design:paramtypes",[exports.Id,Object])],exports.TransferableOutput);let kr=Ar=class{NetworkId;BlockchainId;outputs;inputs;memo;_type=exports.TypeSymbols.BaseTx;constructor(t,e,r,s,n){this.NetworkId=t,this.BlockchainId=e,this.outputs=r,this.inputs=s,this.memo=n}static fromBytes(t,e){const[r,s,n,o,a,i]=tr(t,[exports.Int,exports.Id,Je(exports.TransferableOutput),Je(exports.TransferableInput),exports.Bytes],e);return[new Ar(r,s,n,o,a),i]}static fromNative(t,e,r,s,n){return new Ar(new exports.Int(t),exports.Id.fromString(e),r,s,new exports.Bytes(n))}toBytes(t){return e.concatBytes(er([this.NetworkId,this.BlockchainId],t),Qe(this.outputs,t),Qe(this.inputs,t),this.memo.toBytes())}};kr=Ar=o([t=>{},a("design:paramtypes",[exports.Int,exports.Id,Array,Array,exports.Bytes])],kr);class Pr extends Ke{vm=Ie}var Dr;let Rr=Dr=class extends Pr{baseTx;_type=exports.TypeSymbols.AvmBaseTx;constructor(t){super(),this.baseTx=t}static fromBytes(t,e){const[r,s]=tr(t,[kr],e);return[new Dr(r),s]}toBytes(t){return this.baseTx.toBytes(t)}};Rr=Dr=o([t=>{},a("design:paramtypes",[kr])],Rr);let Nr=class{typeIdToType;_type=exports.TypeSymbols.Codec;typeToTypeID;constructor(t){this.typeIdToType=t,this.typeToTypeID=t.reduce(((t,e,r)=>e?t.set((new e)._type,r):t),new Map)}PackPrefix=t=>{const r=this.typeToTypeID.get(t._type);if(void 0===r)throw new Error(`can't marshal unregistered type: ${t._type.toString()}`);return e.concatBytes($e(r),t.toBytes(this))};UnpackPrefix=t=>{let e;[e,t]=tr(t,[exports.Int]);const r=this.typeIdToType[e.value()];if(void 0===r)throw new Error(`couldn't unmarshal interface: unknown type ID ${e.value()}`);const[s,n]=r.fromBytes(t,this);return[s,n]};static fromBytes(t,e){if(!e)throw new Error("codec required");return e.UnpackPrefix(t)}toBytes(){throw new Error("not implemented")}PackPrefixList(t){return e.concatBytes($e(t.length),...t.map((t=>this.PackPrefix(t))))}};Nr=o([t=>{},a("design:paramtypes",[Array])],Nr);class _r{codecs={};RegisterCodec(t,e){if(t in this.codecs)throw new Error("duplicated codec version");this.codecs[t]=e}unpack=(t,e)=>{const[r,s]=this.getCodecFromBuffer(t);return e.fromBytes(s,r)[0]};unpackTransaction=t=>{const[e,r]=this.getCodecFromBuffer(t);return e.UnpackPrefix(r)[0]};getCodecFromBuffer(t){const[e,r]=tr(t,[exports.Short]);return[this.getCodecForVersion(e),r]}getCodecForVersion(t){if(!this.codecs[t.value()])throw new Error(`codec id(${t.value()}) not found`);return this.codecs[t.value()]}getDefaultCodec(){return this.getCodecForVersion(new exports.Short(0))}getDefaultCodecId(){return new exports.Short(0)}packCodec(t,r=0){const s=new exports.Short(r),n=this.getCodecForVersion(s);return e.concatBytes(s.toBytes(),n.PackPrefix(t))}}class Fr extends exports.Credential{_type=exports.TypeSymbols.NftFxCredential}var Vr;let Ur=Vr=class{input;groupId;payload;outputOwnerList;_type=exports.TypeSymbols.NftFxMintOperation;constructor(t,e,r,s){this.input=t,this.groupId=e,this.payload=r,this.outputOwnerList=s}static fromBytes(t){const[e,r,s,n,o]=tr(t,[exports.Input,exports.Int,exports.Bytes,exports.OutputOwnersList]);return[new Vr(e,r,s,n),o]}toBytes(t){return er([this.input,this.groupId,this.payload,this.outputOwnerList],t)}};var Mr;Ur=Vr=o([t=>{},a("design:paramtypes",[exports.Input,exports.Int,exports.Bytes,exports.OutputOwnersList])],Ur);let Cr=Mr=class{groupId;outputOwners;_type=exports.TypeSymbols.NftFxMintOutput;constructor(t,e){this.groupId=t,this.outputOwners=e}static fromBytes(t,e){const[r,s,n]=tr(t,[exports.Int,exports.OutputOwners],e);return[new Mr(r,s),n]}toBytes(t){return er([this.groupId,this.outputOwners],t)}};var qr;Cr=Mr=o([t=>{},a("design:paramtypes",[exports.Int,exports.OutputOwners])],Cr);let Lr=qr=class{groupId;payload;outputOwners;_type=exports.TypeSymbols.NftFxTransferOutput;constructor(t,e,r){this.groupId=t,this.payload=e,this.outputOwners=r}static fromBytes(t){const[e,r,s,n]=tr(t,[exports.Int,exports.Bytes,exports.OutputOwners]);return[new qr(e,r,s),n]}toBytes(t){return er([this.groupId,this.payload,this.outputOwners],t)}};var jr;Lr=qr=o([t=>{},a("design:paramtypes",[exports.Int,exports.Bytes,exports.OutputOwners])],Lr);let Hr=jr=class{input;output;_type=exports.TypeSymbols.NftFxTransferOperation;constructor(t,e){this.input=t,this.output=e}static fromBytes(t){const[e,r,s]=tr(t,[exports.Input,Lr]);return[new jr(e,r),s]}toBytes(t){return er([this.input,this.output],t)}};Hr=jr=o([t=>{},a("design:paramtypes",[exports.Input,Lr])],Hr);const Zr=Object.freeze([Cr,Lr,Ur,Hr,Fr]);var Xr;let Gr=Xr=class{fxId;outputs;_type=exports.TypeSymbols.InitialState;constructor(t,e){this.fxId=t,this.outputs=e}static fromBytes(t,e){const[r,s,n]=tr(t,[exports.Int,We],e);return[new Xr(r,s),n]}toBytes(t){return e.concatBytes(this.fxId.toBytes(),t.PackPrefixList(this.outputs))}};var Kr;Gr=Xr=o([t=>{},a("design:paramtypes",[exports.Int,Array])],Gr);let $r=Kr=class{baseTx;name;symbol;denomination;initialStates;_type=exports.TypeSymbols.CreateAssetTx;constructor(t,e,r,s,n){this.baseTx=t,this.name=e,this.symbol=r,this.denomination=s,this.initialStates=n}static fromBytes(t,e){const[r,s,n,o,a,i]=tr(t,[kr,exports.Stringpr,exports.Stringpr,exports.Byte,Je(Gr)],e);return[new Kr(r,s,n,o,a),i]}toBytes(t){return e.concatBytes(er([this.baseTx,this.name,this.symbol,this.denomination],t),Qe(this.initialStates,t))}};var zr;$r=Kr=o([t=>{},a("design:paramtypes",[kr,exports.Stringpr,exports.Stringpr,exports.Byte,Array])],$r);let Yr=zr=class extends Pr{baseTx;destination;outs;_type=exports.TypeSymbols.AvmExportTx;constructor(t,e,r){super(),this.baseTx=t,this.destination=e,this.outs=r}static fromBytes(t,e){const[r,s,n,o]=tr(t,[kr,exports.Id,Je(exports.TransferableOutput)],e);return[new zr(r,s,n),o]}toBytes(t){return e.concatBytes(er([this.baseTx,this.destination],t),Qe(this.outs,t))}};var Jr;Yr=zr=o([t=>{},a("design:paramtypes",[kr,exports.Id,Array])],Yr);let Wr=Jr=class extends Pr{baseTx;sourceChain;ins;_type=exports.TypeSymbols.AvmImportTx;constructor(t,e,r){super(),this.baseTx=t,this.sourceChain=e,this.ins=r}getSigIndices(){return this.ins.map((t=>t.sigIndicies())).concat(super.getSigIndices())}static fromBytes(t,e){const[r,s,n,o]=tr(t,[kr,exports.Id,Je(exports.TransferableInput)],e);return[new Jr(r,s,n),o]}toBytes(t){return e.concatBytes(er([this.baseTx,this.sourceChain],t),Qe(this.ins,t))}};var Qr;Wr=Jr=o([t=>{},a("design:paramtypes",[kr,exports.Id,Array])],Wr);let ts=Qr=class{assetId;UTXOId;transferOp;_type=exports.TypeSymbols.TransferableOp;constructor(t,e,r){this.assetId=t,this.UTXOId=e,this.transferOp=r}static fromBytes(t,e){const[r,s,n,o]=tr(t,[exports.Id,Je(Or),Nr],e);return[new Qr(r,s,n),o]}toBytes(t){return e.concatBytes(er([this.assetId],t),Qe(this.UTXOId,t),t.PackPrefix(this.transferOp))}};var es;ts=Qr=o([t=>{},a("design:paramtypes",[exports.Id,Array,Object])],ts);let rs,ss=es=class{baseTx;ops;_type=exports.TypeSymbols.OperationTx;constructor(t,e){this.baseTx=t,this.ops=e}static fromBytes(t,e){const[r,s,n]=tr(t,[kr,Je(ts)],e);return[new es(r,s),n]}toBytes(t){return e.concatBytes(this.baseTx.toBytes(t),Qe(this.ops,t))}};ss=es=o([t=>{},a("design:paramtypes",[kr,Array])],ss);const ns=()=>rs||(rs=new _r,rs.RegisterCodec(0,new Nr([Rr,$r,ss,Wr,Yr,...Tr,...Zr])),rs);class os extends Ge{vm=Be;getBlockchainId=()=>this.blockchainId.toString()}var as;let is=class{static{as=this}address;amount;assetId;nonce;_type=exports.TypeSymbols.EvmInput;constructor(t,e,r,s){this.address=t,this.amount=e,this.assetId=r,this.nonce=s}static fromBytes(t,e){const[r,s,n,o,a]=tr(t,[exports.Address,exports.BigIntPr,exports.Id,exports.BigIntPr],e);return[new as(r,s,n,o),a]}static compare=(t,e)=>t.address.value()!==e.address.value()?t.address.value().localeCompare(e.address.value()):t.assetId.value().localeCompare(e.assetId.value());toBytes(t){return rr(t,this.address,this.amount,this.assetId,this.nonce)}};var cs;is=as=o([t=>{},a("design:paramtypes",[exports.Address,exports.BigIntPr,exports.Id,exports.BigIntPr])],is);let us=cs=class extends os{networkId;blockchainId;destinationChain;ins;exportedOutputs;_type=exports.TypeSymbols.EvmExportTx;constructor(t,e,r,s,n){super(),this.networkId=t,this.blockchainId=e,this.destinationChain=r,this.ins=s,this.exportedOutputs=n}getSigIndices(){return[[0]]}static fromBytes(t,e){const[r,s,n,o,a,i]=tr(t,[exports.Int,exports.Id,exports.Id,Je(is),Je(exports.TransferableOutput)],e);return[new cs(r,s,n,o,a),i]}toBytes(t){return rr(t,this.networkId,this.blockchainId,this.destinationChain,this.ins,this.exportedOutputs)}};var ds;us=cs=o([t=>{},a("design:paramtypes",[exports.Int,exports.Id,exports.Id,Array,Array])],us);let fs=ds=class{address;amount;assetId;_type=exports.TypeSymbols.EvmOutput;constructor(t,e,r){this.address=t,this.amount=e,this.assetId=r}static fromBytes(t,e){const[r,s,n,o]=tr(t,[exports.Address,exports.BigIntPr,exports.Id],e);return[new ds(r,s,n),o]}toBytes(t){return rr(t,this.address,this.amount,this.assetId)}};var ps;fs=ds=o([t=>{},a("design:paramtypes",[exports.Address,exports.BigIntPr,exports.Id])],fs);let ls,hs=ps=class extends os{networkId;blockchainId;sourceChain;importedInputs;Outs;_type=exports.TypeSymbols.EvmImportTx;constructor(t,e,r,s,n){super(),this.networkId=t,this.blockchainId=e,this.sourceChain=r,this.importedInputs=s,this.Outs=n}getSigIndices(){return this.importedInputs.map((t=>t.sigIndicies()))}static fromBytes(t,e){const[r,s,n,o,a,i]=tr(t,[exports.Int,exports.Id,exports.Id,Je(exports.TransferableInput),Je(fs)],e);return[new ps(r,s,n,o,a),i]}toBytes(t){return rr(t,this.networkId,this.blockchainId,this.sourceChain,this.importedInputs,this.Outs)}};hs=ps=o([t=>{},a("design:paramtypes",[exports.Int,exports.Id,exports.Id,Array,Array])],hs);const xs=new Nr([hs,us,...Array(3).fill(void 0),...Tr,exports.Input,exports.OutputOwners]),ms=()=>ls||(ls=new _r,ls.RegisterCodec(0,xs),ls);class bs extends Ke{vm=Te}var gs;let ys=gs=class{nodeId;startTime;endTime;weight;_type=exports.TypeSymbols.Validator;constructor(t,e,r,s){this.nodeId=t,this.startTime=e,this.endTime=r,this.weight=s}static fromNative(t,e,r,s){return new gs(exports.NodeId.fromString(t),new exports.BigIntPr(e),new exports.BigIntPr(r),new exports.BigIntPr(s))}static fromBytes(t,e){const[r,s,n,o,a]=tr(t,[exports.NodeId,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr],e);return[new gs(r,s,n,o),a]}toBytes(t){return er([this.nodeId,this.startTime,this.endTime,this.weight],t)}};var ws;ys=gs=o([t=>{},a("design:paramtypes",[exports.NodeId,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr])],ys);let Is=ws=class extends bs{baseTx;validator;stake;rewardsOwner;_type=exports.TypeSymbols.AddDelegatorTx;constructor(t,e,r,s){super(),this.baseTx=t,this.validator=e,this.stake=r,this.rewardsOwner=s}getRewardsOwner(){return this.rewardsOwner}static fromBytes(t,e){const[r,s,n,o,a]=tr(t,[kr,ys,Je(exports.TransferableOutput),Nr],e);return[new ws(r,s,n,o),a]}toBytes(t){return e.concatBytes(er([this.baseTx,this.validator,this.stake],t),t.PackPrefix(this.rewardsOwner))}};Is=ws=o([t=>{},a("design:paramtypes",[kr,ys,Array,Object])],Is);class Bs extends bs{getSubnetAuth(){return this.subnetAuth}getSigIndices(){return[...this.getInputs().map((t=>t.sigIndicies())),this.getSubnetAuth().values()].filter((t=>void 0!==t))}}var Ts;let Ss=Ts=class{validator;subnetId;_type=exports.TypeSymbols.SubnetValidator;constructor(t,e){this.validator=t,this.subnetId=e}static fromNative(t,e,r,s,n){return new Ts(ys.fromNative(t,e,r,s),n)}static fromBytes(t,e){const[r,s,n]=tr(t,[ys,exports.Id],e);return[new Ts(r,s),n]}toBytes(t){return er([this.validator,this.subnetId],t)}};var Os;Ss=Ts=o([t=>{},a("design:paramtypes",[ys,exports.Id])],Ss);let vs=Os=class extends Bs{baseTx;subnetValidator;subnetAuth;_type=exports.TypeSymbols.AddSubnetValidatorTx;constructor(t,e,r){super(),this.baseTx=t,this.subnetValidator=e,this.subnetAuth=r}getSubnetID(){return this.subnetValidator.subnetId}static fromBytes(t,e){const[r,s,n,o]=tr(t,[kr,Ss,Nr],e);return[new Os(r,s,n),o]}toBytes(t){return e.concatBytes(er([this.baseTx,this.subnetValidator],t),t.PackPrefix(this.subnetAuth))}};var Es;vs=Os=o([t=>{},a("design:paramtypes",[kr,Ss,Object])],vs);let As=Es=class extends bs{baseTx;validator;stake;rewardsOwner;shares;_type=exports.TypeSymbols.AddValidatorTx;constructor(t,e,r,s,n){super(),this.baseTx=t,this.validator=e,this.stake=r,this.rewardsOwner=s,this.shares=n}getRewardsOwner(){return this.rewardsOwner}static fromBytes(t,e){const[r,s,n,o,a,i]=tr(t,[kr,ys,Je(exports.TransferableOutput),Nr,exports.Int],e);return[new Es(r,s,n,o,a),i]}toBytes(t){return e.concatBytes(er([this.baseTx,this.validator],t),Qe(this.stake,t),t.PackPrefix(this.rewardsOwner),this.shares.toBytes())}};var ks;As=Es=o([t=>{},a("design:paramtypes",[kr,ys,Array,Object,exports.Int])],As);let Ps=ks=class extends bs{time;_type=exports.TypeSymbols.AdvanceTimeTx;constructor(t){super(),this.time=t}baseTx=void 0;static fromBytes(t,e){const[r,s]=tr(t,[exports.BigIntPr],e);return[new ks(r),s]}toBytes(t){return rr(t,this.time)}};var Ds;Ps=ks=o([t=>{},a("design:paramtypes",[exports.BigIntPr])],Ps);let Rs=Ds=class extends Bs{baseTx;subnetID;chainName;vmID;fxIds;genesisData;subnetAuth;_type=exports.TypeSymbols.CreateChainTx;constructor(t,e,r,s,n,o,a){super(),this.baseTx=t,this.subnetID=e,this.chainName=r,this.vmID=s,this.fxIds=n,this.genesisData=o,this.subnetAuth=a}getSubnetID(){return this.subnetID}static fromBytes(t,e){const[r,s,n,o,a,i,c,u]=tr(t,[kr,exports.Id,exports.Stringpr,exports.Id,Je(exports.Id),exports.Bytes,Nr],e);return[new Ds(r,s,n,o,a,i,c),u]}toBytes(t){return e.concatBytes(er([this.baseTx,this.subnetID,this.chainName,this.vmID],t),Qe(this.fxIds,t),this.genesisData.toBytes(),t.PackPrefix(this.subnetAuth))}};var Ns;Rs=Ds=o([t=>{},a("design:paramtypes",[kr,exports.Id,exports.Stringpr,exports.Id,Array,exports.Bytes,Object])],Rs);let _s=Ns=class extends bs{baseTx;subnetOwners;_type=exports.TypeSymbols.CreateSubnetTx;constructor(t,e){super(),this.baseTx=t,this.subnetOwners=e}getSubnetOwners(){return this.subnetOwners}static fromBytes(t,e){const[r,s,n]=tr(t,[kr,Nr],e);return[new Ns(r,s),n]}toBytes(t){return e.concatBytes(er([this.baseTx],t),t.PackPrefix(this.subnetOwners))}};var Fs;_s=Ns=o([t=>{},a("design:paramtypes",[kr,Object])],_s);let Vs=Fs=class extends bs{baseTx;destination;outs;_type=exports.TypeSymbols.PvmExportTx;constructor(t,e,r){super(),this.baseTx=t,this.destination=e,this.outs=r}static fromBytes(t,e){const[r,s,n,o]=tr(t,[kr,exports.Id,Je(exports.TransferableOutput)],e);return[new Fs(r,s,n),o]}toBytes(t){return rr(t,this.baseTx,this.destination,this.outs)}};var Us;Vs=Fs=o([t=>{},a("design:paramtypes",[kr,exports.Id,Array])],Vs);let Ms=Us=class extends bs{baseTx;sourceChain;ins;_type=exports.TypeSymbols.PvmImportTx;constructor(t,e,r){super(),this.baseTx=t,this.sourceChain=e,this.ins=r}getSigIndices(){return this.ins.map((t=>t.sigIndicies()))}static fromBytes(t,e){const[r,s,n,o]=tr(t,[kr,exports.Id,Je(exports.TransferableInput)],e);return[new Us(r,s,n),o]}toBytes(t){return er([this.baseTx,this.sourceChain,this.ins],t)}};var Cs;Ms=Us=o([t=>{},a("design:paramtypes",[kr,exports.Id,Array])],Ms);let qs=Cs=class extends bs{txId;_type=exports.TypeSymbols.RewardValidatorTx;constructor(t){super(),this.txId=t}baseTx=void 0;static fromBytes(t,e){const[r,s]=tr(t,[exports.Id],e);return[new Cs(r),s]}toBytes(t){return rr(t,this.txId)}};var Ls;qs=Cs=o([t=>{},a("design:paramtypes",[exports.Id])],qs);let js=Ls=class{lockTime;transferableInput;_type=exports.TypeSymbols.StakeableLockIn;constructor(t,e){this.lockTime=t,this.transferableInput=e}static fromBytes(t,e){const[r,s]=tr(t,[exports.BigIntPr],e),[n,o]=e.UnpackPrefix(s);return[new Ls(r,n),o]}amount(){return this.transferableInput.amount()}toBytes(t){return e.concatBytes(rr(t,this.lockTime),t.PackPrefix(this.transferableInput))}};var Hs;js=Ls=o([t=>{},a("design:paramtypes",[exports.BigIntPr,Object])],js);let Zs=Hs=class{lockTime;transferOut;_type=exports.TypeSymbols.StakeableLockOut;constructor(t,e){this.lockTime=t,this.transferOut=e}amount(){return this.transferOut.amount()}getStakeableLocktime(){return this.lockTime.value()}getLocktime(){return this.lockTime.value()}static fromBytes(t,e){const[r,s,n]=tr(t,[exports.BigIntPr,Nr],e);return[new Hs(r,s),n]}getOwners(){if(ur(this.transferOut))return this.transferOut.getOwners();throw new Error("Unable to get owners.")}getOutputOwners(){if(ur(this.transferOut))return this.transferOut.outputOwners;throw new Error("Unable to get output owners.")}toBytes(t){return e.concatBytes(rr(t,this.lockTime),t.PackPrefix(this.transferOut))}};var Xs;Zs=Hs=o([t=>{},a("design:paramtypes",[exports.BigIntPr,Object])],Zs);let Gs=Xs=class extends bs{baseTx;subnetValidator;signer;stake;validatorRewardsOwner;delegatorRewardsOwner;shares;_type=exports.TypeSymbols.AddPermissionlessValidatorTx;constructor(t,e,r,s,n,o,a){super(),this.baseTx=t,this.subnetValidator=e,this.signer=r,this.stake=s,this.validatorRewardsOwner=n,this.delegatorRewardsOwner=o,this.shares=a}getValidatorRewardsOwner(){return this.validatorRewardsOwner}getDelegatorRewardsOwner(){return this.delegatorRewardsOwner}static fromBytes(t,e){const[r,s,n,o,a,i,c,u]=tr(t,[kr,Ss,Nr,Je(exports.TransferableOutput),Nr,Nr,exports.Int],e);return[new Xs(r,s,n,o,a,i,c),u]}toBytes(t){return e.concatBytes(er([this.baseTx,this.subnetValidator],t),t.PackPrefix(this.signer),Qe(this.stake,t),t.PackPrefix(this.validatorRewardsOwner),t.PackPrefix(this.delegatorRewardsOwner),this.shares.toBytes())}};var Ks;Gs=Xs=o([t=>{},a("design:paramtypes",[kr,Ss,Function,Array,Object,Object,exports.Int])],Gs);let $s=Ks=class extends bs{baseTx;subnetValidator;stake;delegatorRewardsOwner;_type=exports.TypeSymbols.AddPermissionlessDelegatorTx;constructor(t,e,r,s){super(),this.baseTx=t,this.subnetValidator=e,this.stake=r,this.delegatorRewardsOwner=s}getDelegatorRewardsOwner(){return this.delegatorRewardsOwner}static fromBytes(t,e){const[r,s,n,o,a]=tr(t,[kr,Ss,Je(exports.TransferableOutput),Nr],e);return[new Ks(r,s,n,o),a]}toBytes(t){return e.concatBytes(er([this.baseTx,this.subnetValidator],t),Qe(this.stake,t),t.PackPrefix(this.delegatorRewardsOwner))}};function zs(t,e){return Ys(r.sha256(t),e)}async function Ys(t,r){const s=await ce.sign(t,r);if(void 0!==s.recovery)return e.concatBytes(s.toCompactRawBytes(),new Uint8Array([s.recovery]));throw new Error("Recovery bit is missing.")}function Js(t,e){const r=e.slice(-1);return ce.Signature.fromCompact(e.slice(0,-1)).addRecoveryBit(r[0]).recoverPublicKey(t).toRawBytes(!0)}function Ws(t){return ce.getPublicKey(t,!0)}function Qs(t){return s.ripemd160(r.sha256(t))}function tn(t){return ge(he.fromPublicKey(t))}$s=Ks=o([t=>{},a("design:paramtypes",[kr,Ss,Array,Object])],$s);var en=Object.freeze({__proto__:null,getPublicKey:Ws,publicKeyBytesToAddress:Qs,publicKeyToEthAddress:tn,randomPrivateKey:function(){return ce.utils.randomPrivateKey()},recoverPublicKey:Js,sign:zs,signHash:Ys,verify:function(t,e,r){return ce.verify(t.slice(0,-1),e,r)}});const rn=BigInt(2),sn=BigInt(3);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const nn=BigInt(0),on=BigInt(1),an=BigInt(2),cn=BigInt(3),un=BigInt(4),dn=BigInt(8),fn=BigInt(16),pn=BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab"),ln=Et(pn),hn=Et(BigInt("0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001")),xn=({c0:t,c1:e},{c0:r,c1:s})=>({c0:ln.add(t,r),c1:ln.add(e,s)}),mn=({c0:t,c1:e},{c0:r,c1:s})=>({c0:ln.sub(t,r),c1:ln.sub(e,s)}),bn=({c0:t,c1:e},r)=>{if("bigint"==typeof r)return{c0:ln.mul(t,r),c1:ln.mul(e,r)};const{c0:s,c1:n}=r;let o=ln.mul(t,s),a=ln.mul(e,n);return{c0:ln.sub(o,a),c1:ln.sub(ln.mul(ln.add(t,e),ln.add(s,n)),ln.add(o,a))}},gn=({c0:t,c1:e})=>{const r=ln.add(t,e),s=ln.sub(t,e),n=ln.add(t,t);return{c0:ln.mul(r,s),c1:ln.mul(n,e)}},yn=pn*pn,wn={ORDER:yn,BITS:et(yn),BYTES:Math.ceil(et(yn)/8),MASK:st(et(yn)),ZERO:{c0:ln.ZERO,c1:ln.ZERO},ONE:{c0:ln.ONE,c1:ln.ZERO},create:t=>t,isValid:({c0:t,c1:e})=>"bigint"==typeof t&&"bigint"==typeof e,is0:({c0:t,c1:e})=>ln.is0(t)&&ln.is0(e),eql:({c0:t,c1:e},{c0:r,c1:s})=>ln.eql(t,r)&&ln.eql(e,s),neg:({c0:t,c1:e})=>({c0:ln.neg(t),c1:ln.neg(e)}),pow:(t,e)=>St(wn,t,e),invertBatch:t=>Ot(wn,t),add:xn,sub:mn,mul:bn,sqr:gn,addN:xn,subN:mn,mulN:bn,sqrN:gn,div:(t,e)=>wn.mul(t,"bigint"==typeof e?ln.inv(ln.create(e)):wn.inv(e)),inv:({c0:t,c1:e})=>{const r=ln.inv(ln.create(t*t+e*e));return{c0:ln.mul(r,ln.create(t)),c1:ln.mul(r,ln.create(-e))}},sqrt:t=>{if(wn.eql(t,wn.ZERO))return wn.ZERO;const e=wn.pow(t,(wn.ORDER+dn)/fn),r=wn.div(wn.sqr(e),t),s=Tn,n=[s[0],s[2],s[4],s[6]].find((t=>wn.eql(t,r)));if(!n)throw new Error("No root");const o=s.indexOf(n),a=s[o/2];if(!a)throw new Error("Invalid root");const i=wn.div(e,a),c=wn.neg(i),{re:u,im:d}=wn.reim(i),{re:f,im:p}=wn.reim(c);return d>p||d===p&&u>f?i:c},isOdd:t=>{const{re:e,im:r}=wn.reim(t);return BigInt(e%an||e===nn&&r%an)==on},fromBytes(t){if(t.length!==wn.BYTES)throw new Error(`fromBytes wrong length=${t.length}`);return{c0:ln.fromBytes(t.subarray(0,ln.BYTES)),c1:ln.fromBytes(t.subarray(ln.BYTES))}},toBytes:({c0:t,c1:e})=>Q(ln.toBytes(t),ln.toBytes(e)),cmov:({c0:t,c1:e},{c0:r,c1:s},n)=>({c0:ln.cmov(t,r,n),c1:ln.cmov(e,s,n)}),reim:({c0:t,c1:e})=>({re:t,im:e}),mulByNonresidue:({c0:t,c1:e})=>({c0:ln.sub(t,e),c1:ln.add(t,e)}),multiplyByB:({c0:t,c1:e})=>{let r=ln.mul(t,un),s=ln.mul(e,un);return{c0:ln.sub(r,s),c1:ln.add(r,s)}},fromBigTuple:t=>{if(2!==t.length)throw new Error("Invalid tuple");const e=t.map((t=>ln.create(t)));return{c0:e[0],c1:e[1]}},frobeniusMap:({c0:t,c1:e},r)=>({c0:t,c1:ln.mul(e,In[r%2])})},In=[BigInt("0x1"),BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa")].map((t=>ln.create(t))),Bn=BigInt("0x6af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09"),Tn=[[on,nn],[Bn,-Bn],[nn,on],[Bn,Bn],[-on,nn],[-Bn,Bn],[nn,-on],[-Bn,-Bn]].map((t=>wn.fromBigTuple(t))),Sn=({c0:t,c1:e,c2:r},{c0:s,c1:n,c2:o})=>({c0:wn.add(t,s),c1:wn.add(e,n),c2:wn.add(r,o)}),On=({c0:t,c1:e,c2:r},{c0:s,c1:n,c2:o})=>({c0:wn.sub(t,s),c1:wn.sub(e,n),c2:wn.sub(r,o)}),vn=({c0:t,c1:e,c2:r},s)=>{if("bigint"==typeof s)return{c0:wn.mul(t,s),c1:wn.mul(e,s),c2:wn.mul(r,s)};const{c0:n,c1:o,c2:a}=s,i=wn.mul(t,n),c=wn.mul(e,o),u=wn.mul(r,a);return{c0:wn.add(i,wn.mulByNonresidue(wn.sub(wn.mul(wn.add(e,r),wn.add(o,a)),wn.add(c,u)))),c1:wn.add(wn.sub(wn.mul(wn.add(t,e),wn.add(n,o)),wn.add(i,c)),wn.mulByNonresidue(u)),c2:wn.sub(wn.add(c,wn.mul(wn.add(t,r),wn.add(n,a))),wn.add(i,u))}},En=({c0:t,c1:e,c2:r})=>{let s=wn.sqr(t),n=wn.mul(wn.mul(t,e),an),o=wn.mul(wn.mul(e,r),an),a=wn.sqr(r);return{c0:wn.add(wn.mulByNonresidue(o),s),c1:wn.add(wn.mulByNonresidue(a),n),c2:wn.sub(wn.sub(wn.add(wn.add(n,wn.sqr(wn.add(wn.sub(t,e),r))),o),s),a)}},An={ORDER:wn.ORDER,BITS:3*wn.BITS,BYTES:3*wn.BYTES,MASK:st(3*wn.BITS),ZERO:{c0:wn.ZERO,c1:wn.ZERO,c2:wn.ZERO},ONE:{c0:wn.ONE,c1:wn.ZERO,c2:wn.ZERO},create:t=>t,isValid:({c0:t,c1:e,c2:r})=>wn.isValid(t)&&wn.isValid(e)&&wn.isValid(r),is0:({c0:t,c1:e,c2:r})=>wn.is0(t)&&wn.is0(e)&&wn.is0(r),neg:({c0:t,c1:e,c2:r})=>({c0:wn.neg(t),c1:wn.neg(e),c2:wn.neg(r)}),eql:({c0:t,c1:e,c2:r},{c0:s,c1:n,c2:o})=>wn.eql(t,s)&&wn.eql(e,n)&&wn.eql(r,o),sqrt:()=>{throw new Error("Not implemented")},div:(t,e)=>An.mul(t,"bigint"==typeof e?ln.inv(ln.create(e)):An.inv(e)),pow:(t,e)=>St(An,t,e),invertBatch:t=>Ot(An,t),add:Sn,sub:On,mul:vn,sqr:En,addN:Sn,subN:On,mulN:vn,sqrN:En,inv:({c0:t,c1:e,c2:r})=>{let s=wn.sub(wn.sqr(t),wn.mulByNonresidue(wn.mul(r,e))),n=wn.sub(wn.mulByNonresidue(wn.sqr(r)),wn.mul(t,e)),o=wn.sub(wn.sqr(e),wn.mul(t,r)),a=wn.inv(wn.add(wn.mulByNonresidue(wn.add(wn.mul(r,n),wn.mul(e,o))),wn.mul(t,s)));return{c0:wn.mul(a,s),c1:wn.mul(a,n),c2:wn.mul(a,o)}},fromBytes:t=>{if(t.length!==An.BYTES)throw new Error(`fromBytes wrong length=${t.length}`);return{c0:wn.fromBytes(t.subarray(0,wn.BYTES)),c1:wn.fromBytes(t.subarray(wn.BYTES,2*wn.BYTES)),c2:wn.fromBytes(t.subarray(2*wn.BYTES))}},toBytes:({c0:t,c1:e,c2:r})=>Q(wn.toBytes(t),wn.toBytes(e),wn.toBytes(r)),cmov:({c0:t,c1:e,c2:r},{c0:s,c1:n,c2:o},a)=>({c0:wn.cmov(t,s,a),c1:wn.cmov(e,n,a),c2:wn.cmov(r,o,a)}),fromBigSix:t=>{if(!Array.isArray(t)||6!==t.length)throw new Error("Invalid Fp6 usage");return{c0:wn.fromBigTuple(t.slice(0,2)),c1:wn.fromBigTuple(t.slice(2,4)),c2:wn.fromBigTuple(t.slice(4,6))}},frobeniusMap:({c0:t,c1:e,c2:r},s)=>({c0:wn.frobeniusMap(t,s),c1:wn.mul(wn.frobeniusMap(e,s),kn[s%6]),c2:wn.mul(wn.frobeniusMap(r,s),Pn[s%6])}),mulByNonresidue:({c0:t,c1:e,c2:r})=>({c0:wn.mulByNonresidue(r),c1:t,c2:e}),multiplyBy1:({c0:t,c1:e,c2:r},s)=>({c0:wn.mulByNonresidue(wn.mul(r,s)),c1:wn.mul(t,s),c2:wn.mul(e,s)}),multiplyBy01({c0:t,c1:e,c2:r},s,n){let o=wn.mul(t,s),a=wn.mul(e,n);return{c0:wn.add(wn.mulByNonresidue(wn.sub(wn.mul(wn.add(e,r),n),a)),o),c1:wn.sub(wn.sub(wn.mul(wn.add(s,n),wn.add(t,e)),o),a),c2:wn.add(wn.sub(wn.mul(wn.add(t,r),s),o),a)}},multiplyByFp2:({c0:t,c1:e,c2:r},s)=>({c0:wn.mul(t,s),c1:wn.mul(e,s),c2:wn.mul(r,s)})},kn=[[BigInt("0x1"),BigInt("0x0")],[BigInt("0x0"),BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"),BigInt("0x0")],[BigInt("0x0"),BigInt("0x1")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac"),BigInt("0x0")],[BigInt("0x0"),BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe")]].map((t=>wn.fromBigTuple(t))),Pn=[[BigInt("0x1"),BigInt("0x0")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad"),BigInt("0x0")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac"),BigInt("0x0")],[BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa"),BigInt("0x0")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"),BigInt("0x0")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff"),BigInt("0x0")]].map((t=>wn.fromBigTuple(t))),Dn=BigInt("0xd201000000010000"),Rn=et(Dn),Nn=({c0:t,c1:e},{c0:r,c1:s})=>({c0:An.add(t,r),c1:An.add(e,s)}),_n=({c0:t,c1:e},{c0:r,c1:s})=>({c0:An.sub(t,r),c1:An.sub(e,s)}),Fn=({c0:t,c1:e},r)=>{if("bigint"==typeof r)return{c0:An.mul(t,r),c1:An.mul(e,r)};let{c0:s,c1:n}=r,o=An.mul(t,s),a=An.mul(e,n);return{c0:An.add(o,An.mulByNonresidue(a)),c1:An.sub(An.mul(An.add(t,e),An.add(s,n)),An.add(o,a))}},Vn=({c0:t,c1:e})=>{let r=An.mul(t,e);return{c0:An.sub(An.sub(An.mul(An.add(An.mulByNonresidue(e),t),An.add(t,e)),r),An.mulByNonresidue(r)),c1:An.add(r,r)}};function Un(t,e){const r=wn.sqr(t),s=wn.sqr(e);return{first:wn.add(wn.mulByNonresidue(s),r),second:wn.sub(wn.sub(wn.sqr(wn.add(t,e)),r),s)}}const Mn={ORDER:wn.ORDER,BITS:2*wn.BITS,BYTES:2*wn.BYTES,MASK:st(2*wn.BITS),ZERO:{c0:An.ZERO,c1:An.ZERO},ONE:{c0:An.ONE,c1:An.ZERO},create:t=>t,isValid:({c0:t,c1:e})=>An.isValid(t)&&An.isValid(e),is0:({c0:t,c1:e})=>An.is0(t)&&An.is0(e),neg:({c0:t,c1:e})=>({c0:An.neg(t),c1:An.neg(e)}),eql:({c0:t,c1:e},{c0:r,c1:s})=>An.eql(t,r)&&An.eql(e,s),sqrt:()=>{throw new Error("Not implemented")},inv:({c0:t,c1:e})=>{let r=An.inv(An.sub(An.sqr(t),An.mulByNonresidue(An.sqr(e))));return{c0:An.mul(t,r),c1:An.neg(An.mul(e,r))}},div:(t,e)=>Mn.mul(t,"bigint"==typeof e?ln.inv(ln.create(e)):Mn.inv(e)),pow:(t,e)=>St(Mn,t,e),invertBatch:t=>Ot(Mn,t),add:Nn,sub:_n,mul:Fn,sqr:Vn,addN:Nn,subN:_n,mulN:Fn,sqrN:Vn,fromBytes:t=>{if(t.length!==Mn.BYTES)throw new Error(`fromBytes wrong length=${t.length}`);return{c0:An.fromBytes(t.subarray(0,An.BYTES)),c1:An.fromBytes(t.subarray(An.BYTES))}},toBytes:({c0:t,c1:e})=>Q(An.toBytes(t),An.toBytes(e)),cmov:({c0:t,c1:e},{c0:r,c1:s},n)=>({c0:An.cmov(t,r,n),c1:An.cmov(e,s,n)}),fromBigTwelve:t=>({c0:An.fromBigSix(t.slice(0,6)),c1:An.fromBigSix(t.slice(6,12))}),frobeniusMap(t,e){const r=An.frobeniusMap(t.c0,e),{c0:s,c1:n,c2:o}=An.frobeniusMap(t.c1,e),a=Cn[e%12];return{c0:r,c1:An.create({c0:wn.mul(s,a),c1:wn.mul(n,a),c2:wn.mul(o,a)})}},multiplyBy014:({c0:t,c1:e},r,s,n)=>{let o=An.multiplyBy01(t,r,s),a=An.multiplyBy1(e,n);return{c0:An.add(An.mulByNonresidue(a),o),c1:An.sub(An.sub(An.multiplyBy01(An.add(e,t),r,wn.add(s,n)),o),a)}},multiplyByFp2:({c0:t,c1:e},r)=>({c0:An.multiplyByFp2(t,r),c1:An.multiplyByFp2(e,r)}),conjugate:({c0:t,c1:e})=>({c0:t,c1:An.neg(e)}),_cyclotomicSquare:({c0:t,c1:e})=>{const{c0:r,c1:s,c2:n}=t,{c0:o,c1:a,c2:i}=e,{first:c,second:u}=Un(r,a),{first:d,second:f}=Un(o,n),{first:p,second:l}=Un(s,i);let h=wn.mulByNonresidue(l);return{c0:An.create({c0:wn.add(wn.mul(wn.sub(c,r),an),c),c1:wn.add(wn.mul(wn.sub(d,s),an),d),c2:wn.add(wn.mul(wn.sub(p,n),an),p)}),c1:An.create({c0:wn.add(wn.mul(wn.add(h,o),an),h),c1:wn.add(wn.mul(wn.add(u,a),an),u),c2:wn.add(wn.mul(wn.add(f,i),an),f)})}},_cyclotomicExp(t,e){let r=Mn.ONE;for(let s=Rn-1;s>=0;s--)r=Mn._cyclotomicSquare(r),rt(e,s)&&(r=Mn.mul(r,t));return r},finalExponentiate:t=>{const e=Dn,r=Mn.div(Mn.frobeniusMap(t,6),t),s=Mn.mul(Mn.frobeniusMap(r,2),r),n=Mn.conjugate(Mn._cyclotomicExp(s,e)),o=Mn.mul(Mn.conjugate(Mn._cyclotomicSquare(s)),n),a=Mn.conjugate(Mn._cyclotomicExp(o,e)),i=Mn.conjugate(Mn._cyclotomicExp(a,e)),c=Mn.mul(Mn.conjugate(Mn._cyclotomicExp(i,e)),Mn._cyclotomicSquare(n)),u=Mn.conjugate(Mn._cyclotomicExp(c,e)),d=Mn.frobeniusMap(Mn.mul(n,i),2),f=Mn.frobeniusMap(Mn.mul(a,s),3),p=Mn.frobeniusMap(Mn.mul(c,Mn.conjugate(s)),1),l=Mn.mul(Mn.mul(u,Mn.conjugate(o)),s);return Mn.mul(Mn.mul(Mn.mul(d,f),p),l)}},Cn=[[BigInt("0x1"),BigInt("0x0")],[BigInt("0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8"),BigInt("0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff"),BigInt("0x0")],[BigInt("0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2"),BigInt("0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"),BigInt("0x0")],[BigInt("0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995"),BigInt("0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116")],[BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa"),BigInt("0x0")],[BigInt("0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3"),BigInt("0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac"),BigInt("0x0")],[BigInt("0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09"),BigInt("0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad"),BigInt("0x0")],[BigInt("0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116"),BigInt("0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995")]].map((t=>wn.fromBigTuple(t))),qn=Jt(wn,[[["0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6","0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6"],["0x0","0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a"],["0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e","0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d"],["0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1","0x0"]],[["0x0","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63"],["0xc","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f"],["0x1","0x0"]],[["0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706","0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706"],["0x0","0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be"],["0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c","0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f"],["0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10","0x0"]],[["0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb"],["0x0","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3"],["0x12","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99"],["0x1","0x0"]]].map((t=>t.map((t=>wn.fromBigTuple(t.map(BigInt))))))),Ln=Jt(ln,[["0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7","0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb","0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0","0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861","0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9","0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983","0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84","0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e","0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317","0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e","0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b","0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229"],["0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c","0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff","0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19","0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8","0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e","0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5","0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a","0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e","0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641","0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a","0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"],["0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33","0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696","0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6","0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb","0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb","0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0","0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2","0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29","0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587","0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30","0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132","0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e","0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8","0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133","0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b","0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604"],["0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1","0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d","0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2","0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416","0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d","0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac","0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c","0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9","0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a","0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55","0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8","0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092","0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc","0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7","0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f","0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"]].map((t=>t.map((t=>BigInt(t)))))),jn=Zt(wn,{A:wn.create({c0:ln.create(nn),c1:ln.create(BigInt(240))}),B:wn.create({c0:ln.create(BigInt(1012)),c1:ln.create(BigInt(1012))}),Z:wn.create({c0:ln.create(BigInt(-2)),c1:ln.create(BigInt(-1))})}),Hn=Zt(ln,{A:ln.create(BigInt("0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d")),B:ln.create(BigInt("0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0")),Z:ln.create(BigInt(11))}),Zn=An.create({c0:wn.ZERO,c1:wn.ONE,c2:wn.ZERO}),Xn=Mn.create({c0:Zn,c1:An.ZERO}),Gn=Mn.create({c0:An.ZERO,c1:Zn}),[Kn,$n]=Mn.invertBatch([Xn,Gn]);function zn(t,e){const r=e.toAffine(),s=(n=r.x,o=r.y,[Mn.mul(Mn.frobeniusMap(Mn.multiplyByFp2(Kn,n),1),Xn).c0.c0,Mn.mul(Mn.frobeniusMap(Mn.multiplyByFp2($n,o),1),Gn).c0.c0]);var n,o;return new t(s[0],s[1],wn.ONE)}const Yn=BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac");function Jn(t,e){const r=e.toAffine(),s=(n=r.x,o=r.y,[wn.mul(n,Yn),wn.neg(o)]);var n,o;return new t(s[0],s[1],wn.ONE)}const Wn=Object.freeze({DST:"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",encodeDST:"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",p:ln.ORDER,m:2,k:128,expand:"xmd",hash:r.sha256}),Qn=eo(ln.toBytes(nn),{infinity:!0,compressed:!0});function to(t){const e=224&(t=t.slice())[0],r=!!(e>>7&1),s=!!(e>>6&1),n=!!(e>>5&1);return t[0]&=31,{compressed:r,infinity:s,sort:n,value:t}}function eo(t,e){if(224&t[0])throw new Error("setMask: non-empty mask");return e.compressed&&(t[0]|=128),e.infinity&&(t[0]|=64),e.sort&&(t[0]|=32),t}function ro(t){t.assertValidity();const e=t.equals(no.G1.ProjectivePoint.ZERO),{x:r,y:s}=t.toAffine();if(e)return Qn.slice();const n=ln.ORDER,o=Boolean(s*an/n);return eo(Y(r,ln.BYTES),{compressed:!0,sort:o})}function so(t){t.assertValidity();const e=ln.BYTES;if(t.equals(no.G2.ProjectivePoint.ZERO))return Q(Qn,Y(nn,e));const{x:r,y:s}=t.toAffine(),{re:n,im:o}=wn.reim(r),{re:a,im:i}=wn.reim(s),c=Boolean((i>nn?i*an:a*an)/ln.ORDER&on),u=n;return Q(eo(Y(o,e),{sort:c,compressed:!0}),Y(u,e))}const no=function(t){const{Fp:e,Fr:r,Fp2:s,Fp6:n,Fp12:o}=t.fields,a=et(t.params.x);function i(e){const{x:r,y:n}=e,o=r,i=n;let c=o,u=i,d=s.ONE,f=[];for(let e=a-2;e>=0;e--){let r=s.sqr(u),n=s.sqr(d),a=s.multiplyByB(s.mul(n,sn)),p=s.mul(a,sn),l=s.sub(s.sub(s.sqr(s.add(u,d)),n),r);if(f.push([s.sub(a,r),s.mul(s.sqr(c),sn),s.neg(l)]),c=s.div(s.mul(s.mul(s.sub(r,p),c),u),rn),u=s.sub(s.sqr(s.div(s.add(r,p),rn)),s.mul(s.sqr(a),sn)),d=s.mul(r,l),rt(t.params.x,e)){let t=s.sub(u,s.mul(i,d)),e=s.sub(c,s.mul(o,d));f.push([s.sub(s.mul(t,o),s.mul(e,i)),s.neg(t),e]);let r=s.sqr(e),n=s.mul(r,e),a=s.mul(r,c),p=s.add(s.sub(n,s.mul(a,rn)),s.mul(s.sqr(t),d));c=s.mul(e,p),u=s.sub(s.mul(s.sub(a,p),t),s.mul(n,u)),d=s.mul(d,n)}}return f}function c(e,r){const{x:n}=t.params,i=r[0],c=r[1];let u=o.ONE;for(let t=0,r=a-2;r>=0;r--,t++){const a=e[t];if(u=o.multiplyBy014(u,a[0],s.mul(a[1],i),s.mul(a[2],c)),rt(n,r)){t+=1;const r=e[t];u=o.multiplyBy014(u,r[0],s.mul(r[1],i),s.mul(r[2],c))}0!==r&&(u=o.sqr(u))}return o.conjugate(u)}const u={randomPrivateKey:()=>{const e=kt(r.ORDER);return Pt(t.randomBytes(e),r.ORDER)},calcPairingPrecomputes:i},d=jt({n:r.ORDER,...t.G1}),f=Object.assign(d,Wt(d.ProjectivePoint,t.G1.mapToCurve,{...t.htfDefaults,...t.G1.htfDefaults})),p=jt({n:r.ORDER,...t.G2}),l=Object.assign(p,Wt(p.ProjectivePoint,t.G2.mapToCurve,{...t.htfDefaults,...t.G2.htfDefaults})),{ShortSignature:h}=t.G1,{Signature:x}=t.G2;function m(t,e,r=!0){if(t.equals(f.ProjectivePoint.ZERO)||e.equals(l.ProjectivePoint.ZERO))throw new Error("pairing is not available for ZERO point");t.assertValidity(),e.assertValidity();const s=t.toAffine(),n=c(function(t){const e=t;return e._PPRECOMPUTES||(e._PPRECOMPUTES=i(t.toAffine())),e._PPRECOMPUTES}(e),[s.x,s.y]);return r?o.finalExponentiate(n):n}function b(t){return t instanceof f.ProjectivePoint?t:f.ProjectivePoint.fromHex(t)}function g(t,e){return t instanceof f.ProjectivePoint?t:f.hashToCurve(W("point",t),e)}function y(t){return t instanceof l.ProjectivePoint?t:x.fromHex(t)}function w(t,e){return t instanceof l.ProjectivePoint?t:l.hashToCurve(W("point",t),e)}return f.ProjectivePoint.BASE._setWindowSize(4),{getPublicKey:function(t){return f.ProjectivePoint.fromPrivateKey(t).toRawBytes(!0)},getPublicKeyForShortSignatures:function(t){return l.ProjectivePoint.fromPrivateKey(t).toRawBytes(!0)},sign:function(t,e,r){const s=w(t,r);s.assertValidity();const n=s.multiply(f.normPrivateKeyToScalar(e));return t instanceof l.ProjectivePoint?n:x.toRawBytes(n)},signShortSignature:function(t,e,r){const s=g(t,r);s.assertValidity();const n=s.multiply(f.normPrivateKeyToScalar(e));return t instanceof f.ProjectivePoint?n:h.toRawBytes(n)},verify:function(t,e,r,s){const n=b(r),a=w(e,s),i=f.ProjectivePoint.BASE,c=y(t),u=m(n.negate(),a,!1),d=m(i,c,!1),p=o.finalExponentiate(o.mul(d,u));return o.eql(p,o.ONE)},verifyBatch:function(t,e,r,s){if(!e.length)throw new Error("Expected non-empty messages array");if(r.length!==e.length)throw new Error("Pubkey count should equal msg count");const n=y(t),a=e.map((t=>w(t,s))),i=r.map(b);try{const t=[];for(const e of new Set(a)){const r=a.reduce(((t,r,s)=>r===e?t.add(i[s]):t),f.ProjectivePoint.ZERO);t.push(m(r,e,!1))}t.push(m(f.ProjectivePoint.BASE.negate(),n,!1));const e=t.reduce(((t,e)=>o.mul(t,e)),o.ONE),r=o.finalExponentiate(e);return o.eql(r,o.ONE)}catch{return!1}},verifyShortSignature:function(t,e,r,s){const n=y(r),a=g(e,s),i=l.ProjectivePoint.BASE,c=b(t),u=m(a,n,!1),d=m(c,i.negate(),!1),f=o.finalExponentiate(o.mul(d,u));return o.eql(f,o.ONE)},aggregatePublicKeys:function(t){if(!t.length)throw new Error("Expected non-empty array");const e=t.map(b).reduce(((t,e)=>t.add(e)),f.ProjectivePoint.ZERO);return t[0]instanceof f.ProjectivePoint?(e.assertValidity(),e):e.toRawBytes(!0)},aggregateSignatures:function(t){if(!t.length)throw new Error("Expected non-empty array");const e=t.map(y).reduce(((t,e)=>t.add(e)),l.ProjectivePoint.ZERO);return t[0]instanceof l.ProjectivePoint?(e.assertValidity(),e):x.toRawBytes(e)},aggregateShortSignatures:function(t){if(!t.length)throw new Error("Expected non-empty array");const e=t.map(b).reduce(((t,e)=>t.add(e)),f.ProjectivePoint.ZERO);return t[0]instanceof f.ProjectivePoint?(e.assertValidity(),e):h.toRawBytes(e)},millerLoop:c,pairing:m,G1:f,G2:l,Signature:x,ShortSignature:h,fields:{Fr:r,Fp:e,Fp2:s,Fp6:n,Fp12:o},params:{x:t.params.x,r:t.params.r,G1b:t.G1.b,G2b:t.G2.b},utils:u}}({fields:{Fp:ln,Fp2:wn,Fp6:An,Fp12:Mn,Fr:hn},G1:{Fp:ln,h:BigInt("0x396c8c005555e1568c00aaab0000aaab"),Gx:BigInt("0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb"),Gy:BigInt("0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1"),a:ln.ZERO,b:un,htfDefaults:{...Wn,m:1,DST:"BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_"},wrapPrivateKey:!0,allowInfinityPoint:!0,isTorsionFree:(t,e)=>{const r=BigInt("0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"),s=new t(ln.mul(e.px,r),e.py,e.pz);return e.multiplyUnsafe(no.params.x).negate().multiplyUnsafe(no.params.x).equals(s)},clearCofactor:(t,e)=>e.multiplyUnsafe(no.params.x).add(e),mapToCurve:t=>{const{x:e,y:r}=Hn(ln.create(t[0]));return Ln(e,r)},fromBytes:t=>{const{compressed:e,infinity:r,sort:s,value:n}=to(t);if(48===n.length&&e){const t=ln.ORDER,e=$(n),o=ln.create(e&ln.MASK);if(r){if(o!==nn)throw new Error("G1: non-empty compressed point at infinity");return{x:nn,y:nn}}const a=ln.add(ln.pow(o,cn),ln.create(no.params.G1b));let i=ln.sqrt(a);if(!i)throw new Error("Invalid compressed G1 point");return i*an/t!==BigInt(s)&&(i=ln.neg(i)),{x:ln.create(o),y:ln.create(i)}}if(96!==n.length||e)throw new Error("Invalid point G1, expected 48/96 bytes");{const t=$(n.subarray(0,ln.BYTES)),e=$(n.subarray(ln.BYTES));if(r){if(t!==nn||e!==nn)throw new Error("G1: non-empty point at infinity");return no.G1.ProjectivePoint.ZERO.toAffine()}return{x:ln.create(t),y:ln.create(e)}}},toBytes:(t,e,r)=>{const s=e.equals(t.ZERO),{x:n,y:o}=e.toAffine();if(r){if(s)return Qn.slice();const t=ln.ORDER,e=Boolean(o*an/t);return eo(Y(n,ln.BYTES),{compressed:!0,sort:e})}if(s){return Q(new Uint8Array([64]),new Uint8Array(2*ln.BYTES-1))}return Q(Y(n,ln.BYTES),Y(o,ln.BYTES))},ShortSignature:{fromHex(t){const{infinity:e,sort:r,value:s}=to(W("signatureHex",t,48)),n=ln.ORDER,o=$(s);if(e)return no.G1.ProjectivePoint.ZERO;const a=ln.create(o&ln.MASK),i=ln.add(ln.pow(a,cn),ln.create(no.params.G1b));let c=ln.sqrt(i);if(!c)throw new Error("Invalid compressed G1 point");const u=BigInt(r);c*an/n!==u&&(c=ln.neg(c));const d=no.G1.ProjectivePoint.fromAffine({x:a,y:c});return d.assertValidity(),d},toRawBytes:t=>ro(t),toHex:t=>j(ro(t))}},G2:{Fp:wn,h:BigInt("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5"),Gx:wn.fromBigTuple([BigInt("0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"),BigInt("0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e")]),Gy:wn.fromBigTuple([BigInt("0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801"),BigInt("0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be")]),a:wn.ZERO,b:wn.fromBigTuple([un,un]),hEff:BigInt("0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551"),htfDefaults:{...Wn},wrapPrivateKey:!0,allowInfinityPoint:!0,mapToCurve:t=>{const{x:e,y:r}=jn(wn.fromBigTuple(t));return qn(e,r)},isTorsionFree:(t,e)=>e.multiplyUnsafe(no.params.x).negate().equals(zn(t,e)),clearCofactor:(t,e)=>{const r=no.params.x;let s=e.multiplyUnsafe(r).negate(),n=zn(t,e),o=e.double();o=Jn(t,o),o=o.subtract(n),n=s.add(n),n=n.multiplyUnsafe(r).negate(),o=o.add(n),o=o.subtract(s);return o.subtract(e)},fromBytes:t=>{const{compressed:e,infinity:r,sort:s,value:n}=to(t);if(!e&&!r&&s||!e&&r&&s||s&&r&&e)throw new Error("Invalid encoding flag: "+(224&t[0]));const o=ln.BYTES,a=(t,e,r)=>$(t.slice(e,r));if(96===n.length&&e){const t=no.params.G2b,e=ln.ORDER;if(r){if(n.reduce(((t,e)=>0!==t?e+1:e),0)>0)throw new Error("Invalid compressed G2 point");return{x:wn.ZERO,y:wn.ZERO}}const i=a(n,0,o),c=a(n,o,2*o),u=wn.create({c0:ln.create(c),c1:ln.create(i)}),d=wn.add(wn.pow(u,cn),t);let f=wn.sqrt(d);const p=f.c1===nn?f.c0*an/e:f.c1*an/e?on:nn;return f=s&&p>0?f:wn.neg(f),{x:u,y:f}}if(192!==n.length||e)throw new Error("Invalid point G2, expected 96/192 bytes");{if(r){if(n.reduce(((t,e)=>0!==t?e+1:e),0)>0)throw new Error("Invalid uncompressed G2 point");return{x:wn.ZERO,y:wn.ZERO}}const t=a(n,0,o),e=a(n,o,2*o),s=a(n,2*o,3*o),i=a(n,3*o,4*o);return{x:wn.fromBigTuple([e,t]),y:wn.fromBigTuple([i,s])}}},toBytes:(t,e,r)=>{const{BYTES:s,ORDER:n}=ln,o=e.equals(t.ZERO),{x:a,y:i}=e.toAffine();if(r){if(o)return Q(Qn,Y(nn,s));const t=Boolean(i.c1===nn?i.c0*an/n:i.c1*an/n);return Q(eo(Y(a.c1,s),{compressed:!0,sort:t}),Y(a.c0,s))}{if(o)return Q(new Uint8Array([64]),new Uint8Array(4*s-1));const{re:t,im:e}=wn.reim(a),{re:r,im:n}=wn.reim(i);return Q(Y(e,s),Y(t,s),Y(n,s),Y(r,s))}},Signature:{fromHex(t){const{infinity:e,sort:r,value:s}=to(W("signatureHex",t)),n=ln.ORDER,o=t.length/2;if(48!==o&&96!==o)throw new Error("Invalid compressed signature length, must be 96 or 192");const a=$(s.slice(0,o)),i=$(s.slice(o));if(e)return no.G2.ProjectivePoint.ZERO;const c=ln.create(a&ln.MASK),u=ln.create(i),d=wn.create({c0:u,c1:c}),f=wn.add(wn.pow(d,cn),no.params.G2b);let p=wn.sqrt(f);if(!p)throw new Error("Failed to find a square root");const{re:l,im:h}=wn.reim(p),x=BigInt(r);(h>nn&&h*an/n!==x||h===nn&&l*an/n!==x)&&(p=wn.neg(p));const m=no.G2.ProjectivePoint.fromAffine({x:d,y:p});return m.assertValidity(),m},toRawBytes:t=>so(t),toHex:t=>j(so(t))}},params:{x:Dn,r:hn.ORDER},htfDefaults:Wn,hash:r.sha256,randomBytes:e.randomBytes}),oo="BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_",ao="BLS_POP_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_";function io(t){return no.G1.ProjectivePoint.fromHex(t)}function co(t){return t.toRawBytes()}function uo(t){return no.Signature.fromHex(t)}function fo(t,e,r){return no.verify(e,r,t,{DST:ao})}var po,lo=Object.freeze({__proto__:null,PUBLIC_KEY_LENGTH:48,SIGNATURE_LENGTH:96,publicKeyFromBytes:io,publicKeyToBytes:co,secretKeyFromBytes:function(t){return no.G1.normPrivateKeyToScalar(t)},secretKeyToBytes:function(t){return ge(t.toString(16))},sign:function(t,e){return no.sign(t,e,{DST:oo})},signProofOfPossession:function(t,e){return no.sign(t,e,{DST:ao})},signatureFromBytes:uo,signatureToBytes:function(t){return t.toRawBytes()},verify:function(t,e,r){return no.verify(e,r,t,{DST:oo})},verifyProofOfPossession:fo});let ho=po=class{publicKey;signature;_type=exports.TypeSymbols.ProofOfPossession;constructor(t,e){this.publicKey=t,this.signature=e;const r=io(t),s=uo(e);if(r.assertValidity(),s.assertValidity(),!fo(r,s,co(r)))throw new Error("Invalid proof of possession")}static fromBytes(t){const e=t.slice(0,48),r=t.slice(48,144),s=t.slice(144);return[new po(e,r),s]}toString(){return be(this.toBytes())}toBytes(){return e.concatBytes(this.publicKey,this.signature)}};var xo,mo;ho=po=o([t=>{},a("design:paramtypes",[Uint8Array,Uint8Array])],ho);let bo=xo=class{proof;_type=exports.TypeSymbols.Signer;constructor(t){this.proof=t}static fromBytes(t,e){const[r,s]=tr(t,[ho],e);return[new xo(r),s]}toBytes(t){return er([this.proof],t)}};bo=xo=o([t=>{},a("design:paramtypes",[ho])],bo);let go=mo=class{_type=exports.TypeSymbols.SignerEmpty;static fromBytes(t,e){const[r]=tr(t,[],e);return[new mo,r]}toBytes(t){return er([],t)}};var yo;go=mo=o([t=>{}],go);let wo=yo=class extends Bs{baseTx;nodeId;subnetId;subnetAuth;_type=exports.TypeSymbols.RemoveSubnetValidatorTx;constructor(t,e,r,s){super(),this.baseTx=t,this.nodeId=e,this.subnetId=r,this.subnetAuth=s}getSubnetID(){return this.subnetId}static fromBytes(t,e){const[r,s,n,o,a]=tr(t,[kr,exports.NodeId,exports.Id,Nr],e);return[new yo(r,s,n,o),a]}toBytes(t){return e.concatBytes(er([this.baseTx,this.nodeId,this.subnetId],t),t.PackPrefix(this.subnetAuth))}};var Io;wo=yo=o([t=>{},a("design:paramtypes",[kr,exports.NodeId,exports.Id,Object])],wo);let Bo=Io=class extends Bs{baseTx;subnetID;subnetAuth;subnetOwners;_type=exports.TypeSymbols.TransferSubnetOwnershipTx;constructor(t,e,r,s){super(),this.baseTx=t,this.subnetID=e,this.subnetAuth=r,this.subnetOwners=s}getSubnetID(){return this.subnetID}getSubnetOwners(){return this.subnetOwners}static fromBytes(t,e){const[r,s,n,o,a]=tr(t,[kr,exports.Id,Nr,Nr],e);return[new Io(r,s,n,o),a]}toBytes(t){return e.concatBytes(er([this.baseTx,this.subnetID],t),t.PackPrefix(this.subnetAuth),t.PackPrefix(this.subnetOwners))}};var To;Bo=Io=o([t=>{},a("design:paramtypes",[kr,exports.Id,Object,Object])],Bo);let So=To=class extends Bs{baseTx;subnetID;assetId;initialSupply;maximumSupply;minConsumptionRate;maxConsumptionRate;minValidatorStake;maxValidatorStake;minStakeDuration;maxStakeDuration;minDelegationFee;minDelegatorStake;maxValidatorWeightFactor;uptimeRequirement;subnetAuth;_type=exports.TypeSymbols.TransformSubnetTx;constructor(t,e,r,s,n,o,a,i,c,u,d,f,p,l,h,x){super(),this.baseTx=t,this.subnetID=e,this.assetId=r,this.initialSupply=s,this.maximumSupply=n,this.minConsumptionRate=o,this.maxConsumptionRate=a,this.minValidatorStake=i,this.maxValidatorStake=c,this.minStakeDuration=u,this.maxStakeDuration=d,this.minDelegationFee=f,this.minDelegatorStake=p,this.maxValidatorWeightFactor=l,this.uptimeRequirement=h,this.subnetAuth=x}getSubnetID(){return this.subnetID}static fromBytes(t,e){const[r,s,n,o,a,i,c,u,d,f,p,l,h,x,m,b,g]=tr(t,[kr,exports.Id,exports.Id,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr,exports.Int,exports.Int,exports.Int,exports.Int,exports.Byte,exports.Int,Nr],e);return[new To(r,s,n,o,a,i,c,u,d,f,p,l,h,x,m,b),g]}toBytes(t){return e.concatBytes(er([this.baseTx,this.subnetID,this.assetId,this.initialSupply,this.maximumSupply,this.minConsumptionRate,this.maxConsumptionRate,this.minValidatorStake,this.maxValidatorStake,this.minStakeDuration,this.maxStakeDuration,this.minDelegationFee,this.minDelegatorStake,this.maxValidatorWeightFactor,this.uptimeRequirement],t),t.PackPrefix(this.subnetAuth))}};var Oo;So=To=o([t=>{},a("design:paramtypes",[kr,exports.Id,exports.Id,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr,exports.BigIntPr,exports.Int,exports.Int,exports.Int,exports.Int,exports.Byte,exports.Int,Object])],So);let vo=Oo=class extends bs{baseTx;_type=exports.TypeSymbols.PvmBaseTx;constructor(t){super(),this.baseTx=t}static fromBytes(t,e){const[r,s]=tr(t,[kr],e);return[new Oo(r),s]}toBytes(t){return this.baseTx.toBytes(t)}};vo=Oo=o([t=>{},a("design:paramtypes",[kr])],vo);const Eo=new Nr([...new Array(5),...Tr,exports.Input,exports.OutputOwners,As,vs,Is,Rs,_s,Ms,Vs,Ps,qs,js,Zs,wo,So,Gs,$s,go,bo,...new Array(4),Bo,vo]);let Ao;const ko=()=>Ao||(Ao=new _r,Ao.RegisterCodec(0,Eo),Ao);function Po(t){switch(t){case"AVM":return ns();case"EVM":return ms();case"PVM":return ko();default:throw new Error("unknown VM")}}function Do(t){return Po(t.vm).packCodec(t)}var Ro;let No=Ro=class{unsignedTx;credentials;_type=exports.TypeSymbols.AvmSignedTx;constructor(t,e){this.unsignedTx=t,this.credentials=e}static fromBytes(t,e){const[r,s,n]=tr(t,[Nr,Je(Nr)],e);return[new Ro(r,s),n]}getCredentials(){return this.credentials}getAllSignatures(){return this.getCredentials().flatMap((t=>t.getSignatures()))}toBytes(){const t=Po(this.unsignedTx.vm).getCodecForVersion(new exports.Short(0));return e.concatBytes(new exports.Short(0).toBytes(),t.PackPrefix(this.unsignedTx),t.PackPrefixList(this.credentials))}};function _o(t){return t._type===exports.TypeSymbols.TransferableOutput}function Fo(t){return t._type===exports.TypeSymbols.TransferableInput}No=Ro=o([t=>{},a("design:paramtypes",[Function,Array])],No);var Vo=Object.freeze({__proto__:null,AvaxTx:Ke,get BaseTx(){return kr},get SignedTx(){return No},get TransferableInput(){return exports.TransferableInput},get TransferableOutput(){return exports.TransferableOutput},get UTXOID(){return Or},isBaseTx:function(t){return t._type===exports.TypeSymbols.BaseTx},isTransferableInput:Fo,isTransferableOutput:_o});function Uo(t){return t._type===exports.TypeSymbols.AvmBaseTx}function Mo(t){return t._type===exports.TypeSymbols.AvmExportTx}function Co(t){return t._type===exports.TypeSymbols.AvmImportTx}var qo=Object.freeze({__proto__:null,get BaseTx(){return Rr},get CreateAssetTx(){return $r},get ExportTx(){return Yr},get ImportTx(){return Wr},get InitialState(){return Gr},get OperationTx(){return ss},getAVMManager:ns,isAvmBaseTx:Uo,isCreateAssetTx:function(t){return t._type===exports.TypeSymbols.CreateAssetTx},isExportTx:Mo,isImportTx:Co,isOperationTx:function(t){return t._type===exports.TypeSymbols.OperationTx}});function Lo(t){return t._type==exports.TypeSymbols.EvmExportTx}function jo(t){return t._type==exports.TypeSymbols.EvmImportTx}function Ho(t){return jo(t)||Lo(t)}function Zo(t){return!(!Lo(t)&&!jo(t))}var Xo=Object.freeze({__proto__:null,EVMTx:os,get ExportTx(){return us},get ImportTx(){return hs},get Input(){return is},get Output(){return fs},isEvmTx:Ho,isExportTx:Lo,isImportExportTx:Zo,isImportTx:jo});function Go(t){return t._type===exports.TypeSymbols.PvmBaseTx}function Ko(t){return t._type===exports.TypeSymbols.AddDelegatorTx}function $o(t){return t._type===exports.TypeSymbols.AddPermissionlessDelegatorTx}function zo(t){return t._type===exports.TypeSymbols.AddPermissionlessValidatorTx}function Yo(t){return t._type===exports.TypeSymbols.AddSubnetValidatorTx}function Jo(t){return t._type===exports.TypeSymbols.AddValidatorTx}function Wo(t){return t._type===exports.TypeSymbols.CreateChainTx}function Qo(t){return t._type===exports.TypeSymbols.CreateSubnetTx}function ta(t){return t._type===exports.TypeSymbols.RemoveSubnetValidatorTx}function ea(t){return t._type===exports.TypeSymbols.TransferSubnetOwnershipTx}function ra(t){return t._type===exports.TypeSymbols.TransformSubnetTx}function sa(t){return t._type===exports.TypeSymbols.PvmExportTx}function na(t){return t._type===exports.TypeSymbols.PvmImportTx}var oa=Object.freeze({__proto__:null,AbstractSubnetTx:Bs,get AddDelegatorTx(){return Is},get AddPermissionlessDelegatorTx(){return $s},get AddPermissionlessValidatorTx(){return Gs},get AddSubnetValidatorTx(){return vs},get AddValidatorTx(){return As},get AdvanceTimeTx(){return Ps},get BaseTx(){return vo},get CreateChainTx(){return Rs},get CreateSubnetTx(){return _s},get ExportTx(){return Vs},get ImportTx(){return Ms},get ProofOfPossession(){return ho},get RemoveSubnetValidatorTx(){return wo},get Signer(){return bo},get SignerEmpty(){return go},get StakeableLockIn(){return js},get StakeableLockOut(){return Zs},get SubnetValidator(){return Ss},get TransferSubnetOwnershipTx(){return Bo},get TransformSubnetTx(){return So},get Validator(){return ys},isAddDelegatorTx:Ko,isAddPermissionlessDelegatorTx:$o,isAddPermissionlessValidatorTx:zo,isAddSubnetValidatorTx:Yo,isAddValidatorTx:Jo,isAdvanceTimeTx:function(t){return t._type===exports.TypeSymbols.AdvanceTimeTx},isCreateChainTx:Wo,isCreateSubnetTx:Qo,isEmptySigner:function(t){return t._type===exports.TypeSymbols.SignerEmpty},isExportTx:sa,isImportTx:na,isPvmBaseTx:Go,isRemoveSubnetValidatorTx:ta,isRewardValidatorTx:function(t){return t._type===exports.TypeSymbols.RewardValidatorTx},isSigner:function(t){return t._type===exports.TypeSymbols.Signer},isTransferSubnetOwnershipTx:ea,isTransformSubnetTx:ra});const aa=1n,ia=1000n;function ca(t){return ua(t.toBytes().length)+BigInt(t.getSigIndices().flatMap((t=>t)).length)*ia+10000n}function ua(t){return BigInt(t)*aa}class da{utxos;constructor(t){this.utxos=t,this.utxos=function(t){const e=t.map((t=>t.ID()));return t.filter(((t,r)=>e.indexOf(t.ID())==r))}(t)}getUTXOs(){return[...this.utxos]}getAssetDict(){const t={};this.utxos.forEach((e=>{const r=e.assetId.toString(),s=t[r]||[];t[r]=[...s,e]}));const e={};for(const r in t)e[r]=new da(t[r]);return e}getAssetIDs(){const t=this.utxos.map((t=>t.assetId.toString()));return t.filter(((e,r)=>t.indexOf(e)===r))}push(t){return new da([...this.getUTXOs(),t])}getUTXOIDs(){return this.utxos.map((t=>t.ID()))}merge(t){const e=[...this.getUTXOs(),...t.getUTXOs()];return new da(e)}getTransferOuts(){const t=this.utxos.filter((t=>ur(t.output)));return new da(t)}}function fa(t){return e.concatBytes(t,r.sha256(t).subarray(-4))}const pa=(t,e,r,s)=>{if(t.locktime.value()>r)return;const n=new Set(e.map((t=>t.toString()))),o=t.addrs.reduce(((e,r,o)=>e.size()<t.threshold.value()&&n.has(r.value())?s?.length&&!s.includes(o)?e:e.set(r,o):e),new la);return o.size()<t.threshold.value()?void 0:{sigIndicies:Array.from(o.values()),addressMap:o}};class la{constructor(t=[]){t.forEach((([t,e])=>{this.set(t,e)}))}storage=new Map;set(t,e){return this.storage.set(t.toHex(),e),this}toJSON(){return Array.from(this.storage.entries())}static fromJSON(t){return new la(t.map((([t,e])=>[exports.Address.fromHex(t),e])))}get(t){return this.storage.get(t.toHex())}has(t){return this.storage.has(t.toHex())}size(){return this.storage.size}forEach(t){return this.storage.forEach(((e,r)=>t(e,exports.Address.fromHex(r))))}forEachHex(t,e=!1){return e?la.fromJSON([...this.storage.entries()].sort(((t,e)=>t[1]-e[1])).map((([t],e)=>[t,e]))).storage.forEach(t):this.storage.forEach(t)}values(){return this.storage.values()}}class ha{constructor(t=[]){t.length&&this.push(...t)}storage=[];index={};orderedIndex={};push(...t){t.forEach((t=>{t.forEachHex(((t,e)=>{this.index[e]=this.index[e]??[],this.index[e].push([this.storage.length,t])})),t.forEachHex(((t,e)=>{this.orderedIndex[e]=this.orderedIndex[e]??[],this.orderedIndex[e].push([this.storage.length,t])}),!0),this.storage.push(t)}))}static fromTransferableInputs(t,e,r,s){const n=e.reduce(((t,e)=>t.set(e.utxoId.ID(),e)),new Map),o=t.map(((t,e)=>{const o=n.get(t.utxoID.ID());if(!o)throw new Error("input utxo not found");if(s){const n=Br(s),a=pa(o.getOutputOwners(),n,r,t.sigIndicies());if(!a)throw new Error(`input ${e} has no valid owners`);return a.addressMap}const a=t.sigIndicies().map((t=>[o.getOutputOwners().addrs[t],t]));return new la(a)}));return new ha(o)}toJSON(){return this.storage}static fromJSON(t){return new ha(t.map((t=>la.fromJSON(t))))}getAddresses(){return Object.keys(this.index).map((t=>ge(t)))}forEach(t,e=!1){Object.entries(e?this.orderedIndex:this.index).forEach((([e,r])=>{t(r,e)}))}has(t){return t.toHex()in this.index}toArray(){return this.storage}merge(t){t.toArray().forEach((t=>this.push(t)))}getSigIndicesForAddress(t,e=!1){return e?this.orderedIndex[t.toHex()]:this.index[t.toHex()]}}const xa=t=>Zo(t)?Lo(t)?[]:t.importedInputs:[],ma=t=>Ho(t)?xa(t):Co(t)||na(t)?[...t.baseTx.inputs??[],...t.ins??[]]:t.getInputs(),ba=t=>Zo(t)&&Lo(t)?t.exportedOutputs:[],ga=t=>{if(Ho(t))return ba(t);if(Mo(t)||sa(t))return[...t.baseTx?.outputs??[],...t.outs??[]];if(Jo(t)||Ko(t)||zo(t)||$o(t)){const e=[...t.baseTx?.outputs??[],...t.stake??[]];return Jo(t)?e.push(t.getRewardsOwner(),t.getRewardsOwner()):Ko(t)?e.push(t.getRewardsOwner()):zo(t)?e.push(t.getValidatorRewardsOwner(),t.getDelegatorRewardsOwner()):e.push(t.getDelegatorRewardsOwner()),e}return Qo(t)?[...t.baseTx.outputs,t.getSubnetOwners()]:t?.baseTx?.outputs??[]},ya=(t,e)=>{const r=t.get(e.assetId.toString())??0n,s=Fo(e)||_o(e)?e.amount():e.amount.value();return t.set(e.assetId.toString(),r+s),t},wa=t=>{if(Lo(t))return t.ins.reduce(ya,new Map);return ma(t).reduce(ya,new Map)},Ia=t=>{if(jo(t))return t.Outs.reduce(ya,new Map);return ga(t).reduce(((t,e)=>_o(e)?ya(t,e):t),new Map)},Ba=t=>{const e=wa(t),r=Ia(t),s=new Map;for(const[t,n]of e.entries()){const e=r.get(t)??0n;s.set(t,n-e)}return s};var Ta,Sa=Object.freeze({__proto__:null,AddressMap:la,AddressMaps:ha,CCostPerSignature:ia,CFixedFee:1e4,CTxBytesGas:aa,UtxoSet:da,add0x:fe,addChecksum:fa,addressesFromBytes:Br,base58:t.base58,base58check:Ee,bech32ToBytes:d,bufferToBigInt:xe,bufferToHex:be,bufferToNumber:me,bytesCompare:Ae,bytesEqual:(t,e)=>t.length===e.length&&0===Ae(t,e),calcBytesCost:ua,concatBytes:e.concatBytes,costCorethTx:ca,format:function(t,e,r){const s=p(e,r);return`${t}${c}${s}`},formatBech32:p,getBurnedAmountByTx:Ba,getInputAmounts:wa,getManagerForVM:Po,getOutputAmounts:Ia,getTransferableInputsByEvmTx:xa,getTransferableInputsByTx:ma,getTransferableOutputsByEvmTx:ba,getTransferableOutputsByTx:ga,hexToBuffer:ge,isRewardsOwner:fr,isStakeableLockIn:pr,isStakeableLockOut:dr,isTransferInput:lr,isTransferOut:ur,packTx:Do,padLeft:ye,parse:u,parseBech32:f,printDeep:t=>{console.log(n.inspect(t,{depth:null,colors:!0}))},printHex:(t,e="")=>{console.log(`name = ${e}`,be(t))},printJSON:t=>{console.log(JSON.stringify(t,null,2))},strip0x:pe,unpackWithManager:function(t,e){return Po(t).unpackTransaction(e)},validateBurnedAmount:({unsignedTx:t,context:e,burnedAmount:r,evmBaseFee:s,evmFeeTolerance:n})=>{const o=t.getTx(),a=r??((t,e)=>Ba(t).get(e.avaxAssetID)??0n)(o,e),i=t=>({isValid:a===t,txFee:t});if(Zo(o)){if(!s||!n)throw new Error("missing evm fee data");const e=Math.floor(n);if(e<1||e>100)throw new Error("evmFeeTolerance must be [1,100]");const r=s*ca(t),o=r*(100n-BigInt(e))/100n,i=r*(100n+BigInt(e))/100n;return{isValid:a>=o&&a<=i,txFee:a}}if(Jo(o))return i(e.addPrimaryNetworkValidatorFee);if(Ko(o))return i(e.addPrimaryNetworkDelegatorFee);if(Qo(o))return i(e.createSubnetTxFee);if(Wo(o))return i(e.createBlockchainTxFee);if(Yo(o))return i(e.addSubnetValidatorFee);if(ra(o))return i(e.transformSubnetTxFee);if(zo(o)){return i(o.subnetValidator.subnetId.toString()===Re.toString()?e.addPrimaryNetworkValidatorFee:e.addSubnetValidatorFee)}if($o(o)){return i(o.subnetValidator.subnetId.toString()===Re.toString()?e.addPrimaryNetworkDelegatorFee:e.addSubnetDelegatorFee)}if(Uo(o)||Go(o)||Mo(o)||Co(o)||sa(o)||na(o)||ta(o)||ea(o))return i(e.baseTxFee);throw new Error("tx type is not supported")}});exports.Utxo=Ta=class{utxoId;assetId;output;_type=exports.TypeSymbols.UTXO;constructor(t,e,r){this.utxoId=t,this.assetId=e,this.output=r}static fromBytes(t,e){const[r,s,n,o]=tr(t,[Or,exports.Id,Nr],e);return[new Ta(r,s,n),o]}getOutputOwners(){if(ur(this.output))return this.output.outputOwners;if(dr(this.output))return this.output.getOutputOwners();if(fr(this.output))return this.output;throw new Error("unable to get output owner")}toBytes(t){return e.concatBytes(er([this.utxoId,this.assetId],t),t.PackPrefix(this.output))}getAssetId(){return this.assetId.toString()}ID(){return this.utxoId.ID()}},exports.Utxo=Ta=o([t=>{},a("design:paramtypes",[Or,exports.Id,Object])],exports.Utxo);const Oa="https://api.avax.network";class va{url;reqId=0;constructor(t){this.url=t}async callMethod(t,e,r){const s={jsonrpc:"2.0",id:this.reqId++,method:t,params:e},n=await fetch(this.url,{...r,method:"POST",body:JSON.stringify(s),headers:{"Content-Type":"application/json",...r?.headers}}).then((async t=>t.json())).then((t=>t));if(n.error)throw new Error(n.error.message);return n.result}}class Ea{path;base;fetchOptions;rpcProvider;constructor(t=Oa,e,r,s){this.path=e,this.base=r,this.fetchOptions=s,this.rpcProvider=new va(t+e)}setFetchOptions(t){this.fetchOptions=t}getMethodName=t=>this.base?`${this.base}.${t}`:t;callRpc=(t,e)=>this.rpcProvider.callMethod(this.getMethodName(t),e,this.fetchOptions)}class Aa extends Ea{path;base;manager;constructor(t=Oa,e,r,s){super(t,e,r),this.path=e,this.base=r,this.manager=s}async getUTXOs(t){const e=await this.callRpc("getUTXOs",{...t,encoding:"hex"}),r=e.utxos.map((t=>this.manager.unpack(ge(t),exports.Utxo)));return{...e,utxos:r}}issueTx(t){return this.callRpc("issueTx",t)}issueSignedTx(t){return this.issueTx({tx:be(fa(t.toBytes()))})}}class ka extends Aa{getAssetDescription(t){return this.callRpc("getAssetDescription",{assetID:t})}getTx=async t=>{const e=await this.callRpc("getTx",{...t,encoding:"hex"});return this.manager.unpack(ge(e.tx),No)};getTxJson=t=>this.callRpc("getTx",{...t,encoding:"json"});getTxStatus(t){return this.callRpc("getTxStatus",{includeReason:!0,...t})}getBalance(t){return this.callRpc("getBalance",t)}getAddressTxs(t){return this.callRpc("GetAddressTxs",t)}}class Pa extends ka{constructor(t){super(t,"/ext/bc/X","avm",ns())}buildGenesis=async t=>await this.callRpc("buildGenesis",t);getAllBalances(t){return this.callRpc("getAllBalances",t)}}const Da=(t,e,r)=>{const s=Br(e);return t.reduce(((t,e)=>{const{importedInputs:n,inputUTXOs:o,importedAmounts:a}=t,i=e.output;if(!ur(i))return t;const c=pa(i.outputOwners,s,r);return c?(n.push(exports.TransferableInput.fromUtxoAndSigindicies(e,c.sigIndicies)),o.push(e),a[e.getAssetId()]=(a[e.getAssetId()]??0n)+i.amount(),t):t}),{importedInputs:[],inputUTXOs:[],importedAmounts:{}})},Ra=(t,e)=>{const r=exports.Id.compare(t.assetId,e.assetId);if(0!==r)return r;const s=[dr],n=ns().getDefaultCodec(),o=ko().getDefaultCodec(),a=s.some((e=>e(t.output)))?o:n,i=s.some((t=>t(e.output)))?o:n;return Ae(t.toBytes(a),e.toBytes(i))},Na=(t,e)=>t.address.value()===e.address.value()?Ae(t.assetId.toBytes(),e.assetId.toBytes()):t.address.value().localeCompare(e.address.value()),_a=t=>t.reduce(((t,e)=>(t[e.getAssetId()]=t[e.getAssetId()]??0n,t[e.getAssetId()]+=e.amount(),t)),{}),Fa=(t,e)=>({minIssuanceTime:BigInt(Math.floor((new Date).getTime()/1e3)),changeAddresses:t,threshold:1,memo:new Uint8Array,locktime:0n,...e});new exports.OutputOwners(new exports.BigIntPr(0n),new exports.Int(0),[]),new exports.Id(new Uint8Array(32));const Va=new exports.Signature(new Uint8Array(Array(65).fill(0)));class Ua{tx;utxos;addressMaps;credentials;constructor(t,e,r,s){this.tx=t,this.utxos=e,this.addressMaps=r,this.credentials=s||this.tx.getSigIndices().map((t=>new exports.Credential(t.map((()=>Va)))))}toJSON(){const t=Po(this.tx.vm).getDefaultCodec();return{codecId:Po(this.tx.vm).getDefaultCodecId(),vm:this.tx.vm,txBytes:be(this.toBytes()),utxos:this.utxos.map((e=>be(e.toBytes(t)))),addressMaps:this.addressMaps,credentials:this.credentials}}static fromJSON(t){const e=JSON.parse(t),r=["txBytes","utxos","addressMaps","vm","codecId","credentials"];r.forEach((t=>{if(!e[t])throw new Error(`invalid structure. must have ${r.join(", ")}, missing ${t}`)}));const s=e.vm;if(!Se.includes(s))throw new Error("invalid VM");const n=Po(s),[o,a]=n.getCodecFromBuffer(ge(e.txBytes)),i=o.UnpackPrefix(a)[0],c=e.utxos.map((t=>exports.Utxo.fromBytes(ge(t),o)[0])),u=ha.fromJSON(e.addressMaps),d=e.credentials.map((t=>exports.Credential.fromJSON(t)));return new Ua(i,c,u,d)}getSigIndices(){return this.tx.getSigIndices()}hasAddress(t){return this.addressMaps.has(t)}hasPubkey(t){return this.hasAddress(new exports.Address(this.publicKeyBytesToAddress(t)))}getAddresses(){return this.addressMaps.getAddresses()}getSigIndicesForAddress(t){const e=this.getSigIndices().some(((t,e)=>{const r=this.credentials[e].toJSON().length;return Math.max(...t)>r-1}));return this.addressMaps.getSigIndicesForAddress(t,e)}getSigIndicesForPubKey(t){const e=this.publicKeyBytesToAddress(t),r=tn(t),s=this.getSigIndicesForAddress(new exports.Address(e)),n=this.getSigIndicesForAddress(new exports.Address(r));return s||n}getInputUtxos(){return this.utxos}toBytes(){return Do(this.tx)}getBlockchainId(){return this.tx.getBlockchainId()}getTx(){return this.tx}getSignedTx(){return new No(this.tx,this.credentials)}getCredentials(){return this.credentials}addSignatureAt(t,e,r){if(e>=this.getCredentials().length)throw new Error("index out of bounds");this.getCredentials()[e].setSignature(r,t)}addSignature(t){const e=Js(r.sha256(this.toBytes()),t);this.addSignatureForPubKey(t,e)}addSignatureForPubKey(t,e){const r=this.getSigIndicesForPubKey(e);r&&r.forEach((([e,r])=>{this.addSignatureAt(t,e,r)}))}publicKeyBytesToAddress(t){return Qs(t)}hasAllSignatures(){const t=this.credentials.map((t=>t.getSignatures())),e=Va.toString(),s=r.sha256(this.toBytes());if(!t.every((t=>t.every((t=>t!==e)))))return!1;let n=!0;return this.addressMaps.forEach((e=>{e.forEach((([e,r])=>{const o=t[e]?.[r];if(!o)throw new Error("error: incorrect structure for credentials");const a=ge(o),i=Js(s,a);this.hasPubkey(i)||(n=!1)}))}),!0),n}getVM(){return this.tx.getVM()}}const Ma=()=>({inputs:[],inputUTXOs:[],stakeOutputs:[],changeOutputs:[],addressMaps:new ha});function Ca(t=new Map,e=new Map,r,s,n,o){const a={amountsToBurn:t,utxos:r,amountsToStake:e,fromAddresses:s,options:n,...Ma()},i=[...o,function({amountsToBurn:t,...e}){return t.forEach(((t,e)=>{if(0n!==t)throw new Error(`insufficient funds (Burn Amount): need ${t} more units of ${e} to burn`)})),{amountsToBurn:t,...e}},function({amountsToStake:t,...e}){return t.forEach(((t,e)=>{if(0n!==t)throw new Error(`insufficient funds (Stake Amount): need ${t} more units of ${e} to stake`)})),{amountsToStake:t,...e}},function({inputs:t,...e}){return t.sort(exports.TransferableInput.compare),{inputs:t,...e}},function({changeOutputs:t,...e}){return t.sort(Ra),{changeOutputs:t,...e}},function({stakeOutputs:t,...e}){return t.sort(Ra),{stakeOutputs:t,...e}},function({inputs:t,inputUTXOs:e,...r}){return{inputs:t,inputUTXOs:e,...r,addressMaps:ha.fromTransferableInputs(t,e,n.minIssuanceTime,s.map((t=>t.toBytes())))}}].reduce(((t,e)=>e(function(t){return{...t,amountsToBurn:new Map([...t.amountsToBurn]),amountsToStake:new Map([...t.amountsToStake]),inputs:[...t.inputs],inputUTXOs:[...t.inputUTXOs],stakeOutputs:[...t.stakeOutputs],changeOutputs:[...t.changeOutputs]}}(t))),a),{amountsToBurn:c,amountsToStake:u,fromAddresses:d,options:f,utxos:p,...l}=i;return l}const qa=(...t)=>t.reduce(((t,e)=>e<t?e:t)),La=new Error("No addresses match UTXO owners");function ja(t,e,r,s){const n=t.reduce(((t,n)=>{const o=e(n),a=pa(o.outputOwners,r,s.minIssuanceTime);return a?[...t,{sigData:a,data:n}]:t}),[]);if(t.length&&!n.length)throw La;return n}const Ha=({amountsToBurn:t,utxos:e,options:r,changeOutputs:s,inputUTXOs:n,fromAddresses:o,inputs:a,...i})=>{const c=new exports.OutputOwners(new exports.BigIntPr(0n),new exports.Int(r.threshold),Br(r.changeAddresses));return ja(e.filter((e=>!!t.get(e.assetId.toString()))).filter((t=>!!ur(t.output))),(t=>t.output),o,r).forEach((({sigData:e,data:r})=>{const o=r.output,i=t.get(r.assetId.toString())??0n,u=qa(i,o.amt.value());if(!u)return;t.set(r.assetId.toString(),i-u),a.push(exports.TransferableInput.fromUtxoAndSigindicies(r,e.sigIndicies)),n.push(r);const d=o.amt.value()-u;d>0&&s.push(new exports.TransferableOutput(r.assetId,new exports.TransferOutput(new exports.BigIntPr(d),c)))})),{utxos:e,fromAddresses:o,options:r,...i,amountsToBurn:t,inputs:a,changeOutputs:s,inputUTXOs:n}},Za=(t,e,r,s)=>kr.fromNative(t.networkID,t.xBlockchainID,e,r,s),Xa=(t,e,r,s)=>kr.fromNative(t.networkID,t.pBlockchainID,e,r,s);var Ga=Object.freeze({__proto__:null,AvaxApi:ka,Transaction:Ge,UnsignedTx:Ua,baseTxUnsafeAvm:Za,baseTxUnsafePvm:Xa});const Ka=(t,e,r,s,n,o,a,i)=>{e.sort(Ra);const c=_a([...e,...r]),u=_a(s);if(!Object.entries(c).every((([t,e])=>u[t]&&u[t]>=e)))throw new Error("Not enough inputs to cover the outputs");return new Ua(new Yr(Za(t,r,s,o),exports.Id.fromString(n),e),a,i)};var $a=Object.freeze({__proto__:null,AVMApi:Pa,newBaseTx:function(t,e,r,s,n){const o=Br(e),a=Fa(e,n),i=new Map([[t.avaxAssetID,t.baseTxFee]]);s.forEach((t=>{const e=t.assetId.value();i.set(e,(i.get(e)||0n)+t.output.amount())}));const{inputs:c,inputUTXOs:u,changeOutputs:d,addressMaps:f}=Ca(i,void 0,r,o,a,[Ha]),p=[...s,...d];return p.sort(Ra),new Ua(new Rr(Za(t,p,c,a.memo)),u,f)},newExportTx:function(t,e,r,s,n,o){const a=Br(r),i=Fa(r,o),c=new Map([[t.avaxAssetID,t.baseTxFee]]);n.forEach((t=>{const e=t.assetId.value();c.set(e,(c.get(e)||0n)+t.output.amount())}));const{inputs:u,changeOutputs:d,inputUTXOs:f,addressMaps:p}=Ca(c,void 0,s,a,i,[Ha]);return n.sort(Ra),Ka(t,n,d,u,e,i.memo,f,p)},newImportTx:function(t,e,r,s,n,o,a=1,i=0n){const c=Br(n),u=Fa(n,o),{importedAmounts:d,importedInputs:f,inputUTXOs:p}=Da(r,n,u.minIssuanceTime);if(!f.length)throw new Error("no UTXOs available to import");f.sort(exports.TransferableInput.compare);const l=ha.fromTransferableInputs(f,r,u.minIssuanceTime,n),h=d[t.avaxAssetID]??0n;let x={inputs:[],inputUTXOs:[],stakeOutputs:[],changeOutputs:[],addressMaps:new ha};const m=t.baseTxFee,b=t.avaxAssetID;if(h>m)d[b]-=m;else{if(h<m){const t=new Map([[b,m-h]]);x=Ca(t,void 0,r,c,u,[Ha])}delete d[b]}return p.push(...x.inputUTXOs||[]),l.merge(x.addressMaps||new ha),Object.entries(d).forEach((([t,e])=>{x.changeOutputs.push(exports.TransferableOutput.fromNative(t,e,s,i,a))})),new Ua(new Wr(kr.fromNative(t.networkID,t.xBlockchainID,x.changeOutputs||[],x.inputs||[],u.memo),exports.Id.fromString(e),f),p,l)}});class za extends Ua{hasPubkey(t){const e=new exports.Address(this.publicKeyBytesToAddress(t)),r=new exports.Address(tn(t));return this.hasAddress(e)||this.hasAddress(r)}static fromJSON(t){const e=Ua.fromJSON(t);return new za(e.tx,e.utxos,e.addressMaps,e.credentials)}}class Ya extends Ea{baseURL;constructor(t=Oa){super(t,"/ext/info","info"),this.baseURL=t}getNodeVersion(){return this.callRpc("getNodeVersion")}async getNodeId(){return this.callRpc("getNodeID")}getNodeIp(){return this.callRpc("getNodeIP")}getNetworkId(){return this.callRpc("getNetworkID")}getNetworkName(){return this.callRpc("getNetworkName")}getBlockchainId(t){return this.callRpc("getBlockchainID",{alias:t})}peers(t){return this.callRpc("peers",{nodeIDs:t})}isBootstrapped(t){return this.callRpc("peers",{chain:t})}async getTxFee(){const t=await this.callRpc("getTxFee");return{txFee:BigInt(t.txFee),createAssetTxFee:BigInt(t.createAssetTxFee),createSubnetTxFee:BigInt(t.createSubnetTxFee),transformSubnetTxFee:BigInt(t.transformSubnetTxFee),createBlockchainTxFee:BigInt(t.createBlockchainTxFee),addPrimaryNetworkValidatorFee:BigInt(t.addPrimaryNetworkValidatorFee),addPrimaryNetworkDelegatorFee:BigInt(t.addPrimaryNetworkDelegatorFee),addSubnetValidatorFee:BigInt(t.addSubnetValidatorFee),addSubnetDelegatorFee:BigInt(t.addSubnetDelegatorFee)}}uptime(){return this.callRpc("uptime")}getVMs(){return this.callRpc("getVMs")}}var Ja=Object.freeze({__proto__:null,getContextFromURI:async(t,e="AVAX")=>{const r=new Pa(t),{assetID:s}=await r.getAssetDescription(e),n=new Ya(t),{txFee:o,createAssetTxFee:a,createSubnetTxFee:i,transformSubnetTxFee:c,createBlockchainTxFee:u,addPrimaryNetworkValidatorFee:d,addPrimaryNetworkDelegatorFee:f,addSubnetValidatorFee:p,addSubnetDelegatorFee:l}=await n.getTxFee(),{blockchainID:h}=await n.getBlockchainId("X"),{blockchainID:x}=await n.getBlockchainId("P"),{blockchainID:m}=await n.getBlockchainId("C"),{networkID:b}=await n.getNetworkId();return Object.freeze({xBlockchainID:h,pBlockchainID:x,cBlockchainID:m,avaxAssetID:s,baseTxFee:o,createAssetTxFee:a,createSubnetTxFee:i,transformSubnetTxFee:c,createBlockchainTxFee:u,addPrimaryNetworkValidatorFee:d,addPrimaryNetworkDelegatorFee:f,addSubnetValidatorFee:p,addSubnetDelegatorFee:l,networkID:b,hrp:He(b)})}});class Wa extends Ea{constructor(t){super(t,"/ext/bc/C/rpc")}async getBaseFee(){return BigInt(await this.callRpc("eth_baseFee"))}}const Qa=t=>({locktime:0n,threshold:1,...t});function ti(t,e,r,s,n,o,a,i,c){return e*ca(ei(t,r,s,n,o,e,a,i,c))}function ei(t,e,r,s,n,o,a,i,c){i=i??t.avaxAssetID;const{threshold:u,locktime:d}=Qa(c),f=[];t.avaxAssetID===i?f.push({assetId:t.avaxAssetID,amount:e+o}):(f.push({amount:o,assetId:t.avaxAssetID}),f.push({amount:e,assetId:i}));const p=f.map((({assetId:t,amount:e})=>new is(new exports.Address(s),new exports.BigIntPr(e),exports.Id.fromString(t),new exports.BigIntPr(a)))),l=[new exports.TransferableOutput(exports.Id.fromString(i),new exports.TransferOutput(new exports.BigIntPr(e),new exports.OutputOwners(new exports.BigIntPr(d),new exports.Int(u),Br(n))))];return p.sort(is.compare),new za(new us(new exports.Int(t.networkID),exports.Id.fromString(t.cBlockchainID),exports.Id.fromString(r),p,l),[],new ha([new la([[new exports.Address(s),0]])]))}function ri(t,e,r,s,n,o=0n,a=t.avaxAssetID){const i=Br(r),c=new Map;let u=[],d=[],f=0n;const p=[];s.forEach((t=>{const e=t.getAssetId(),r=t.output,s=r.amount();let n=s;a&&o&&f<o&&a===e&&(f+=n,f>o?(n=f-o,f=o):n=0n);const d=pa(r.outputOwners,i,0n);if(!d)return;const l=new exports.TransferableInput(t.utxoId,t.assetId,exports.TransferInput.fromNative(s,d.sigIndicies));u.push(l),p.push(t);const h=c.get(e);h&&(n+=h),c.set(e,n)}));for(const[t,r]of c.entries())d.push(new fs(new exports.Address(e),new exports.BigIntPr(r),exports.Id.fromString(t)));u=u.sort(exports.TransferableInput.compare);const l=ha.fromTransferableInputs(u,s,0n,r);d=d.sort(Na);const h=new hs(new exports.Int(t.networkID),exports.Id.fromString(t.cBlockchainID),exports.Id.fromString(n),u,d);return new za(h,p,l)}var si=Object.freeze({__proto__:null,EVMApi:class extends Aa{ethAPI;constructor(t){super(t,"/ext/bc/C/avax","avax",ms()),this.ethAPI=new Wa(t)}getAtomicTx=async t=>{const e=await this.callRpc("getAtomicTx",{...t,encoding:"hex"});return this.manager.unpack(ge(e.tx),No)};getBaseFee(){return this.ethAPI.getBaseFee()}getAtomicTxStatus(t){return this.callRpc("getAtomicTxStatus",{txID:t})}},estimateExportCost:ti,newExportTx:ei,newExportTxFromBaseFee:function(t,e,r,s,n,o,a,i,c){return ei(t,r,s,n,o,ti(t,e,r,s,n,o,a,i,c),a,i,c)},newImportTx:ri,newImportTxFromBaseFee:function(t,e,r,s,n,o=0n,a){const i=function(t,e,r,s,n,o=0n,a){const i=ri(t,e,r,s,n,o,a),c=ca(i);return o*c}(t,e,r,s,n,o,a);return ri(t,e,r,s,n,i,a)}});function ni(t,e,r,s){return new exports.TransferableOutput(t.assetId,new Zs(e.lockTime,new exports.TransferOutput(new exports.BigIntPr(s),r.outputOwners)))}function oi({amountsToBurn:t,utxos:e,fromAddresses:r,amountsToStake:s,options:n,changeOutputs:o,inputUTXOs:a,inputs:i,stakeOutputs:c,...u}){return ja(e.filter((t=>{const e=t.output;return!!dr(e)&&n.minIssuanceTime<e.getLocktime()})).map((t=>{const e=t.assetId.value();return{utxo:t,assetId:e,remainingAmountToStake:s.get(e)??0n,lockedOutput:t.output}})).filter((({remainingAmountToStake:t})=>!!t)).filter((({lockedOutput:t})=>{if(!(t.transferOut instanceof exports.TransferOutput))throw new Error("unknown output type");return n.minIssuanceTime<t.lockTime.value()})),(({lockedOutput:t})=>t.transferOut),r,n).forEach((({sigData:t,data:{utxo:e,assetId:r,lockedOutput:n}})=>{const u=n.transferOut,d=s.get(r)??0n;if(!d)return;i.push(function(t,e,r,s){return new exports.TransferableInput(t.utxoId,t.assetId,new js(e.lockTime,exports.TransferInput.fromNative(r.amount(),s.sigIndicies)))}(e,n,u,t)),a.push(e);const f=qa(d,u.amt.value());c.push(ni(e,n,u,f)),s.set(r,d-f);const p=u.amount()-f;p>0n&&o.push(ni(e,n,u,p))})),{...u,amountsToBurn:t,utxos:e,fromAddresses:r,amountsToStake:s,options:n,changeOutputs:o,inputUTXOs:a,inputs:i,stakeOutputs:c}}function ai({amountsToBurn:t,utxos:e,fromAddresses:r,amountsToStake:s,options:n,changeOutputs:o,inputUTXOs:a,inputs:i,stakeOutputs:c,...u}){const d=new exports.OutputOwners(new exports.BigIntPr(0n),new exports.Int(1),Br(n.changeAddresses));return ja(e.filter((t=>{if(ur(t.output))return!0;const e=t.output;return!(!dr(e)||!ur(e.transferOut))&&e.getLocktime()<n.minIssuanceTime})),(t=>ur(t.output)?t.output:t.output.transferOut),r,n).forEach((({sigData:e,data:r})=>{const n=t.get(r.assetId.value())??0n,u=s.get(r.assetId.value())??0n;if(!n&&!u)return;const f=ur(r.output)?r.output:r.output.transferOut;i.push(new exports.TransferableInput(r.utxoId,r.assetId,exports.TransferInput.fromNative(f.amount(),e.sigIndicies))),a.push(r);const p=qa(n,f.amt.value());t.set(r.assetId.value(),n-p);const l=f.amount()-p,h=qa(u,l);s.set(r.assetId.value(),(s.get(r.assetId.value())??0n)-h),h>0n&&c.push(new exports.TransferableOutput(r.assetId,new exports.TransferOutput(new exports.BigIntPr(h),d)));const x=l-h;x>0&&o.push(new exports.TransferableOutput(r.assetId,new exports.TransferOutput(new exports.BigIntPr(x),d)))})),{...u,amountsToBurn:t,utxos:e,fromAddresses:r,amountsToStake:s,options:n,changeOutputs:o,inputUTXOs:a,inputs:i,stakeOutputs:c}}const ii=(t,e)=>t.getAssetId()===e.getAssetId()&&(dr(t.output)&&dr(e.output)&&t.output.getStakeableLocktime()===e.output.getStakeableLocktime()&&t.output.getOutputOwners().equals(e.output.getOutputOwners())||ur(t.output)&&ur(e.output)&&t.output.outputOwners.equals(e.output.outputOwners)),ci=(t,e)=>{if(dr(t.output)&&dr(e.output))return new exports.TransferableOutput(t.assetId,new Zs(t.output.lockTime,new exports.TransferOutput(new exports.BigIntPr(t.amount()+e.amount()),t.output.getOutputOwners())));if(ur(t.output)&&ur(e.output))return new exports.TransferableOutput(t.assetId,new exports.TransferOutput(new exports.BigIntPr(t.amount()+e.amount()),t.output.outputOwners));throw new Error("Calling combine on incompatible TransferableOutputs")},ui=t=>((t,e,r)=>{const s=[];for(const n of t){let t=!1;for(let o=0;o<s.length;o++){const a=s[o];if(e(a,n)){s[o]=r(a,n),t=!0;break}}t||s.push(n)}return s})(t,ii,ci);function di({changeOutputs:t,stakeOutputs:e,...r}){return{...r,changeOutputs:ui(t),stakeOutputs:ui(e)}}var fi=Object.freeze({__proto__:null,PVMApi:class extends ka{constructor(t){super(t,"/ext/bc/P","platform",ko())}getAssetDescription(t){return this.callRpc("getAssetDescription",{assetID:t})}getCurrentValidators(t){return this.callRpc("getCurrentValidators",t)}getPendingValidators(t){return this.callRpc("getPendingValidators",t)}async getRewardUTXOs(t){const e=await this.callRpc("getRewardUTXOs",t);return{...e,utxos:e.utxos.map((t=>ko().unpack(ge(t),exports.Utxo)))}}async getStake(t){const e=await this.callRpc("getStake",t);return{...e,stakedOutputs:e.stakedOutputs.map((t=>ko().unpack(ge(t),exports.TransferableOutput)))}}getValidatorsAt(t){return this.callRpc("getValidatorsAt",t)}getCurrentSupply(){return this.callRpc("getCurrentSupply")}getMaxStakeAmount(t){return this.callRpc("getMaxStakeAmount",t)}async getBalance(t){const e=await this.callRpc("getBalance",t);return{balance:BigInt(e.balance),unlocked:BigInt(e.unlocked),lockedStakeable:BigInt(e.lockedStakeable),lockedNotStakeable:BigInt(e.lockedNotStakeable),utxoIDs:e.utxoIDs}}getBlockchains(){return this.callRpc("getBlockchains")}getBlockchainStatus(t){return this.callRpc("getBlockchainStatus",{blockchainID:t})}getHeight(){return this.callRpc("getHeight")}getMinStake(){return this.callRpc("getMinStake")}getStakingAssetID(t){return this.callRpc("getStakingAssetID",t)}getSubnets(t){return this.callRpc("getSubnets",t)}getTimestamp(){return this.callRpc("getTimestamp")}getTotalStake(t){return this.callRpc("getTotalStake",{subnetID:t})}getTxStatus(t){return this.callRpc("getTxStatus",t)}sampleValidators(t){return this.callRpc("sampleValidators",t)}validatedBy(t){return this.callRpc("validatedBy",t)}validates(t){return this.callRpc("validates",t)}},newAddDelegatorTx:function(t,e,r,s,n,o,a,i,c,u=1,d=0n){const f=new Map([[t.avaxAssetID,t.addPrimaryNetworkDelegatorFee]]),p=new Map([[t.avaxAssetID,a]]),l=Fa(r,c),{inputs:h,addressMaps:x,changeOutputs:m,inputUTXOs:b,stakeOutputs:g}=Ca(f,p,e,Br(r),l,[oi,ai,di]),y=new Is(kr.fromNative(t.networkID,t.pBlockchainID,m,h,l.memo),ys.fromNative(s,n,o,a),g,exports.OutputOwners.fromNative(i,d,u));return new Ua(y,b,x)},newAddPermissionlessDelegatorTx:function(t,e,r,s,n,o,a,i,c,u,d=1,f=0n,p){const l=n===Re.toString(),h=l?t.addPrimaryNetworkDelegatorFee:t.addSubnetDelegatorFee,x=p??t.avaxAssetID;if(l&&x!==t.avaxAssetID)throw new Error("Staking asset ID must be AVAX for the primary network.");const m=new Map([[t.avaxAssetID,h]]),b=new Map([[x,i]]),g=Fa(r,u),{addressMaps:y,changeOutputs:w,inputUTXOs:I,inputs:B,stakeOutputs:T}=Ca(m,b,e,Br(r),g,[oi,ai,di]),S=new $s(kr.fromNative(t.networkID,t.pBlockchainID,w,B,g.memo),Ss.fromNative(s,o,a,i,exports.Id.fromString(n)),T,exports.OutputOwners.fromNative(c,f,d));return new Ua(S,I,y)},newAddPermissionlessValidatorTx:function(t,e,r,s,n,o,a,i,c,u,d,f,p=1,l=0n,h,x,m){const b=n===Re.toString(),g=b?t.addPrimaryNetworkValidatorFee:t.addSubnetValidatorFee,y=new Map([[t.avaxAssetID,g]]),w=m??t.avaxAssetID;if(b&&w!==t.avaxAssetID)throw new Error("Staking asset ID must be AVAX for the primary network.");const I=new Map([[w,i]]),B=Fa(r,f),{addressMaps:T,changeOutputs:S,inputUTXOs:O,inputs:v,stakeOutputs:E}=Ca(y,I,e,Br(r),B,[oi,ai,di]),A=new Gs(kr.fromNative(t.networkID,t.pBlockchainID,S,v,B.memo),Ss.fromNative(s,o,a,i,exports.Id.fromString(n)),function(t,e){return t&&e?new bo(new ho(new Uint8Array(t),new Uint8Array(e))):new go}(h,x),E,exports.OutputOwners.fromNative(c,l,p),exports.OutputOwners.fromNative(u,0n),new exports.Int(d));return new Ua(A,O,T)},newAddSubnetValidatorTx:function(t,e,r,s,n,o,a,i,c,u){const d=Fa(r,u),{inputs:f,addressMaps:p,changeOutputs:l,inputUTXOs:h}=Ca(new Map([[t.avaxAssetID,t.addSubnetValidatorFee]]),void 0,e,Br(r),d,[ai]),x=new vs(kr.fromNative(t.networkID,t.pBlockchainID,l,f,d.memo),Ss.fromNative(s,n,o,a,exports.Id.fromString(i)),exports.Input.fromNative(c));return new Ua(x,h,p)},newAddValidatorTx:function(t,e,r,s,n,o,a,i,c,u,d=1,f=0n){const p=new Map([[t.avaxAssetID,t.addPrimaryNetworkValidatorFee]]),l=new Map([[t.avaxAssetID,a]]),h=Fa(r,u),{addressMaps:x,changeOutputs:m,inputUTXOs:b,inputs:g,stakeOutputs:y}=Ca(p,l,e,Br(r),h,[oi,ai,di]),w=new As(kr.fromNative(t.networkID,t.pBlockchainID,m,g,h.memo),ys.fromNative(s,n,o,a),y,exports.OutputOwners.fromNative(i,f,d),new exports.Int(c));return new Ua(w,b,x)},newBaseTx:function(t,e,r,s,n){const o=Br(e),a=Fa(e,n),i=new Map([[t.avaxAssetID,t.baseTxFee]]);s.forEach((t=>{const e=t.assetId.value();i.set(e,(i.get(e)||0n)+t.output.amount())}));const{inputs:c,inputUTXOs:u,changeOutputs:d,addressMaps:f}=Ca(i,void 0,r,o,a,[ai,di]),p=[...s,...d];return p.sort(Ra),new Ua(new vo(Xa(t,p,c,a.memo)),u,f)},newCreateBlockchainTx:function(t,e,r,s,n,o,a,i,c,u){const d=Fa(r,u),{inputs:f,addressMaps:p,changeOutputs:l,inputUTXOs:h}=Ca(new Map([[t.avaxAssetID,t.createBlockchainTxFee]]),void 0,e,Br(r),d,[ai]),x=new Rs(kr.fromNative(t.networkID,t.pBlockchainID,l,f,d.memo),exports.Id.fromString(s),new exports.Stringpr(n),exports.Id.fromString(o),a.map(exports.Id.fromString.bind(exports.Id)),new exports.Bytes((new TextEncoder).encode(JSON.stringify(i))),exports.Input.fromNative(c));return new Ua(x,h,p)},newCreateSubnetTx:function(t,e,r,s,n,o=1,a=0n){const i=Fa(r,n),{inputs:c,addressMaps:u,changeOutputs:d,inputUTXOs:f}=Ca(new Map([[t.avaxAssetID,t.createSubnetTxFee]]),void 0,e,Br(r),i,[ai]),p=new _s(kr.fromNative(t.networkID,t.pBlockchainID,d,c,i.memo),exports.OutputOwners.fromNative(s,a,o));return new Ua(p,f,u)},newExportTx:function(t,e,r,s,n,o){const a=Br(r),i=Fa(r,o),c=((t,e,r)=>{const s=new Map([[t.avaxAssetID,r]]);return e.forEach((t=>{const e=t.assetId.value();s.set(e,(s.get(e)||0n)+t.output.amount())})),s})(t,n,t.baseTxFee),{inputs:u,changeOutputs:d,addressMaps:f,inputUTXOs:p}=Ca(c,void 0,s,a,i,[ai]);return n.sort(Ra),new Ua(new Vs(new kr(new exports.Int(t.networkID),Ne,d,u,new exports.Bytes(i.memo)),exports.Id.fromString(e),n),p,f)},newImportTx:function(t,e,r,s,n,o,a=1,i=0n){const c=Br(n),u=Fa(n,o);r=r.filter((e=>e.assetId.toString()===t.avaxAssetID));const{importedAmounts:d,importedInputs:f,inputUTXOs:p}=Da(r,n,u.minIssuanceTime),l=d[t.avaxAssetID]??0n;f.sort(exports.TransferableInput.compare);const h=ha.fromTransferableInputs(f,r,u.minIssuanceTime,n);if(!f.length)throw new Error("no UTXOs available to import");let x=[],m=[];if(l<t.baseTxFee){const e=Ca(new Map([[t.avaxAssetID,t.baseTxFee-l]]),void 0,r,c,u,[ai]);x=e.inputs,m=e.changeOutputs}else l>t.baseTxFee&&m.push(exports.TransferableOutput.fromNative(t.avaxAssetID,l-t.baseTxFee,s,i,a));return new Ua(new Ms(new kr(new exports.Int(t.networkID),Ne,m,x,new exports.Bytes(u.memo)),exports.Id.fromString(e),f),p,h)},newRemoveSubnetValidatorTx:function(t,e,r,s,n,o,a){const i=Fa(r,a),{inputs:c,addressMaps:u,changeOutputs:d,inputUTXOs:f}=Ca(new Map([[t.avaxAssetID,t.baseTxFee]]),void 0,e,Br(r),i,[ai]),p=new wo(kr.fromNative(t.networkID,t.pBlockchainID,d,c,i.memo),exports.NodeId.fromString(s),exports.Id.fromString(n),exports.Input.fromNative(o));return new Ua(p,f,u)},newTransferSubnetOwnershipTx:function(t,e,r,s,n,o,a,i=1,c=0n){const u=Fa(r,a),{inputs:d,addressMaps:f,changeOutputs:p,inputUTXOs:l}=Ca(new Map([[t.avaxAssetID,t.baseTxFee]]),void 0,e,Br(r),u,[ai]);return new Ua(new Bo(kr.fromNative(t.networkID,t.pBlockchainID,p,d,u.memo),exports.Id.fromString(s),exports.Input.fromNative(n),exports.OutputOwners.fromNative(o,c,i)),l,f)},newTransformSubnetTx:function(t,e,r,s,n,o,a,i,c,u,d,f,p,l,h,x,m,b,g){const y=Fa(r,g),{inputs:w,addressMaps:I,changeOutputs:B,inputUTXOs:T}=Ca(new Map([[t.avaxAssetID,t.transformSubnetTxFee]]),void 0,e,Br(r),y,[ai]);return new Ua(new So(kr.fromNative(t.networkID,t.pBlockchainID,B,w,y.memo),exports.Id.fromString(s),exports.Id.fromString(n),new exports.BigIntPr(o),new exports.BigIntPr(a),new exports.BigIntPr(i),new exports.BigIntPr(c),new exports.BigIntPr(u),new exports.BigIntPr(d),new exports.Int(f),new exports.Int(p),new exports.Int(l),new exports.Int(h),new exports.Byte(ge(x.toString(16))),new exports.Int(m),exports.Input.fromNative(b)),T,I)}});exports.AVM=Ie,exports.Common=Ga,exports.Context=Ja,exports.EVM=Be,exports.EVMUnsignedTx=za,exports.Info=Ya,exports.PVM=Te,exports.TypeRegistry=Tr,exports.UnsignedTx=Ua,exports.ValidVMs=Se,exports.addTxSignatures=async({unsignedTx:t,privateKeys:e})=>{const r=t.toBytes();await Promise.all(e.map((async e=>{const s=Ws(e);if(t.hasPubkey(s)){const s=await zs(r,e);t.addSignature(s)}})))},exports.avaxSerial=Vo,exports.avm=$a,exports.avmSerial=qo,exports.bls=lo,exports.evm=si,exports.evmSerial=Xo,exports.networkIDs=Xe,exports.pvm=fi,exports.pvmSerial=oa,exports.secp256k1=en,exports.utils=Sa;
