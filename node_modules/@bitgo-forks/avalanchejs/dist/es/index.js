import{bech32 as t,base58 as e,bytesToString as r}from"@scure/base";import{concatBytes as n,randomBytes as s,hexToBytes as a,bytesToHex as i}from"@noble/hashes/utils";import{sha256 as o}from"@noble/hashes/sha256";import{ripemd160 as c}from"@noble/hashes/ripemd160";import u from"util";function f(t,e,r,n){var s,a=arguments.length,i=a<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,r,n);else for(var o=t.length-1;o>=0;o--)(s=t[o])&&(i=(a<3?s(i):a>3?s(e,r,i):s(e,r))||i);return a>3&&i&&Object.defineProperty(e,r,i),i}function d(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)}const l=Symbol.for("nodejs.util.inspect.custom"),p="-";function h(t){const e=t.split(p);if(e.length<2)throw new Error(`Invalid address: ${t}`);const r=e[0],n=e[1],[s,a]=b(n);return[r,s,a]}function m(t){return h(t)[2]}function b(e){const{prefix:r,words:n}=t.decode(e);return[r,t.fromWords(n)]}function g(e,r){const n=t.toWords(r);return t.encode(e,n)}function y(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function w(t,...e){if(!((r=t)instanceof Uint8Array||null!=r&&"object"==typeof r&&"Uint8Array"===r.constructor.name))throw new Error("Expected Uint8Array");var r;if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function x(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}const I=BigInt(2**32-1),B=BigInt(32);function v(t,e=!1){return e?{h:Number(t&I),l:Number(t>>B&I)}:{h:0|Number(t>>B&I),l:0|Number(t&I)}}function T(t,e=!1){let r=new Uint32Array(t.length),n=new Uint32Array(t.length);for(let s=0;s<t.length;s++){const{h:a,l:i}=v(t[s],e);[r[s],n[s]]=[a,i]}return[r,n]}if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");function O(t){if("string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),!((e=t)instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name))throw new Error("expected Uint8Array, got "+typeof t);var e;return t}class S{clone(){return this._cloneInto()}}const[E,A,k]=[[],[],[]],P=BigInt(0),D=BigInt(1),R=BigInt(2),N=BigInt(7),_=BigInt(256),F=BigInt(113);for(let t=0,e=D,r=1,n=0;t<24;t++){[r,n]=[n,(2*r+3*n)%5],E.push(2*(5*n+r)),A.push((t+1)*(t+2)/2%64);let s=P;for(let t=0;t<7;t++)e=(e<<D^(e>>N)*F)%_,e&R&&(s^=D<<(D<<BigInt(t))-D);k.push(s)}const[V,U]=T(k,!0),M=(t,e,r)=>r>32?((t,e,r)=>e<<r-32|t>>>64-r)(t,e,r):((t,e,r)=>t<<r|e>>>32-r)(t,e,r),C=(t,e,r)=>r>32?((t,e,r)=>t<<r-32|e>>>64-r)
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */(t,e,r):((t,e,r)=>e<<r|t>>>32-r)(t,e,r);class q extends S{constructor(t,e,r,n=!1,s=24){if(super(),this.blockLen=t,this.suffix=e,this.outputLen=r,this.enableXOF=n,this.rounds=s,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,y(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var a;this.state=new Uint8Array(200),this.state32=(a=this.state,new Uint32Array(a.buffer,a.byteOffset,Math.floor(a.byteLength/4)))}keccak(){!function(t,e=24){const r=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let e=0;e<10;e++)r[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const n=(e+8)%10,s=(e+2)%10,a=r[s],i=r[s+1],o=M(a,i,1)^r[n],c=C(a,i,1)^r[n+1];for(let r=0;r<50;r+=10)t[e+r]^=o,t[e+r+1]^=c}let e=t[2],s=t[3];for(let r=0;r<24;r++){const n=A[r],a=M(e,s,n),i=C(e,s,n),o=E[r];e=t[o],s=t[o+1],t[o]=a,t[o+1]=i}for(let e=0;e<50;e+=10){for(let n=0;n<10;n++)r[n]=t[e+n];for(let n=0;n<10;n++)t[e+n]^=~r[(n+2)%10]&r[(n+4)%10]}t[0]^=V[n],t[1]^=U[n]}r.fill(0)}(this.state32,this.rounds),this.posOut=0,this.pos=0}update(t){x(this);const{blockLen:e,state:r}=this,n=(t=O(t)).length;for(let s=0;s<n;){const a=Math.min(e-this.pos,n-s);for(let e=0;e<a;e++)r[this.pos++]^=t[s++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:r,blockLen:n}=this;t[r]^=e,0!=(128&e)&&r===n-1&&this.keccak(),t[n-1]^=128,this.keccak()}writeInto(t){x(this,!1),w(t),this.finish();const e=this.state,{blockLen:r}=this;for(let n=0,s=t.length;n<s;){this.posOut>=r&&this.keccak();const a=Math.min(r-this.posOut,s-n);t.set(e.subarray(this.posOut,this.posOut+a),n),this.posOut+=a,n+=a}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return y(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(function(t,e){w(t);const r=e.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:e,suffix:r,outputLen:n,rounds:s,enableXOF:a}=this;return t||(t=new q(e,r,n,a,s)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=r,t.outputLen=n,t.enableXOF=a,t.destroyed=this.destroyed,t}}const j=((t,e,r)=>function(t){const e=e=>t().update(O(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}((()=>new q(e,t,r))))(1,136,32),L=BigInt(0),H=BigInt(1),Z=BigInt(2);function X(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}const G=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function K(t){if(!X(t))throw new Error("Uint8Array expected");let e="";for(let r=0;r<t.length;r++)e+=G[t[r]];return e}function $(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function z(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}const Y={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function J(t){return t>=Y._0&&t<=Y._9?t-Y._0:t>=Y._A&&t<=Y._F?t-(Y._A-10):t>=Y._a&&t<=Y._f?t-(Y._a-10):void 0}function W(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,r=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let e=0,s=0;e<r;e++,s+=2){const r=J(t.charCodeAt(s)),a=J(t.charCodeAt(s+1));if(void 0===r||void 0===a){const e=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+s)}n[e]=16*r+a}return n}function Q(t){return z(K(t))}function tt(t){if(!X(t))throw new Error("Uint8Array expected");return z(K(Uint8Array.from(t).reverse()))}function et(t,e){return W(t.toString(16).padStart(2*e,"0"))}function rt(t,e){return et(t,e).reverse()}function nt(t,e,r){let n;if("string"==typeof e)try{n=W(e)}catch(r){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${r}`)}else{if(!X(e))throw new Error(`${t} must be hex string or Uint8Array`);n=Uint8Array.from(e)}const s=n.length;if("number"==typeof r&&s!==r)throw new Error(`${t} expected ${r} bytes, got ${s}`);return n}function st(...t){let e=0;for(let r=0;r<t.length;r++){const n=t[r];if(!X(n))throw new Error("Uint8Array expected");e+=n.length}let r=new Uint8Array(e),n=0;for(let e=0;e<t.length;e++){const s=t[e];r.set(s,n),n+=s.length}return r}function at(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}function it(t){let e;for(e=0;t>L;t>>=H,e+=1);return e}function ot(t,e){return t>>BigInt(e)&H}const ct=t=>(Z<<BigInt(t-1))-H,ut=t=>new Uint8Array(t),ft=t=>Uint8Array.from(t);function dt(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=ut(t),s=ut(t),a=0;const i=()=>{n.fill(1),s.fill(0),a=0},o=(...t)=>r(s,n,...t),c=(t=ut())=>{s=o(ft([0]),t),n=o(),0!==t.length&&(s=o(ft([1]),t),n=o())},u=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){n=o();const e=n.slice();r.push(e),t+=n.length}return st(...r)};return(t,e)=>{let r;for(i(),c(t);!(r=e(u()));)c();return i(),r}}const lt={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||X(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function pt(t,e,r={}){const n=(e,r,n)=>{const s=lt[r];if("function"!=typeof s)throw new Error(`Invalid validator "${r}", expected function`);const a=t[e];if(!(n&&void 0===a||s(a,t)))throw new Error(`Invalid param ${String(e)}=${a} (${typeof a}), expected ${r}`)};for(const[t,r]of Object.entries(e))n(t,r,!1);for(const[t,e]of Object.entries(r))n(t,e,!0);return t}var ht=Object.freeze({__proto__:null,bitGet:ot,bitLen:it,bitMask:ct,bitSet:(t,e,r)=>t|(r?H:L)<<BigInt(e),bytesToHex:K,bytesToNumberBE:Q,bytesToNumberLE:tt,concatBytes:st,createHmacDrbg:dt,ensureBytes:nt,equalBytes:function(t,e){if(t.length!==e.length)return!1;let r=0;for(let n=0;n<t.length;n++)r|=t[n]^e[n];return 0===r},hexToBytes:W,hexToNumber:z,isBytes:X,numberToBytesBE:et,numberToBytesLE:rt,numberToHexUnpadded:$,numberToVarBytesBE:function(t){return W($(t))},utf8ToBytes:at,validateObject:pt});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const mt=BigInt(0),bt=BigInt(1),gt=BigInt(2),yt=BigInt(3),wt=BigInt(4),xt=BigInt(5),It=BigInt(8);function Bt(t,e){const r=t%e;return r>=mt?r:e+r}function vt(t,e,r){if(r<=mt||e<mt)throw new Error("Expected power/modulo > 0");if(r===bt)return mt;let n=bt;for(;e>mt;)e&bt&&(n=n*t%r),t=t*t%r,e>>=bt;return n}function Tt(t,e,r){let n=t;for(;e-- >mt;)n*=n,n%=r;return n}function Ot(t,e){if(t===mt||e<=mt)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=Bt(t,e),n=e,s=mt,a=bt;for(;r!==mt;){const t=n%r,e=s-a*(n/r);n=r,r=t,s=a,a=e}if(n!==bt)throw new Error("invert: does not exist");return Bt(s,e)}function St(t){if(t%wt===yt){const e=(t+bt)/wt;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}if(t%It===xt){const e=(t-xt)/It;return function(t,r){const n=t.mul(r,gt),s=t.pow(n,e),a=t.mul(r,s),i=t.mul(t.mul(a,gt),s),o=t.mul(a,t.sub(i,t.ONE));if(!t.eql(t.sqr(o),r))throw new Error("Cannot find square root");return o}}return function(t){const e=(t-bt)/gt;let r,n,s;for(r=t-bt,n=0;r%gt===mt;r/=gt,n++);for(s=gt;s<t&&vt(s,e,t)!==t-bt;s++);if(1===n){const e=(t+bt)/wt;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}const a=(r+bt)/gt;return function(t,i){if(t.pow(i,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let o=n,c=t.pow(t.mul(t.ONE,s),r),u=t.pow(i,a),f=t.pow(i,r);for(;!t.eql(f,t.ONE);){if(t.eql(f,t.ZERO))return t.ZERO;let e=1;for(let r=t.sqr(f);e<o&&!t.eql(r,t.ONE);e++)r=t.sqr(r);const r=t.pow(c,bt<<BigInt(o-e-1));c=t.sqr(r),u=t.mul(u,r),f=t.mul(f,c),o=e}return u}}(t)}BigInt(9),BigInt(16);const Et=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function At(t){return pt(t,Et.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}function kt(t,e,r){if(r<mt)throw new Error("Expected power > 0");if(r===mt)return t.ONE;if(r===bt)return e;let n=t.ONE,s=e;for(;r>mt;)r&bt&&(n=t.mul(n,s)),s=t.sqr(s),r>>=bt;return n}function Pt(t,e){const r=new Array(e.length),n=e.reduce(((e,n,s)=>t.is0(n)?e:(r[s]=e,t.mul(e,n))),t.ONE),s=t.inv(n);return e.reduceRight(((e,n,s)=>t.is0(n)?e:(r[s]=t.mul(e,r[s]),t.mul(e,n))),s),r}function Dt(t,e){const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Rt(t,e,r=!1,n={}){if(t<=mt)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:s,nByteLength:a}=Dt(t,e);if(a>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=St(t),o=Object.freeze({ORDER:t,BITS:s,BYTES:a,MASK:ct(s),ZERO:mt,ONE:bt,create:e=>Bt(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("Invalid field element: expected bigint, got "+typeof e);return mt<=e&&e<t},is0:t=>t===mt,isOdd:t=>(t&bt)===bt,neg:e=>Bt(-e,t),eql:(t,e)=>t===e,sqr:e=>Bt(e*e,t),add:(e,r)=>Bt(e+r,t),sub:(e,r)=>Bt(e-r,t),mul:(e,r)=>Bt(e*r,t),pow:(t,e)=>kt(o,t,e),div:(e,r)=>Bt(e*Ot(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>Ot(e,t),sqrt:n.sqrt||(t=>i(o,t)),invertBatch:t=>Pt(o,t),cmov:(t,e,r)=>r?e:t,toBytes:t=>r?rt(t,a):et(t,a),fromBytes:t=>{if(t.length!==a)throw new Error(`Fp.fromBytes: expected ${a}, got ${t.length}`);return r?tt(t):Q(t)}});return Object.freeze(o)}function Nt(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function _t(t){const e=Nt(t);return e+Math.ceil(e/2)}function Ft(t,e,r=!1){const n=t.length,s=Nt(e),a=_t(e);if(n<16||n<a||n>1024)throw new Error(`expected ${a}-1024 bytes of input, got ${n}`);const i=Bt(r?Q(t):tt(t),e-bt)+bt;return r?rt(i,s):et(i,s)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Vt=BigInt(0),Ut=BigInt(1);function Mt(t){return At(t.Fp),pt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Dt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const{bytesToNumberBE:Ct,hexToBytes:qt}=ht,jt={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(t){const{Err:e}=jt;if(t.length<2||2!==t[0])throw new e("Invalid signature integer tag");const r=t[1],n=t.subarray(2,r+2);if(!r||n.length!==r)throw new e("Invalid signature integer: wrong length");if(128&n[0])throw new e("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new e("Invalid signature integer: unnecessary leading zero");return{d:Ct(n),l:t.subarray(r+2)}},toSig(t){const{Err:e}=jt,r="string"==typeof t?qt(t):t;if(!X(r))throw new Error("ui8a expected");let n=r.length;if(n<2||48!=r[0])throw new e("Invalid signature tag");if(r[1]!==n-2)throw new e("Invalid signature: incorrect length");const{d:s,l:a}=jt._parseInt(r.subarray(2)),{d:i,l:o}=jt._parseInt(a);if(o.length)throw new e("Invalid signature: left bytes after parsing");return{r:s,s:i}},hexFromSig(t){const e=t=>8&Number.parseInt(t[0],16)?"00"+t:t,r=t=>{const e=t.toString(16);return 1&e.length?`0${e}`:e},n=e(r(t.s)),s=e(r(t.r)),a=n.length/2,i=s.length/2,o=r(a),c=r(i);return`30${r(i+a+4)}02${c}${s}02${o}${n}`}},Lt=BigInt(0),Ht=BigInt(1),Zt=BigInt(2),Xt=BigInt(3),Gt=BigInt(4);function Kt(t){const e=function(t){const e=Mt(t);pt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:s}=e;if(r){if(!n.eql(s,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,n=e.toBytes||((t,e,n)=>{const s=e.toAffine();return st(Uint8Array.from([4]),r.toBytes(s.x),r.toBytes(s.y))}),s=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function a(t){const{a:n,b:s}=e,a=r.sqr(t),i=r.mul(a,t);return r.add(r.add(i,r.mul(t,n)),s)}if(!r.eql(r.sqr(e.Gy),a(e.Gx)))throw new Error("bad generator point: equation left != right");function i(t){return"bigint"==typeof t&&Lt<t&&t<e.n}function o(t){if(!i(t))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(t){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:s,n:a}=e;if(r&&"bigint"!=typeof t){if(X(t)&&(t=K(t)),"string"!=typeof t||!r.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*n,"0")}let i;try{i="bigint"==typeof t?t:Q(nt("private key",t,n))}catch(e){throw new Error(`private key must be ${n} bytes, hex or bigint, not ${typeof t}`)}return s&&(i=Bt(i,a)),o(i),i}const u=new Map;function f(t){if(!(t instanceof d))throw new Error("ProjectivePoint expected")}class d{constructor(t,e,n){if(this.px=t,this.py=e,this.pz=n,null==t||!r.isValid(t))throw new Error("x required");if(null==e||!r.isValid(e))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required")}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw new Error("invalid affine point");if(t instanceof d)throw new Error("projective point not allowed");const s=t=>r.eql(t,r.ZERO);return s(e)&&s(n)?d.ZERO:new d(e,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(d.fromAffine)}static fromHex(t){const e=d.fromAffine(s(nt("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return d.BASE.multiply(c(t))}_setWindowSize(t){this._WINDOW_SIZE=t,u.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:t,y:n}=this.toAffine();if(!r.isValid(t)||!r.isValid(n))throw new Error("bad point: x or y not FE");const s=r.sqr(n),i=a(t);if(!r.eql(s,i))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){f(t);const{px:e,py:n,pz:s}=this,{px:a,py:i,pz:o}=t,c=r.eql(r.mul(e,o),r.mul(a,s)),u=r.eql(r.mul(n,o),r.mul(i,s));return c&&u}negate(){return new d(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:n}=e,s=r.mul(n,Xt),{px:a,py:i,pz:o}=this;let c=r.ZERO,u=r.ZERO,f=r.ZERO,l=r.mul(a,a),p=r.mul(i,i),h=r.mul(o,o),m=r.mul(a,i);return m=r.add(m,m),f=r.mul(a,o),f=r.add(f,f),c=r.mul(t,f),u=r.mul(s,h),u=r.add(c,u),c=r.sub(p,u),u=r.add(p,u),u=r.mul(c,u),c=r.mul(m,c),f=r.mul(s,f),h=r.mul(t,h),m=r.sub(l,h),m=r.mul(t,m),m=r.add(m,f),f=r.add(l,l),l=r.add(f,l),l=r.add(l,h),l=r.mul(l,m),u=r.add(u,l),h=r.mul(i,o),h=r.add(h,h),l=r.mul(h,m),c=r.sub(c,l),f=r.mul(h,p),f=r.add(f,f),f=r.add(f,f),new d(c,u,f)}add(t){f(t);const{px:n,py:s,pz:a}=this,{px:i,py:o,pz:c}=t;let u=r.ZERO,l=r.ZERO,p=r.ZERO;const h=e.a,m=r.mul(e.b,Xt);let b=r.mul(n,i),g=r.mul(s,o),y=r.mul(a,c),w=r.add(n,s),x=r.add(i,o);w=r.mul(w,x),x=r.add(b,g),w=r.sub(w,x),x=r.add(n,a);let I=r.add(i,c);return x=r.mul(x,I),I=r.add(b,y),x=r.sub(x,I),I=r.add(s,a),u=r.add(o,c),I=r.mul(I,u),u=r.add(g,y),I=r.sub(I,u),p=r.mul(h,x),u=r.mul(m,y),p=r.add(u,p),u=r.sub(g,p),p=r.add(g,p),l=r.mul(u,p),g=r.add(b,b),g=r.add(g,b),y=r.mul(h,y),x=r.mul(m,x),g=r.add(g,y),y=r.sub(b,y),y=r.mul(h,y),x=r.add(x,y),b=r.mul(g,x),l=r.add(l,b),b=r.mul(I,x),u=r.mul(w,u),u=r.sub(u,b),b=r.mul(w,g),p=r.mul(I,p),p=r.add(p,b),new d(u,l,p)}subtract(t){return this.add(t.negate())}is0(){return this.equals(d.ZERO)}wNAF(t){return p.wNAFCached(this,u,t,(t=>{const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(d.fromAffine)}))}multiplyUnsafe(t){const n=d.ZERO;if(t===Lt)return n;if(o(t),t===Ht)return this;const{endo:s}=e;if(!s)return p.unsafeLadder(this,t);let{k1neg:a,k1:i,k2neg:c,k2:u}=s.splitScalar(t),f=n,l=n,h=this;for(;i>Lt||u>Lt;)i&Ht&&(f=f.add(h)),u&Ht&&(l=l.add(h)),h=h.double(),i>>=Ht,u>>=Ht;return a&&(f=f.negate()),c&&(l=l.negate()),l=new d(r.mul(l.px,s.beta),l.py,l.pz),f.add(l)}multiply(t){o(t);let n,s,a=t;const{endo:i}=e;if(i){const{k1neg:t,k1:e,k2neg:o,k2:c}=i.splitScalar(a);let{p:u,f:f}=this.wNAF(e),{p:l,f:h}=this.wNAF(c);u=p.constTimeNegate(t,u),l=p.constTimeNegate(o,l),l=new d(r.mul(l.px,i.beta),l.py,l.pz),n=u.add(l),s=f.add(h)}else{const{p:t,f:e}=this.wNAF(a);n=t,s=e}return d.normalizeZ([n,s])[0]}multiplyAndAddUnsafe(t,e,r){const n=d.BASE,s=(t,e)=>e!==Lt&&e!==Ht&&t.equals(n)?t.multiply(e):t.multiplyUnsafe(e),a=s(this,e).add(s(t,r));return a.is0()?void 0:a}toAffine(t){const{px:e,py:n,pz:s}=this,a=this.is0();null==t&&(t=a?r.ONE:r.inv(s));const i=r.mul(e,t),o=r.mul(n,t),c=r.mul(s,t);if(a)return{x:r.ZERO,y:r.ZERO};if(!r.eql(c,r.ONE))throw new Error("invZ was invalid");return{x:i,y:o}}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===Ht)return!0;if(r)return r(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===Ht?this:r?r(d,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return this.assertValidity(),n(d,this,t)}toHex(t=!0){return K(this.toRawBytes(t))}}d.BASE=new d(e.Gx,e.Gy,r.ONE),d.ZERO=new d(r.ZERO,r.ONE,r.ZERO);const l=e.nBitLength,p=function(t,e){const r=(t,e)=>{const r=e.negate();return t?r:e},n=t=>({windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate:r,unsafeLadder(e,r){let n=t.ZERO,s=e;for(;r>Vt;)r&Ut&&(n=n.add(s)),s=s.double(),r>>=Ut;return n},precomputeWindow(t,e){const{windows:r,windowSize:s}=n(e),a=[];let i=t,o=i;for(let t=0;t<r;t++){o=i,a.push(o);for(let t=1;t<s;t++)o=o.add(i),a.push(o);i=o.double()}return a},wNAF(e,s,a){const{windows:i,windowSize:o}=n(e);let c=t.ZERO,u=t.BASE;const f=BigInt(2**e-1),d=2**e,l=BigInt(e);for(let t=0;t<i;t++){const e=t*o;let n=Number(a&f);a>>=l,n>o&&(n-=d,a+=Ut);const i=e,p=e+Math.abs(n)-1,h=t%2!=0,m=n<0;0===n?u=u.add(r(h,s[i])):c=c.add(r(m,s[p]))}return{p:c,f:u}},wNAFCached(t,e,r,n){const s=t._WINDOW_SIZE||1;let a=e.get(t);return a||(a=this.precomputeWindow(t,s),1!==s&&e.set(t,n(a))),this.wNAF(s,a,r)}}}(d,e.endo?Math.ceil(l/2):l);return{CURVE:e,ProjectivePoint:d,normPrivateKeyToScalar:c,weierstrassEquation:a,isWithinCurveOrder:i}}function $t(t){const e=function(t){const e=Mt(t);return pt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:r,n:n}=e,s=r.BYTES+1,a=2*r.BYTES+1;function i(t){return Bt(t,n)}function o(t){return Ot(t,n)}const{ProjectivePoint:c,normPrivateKeyToScalar:u,weierstrassEquation:f,isWithinCurveOrder:d}=Kt({...e,toBytes(t,e,n){const s=e.toAffine(),a=r.toBytes(s.x),i=st;return n?i(Uint8Array.from([e.hasEvenY()?2:3]),a):i(Uint8Array.from([4]),a,r.toBytes(s.y))},fromBytes(t){const e=t.length,n=t[0],i=t.subarray(1);if(e!==s||2!==n&&3!==n){if(e===a&&4===n){return{x:r.fromBytes(i.subarray(0,r.BYTES)),y:r.fromBytes(i.subarray(r.BYTES,2*r.BYTES))}}throw new Error(`Point of length ${e} was invalid. Expected ${s} compressed bytes or ${a} uncompressed bytes`)}{const t=Q(i);if(!(Lt<(o=t)&&o<r.ORDER))throw new Error("Point is not on curve");const e=f(t);let s=r.sqrt(e);return 1==(1&n)!==((s&Ht)===Ht)&&(s=r.neg(s)),{x:t,y:s}}var o}}),l=t=>K(et(t,e.nByteLength));function p(t){return t>n>>Ht}const h=(t,e,r)=>Q(t.slice(e,r));class m{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){const r=e.nByteLength;return t=nt("compactSignature",t,2*r),new m(h(t,0,r),h(t,r,2*r))}static fromDER(t){const{r:e,s:r}=jt.toSig(nt("DER",t));return new m(e,r)}assertValidity(){if(!d(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!d(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new m(this.r,this.s,t)}recoverPublicKey(t){const{r:n,s:s,recovery:a}=this,u=w(nt("msgHash",t));if(null==a||![0,1,2,3].includes(a))throw new Error("recovery id invalid");const f=2===a||3===a?n+e.n:n;if(f>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const d=0==(1&a)?"02":"03",p=c.fromHex(d+l(f)),h=o(f),m=i(-u*h),b=i(s*h),g=c.BASE.multiplyAndAddUnsafe(p,m,b);if(!g)throw new Error("point at infinify");return g.assertValidity(),g}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new m(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return W(this.toDERHex())}toDERHex(){return jt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return W(this.toCompactHex())}toCompactHex(){return l(this.r)+l(this.s)}}const b={isValidPrivateKey(t){try{return u(t),!0}catch(t){return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const t=_t(e.n);return Ft(e.randomBytes(t),e.n)},precompute:(t=8,e=c.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function g(t){const e=X(t),r="string"==typeof t,n=(e||r)&&t.length;return e?n===s||n===a:r?n===2*s||n===2*a:t instanceof c}const y=e.bits2int||function(t){const r=Q(t),n=8*t.length-e.nBitLength;return n>0?r>>BigInt(n):r},w=e.bits2int_modN||function(t){return i(y(t))},x=ct(e.nBitLength);function I(t){if("bigint"!=typeof t)throw new Error("bigint expected");if(!(Lt<=t&&t<x))throw new Error(`bigint expected < 2^${e.nBitLength}`);return et(t,e.nByteLength)}function B(t,n,s=v){if(["recovered","canonical"].some((t=>t in s)))throw new Error("sign() legacy options not supported");const{hash:a,randomBytes:f}=e;let{lowS:l,prehash:h,extraEntropy:b}=s;null==l&&(l=!0),t=nt("msgHash",t),h&&(t=nt("prehashed msgHash",a(t)));const g=w(t),x=u(n),B=[I(x),I(g)];if(null!=b){const t=!0===b?f(r.BYTES):b;B.push(nt("extraEntropy",t))}const T=st(...B),O=g;return{seed:T,k2sig:function(t){const e=y(t);if(!d(e))return;const r=o(e),n=c.BASE.multiply(e).toAffine(),s=i(n.x);if(s===Lt)return;const a=i(r*i(O+s*x));if(a===Lt)return;let u=(n.x===s?0:2)|Number(n.y&Ht),f=a;return l&&p(a)&&(f=function(t){return p(t)?i(-t):t}(a),u^=1),new m(s,f,u)}}}const v={lowS:e.lowS,prehash:!1},T={lowS:e.lowS,prehash:!1};return c.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return c.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(g(t))throw new Error("first arg must be private key");if(!g(e))throw new Error("second arg must be public key");return c.fromHex(e).multiply(u(t)).toRawBytes(r)},sign:function(t,r,n=v){const{seed:s,k2sig:a}=B(t,r,n),i=e;return dt(i.hash.outputLen,i.nByteLength,i.hmac)(s,a)},verify:function(t,r,n,s=T){const a=t;if(r=nt("msgHash",r),n=nt("publicKey",n),"strict"in s)throw new Error("options.strict was renamed to lowS");const{lowS:u,prehash:f}=s;let d,l;try{if("string"==typeof a||X(a))try{d=m.fromDER(a)}catch(t){if(!(t instanceof jt.Err))throw t;d=m.fromCompact(a)}else{if("object"!=typeof a||"bigint"!=typeof a.r||"bigint"!=typeof a.s)throw new Error("PARSE");{const{r:t,s:e}=a;d=new m(t,e)}}l=c.fromHex(n)}catch(t){if("PARSE"===t.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(u&&d.hasHighS())return!1;f&&(r=e.hash(r));const{r:p,s:h}=d,b=w(r),g=o(h),y=i(b*g),x=i(p*g),I=c.BASE.multiplyAndAddUnsafe(l,y,x)?.toAffine();return!!I&&i(I.x)===p},ProjectivePoint:c,Signature:m,utils:b}}function zt(t,e){if(At(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const r=function(t,e){const r=t.ORDER;let n=Lt;for(let t=r-Ht;t%Zt===Lt;t/=Zt)n+=Ht;const s=n,a=Zt<<s-Ht-Ht,i=a*Zt,o=(r-Ht)/i,c=(o-Ht)/Zt,u=i-Ht,f=a,d=t.pow(e,o),l=t.pow(e,(o+Ht)/Zt);let p=(e,r)=>{let n=d,a=t.pow(r,u),i=t.sqr(a);i=t.mul(i,r);let o=t.mul(e,i);o=t.pow(o,c),o=t.mul(o,a),a=t.mul(o,r),i=t.mul(o,e);let p=t.mul(i,a);o=t.pow(p,f);let h=t.eql(o,t.ONE);a=t.mul(i,l),o=t.mul(p,n),i=t.cmov(a,i,h),p=t.cmov(o,p,h);for(let e=s;e>Ht;e--){let r=e-Zt;r=Zt<<r-Ht;let s=t.pow(p,r);const o=t.eql(s,t.ONE);a=t.mul(i,n),n=t.mul(n,n),s=t.mul(p,n),i=t.cmov(a,i,o),p=t.cmov(s,p,o)}return{isValid:h,value:i}};if(t.ORDER%Gt===Xt){const r=(t.ORDER-Xt)/Gt,n=t.sqrt(t.neg(e));p=(e,s)=>{let a=t.sqr(s);const i=t.mul(e,s);a=t.mul(a,i);let o=t.pow(a,r);o=t.mul(o,i);const c=t.mul(o,n),u=t.mul(t.sqr(o),s),f=t.eql(u,e);return{isValid:f,value:t.cmov(c,o,f)}}}return p}(t,e.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return n=>{let s,a,i,o,c,u,f,d;s=t.sqr(n),s=t.mul(s,e.Z),a=t.sqr(s),a=t.add(a,s),i=t.add(a,t.ONE),i=t.mul(i,e.B),o=t.cmov(e.Z,t.neg(a),!t.eql(a,t.ZERO)),o=t.mul(o,e.A),a=t.sqr(i),u=t.sqr(o),c=t.mul(u,e.A),a=t.add(a,c),a=t.mul(a,i),u=t.mul(u,o),c=t.mul(u,e.B),a=t.add(a,c),f=t.mul(s,i);const{isValid:l,value:p}=r(a,u);d=t.mul(s,n),d=t.mul(d,p),f=t.cmov(f,i,l),d=t.cmov(d,p,l);const h=t.isOdd(n)===t.isOdd(d);return d=t.cmov(t.neg(d),d,h),f=t.div(f,o),{x:f,y:d}}}const Yt=Q;function Jt(t,e){if(t<0||t>=1<<8*e)throw new Error(`bad I2OSP call: value=${t} length=${e}`);const r=Array.from({length:e}).fill(0);for(let n=e-1;n>=0;n--)r[n]=255&t,t>>>=8;return new Uint8Array(r)}function Wt(t,e){const r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t[n]^e[n];return r}function Qt(t){if(!X(t))throw new Error("Uint8Array expected")}function te(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function ee(t,e,r){pt(r,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:n,k:s,m:a,hash:i,expand:o,DST:c}=r;Qt(t),te(e);const u=function(t){if(X(t))return t;if("string"==typeof t)return at(t);throw new Error("DST must be Uint8Array or string")}(c),f=n.toString(2).length,d=Math.ceil((f+s)/8),l=e*a*d;let p;if("xmd"===o)p=function(t,e,r,n){Qt(t),Qt(e),te(r),e.length>255&&(e=n(st(at("H2C-OVERSIZE-DST-"),e)));const{outputLen:s,blockLen:a}=n,i=Math.ceil(r/s);if(i>255)throw new Error("Invalid xmd length");const o=st(e,Jt(e.length,1)),c=Jt(0,a),u=Jt(r,2),f=new Array(i),d=n(st(c,t,u,Jt(0,1),o));f[0]=n(st(d,Jt(1,1),o));for(let t=1;t<=i;t++){const e=[Wt(d,f[t-1]),Jt(t+1,1),o];f[t]=n(st(...e))}return st(...f).slice(0,r)}(t,u,l,i);else if("xof"===o)p=function(t,e,r,n,s){if(Qt(t),Qt(e),te(r),e.length>255){const t=Math.ceil(2*n/8);e=s.create({dkLen:t}).update(at("H2C-OVERSIZE-DST-")).update(e).digest()}if(r>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:r}).update(t).update(Jt(r,2)).update(e).update(Jt(e.length,1)).digest()}(t,u,l,s,i);else{if("_internal_pass"!==o)throw new Error('expand must be "xmd" or "xof"');p=t}const h=new Array(e);for(let t=0;t<e;t++){const e=new Array(a);for(let r=0;r<a;r++){const s=d*(r+t*a),i=p.subarray(s,s+d);e[r]=Bt(Yt(i),n)}h[t]=e}return h}function re(t,e){const r=e.map((t=>Array.from(t).reverse()));return(e,n)=>{const[s,a,i,o]=r.map((r=>r.reduce(((r,n)=>t.add(t.mul(r,e),n)))));return e=t.div(s,a),n=t.mul(n,t.div(i,o)),{x:e,y:n}}}function ne(t,e,r){if("function"!=typeof e)throw new Error("mapToCurve() must be defined");return{hashToCurve(n,s){const a=ee(n,2,{...r,DST:r.DST,...s}),i=t.fromAffine(e(a[0])),o=t.fromAffine(e(a[1])),c=i.add(o).clearCofactor();return c.assertValidity(),c},encodeToCurve(n,s){const a=ee(n,1,{...r,DST:r.encodeDST,...s}),i=t.fromAffine(e(a[0])).clearCofactor();return i.assertValidity(),i}}}class se extends S{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");y(t.outputLen),y(t.blockLen)}(t);const r=O(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(r.length>n?t.create().update(r).digest():r);for(let t=0;t<s.length;t++)s[t]^=54;this.iHash.update(s),this.oHash=t.create();for(let t=0;t<s.length;t++)s[t]^=106;this.oHash.update(s),s.fill(0)}update(t){return x(this),this.iHash.update(t),this}digestInto(t){x(this),w(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:s,blockLen:a,outputLen:i}=this;return t.finished=n,t.destroyed=s,t.blockLen=a,t.outputLen=i,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ae=(t,e,r)=>new se(t,e).update(r).digest();
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function ie(t){return{hash:t,hmac:(e,...r)=>ae(t,e,n(...r)),randomBytes:s}}ae.create=(t,e)=>new se(t,e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const oe=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),ce=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ue=BigInt(1),fe=BigInt(2),de=(t,e)=>(t+e/fe)/e;const le=Rt(oe,void 0,void 0,{sqrt:function(t){const e=oe,r=BigInt(3),n=BigInt(6),s=BigInt(11),a=BigInt(22),i=BigInt(23),o=BigInt(44),c=BigInt(88),u=t*t*t%e,f=u*u*t%e,d=Tt(f,r,e)*f%e,l=Tt(d,r,e)*f%e,p=Tt(l,fe,e)*u%e,h=Tt(p,s,e)*p%e,m=Tt(h,a,e)*h%e,b=Tt(m,o,e)*m%e,g=Tt(b,c,e)*b%e,y=Tt(g,o,e)*m%e,w=Tt(y,r,e)*f%e,x=Tt(w,i,e)*h%e,I=Tt(x,n,e)*u%e,B=Tt(I,fe,e);if(!le.eql(le.sqr(B),t))throw new Error("Cannot find square root");return B}}),pe=function(t,e){const r=e=>$t({...t,...ie(e)});return Object.freeze({...r(e),create:r})}({a:BigInt(0),b:BigInt(7),Fp:le,n:ce,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=ce,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-ue*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),a=r,i=BigInt("0x100000000000000000000000000000000"),o=de(a*t,e),c=de(-n*t,e);let u=Bt(t-o*r-c*s,e),f=Bt(-o*n-c*a,e);const d=u>i,l=f>i;if(d&&(u=e-u),l&&(f=e-f),u>i||f>i)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:d,k1:u,k2neg:l,k2:f}}}},o);BigInt(0),pe.ProjectivePoint,Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));
/*! micro-eth-signer - MIT License (c) 2021 Paul Miller (paulmillr.com) */
const he=t=>pe.getPublicKey(t,!1),me=t=>pe.ProjectivePoint.fromHex(t).toRawBytes(!1);function be(t){return/^0x/i.test(t)?t:`0x${t}`}function ge(t){return t.replace(/^0x/i,"")}function ye(t){return a(ge(t))}const we={fromPrivateKey:t=>("string"==typeof t&&(t=ye(t)),we.fromPublicKey(he(t))),fromPublicKey(t){const e=me(t),r=i(j(e.subarray(1,65))).slice(24);return we.checksum(r)},checksum(t){const e=ge(t.toLowerCase());if(40!==e.length)throw new Error("Invalid address, must have 40 chars");const r=ge(i(j(e)));let n="";for(let t=0;t<e.length;t++){const s=Number.parseInt(r[t],16);let a=e[t];s>7&&(a=a.toUpperCase()),n+=a}return be(n)},verifyChecksum(t){const e=ge(t);if(40!==e.length)throw new Error("Invalid address, must have 40 chars");if(e===e.toLowerCase()||e===e.toUpperCase())return!0;const r=i(j(e.toLowerCase()));for(let t=0;t<40;t++){const n=e[t],s=Number.parseInt(r[t],16);if(s>7&&n.toUpperCase()!==n)return!1;if(s<=7&&n.toLowerCase()!==n)return!1}return!0}};function xe(t){return BigInt(Be(t))}function Ie(t){return Number.parseInt(i(t),16)}function Be(t){return be(i(t))}function ve(t){return 1&(t=ge(t)).length&&(t="0"+t),a(t)}function Te(t,e){const r=e-t.length;if(r<=0)return t;const n=new Uint8Array(e);return n.set(t,r),n}class Oe{}const Se="AVM",Ee="EVM",Ae="PVM",ke=[Se,Ee,Ae];var Pe,De;!function(t){t.Codec="codec",t.BaseTx="avax.BaseTx",t.TransferableOutput="avax.TransferableOutput",t.TransferableInput="avax.TransferableInput",t.TransferableOp="avax.TransferableOp",t.UTXOID="avax.UTXOID",t.UTXO="avax.Utxo",t.Id="common.Id",t.Address="common.Address",t.NodeId="common.NodeId",t.Int="primitives.Int",t.BigIntPr="primitives.BigInt",t.StringPr="primitives.String",t.Byte="primitives.Byte",t.Bytes="primitives.Bytes",t.Short="primitives.Short",t.Input="secp256k1fx.Input",t.TransferInput="secp256k1fx.TransferInput",t.TransferOutput="secp256k1fx.TransferOutput",t.OutputOwners="secp256k1fx.OutputOwners",t.OutputOwnersList="secp256k1fx.OutputOwnersList",t.Credential="secp256k1fx.Credential",t.Signature="secp256k1fx.Signature",t.SecpMintOperation="secp256k1fx.MintOperation",t.SecpMintOutput="secp256k1fx.MintOutput",t.NftFxMintOperation="nftfx.MintOperation",t.NftFxMintOutput="nftfx.MintOutput",t.NftFxTransferOperation="nftfx.TransferOperation",t.NftFxTransferOutput="nftfx.TransferOutput",t.NftFxCredential="nftfx.Credential",t.AvmBaseTx="avm.BaseTx",t.AvmExportTx="avm.ExportTx",t.AvmImportTx="avm.ImportTx",t.CreateAssetTx="avm.CreateAssetTx",t.OperationTx="avm.OperationTx",t.InitialState="avm.InitialState",t.AvmSignedTx="avm.SignedTx",t.PvmBaseTx="pvm.BaseTx",t.StakeableLockIn="pvm.StakeableLockIn",t.StakeableLockOut="pvm.StakeableLockOut",t.AddDelegatorTx="pvm.AddDelegatorTx",t.AddValidatorTx="pvm.AddValidatorTx",t.AddPermissionlessDelegatorTx="pvm.AddPermissionlessDelegator",t.AddPermissionlessValidatorTx="pvm.AddPermissionlessValidator",t.Validator="pvm.Validator",t.SubnetValidator="pvm.SubnetValidator",t.Signer="pvm.signer",t.SignerEmpty="pvm.signerEmpty",t.ProofOfPossession="pvm.proofOfPossession",t.AddSubnetValidatorTx="pvm.AddSubnetValidator",t.AdvanceTimeTx="pvm.AdvanceTimeTx",t.CreateChainTx="pvm.CreateChainTx",t.CreateSubnetTx="pvm.CreateSubnetTx",t.PvmExportTx="pvm.ExportTx",t.PvmImportTx="pvm.ImportTx",t.RewardValidatorTx="pvm.RewardValidatorTx",t.RemoveSubnetValidatorTx="pvm.RemoveSubnetValidator",t.TransformSubnetTx="pvm.TransformSubnetTx",t.TransferSubnetOwnershipTx="pvm.TransferSubnetOwnershipTx",t.EvmExportTx="evm.ExportTx",t.EvmInput="evm.Input",t.EvmOutput="evm.Output",t.EvmImportTx="evm.ImportTx"}(Pe||(Pe={}));let Re=De=class extends Oe{address;_type=Pe.Address;constructor(t){super(),this.address=t}static fromBytes(t){return[new De(t.slice(0,20)),t.slice(20)]}[l](t,e){return e.stylize(this.toJSON(),"string")}toJSON(t="avax"){return this.toString(t)}static fromString(t){return new De(m(t))}static fromHex(t){return new De(ve(t))}toHex(){return Be(this.address)}toBytes(){return Te(this.address,20)}toString(t="avax"){return g(t,this.address)}value(){return this.toString()}};Re=De=f([t=>{},d("design:paramtypes",[Uint8Array])],Re);const Ne={encode:t=>e.encode(n(t,o(t).subarray(-4))),decode:t=>e.decode(t).subarray(0,-4)},_e=(t,e)=>{let r;for(r=0;r<t.length&&r<e.length;r++){const n=t[r],s=e[r];if(n!==s)return n-s}return r===t.length&&r===e.length?0:r===t.length?-1:1};var Fe;let Ve=Fe=class extends Oe{idVal;_type=Pe.Id;constructor(t){super(),this.idVal=t}static fromBytes(t){return[new Fe(t.slice(0,32)),t.slice(32)]}static compare(t,e){return _e(t.toBytes(),e.toBytes())}[l](t,e){return e.stylize(this.toString(),"string")}toBytes(){return Te(this.idVal,32)}toJSON(){return this.toString()}toString(){return Ne.encode(this.toBytes())}static fromString(t){return Fe.fromBytes(Ne.decode(t))[0]}static fromHex(t){return new Fe(ve(t))}value(){return this.toString()}};var Ue;Ve=Fe=f([t=>{},d("design:paramtypes",[Uint8Array])],Ve);const Me="NodeID-";let Ce=Ue=class extends Oe{idVal;_type=Pe.NodeId;constructor(t){super(),this.idVal=t}static fromBytes(t){return[new Ue(t.slice(0,20)),t.slice(20)]}[l](t,e){return e.stylize(this.toString(),"string")}toBytes(){return Te(this.idVal,20)}toJSON(){return this.toString()}toString(){return Me+Ne.encode(this.toBytes())}static fromString(t){if(!t.includes(Me))throw new Error("ID is missing prefix");return this.fromBytes(Ne.decode(t.replace(Me,"")))[0]}static fromHex(t){return new Ue(ve(t))}value(){return this.toString()}};Ce=Ue=f([t=>{},d("design:paramtypes",[Uint8Array])],Ce);const qe=new Ve(new Uint8Array(32)),je=new Ve(new Uint8Array(32)),Le="avax",He="cascade",Ze="denali",Xe="everest",Ge="fuji",Ke="testing",$e="local",ze="custom",Ye={1:Le,2:He,3:Ze,4:Xe,5:Ge,10:Ke,12345:$e},Je=t=>Ye[t]??ze;var We,Qe=Object.freeze({__proto__:null,CascadeHRP:He,CascadeID:2,CascadeName:"cascade",DenaliHRP:Ze,DenaliID:3,DenaliName:"denali",EverestHRP:Xe,EverestID:4,EverestName:"everest",FallbackHRP:ze,FujiHRP:Ge,FujiID:5,FujiName:"fuji",LocalHRP:$e,LocalID:12345,LocalName:"local",MainnetHRP:Le,MainnetID:1,MainnetName:"mainnet",NetworkIDToHRP:Ye,PlatformChainID:je,PrimaryNetworkID:qe,TestnetID:5,TestnetName:"testnet",UnitTestHRP:Ke,UnitTestID:10,UnitTestName:"testing",getHRP:Je});class tr{getVM(){return this.vm}}class er extends tr{getInputs(){return this.baseTx?.inputs??[]}getBlockchainId(){return this.baseTx?.BlockchainId.toString()??""}getSigIndices(){return this.getInputs().map((t=>t.sigIndicies())).filter((t=>void 0!==t))}}let rr=We=class extends Oe{int;_type=Pe.Int;constructor(t){super(),this.int=t}static fromBytes(t){return[new We(Ie(t.slice(0,4))),t.slice(4)]}[l](){return this.value()}toJSON(){return this.int}toBytes(){return Te(ve(this.int.toString(16)),4)}value(){return this.int}};rr=We=f([t=>{},d("design:paramtypes",[Number])],rr);const nr=t=>new rr(t).toBytes(),sr=(t,e,r)=>ar(t,e.fromBytes,r),ar=(t,e,r)=>{let n;[n,t]=rr.fromBytes(t);const s=[];for(let a=0;a<n.value();a++){if(0===t.length)throw new Error("not enough bytes");let n;[n,t]=e(t,r),s.push(n)}return[s,t]},ir=t=>({fromBytes:(e,r)=>sr(e,t,r)}),or={fromBytes:(t,e)=>{if(!e)throw new Error("codec required when using unpackCodecList");return ar(t,e.UnpackPrefix,e)}},cr=(t,e)=>n(nr(t.length),...t.map((t=>t.toBytes(e))));function ur(t,e,r){return[...e.map((e=>{let n;if(!t.length)throw new Error("not enough bytes");return[n,t]=e.fromBytes(t,r),n})),t]}function fr(t,e){return n(...t.map((t=>Array.isArray(t)?cr(t,e):t.toBytes(e))))}function dr(t,...e){return fr(e,t)}var lr;let pr=lr=class extends Oe{bigint;_type=Pe.BigIntPr;constructor(t){super(),this.bigint=t}[l](){return this.bigint}static fromBytes(t){return[new lr(xe(t.slice(0,8))),t.slice(8)]}toJSON(){return this.bigint.toString()}toBytes(){return Te(ve(this.bigint.toString(16)),8)}value(){return this.bigint}};var hr;pr=lr=f([t=>{},d("design:paramtypes",[BigInt])],pr);let mr=hr=class extends Oe{byte;_type=Pe.Byte;constructor(t){super(),this.byte=t}static fromBytes(t){return[new hr(t.slice(0,1)),t.slice(1)]}toJSON(){return Be(this.byte)}toBytes(){return this.byte}};var br;mr=hr=f([t=>{},d("design:paramtypes",[Uint8Array])],mr);let gr=br=class extends Oe{bytes;_type=Pe.Bytes;constructor(t){super(),this.bytes=t}toString(t="utf8"){return r(t,this.bytes)}toJSON(){return Be(this.bytes)}static fromBytes(t){const[e,r]=rr.fromBytes(t);return[new br(r.slice(0,e.value())),r.slice(e.value())]}toBytes(){return n(nr(this.bytes.length),this.bytes)}};var yr;gr=br=f([t=>{},d("design:paramtypes",[Uint8Array])],gr);let wr=yr=class extends Oe{short;_type=Pe.Short;constructor(t){super(),this.short=t}static fromBytes(t){return[new yr(Ie(t.slice(0,2))),t.slice(2)]}toJSON(){return this.short.toString()}toBytes(){return Te(ve(this.short.toString(16)),2)}value(){return this.short}};var xr;wr=yr=f([t=>{},d("design:paramtypes",[Number])],wr);let Ir=xr=class extends Oe{string;_type=Pe.StringPr;constructor(t){super(),this.string=t}static fromBytes(t){const[e,r]=wr.fromBytes(t);return[new xr((new TextDecoder).decode(r.slice(0,e.value()))),r.slice(e.value())]}toJSON(){return this.string}toBytes(){return n(Te(ve(this.string.length.toString(16)),2),(new TextEncoder).encode(this.string))}value(){return this.string}};function Br(t){return t._type===Pe.TransferOutput}function vr(t){return t._type===Pe.StakeableLockOut}function Tr(t){return t._type===Pe.OutputOwners}function Or(t){return t._type===Pe.StakeableLockIn}function Sr(t){return t._type===Pe.TransferInput}var Er;Ir=xr=f([t=>{},d("design:paramtypes",[String])],Ir);let Ar=Er=class{sig;_type=Pe.Signature;constructor(t){if(this.sig=t,65!==t.length)throw new Error("incorrect number of bytes for signature")}toJSON(){return i(this.sig)}static fromJSON(t){return new Er(ye(t))}static fromBytes(t){return[new Er(t.slice(0,65)),t.slice(65)]}[l](t,e){return e.stylize(this.toString(),"string")}toString(){return Be(this.sig)}toBytes(){return Te(this.sig,65)}};var kr;Ar=Er=f([t=>{},d("design:paramtypes",[Uint8Array])],Ar);let Pr=kr=class{signatures;_type=Pe.Credential;constructor(t){this.signatures=t}static fromBytes(t,e){const[r,n]=sr(t,Ar,e);return[new kr(r),n]}toJSON(){return this.signatures}static fromJSON(t){return new kr(t.map((t=>Ar.fromJSON(t))))}setSignature(t,e){if(t>=this.signatures.length)throw new Error(`index ${t} is out of bounds for credential`);this.signatures[t]=new Ar(e)}getSignatures(){return this.signatures.map((t=>t.toString()))}toBytes(t){return cr(this.signatures,t)}};var Dr;Pr=kr=f([t=>{},d("design:paramtypes",[Array])],Pr);let Rr=Dr=class{sigIndices;_type=Pe.Input;constructor(t){this.sigIndices=t}static fromNative(t){return new Dr(t.map((t=>new rr(t))))}static fromBytes(t){const[e,r]=ur(t,[ir(rr)]);return[new Dr(e),r]}values(){return this.sigIndices.map((t=>t.value()))}toBytes(t){return cr(this.sigIndices,t)}};function Nr(t){return t.map((t=>new Re(t)))}var _r;Rr=Dr=f([t=>{},d("design:paramtypes",[Array])],Rr);let Fr=_r=class{locktime;threshold;addrs;_type=Pe.OutputOwners;constructor(t,e,r){this.locktime=t,this.threshold=e,this.addrs=r}static fromNative(t,e=0n,r=1){return new _r(new pr(e),new rr(r),Nr(t))}static fromBytes(t,e){const[r,n,s,a]=ur(t,[pr,rr,ir(Re)],e);return[new _r(r,n,s),a]}toBytes(t){return n(fr([this.locktime,this.threshold],t),cr(this.addrs,t))}equals(t){return this.locktime.value()===t.locktime.value()&&this.threshold.value()===t.threshold.value()&&this.addrs.length===t.addrs.length&&this.addrs.every(((e,r)=>e.value()===t.addrs[r].value()))}};var Vr;Fr=_r=f([t=>{},d("design:paramtypes",[pr,rr,Array])],Fr);let Ur=Vr=class{outputOwners;_type=Pe.SecpMintOutput;constructor(t){this.outputOwners=t}static fromBytes(t,e){let r;return[r,t]=Fr.fromBytes(t,e),[new Vr(r),t]}toBytes(t){return this.outputOwners.toBytes(t)}};var Mr;Ur=Vr=f([t=>{},d("design:paramtypes",[Fr])],Ur);let Cr=Mr=class{amt;outputOwners;_type=Pe.TransferOutput;constructor(t,e){this.amt=t,this.outputOwners=e}amount(){return this.amt.value()}getLocktime(){return this.outputOwners.locktime.value()}getOwners(){return this.outputOwners.addrs.map((t=>t.toBytes()))}getThreshold(){return this.outputOwners.threshold.value()}static fromBytes(t){const[e,r,n]=ur(t,[pr,Fr]);return[new Mr(e,r),n]}toBytes(t){return fr([this.amt,this.outputOwners],t)}};var qr;Cr=Mr=f([t=>{},d("design:paramtypes",[pr,Fr])],Cr);let jr=qr=class{input;mintOutput;transferOutput;_type=Pe.SecpMintOperation;constructor(t,e,r){this.input=t,this.mintOutput=e,this.transferOutput=r}static fromBytes(t){const[e,r,n,s]=ur(t,[Rr,Ur,Cr]);return[new qr(e,r,n),s]}toBytes(t){return n(this.input.toBytes(t),this.mintOutput.toBytes(t),this.transferOutput.toBytes(t))}};var Lr;jr=qr=f([t=>{},d("design:paramtypes",[Rr,Ur,Cr])],jr);let Hr=Lr=class{outputOwners;_type=Pe.OutputOwnersList;constructor(t){this.outputOwners=t}static fromBytes(t,e){const[r,n]=sr(t,Fr,e);return[new Lr(r),n]}toBytes(t){return cr(this.outputOwners,t)}};var Zr;Hr=Lr=f([t=>{},d("design:paramtypes",[Array])],Hr);let Xr=Zr=class{amt;input;_type=Pe.TransferInput;constructor(t,e){this.amt=t,this.input=e}static fromBytes(t){const[e,r,n]=ur(t,[pr,Rr]);return[new Zr(e,r),n]}static fromNative(t,e){return new Zr(new pr(t),Rr.fromNative(e))}sigIndicies(){return this.input.values()}amount(){return this.amt.value()}toBytes(t){return fr([this.amt,this.input],t)}};Xr=Zr=f([t=>{},d("design:paramtypes",[pr,Rr])],Xr);const Gr=Object.freeze([Xr,Ur,Cr,jr,Pr]);var Kr;let $r=Kr=class{txID;outputIdx;_type=Pe.UTXOID;constructor(t,e){this.txID=t,this.outputIdx=e}static fromBytes(t,e){const[r,n,s]=ur(t,[Ve,rr],e);return[new Kr(r,n),s]}static fromNative(t,e){return new Kr(Ve.fromString(t),new rr(e))}static compare(t,e){const r=Ve.compare(t.txID,e.txID);return 0!==r?r:t.outputIdx.value()-e.outputIdx.value()}toBytes(t){return fr([this.txID,this.outputIdx],t)}ID(){return Ne.encode(o(n(new pr(BigInt(this.outputIdx.value())).toBytes(),this.txID.toBytes())))}};var zr;$r=Kr=f([t=>{},d("design:paramtypes",[Ve,rr])],$r);let Yr=zr=class{utxoID;assetId;input;_type=Pe.TransferableInput;constructor(t,e,r){this.utxoID=t,this.assetId=e,this.input=r}static fromBytes(t,e){const[r,n,s]=ur(t,[$r,Ve]),[a,i]=e.UnpackPrefix(s);return[new zr(r,n,a),i]}static fromNative(t,e,r,n,s){return new zr($r.fromNative(t,e),Ve.fromString(r),new Xr(new pr(n),new Rr(s.map((t=>new rr(t))))))}static fromUtxoAndSigindicies(t,e){const r=t.output;if(!Br(r))throw new Error("utxo.output must be Transferout");return new zr(t.utxoId,t.assetId,Xr.fromNative(r.amount(),e))}sigIndicies(){const t=this.input;if(Sr(t))return t.sigIndicies();if(Or(t)){const e=t.transferableInput;if(Sr(e))return e.sigIndicies()}throw new Error("Input must be TransferInput or StakeableLockIn")}static compare(t,e){return $r.compare(t.utxoID,e.utxoID)}amount(){return this.input.amount()}getAssetId(){return this.assetId.toString()}toBytes(t){return n(fr([this.utxoID,this.assetId],t),t.PackPrefix(this.input))}};var Jr;Yr=zr=f([t=>{},d("design:paramtypes",[$r,Ve,Object])],Yr);let Wr=Jr=class{assetId;output;_type=Pe.TransferableOutput;constructor(t,e){this.assetId=t,this.output=e}static fromNative(t,e,r,n,s){return new Jr(Ve.fromString(t),new Cr(new pr(e),Fr.fromNative(r,n,s)))}static fromBytes(t,e){const[r,n]=ur(t,[Ve],e),[s,a]=e.UnpackPrefix(n);return[new Jr(r,s),a]}getAssetId(){return this.assetId.toString()}amount(){return this.output.amount()}toBytes(t){return n(fr([this.assetId],t),t.PackPrefix(this.output))}};var Qr;Wr=Jr=f([t=>{},d("design:paramtypes",[Ve,Object])],Wr);let tn=Qr=class{NetworkId;BlockchainId;outputs;inputs;memo;_type=Pe.BaseTx;constructor(t,e,r,n,s){this.NetworkId=t,this.BlockchainId=e,this.outputs=r,this.inputs=n,this.memo=s}static fromBytes(t,e){const[r,n,s,a,i,o]=ur(t,[rr,Ve,ir(Wr),ir(Yr),gr],e);return[new Qr(r,n,s,a,i),o]}static fromNative(t,e,r,n,s){return new Qr(new rr(t),Ve.fromString(e),r,n,new gr(s))}toBytes(t){return n(fr([this.NetworkId,this.BlockchainId],t),cr(this.outputs,t),cr(this.inputs,t),this.memo.toBytes())}};tn=Qr=f([t=>{},d("design:paramtypes",[rr,Ve,Array,Array,gr])],tn);class en extends er{vm=Se}var rn;let nn=rn=class extends en{baseTx;_type=Pe.AvmBaseTx;constructor(t){super(),this.baseTx=t}static fromBytes(t,e){const[r,n]=ur(t,[tn],e);return[new rn(r),n]}toBytes(t){return this.baseTx.toBytes(t)}};nn=rn=f([t=>{},d("design:paramtypes",[tn])],nn);let sn=class{typeIdToType;_type=Pe.Codec;typeToTypeID;constructor(t){this.typeIdToType=t,this.typeToTypeID=t.reduce(((t,e,r)=>e?t.set((new e)._type,r):t),new Map)}PackPrefix=t=>{const e=this.typeToTypeID.get(t._type);if(void 0===e)throw new Error(`can't marshal unregistered type: ${t._type.toString()}`);return n(nr(e),t.toBytes(this))};UnpackPrefix=t=>{let e;[e,t]=ur(t,[rr]);const r=this.typeIdToType[e.value()];if(void 0===r)throw new Error(`couldn't unmarshal interface: unknown type ID ${e.value()}`);const[n,s]=r.fromBytes(t,this);return[n,s]};static fromBytes(t,e){if(!e)throw new Error("codec required");return e.UnpackPrefix(t)}toBytes(){throw new Error("not implemented")}PackPrefixList(t){return n(nr(t.length),...t.map((t=>this.PackPrefix(t))))}};sn=f([t=>{},d("design:paramtypes",[Array])],sn);class an{codecs={};RegisterCodec(t,e){if(t in this.codecs)throw new Error("duplicated codec version");this.codecs[t]=e}unpack=(t,e)=>{const[r,n]=this.getCodecFromBuffer(t);return e.fromBytes(n,r)[0]};unpackTransaction=t=>{const[e,r]=this.getCodecFromBuffer(t);return e.UnpackPrefix(r)[0]};getCodecFromBuffer(t){const[e,r]=ur(t,[wr]);return[this.getCodecForVersion(e),r]}getCodecForVersion(t){if(!this.codecs[t.value()])throw new Error(`codec id(${t.value()}) not found`);return this.codecs[t.value()]}getDefaultCodec(){return this.getCodecForVersion(new wr(0))}getDefaultCodecId(){return new wr(0)}packCodec(t,e=0){const r=new wr(e),s=this.getCodecForVersion(r);return n(r.toBytes(),s.PackPrefix(t))}}var on;let cn=on=class{input;groupId;payload;outputOwnerList;_type=Pe.NftFxMintOperation;constructor(t,e,r,n){this.input=t,this.groupId=e,this.payload=r,this.outputOwnerList=n}static fromBytes(t){const[e,r,n,s,a]=ur(t,[Rr,rr,gr,Hr]);return[new on(e,r,n,s),a]}toBytes(t){return fr([this.input,this.groupId,this.payload,this.outputOwnerList],t)}};var un;cn=on=f([t=>{},d("design:paramtypes",[Rr,rr,gr,Hr])],cn);let fn=un=class{groupId;outputOwners;_type=Pe.NftFxMintOutput;constructor(t,e){this.groupId=t,this.outputOwners=e}static fromBytes(t,e){const[r,n,s]=ur(t,[rr,Fr],e);return[new un(r,n),s]}toBytes(t){return fr([this.groupId,this.outputOwners],t)}};var dn;fn=un=f([t=>{},d("design:paramtypes",[rr,Fr])],fn);let ln=dn=class{groupId;payload;outputOwners;_type=Pe.NftFxTransferOutput;constructor(t,e,r){this.groupId=t,this.payload=e,this.outputOwners=r}static fromBytes(t){const[e,r,n,s]=ur(t,[rr,gr,Fr]);return[new dn(e,r,n),s]}toBytes(t){return fr([this.groupId,this.payload,this.outputOwners],t)}};var pn;ln=dn=f([t=>{},d("design:paramtypes",[rr,gr,Fr])],ln);let hn=pn=class{input;output;_type=Pe.NftFxTransferOperation;constructor(t,e){this.input=t,this.output=e}static fromBytes(t){const[e,r,n]=ur(t,[Rr,ln]);return[new pn(e,r),n]}toBytes(t){return fr([this.input,this.output],t)}};hn=pn=f([t=>{},d("design:paramtypes",[Rr,ln])],hn);const mn=Object.freeze([fn,ln,cn,hn,class extends Pr{_type=Pe.NftFxCredential}]);var bn;let gn=bn=class{fxId;outputs;_type=Pe.InitialState;constructor(t,e){this.fxId=t,this.outputs=e}static fromBytes(t,e){const[r,n,s]=ur(t,[rr,or],e);return[new bn(r,n),s]}toBytes(t){return n(this.fxId.toBytes(),t.PackPrefixList(this.outputs))}};var yn;gn=bn=f([t=>{},d("design:paramtypes",[rr,Array])],gn);let wn=yn=class{baseTx;name;symbol;denomination;initialStates;_type=Pe.CreateAssetTx;constructor(t,e,r,n,s){this.baseTx=t,this.name=e,this.symbol=r,this.denomination=n,this.initialStates=s}static fromBytes(t,e){const[r,n,s,a,i,o]=ur(t,[tn,Ir,Ir,mr,ir(gn)],e);return[new yn(r,n,s,a,i),o]}toBytes(t){return n(fr([this.baseTx,this.name,this.symbol,this.denomination],t),cr(this.initialStates,t))}};var xn;wn=yn=f([t=>{},d("design:paramtypes",[tn,Ir,Ir,mr,Array])],wn);let In=xn=class extends en{baseTx;destination;outs;_type=Pe.AvmExportTx;constructor(t,e,r){super(),this.baseTx=t,this.destination=e,this.outs=r}static fromBytes(t,e){const[r,n,s,a]=ur(t,[tn,Ve,ir(Wr)],e);return[new xn(r,n,s),a]}toBytes(t){return n(fr([this.baseTx,this.destination],t),cr(this.outs,t))}};var Bn;In=xn=f([t=>{},d("design:paramtypes",[tn,Ve,Array])],In);let vn=Bn=class extends en{baseTx;sourceChain;ins;_type=Pe.AvmImportTx;constructor(t,e,r){super(),this.baseTx=t,this.sourceChain=e,this.ins=r}getSigIndices(){return this.ins.map((t=>t.sigIndicies())).concat(super.getSigIndices())}static fromBytes(t,e){const[r,n,s,a]=ur(t,[tn,Ve,ir(Yr)],e);return[new Bn(r,n,s),a]}toBytes(t){return n(fr([this.baseTx,this.sourceChain],t),cr(this.ins,t))}};var Tn;vn=Bn=f([t=>{},d("design:paramtypes",[tn,Ve,Array])],vn);let On=Tn=class{assetId;UTXOId;transferOp;_type=Pe.TransferableOp;constructor(t,e,r){this.assetId=t,this.UTXOId=e,this.transferOp=r}static fromBytes(t,e){const[r,n,s,a]=ur(t,[Ve,ir($r),sn],e);return[new Tn(r,n,s),a]}toBytes(t){return n(fr([this.assetId],t),cr(this.UTXOId,t),t.PackPrefix(this.transferOp))}};var Sn;On=Tn=f([t=>{},d("design:paramtypes",[Ve,Array,Object])],On);let En,An=Sn=class{baseTx;ops;_type=Pe.OperationTx;constructor(t,e){this.baseTx=t,this.ops=e}static fromBytes(t,e){const[r,n,s]=ur(t,[tn,ir(On)],e);return[new Sn(r,n),s]}toBytes(t){return n(this.baseTx.toBytes(t),cr(this.ops,t))}};An=Sn=f([t=>{},d("design:paramtypes",[tn,Array])],An);const kn=()=>En||(En=new an,En.RegisterCodec(0,new sn([nn,wn,An,vn,In,...Gr,...mn])),En);class Pn extends tr{vm=Ee;getBlockchainId=()=>this.blockchainId.toString()}var Dn;let Rn=class{static{Dn=this}address;amount;assetId;nonce;_type=Pe.EvmInput;constructor(t,e,r,n){this.address=t,this.amount=e,this.assetId=r,this.nonce=n}static fromBytes(t,e){const[r,n,s,a,i]=ur(t,[Re,pr,Ve,pr],e);return[new Dn(r,n,s,a),i]}static compare=(t,e)=>t.address.value()!==e.address.value()?t.address.value().localeCompare(e.address.value()):t.assetId.value().localeCompare(e.assetId.value());toBytes(t){return dr(t,this.address,this.amount,this.assetId,this.nonce)}};var Nn;Rn=Dn=f([t=>{},d("design:paramtypes",[Re,pr,Ve,pr])],Rn);let _n=Nn=class extends Pn{networkId;blockchainId;destinationChain;ins;exportedOutputs;_type=Pe.EvmExportTx;constructor(t,e,r,n,s){super(),this.networkId=t,this.blockchainId=e,this.destinationChain=r,this.ins=n,this.exportedOutputs=s}getSigIndices(){return[[0]]}static fromBytes(t,e){const[r,n,s,a,i,o]=ur(t,[rr,Ve,Ve,ir(Rn),ir(Wr)],e);return[new Nn(r,n,s,a,i),o]}toBytes(t){return dr(t,this.networkId,this.blockchainId,this.destinationChain,this.ins,this.exportedOutputs)}};var Fn;_n=Nn=f([t=>{},d("design:paramtypes",[rr,Ve,Ve,Array,Array])],_n);let Vn=Fn=class{address;amount;assetId;_type=Pe.EvmOutput;constructor(t,e,r){this.address=t,this.amount=e,this.assetId=r}static fromBytes(t,e){const[r,n,s,a]=ur(t,[Re,pr,Ve],e);return[new Fn(r,n,s),a]}toBytes(t){return dr(t,this.address,this.amount,this.assetId)}};var Un;Vn=Fn=f([t=>{},d("design:paramtypes",[Re,pr,Ve])],Vn);let Mn,Cn=Un=class extends Pn{networkId;blockchainId;sourceChain;importedInputs;Outs;_type=Pe.EvmImportTx;constructor(t,e,r,n,s){super(),this.networkId=t,this.blockchainId=e,this.sourceChain=r,this.importedInputs=n,this.Outs=s}getSigIndices(){return this.importedInputs.map((t=>t.sigIndicies()))}static fromBytes(t,e){const[r,n,s,a,i,o]=ur(t,[rr,Ve,Ve,ir(Yr),ir(Vn)],e);return[new Un(r,n,s,a,i),o]}toBytes(t){return dr(t,this.networkId,this.blockchainId,this.sourceChain,this.importedInputs,this.Outs)}};Cn=Un=f([t=>{},d("design:paramtypes",[rr,Ve,Ve,Array,Array])],Cn);const qn=new sn([Cn,_n,...Array(3).fill(void 0),...Gr,Rr,Fr]),jn=()=>Mn||(Mn=new an,Mn.RegisterCodec(0,qn),Mn);class Ln extends er{vm=Ae}var Hn;let Zn=Hn=class{nodeId;startTime;endTime;weight;_type=Pe.Validator;constructor(t,e,r,n){this.nodeId=t,this.startTime=e,this.endTime=r,this.weight=n}static fromNative(t,e,r,n){return new Hn(Ce.fromString(t),new pr(e),new pr(r),new pr(n))}static fromBytes(t,e){const[r,n,s,a,i]=ur(t,[Ce,pr,pr,pr],e);return[new Hn(r,n,s,a),i]}toBytes(t){return fr([this.nodeId,this.startTime,this.endTime,this.weight],t)}};var Xn;Zn=Hn=f([t=>{},d("design:paramtypes",[Ce,pr,pr,pr])],Zn);let Gn=Xn=class extends Ln{baseTx;validator;stake;rewardsOwner;_type=Pe.AddDelegatorTx;constructor(t,e,r,n){super(),this.baseTx=t,this.validator=e,this.stake=r,this.rewardsOwner=n}getRewardsOwner(){return this.rewardsOwner}static fromBytes(t,e){const[r,n,s,a,i]=ur(t,[tn,Zn,ir(Wr),sn],e);return[new Xn(r,n,s,a),i]}toBytes(t){return n(fr([this.baseTx,this.validator,this.stake],t),t.PackPrefix(this.rewardsOwner))}};Gn=Xn=f([t=>{},d("design:paramtypes",[tn,Zn,Array,Object])],Gn);class Kn extends Ln{getSubnetAuth(){return this.subnetAuth}getSigIndices(){return[...this.getInputs().map((t=>t.sigIndicies())),this.getSubnetAuth().values()].filter((t=>void 0!==t))}}var $n;let zn=$n=class{validator;subnetId;_type=Pe.SubnetValidator;constructor(t,e){this.validator=t,this.subnetId=e}static fromNative(t,e,r,n,s){return new $n(Zn.fromNative(t,e,r,n),s)}static fromBytes(t,e){const[r,n,s]=ur(t,[Zn,Ve],e);return[new $n(r,n),s]}toBytes(t){return fr([this.validator,this.subnetId],t)}};var Yn;zn=$n=f([t=>{},d("design:paramtypes",[Zn,Ve])],zn);let Jn=Yn=class extends Kn{baseTx;subnetValidator;subnetAuth;_type=Pe.AddSubnetValidatorTx;constructor(t,e,r){super(),this.baseTx=t,this.subnetValidator=e,this.subnetAuth=r}getSubnetID(){return this.subnetValidator.subnetId}static fromBytes(t,e){const[r,n,s,a]=ur(t,[tn,zn,sn],e);return[new Yn(r,n,s),a]}toBytes(t){return n(fr([this.baseTx,this.subnetValidator],t),t.PackPrefix(this.subnetAuth))}};var Wn;Jn=Yn=f([t=>{},d("design:paramtypes",[tn,zn,Object])],Jn);let Qn=Wn=class extends Ln{baseTx;validator;stake;rewardsOwner;shares;_type=Pe.AddValidatorTx;constructor(t,e,r,n,s){super(),this.baseTx=t,this.validator=e,this.stake=r,this.rewardsOwner=n,this.shares=s}getRewardsOwner(){return this.rewardsOwner}static fromBytes(t,e){const[r,n,s,a,i,o]=ur(t,[tn,Zn,ir(Wr),sn,rr],e);return[new Wn(r,n,s,a,i),o]}toBytes(t){return n(fr([this.baseTx,this.validator],t),cr(this.stake,t),t.PackPrefix(this.rewardsOwner),this.shares.toBytes())}};var ts;Qn=Wn=f([t=>{},d("design:paramtypes",[tn,Zn,Array,Object,rr])],Qn);let es=ts=class extends Ln{time;_type=Pe.AdvanceTimeTx;constructor(t){super(),this.time=t}baseTx=void 0;static fromBytes(t,e){const[r,n]=ur(t,[pr],e);return[new ts(r),n]}toBytes(t){return dr(t,this.time)}};var rs;es=ts=f([t=>{},d("design:paramtypes",[pr])],es);let ns=rs=class extends Kn{baseTx;subnetID;chainName;vmID;fxIds;genesisData;subnetAuth;_type=Pe.CreateChainTx;constructor(t,e,r,n,s,a,i){super(),this.baseTx=t,this.subnetID=e,this.chainName=r,this.vmID=n,this.fxIds=s,this.genesisData=a,this.subnetAuth=i}getSubnetID(){return this.subnetID}static fromBytes(t,e){const[r,n,s,a,i,o,c,u]=ur(t,[tn,Ve,Ir,Ve,ir(Ve),gr,sn],e);return[new rs(r,n,s,a,i,o,c),u]}toBytes(t){return n(fr([this.baseTx,this.subnetID,this.chainName,this.vmID],t),cr(this.fxIds,t),this.genesisData.toBytes(),t.PackPrefix(this.subnetAuth))}};var ss;ns=rs=f([t=>{},d("design:paramtypes",[tn,Ve,Ir,Ve,Array,gr,Object])],ns);let as=ss=class extends Ln{baseTx;subnetOwners;_type=Pe.CreateSubnetTx;constructor(t,e){super(),this.baseTx=t,this.subnetOwners=e}getSubnetOwners(){return this.subnetOwners}static fromBytes(t,e){const[r,n,s]=ur(t,[tn,sn],e);return[new ss(r,n),s]}toBytes(t){return n(fr([this.baseTx],t),t.PackPrefix(this.subnetOwners))}};var is;as=ss=f([t=>{},d("design:paramtypes",[tn,Object])],as);let os=is=class extends Ln{baseTx;destination;outs;_type=Pe.PvmExportTx;constructor(t,e,r){super(),this.baseTx=t,this.destination=e,this.outs=r}static fromBytes(t,e){const[r,n,s,a]=ur(t,[tn,Ve,ir(Wr)],e);return[new is(r,n,s),a]}toBytes(t){return dr(t,this.baseTx,this.destination,this.outs)}};var cs;os=is=f([t=>{},d("design:paramtypes",[tn,Ve,Array])],os);let us=cs=class extends Ln{baseTx;sourceChain;ins;_type=Pe.PvmImportTx;constructor(t,e,r){super(),this.baseTx=t,this.sourceChain=e,this.ins=r}getSigIndices(){return this.ins.map((t=>t.sigIndicies()))}static fromBytes(t,e){const[r,n,s,a]=ur(t,[tn,Ve,ir(Yr)],e);return[new cs(r,n,s),a]}toBytes(t){return fr([this.baseTx,this.sourceChain,this.ins],t)}};var fs;us=cs=f([t=>{},d("design:paramtypes",[tn,Ve,Array])],us);let ds=fs=class extends Ln{txId;_type=Pe.RewardValidatorTx;constructor(t){super(),this.txId=t}baseTx=void 0;static fromBytes(t,e){const[r,n]=ur(t,[Ve],e);return[new fs(r),n]}toBytes(t){return dr(t,this.txId)}};var ls;ds=fs=f([t=>{},d("design:paramtypes",[Ve])],ds);let ps=ls=class{lockTime;transferableInput;_type=Pe.StakeableLockIn;constructor(t,e){this.lockTime=t,this.transferableInput=e}static fromBytes(t,e){const[r,n]=ur(t,[pr],e),[s,a]=e.UnpackPrefix(n);return[new ls(r,s),a]}amount(){return this.transferableInput.amount()}toBytes(t){return n(dr(t,this.lockTime),t.PackPrefix(this.transferableInput))}};var hs;ps=ls=f([t=>{},d("design:paramtypes",[pr,Object])],ps);let ms=hs=class{lockTime;transferOut;_type=Pe.StakeableLockOut;constructor(t,e){this.lockTime=t,this.transferOut=e}amount(){return this.transferOut.amount()}getStakeableLocktime(){return this.lockTime.value()}getLocktime(){return this.lockTime.value()}static fromBytes(t,e){const[r,n,s]=ur(t,[pr,sn],e);return[new hs(r,n),s]}getOwners(){if(Br(this.transferOut))return this.transferOut.getOwners();throw new Error("Unable to get owners.")}getOutputOwners(){if(Br(this.transferOut))return this.transferOut.outputOwners;throw new Error("Unable to get output owners.")}toBytes(t){return n(dr(t,this.lockTime),t.PackPrefix(this.transferOut))}};var bs;ms=hs=f([t=>{},d("design:paramtypes",[pr,Object])],ms);let gs=bs=class extends Ln{baseTx;subnetValidator;signer;stake;validatorRewardsOwner;delegatorRewardsOwner;shares;_type=Pe.AddPermissionlessValidatorTx;constructor(t,e,r,n,s,a,i){super(),this.baseTx=t,this.subnetValidator=e,this.signer=r,this.stake=n,this.validatorRewardsOwner=s,this.delegatorRewardsOwner=a,this.shares=i}getValidatorRewardsOwner(){return this.validatorRewardsOwner}getDelegatorRewardsOwner(){return this.delegatorRewardsOwner}static fromBytes(t,e){const[r,n,s,a,i,o,c,u]=ur(t,[tn,zn,sn,ir(Wr),sn,sn,rr],e);return[new bs(r,n,s,a,i,o,c),u]}toBytes(t){return n(fr([this.baseTx,this.subnetValidator],t),t.PackPrefix(this.signer),cr(this.stake,t),t.PackPrefix(this.validatorRewardsOwner),t.PackPrefix(this.delegatorRewardsOwner),this.shares.toBytes())}};var ys;gs=bs=f([t=>{},d("design:paramtypes",[tn,zn,Function,Array,Object,Object,rr])],gs);let ws=ys=class extends Ln{baseTx;subnetValidator;stake;delegatorRewardsOwner;_type=Pe.AddPermissionlessDelegatorTx;constructor(t,e,r,n){super(),this.baseTx=t,this.subnetValidator=e,this.stake=r,this.delegatorRewardsOwner=n}getDelegatorRewardsOwner(){return this.delegatorRewardsOwner}static fromBytes(t,e){const[r,n,s,a,i]=ur(t,[tn,zn,ir(Wr),sn],e);return[new ys(r,n,s,a),i]}toBytes(t){return n(fr([this.baseTx,this.subnetValidator],t),cr(this.stake,t),t.PackPrefix(this.delegatorRewardsOwner))}};function xs(t,e){return Is(o(t),e)}async function Is(t,e){const r=await pe.sign(t,e);if(void 0!==r.recovery)return n(r.toCompactRawBytes(),new Uint8Array([r.recovery]));throw new Error("Recovery bit is missing.")}function Bs(t,e){const r=e.slice(-1);return pe.Signature.fromCompact(e.slice(0,-1)).addRecoveryBit(r[0]).recoverPublicKey(t).toRawBytes(!0)}function vs(t){return pe.getPublicKey(t,!0)}function Ts(t){return c(o(t))}function Os(t){return ve(we.fromPublicKey(t))}ws=ys=f([t=>{},d("design:paramtypes",[tn,zn,Array,Object])],ws);var Ss=Object.freeze({__proto__:null,getPublicKey:vs,publicKeyBytesToAddress:Ts,publicKeyToEthAddress:Os,randomPrivateKey:function(){return pe.utils.randomPrivateKey()},recoverPublicKey:Bs,sign:xs,signHash:Is,verify:function(t,e,r){return pe.verify(t.slice(0,-1),e,r)}});const Es=BigInt(2),As=BigInt(3);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ks=BigInt(0),Ps=BigInt(1),Ds=BigInt(2),Rs=BigInt(3),Ns=BigInt(4),_s=BigInt(8),Fs=BigInt(16),Vs=BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab"),Us=Rt(Vs),Ms=Rt(BigInt("0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001")),Cs=({c0:t,c1:e},{c0:r,c1:n})=>({c0:Us.add(t,r),c1:Us.add(e,n)}),qs=({c0:t,c1:e},{c0:r,c1:n})=>({c0:Us.sub(t,r),c1:Us.sub(e,n)}),js=({c0:t,c1:e},r)=>{if("bigint"==typeof r)return{c0:Us.mul(t,r),c1:Us.mul(e,r)};const{c0:n,c1:s}=r;let a=Us.mul(t,n),i=Us.mul(e,s);return{c0:Us.sub(a,i),c1:Us.sub(Us.mul(Us.add(t,e),Us.add(n,s)),Us.add(a,i))}},Ls=({c0:t,c1:e})=>{const r=Us.add(t,e),n=Us.sub(t,e),s=Us.add(t,t);return{c0:Us.mul(r,n),c1:Us.mul(s,e)}},Hs=Vs*Vs,Zs={ORDER:Hs,BITS:it(Hs),BYTES:Math.ceil(it(Hs)/8),MASK:ct(it(Hs)),ZERO:{c0:Us.ZERO,c1:Us.ZERO},ONE:{c0:Us.ONE,c1:Us.ZERO},create:t=>t,isValid:({c0:t,c1:e})=>"bigint"==typeof t&&"bigint"==typeof e,is0:({c0:t,c1:e})=>Us.is0(t)&&Us.is0(e),eql:({c0:t,c1:e},{c0:r,c1:n})=>Us.eql(t,r)&&Us.eql(e,n),neg:({c0:t,c1:e})=>({c0:Us.neg(t),c1:Us.neg(e)}),pow:(t,e)=>kt(Zs,t,e),invertBatch:t=>Pt(Zs,t),add:Cs,sub:qs,mul:js,sqr:Ls,addN:Cs,subN:qs,mulN:js,sqrN:Ls,div:(t,e)=>Zs.mul(t,"bigint"==typeof e?Us.inv(Us.create(e)):Zs.inv(e)),inv:({c0:t,c1:e})=>{const r=Us.inv(Us.create(t*t+e*e));return{c0:Us.mul(r,Us.create(t)),c1:Us.mul(r,Us.create(-e))}},sqrt:t=>{if(Zs.eql(t,Zs.ZERO))return Zs.ZERO;const e=Zs.pow(t,(Zs.ORDER+_s)/Fs),r=Zs.div(Zs.sqr(e),t),n=Ks,s=[n[0],n[2],n[4],n[6]].find((t=>Zs.eql(t,r)));if(!s)throw new Error("No root");const a=n.indexOf(s),i=n[a/2];if(!i)throw new Error("Invalid root");const o=Zs.div(e,i),c=Zs.neg(o),{re:u,im:f}=Zs.reim(o),{re:d,im:l}=Zs.reim(c);return f>l||f===l&&u>d?o:c},isOdd:t=>{const{re:e,im:r}=Zs.reim(t);return BigInt(e%Ds||e===ks&&r%Ds)==Ps},fromBytes(t){if(t.length!==Zs.BYTES)throw new Error(`fromBytes wrong length=${t.length}`);return{c0:Us.fromBytes(t.subarray(0,Us.BYTES)),c1:Us.fromBytes(t.subarray(Us.BYTES))}},toBytes:({c0:t,c1:e})=>st(Us.toBytes(t),Us.toBytes(e)),cmov:({c0:t,c1:e},{c0:r,c1:n},s)=>({c0:Us.cmov(t,r,s),c1:Us.cmov(e,n,s)}),reim:({c0:t,c1:e})=>({re:t,im:e}),mulByNonresidue:({c0:t,c1:e})=>({c0:Us.sub(t,e),c1:Us.add(t,e)}),multiplyByB:({c0:t,c1:e})=>{let r=Us.mul(t,Ns),n=Us.mul(e,Ns);return{c0:Us.sub(r,n),c1:Us.add(r,n)}},fromBigTuple:t=>{if(2!==t.length)throw new Error("Invalid tuple");const e=t.map((t=>Us.create(t)));return{c0:e[0],c1:e[1]}},frobeniusMap:({c0:t,c1:e},r)=>({c0:t,c1:Us.mul(e,Xs[r%2])})},Xs=[BigInt("0x1"),BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa")].map((t=>Us.create(t))),Gs=BigInt("0x6af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09"),Ks=[[Ps,ks],[Gs,-Gs],[ks,Ps],[Gs,Gs],[-Ps,ks],[-Gs,Gs],[ks,-Ps],[-Gs,-Gs]].map((t=>Zs.fromBigTuple(t))),$s=({c0:t,c1:e,c2:r},{c0:n,c1:s,c2:a})=>({c0:Zs.add(t,n),c1:Zs.add(e,s),c2:Zs.add(r,a)}),zs=({c0:t,c1:e,c2:r},{c0:n,c1:s,c2:a})=>({c0:Zs.sub(t,n),c1:Zs.sub(e,s),c2:Zs.sub(r,a)}),Ys=({c0:t,c1:e,c2:r},n)=>{if("bigint"==typeof n)return{c0:Zs.mul(t,n),c1:Zs.mul(e,n),c2:Zs.mul(r,n)};const{c0:s,c1:a,c2:i}=n,o=Zs.mul(t,s),c=Zs.mul(e,a),u=Zs.mul(r,i);return{c0:Zs.add(o,Zs.mulByNonresidue(Zs.sub(Zs.mul(Zs.add(e,r),Zs.add(a,i)),Zs.add(c,u)))),c1:Zs.add(Zs.sub(Zs.mul(Zs.add(t,e),Zs.add(s,a)),Zs.add(o,c)),Zs.mulByNonresidue(u)),c2:Zs.sub(Zs.add(c,Zs.mul(Zs.add(t,r),Zs.add(s,i))),Zs.add(o,u))}},Js=({c0:t,c1:e,c2:r})=>{let n=Zs.sqr(t),s=Zs.mul(Zs.mul(t,e),Ds),a=Zs.mul(Zs.mul(e,r),Ds),i=Zs.sqr(r);return{c0:Zs.add(Zs.mulByNonresidue(a),n),c1:Zs.add(Zs.mulByNonresidue(i),s),c2:Zs.sub(Zs.sub(Zs.add(Zs.add(s,Zs.sqr(Zs.add(Zs.sub(t,e),r))),a),n),i)}},Ws={ORDER:Zs.ORDER,BITS:3*Zs.BITS,BYTES:3*Zs.BYTES,MASK:ct(3*Zs.BITS),ZERO:{c0:Zs.ZERO,c1:Zs.ZERO,c2:Zs.ZERO},ONE:{c0:Zs.ONE,c1:Zs.ZERO,c2:Zs.ZERO},create:t=>t,isValid:({c0:t,c1:e,c2:r})=>Zs.isValid(t)&&Zs.isValid(e)&&Zs.isValid(r),is0:({c0:t,c1:e,c2:r})=>Zs.is0(t)&&Zs.is0(e)&&Zs.is0(r),neg:({c0:t,c1:e,c2:r})=>({c0:Zs.neg(t),c1:Zs.neg(e),c2:Zs.neg(r)}),eql:({c0:t,c1:e,c2:r},{c0:n,c1:s,c2:a})=>Zs.eql(t,n)&&Zs.eql(e,s)&&Zs.eql(r,a),sqrt:()=>{throw new Error("Not implemented")},div:(t,e)=>Ws.mul(t,"bigint"==typeof e?Us.inv(Us.create(e)):Ws.inv(e)),pow:(t,e)=>kt(Ws,t,e),invertBatch:t=>Pt(Ws,t),add:$s,sub:zs,mul:Ys,sqr:Js,addN:$s,subN:zs,mulN:Ys,sqrN:Js,inv:({c0:t,c1:e,c2:r})=>{let n=Zs.sub(Zs.sqr(t),Zs.mulByNonresidue(Zs.mul(r,e))),s=Zs.sub(Zs.mulByNonresidue(Zs.sqr(r)),Zs.mul(t,e)),a=Zs.sub(Zs.sqr(e),Zs.mul(t,r)),i=Zs.inv(Zs.add(Zs.mulByNonresidue(Zs.add(Zs.mul(r,s),Zs.mul(e,a))),Zs.mul(t,n)));return{c0:Zs.mul(i,n),c1:Zs.mul(i,s),c2:Zs.mul(i,a)}},fromBytes:t=>{if(t.length!==Ws.BYTES)throw new Error(`fromBytes wrong length=${t.length}`);return{c0:Zs.fromBytes(t.subarray(0,Zs.BYTES)),c1:Zs.fromBytes(t.subarray(Zs.BYTES,2*Zs.BYTES)),c2:Zs.fromBytes(t.subarray(2*Zs.BYTES))}},toBytes:({c0:t,c1:e,c2:r})=>st(Zs.toBytes(t),Zs.toBytes(e),Zs.toBytes(r)),cmov:({c0:t,c1:e,c2:r},{c0:n,c1:s,c2:a},i)=>({c0:Zs.cmov(t,n,i),c1:Zs.cmov(e,s,i),c2:Zs.cmov(r,a,i)}),fromBigSix:t=>{if(!Array.isArray(t)||6!==t.length)throw new Error("Invalid Fp6 usage");return{c0:Zs.fromBigTuple(t.slice(0,2)),c1:Zs.fromBigTuple(t.slice(2,4)),c2:Zs.fromBigTuple(t.slice(4,6))}},frobeniusMap:({c0:t,c1:e,c2:r},n)=>({c0:Zs.frobeniusMap(t,n),c1:Zs.mul(Zs.frobeniusMap(e,n),Qs[n%6]),c2:Zs.mul(Zs.frobeniusMap(r,n),ta[n%6])}),mulByNonresidue:({c0:t,c1:e,c2:r})=>({c0:Zs.mulByNonresidue(r),c1:t,c2:e}),multiplyBy1:({c0:t,c1:e,c2:r},n)=>({c0:Zs.mulByNonresidue(Zs.mul(r,n)),c1:Zs.mul(t,n),c2:Zs.mul(e,n)}),multiplyBy01({c0:t,c1:e,c2:r},n,s){let a=Zs.mul(t,n),i=Zs.mul(e,s);return{c0:Zs.add(Zs.mulByNonresidue(Zs.sub(Zs.mul(Zs.add(e,r),s),i)),a),c1:Zs.sub(Zs.sub(Zs.mul(Zs.add(n,s),Zs.add(t,e)),a),i),c2:Zs.add(Zs.sub(Zs.mul(Zs.add(t,r),n),a),i)}},multiplyByFp2:({c0:t,c1:e,c2:r},n)=>({c0:Zs.mul(t,n),c1:Zs.mul(e,n),c2:Zs.mul(r,n)})},Qs=[[BigInt("0x1"),BigInt("0x0")],[BigInt("0x0"),BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"),BigInt("0x0")],[BigInt("0x0"),BigInt("0x1")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac"),BigInt("0x0")],[BigInt("0x0"),BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe")]].map((t=>Zs.fromBigTuple(t))),ta=[[BigInt("0x1"),BigInt("0x0")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad"),BigInt("0x0")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac"),BigInt("0x0")],[BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa"),BigInt("0x0")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"),BigInt("0x0")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff"),BigInt("0x0")]].map((t=>Zs.fromBigTuple(t))),ea=BigInt("0xd201000000010000"),ra=it(ea),na=({c0:t,c1:e},{c0:r,c1:n})=>({c0:Ws.add(t,r),c1:Ws.add(e,n)}),sa=({c0:t,c1:e},{c0:r,c1:n})=>({c0:Ws.sub(t,r),c1:Ws.sub(e,n)}),aa=({c0:t,c1:e},r)=>{if("bigint"==typeof r)return{c0:Ws.mul(t,r),c1:Ws.mul(e,r)};let{c0:n,c1:s}=r,a=Ws.mul(t,n),i=Ws.mul(e,s);return{c0:Ws.add(a,Ws.mulByNonresidue(i)),c1:Ws.sub(Ws.mul(Ws.add(t,e),Ws.add(n,s)),Ws.add(a,i))}},ia=({c0:t,c1:e})=>{let r=Ws.mul(t,e);return{c0:Ws.sub(Ws.sub(Ws.mul(Ws.add(Ws.mulByNonresidue(e),t),Ws.add(t,e)),r),Ws.mulByNonresidue(r)),c1:Ws.add(r,r)}};function oa(t,e){const r=Zs.sqr(t),n=Zs.sqr(e);return{first:Zs.add(Zs.mulByNonresidue(n),r),second:Zs.sub(Zs.sub(Zs.sqr(Zs.add(t,e)),r),n)}}const ca={ORDER:Zs.ORDER,BITS:2*Zs.BITS,BYTES:2*Zs.BYTES,MASK:ct(2*Zs.BITS),ZERO:{c0:Ws.ZERO,c1:Ws.ZERO},ONE:{c0:Ws.ONE,c1:Ws.ZERO},create:t=>t,isValid:({c0:t,c1:e})=>Ws.isValid(t)&&Ws.isValid(e),is0:({c0:t,c1:e})=>Ws.is0(t)&&Ws.is0(e),neg:({c0:t,c1:e})=>({c0:Ws.neg(t),c1:Ws.neg(e)}),eql:({c0:t,c1:e},{c0:r,c1:n})=>Ws.eql(t,r)&&Ws.eql(e,n),sqrt:()=>{throw new Error("Not implemented")},inv:({c0:t,c1:e})=>{let r=Ws.inv(Ws.sub(Ws.sqr(t),Ws.mulByNonresidue(Ws.sqr(e))));return{c0:Ws.mul(t,r),c1:Ws.neg(Ws.mul(e,r))}},div:(t,e)=>ca.mul(t,"bigint"==typeof e?Us.inv(Us.create(e)):ca.inv(e)),pow:(t,e)=>kt(ca,t,e),invertBatch:t=>Pt(ca,t),add:na,sub:sa,mul:aa,sqr:ia,addN:na,subN:sa,mulN:aa,sqrN:ia,fromBytes:t=>{if(t.length!==ca.BYTES)throw new Error(`fromBytes wrong length=${t.length}`);return{c0:Ws.fromBytes(t.subarray(0,Ws.BYTES)),c1:Ws.fromBytes(t.subarray(Ws.BYTES))}},toBytes:({c0:t,c1:e})=>st(Ws.toBytes(t),Ws.toBytes(e)),cmov:({c0:t,c1:e},{c0:r,c1:n},s)=>({c0:Ws.cmov(t,r,s),c1:Ws.cmov(e,n,s)}),fromBigTwelve:t=>({c0:Ws.fromBigSix(t.slice(0,6)),c1:Ws.fromBigSix(t.slice(6,12))}),frobeniusMap(t,e){const r=Ws.frobeniusMap(t.c0,e),{c0:n,c1:s,c2:a}=Ws.frobeniusMap(t.c1,e),i=ua[e%12];return{c0:r,c1:Ws.create({c0:Zs.mul(n,i),c1:Zs.mul(s,i),c2:Zs.mul(a,i)})}},multiplyBy014:({c0:t,c1:e},r,n,s)=>{let a=Ws.multiplyBy01(t,r,n),i=Ws.multiplyBy1(e,s);return{c0:Ws.add(Ws.mulByNonresidue(i),a),c1:Ws.sub(Ws.sub(Ws.multiplyBy01(Ws.add(e,t),r,Zs.add(n,s)),a),i)}},multiplyByFp2:({c0:t,c1:e},r)=>({c0:Ws.multiplyByFp2(t,r),c1:Ws.multiplyByFp2(e,r)}),conjugate:({c0:t,c1:e})=>({c0:t,c1:Ws.neg(e)}),_cyclotomicSquare:({c0:t,c1:e})=>{const{c0:r,c1:n,c2:s}=t,{c0:a,c1:i,c2:o}=e,{first:c,second:u}=oa(r,i),{first:f,second:d}=oa(a,s),{first:l,second:p}=oa(n,o);let h=Zs.mulByNonresidue(p);return{c0:Ws.create({c0:Zs.add(Zs.mul(Zs.sub(c,r),Ds),c),c1:Zs.add(Zs.mul(Zs.sub(f,n),Ds),f),c2:Zs.add(Zs.mul(Zs.sub(l,s),Ds),l)}),c1:Ws.create({c0:Zs.add(Zs.mul(Zs.add(h,a),Ds),h),c1:Zs.add(Zs.mul(Zs.add(u,i),Ds),u),c2:Zs.add(Zs.mul(Zs.add(d,o),Ds),d)})}},_cyclotomicExp(t,e){let r=ca.ONE;for(let n=ra-1;n>=0;n--)r=ca._cyclotomicSquare(r),ot(e,n)&&(r=ca.mul(r,t));return r},finalExponentiate:t=>{const e=ea,r=ca.div(ca.frobeniusMap(t,6),t),n=ca.mul(ca.frobeniusMap(r,2),r),s=ca.conjugate(ca._cyclotomicExp(n,e)),a=ca.mul(ca.conjugate(ca._cyclotomicSquare(n)),s),i=ca.conjugate(ca._cyclotomicExp(a,e)),o=ca.conjugate(ca._cyclotomicExp(i,e)),c=ca.mul(ca.conjugate(ca._cyclotomicExp(o,e)),ca._cyclotomicSquare(s)),u=ca.conjugate(ca._cyclotomicExp(c,e)),f=ca.frobeniusMap(ca.mul(s,o),2),d=ca.frobeniusMap(ca.mul(i,n),3),l=ca.frobeniusMap(ca.mul(c,ca.conjugate(n)),1),p=ca.mul(ca.mul(u,ca.conjugate(a)),n);return ca.mul(ca.mul(ca.mul(f,d),l),p)}},ua=[[BigInt("0x1"),BigInt("0x0")],[BigInt("0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8"),BigInt("0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff"),BigInt("0x0")],[BigInt("0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2"),BigInt("0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09")],[BigInt("0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"),BigInt("0x0")],[BigInt("0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995"),BigInt("0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116")],[BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa"),BigInt("0x0")],[BigInt("0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3"),BigInt("0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac"),BigInt("0x0")],[BigInt("0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09"),BigInt("0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2")],[BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad"),BigInt("0x0")],[BigInt("0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116"),BigInt("0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995")]].map((t=>Zs.fromBigTuple(t))),fa=re(Zs,[[["0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6","0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6"],["0x0","0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a"],["0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e","0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d"],["0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1","0x0"]],[["0x0","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63"],["0xc","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f"],["0x1","0x0"]],[["0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706","0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706"],["0x0","0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be"],["0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c","0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f"],["0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10","0x0"]],[["0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb"],["0x0","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3"],["0x12","0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99"],["0x1","0x0"]]].map((t=>t.map((t=>Zs.fromBigTuple(t.map(BigInt))))))),da=re(Us,[["0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7","0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb","0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0","0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861","0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9","0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983","0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84","0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e","0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317","0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e","0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b","0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229"],["0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c","0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff","0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19","0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8","0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e","0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5","0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a","0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e","0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641","0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a","0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"],["0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33","0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696","0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6","0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb","0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb","0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0","0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2","0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29","0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587","0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30","0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132","0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e","0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8","0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133","0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b","0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604"],["0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1","0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d","0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2","0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416","0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d","0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac","0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c","0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9","0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a","0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55","0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8","0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092","0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc","0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7","0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f","0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"]].map((t=>t.map((t=>BigInt(t)))))),la=zt(Zs,{A:Zs.create({c0:Us.create(ks),c1:Us.create(BigInt(240))}),B:Zs.create({c0:Us.create(BigInt(1012)),c1:Us.create(BigInt(1012))}),Z:Zs.create({c0:Us.create(BigInt(-2)),c1:Us.create(BigInt(-1))})}),pa=zt(Us,{A:Us.create(BigInt("0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d")),B:Us.create(BigInt("0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0")),Z:Us.create(BigInt(11))}),ha=Ws.create({c0:Zs.ZERO,c1:Zs.ONE,c2:Zs.ZERO}),ma=ca.create({c0:ha,c1:Ws.ZERO}),ba=ca.create({c0:Ws.ZERO,c1:ha}),[ga,ya]=ca.invertBatch([ma,ba]);function wa(t,e){const r=e.toAffine(),n=(s=r.x,a=r.y,[ca.mul(ca.frobeniusMap(ca.multiplyByFp2(ga,s),1),ma).c0.c0,ca.mul(ca.frobeniusMap(ca.multiplyByFp2(ya,a),1),ba).c0.c0]);var s,a;return new t(n[0],n[1],Zs.ONE)}const xa=BigInt("0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac");function Ia(t,e){const r=e.toAffine(),n=(s=r.x,a=r.y,[Zs.mul(s,xa),Zs.neg(a)]);var s,a;return new t(n[0],n[1],Zs.ONE)}const Ba=Object.freeze({DST:"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",encodeDST:"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",p:Us.ORDER,m:2,k:128,expand:"xmd",hash:o}),va=Oa(Us.toBytes(ks),{infinity:!0,compressed:!0});function Ta(t){const e=224&(t=t.slice())[0],r=!!(e>>7&1),n=!!(e>>6&1),s=!!(e>>5&1);return t[0]&=31,{compressed:r,infinity:n,sort:s,value:t}}function Oa(t,e){if(224&t[0])throw new Error("setMask: non-empty mask");return e.compressed&&(t[0]|=128),e.infinity&&(t[0]|=64),e.sort&&(t[0]|=32),t}function Sa(t){t.assertValidity();const e=t.equals(Aa.G1.ProjectivePoint.ZERO),{x:r,y:n}=t.toAffine();if(e)return va.slice();const s=Us.ORDER,a=Boolean(n*Ds/s);return Oa(et(r,Us.BYTES),{compressed:!0,sort:a})}function Ea(t){t.assertValidity();const e=Us.BYTES;if(t.equals(Aa.G2.ProjectivePoint.ZERO))return st(va,et(ks,e));const{x:r,y:n}=t.toAffine(),{re:s,im:a}=Zs.reim(r),{re:i,im:o}=Zs.reim(n),c=Boolean((o>ks?o*Ds:i*Ds)/Us.ORDER&Ps),u=s;return st(Oa(et(a,e),{sort:c,compressed:!0}),et(u,e))}const Aa=function(t){const{Fp:e,Fr:r,Fp2:n,Fp6:s,Fp12:a}=t.fields,i=it(t.params.x);function o(e){const{x:r,y:s}=e,a=r,o=s;let c=a,u=o,f=n.ONE,d=[];for(let e=i-2;e>=0;e--){let r=n.sqr(u),s=n.sqr(f),i=n.multiplyByB(n.mul(s,As)),l=n.mul(i,As),p=n.sub(n.sub(n.sqr(n.add(u,f)),s),r);if(d.push([n.sub(i,r),n.mul(n.sqr(c),As),n.neg(p)]),c=n.div(n.mul(n.mul(n.sub(r,l),c),u),Es),u=n.sub(n.sqr(n.div(n.add(r,l),Es)),n.mul(n.sqr(i),As)),f=n.mul(r,p),ot(t.params.x,e)){let t=n.sub(u,n.mul(o,f)),e=n.sub(c,n.mul(a,f));d.push([n.sub(n.mul(t,a),n.mul(e,o)),n.neg(t),e]);let r=n.sqr(e),s=n.mul(r,e),i=n.mul(r,c),l=n.add(n.sub(s,n.mul(i,Es)),n.mul(n.sqr(t),f));c=n.mul(e,l),u=n.sub(n.mul(n.sub(i,l),t),n.mul(s,u)),f=n.mul(f,s)}}return d}function c(e,r){const{x:s}=t.params,o=r[0],c=r[1];let u=a.ONE;for(let t=0,r=i-2;r>=0;r--,t++){const i=e[t];if(u=a.multiplyBy014(u,i[0],n.mul(i[1],o),n.mul(i[2],c)),ot(s,r)){t+=1;const r=e[t];u=a.multiplyBy014(u,r[0],n.mul(r[1],o),n.mul(r[2],c))}0!==r&&(u=a.sqr(u))}return a.conjugate(u)}const u={randomPrivateKey:()=>{const e=_t(r.ORDER);return Ft(t.randomBytes(e),r.ORDER)},calcPairingPrecomputes:o},f=Kt({n:r.ORDER,...t.G1}),d=Object.assign(f,ne(f.ProjectivePoint,t.G1.mapToCurve,{...t.htfDefaults,...t.G1.htfDefaults})),l=Kt({n:r.ORDER,...t.G2}),p=Object.assign(l,ne(l.ProjectivePoint,t.G2.mapToCurve,{...t.htfDefaults,...t.G2.htfDefaults})),{ShortSignature:h}=t.G1,{Signature:m}=t.G2;function b(t,e,r=!0){if(t.equals(d.ProjectivePoint.ZERO)||e.equals(p.ProjectivePoint.ZERO))throw new Error("pairing is not available for ZERO point");t.assertValidity(),e.assertValidity();const n=t.toAffine(),s=c(function(t){const e=t;return e._PPRECOMPUTES||(e._PPRECOMPUTES=o(t.toAffine())),e._PPRECOMPUTES}(e),[n.x,n.y]);return r?a.finalExponentiate(s):s}function g(t){return t instanceof d.ProjectivePoint?t:d.ProjectivePoint.fromHex(t)}function y(t,e){return t instanceof d.ProjectivePoint?t:d.hashToCurve(nt("point",t),e)}function w(t){return t instanceof p.ProjectivePoint?t:m.fromHex(t)}function x(t,e){return t instanceof p.ProjectivePoint?t:p.hashToCurve(nt("point",t),e)}return d.ProjectivePoint.BASE._setWindowSize(4),{getPublicKey:function(t){return d.ProjectivePoint.fromPrivateKey(t).toRawBytes(!0)},getPublicKeyForShortSignatures:function(t){return p.ProjectivePoint.fromPrivateKey(t).toRawBytes(!0)},sign:function(t,e,r){const n=x(t,r);n.assertValidity();const s=n.multiply(d.normPrivateKeyToScalar(e));return t instanceof p.ProjectivePoint?s:m.toRawBytes(s)},signShortSignature:function(t,e,r){const n=y(t,r);n.assertValidity();const s=n.multiply(d.normPrivateKeyToScalar(e));return t instanceof d.ProjectivePoint?s:h.toRawBytes(s)},verify:function(t,e,r,n){const s=g(r),i=x(e,n),o=d.ProjectivePoint.BASE,c=w(t),u=b(s.negate(),i,!1),f=b(o,c,!1),l=a.finalExponentiate(a.mul(f,u));return a.eql(l,a.ONE)},verifyBatch:function(t,e,r,n){if(!e.length)throw new Error("Expected non-empty messages array");if(r.length!==e.length)throw new Error("Pubkey count should equal msg count");const s=w(t),i=e.map((t=>x(t,n))),o=r.map(g);try{const t=[];for(const e of new Set(i)){const r=i.reduce(((t,r,n)=>r===e?t.add(o[n]):t),d.ProjectivePoint.ZERO);t.push(b(r,e,!1))}t.push(b(d.ProjectivePoint.BASE.negate(),s,!1));const e=t.reduce(((t,e)=>a.mul(t,e)),a.ONE),r=a.finalExponentiate(e);return a.eql(r,a.ONE)}catch{return!1}},verifyShortSignature:function(t,e,r,n){const s=w(r),i=y(e,n),o=p.ProjectivePoint.BASE,c=g(t),u=b(i,s,!1),f=b(c,o.negate(),!1),d=a.finalExponentiate(a.mul(f,u));return a.eql(d,a.ONE)},aggregatePublicKeys:function(t){if(!t.length)throw new Error("Expected non-empty array");const e=t.map(g).reduce(((t,e)=>t.add(e)),d.ProjectivePoint.ZERO);return t[0]instanceof d.ProjectivePoint?(e.assertValidity(),e):e.toRawBytes(!0)},aggregateSignatures:function(t){if(!t.length)throw new Error("Expected non-empty array");const e=t.map(w).reduce(((t,e)=>t.add(e)),p.ProjectivePoint.ZERO);return t[0]instanceof p.ProjectivePoint?(e.assertValidity(),e):m.toRawBytes(e)},aggregateShortSignatures:function(t){if(!t.length)throw new Error("Expected non-empty array");const e=t.map(g).reduce(((t,e)=>t.add(e)),d.ProjectivePoint.ZERO);return t[0]instanceof d.ProjectivePoint?(e.assertValidity(),e):h.toRawBytes(e)},millerLoop:c,pairing:b,G1:d,G2:p,Signature:m,ShortSignature:h,fields:{Fr:r,Fp:e,Fp2:n,Fp6:s,Fp12:a},params:{x:t.params.x,r:t.params.r,G1b:t.G1.b,G2b:t.G2.b},utils:u}}({fields:{Fp:Us,Fp2:Zs,Fp6:Ws,Fp12:ca,Fr:Ms},G1:{Fp:Us,h:BigInt("0x396c8c005555e1568c00aaab0000aaab"),Gx:BigInt("0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb"),Gy:BigInt("0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1"),a:Us.ZERO,b:Ns,htfDefaults:{...Ba,m:1,DST:"BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_"},wrapPrivateKey:!0,allowInfinityPoint:!0,isTorsionFree:(t,e)=>{const r=BigInt("0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"),n=new t(Us.mul(e.px,r),e.py,e.pz);return e.multiplyUnsafe(Aa.params.x).negate().multiplyUnsafe(Aa.params.x).equals(n)},clearCofactor:(t,e)=>e.multiplyUnsafe(Aa.params.x).add(e),mapToCurve:t=>{const{x:e,y:r}=pa(Us.create(t[0]));return da(e,r)},fromBytes:t=>{const{compressed:e,infinity:r,sort:n,value:s}=Ta(t);if(48===s.length&&e){const t=Us.ORDER,e=Q(s),a=Us.create(e&Us.MASK);if(r){if(a!==ks)throw new Error("G1: non-empty compressed point at infinity");return{x:ks,y:ks}}const i=Us.add(Us.pow(a,Rs),Us.create(Aa.params.G1b));let o=Us.sqrt(i);if(!o)throw new Error("Invalid compressed G1 point");return o*Ds/t!==BigInt(n)&&(o=Us.neg(o)),{x:Us.create(a),y:Us.create(o)}}if(96!==s.length||e)throw new Error("Invalid point G1, expected 48/96 bytes");{const t=Q(s.subarray(0,Us.BYTES)),e=Q(s.subarray(Us.BYTES));if(r){if(t!==ks||e!==ks)throw new Error("G1: non-empty point at infinity");return Aa.G1.ProjectivePoint.ZERO.toAffine()}return{x:Us.create(t),y:Us.create(e)}}},toBytes:(t,e,r)=>{const n=e.equals(t.ZERO),{x:s,y:a}=e.toAffine();if(r){if(n)return va.slice();const t=Us.ORDER,e=Boolean(a*Ds/t);return Oa(et(s,Us.BYTES),{compressed:!0,sort:e})}if(n){return st(new Uint8Array([64]),new Uint8Array(2*Us.BYTES-1))}return st(et(s,Us.BYTES),et(a,Us.BYTES))},ShortSignature:{fromHex(t){const{infinity:e,sort:r,value:n}=Ta(nt("signatureHex",t,48)),s=Us.ORDER,a=Q(n);if(e)return Aa.G1.ProjectivePoint.ZERO;const i=Us.create(a&Us.MASK),o=Us.add(Us.pow(i,Rs),Us.create(Aa.params.G1b));let c=Us.sqrt(o);if(!c)throw new Error("Invalid compressed G1 point");const u=BigInt(r);c*Ds/s!==u&&(c=Us.neg(c));const f=Aa.G1.ProjectivePoint.fromAffine({x:i,y:c});return f.assertValidity(),f},toRawBytes:t=>Sa(t),toHex:t=>K(Sa(t))}},G2:{Fp:Zs,h:BigInt("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5"),Gx:Zs.fromBigTuple([BigInt("0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"),BigInt("0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e")]),Gy:Zs.fromBigTuple([BigInt("0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801"),BigInt("0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be")]),a:Zs.ZERO,b:Zs.fromBigTuple([Ns,Ns]),hEff:BigInt("0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551"),htfDefaults:{...Ba},wrapPrivateKey:!0,allowInfinityPoint:!0,mapToCurve:t=>{const{x:e,y:r}=la(Zs.fromBigTuple(t));return fa(e,r)},isTorsionFree:(t,e)=>e.multiplyUnsafe(Aa.params.x).negate().equals(wa(t,e)),clearCofactor:(t,e)=>{const r=Aa.params.x;let n=e.multiplyUnsafe(r).negate(),s=wa(t,e),a=e.double();a=Ia(t,a),a=a.subtract(s),s=n.add(s),s=s.multiplyUnsafe(r).negate(),a=a.add(s),a=a.subtract(n);return a.subtract(e)},fromBytes:t=>{const{compressed:e,infinity:r,sort:n,value:s}=Ta(t);if(!e&&!r&&n||!e&&r&&n||n&&r&&e)throw new Error("Invalid encoding flag: "+(224&t[0]));const a=Us.BYTES,i=(t,e,r)=>Q(t.slice(e,r));if(96===s.length&&e){const t=Aa.params.G2b,e=Us.ORDER;if(r){if(s.reduce(((t,e)=>0!==t?e+1:e),0)>0)throw new Error("Invalid compressed G2 point");return{x:Zs.ZERO,y:Zs.ZERO}}const o=i(s,0,a),c=i(s,a,2*a),u=Zs.create({c0:Us.create(c),c1:Us.create(o)}),f=Zs.add(Zs.pow(u,Rs),t);let d=Zs.sqrt(f);const l=d.c1===ks?d.c0*Ds/e:d.c1*Ds/e?Ps:ks;return d=n&&l>0?d:Zs.neg(d),{x:u,y:d}}if(192!==s.length||e)throw new Error("Invalid point G2, expected 96/192 bytes");{if(r){if(s.reduce(((t,e)=>0!==t?e+1:e),0)>0)throw new Error("Invalid uncompressed G2 point");return{x:Zs.ZERO,y:Zs.ZERO}}const t=i(s,0,a),e=i(s,a,2*a),n=i(s,2*a,3*a),o=i(s,3*a,4*a);return{x:Zs.fromBigTuple([e,t]),y:Zs.fromBigTuple([o,n])}}},toBytes:(t,e,r)=>{const{BYTES:n,ORDER:s}=Us,a=e.equals(t.ZERO),{x:i,y:o}=e.toAffine();if(r){if(a)return st(va,et(ks,n));const t=Boolean(o.c1===ks?o.c0*Ds/s:o.c1*Ds/s);return st(Oa(et(i.c1,n),{compressed:!0,sort:t}),et(i.c0,n))}{if(a)return st(new Uint8Array([64]),new Uint8Array(4*n-1));const{re:t,im:e}=Zs.reim(i),{re:r,im:s}=Zs.reim(o);return st(et(e,n),et(t,n),et(s,n),et(r,n))}},Signature:{fromHex(t){const{infinity:e,sort:r,value:n}=Ta(nt("signatureHex",t)),s=Us.ORDER,a=t.length/2;if(48!==a&&96!==a)throw new Error("Invalid compressed signature length, must be 96 or 192");const i=Q(n.slice(0,a)),o=Q(n.slice(a));if(e)return Aa.G2.ProjectivePoint.ZERO;const c=Us.create(i&Us.MASK),u=Us.create(o),f=Zs.create({c0:u,c1:c}),d=Zs.add(Zs.pow(f,Rs),Aa.params.G2b);let l=Zs.sqrt(d);if(!l)throw new Error("Failed to find a square root");const{re:p,im:h}=Zs.reim(l),m=BigInt(r);(h>ks&&h*Ds/s!==m||h===ks&&p*Ds/s!==m)&&(l=Zs.neg(l));const b=Aa.G2.ProjectivePoint.fromAffine({x:f,y:l});return b.assertValidity(),b},toRawBytes:t=>Ea(t),toHex:t=>K(Ea(t))}},params:{x:ea,r:Ms.ORDER},htfDefaults:Ba,hash:o,randomBytes:s}),ka="BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_",Pa="BLS_POP_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_";function Da(t){return Aa.G1.ProjectivePoint.fromHex(t)}function Ra(t){return t.toRawBytes()}function Na(t){return Aa.Signature.fromHex(t)}function _a(t,e,r){return Aa.verify(e,r,t,{DST:Pa})}var Fa,Va=Object.freeze({__proto__:null,PUBLIC_KEY_LENGTH:48,SIGNATURE_LENGTH:96,publicKeyFromBytes:Da,publicKeyToBytes:Ra,secretKeyFromBytes:function(t){return Aa.G1.normPrivateKeyToScalar(t)},secretKeyToBytes:function(t){return ve(t.toString(16))},sign:function(t,e){return Aa.sign(t,e,{DST:ka})},signProofOfPossession:function(t,e){return Aa.sign(t,e,{DST:Pa})},signatureFromBytes:Na,signatureToBytes:function(t){return t.toRawBytes()},verify:function(t,e,r){return Aa.verify(e,r,t,{DST:ka})},verifyProofOfPossession:_a});let Ua=Fa=class{publicKey;signature;_type=Pe.ProofOfPossession;constructor(t,e){this.publicKey=t,this.signature=e;const r=Da(t),n=Na(e);if(r.assertValidity(),n.assertValidity(),!_a(r,n,Ra(r)))throw new Error("Invalid proof of possession")}static fromBytes(t){const e=t.slice(0,48),r=t.slice(48,144),n=t.slice(144);return[new Fa(e,r),n]}toString(){return Be(this.toBytes())}toBytes(){return n(this.publicKey,this.signature)}};var Ma,Ca;Ua=Fa=f([t=>{},d("design:paramtypes",[Uint8Array,Uint8Array])],Ua);let qa=Ma=class{proof;_type=Pe.Signer;constructor(t){this.proof=t}static fromBytes(t,e){const[r,n]=ur(t,[Ua],e);return[new Ma(r),n]}toBytes(t){return fr([this.proof],t)}};qa=Ma=f([t=>{},d("design:paramtypes",[Ua])],qa);let ja=Ca=class{_type=Pe.SignerEmpty;static fromBytes(t,e){const[r]=ur(t,[],e);return[new Ca,r]}toBytes(t){return fr([],t)}};var La;ja=Ca=f([t=>{}],ja);let Ha=La=class extends Kn{baseTx;nodeId;subnetId;subnetAuth;_type=Pe.RemoveSubnetValidatorTx;constructor(t,e,r,n){super(),this.baseTx=t,this.nodeId=e,this.subnetId=r,this.subnetAuth=n}getSubnetID(){return this.subnetId}static fromBytes(t,e){const[r,n,s,a,i]=ur(t,[tn,Ce,Ve,sn],e);return[new La(r,n,s,a),i]}toBytes(t){return n(fr([this.baseTx,this.nodeId,this.subnetId],t),t.PackPrefix(this.subnetAuth))}};var Za;Ha=La=f([t=>{},d("design:paramtypes",[tn,Ce,Ve,Object])],Ha);let Xa=Za=class extends Kn{baseTx;subnetID;subnetAuth;subnetOwners;_type=Pe.TransferSubnetOwnershipTx;constructor(t,e,r,n){super(),this.baseTx=t,this.subnetID=e,this.subnetAuth=r,this.subnetOwners=n}getSubnetID(){return this.subnetID}getSubnetOwners(){return this.subnetOwners}static fromBytes(t,e){const[r,n,s,a,i]=ur(t,[tn,Ve,sn,sn],e);return[new Za(r,n,s,a),i]}toBytes(t){return n(fr([this.baseTx,this.subnetID],t),t.PackPrefix(this.subnetAuth),t.PackPrefix(this.subnetOwners))}};var Ga;Xa=Za=f([t=>{},d("design:paramtypes",[tn,Ve,Object,Object])],Xa);let Ka=Ga=class extends Kn{baseTx;subnetID;assetId;initialSupply;maximumSupply;minConsumptionRate;maxConsumptionRate;minValidatorStake;maxValidatorStake;minStakeDuration;maxStakeDuration;minDelegationFee;minDelegatorStake;maxValidatorWeightFactor;uptimeRequirement;subnetAuth;_type=Pe.TransformSubnetTx;constructor(t,e,r,n,s,a,i,o,c,u,f,d,l,p,h,m){super(),this.baseTx=t,this.subnetID=e,this.assetId=r,this.initialSupply=n,this.maximumSupply=s,this.minConsumptionRate=a,this.maxConsumptionRate=i,this.minValidatorStake=o,this.maxValidatorStake=c,this.minStakeDuration=u,this.maxStakeDuration=f,this.minDelegationFee=d,this.minDelegatorStake=l,this.maxValidatorWeightFactor=p,this.uptimeRequirement=h,this.subnetAuth=m}getSubnetID(){return this.subnetID}static fromBytes(t,e){const[r,n,s,a,i,o,c,u,f,d,l,p,h,m,b,g,y]=ur(t,[tn,Ve,Ve,pr,pr,pr,pr,pr,pr,rr,rr,rr,rr,mr,rr,sn],e);return[new Ga(r,n,s,a,i,o,c,u,f,d,l,p,h,m,b,g),y]}toBytes(t){return n(fr([this.baseTx,this.subnetID,this.assetId,this.initialSupply,this.maximumSupply,this.minConsumptionRate,this.maxConsumptionRate,this.minValidatorStake,this.maxValidatorStake,this.minStakeDuration,this.maxStakeDuration,this.minDelegationFee,this.minDelegatorStake,this.maxValidatorWeightFactor,this.uptimeRequirement],t),t.PackPrefix(this.subnetAuth))}};var $a;Ka=Ga=f([t=>{},d("design:paramtypes",[tn,Ve,Ve,pr,pr,pr,pr,pr,pr,rr,rr,rr,rr,mr,rr,Object])],Ka);let za=$a=class extends Ln{baseTx;_type=Pe.PvmBaseTx;constructor(t){super(),this.baseTx=t}static fromBytes(t,e){const[r,n]=ur(t,[tn],e);return[new $a(r),n]}toBytes(t){return this.baseTx.toBytes(t)}};za=$a=f([t=>{},d("design:paramtypes",[tn])],za);const Ya=new sn([...new Array(5),...Gr,Rr,Fr,Qn,Jn,Gn,ns,as,us,os,es,ds,ps,ms,Ha,Ka,gs,ws,ja,qa,...new Array(4),Xa,za]);let Ja;const Wa=()=>Ja||(Ja=new an,Ja.RegisterCodec(0,Ya),Ja);function Qa(t){switch(t){case"AVM":return kn();case"EVM":return jn();case"PVM":return Wa();default:throw new Error("unknown VM")}}function ti(t){return Qa(t.vm).packCodec(t)}var ei;let ri=ei=class{unsignedTx;credentials;_type=Pe.AvmSignedTx;constructor(t,e){this.unsignedTx=t,this.credentials=e}static fromBytes(t,e){const[r,n,s]=ur(t,[sn,ir(sn)],e);return[new ei(r,n),s]}getCredentials(){return this.credentials}getAllSignatures(){return this.getCredentials().flatMap((t=>t.getSignatures()))}toBytes(){const t=Qa(this.unsignedTx.vm).getCodecForVersion(new wr(0));return n(new wr(0).toBytes(),t.PackPrefix(this.unsignedTx),t.PackPrefixList(this.credentials))}};function ni(t){return t._type===Pe.TransferableOutput}function si(t){return t._type===Pe.TransferableInput}ri=ei=f([t=>{},d("design:paramtypes",[Function,Array])],ri);var ai=Object.freeze({__proto__:null,AvaxTx:er,get BaseTx(){return tn},get SignedTx(){return ri},get TransferableInput(){return Yr},get TransferableOutput(){return Wr},get UTXOID(){return $r},isBaseTx:function(t){return t._type===Pe.BaseTx},isTransferableInput:si,isTransferableOutput:ni});function ii(t){return t._type===Pe.AvmBaseTx}function oi(t){return t._type===Pe.AvmExportTx}function ci(t){return t._type===Pe.AvmImportTx}var ui=Object.freeze({__proto__:null,get BaseTx(){return nn},get CreateAssetTx(){return wn},get ExportTx(){return In},get ImportTx(){return vn},get InitialState(){return gn},get OperationTx(){return An},getAVMManager:kn,isAvmBaseTx:ii,isCreateAssetTx:function(t){return t._type===Pe.CreateAssetTx},isExportTx:oi,isImportTx:ci,isOperationTx:function(t){return t._type===Pe.OperationTx}});function fi(t){return t._type==Pe.EvmExportTx}function di(t){return t._type==Pe.EvmImportTx}function li(t){return di(t)||fi(t)}function pi(t){return!(!fi(t)&&!di(t))}var hi=Object.freeze({__proto__:null,EVMTx:Pn,get ExportTx(){return _n},get ImportTx(){return Cn},get Input(){return Rn},get Output(){return Vn},isEvmTx:li,isExportTx:fi,isImportExportTx:pi,isImportTx:di});function mi(t){return t._type===Pe.PvmBaseTx}function bi(t){return t._type===Pe.AddDelegatorTx}function gi(t){return t._type===Pe.AddPermissionlessDelegatorTx}function yi(t){return t._type===Pe.AddPermissionlessValidatorTx}function wi(t){return t._type===Pe.AddSubnetValidatorTx}function xi(t){return t._type===Pe.AddValidatorTx}function Ii(t){return t._type===Pe.CreateChainTx}function Bi(t){return t._type===Pe.CreateSubnetTx}function vi(t){return t._type===Pe.RemoveSubnetValidatorTx}function Ti(t){return t._type===Pe.TransferSubnetOwnershipTx}function Oi(t){return t._type===Pe.TransformSubnetTx}function Si(t){return t._type===Pe.PvmExportTx}function Ei(t){return t._type===Pe.PvmImportTx}var Ai=Object.freeze({__proto__:null,AbstractSubnetTx:Kn,get AddDelegatorTx(){return Gn},get AddPermissionlessDelegatorTx(){return ws},get AddPermissionlessValidatorTx(){return gs},get AddSubnetValidatorTx(){return Jn},get AddValidatorTx(){return Qn},get AdvanceTimeTx(){return es},get BaseTx(){return za},get CreateChainTx(){return ns},get CreateSubnetTx(){return as},get ExportTx(){return os},get ImportTx(){return us},get ProofOfPossession(){return Ua},get RemoveSubnetValidatorTx(){return Ha},get Signer(){return qa},get SignerEmpty(){return ja},get StakeableLockIn(){return ps},get StakeableLockOut(){return ms},get SubnetValidator(){return zn},get TransferSubnetOwnershipTx(){return Xa},get TransformSubnetTx(){return Ka},get Validator(){return Zn},isAddDelegatorTx:bi,isAddPermissionlessDelegatorTx:gi,isAddPermissionlessValidatorTx:yi,isAddSubnetValidatorTx:wi,isAddValidatorTx:xi,isAdvanceTimeTx:function(t){return t._type===Pe.AdvanceTimeTx},isCreateChainTx:Ii,isCreateSubnetTx:Bi,isEmptySigner:function(t){return t._type===Pe.SignerEmpty},isExportTx:Si,isImportTx:Ei,isPvmBaseTx:mi,isRemoveSubnetValidatorTx:vi,isRewardValidatorTx:function(t){return t._type===Pe.RewardValidatorTx},isSigner:function(t){return t._type===Pe.Signer},isTransferSubnetOwnershipTx:Ti,isTransformSubnetTx:Oi});const ki=1n,Pi=1000n;function Di(t){return Ri(t.toBytes().length)+BigInt(t.getSigIndices().flatMap((t=>t)).length)*Pi+10000n}function Ri(t){return BigInt(t)*ki}class Ni{utxos;constructor(t){this.utxos=t,this.utxos=function(t){const e=t.map((t=>t.ID()));return t.filter(((t,r)=>e.indexOf(t.ID())==r))}(t)}getUTXOs(){return[...this.utxos]}getAssetDict(){const t={};this.utxos.forEach((e=>{const r=e.assetId.toString(),n=t[r]||[];t[r]=[...n,e]}));const e={};for(const r in t)e[r]=new Ni(t[r]);return e}getAssetIDs(){const t=this.utxos.map((t=>t.assetId.toString()));return t.filter(((e,r)=>t.indexOf(e)===r))}push(t){return new Ni([...this.getUTXOs(),t])}getUTXOIDs(){return this.utxos.map((t=>t.ID()))}merge(t){const e=[...this.getUTXOs(),...t.getUTXOs()];return new Ni(e)}getTransferOuts(){const t=this.utxos.filter((t=>Br(t.output)));return new Ni(t)}}function _i(t){return n(t,o(t).subarray(-4))}const Fi=(t,e,r,n)=>{if(t.locktime.value()>r)return;const s=new Set(e.map((t=>t.toString()))),a=t.addrs.reduce(((e,r,a)=>e.size()<t.threshold.value()&&s.has(r.value())?n?.length&&!n.includes(a)?e:e.set(r,a):e),new Vi);return a.size()<t.threshold.value()?void 0:{sigIndicies:Array.from(a.values()),addressMap:a}};class Vi{constructor(t=[]){t.forEach((([t,e])=>{this.set(t,e)}))}storage=new Map;set(t,e){return this.storage.set(t.toHex(),e),this}toJSON(){return Array.from(this.storage.entries())}static fromJSON(t){return new Vi(t.map((([t,e])=>[Re.fromHex(t),e])))}get(t){return this.storage.get(t.toHex())}has(t){return this.storage.has(t.toHex())}size(){return this.storage.size}forEach(t){return this.storage.forEach(((e,r)=>t(e,Re.fromHex(r))))}forEachHex(t,e=!1){return e?Vi.fromJSON([...this.storage.entries()].sort(((t,e)=>t[1]-e[1])).map((([t],e)=>[t,e]))).storage.forEach(t):this.storage.forEach(t)}values(){return this.storage.values()}}class Ui{constructor(t=[]){t.length&&this.push(...t)}storage=[];index={};orderedIndex={};push(...t){t.forEach((t=>{t.forEachHex(((t,e)=>{this.index[e]=this.index[e]??[],this.index[e].push([this.storage.length,t])})),t.forEachHex(((t,e)=>{this.orderedIndex[e]=this.orderedIndex[e]??[],this.orderedIndex[e].push([this.storage.length,t])}),!0),this.storage.push(t)}))}static fromTransferableInputs(t,e,r,n){const s=e.reduce(((t,e)=>t.set(e.utxoId.ID(),e)),new Map),a=t.map(((t,e)=>{const a=s.get(t.utxoID.ID());if(!a)throw new Error("input utxo not found");if(n){const s=Nr(n),i=Fi(a.getOutputOwners(),s,r,t.sigIndicies());if(!i)throw new Error(`input ${e} has no valid owners`);return i.addressMap}const i=t.sigIndicies().map((t=>[a.getOutputOwners().addrs[t],t]));return new Vi(i)}));return new Ui(a)}toJSON(){return this.storage}static fromJSON(t){return new Ui(t.map((t=>Vi.fromJSON(t))))}getAddresses(){return Object.keys(this.index).map((t=>ve(t)))}forEach(t,e=!1){Object.entries(e?this.orderedIndex:this.index).forEach((([e,r])=>{t(r,e)}))}has(t){return t.toHex()in this.index}toArray(){return this.storage}merge(t){t.toArray().forEach((t=>this.push(t)))}getSigIndicesForAddress(t,e=!1){return e?this.orderedIndex[t.toHex()]:this.index[t.toHex()]}}const Mi=t=>pi(t)?fi(t)?[]:t.importedInputs:[],Ci=t=>li(t)?Mi(t):ci(t)||Ei(t)?[...t.baseTx.inputs??[],...t.ins??[]]:t.getInputs(),qi=t=>pi(t)&&fi(t)?t.exportedOutputs:[],ji=t=>{if(li(t))return qi(t);if(oi(t)||Si(t))return[...t.baseTx?.outputs??[],...t.outs??[]];if(xi(t)||bi(t)||yi(t)||gi(t)){const e=[...t.baseTx?.outputs??[],...t.stake??[]];return xi(t)?e.push(t.getRewardsOwner(),t.getRewardsOwner()):bi(t)?e.push(t.getRewardsOwner()):yi(t)?e.push(t.getValidatorRewardsOwner(),t.getDelegatorRewardsOwner()):e.push(t.getDelegatorRewardsOwner()),e}return Bi(t)?[...t.baseTx.outputs,t.getSubnetOwners()]:t?.baseTx?.outputs??[]},Li=(t,e)=>{const r=t.get(e.assetId.toString())??0n,n=si(e)||ni(e)?e.amount():e.amount.value();return t.set(e.assetId.toString(),r+n),t},Hi=t=>{if(fi(t))return t.ins.reduce(Li,new Map);return Ci(t).reduce(Li,new Map)},Zi=t=>{if(di(t))return t.Outs.reduce(Li,new Map);return ji(t).reduce(((t,e)=>ni(e)?Li(t,e):t),new Map)},Xi=t=>{const e=Hi(t),r=Zi(t),n=new Map;for(const[t,s]of e.entries()){const e=r.get(t)??0n;n.set(t,s-e)}return n};var Gi,Ki=Object.freeze({__proto__:null,AddressMap:Vi,AddressMaps:Ui,CCostPerSignature:Pi,CFixedFee:1e4,CTxBytesGas:ki,UtxoSet:Ni,add0x:be,addChecksum:_i,addressesFromBytes:Nr,base58:e,base58check:Ne,bech32ToBytes:m,bufferToBigInt:xe,bufferToHex:Be,bufferToNumber:Ie,bytesCompare:_e,bytesEqual:(t,e)=>t.length===e.length&&0===_e(t,e),calcBytesCost:Ri,concatBytes:n,costCorethTx:Di,format:function(t,e,r){const n=g(e,r);return`${t}${p}${n}`},formatBech32:g,getBurnedAmountByTx:Xi,getInputAmounts:Hi,getManagerForVM:Qa,getOutputAmounts:Zi,getTransferableInputsByEvmTx:Mi,getTransferableInputsByTx:Ci,getTransferableOutputsByEvmTx:qi,getTransferableOutputsByTx:ji,hexToBuffer:ve,isRewardsOwner:Tr,isStakeableLockIn:Or,isStakeableLockOut:vr,isTransferInput:Sr,isTransferOut:Br,packTx:ti,padLeft:Te,parse:h,parseBech32:b,printDeep:t=>{console.log(u.inspect(t,{depth:null,colors:!0}))},printHex:(t,e="")=>{console.log(`name = ${e}`,Be(t))},printJSON:t=>{console.log(JSON.stringify(t,null,2))},strip0x:ge,unpackWithManager:function(t,e){return Qa(t).unpackTransaction(e)},validateBurnedAmount:({unsignedTx:t,context:e,burnedAmount:r,evmBaseFee:n,evmFeeTolerance:s})=>{const a=t.getTx(),i=r??((t,e)=>Xi(t).get(e.avaxAssetID)??0n)(a,e),o=t=>({isValid:i===t,txFee:t});if(pi(a)){if(!n||!s)throw new Error("missing evm fee data");const e=Math.floor(s);if(e<1||e>100)throw new Error("evmFeeTolerance must be [1,100]");const r=n*Di(t),a=r*(100n-BigInt(e))/100n,o=r*(100n+BigInt(e))/100n;return{isValid:i>=a&&i<=o,txFee:i}}if(xi(a))return o(e.addPrimaryNetworkValidatorFee);if(bi(a))return o(e.addPrimaryNetworkDelegatorFee);if(Bi(a))return o(e.createSubnetTxFee);if(Ii(a))return o(e.createBlockchainTxFee);if(wi(a))return o(e.addSubnetValidatorFee);if(Oi(a))return o(e.transformSubnetTxFee);if(yi(a)){return o(a.subnetValidator.subnetId.toString()===qe.toString()?e.addPrimaryNetworkValidatorFee:e.addSubnetValidatorFee)}if(gi(a)){return o(a.subnetValidator.subnetId.toString()===qe.toString()?e.addPrimaryNetworkDelegatorFee:e.addSubnetDelegatorFee)}if(ii(a)||mi(a)||oi(a)||ci(a)||Si(a)||Ei(a)||vi(a)||Ti(a))return o(e.baseTxFee);throw new Error("tx type is not supported")}});let $i=Gi=class{utxoId;assetId;output;_type=Pe.UTXO;constructor(t,e,r){this.utxoId=t,this.assetId=e,this.output=r}static fromBytes(t,e){const[r,n,s,a]=ur(t,[$r,Ve,sn],e);return[new Gi(r,n,s),a]}getOutputOwners(){if(Br(this.output))return this.output.outputOwners;if(vr(this.output))return this.output.getOutputOwners();if(Tr(this.output))return this.output;throw new Error("unable to get output owner")}toBytes(t){return n(fr([this.utxoId,this.assetId],t),t.PackPrefix(this.output))}getAssetId(){return this.assetId.toString()}ID(){return this.utxoId.ID()}};$i=Gi=f([t=>{},d("design:paramtypes",[$r,Ve,Object])],$i);const zi=async({unsignedTx:t,privateKeys:e})=>{const r=t.toBytes();await Promise.all(e.map((async e=>{const n=vs(e);if(t.hasPubkey(n)){const n=await xs(r,e);t.addSignature(n)}})))},Yi="https://api.avax.network";class Ji{url;reqId=0;constructor(t){this.url=t}async callMethod(t,e,r){const n={jsonrpc:"2.0",id:this.reqId++,method:t,params:e},s=await fetch(this.url,{...r,method:"POST",body:JSON.stringify(n),headers:{"Content-Type":"application/json",...r?.headers}}).then((async t=>t.json())).then((t=>t));if(s.error)throw new Error(s.error.message);return s.result}}class Wi{path;base;fetchOptions;rpcProvider;constructor(t=Yi,e,r,n){this.path=e,this.base=r,this.fetchOptions=n,this.rpcProvider=new Ji(t+e)}setFetchOptions(t){this.fetchOptions=t}getMethodName=t=>this.base?`${this.base}.${t}`:t;callRpc=(t,e)=>this.rpcProvider.callMethod(this.getMethodName(t),e,this.fetchOptions)}class Qi extends Wi{path;base;manager;constructor(t=Yi,e,r,n){super(t,e,r),this.path=e,this.base=r,this.manager=n}async getUTXOs(t){const e=await this.callRpc("getUTXOs",{...t,encoding:"hex"}),r=e.utxos.map((t=>this.manager.unpack(ve(t),$i)));return{...e,utxos:r}}issueTx(t){return this.callRpc("issueTx",t)}issueSignedTx(t){return this.issueTx({tx:Be(_i(t.toBytes()))})}}class to extends Qi{getAssetDescription(t){return this.callRpc("getAssetDescription",{assetID:t})}getTx=async t=>{const e=await this.callRpc("getTx",{...t,encoding:"hex"});return this.manager.unpack(ve(e.tx),ri)};getTxJson=t=>this.callRpc("getTx",{...t,encoding:"json"});getTxStatus(t){return this.callRpc("getTxStatus",{includeReason:!0,...t})}getBalance(t){return this.callRpc("getBalance",t)}getAddressTxs(t){return this.callRpc("GetAddressTxs",t)}}class eo extends to{constructor(t){super(t,"/ext/bc/X","avm",kn())}buildGenesis=async t=>await this.callRpc("buildGenesis",t);getAllBalances(t){return this.callRpc("getAllBalances",t)}}const ro=(t,e,r)=>{const n=Nr(e);return t.reduce(((t,e)=>{const{importedInputs:s,inputUTXOs:a,importedAmounts:i}=t,o=e.output;if(!Br(o))return t;const c=Fi(o.outputOwners,n,r);return c?(s.push(Yr.fromUtxoAndSigindicies(e,c.sigIndicies)),a.push(e),i[e.getAssetId()]=(i[e.getAssetId()]??0n)+o.amount(),t):t}),{importedInputs:[],inputUTXOs:[],importedAmounts:{}})},no=(t,e)=>{const r=Ve.compare(t.assetId,e.assetId);if(0!==r)return r;const n=[vr],s=kn().getDefaultCodec(),a=Wa().getDefaultCodec(),i=n.some((e=>e(t.output)))?a:s,o=n.some((t=>t(e.output)))?a:s;return _e(t.toBytes(i),e.toBytes(o))},so=(t,e)=>t.address.value()===e.address.value()?_e(t.assetId.toBytes(),e.assetId.toBytes()):t.address.value().localeCompare(e.address.value()),ao=t=>t.reduce(((t,e)=>(t[e.getAssetId()]=t[e.getAssetId()]??0n,t[e.getAssetId()]+=e.amount(),t)),{}),io=(t,e)=>({minIssuanceTime:BigInt(Math.floor((new Date).getTime()/1e3)),changeAddresses:t,threshold:1,memo:new Uint8Array,locktime:0n,...e});new Fr(new pr(0n),new rr(0),[]),new Ve(new Uint8Array(32));const oo=new Ar(new Uint8Array(Array(65).fill(0)));class co{tx;utxos;addressMaps;credentials;constructor(t,e,r,n){this.tx=t,this.utxos=e,this.addressMaps=r,this.credentials=n||this.tx.getSigIndices().map((t=>new Pr(t.map((()=>oo)))))}toJSON(){const t=Qa(this.tx.vm).getDefaultCodec();return{codecId:Qa(this.tx.vm).getDefaultCodecId(),vm:this.tx.vm,txBytes:Be(this.toBytes()),utxos:this.utxos.map((e=>Be(e.toBytes(t)))),addressMaps:this.addressMaps,credentials:this.credentials}}static fromJSON(t){const e=JSON.parse(t),r=["txBytes","utxos","addressMaps","vm","codecId","credentials"];r.forEach((t=>{if(!e[t])throw new Error(`invalid structure. must have ${r.join(", ")}, missing ${t}`)}));const n=e.vm;if(!ke.includes(n))throw new Error("invalid VM");const s=Qa(n),[a,i]=s.getCodecFromBuffer(ve(e.txBytes)),o=a.UnpackPrefix(i)[0],c=e.utxos.map((t=>$i.fromBytes(ve(t),a)[0])),u=Ui.fromJSON(e.addressMaps),f=e.credentials.map((t=>Pr.fromJSON(t)));return new co(o,c,u,f)}getSigIndices(){return this.tx.getSigIndices()}hasAddress(t){return this.addressMaps.has(t)}hasPubkey(t){return this.hasAddress(new Re(this.publicKeyBytesToAddress(t)))}getAddresses(){return this.addressMaps.getAddresses()}getSigIndicesForAddress(t){const e=this.getSigIndices().some(((t,e)=>{const r=this.credentials[e].toJSON().length;return Math.max(...t)>r-1}));return this.addressMaps.getSigIndicesForAddress(t,e)}getSigIndicesForPubKey(t){const e=this.publicKeyBytesToAddress(t),r=Os(t),n=this.getSigIndicesForAddress(new Re(e)),s=this.getSigIndicesForAddress(new Re(r));return n||s}getInputUtxos(){return this.utxos}toBytes(){return ti(this.tx)}getBlockchainId(){return this.tx.getBlockchainId()}getTx(){return this.tx}getSignedTx(){return new ri(this.tx,this.credentials)}getCredentials(){return this.credentials}addSignatureAt(t,e,r){if(e>=this.getCredentials().length)throw new Error("index out of bounds");this.getCredentials()[e].setSignature(r,t)}addSignature(t){const e=Bs(o(this.toBytes()),t);this.addSignatureForPubKey(t,e)}addSignatureForPubKey(t,e){const r=this.getSigIndicesForPubKey(e);r&&r.forEach((([e,r])=>{this.addSignatureAt(t,e,r)}))}publicKeyBytesToAddress(t){return Ts(t)}hasAllSignatures(){const t=this.credentials.map((t=>t.getSignatures())),e=oo.toString(),r=o(this.toBytes());if(!t.every((t=>t.every((t=>t!==e)))))return!1;let n=!0;return this.addressMaps.forEach((e=>{e.forEach((([e,s])=>{const a=t[e]?.[s];if(!a)throw new Error("error: incorrect structure for credentials");const i=ve(a),o=Bs(r,i);this.hasPubkey(o)||(n=!1)}))}),!0),n}getVM(){return this.tx.getVM()}}const uo=()=>({inputs:[],inputUTXOs:[],stakeOutputs:[],changeOutputs:[],addressMaps:new Ui});function fo(t=new Map,e=new Map,r,n,s,a){const i={amountsToBurn:t,utxos:r,amountsToStake:e,fromAddresses:n,options:s,...uo()},o=[...a,function({amountsToBurn:t,...e}){return t.forEach(((t,e)=>{if(0n!==t)throw new Error(`insufficient funds (Burn Amount): need ${t} more units of ${e} to burn`)})),{amountsToBurn:t,...e}},function({amountsToStake:t,...e}){return t.forEach(((t,e)=>{if(0n!==t)throw new Error(`insufficient funds (Stake Amount): need ${t} more units of ${e} to stake`)})),{amountsToStake:t,...e}},function({inputs:t,...e}){return t.sort(Yr.compare),{inputs:t,...e}},function({changeOutputs:t,...e}){return t.sort(no),{changeOutputs:t,...e}},function({stakeOutputs:t,...e}){return t.sort(no),{stakeOutputs:t,...e}},function({inputs:t,inputUTXOs:e,...r}){return{inputs:t,inputUTXOs:e,...r,addressMaps:Ui.fromTransferableInputs(t,e,s.minIssuanceTime,n.map((t=>t.toBytes())))}}].reduce(((t,e)=>e(function(t){return{...t,amountsToBurn:new Map([...t.amountsToBurn]),amountsToStake:new Map([...t.amountsToStake]),inputs:[...t.inputs],inputUTXOs:[...t.inputUTXOs],stakeOutputs:[...t.stakeOutputs],changeOutputs:[...t.changeOutputs]}}(t))),i),{amountsToBurn:c,amountsToStake:u,fromAddresses:f,options:d,utxos:l,...p}=o;return p}const lo=(...t)=>t.reduce(((t,e)=>e<t?e:t)),po=new Error("No addresses match UTXO owners");function ho(t,e,r,n){const s=t.reduce(((t,s)=>{const a=e(s),i=Fi(a.outputOwners,r,n.minIssuanceTime);return i?[...t,{sigData:i,data:s}]:t}),[]);if(t.length&&!s.length)throw po;return s}const mo=({amountsToBurn:t,utxos:e,options:r,changeOutputs:n,inputUTXOs:s,fromAddresses:a,inputs:i,...o})=>{const c=new Fr(new pr(0n),new rr(r.threshold),Nr(r.changeAddresses));return ho(e.filter((e=>!!t.get(e.assetId.toString()))).filter((t=>!!Br(t.output))),(t=>t.output),a,r).forEach((({sigData:e,data:r})=>{const a=r.output,o=t.get(r.assetId.toString())??0n,u=lo(o,a.amt.value());if(!u)return;t.set(r.assetId.toString(),o-u),i.push(Yr.fromUtxoAndSigindicies(r,e.sigIndicies)),s.push(r);const f=a.amt.value()-u;f>0&&n.push(new Wr(r.assetId,new Cr(new pr(f),c)))})),{utxos:e,fromAddresses:a,options:r,...o,amountsToBurn:t,inputs:i,changeOutputs:n,inputUTXOs:s}},bo=(t,e,r,n)=>tn.fromNative(t.networkID,t.xBlockchainID,e,r,n),go=(t,e,r,n)=>tn.fromNative(t.networkID,t.pBlockchainID,e,r,n);var yo=Object.freeze({__proto__:null,AvaxApi:to,Transaction:tr,UnsignedTx:co,baseTxUnsafeAvm:bo,baseTxUnsafePvm:go});const wo=(t,e,r,n,s,a,i,o)=>{e.sort(no);const c=ao([...e,...r]),u=ao(n);if(!Object.entries(c).every((([t,e])=>u[t]&&u[t]>=e)))throw new Error("Not enough inputs to cover the outputs");return new co(new In(bo(t,r,n,a),Ve.fromString(s),e),i,o)};var xo=Object.freeze({__proto__:null,AVMApi:eo,newBaseTx:function(t,e,r,n,s){const a=Nr(e),i=io(e,s),o=new Map([[t.avaxAssetID,t.baseTxFee]]);n.forEach((t=>{const e=t.assetId.value();o.set(e,(o.get(e)||0n)+t.output.amount())}));const{inputs:c,inputUTXOs:u,changeOutputs:f,addressMaps:d}=fo(o,void 0,r,a,i,[mo]),l=[...n,...f];return l.sort(no),new co(new nn(bo(t,l,c,i.memo)),u,d)},newExportTx:function(t,e,r,n,s,a){const i=Nr(r),o=io(r,a),c=new Map([[t.avaxAssetID,t.baseTxFee]]);s.forEach((t=>{const e=t.assetId.value();c.set(e,(c.get(e)||0n)+t.output.amount())}));const{inputs:u,changeOutputs:f,inputUTXOs:d,addressMaps:l}=fo(c,void 0,n,i,o,[mo]);return s.sort(no),wo(t,s,f,u,e,o.memo,d,l)},newImportTx:function(t,e,r,n,s,a,i=1,o=0n){const c=Nr(s),u=io(s,a),{importedAmounts:f,importedInputs:d,inputUTXOs:l}=ro(r,s,u.minIssuanceTime);if(!d.length)throw new Error("no UTXOs available to import");d.sort(Yr.compare);const p=Ui.fromTransferableInputs(d,r,u.minIssuanceTime,s),h=f[t.avaxAssetID]??0n;let m={inputs:[],inputUTXOs:[],stakeOutputs:[],changeOutputs:[],addressMaps:new Ui};const b=t.baseTxFee,g=t.avaxAssetID;if(h>b)f[g]-=b;else{if(h<b){const t=new Map([[g,b-h]]);m=fo(t,void 0,r,c,u,[mo])}delete f[g]}return l.push(...m.inputUTXOs||[]),p.merge(m.addressMaps||new Ui),Object.entries(f).forEach((([t,e])=>{m.changeOutputs.push(Wr.fromNative(t,e,n,o,i))})),new co(new vn(tn.fromNative(t.networkID,t.xBlockchainID,m.changeOutputs||[],m.inputs||[],u.memo),Ve.fromString(e),d),l,p)}});class Io extends co{hasPubkey(t){const e=new Re(this.publicKeyBytesToAddress(t)),r=new Re(Os(t));return this.hasAddress(e)||this.hasAddress(r)}static fromJSON(t){const e=co.fromJSON(t);return new Io(e.tx,e.utxos,e.addressMaps,e.credentials)}}class Bo extends Wi{baseURL;constructor(t=Yi){super(t,"/ext/info","info"),this.baseURL=t}getNodeVersion(){return this.callRpc("getNodeVersion")}async getNodeId(){return this.callRpc("getNodeID")}getNodeIp(){return this.callRpc("getNodeIP")}getNetworkId(){return this.callRpc("getNetworkID")}getNetworkName(){return this.callRpc("getNetworkName")}getBlockchainId(t){return this.callRpc("getBlockchainID",{alias:t})}peers(t){return this.callRpc("peers",{nodeIDs:t})}isBootstrapped(t){return this.callRpc("peers",{chain:t})}async getTxFee(){const t=await this.callRpc("getTxFee");return{txFee:BigInt(t.txFee),createAssetTxFee:BigInt(t.createAssetTxFee),createSubnetTxFee:BigInt(t.createSubnetTxFee),transformSubnetTxFee:BigInt(t.transformSubnetTxFee),createBlockchainTxFee:BigInt(t.createBlockchainTxFee),addPrimaryNetworkValidatorFee:BigInt(t.addPrimaryNetworkValidatorFee),addPrimaryNetworkDelegatorFee:BigInt(t.addPrimaryNetworkDelegatorFee),addSubnetValidatorFee:BigInt(t.addSubnetValidatorFee),addSubnetDelegatorFee:BigInt(t.addSubnetDelegatorFee)}}uptime(){return this.callRpc("uptime")}getVMs(){return this.callRpc("getVMs")}}var vo=Object.freeze({__proto__:null,getContextFromURI:async(t,e="AVAX")=>{const r=new eo(t),{assetID:n}=await r.getAssetDescription(e),s=new Bo(t),{txFee:a,createAssetTxFee:i,createSubnetTxFee:o,transformSubnetTxFee:c,createBlockchainTxFee:u,addPrimaryNetworkValidatorFee:f,addPrimaryNetworkDelegatorFee:d,addSubnetValidatorFee:l,addSubnetDelegatorFee:p}=await s.getTxFee(),{blockchainID:h}=await s.getBlockchainId("X"),{blockchainID:m}=await s.getBlockchainId("P"),{blockchainID:b}=await s.getBlockchainId("C"),{networkID:g}=await s.getNetworkId();return Object.freeze({xBlockchainID:h,pBlockchainID:m,cBlockchainID:b,avaxAssetID:n,baseTxFee:a,createAssetTxFee:i,createSubnetTxFee:o,transformSubnetTxFee:c,createBlockchainTxFee:u,addPrimaryNetworkValidatorFee:f,addPrimaryNetworkDelegatorFee:d,addSubnetValidatorFee:l,addSubnetDelegatorFee:p,networkID:g,hrp:Je(g)})}});class To extends Wi{constructor(t){super(t,"/ext/bc/C/rpc")}async getBaseFee(){return BigInt(await this.callRpc("eth_baseFee"))}}const Oo=t=>({locktime:0n,threshold:1,...t});function So(t,e,r,n,s,a,i,o,c){return e*Di(Eo(t,r,n,s,a,e,i,o,c))}function Eo(t,e,r,n,s,a,i,o,c){o=o??t.avaxAssetID;const{threshold:u,locktime:f}=Oo(c),d=[];t.avaxAssetID===o?d.push({assetId:t.avaxAssetID,amount:e+a}):(d.push({amount:a,assetId:t.avaxAssetID}),d.push({amount:e,assetId:o}));const l=d.map((({assetId:t,amount:e})=>new Rn(new Re(n),new pr(e),Ve.fromString(t),new pr(i)))),p=[new Wr(Ve.fromString(o),new Cr(new pr(e),new Fr(new pr(f),new rr(u),Nr(s))))];return l.sort(Rn.compare),new Io(new _n(new rr(t.networkID),Ve.fromString(t.cBlockchainID),Ve.fromString(r),l,p),[],new Ui([new Vi([[new Re(n),0]])]))}function Ao(t,e,r,n,s,a=0n,i=t.avaxAssetID){const o=Nr(r),c=new Map;let u=[],f=[],d=0n;const l=[];n.forEach((t=>{const e=t.getAssetId(),r=t.output,n=r.amount();let s=n;i&&a&&d<a&&i===e&&(d+=s,d>a?(s=d-a,d=a):s=0n);const f=Fi(r.outputOwners,o,0n);if(!f)return;const p=new Yr(t.utxoId,t.assetId,Xr.fromNative(n,f.sigIndicies));u.push(p),l.push(t);const h=c.get(e);h&&(s+=h),c.set(e,s)}));for(const[t,r]of c.entries())f.push(new Vn(new Re(e),new pr(r),Ve.fromString(t)));u=u.sort(Yr.compare);const p=Ui.fromTransferableInputs(u,n,0n,r);f=f.sort(so);const h=new Cn(new rr(t.networkID),Ve.fromString(t.cBlockchainID),Ve.fromString(s),u,f);return new Io(h,l,p)}var ko=Object.freeze({__proto__:null,EVMApi:class extends Qi{ethAPI;constructor(t){super(t,"/ext/bc/C/avax","avax",jn()),this.ethAPI=new To(t)}getAtomicTx=async t=>{const e=await this.callRpc("getAtomicTx",{...t,encoding:"hex"});return this.manager.unpack(ve(e.tx),ri)};getBaseFee(){return this.ethAPI.getBaseFee()}getAtomicTxStatus(t){return this.callRpc("getAtomicTxStatus",{txID:t})}},estimateExportCost:So,newExportTx:Eo,newExportTxFromBaseFee:function(t,e,r,n,s,a,i,o,c){return Eo(t,r,n,s,a,So(t,e,r,n,s,a,i,o,c),i,o,c)},newImportTx:Ao,newImportTxFromBaseFee:function(t,e,r,n,s,a=0n,i){const o=function(t,e,r,n,s,a=0n,i){const o=Ao(t,e,r,n,s,a,i),c=Di(o);return a*c}(t,e,r,n,s,a,i);return Ao(t,e,r,n,s,o,i)}});function Po(t,e,r,n){return new Wr(t.assetId,new ms(e.lockTime,new Cr(new pr(n),r.outputOwners)))}function Do({amountsToBurn:t,utxos:e,fromAddresses:r,amountsToStake:n,options:s,changeOutputs:a,inputUTXOs:i,inputs:o,stakeOutputs:c,...u}){return ho(e.filter((t=>{const e=t.output;return!!vr(e)&&s.minIssuanceTime<e.getLocktime()})).map((t=>{const e=t.assetId.value();return{utxo:t,assetId:e,remainingAmountToStake:n.get(e)??0n,lockedOutput:t.output}})).filter((({remainingAmountToStake:t})=>!!t)).filter((({lockedOutput:t})=>{if(!(t.transferOut instanceof Cr))throw new Error("unknown output type");return s.minIssuanceTime<t.lockTime.value()})),(({lockedOutput:t})=>t.transferOut),r,s).forEach((({sigData:t,data:{utxo:e,assetId:r,lockedOutput:s}})=>{const u=s.transferOut,f=n.get(r)??0n;if(!f)return;o.push(function(t,e,r,n){return new Yr(t.utxoId,t.assetId,new ps(e.lockTime,Xr.fromNative(r.amount(),n.sigIndicies)))}(e,s,u,t)),i.push(e);const d=lo(f,u.amt.value());c.push(Po(e,s,u,d)),n.set(r,f-d);const l=u.amount()-d;l>0n&&a.push(Po(e,s,u,l))})),{...u,amountsToBurn:t,utxos:e,fromAddresses:r,amountsToStake:n,options:s,changeOutputs:a,inputUTXOs:i,inputs:o,stakeOutputs:c}}function Ro({amountsToBurn:t,utxos:e,fromAddresses:r,amountsToStake:n,options:s,changeOutputs:a,inputUTXOs:i,inputs:o,stakeOutputs:c,...u}){const f=new Fr(new pr(0n),new rr(1),Nr(s.changeAddresses));return ho(e.filter((t=>{if(Br(t.output))return!0;const e=t.output;return!(!vr(e)||!Br(e.transferOut))&&e.getLocktime()<s.minIssuanceTime})),(t=>Br(t.output)?t.output:t.output.transferOut),r,s).forEach((({sigData:e,data:r})=>{const s=t.get(r.assetId.value())??0n,u=n.get(r.assetId.value())??0n;if(!s&&!u)return;const d=Br(r.output)?r.output:r.output.transferOut;o.push(new Yr(r.utxoId,r.assetId,Xr.fromNative(d.amount(),e.sigIndicies))),i.push(r);const l=lo(s,d.amt.value());t.set(r.assetId.value(),s-l);const p=d.amount()-l,h=lo(u,p);n.set(r.assetId.value(),(n.get(r.assetId.value())??0n)-h),h>0n&&c.push(new Wr(r.assetId,new Cr(new pr(h),f)));const m=p-h;m>0&&a.push(new Wr(r.assetId,new Cr(new pr(m),f)))})),{...u,amountsToBurn:t,utxos:e,fromAddresses:r,amountsToStake:n,options:s,changeOutputs:a,inputUTXOs:i,inputs:o,stakeOutputs:c}}const No=(t,e)=>t.getAssetId()===e.getAssetId()&&(vr(t.output)&&vr(e.output)&&t.output.getStakeableLocktime()===e.output.getStakeableLocktime()&&t.output.getOutputOwners().equals(e.output.getOutputOwners())||Br(t.output)&&Br(e.output)&&t.output.outputOwners.equals(e.output.outputOwners)),_o=(t,e)=>{if(vr(t.output)&&vr(e.output))return new Wr(t.assetId,new ms(t.output.lockTime,new Cr(new pr(t.amount()+e.amount()),t.output.getOutputOwners())));if(Br(t.output)&&Br(e.output))return new Wr(t.assetId,new Cr(new pr(t.amount()+e.amount()),t.output.outputOwners));throw new Error("Calling combine on incompatible TransferableOutputs")},Fo=t=>((t,e,r)=>{const n=[];for(const s of t){let t=!1;for(let a=0;a<n.length;a++){const i=n[a];if(e(i,s)){n[a]=r(i,s),t=!0;break}}t||n.push(s)}return n})(t,No,_o);function Vo({changeOutputs:t,stakeOutputs:e,...r}){return{...r,changeOutputs:Fo(t),stakeOutputs:Fo(e)}}var Uo=Object.freeze({__proto__:null,PVMApi:class extends to{constructor(t){super(t,"/ext/bc/P","platform",Wa())}getAssetDescription(t){return this.callRpc("getAssetDescription",{assetID:t})}getCurrentValidators(t){return this.callRpc("getCurrentValidators",t)}getPendingValidators(t){return this.callRpc("getPendingValidators",t)}async getRewardUTXOs(t){const e=await this.callRpc("getRewardUTXOs",t);return{...e,utxos:e.utxos.map((t=>Wa().unpack(ve(t),$i)))}}async getStake(t){const e=await this.callRpc("getStake",t);return{...e,stakedOutputs:e.stakedOutputs.map((t=>Wa().unpack(ve(t),Wr)))}}getValidatorsAt(t){return this.callRpc("getValidatorsAt",t)}getCurrentSupply(){return this.callRpc("getCurrentSupply")}getMaxStakeAmount(t){return this.callRpc("getMaxStakeAmount",t)}async getBalance(t){const e=await this.callRpc("getBalance",t);return{balance:BigInt(e.balance),unlocked:BigInt(e.unlocked),lockedStakeable:BigInt(e.lockedStakeable),lockedNotStakeable:BigInt(e.lockedNotStakeable),utxoIDs:e.utxoIDs}}getBlockchains(){return this.callRpc("getBlockchains")}getBlockchainStatus(t){return this.callRpc("getBlockchainStatus",{blockchainID:t})}getHeight(){return this.callRpc("getHeight")}getMinStake(){return this.callRpc("getMinStake")}getStakingAssetID(t){return this.callRpc("getStakingAssetID",t)}getSubnets(t){return this.callRpc("getSubnets",t)}getTimestamp(){return this.callRpc("getTimestamp")}getTotalStake(t){return this.callRpc("getTotalStake",{subnetID:t})}getTxStatus(t){return this.callRpc("getTxStatus",t)}sampleValidators(t){return this.callRpc("sampleValidators",t)}validatedBy(t){return this.callRpc("validatedBy",t)}validates(t){return this.callRpc("validates",t)}},newAddDelegatorTx:function(t,e,r,n,s,a,i,o,c,u=1,f=0n){const d=new Map([[t.avaxAssetID,t.addPrimaryNetworkDelegatorFee]]),l=new Map([[t.avaxAssetID,i]]),p=io(r,c),{inputs:h,addressMaps:m,changeOutputs:b,inputUTXOs:g,stakeOutputs:y}=fo(d,l,e,Nr(r),p,[Do,Ro,Vo]),w=new Gn(tn.fromNative(t.networkID,t.pBlockchainID,b,h,p.memo),Zn.fromNative(n,s,a,i),y,Fr.fromNative(o,f,u));return new co(w,g,m)},newAddPermissionlessDelegatorTx:function(t,e,r,n,s,a,i,o,c,u,f=1,d=0n,l){const p=s===qe.toString(),h=p?t.addPrimaryNetworkDelegatorFee:t.addSubnetDelegatorFee,m=l??t.avaxAssetID;if(p&&m!==t.avaxAssetID)throw new Error("Staking asset ID must be AVAX for the primary network.");const b=new Map([[t.avaxAssetID,h]]),g=new Map([[m,o]]),y=io(r,u),{addressMaps:w,changeOutputs:x,inputUTXOs:I,inputs:B,stakeOutputs:v}=fo(b,g,e,Nr(r),y,[Do,Ro,Vo]),T=new ws(tn.fromNative(t.networkID,t.pBlockchainID,x,B,y.memo),zn.fromNative(n,a,i,o,Ve.fromString(s)),v,Fr.fromNative(c,d,f));return new co(T,I,w)},newAddPermissionlessValidatorTx:function(t,e,r,n,s,a,i,o,c,u,f,d,l=1,p=0n,h,m,b){const g=s===qe.toString(),y=g?t.addPrimaryNetworkValidatorFee:t.addSubnetValidatorFee,w=new Map([[t.avaxAssetID,y]]),x=b??t.avaxAssetID;if(g&&x!==t.avaxAssetID)throw new Error("Staking asset ID must be AVAX for the primary network.");const I=new Map([[x,o]]),B=io(r,d),{addressMaps:v,changeOutputs:T,inputUTXOs:O,inputs:S,stakeOutputs:E}=fo(w,I,e,Nr(r),B,[Do,Ro,Vo]),A=new gs(tn.fromNative(t.networkID,t.pBlockchainID,T,S,B.memo),zn.fromNative(n,a,i,o,Ve.fromString(s)),function(t,e){return t&&e?new qa(new Ua(new Uint8Array(t),new Uint8Array(e))):new ja}(h,m),E,Fr.fromNative(c,p,l),Fr.fromNative(u,0n),new rr(f));return new co(A,O,v)},newAddSubnetValidatorTx:function(t,e,r,n,s,a,i,o,c,u){const f=io(r,u),{inputs:d,addressMaps:l,changeOutputs:p,inputUTXOs:h}=fo(new Map([[t.avaxAssetID,t.addSubnetValidatorFee]]),void 0,e,Nr(r),f,[Ro]),m=new Jn(tn.fromNative(t.networkID,t.pBlockchainID,p,d,f.memo),zn.fromNative(n,s,a,i,Ve.fromString(o)),Rr.fromNative(c));return new co(m,h,l)},newAddValidatorTx:function(t,e,r,n,s,a,i,o,c,u,f=1,d=0n){const l=new Map([[t.avaxAssetID,t.addPrimaryNetworkValidatorFee]]),p=new Map([[t.avaxAssetID,i]]),h=io(r,u),{addressMaps:m,changeOutputs:b,inputUTXOs:g,inputs:y,stakeOutputs:w}=fo(l,p,e,Nr(r),h,[Do,Ro,Vo]),x=new Qn(tn.fromNative(t.networkID,t.pBlockchainID,b,y,h.memo),Zn.fromNative(n,s,a,i),w,Fr.fromNative(o,d,f),new rr(c));return new co(x,g,m)},newBaseTx:function(t,e,r,n,s){const a=Nr(e),i=io(e,s),o=new Map([[t.avaxAssetID,t.baseTxFee]]);n.forEach((t=>{const e=t.assetId.value();o.set(e,(o.get(e)||0n)+t.output.amount())}));const{inputs:c,inputUTXOs:u,changeOutputs:f,addressMaps:d}=fo(o,void 0,r,a,i,[Ro,Vo]),l=[...n,...f];return l.sort(no),new co(new za(go(t,l,c,i.memo)),u,d)},newCreateBlockchainTx:function(t,e,r,n,s,a,i,o,c,u){const f=io(r,u),{inputs:d,addressMaps:l,changeOutputs:p,inputUTXOs:h}=fo(new Map([[t.avaxAssetID,t.createBlockchainTxFee]]),void 0,e,Nr(r),f,[Ro]),m=new ns(tn.fromNative(t.networkID,t.pBlockchainID,p,d,f.memo),Ve.fromString(n),new Ir(s),Ve.fromString(a),i.map(Ve.fromString.bind(Ve)),new gr((new TextEncoder).encode(JSON.stringify(o))),Rr.fromNative(c));return new co(m,h,l)},newCreateSubnetTx:function(t,e,r,n,s,a=1,i=0n){const o=io(r,s),{inputs:c,addressMaps:u,changeOutputs:f,inputUTXOs:d}=fo(new Map([[t.avaxAssetID,t.createSubnetTxFee]]),void 0,e,Nr(r),o,[Ro]),l=new as(tn.fromNative(t.networkID,t.pBlockchainID,f,c,o.memo),Fr.fromNative(n,i,a));return new co(l,d,u)},newExportTx:function(t,e,r,n,s,a){const i=Nr(r),o=io(r,a),c=((t,e,r)=>{const n=new Map([[t.avaxAssetID,r]]);return e.forEach((t=>{const e=t.assetId.value();n.set(e,(n.get(e)||0n)+t.output.amount())})),n})(t,s,t.baseTxFee),{inputs:u,changeOutputs:f,addressMaps:d,inputUTXOs:l}=fo(c,void 0,n,i,o,[Ro]);return s.sort(no),new co(new os(new tn(new rr(t.networkID),je,f,u,new gr(o.memo)),Ve.fromString(e),s),l,d)},newImportTx:function(t,e,r,n,s,a,i=1,o=0n){const c=Nr(s),u=io(s,a);r=r.filter((e=>e.assetId.toString()===t.avaxAssetID));const{importedAmounts:f,importedInputs:d,inputUTXOs:l}=ro(r,s,u.minIssuanceTime),p=f[t.avaxAssetID]??0n;d.sort(Yr.compare);const h=Ui.fromTransferableInputs(d,r,u.minIssuanceTime,s);if(!d.length)throw new Error("no UTXOs available to import");let m=[],b=[];if(p<t.baseTxFee){const e=fo(new Map([[t.avaxAssetID,t.baseTxFee-p]]),void 0,r,c,u,[Ro]);m=e.inputs,b=e.changeOutputs}else p>t.baseTxFee&&b.push(Wr.fromNative(t.avaxAssetID,p-t.baseTxFee,n,o,i));return new co(new us(new tn(new rr(t.networkID),je,b,m,new gr(u.memo)),Ve.fromString(e),d),l,h)},newRemoveSubnetValidatorTx:function(t,e,r,n,s,a,i){const o=io(r,i),{inputs:c,addressMaps:u,changeOutputs:f,inputUTXOs:d}=fo(new Map([[t.avaxAssetID,t.baseTxFee]]),void 0,e,Nr(r),o,[Ro]),l=new Ha(tn.fromNative(t.networkID,t.pBlockchainID,f,c,o.memo),Ce.fromString(n),Ve.fromString(s),Rr.fromNative(a));return new co(l,d,u)},newTransferSubnetOwnershipTx:function(t,e,r,n,s,a,i,o=1,c=0n){const u=io(r,i),{inputs:f,addressMaps:d,changeOutputs:l,inputUTXOs:p}=fo(new Map([[t.avaxAssetID,t.baseTxFee]]),void 0,e,Nr(r),u,[Ro]);return new co(new Xa(tn.fromNative(t.networkID,t.pBlockchainID,l,f,u.memo),Ve.fromString(n),Rr.fromNative(s),Fr.fromNative(a,c,o)),p,d)},newTransformSubnetTx:function(t,e,r,n,s,a,i,o,c,u,f,d,l,p,h,m,b,g,y){const w=io(r,y),{inputs:x,addressMaps:I,changeOutputs:B,inputUTXOs:v}=fo(new Map([[t.avaxAssetID,t.transformSubnetTxFee]]),void 0,e,Nr(r),w,[Ro]);return new co(new Ka(tn.fromNative(t.networkID,t.pBlockchainID,B,x,w.memo),Ve.fromString(n),Ve.fromString(s),new pr(a),new pr(i),new pr(o),new pr(c),new pr(u),new pr(f),new rr(d),new rr(l),new rr(p),new rr(h),new mr(ve(m.toString(16))),new rr(b),Rr.fromNative(g)),v,I)}});export{Se as AVM,Re as Address,pr as BigIntPr,mr as Byte,gr as Bytes,yo as Common,vo as Context,Pr as Credential,Ee as EVM,Io as EVMUnsignedTx,Ve as Id,Bo as Info,Rr as Input,rr as Int,jr as MintOperation,Ur as MintOutput,Ce as NodeId,Fr as OutputOwners,Hr as OutputOwnersList,Ae as PVM,wr as Short,Ar as Signature,Ir as Stringpr,Xr as TransferInput,Cr as TransferOutput,Yr as TransferableInput,Wr as TransferableOutput,Gr as TypeRegistry,Pe as TypeSymbols,co as UnsignedTx,$i as Utxo,ke as ValidVMs,zi as addTxSignatures,ai as avaxSerial,xo as avm,ui as avmSerial,Va as bls,ko as evm,hi as evmSerial,Qe as networkIDs,Uo as pvm,Ai as pvmSerial,Ss as secp256k1,Ki as utils};
