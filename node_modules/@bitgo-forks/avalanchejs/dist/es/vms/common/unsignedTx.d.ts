import { SignedTx } from '../../serializable/avax';
import { Utxo } from '../../serializable/avax/utxo';
import type { VM } from '../../serializable/constants';
import { Address } from '../../serializable/fxs/common';
import { Credential } from '../../serializable/fxs/secp256k1';
import { AddressMaps } from '../../utils/addressMap';
import type { Transaction } from './transaction';
export declare class UnsignedTx {
    readonly tx: Transaction;
    readonly utxos: Utxo[];
    readonly addressMaps: AddressMaps;
    credentials: Credential[];
    constructor(tx: Transaction, utxos: Utxo[], addressMaps: AddressMaps, credentials?: Credential[]);
    toJSON(): {
        codecId: import("../..").Short;
        vm: VM;
        txBytes: string;
        utxos: string[];
        addressMaps: AddressMaps;
        credentials: Credential[];
    };
    static fromJSON(jsonString: string): UnsignedTx;
    getSigIndices(): number[][];
    hasAddress(address: Address): boolean;
    hasPubkey(pubKey: Uint8Array): boolean;
    getAddresses(): Uint8Array[];
    getSigIndicesForAddress(address: Address): [number, number][];
    getSigIndicesForPubKey(pubkey: Uint8Array): [number, number][];
    getInputUtxos(): Utxo[];
    toBytes(): Uint8Array;
    getBlockchainId(): string;
    getTx(): Transaction;
    getSignedTx(): SignedTx;
    getCredentials(): Credential[];
    addSignatureAt(sig: Uint8Array, index: number, subIndex: number): void;
    addSignature(sig: Uint8Array): void;
    private addSignatureForPubKey;
    protected publicKeyBytesToAddress(pubKey: Uint8Array): Uint8Array;
    hasAllSignatures(): boolean;
    getVM(): VM;
}
//# sourceMappingURL=unsignedTx.d.ts.map