"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addressToName = exports.nameToAddress = exports.getResolver = exports.RESOLVER_CONTRACT = exports.REGISTRY_CONTRACT = exports.REGISTRY = exports.ADDRESS_ZERO = exports.namehash = void 0;
const sha3_1 = require("@noble/hashes/sha3");
const abi = require("../web3.js");
const P = require("micro-packed");
// No support for IDN names because they are stupid.
function namehash(address) {
    let res = new Uint8Array(32);
    if (!address)
        return res;
    for (let label of address.split('.').reverse())
        res = (0, sha3_1.keccak_256)(P.concatBytes(res, (0, sha3_1.keccak_256)(label)));
    return res;
}
exports.namehash = namehash;
exports.ADDRESS_ZERO = '0x0000000000000000000000000000000000000000';
exports.REGISTRY = '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e';
exports.REGISTRY_CONTRACT = [
    {
        name: 'resolver',
        type: 'function',
        inputs: [{ name: 'node', type: 'bytes32' }],
        outputs: [{ type: 'address' }],
    },
];
exports.RESOLVER_CONTRACT = [
    {
        name: 'addr',
        type: 'function',
        inputs: [{ name: 'node', type: 'bytes32' }],
        outputs: [{ type: 'address' }],
    },
    {
        name: 'name',
        type: 'function',
        inputs: [{ name: 'node', type: 'bytes32' }],
        outputs: [{ type: 'string' }],
    },
];
async function getResolver(net, name) {
    const contract = abi.contract(exports.REGISTRY_CONTRACT, net, exports.REGISTRY);
    const res = await contract.resolver.call(namehash(name));
    return res !== exports.ADDRESS_ZERO ? res : undefined;
}
exports.getResolver = getResolver;
async function nameToAddress(net, name) {
    const resolver = await getResolver(net, name);
    if (!resolver)
        return;
    const contract = abi.contract(exports.RESOLVER_CONTRACT, net, resolver);
    const addr = await contract.addr.call(namehash(name));
    if (addr === exports.ADDRESS_ZERO)
        return;
    return addr;
}
exports.nameToAddress = nameToAddress;
async function addressToName(net, addr) {
    const addrDomain = `${abi.strip0x(addr).toLowerCase()}.addr.reverse`;
    const resolver = await getResolver(net, addrDomain);
    if (!resolver)
        return;
    const contract = abi.contract(exports.RESOLVER_CONTRACT, net, resolver);
    const name = await contract.name.call(namehash(addrDomain));
    if (!name)
        return;
    // From spec: ENS does not enforce accuracy of reverse records -
    // anyone may claim that the name for their address is 'alice.eth'.
    // To be certain the claim is accurate, you must always perform a forward
    // resolution for the returned name and check whether it matches the original address.
    const realAddr = await nameToAddress(net, name);
    if (realAddr !== addr)
        return;
    return name;
}
exports.addressToName = addressToName;
