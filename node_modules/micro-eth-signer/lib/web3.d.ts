import * as P from 'micro-packed';
export type Bytes = Uint8Array;
export type Option<T> = T | undefined;
export type Web3CallArgs = {
    to?: string;
    from?: string;
    data?: string;
    nonce?: string;
    value?: string;
    gas?: string;
    gasPrice?: string;
    tag?: number | 'latest' | 'earliest' | 'pending';
};
export type Web3API = {
    ethCall: (args: Web3CallArgs) => Promise<string>;
    estimateGas: (args: Web3CallArgs) => Promise<bigint>;
};
export declare function add0x(hex: string): string;
export declare function strip0x(hex: string): string;
export declare function omit<T extends object, K extends Extract<keyof T, string>>(obj: T, ...keys: K[]): Omit<T, K>;
export declare function zip<A, B>(a: A[], b: B[]): [A, B][];
export declare const PRECISION = 18;
export declare const Decimal: {
    encode: (from: bigint) => string;
    decode: (to: string) => bigint;
};
type Writable<T> = T extends {} ? {
    -readonly [P in keyof T]: Writable<T[P]>;
} : T;
type ArrLike<T> = Array<T> | ReadonlyArray<T>;
export type Component<T extends string> = {
    readonly name?: string;
    readonly type: T;
};
export type NamedComponent<T extends string> = Component<T> & {
    readonly name: string;
};
export type BaseComponent = Component<string>;
export type Tuple<TC extends ArrLike<Component<string>>> = {
    readonly name?: string;
    readonly type: 'tuple';
    readonly components: TC;
};
type IntIdxType = '' | '8' | '16' | '24' | '32' | '40' | '48' | '56' | '64' | '72' | '80' | '88' | '96' | '104' | '112' | '120' | '128' | '136' | '144' | '152' | '160' | '168' | '176' | '184' | '192' | '200' | '208' | '216' | '224' | '232' | '240' | '248' | '256';
type UintType = `uint${IntIdxType}`;
type IntType = `int${IntIdxType}`;
type NumberType = UintType | IntType;
type ByteIdxType = '' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | '13' | '14' | '15' | '16' | '17' | '18' | '19' | '20' | '21' | '22' | '23' | '24' | '25' | '26' | '27' | '28' | '29' | '30' | '31' | '32';
type ByteType = `bytes${ByteIdxType}`;
type DigitsType = '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
type ThrityDigits = DigitsType | `${'1' | '2' | '3'}${'0' | DigitsType}`;
type TwoDigits = DigitsType | `${DigitsType}${'0' | DigitsType}`;
type ThreeDigits = TwoDigits | `${TwoDigits}${'0' | DigitsType}`;
type ArrType<T extends string> = `${T}[${'' | ThreeDigits}]`;
type Arr2dType<T extends string> = `${T}[${'' | ThrityDigits}][${'' | ThrityDigits}]`;
export type MapTuple<T> = T extends ArrLike<Component<string> & {
    name: string;
}> ? {
    [K in T[number] as K['name']]: MapType<K>;
} : T extends ArrLike<Component<string>> ? {
    [K in keyof T]: T[K] extends BaseComponent ? MapType<T[K]> : unknown;
} : unknown;
export type MapType<T extends BaseComponent> = T extends Component<'string'> ? string : T extends Component<ArrType<'string'>> ? string[] : T extends Component<Arr2dType<'string'>> ? string[][] : T extends Component<'address'> ? string : T extends Component<ArrType<'address'>> ? string[] : T extends Component<Arr2dType<'address'>> ? string[][] : T extends Component<'bool'> ? boolean : T extends Component<ArrType<'bool'>> ? boolean[] : T extends Component<Arr2dType<'bool'>> ? boolean[][] : T extends Component<NumberType> ? bigint : T extends Component<ArrType<NumberType>> ? bigint[] : T extends Component<Arr2dType<NumberType>> ? bigint[][] : T extends Component<ByteType> ? Bytes : T extends Component<ArrType<ByteType>> ? Bytes[] : T extends Component<Arr2dType<ByteType>> ? Bytes[][] : T extends Tuple<Array<Component<string>>> ? MapTuple<T['components']> : unknown;
export type UnmapType<T> = T extends MapType<infer U> ? U : never;
export declare function mapComponent<T extends BaseComponent>(c: T): P.CoderType<MapType<Writable<T>>>;
export type ArgsType<T> = T extends [Component<string>] ? MapType<T[0]> : T extends undefined ? 1 : MapTuple<T>;
export declare function mapArgs<T extends ArrLike<Component<string>>>(args: T): P.CoderType<ArgsType<Writable<T>>>;
export type FunctionType = Component<'function'> & {
    readonly inputs?: ReadonlyArray<Component<string>>;
    readonly outputs?: ReadonlyArray<Component<string>>;
};
export type FunctionWithInputs = FunctionType & {
    inputs: ReadonlyArray<Component<string>>;
};
export type FunctionWithOutputs = FunctionType & {
    outputs: ReadonlyArray<Component<string>>;
};
type ContractMethodDecode<T extends FunctionType, O = ArgsType<T['outputs']>> = T extends FunctionWithOutputs ? {
    decodeOutput: (b: Bytes) => O;
} : {
    decodeOutput: (b: Bytes) => void;
};
type ContractMethodEncode<T extends FunctionType, I = ArgsType<T['inputs']>> = T extends FunctionWithInputs ? {
    encodeInput: (v: I) => Bytes;
} : {
    encodeInput: () => Bytes;
};
type ContractMethodGas<T extends FunctionType, I = ArgsType<T['inputs']>> = T extends FunctionWithInputs ? {
    estimateGas: (v: I) => Promise<bigint>;
} : {
    estimateGas: () => Promise<bigint>;
};
type ContractMethodCall<T extends FunctionType, I = ArgsType<T['inputs']>, O = ArgsType<T['outputs']>> = T extends FunctionWithInputs ? T extends FunctionWithOutputs ? {
    call: (v: I) => Promise<O>;
} : {
    call: (v: I) => Promise<void>;
} : T extends FunctionWithOutputs ? {
    call: () => Promise<O>;
} : {
    call: () => Promise<void>;
};
export type ContractMethod<T extends FunctionType> = ContractMethodEncode<T> & ContractMethodDecode<T>;
export type ContractMethodNet<T extends FunctionType> = ContractMethod<T> & ContractMethodGas<T> & ContractMethodCall<T>;
export type FnArg = {
    readonly type: string;
    readonly name?: string;
    readonly components?: ArrLike<FnArg>;
    readonly inputs?: ArrLike<FnArg>;
    readonly outputs?: ArrLike<FnArg>;
    readonly anonymous?: boolean;
    readonly indexed?: boolean;
};
export type ContractTypeFilter<T> = {
    [K in keyof T]: T[K] extends FunctionType & {
        name: string;
    } ? T[K] : never;
};
export type ContractType<T extends Array<FnArg>, N, F = ContractTypeFilter<T>> = F extends ArrLike<FunctionType & {
    name: string;
}> ? {
    [K in F[number] as K['name']]: N extends Web3API ? ContractMethodNet<K> : ContractMethod<K>;
} : never;
export declare function evSigHash(o: FnArg): string;
export declare function fnSigHash(o: FnArg): string;
export declare function contract<T extends ArrLike<FnArg>>(abi: T, net: Web3API, contract?: string): ContractType<Writable<T>, Web3API>;
export declare function contract<T extends ArrLike<FnArg>>(abi: T, net?: undefined, contract?: string): ContractType<Writable<T>, undefined>;
export type EventType = NamedComponent<'event'> & {
    readonly inputs: ReadonlyArray<Component<string>>;
};
export type ContractEventTypeFilter<T> = {
    [K in keyof T]: T[K] extends EventType ? T[K] : never;
};
export type TopicsValue<T> = {
    [K in keyof T]: T[K] | null;
};
export type EventMethod<T extends EventType> = {
    decode: (topics: string[], data: string) => ArgsType<T['inputs']>;
    topics: (values: TopicsValue<ArgsType<T['inputs']>>) => (string | null)[];
};
export type ContractEventType<T extends Array<FnArg>, F = ContractEventTypeFilter<T>> = F extends ArrLike<EventType> ? {
    [K in F[number] as K['name']]: EventMethod<K>;
} : never;
export declare function events<T extends ArrLike<FnArg>>(abi: T): ContractEventType<Writable<T>>;
export type ContractABI = ReadonlyArray<FnArg & {
    readonly hint?: HintFn;
    readonly hook?: HookFn;
}>;
export type ContractInfo = {
    abi: 'ERC20' | 'ERC721' | ContractABI;
    symbol?: string;
    decimals?: number;
    name?: string;
    price?: number;
};
export type HintOpt = {
    contract?: string;
    amount?: bigint;
    contractInfo?: ContractInfo;
    contracts?: Record<string, ContractInfo>;
};
export type HintFn = (value: unknown, opt: HintOpt) => string;
export type HookFn = (decoder: Decoder, contract: string, info: SignatureInfo, opt: HintOpt) => SignatureInfo;
type SignaturePacker = {
    name: string;
    signature: string;
    packer: P.CoderType<unknown>;
    hint?: HintFn;
    hook?: HookFn;
};
type EventSignatureDecoder = {
    name: string;
    signature: string;
    decoder: (topics: string[], _data: string) => unknown;
    hint?: HintFn;
};
export type SignatureInfo = {
    name: string;
    signature: string;
    value: unknown;
    hint?: string;
};
export declare class Decoder {
    contracts: Record<string, Record<string, SignaturePacker>>;
    sighashes: Record<string, SignaturePacker[]>;
    evContracts: Record<string, Record<string, EventSignatureDecoder>>;
    evSighashes: Record<string, EventSignatureDecoder[]>;
    add(contract: string, abi: ContractABI): void;
    method(contract: string, data: Bytes): string | undefined;
    decode(contract: string, _data: Bytes, opt: HintOpt): SignatureInfo | SignatureInfo[] | undefined;
    decodeEvent(contract: string, topics: string[], data: string, opt: HintOpt): SignatureInfo | SignatureInfo[] | undefined;
}
export {};
//# sourceMappingURL=web3.d.ts.map