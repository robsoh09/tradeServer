/* tslint:disable */
/* eslint-disable */
/**
*/
export class KeygenSession {
  free(): void;
/**
* @param {number} participants
* @param {number} threshold
* @param {number} party_id
* @param {Uint8Array | undefined} [seed]
*/
  constructor(participants: number, threshold: number, party_id: number, seed?: Uint8Array);
/**
* @returns {Uint8Array}
*/
  toBytes(): Uint8Array;
/**
* @param {Uint8Array} bytes
* @returns {KeygenSession}
*/
  static fromBytes(bytes: Uint8Array): KeygenSession;
/**
* @param {Keyshare} oldshare
* @param {Uint8Array | undefined} [seed]
* @returns {KeygenSession}
*/
  static initKeyRotation(oldshare: Keyshare, seed?: Uint8Array): KeygenSession;
/**
* @param {Keyshare} oldshare
* @param {Uint8Array} lost_shares
* @param {Uint8Array | undefined} [seed]
* @returns {KeygenSession}
*/
  static initKeyRecovery(oldshare: Keyshare, lost_shares: Uint8Array, seed?: Uint8Array): KeygenSession;
/**
* @param {number} participants
* @param {number} threshold
* @param {number} party_id
* @param {Uint8Array} pk
* @param {Uint8Array} lost_shares
* @param {Uint8Array | undefined} [seed]
* @returns {KeygenSession}
*/
  static initLostShareRecovery(participants: number, threshold: number, party_id: number, pk: Uint8Array, lost_shares: Uint8Array, seed?: Uint8Array): KeygenSession;
/**
* @returns {Error | undefined}
*/
  error(): Error | undefined;
/**
* Finish key generation session and return resulting key share.
* This nethod consumes the session and deallocates it in any
* case, even if the session is not finished and key share is
* not avialable or an error occured before.
* @returns {Keyshare}
*/
  keyshare(): Keyshare;
/**
* @returns {Message}
*/
  createFirstMessage(): Message;
/**
* @returns {Uint8Array}
*/
  calculateChainCodeCommitment(): Uint8Array;
/**
* @param {(Message)[]} msgs
* @param {Array<any> | undefined} [commitments]
* @param {Uint8Array | undefined} [seed]
* @returns {(Message)[]}
*/
  handleMessages(msgs: (Message)[], commitments?: Array<any>, seed?: Uint8Array): (Message)[];
}
/**
*/
export class Keyshare {
  free(): void;
/**
* Create an instance of keyshare from passed array of bytes.
* @param {Uint8Array} bytes
* @returns {Keyshare}
*/
  static fromBytes(bytes: Uint8Array): Keyshare;
/**
* Serialize keyshare into array of bytes.
* @returns {Uint8Array}
*/
  toBytes(): Uint8Array;
/**
* Depricated method, the method does nothing.
* It exists for backward compatibility only
* @param {Keyshare} _oldshare
*/
  finishKeyRotation(_oldshare: Keyshare): void;
/**
*/
  readonly participants: number;
/**
*/
  readonly partyId: number;
/**
*/
  readonly publicKey: Uint8Array;
/**
*/
  readonly threshold: number;
}
/**
*/
export class Message {
  free(): void;
/**
* @param {Uint8Array} payload
* @param {number} from
* @param {number | undefined} [to]
*/
  constructor(payload: Uint8Array, from: number, to?: number);
/**
* @returns {Message}
*/
  clone(): Message;
/**
* Source party ID
*/
  from_id: number;
/**
* Payload
*/
  readonly payload: Uint8Array;
/**
* Destination party ID or undefined for broadcast messages
*/
  to_id?: number;
}
/**
*/
export class SignSession {
  free(): void;
/**
* Create a new session.
* @param {Keyshare} keyshare
* @param {string} chain_path
* @param {Uint8Array | undefined} [seed]
*/
  constructor(keyshare: Keyshare, chain_path: string, seed?: Uint8Array);
/**
* Serialize session into array of bytes.
* @returns {Uint8Array}
*/
  toBytes(): Uint8Array;
/**
* Deserialize session from array of bytes.
* @param {Uint8Array} bytes
* @returns {SignSession}
*/
  static fromBytes(bytes: Uint8Array): SignSession;
/**
* Return an error message, if any.
* @returns {Error | undefined}
*/
  error(): Error | undefined;
/**
* Create a fist message and change session state from Init to WaitMg1.
* @returns {Message}
*/
  createFirstMessage(): Message;
/**
* Handle a batch of messages.
* Decode, process and return an array messages to send to other parties.
* @param {(Message)[]} msgs
* @param {Uint8Array | undefined} [seed]
* @returns {(Message)[]}
*/
  handleMessages(msgs: (Message)[], seed?: Uint8Array): (Message)[];
/**
* The session contains a "pre-signature".
* Returns a last message.
* @param {Uint8Array} message_hash
* @returns {Message}
*/
  lastMessage(message_hash: Uint8Array): Message;
/**
* Combine last messages and return signature as [R, S].
* R, S are 32 byte UintArray.
*
* This method consumes the session and deallocates all
* internal data.
* @param {(Message)[]} msgs
* @returns {Array<any>}
*/
  combine(msgs: (Message)[]): Array<any>;
}
