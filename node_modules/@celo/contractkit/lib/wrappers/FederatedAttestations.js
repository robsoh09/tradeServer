"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.FederatedAttestationsWrapper = void 0;
var BaseWrapper_1 = require("./BaseWrapper");
var FederatedAttestationsWrapper = /** @class */ (function (_super) {
    __extends(FederatedAttestationsWrapper, _super);
    function FederatedAttestationsWrapper() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * @notice Returns identifiers mapped to `account` by signers of `trustedIssuers`
         * @param account Address of the account
         * @param trustedIssuers Array of n issuers whose identifier mappings will be used
         * @return countsPerIssuer Array of number of identifiers returned per issuer
         * @return identifiers Array (length == sum([0])) of identifiers
         * @dev Adds identifier info to the arrays in order of provided trustedIssuers
         * @dev Expectation that only one attestation exists per (identifier, issuer, account)
         */
        _this.lookupIdentifiers = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.lookupIdentifiers);
        /**
         * @notice Returns info about attestations for `identifier` produced by
         *    signers of `trustedIssuers`
         * @param identifier Hash of the identifier
         * @param trustedIssuers Array of n issuers whose attestations will be included
         * @return countsPerIssuer Array of number of attestations returned per issuer
         *          For m (== sum([0])) found attestations:
         * @return accounts Array of m accounts
         * @return signers Array of m signers
         * @return issuedOns Array of m issuedOns
         * @return publishedOns Array of m publishedOns
         * @dev Adds attestation info to the arrays in order of provided trustedIssuers
         * @dev Expectation that only one attestation exists per (identifier, issuer, account)
         */
        _this.lookupAttestations = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.lookupAttestations);
        /**
         * @notice Validates the given attestation and signature
         * @param identifier Hash of the identifier to be attested
         * @param issuer Address of the attestation issuer
         * @param account Address of the account being mapped to the identifier
         * @param issuedOn Time at which the issuer issued the attestation in Unix time
         * @param signer Address of the signer of the attestation
         * @param v The recovery id of the incoming ECDSA signature
         * @param r Output value r of the ECDSA signature
         * @param s Output value s of the ECDSA signature
         * @dev Throws if attestation has been revoked
         * @dev Throws if signer is not an authorized AttestationSigner of the issuer
         */
        _this.validateAttestationSig = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.validateAttestationSig);
        /**
         * @return keccak 256 of abi encoded parameters
         */
        _this.getUniqueAttestationHash = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.getUniqueAttestationHash);
        /**
         * @notice Registers an attestation directly from the issuer
         * @param identifier Hash of the identifier to be attested
         * @param account Address of the account being mapped to the identifier
         * @param issuedOn Time at which the issuer issued the attestation in Unix time
         * @dev Attestation signer and issuer in storage is set to msg.sender
         * @dev Throws if an attestation with the same (identifier, issuer, account) already exists
         */
        _this.registerAttestationAsIssuer = (0, BaseWrapper_1.proxySend)(_this.connection, _this.contract.methods.registerAttestationAsIssuer);
        /**
         * @notice Registers an attestation with a valid signature
         * @param identifier Hash of the identifier to be attested
         * @param issuer Address of the attestation issuer
         * @param account Address of the account being mapped to the identifier
         * @param issuedOn Time at which the issuer issued the attestation in Unix time
         * @param signer Address of the signer of the attestation
         * @param v The recovery id of the incoming ECDSA signature
         * @param r Output value r of the ECDSA signature
         * @param s Output value s of the ECDSA signature
         * @dev Throws if an attestation with the same (identifier, issuer, account) already exists
         */
        _this.registerAttestation = (0, BaseWrapper_1.proxySend)(_this.connection, _this.contract.methods.registerAttestation);
        /**
         * @notice Revokes an attestation
         * @param identifier Hash of the identifier to be revoked
         * @param issuer Address of the attestation issuer
         * @param account Address of the account mapped to the identifier
         * @dev Throws if sender is not the issuer, signer, or account
         */
        _this.revokeAttestation = (0, BaseWrapper_1.proxySend)(_this.connection, _this.contract.methods.revokeAttestation);
        /**
         * @notice Revokes attestations [identifiers <-> accounts] from issuer
         * @param issuer Address of the issuer of all attestations to be revoked
         * @param identifiers Hash of the identifiers
         * @param accounts Addresses of the accounts mapped to the identifiers
         *   at the same indices
         * @dev Throws if the number of identifiers and accounts is not the same
         * @dev Throws if sender is not the issuer or currently registered signer of issuer
         * @dev Throws if an attestation is not found for identifiers[i] <-> accounts[i]
         */
        _this.batchRevokeAttestations = (0, BaseWrapper_1.proxySend)(_this.connection, _this.contract.methods.batchRevokeAttestations);
        return _this;
    }
    return FederatedAttestationsWrapper;
}(BaseWrapper_1.BaseWrapper));
exports.FederatedAttestationsWrapper = FederatedAttestationsWrapper;
//# sourceMappingURL=FederatedAttestations.js.map