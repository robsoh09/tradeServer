import type * as t from 'io-ts';
declare type PossiblyUndefinedKeys<T> = {
    [K in keyof T]: undefined extends T[K] ? K : never;
}[keyof T];
export declare type PossiblyUndefinedProps<T extends t.Props> = {
    [K in keyof T]: undefined extends t.TypeOf<T[K]> ? K : never;
}[keyof T];
declare type Optionalized<T> = Simplify<Omit<T, PossiblyUndefinedKeys<T>> & Partial<Pick<T, PossiblyUndefinedKeys<T>>>>;
export declare type OptionalProps<Props extends t.Props> = Pick<Props, PossiblyUndefinedProps<Props>>;
export declare type RequiredProps<Props extends t.Props> = Omit<Props, PossiblyUndefinedProps<Props>>;
export declare type OptionalizedC<Props extends t.Props> = t.IntersectionC<[
    t.TypeC<RequiredProps<Props>>,
    t.PartialC<OptionalProps<Props>>
]>;
export declare type NestedProps = {
    [K: string]: t.Props;
};
export declare type NestedType<Props extends NestedProps> = {
    [K in keyof Props]: Optionalized<t.TypeOfProps<Props[K]>>;
};
export declare type NestedOutputType<Props extends NestedProps> = {
    [K in keyof Props]: Optionalized<t.OutputOfProps<Props[K]>>;
};
export declare type Flattened<T> = UnionToIntersection<T[keyof T]>;
declare type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;
export declare type Simplify<T> = T extends unknown ? {
    [K in keyof T]: T[K];
} : never;
export {};
//# sourceMappingURL=utils.d.ts.map